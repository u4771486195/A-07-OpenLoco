nullptr) { return T{}; } T value; std::memcpy(&value, args, sizeof(T)); args += sizeof(T); return value; } template<typename T> void skip() { if (args == nullptr) { return; } args += sizeof(T); } template<typename T> void push() { args -= sizeof(T); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/Formatting.cpp ```cpp #include "Formatting.h" #include "Config.h" #include "Date.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Logging.h" #include "Objects/CurrencyObject.h" #include "Objects/ObjectManager.h" #include "StringBuffer.h" #include "StringIds.h" #include "StringManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <cassert> #include <cmath> #include <cstring> #include <fmt/core.h> #include <map> #include <stdexcept> using namespace OpenLoco::Interop; using namespace OpenLoco::Diagnostics; namespace OpenLoco::StringManager { static const std::map<int32_t, StringId> kDayToString = { { 1, StringIds::day_1st }, { 2, StringIds::day_2nd }, { 3, StringIds::day_3rd }, { 4, StringIds::day_4th }, { 5, StringIds::day_5th }, { 6, StringIds::day_6th }, { 7, StringIds::day_7th }, { 8, StringIds::day_8th }, { 9, StringIds::day_9th }, { 10, StringIds::day_10th }, { 11, StringIds::day_11th }, { 12, StringIds::day_12th }, { 13, StringIds::day_13th }, { 14, StringIds::day_14th }, { 15, StringIds::day_15th }, { 16, StringIds::day_16th }, { 17, StringIds::day_17th }, { 18, StringIds::day_18th }, { 19, StringIds::day_19th }, { 20, StringIds::day_20th }, { 21, StringIds::day_21st }, { 22, StringIds::day_22nd }, { 23, StringIds::day_23rd }, { 24, StringIds::day_24th }, { 25, StringIds::day_25th }, { 26, StringIds::day_26th }, { 27, StringIds::day_27th }, { 28, StringIds::day_28th }, { 29, StringIds::day_29th }, { 30, StringIds::day_30th }, { 31, StringIds::day_31st }, }; static const std::map<MonthId, std::pair<StringId, StringId>> kMonthToStringMap = { { MonthId::january, { StringIds::month_short_january, StringIds::month_long_january } }, { MonthId::february, { StringIds::month_short_february, StringIds::month_long_february } }, { MonthId::march, { StringIds::month_short_march, StringIds::month_long_march } }, { MonthId::april, { StringIds::month_short_april, StringIds::month_long_april } }, { MonthId::may, { StringIds::month_short_may, StringIds::month_long_may } }, { MonthId::june, { StringIds::month_short_june, StringIds::month_long_june } }, { MonthId::july, { StringIds::month_short_july, StringIds::month_long_july } }, { MonthId::august, { StringIds::month_short_august, StringIds::month_long_august } }, { MonthId::september, { StringIds::month_short_september, StringIds::month_long_september } }, { MonthId::october, { StringIds::month_short_october, StringIds::month_long_october } }, { MonthId::november, { StringIds::month_short_november, StringIds::month_long_november } }, { MonthId::december, { StringIds::month_short_december, StringIds::month_long_december } }, }; std::pair<StringId, StringId> monthToString(MonthId month) { return kMonthToStringMap.find(month)->second; } static void formatString(StringBuffer& buffer, StringId id); // 0x00495F35 static void formatInt32Grouped(int32_t value, StringBuffer& buffer) { fmt::format_to(std::back_inserter(buffer), std::locale(), "{:L}", value); } // 0x00495E2A static void formatInt32Ungrouped(int32_t value, StringBuffer& buffer) { fmt::format_to(std::back_inserter(buffer), "{}", value); } // 0x00496052 static void formatInt48Grouped(uint64_t value, StringBuffer& buffer, uint8_t separator) { fmt::format_to(std::back_inserter(buffer), std::locale(), "{:L}", value * static_cast<uint64_t>(std::pow(10, separator))); } // 0x004963FC static void formatShortWithOneDecimal(int16_t value, StringBuffer& buffer) { fmt::format_to(std::back_inserter(buffer), std::locale(), "{:L}", value / 10); fmt::format_to(std::back_inserter(buffer), ".{}", value % 10); } // 0x004962F1 static void formatIntWithTwoDecimals(int32_t value, StringBuffer& buffer) { fmt::format_to(std::back_inserter(buffer), std::locale(), "{:L}", value / 100); fmt::format_to(std::back_inserter(buffer), ".{:02}", value % 100); } // 0x00495D09 static void formatDateDMYFull(uint32_t totalDays, StringBuffer& buffer) { auto date = calcDate(totalDays); StringId dayString = kDayToString.find(date.day)->second; formatString(buffer, dayString); buffer.append(' '); StringId monthString = monthToString(date.month).second; formatString(buffer, monthString); buffer.append(' '); formatInt32Ungrouped(date.year, buffer); } // 0x00495D77 static void formatDateMYFull(uint32_t totalDays, StringBuffer& buffer) { auto date = calcDate(totalDays); StringId monthString = monthToString(date.month).second; formatString(buffer, monthString); buffer.append(' '); formatInt32Ungrouped(date.year, buffer); } // 0x00495DC7 static void formatDateMYAbbrev(uint32_t totalDays, StringBuffer& buffer) { auto date = calcDate(totalDays); StringId monthString = monthToString(date.month).second; formatString(buffer, monthString); buffer.append(' '); formatInt32Ungrouped(date.year, buffer); } // 0x00495DC7 static void formatRawDateMYAbbrev(uint32_t totalDays, StringBuffer& buffer) { auto month = static_cast<MonthId>(totalDays % 12); StringId monthString = monthToString(month).first; formatString(buffer, monthString); buffer.append(' '); formatInt32Ungrouped(totalDays / 12, buffer); } static void formatStringPart(StringBuffer& buffer, const char* sourceStr); static void formatCurrency(int64_t value, StringBuffer& buffer) { if (value < 0) { buffer.append('-'); value = -value; } const CurrencyObject* currency = ObjectManager::get<CurrencyObject>(); int64_t localisedValue = value * (1ULL << currency->factor); const char* prefixSymbol = getString(currency->prefixSymbol); formatStringPart(buffer, prefixSymbol); formatInt48Grouped(localisedValue, buffer, currency->separator); const char* suffixSymbol = getString(currency->suffixSymbol); formatStringPart(buffer, suffixSymbol); } static void formatStringImpl(StringBuffer& buffer, StringId id, FormatArgumentsView& args); constexpr uint32_t hpTokW(uint32_t hp) { // vanilla conversion ratio is 764 / 1024, or 0.74609375 return hp * 0.74609375; } static_assert(0 == hpTokW(0)); static_assert(0 == hpTokW(1)); static_assert(1 == hpTokW(2)); static_assert(920 == hpTokW(1234)); static_assert(48895 == hpTokW(65535)); // Loco string argument safe strlen size_t locoStrlen(const char* buffer) { if (buffer == nullptr) { return 0; } auto* ptr = buffer; while (*ptr != '\0') { const auto ch = *ptr++; if (ch >= ControlCodes::oneArgBegin && ch < ControlCodes::oneArgEnd) { ptr++; } else if (ch >= ControlCodes::twoArgBegin && ch < ControlCodes::twoArgEnd) { ptr += 2; } else if (ch >= ControlCodes::fourArgBegin && ch < ControlCodes::fourArgEnd) { ptr += 4; } } return ptr - buffer; } // Loco string argument safe strlen_s size_t locoStrlenS(const char* buffer, std::size_t size) { if (buffer == nullptr || size == 0) { return 0; } auto* ptr = buffer; std::size_t i = 0; while (*ptr != '\0' && i < size) { i++; const auto ch = *ptr++; if (ch >= ControlCodes::oneArgBegin && ch < ControlCodes::oneArgEnd) { i += 1; if (i > size) { return i - 2; // Ignore the Control Code and Arg } ptr++; } else if (ch >= ControlCodes::twoArgBegin && ch < ControlCodes::twoArgEnd) { i += 2; if (i > size) { return i - 3; // Ignore the Control Code and Arg } ptr += 2; } else if (ch >= ControlCodes::fourArgBegin && ch < ControlCodes::fourArgEnd) { i += 4; if (i > size) { return i - 5; // Ignore the Control Code and Arg } ptr += 4; } } return i; } char* locoStrcpy(char* dest, const char* src) { if (src == nullptr) { return dest; } std::copy(src, src + locoStrlen(src) + 1, dest); return dest; } char* locoStrcpyS(char* dest, std::size_t destSize, const char* src, std::size_t srcSize) { if (src == nullptr) { return dest; } auto size = locoStrlenS(src, std::min(destSize, srcSize + 1)); std::copy(src, src + size, dest); dest[size] = '\0'; return dest; } static void formatStringPart(StringBuffer& buffer, const char* sourceStr, FormatArgumentsView& args) { while (true) { uint8_t ch = *sourceStr; if (ch == 0) { return; } else if (ch <= 4) { buffer.appendData(sourceStr, 2); sourceStr += 2; } else if (ch <= 16) { buffer.appendData(sourceStr, 1); sourceStr += 1; } else if (ch <= 22) { buffer.appendData(sourceStr, 3); sourceStr += 3; } else if (ch <= 0x1F) { buffer.appendData(sourceStr, 5); sourceStr += 5; } else if (ch < 0x7B || ch >= 0x90) { buffer.append(ch); sourceStr += 1; } else { sourceStr++; switch (ch) { case ControlCodes::int32_grouped: { int32_t value = args.pop<int32_t>(); formatInt32Grouped(value, buffer); break; } case ControlCodes::int32_ungrouped: { int32_t value = args.pop<int32_t>(); formatInt32Ungrouped(value, buffer); break; } case ControlCodes::int16_decimals: { int16_t value = args.pop<int16_t>(); formatShortWithOneDecimal(value, buffer); break; } case ControlCodes::int32_decimals: { int32_t value = args.pop<int32_t>(); formatIntWithTwoDecimals(value, buffer); break; } case ControlCodes::int16_grouped: { int16_t value = args.pop<int16_t>(); formatInt32Grouped(value, buffer); break; } case ControlCodes::uint16_ungrouped: { int32_t value = args.pop<uint16_t>(); formatInt32Ungrouped(value, buffer); break; } case ControlCodes::currency32: { int32_t value = args.pop<uint32_t>(); formatCurrency(value, buffer); break; } case ControlCodes::currency48: { uint32_t valueLow = args.pop<uint32_t>(); int32_t valueHigh = args.pop<int16_t>(); int64_t value = (valueHigh * (1ULL << 32)) | valueLow; formatCurrency(value, buffer); break; } case ControlCodes::stringidArgs: { StringId id = args.pop<StringId>(); formatStringImpl(buffer, id, args); break; } case ControlCodes::stringidStr: { StringId id = *(StringId*)sourceStr; sourceStr += 2; formatStringImpl(buffer, id, args); break; } case ControlCodes::string_ptr: { const char* str = args.pop<const char*>(); buffer.append(str); break; } case ControlCodes::date: { char modifier = *sourceStr; uint32_t totalDays = args.pop<uint32_t>(); sourceStr++; switch (modifier) { case DateModifier::dmy_full: formatDateDMYFull(totalDays, buffer); break; case DateModifier::my_full: formatDateMYFull(totalDays, buffer); break; case DateModifier::my_abbr: formatDateMYAbbrev(totalDays, buffer); break; case DateModifier::raw_my_abbr: formatRawDateMYAbbrev(totalDays, buffer); break; default: throw Exception::OutOfRange("formatString: unexpected modifier: " + std::to_string((uint8_t)modifier)); } break; } case ControlCodes::velocity: { auto measurementFormat = Config::get().measurementFormat; int32_t value = args.pop<int16_t>(); const char* unit; if (measurementFormat == Config::MeasurementFormat::imperial) { unit = getString(StringIds::unit_mph); } else { unit = getString(StringIds::unit_kmh); value = std::round(value * 1.609375); } formatInt32Grouped(value, buffer); buffer.append(unit); break; } case ControlCodes::pop16: args.skip<uint16_t>(); break; case ControlCodes::push16: args.push<uint16_t>(); break; case ControlCodes::timeMS: throw Exception::RuntimeError("Unimplemented format string: 15"); case ControlCodes::timeHM: throw Exception::RuntimeError("Unimplemented format string: 16"); case ControlCodes::distance: { uint32_t value = args.pop<uint16_t>(); auto measurementFormat = Config::get().measurementFormat; const char* unit; if (measurementFormat == Config::MeasurementFormat::imperial) { unit = getString(StringIds::unit_ft); value = std::round(value * 3.28125); } else { unit = getString(StringIds::unit_m); } formatInt32Grouped(value, buffer); buffer.append(unit); break; } case ControlCodes::height: { int32_t value = args.pop<int16_t>(); bool showHeightAsUnits = (Config::get().showHeightAsUnits); auto measurementFormat = Config::get().measurementFormat; const char* unit; if (showHeightAsUnits) { unit = getString(StringIds::unit_units); } else if (measurementFormat == Config::MeasurementFormat::imperial) { unit = getString(StringIds::unit_ft); value *= 16; } else { unit = getString(StringIds::unit_m); value *= 5; } formatInt32Grouped(value, buffer); buffer.append(unit); break; } case ControlCodes::power: { uint32_t value = args.pop<uint16_t>(); auto measurementFormat = Config::get().measurementFormat; const char* unit; if (measurementFormat == Config::MeasurementFormat::imperial) { unit = getString(StringIds::unit_hp); } else { unit = getString(StringIds::unit_kW); value = hpTokW(value); } formatInt32Grouped(value, buffer); buffer.append(unit); break; } case ControlCodes::inlineSpriteArgs: { uint32_t value = args.pop<uint32_t>(); buffer.append(static_cast<char>(ControlCodes::inlineSpriteStr)); buffer.appendData(&value, sizeof(value)); break; } } } } } static void formatStringPart(StringBuffer& buffer, const char* sourceStr) { auto wrapped = FormatArgumentsView(); formatStringPart(buffer, sourceStr, wrapped); } // 0x004958C6 static void formatStringImpl(StringBuffer& buffer, StringId id, FormatArgumentsView& args) { if (id < kUserStringsStart) { const char* sourceStr = getString(id); if (sourceStr == nullptr) { buffer.format(std::locale(), "(missing string id: {})", id); Logging::warn("formatString: nullptr for string id: {}", id); return; } formatStringPart(buffer, sourceStr, args); } else if (id < kUserStringsEnd) { id -= kUserStringsStart; args.skip<uint16_t>(); const char* sourceStr = getUserString(id); buffer.append(sourceStr, kUserStringSize); } else if (id < kTownNamesEnd) { id -= kTownNamesStart; const auto townId = TownId(args.pop<uint16_t>()); auto town = TownManager::get(townId); // TODO: Clean this up once we have only FormatArguments. FormatArgumentsBuffer buf; auto fmt = FormatArguments(buf); fmt.push(town->name); auto fmtView = FormatArgumentsView(fmt); formatStringImpl(buffer, id, fmtView); } else if (id == kTownNamesEnd) { const auto townId = TownId(args.pop<uint16_t>()); auto town = TownManager::get(townId); formatString(buffer, town->name); } else { buffer.format(std::locale(), "(invalid string id: {})", id); Logging::warn("formatString: invalid string id: {}", id); } } static void formatString(StringBuffer& buffer, StringId id) { auto args = FormatArgumentsView{}; formatStringImpl(buffer, id, args); } // TODO: Remove unsafe variant. char* formatString(char* buffer, StringId id) { return formatString(buffer, 0xFFFFFFFFU, id); } char* formatString(char* buffer, size_t bufferLen, StringId id) { auto wrapped = FormatArgumentsView{}; auto buf = StringBuffer(buffer, bufferLen); formatStringImpl(buf, id, wrapped); buf.nullTerminate(); return buf.current(); } char* formatString(char* buffer, StringId id, FormatArgumentsView args) { return formatString(buffer, 0xFFFFFFFFU, id, args); } char* formatString(char* buffer, size_t bufferLen, StringId id, FormatArgumentsView args) { auto buf = StringBuffer(buffer, bufferLen); formatStringImpl(buf, id, args); buf.nullTerminate(); return buf.current(); } StringId isTownName(StringId stringId) { return stringId >= kTownNamesStart && stringId < kTownNamesEnd; } StringId toTownName(StringId stringId) { assert(stringId < kTownNamesStart && stringId + kTownNamesStart < kTownNamesEnd); return StringId(kTownNamesStart + stringId); } StringId fromTownName(StringId stringId) { assert(isTownName(stringId)); return StringId(stringId - kTownNamesStart); } int32_t internalLengthToComma1DP(const int32_t length) { return length * 100 / 4 / 32; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/Formatting.h ```h #pragma once #include "FormatArguments.hpp" #include "StringManager.h" #include "Types.hpp" #include <cstddef> #include <cstdint> #include <string_view> #include <utility> #ifdef small #error "small is defined, likely by windows.h" #endif namespace OpenLoco { namespace ControlCodes { // Arguments (1 byte): uint8_t constexpr uint8_t moveX = 1; constexpr uint8_t adjustPalette = 2; // Not used // 3-4 Not used constexpr uint8_t oneArgBegin = moveX; constexpr uint8_t oneArgEnd = 4 + 1; // Arguments: none constexpr uint8_t newline = 5; constexpr uint8_t newlineSmaller = 6; namespace Font { constexpr uint8_t small = 7; constexpr uint8_t large = 8; constexpr uint8_t bold = 9; constexpr uint8_t regular = 10; constexpr uint8_t outline = 11; constexpr uint8_t outlineOff = 12; } constexpr uint8_t windowColour1 = 13; constexpr uint8_t windowColour2 = 14; constexpr uint8_t windowColour3 = 15; constexpr uint8_t windowColour4 = 16; // Not used constexpr uint8_t noArgBegin = newline; constexpr uint8_t noArgEnd = windowColour4 + 1; // Arguments (2 bytes): int8_t, int8_t constexpr uint8_t newlineXY = 17; // 18-22 Not used constexpr uint8_t twoArgBegin = newlineXY; constexpr uint8_t twoArgEnd = 22 + 1; // Arguments (4 bytes): uint32_t constexpr uint8_t inlineSpriteStr = 23; // 24-31 Not used constexpr uint8_t fourArgBegin = inlineSpriteStr; constexpr uint8_t fourArgEnd = 31 + 1; // Arguments in Args buffer // Note: // Pre formatString: // ControlCodes valid args in args buffer. // Post formatString: // ControlCodes are invalid // inlineSpriteArgs replaced with inlineSpriteStr, arg is in string constexpr uint8_t int32_grouped = 123 + 0; constexpr uint8_t int32_ungrouped = 123 + 1; constexpr uint8_t int16_decimals = 123 + 2; constexpr uint8_t int32_decimals = 123 + 3; constexpr uint8_t int16_grouped = 123 + 4; constexpr uint8_t uint16_ungrouped = 123 + 5; constexpr uint8_t currency32 = 123 + 6; constexpr uint8_t currency48 = 123 + 7; constexpr uint8_t stringidArgs = 123 + 8; constexpr uint8_t stringidStr = 123 + 9; constexpr uint8_t string_ptr = 123 + 10; constexpr uint8_t date = 123 + 11; constexpr uint8_t velocity = 123 + 12; constexpr uint8_t pop16 = 123 + 13; constexpr uint8_t push16 = 123 + 14; constexpr uint8_t timeMS = 123 + 15; constexpr uint8_t timeHM = 123 + 16; constexpr uint8_t distance = 123 + 17; constexpr uint8_t height = 123 + 18; constexpr uint8_t power = 123 + 19; constexpr uint8_t inlineSpriteArgs = 123 + 20; namespace Colour { // Arguments: none constexpr uint8_t black = 144; constexpr uint8_t grey = 145; constexpr uint8_t white = 146; constexpr uint8_t red = 147; constexpr uint8_t green = 148; constexpr uint8_t yellow = 149; constexpr uint8_t topaz = 150; constexpr uint8_t celadon = 151; constexpr uint8_t babyBlue = 152; constexpr uint8_t paleLavender = 153; constexpr uint8_t paleGold = 154; constexpr uint8_t lightPink = 155; constexpr uint8_t pearlAqua = 156; constexpr uint8_t paleSilver = 157; } } namespace DateModifier { constexpr uint8_t dmy_full = 0; constexpr uint8_t my_full = 4; constexpr uint8_t my_abbr = 5; constexpr uint8_t raw_my_abbr = 8; } } namespace OpenLoco { enum class MonthId : uint8_t; } namespace OpenLoco::StringManager { char* formatString(char* buffer, StringId id); char* formatString(char* buffer, size_t bufferLen, StringId id); char* formatString(char* buffer, StringId id, FormatArgumentsView args); char* formatString(char* buffer, size_t bufferLen, StringId id, FormatArgumentsView args); // TODO: Move this somewhere more sensible, the string manager should have no idea about the meaning of strings StringId isTownName(StringId stringId); StringId toTownName(StringId stringId); StringId fromTownName(StringId stringId); std::pair<StringId, StringId> monthToString(MonthId month); int32_t internalLengthToComma1DP(const int32_t length); size_t locoStrlen(const char* buffer); size_t locoStrlenS(const char* buffer, std::size_t size); char* locoStrcpy(char* dest, const char* src); char* locoStrcpyS(char* dest, std::size_t destSize, const char* src, std::size_t srcSize); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/LanguageFiles.cpp ```cpp #include "LanguageFiles.h" #include "Config.h" #include "Conversion.h" #include "Environment.h" #include "Localisation/Formatting.h" #include "Logging.h" #include "StringIds.h" #include "StringManager.h" #include "Ui.h" #include "Unicode.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Platform/Platform.h> #include <cassert> #include <iostream> #include <stdexcept> #include <yaml-cpp/yaml.h> using namespace OpenLoco::Interop; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Localisation { static std::vector<std::unique_ptr<char[]>> _stringsOwner; static const std::map<std::string, uint8_t, std::less<>> kBasicCommands = { { "INT16_1DP", ControlCodes::int16_decimals }, { "INT32_2DP", ControlCodes::int32_decimals }, { "INT16", ControlCodes::int16_grouped }, { "UINT16", ControlCodes::uint16_ungrouped }, { "SMALLFONT", ControlCodes::Font::regular }, { "BIGFONT", ControlCodes::Font::large }, { "TINYFONT", ControlCodes::Font::small }, { "NEWLINE_SMALLER", ControlCodes::newlineSmaller }, { "OUTLINE", OpenLoco::ControlCodes::Font::outline }, { "VELOCITY", ControlCodes::velocity }, { "CURRENCY32", ControlCodes::currency32 }, { "HEIGHT", ControlCodes::height }, { "CURRENCY48", ControlCodes::currency48 }, { "STRING", ControlCodes::string_ptr }, { "POP16", ControlCodes::pop16 }, { "POWER", ControlCodes::power }, }; static const std::map<std::string, uint8_t, std::less<>> kTextColourNames = { { "BLACK", ControlCodes::Colour::black }, { "WINDOW_1", ControlCodes::windowColour1 }, { "WINDOW_2", ControlCodes::windowColour2 }, { "WINDOW_3", ControlCodes::windowColour3 }, { "WINDOW_4", ControlCodes::windowColour4 }, { "WHITE", ControlCodes::Colour::white }, { "YELLOW", ControlCodes::Colour::yellow }, { "TOPAZ", ControlCodes::Colour::topaz }, { "RED", ControlCodes::Colour::red }, { "GREEN", ControlCodes::Colour::green }, }; static std::unique_ptr<char[]> readString(const char* value, size_t size) { // Take terminating NULL character in account auto str = std::make_unique<char[]>(size + 1); char* out = str.get(); const utf8_t* ptr = (utf8_t*)value; while (true) { utf32_t codepoint = readCodePoint(&ptr); if (codepoint == UnicodeChar::superscript_minus || codepoint == UnicodeChar::variation_selector) { continue; } char readChar = convertUnicodeToLoco(codepoint); if (readChar == '{') { std::vector<std::string_view> commands = {}; char* start = nullptr; while (true) { char* pos = (char*)ptr; readChar = readCodePoint(&ptr); if (readChar == ' ') { if (start != nullptr) { commands.push_back(std::string_view(start, pos - start)); } start = nullptr; continue; } if (readChar == '}') { if (start != nullptr) { commands.push_back(std::string_view(start, pos - start)); } break; } if (start == nullptr) { start = pos; } } auto search = kBasicCommands.find(commands[0]); if (search != kBasicCommands.end()) { *out = search->second; out++; } else if (commands[0] == "STRINGID") { if (commands.size() == 1) { *out = (char)ControlCodes::stringidArgs; out++; } else { Logging::error("{}", commands[1]); } } else if (commands[0] == "UINT16") { *out = (char)ControlCodes::uint16_ungrouped; out++; } else if (commands[0] == "SPRITE") { if (commands.size() == 1) { *out++ = (char)ControlCodes::inlineSpriteArgs; } else { *out++ = (char)ControlCodes::inlineSpriteStr; int32_t spriteId = std::atoi(commands[1].data()); *((uint32_t*)out) = spriteId; out += 4; } } else if (commands[0] == "INT32") { if (commands.size() == 2 && commands[1] == "RAW") { *out++ = (char)ControlCodes::int32_ungrouped; } else { *out++ = (char)ControlCodes::int32_grouped; } } else if (commands[0] == "RAWDATE" && commands.size() >= 2) { *out++ = (char)ControlCodes::date; if (commands.size() == 3 && commands[1] == "MY" && commands[2] == "SHORT") { *out++ = DateModifier::raw_my_abbr; } } else if (commands[0] == "DATE" && commands.size() == 2) { *out++ = (char)ControlCodes::date; if (commands[1] == "DMY") { *out++ = DateModifier::dmy_full; } else if (commands[1] == "MY") { *out++ = DateModifier::my_full; } } else if (commands[0] == "COLOUR") { auto colour = kTextColourNames.find(commands[1]); if (colour != kTextColourNames.end()) { *out = colour->second; out++; } else { Logging::error("{}", commands[1]); } } else if (commands[0] == "MOVE_X") { *out++ = (char)ControlCodes::moveX; uint8_t pixelsToMoveBy = std::atoi(commands[1].data()); *out++ = pixelsToMoveBy; } else if (commands[0] == "NEWLINE") { if (commands.size() == 1) { *out++ = (char)ControlCodes::newline; } else if (commands.size() == 3) { *out++ = (char)ControlCodes::newlineXY; uint8_t xPixelsToMoveBy = std::atoi(commands[1].data()); *out++ = xPixelsToMoveBy; uint8_t yPixelsToMoveBy = std::atoi(commands[2].data()); *out++ = yPixelsToMoveBy; } } else { Logging::error("{}", commands[0]); } continue; } else { *out = readChar; out++; } if (readChar == '\0') { break; } } return str; } static bool stringIsBuffer(int id) { switch (id) { case StringIds::buffer_337: case StringIds::buffer_338: case StringIds::buffer_1250: case StringIds::preferred_currency_buffer: case StringIds::buffer_1719: case StringIds::buffer_2039: case StringIds::buffer_2040: return true; default: return false; } } static bool loadLanguageStringTable(fs::path languageFile) { try { YAML::Node node = YAML::LoadFile(languageFile.string()); node = node["strings"]; for (YAML::const_iterator it = node.begin(); it != node.end(); ++it) { int id = it->first.as<int>(); if (stringIsBuffer(id)) { continue; } std::string new_string = it->second.as<std::string>(); _stringsOwner.emplace_back(readString(new_string.data(), new_string.length())); char* processedString = _stringsOwner.back().get(); if (processedString != nullptr) { StringManager::swapString(id, processedString); } } return true; } catch (const std::exception& e) { Logging::error("{}", e.what()); Ui::showMessageBox("Exception", e.what()); return false; } } void loadLanguageFile() { // First, load en-GB for fallback strings. fs::path languageDir = Environment::getPath(Environment::PathId::languageFiles); fs::path languageFile = languageDir / "en-GB.yml"; if (!loadLanguageStringTable(languageFile)) { throw Exception::RuntimeError("Could not load the en-GB language file!"); } // Determine the language currently selected. auto& config = Config::get(); if (config.language == "en-GB") { return; } // Now, load the language table for the language currently selected. languageFile = languageDir / (config.language + ".yml"); if (!loadLanguageStringTable(languageFile)) { throw Exception::RuntimeError("Could not load the " + config.language + " language file!"); } } void unloadLanguageFile() { _stringsOwner.clear(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/LanguageFiles.h ```h #pragma once #include <cstdint> namespace OpenLoco::Localisation { void loadLanguageFile(); void unloadLanguageFile(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/Languages.cpp ```cpp #include "Languages.h" #include "Conversion.h" #include "Environment.h" #include <OpenLoco/Core/FileSystem.hpp> #include <OpenLoco/Platform/Platform.h> #include <yaml-cpp/yaml.h> #include <algorithm> #include <fstream> #include <ranges> namespace OpenLoco::Localisation { static std::vector<LanguageDescriptor> _languageDescriptors; void enumerateLanguages() { // (Re-)initialise the languages table. _languageDescriptors.clear(); LanguageDescriptor undefinedLanguage = { "", "", "", LocoLanguageId::english_uk }; _languageDescriptors.emplace_back(undefinedLanguage); // Search the languages dir for YAML language files. fs::path languageDir = Environment::getPath(Environment::PathId::languageFiles); for (auto& entry : fs::directory_iterator(languageDir)) { const auto filePath = entry.path(); const auto fileExt = filePath.extension(); if (fileExt != ".yml") { continue; } std::fstream stream(filePath); if (!stream.is_open()) { continue; } // Read only the header of the file to speed up the indexing process. std::string headerYaml; for (std::string line; line != "strings:" && !stream.eof(); std::getline(stream, line)) { headerYaml += line + '\n'; } YAML::Node node = YAML::Load(headerYaml); if (!node.IsMap()) { continue; } YAML::Node header = node["header"]; // Create a language descriptor for this language file. LanguageDescriptor language; language.locale = header["locale"].as<std::string>(); language.englishName = header["english_name"].as<std::string>(); language.nativeName = convertUnicodeToLoco(header["native_name"].as<std::string>()); language.locoOriginalId = (LocoLanguageId)header["loco_original_id"].as<size_t>(); // Store it in the languages map. _languageDescriptors.emplace_back(language); } // Sort by native name. std::ranges::sort(_languageDescriptors, {}, &LanguageDescriptor::nativeName); } std::span<const LanguageDescriptor> getLanguageDescriptors() { return _languageDescriptors; } const LanguageDescriptor& getDescriptorForLanguage(std::string_view target_locale) { const auto it = std::ranges::find(_languageDescriptors, target_locale, &LanguageDescriptor::locale); if (it != _languageDescriptors.end()) { return *it; } return _languageDescriptors[0]; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/Languages.h ```h #pragma once #include <cstdint> #include <span> #include <string> namespace OpenLoco::Localisation { enum class LocoLanguageId : uint8_t { english_uk, english_us, french, german, spanish, italian, dutch, swedish, japanese, korean, chinese_simplified, chinese_traditional, id_12, portuguese, blank = 254, end = 255 }; struct LanguageDescriptor { std::string locale; std::string englishName; std::string nativeName; LocoLanguageId locoOriginalId; }; void enumerateLanguages(); std::span<const LanguageDescriptor> getLanguageDescriptors(); const LanguageDescriptor& getDescriptorForLanguage(std::string_view targetLocale); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/StringBuffer.cpp ```cpp #include "StringBuffer.h" #include "Formatting.h" namespace OpenLoco { StringBuffer::StringBuffer(value_type* buffer, size_t maxLen) : buffer(buffer) , offset(0) , maxLen(maxLen) { } void StringBuffer::appendData(const void* data, size_t size) { if (offset + size >= maxLen) { throw Exception::OverflowError("String buffer overflow"); } std::memcpy(buffer + offset, data, size); offset += size; } void StringBuffer::append(value_type chr) { if (offset >= maxLen) { throw Exception::OverflowError("String buffer overflow"); } buffer[offset] = chr; offset++; } void StringBuffer::append(const char* input) { return append(input, 0xFFFFFFFFU); } void StringBuffer::append(const char* input, size_t inputLen) { for (size_t i = 0; i < inputLen;) { auto ch = input[i]; if (ch == '\0') { break; } if (ch >= ControlCodes::oneArgBegin && ch < ControlCodes::oneArgEnd) { append(ch); i++; } else if (ch >= ControlCodes::twoArgBegin && ch < ControlCodes::twoArgEnd) { if (i + 2 > inputLen) { throw Exception::OverflowError("String buffer overflow"); } appendData(input + i, 2); i += 2; } else if (ch >= ControlCodes::fourArgBegin && ch < ControlCodes::fourArgEnd) { if (i + 4 > inputLen) { throw Exception::OverflowError("String buffer overflow"); } appendData(input + i, 4); i += 4; } else { append(ch); i++; } } } // std::back_inserter support. void StringBuffer::push_back(value_type chr) { append(chr); } char* StringBuffer::current() const { return buffer + offset; } void StringBuffer::nullTerminate() { if (offset < maxLen) { buffer[offset] = '\0'; } else { buffer[maxLen - 1] = '\0'; } } void StringBuffer::grow(size_t numChars) { if (offset + numChars >= maxLen) { throw std::overflow_error("String buffer overflow"); } offset += numChars; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/StringBuffer.h ```h #pragma once #include <cstddef> #include <fmt/core.h> #include <iterator> namespace OpenLoco { struct StringBuffer { using value_type = char; char* buffer; size_t offset; size_t maxLen; public: StringBuffer(value_type* buffer, size_t maxLen); void appendData(const void* data, size_t size); void append(value_type chr); void append(const char* input); void append(const char* input, size_t inputLen); // std::back_inserter support. void push_back(value_type chr); template<typename TLocale, typename... TArgs> void format(TLocale&& loc, fmt::format_string<TArgs...> fmt, TArgs&&... args) { fmt::format_to(std::back_inserter(*this), loc, fmt, std::forward<TArgs>(args)...); } char* current() const; void nullTerminate(); void grow(size_t numChars); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/StringIds.h ```h #pragma once #include "StringManager.h" #define UNUSED_STR(x) (x) namespace OpenLoco::StringIds { constexpr StringId empty = 0; constexpr StringId empty_pop = 1; constexpr StringId new_company = 2; constexpr StringId new_owner = 3; constexpr StringId train_number = 4; constexpr StringId bus_number = 5; constexpr StringId truck_number = 6; constexpr StringId tram_number = 7; constexpr StringId aircraft_number = 8; constexpr StringId ship_number = 9; constexpr StringId day_1st = 10; constexpr StringId day_2nd = 11; constexpr StringId day_3rd = 12; constexpr StringId day_4th = 13; constexpr StringId day_5th = 14; constexpr StringId day_6th = 15; constexpr StringId day_7th = 16; constexpr StringId day_8th = 17; constexpr StringId day_9th = 18; constexpr StringId day_10th = 19; constexpr StringId day_11th = 20; constexpr StringId day_12th = 21; constexpr StringId day_13th = 22; constexpr StringId day_14th = 23; constexpr StringId day_15th = 24; constexpr StringId day_16th = 25; constexpr StringId day_17th = 26; constexpr StringId day_18th = 27; constexpr StringId day_19th = 28; constexpr StringId day_20th = 29; constexpr StringId day_21st = 30; constexpr StringId day_22nd = 31; constexpr StringId day_23rd = 32; constexpr StringId day_24th = 33; constexpr StringId day_25th = 34; constexpr StringId day_26th = 35; constexpr StringId day_27th = 36; constexpr StringId day_28th = 37; constexpr StringId day_29th = 38; constexpr StringId day_30th = 39; constexpr StringId day_31st = 40; constexpr StringId month_short_january = 41; constexpr StringId month_short_february = 42; constexpr StringId month_short_march = 43; constexpr StringId month_short_april = 44; constexpr StringId month_short_may = 45; constexpr StringId month_short_june = 46; constexpr StringId month_short_july = 47; constexpr StringId month_short_august = 48; constexpr StringId month_short_september = 49; constexpr StringId month_short_october = 50; constexpr StringId month_short_november = 51; constexpr StringId month_short_december = 52; constexpr StringId unable_to_allocate_enough_memory = 55; constexpr StringId close_window_cross = 56; constexpr StringId chosen_name_in_use = 57; constexpr StringId too_many_names_in_use = 58; constexpr StringId not_enough_cash_requires_currency32 = 59; constexpr StringId tooltip_close_window = 60; constexpr StringId game_init_failure = 61; constexpr StringId display_resolution_dropdown_format = 65; constexpr StringId display_resolution_label_format = 66; constexpr StringId menu_about = 67; constexpr StringId about_locomotion_caption = 68; constexpr StringId about_locomotion_69 = 69; constexpr StringId about_locomotion_70 = 70; constexpr StringId about_locomotion_71 = 71; constexpr StringId about_locomotion_72 = 72; constexpr StringId about_locomotion_73 = 73; constexpr StringId about_locomotion_74 = 74; constexpr StringId about_locomotion_75 = 75; constexpr StringId about_locomotion_76 = 76; constexpr StringId about_locomotion_77 = 77; constexpr StringId about_locomotion_78 = UNUSED_STR(78); constexpr StringId about_locomotion_79 = UNUSED_STR(79); constexpr StringId about_locomotion_80 = UNUSED_STR(80); constexpr StringId about_locomotion_81 = UNUSED_STR(81); constexpr StringId about_locomotion_82 = UNUSED_STR(82); constexpr StringId about_locomotion_83 = UNUSED_STR(83); constexpr StringId about_locomotion_84 = UNUSED_STR(84); constexpr StringId stringid = 85; constexpr StringId arg2_stringid = 86; constexpr StringId arg4_stringid = 87; constexpr StringId arg6_stringid = 88; constexpr StringId arg8_stringid = 89; constexpr StringId arg10_stringid = 90; constexpr StringId arg12_stringid = 91; constexpr StringId arg14_stringid = 92; constexpr StringId arg16_stringid = 93; constexpr StringId arg18_stringid = 94; constexpr StringId arg20_stringid = 95; constexpr StringId dropdown = 96; constexpr StringId error_too_low = 98; constexpr StringId error_too_high = 99; constexpr StringId error_cant_lower_land_here = 100; constexpr StringId error_cant_raise_land_here = 101; constexpr StringId object_in_the_way = 102; constexpr StringId menu_load_game = 103; constexpr StringId menu_save_game = 104; constexpr StringId menu_quit_scenario_editor = 105; constexpr StringId menu_quit_game = 106; constexpr StringId screenshot_filename_template = 107; constexpr StringId menu_screenshot = 108; constexpr StringId screenshot_saved_as = 109; constexpr StringId screenshot_failed = 110; constexpr StringId landscape_data_area_full = 111; constexpr StringId cant_build_partly_above_partly_below_ground = 112; constexpr StringId stringid_2 = 113; constexpr StringId tooltip_left_hand_curve = 114; constexpr StringId tooltip_right_hand_curve = 115; constexpr StringId tooltip_left_hand_curve_small = 116; constexpr StringId tooltip_right_hand_curve_small = 117; constexpr StringId tooltip_left_hand_curve_very_small = 118; constexpr StringId tooltip_right_hand_curve_very_small = 119; constexpr StringId tooltip_left_hand_curve_large = 120; constexpr StringId tooltip_right_hand_curve_large = 121; constexpr StringId tooltip_straight = 122; constexpr StringId tooltip_s_bend_left = 123; constexpr StringId tooltip_s_bend_right = 124; constexpr StringId tooltip_s_bend_left_dual_track = 125; constexpr StringId tooltip_s_bend_right_dual_track = 126; constexpr StringId tooltip_s_bend_to_single_track = 127; constexpr StringId tooltip_turnaround = 128; constexpr StringId tooltip_start_construction = 129; constexpr StringId tooltip_construct = 130; constexpr StringId tooltip_remove = 131; constexpr StringId tooltip_steep_slope_down = 132; constexpr StringId tooltip_slope_down = 133; constexpr StringId tooltip_level = 134; constexpr StringId tooltip_slope_up = 135; constexpr StringId tooltip_steep_slope_up = 136; constexpr StringId build_this = 137; constexpr StringId build_cost = 138; constexpr StringId cant_build_signal_here = 139; constexpr StringId cant_build_signals_here = 140; constexpr StringId cant_remove_signal = 141; constexpr StringId cant_remove_pop3_string = 142; constexpr StringId cant_build_pop3_string = 143; constexpr StringId raise_or_lower_land_first = 144; constexpr StringId menu_underground_view = 145; // String below is unused constexpr StringId menu_hide_foreground_tracks_roads = 146; constexpr StringId station_type_can_only_be_built_at_road_ends = 147; constexpr StringId wrong_type_of_station_for_string_id = 148; constexpr StringId station_not_compatible_with_string_id = 149; constexpr StringId level_crossing_in_the_way = 150; constexpr StringId level_crossing_only_possible_with_straight_road_and_track_at_same_level = 151; constexpr StringId junction_not_possible = 152; constexpr StringId junction_must_be_entirely_level = 153; constexpr StringId string_id_in_the_way_wrong_height_for_junction = 154; constexpr StringId already_built_here = 155; constexpr StringId unable_to_cross_or_create_junction_with_string = 156; constexpr StringId junctions_not_possible = 157; constexpr StringId capt_signal = 158; constexpr StringId capt_station = 159; constexpr StringId capt_airport = 160; constexpr StringId capt_ship_port = 161; constexpr StringId station_in_the_way = 162; constexpr StringId signal_in_the_way = 163; constexpr StringId cant_remove_airport = 164; constexpr StringId cant_remove_ship_port = 165; constexpr StringId cant_remove_station = 166; constexpr StringId wrong_type_of_track_road = 167; constexpr StringId bridge_types_must_match = 168; constexpr StringId bridge_not_suitable_for_junction = 169; constexpr StringId track_combination_not_possible = 170; constexpr StringId too_many_objects_in_game = 171; constexpr StringId menu_rotate_clockwise = 172; constexpr StringId menu_rotate_anti_clockwise = 173; constexpr StringId starting_for_the_first_time = 174; constexpr StringId checking_object_files = 175; constexpr StringId title_load_game = 176; constexpr StringId title_quit_game = 177; constexpr StringId title_quit_game_alt = 178; constexpr StringId title_quit_scenario_editor = 179; constexpr StringId title_load_landscape = 180; constexpr StringId prompt_save_before_loading = 181; constexpr StringId prompt_save_before_quitting = 182; constexpr StringId prompt_save_before_quitting_alt = 183; constexpr StringId label_button_save = 184; constexpr StringId label_button_dont_save = 185; constexpr StringId label_button_cancel = 186; constexpr StringId label_button_ok = 187; constexpr StringId tooltip_scroll_left = 188; constexpr StringId tooltip_scroll_right = 189; constexpr StringId tooltip_scroll_left_fast = 190; constexpr StringId tooltip_scroll_right_fast = 191; constexpr StringId tooltip_scroll_left_right = 192; constexpr StringId tooltip_scroll_up = 193; constexpr StringId tooltip_scroll_down = 194; constexpr StringId tooltip_scroll_up_fast = 195; constexpr StringId tooltip_scroll_down_fast = 196; constexpr StringId tooltip_scroll_up_down = 197; constexpr StringId tooltip_scroll_map = 198; constexpr StringId tooltip_scroll_vehicle_list = 199; constexpr StringId tooltip_scroll_new_vehicle_list = 200; constexpr StringId tooltip_scroll_list = 201; constexpr StringId tooltip_scroll_trees_list = 202; constexpr StringId tooltip_scroll_orders_list = 203; constexpr StringId tooltip_scroll_station_list = 204; constexpr StringId tooltip_scroll_town_list = 205; constexpr StringId tooltip_scroll_industry_list = 206; constexpr StringId tooltip_scroll_new_industry_list = 207; constexpr StringId tooltip_scroll_building_list = 208; constexpr StringId tooltip_scroll_walls_list = 209; constexpr StringId tooltip_scroll_ratings_list = 210; constexpr StringId tooltip_scroll_cargo_list = 211; constexpr StringId tooltip_scroll_message_list = 212; constexpr StringId tooltip_scroll_company_list = 213; constexpr StringId tooltip_scroll_scenario_list = 214; constexpr StringId tooltip_scroll_credits_list = 215; constexpr StringId increase_height_cost = 216; constexpr StringId decrease_height_cost = 217; constexpr StringId clear_land_cost = 219; constexpr StringId error_cant_change_colour_scheme = 222; constexpr StringId menu_zoom_in = 223; constexpr StringId menu_zoom_out = 224; constexpr StringId menu_towns = 225; constexpr StringId menu_industries = 226; constexpr StringId menu_airport = 227; constexpr StringId menu_ship_port = 228; constexpr StringId landscape_generation_options = 229; constexpr StringId label_icons_none = 230; constexpr StringId label_icons_rail = 231; constexpr StringId label_icons_road = 232; constexpr StringId label_icons_rail_road = 233; constexpr StringId label_icons_air = 234; constexpr StringId label_icons_rail_air = 235; constexpr StringId label_icons_road_air = 236; constexpr StringId label_icons_rail_road_air = 237; constexpr StringId label_icons_water = 238; constexpr StringId label_icons_rail_water = 239; constexpr StringId label_icons_road_water = 240; constexpr StringId label_icons_rail_road_water = 241; constexpr StringId label_icons_air_water = 242; constexpr StringId label_icons_rail_air_water = 243; constexpr StringId label_icons_road_air_water = 244; constexpr StringId label_icons_rail_road_air_water = 245; constexpr StringId title_company = 246; constexpr StringId title_company_details = 247; constexpr StringId title_company_finances = 248; constexpr StringId title_company_cargo_delivered = 249; constexpr StringId title_company_colour_scheme = 250; constexpr StringId title_company_challenge = 251; constexpr StringId tooltip_change_direction = 252; constexpr StringId tooltip_pass_signal_at_danger = 253; constexpr StringId tooltip_remove_from_track = 254; constexpr StringId tooltip_place_on_track = 255; constexpr StringId tooltip_remove_from_airport = 256; constexpr StringId tooltip_place_on_airport = 257; constexpr StringId tooltip_remove_from_water = 258; constexpr StringId tooltip_place_on_dock = 259; constexpr StringId cant_start_string_id = 260; constexpr StringId cant_select_manual_mode_string_id = 261; constexpr StringId cant_stop_string_id = 262; constexpr StringId velocity = 263; constexpr StringId unlimited_speed = 264; constexpr StringId stop = 265; constexpr StringId start = 266; constexpr StringId manual = 267; constexpr StringId tooltip_select_track_to_upgrade = 268; constexpr StringId tooltip_stop_start = 269; constexpr StringId signal_black = 270; constexpr StringId tab_track_road_construction = 271; constexpr StringId tab_station_construction = 272; constexpr StringId tab_signal_construction = 273; constexpr StringId tab_electrification_construction = 274; constexpr StringId tooltip_select_signal_type = 275; constexpr StringId tooltip_signal_both_directions = 276; constexpr StringId tooltip_signal_single_direction = 277; constexpr StringId tooltip_bridge_stats = 278; constexpr StringId tooltip_select_station_type = 279; constexpr StringId station_name_ordinal = 280; constexpr StringId station_town = 281; constexpr StringId station_town_north = 282; constexpr StringId station_town_south = 283; constexpr StringId station_town_east = 284; constexpr StringId station_town_west = 285; constexpr StringId station_town_central = 286; constexpr StringId station_town_transfer = 287; constexpr StringId station_town_halt = 288; constexpr StringId station_town_valley = 289; constexpr StringId station_town_heights = 290; constexpr StringId station_town_woods = 291; constexpr StringId station_town_lakeside = 292; constexpr StringId station_town_exchange = 293; constexpr StringId station_town_airport = 294; constexpr StringId station_town_oilfield = 295; constexpr StringId station_town_mines = 296; constexpr StringId station_town_docks = 297; constexpr StringId station_town_annexe = 298; constexpr StringId station_town_sidings = 299; constexpr StringId station_town_branch = 300; constexpr StringId station_upper_town = 301; constexpr StringId station_lower_town = 302; constexpr StringId station_town_heliport = 303; constexpr StringId station_town_forest = 304; constexpr StringId station_town_junction = 305; constexpr StringId station_town_cross = 306; constexpr StringId station_town_views = 307; constexpr StringId station_town_ord_1 = 308; constexpr StringId station_town_ord_2 = 309; constexpr StringId station_town_ord_3 = 310; constexpr StringId station_town_ord_4 = 311; constexpr StringId station_town_ord_5 = 312; constexpr StringId station_town_ord_6 = 313; constexpr StringId station_town_ord_7 = 314; constexpr StringId station_town_ord_8 = 315; constexpr StringId station_town_ord_9 = 316; constexpr StringId station_town_ord_10 = 317; constexpr StringId station_town_ord_11 = 318; constexpr StringId station_town_ord_12 = 319; constexpr StringId station_town_ord_13 = 320; constexpr StringId station_town_ord_14 = 321; constexpr StringId station_town_ord_15 = 322; constexpr StringId station_town_ord_16 = 323; constexpr StringId station_town_ord_17 = 324; constexpr StringId station_town_ord_18 = 325; constexpr StringId station_town_ord_19 = 326; constexpr StringId station_town_ord_20 = 327; constexpr StringId vehicle_details_weight = 328; constexpr StringId vehicle_details_total_power_and_weight = 329; constexpr StringId vehicle_details_max_speed_and_reliability = 330; constexpr StringId vehicle_details_max_speed_and_rack_rail_and_reliability = 331; constexpr StringId tooltip_sell_or_drag_vehicle = 332; constexpr StringId tooltip_build_new_vehicle_for = 333; constexpr StringId click_on_view_select_string_id_start = 334; constexpr StringId incompatible_vehicle = 335; constexpr StringId too_many_vehicles = 336; constexpr StringId buffer_337 = 337; constexpr StringId buffer_338 = 338; constexpr StringId tooltip_stringid = 339; constexpr StringId vehicle_details_tooltip_built = 340; constexpr StringId vehicle_details_tooltip_value = 341; constexpr StringId vehicle_details_tooltip_power = 342; constexpr StringId vehicle_details_tooltip_weight = 343; constexpr StringId vehicle_details_tooltip_max_speed = 344; constexpr StringId vehicle_details_tooltip_speed_on_stringid = 345; constexpr StringId vehicle_details_tooltip_reliability = 346; constexpr StringId stringid_stringid = 347; constexpr StringId single_section = 348; constexpr StringId block_section = 349; constexpr StringId all_connected_track = 350; constexpr StringId too_much_track_some_track_not_upgraded = 351; constexpr StringId upgrade_track_with_mods = 352; constexpr StringId click_track_to_upgrade = 353; constexpr StringId tooltip_select_track_mod = 354; constexpr StringId move_main_view_to_show_this = 355; constexpr StringId off_edge_of_map = 356; constexpr StringId cannot_build_partly_above_below_water = 357; constexpr StringId too_close_to_water_surface = 358; constexpr StringId cant_build_this_underwater = 359; constexpr StringId error_can_only_build_above_ground = 360; constexpr StringId can_only_build_this_on_level_land = 361; constexpr StringId title_prompt_load_game = 362; constexpr StringId title_prompt_load_landscape = 363; constexpr StringId title_prompt_save_landscape = 364; constexpr StringId title_prompt_save_game = 365; constexpr StringId title_prompt_save_scenario = 366; constexpr StringId format_openloco_saved_game = 367; constexpr StringId format_openloco_scenario = 368; constexpr StringId format_openloco_landscape = 369; constexpr StringId error_game_save_failed = 370; // String below is unused constexpr StringId menu_hide_foreground_scenery_buildings = 372; constexpr StringId can_only_be_built_on_water = 373; constexpr StringId can_only_be_built_on_water_next_to_water_based_industry = 374; constexpr StringId title_name_vehicle = 375; constexpr StringId prompt_enter_new_vehicle_name = 376; constexpr StringId cant_rename_this_vehicle = 377; constexpr StringId bridge_needed = 378; constexpr StringId too_far_above_ground_for_bridge_type = 379; constexpr StringId bridge_already_at_maximum_height = 380; constexpr StringId stringid_requires_a_bridge = 381; constexpr StringId bridge_type_unsuitable_for_this_configuration = 382; constexpr StringId title_station_name = 383; constexpr StringId prompt_type_new_station_name = 384; constexpr StringId error_cant_rename_station = 385; constexpr StringId cant_move_vehicle = 387; constexpr StringId cant_reverse_train = 388; constexpr StringId cant_sell_vehicle = 389; constexpr StringId cant_sell_string_id = 390; constexpr StringId quote_string_quote = 391; constexpr StringId quote_string_quote2 = 392; constexpr StringId string_station_platform = 393; constexpr StringId string_station_building_bus_stop = 394; constexpr StringId station_catchment = 395; constexpr StringId menu_mute = 396; constexpr StringId menu_play_music = 397; constexpr StringId player_info_bankrupt = 398; constexpr StringId message_not_allowed_to_wait_for_full_load_at = 399; constexpr StringId message_has_slipped_to_a_halt_on_incline = 400; constexpr StringId message_now_accepts = 401; constexpr StringId message_no_longer_accepts = 402; constexpr StringId message_new_transport_company = 403; constexpr StringId message_not_able_to_land_at = 404; constexpr StringId message_first_string_arrive_at = 405; constexpr StringId message_first_string_delivery_arives_at = 406; constexpr StringId message_first_string_delivered_to = 407; constexpr StringId message_new_vehicle_invented = 408; constexpr StringId message_is_promoted_to = 409; constexpr StringId message_new_string_under_construction_near = 410; constexpr StringId message_congratulations_you_have_completed = 411; constexpr StringId message_failure_you_have_failed = 412; constexpr StringId message_beaten_has_completed = 413; constexpr StringId message_bankruptcy_warning_6_months_remaining = 414; constexpr StringId message_bankruptcy_warning_3_months_remaining = 415; constexpr StringId message_bankrupt = 416; constexpr StringId message_bankrupt_2 = 417; constexpr StringId message_has_crashed = 418; constexpr StringId message_corporate_scandal = 419; constexpr StringId message_new_speed_record = 420; constexpr StringId dropdown_stringid = 421; constexpr StringId dropdown_stringid_selected = 422; constexpr StringId dropdown_company_select = 423; constexpr StringId dropdown_stringptr = 424; constexpr StringId menu_height_marks_on_tracks_roads = 426; constexpr StringId menu_height_marks_on_land = 427; constexpr StringId menu_one_way_direction_arrows = 428; constexpr StringId menu_town_names_displayed = 429; constexpr StringId menu_station_names_displayed = 430; constexpr StringId accepts = 431; constexpr StringId quantity_eigth = 432; constexpr StringId quantity_quarter = 433; constexpr StringId quantity_three_eigths = 434; constexpr StringId quantity_half = 435; constexpr StringId quantity_five_eigths = 436; constexpr StringId quantity_three_quarters = 437; constexpr StringId quantity_seven_eigths = 438; constexpr StringId comma = 439; constexpr StringId produces = 440; constexpr StringId under_construction = 441; constexpr StringId string_owned_by_string = 442; constexpr StringId dropdown_without_checkmark = 443; constexpr StringId dropdown_with_checkmark = 444; constexpr StringId error_cant_remove_this = 445; constexpr StringId title_build_walls = 446; constexpr StringId title_plant_trees = 447; constexpr StringId cant_plant_this_here = 449; constexpr StringId outlined_wcolour2_stringid = 450; constexpr StringId stringid_right_click_to_modify = 451; constexpr StringId stringid_right_click_to_remove = 452; constexpr StringId black_tiny_font = 453; constexpr StringId red_stringid = 454; constexpr StringId black_stringid = 455; constexpr StringId black_stringid_stringid = 456; constexpr StringId wcolour2_stringid = 457; constexpr StringId white_stringid = 458; constexpr StringId vehicle_status_stopping = 459; constexpr StringId vehicle_status_waiting_at_signal = 460; constexpr StringId vehicle_status_at_velocity = 461; constexpr StringId vehicle_status_crashed = 462; constexpr StringId vehicle_status_stuck = 463; constexpr StringId vehicle_status_broken_down = 464; constexpr StringId vehicle_status_stopped = 465; constexpr StringId vehicle_status_loading = 466; constexpr StringId vehicle_status_unloading = 467; constexpr StringId vehicle_status_approaching = 468; constexpr StringId vehicle_status_landing = 469; constexpr StringId vehicle_status_taxiing = 470; constexpr StringId vehicle_status_taking_off = 471; constexpr StringId vehicle_status_heading_for = 472; constexpr StringId vehicle_status_no_position = 473; constexpr StringId vehicle_status_travelling = 474; constexpr StringId competitor_vehicle = 475; constexpr StringId company_vehicle = 476; constexpr StringId error_cant_lower_water_here = 477; constexpr StringId error_cant_raise_water_here = 478; constexpr StringId audio_device_none = 479; constexpr StringId stringptr = 480; constexpr StringId cant_build_this_underwater_duplicate = 484; // This is a duplicate and could be deleted constexpr StringId land_type_not_suitable = 485; constexpr StringId spinner_up = 486; constexpr StringId spinner_down = 487; constexpr StringId status_num_stations_singular = 520; constexpr StringId status_num_stations_plural = 521; constexpr StringId status_num_vehicles_singular = 527; constexpr StringId status_num_vehicles_plural = 528; constexpr StringId status_towns_singular = 555; constexpr StringId status_towns_plural = 556; constexpr StringId status_num_industries_singular = 562; constexpr StringId status_num_industries_plural = 563; constexpr StringId rotate_object_90 = 565; constexpr StringId error_cant_change_land_type = 567; constexpr StringId format_currency_income_green = 568; constexpr StringId format_currency_expense_red_negative = 569; constexpr StringId format_currency_income_in_company_colour = 570; constexpr StringId format_currency_expense_in_company_colour_negative = 571; constexpr StringId player_info_company_value = 572; constexpr StringId player_info_company_value_negative = 573; constexpr StringId tooltip_vehicle_tab_main = 574; constexpr StringId tooltip_vehicle_tab_details = 575; constexpr StringId tooltip_vehicle_tab_cargo = 576; constexpr StringId tooltip_vehicle_tab_route = 577; constexpr StringId tooltip_vehicle_tab_finance = 578; constexpr StringId new_construction_position = 579; constexpr StringId rotate_90 = 580; constexpr StringId string_id_in_the_way = 581; constexpr StringId error_cant_build_this_here = 583; constexpr StringId date_monthyear = 584; constexpr StringId openloco = 585; constexpr StringId expenditure_income = 587; constexpr StringId train_income = 588; constexpr StringId train_running_costs = 589; constexpr StringId bus_income = 590; constexpr StringId bus_running_costs = 591; constexpr StringId truck_income = 592; constexpr StringId truck_running_costs = 593; constexpr StringId tram_income = 594; constexpr StringId tram_running_costs = 595; constexpr StringId aircraft_income = 596; constexpr StringId aircraft_running_costs = 597; constexpr StringId ship_income = 598; constexpr StringId ship_running_costs = 599; constexpr StringId construction = 600; constexpr StringId vehicle_purchases = 601; constexpr StringId vehicle_disposals = 602; constexpr StringId loan_interest = 603; constexpr StringId miscellaneous = 604; constexpr StringId uint16_raw = 605; constexpr StringId plus_currency48 = 606; constexpr StringId currency48 = 607; constexpr StringId company_current_loan = 608; constexpr StringId company_current_loan_value = 609; constexpr StringId cant_borrow_any_more_money = 610; constexpr StringId not_enough_cash_available = 611; constexpr StringId cant_pay_back_loan = 612; constexpr StringId title_menu_new_game = 613; constexpr StringId title_menu_load_game = 614; constexpr StringId title_menu_show_tutorial = 615; constexpr StringId title_menu_exit_from_game = 616; constexpr StringId town_size_hamlet = 617; constexpr StringId town_size_village = 618; constexpr StringId town_size_town = 619; constexpr StringId town_size_city = 620; constexpr StringId town_size_metropolis = 621; constexpr StringId track_road_unsuitable = 622; constexpr StringId track_road_unsuitable_for_station = 623; constexpr StringId station_cannot_be_built_on_a_junction = 624; constexpr StringId signals_cannot_be_built_on_a_junction = 625; constexpr StringId signals_cannot_be_built_in_stations = 626; constexpr StringId wcolour3_stringid_2 = 627; // identical to 628 constexpr StringId wcolour3_stringid = 628; constexpr StringId wcolour3_stringid_stringid = 629; constexpr StringId cash_bankrupt = 630; constexpr StringId cash_positive = 631; constexpr StringId cash_negative = 632; constexpr StringId company_value = 633; constexpr StringId profit_from_vehicles = 634; constexpr StringId month_long_january = 635; constexpr StringId month_long_february = 636; constexpr StringId month_long_march = 637; constexpr StringId month_long_april = 638; constexpr StringId month_long_may = 639; constexpr StringId month_long_june = 640; constexpr StringId month_long_july = 641; constexpr StringId month_long_august = 642; constexpr StringId month_long_september = 643; constexpr StringId month_long_october = 644; constexpr StringId month_long_november = 645; constexpr StringId month_long_december = 646; constexpr StringId tooltip_daymonthyear_challenge = 647; constexpr StringId select_scenario_for_new_game = 648; constexpr StringId sound_quality = UNUSED_STR(650); constexpr StringId sound_quality_low = UNUSED_STR(651); constexpr StringId sound_quality_medium = UNUSED_STR(652); constexpr StringId sound_quality_high = UNUSED_STR(653); constexpr StringId options = 654; constexpr StringId distance_and_speed = 656; constexpr StringId heights = 657; constexpr StringId imperial = 658; constexpr StringId metric = 659; constexpr StringId height_units = 660; constexpr StringId height_real_values = 661; constexpr StringId display_resolution = 662; constexpr StringId landscape_smoothing = 663; constexpr StringId landscape_smoothing_tip = 664; constexpr StringId gridlines_on_landscape = 665; constexpr StringId gridlines_on_landscape_tip = 666; constexpr StringId bank_refuses_to_increase_loan = 667; constexpr StringId tooltip_clear_area = 668; constexpr StringId tooltip_decrease_clear_area = 669; constexpr StringId tooltip_increase_clear_area = 670; constexpr StringId tooltip_decrease_adjust_land_area = 671; constexpr StringId tooltip_increase_adjust_land_area = 672; constexpr StringId tooltip_decrease_adjust_water_area = 673; constexpr StringId tooltip_increase_adjust_water_area = 674; constexpr StringId title_adjust_land = 675; constexpr StringId title_adjust_water = 676; constexpr StringId tooltip_adjust_water_tool = 677; constexpr StringId tooltip_adjust_land_tool = 678; constexpr StringId clear_area = 679; constexpr StringId menu_clear_area = 680; constexpr StringId menu_adjust_land = 681; constexpr StringId menu_adjust_water = 682; constexpr StringId menu_plant_trees = 683; constexpr StringId menu_build_walls = 684; constexpr StringId title_vehicle_details = 685; constexpr StringId title_vehicle_cargo = 686; constexpr StringId title_vehicle_route = 687; constexpr StringId company_details_trains_count = 689; constexpr StringId company_details_buses_count = 690; constexpr StringId company_details_trucks_count = 691; constexpr StringId company_details_trams_count = 692; constexpr StringId company_details_aircraft_count = 693; constexpr StringId company_details_ships_count = 694; constexpr StringId challenge_failed = 695; constexpr StringId challenge_completed = 696; constexpr StringId tooltip_performance_index = 697; constexpr StringId tooltip_company_value = 698; constexpr StringId challenge_progress = 699; constexpr StringId challenge_time_left = 700; constexpr StringId customise_keys = 701; constexpr StringId keyboard_shortcuts = 702; constexpr StringId reset_keys = 703; constexpr StringId reset_keys_tip = 704; constexpr StringId shortcut_close_topmost_window = 705; constexpr StringId shortcut_close_all_floating_windows = 706; constexpr StringId shortcut_cancel_construction_mode = 707; constexpr StringId shortcut_pause_unpause_game = 708; constexpr StringId shortcut_zoom_view_out = 709; constexpr StringId shortcut_zoom_view_in = 710; constexpr StringId shortcut_rotate_view = 711; constexpr StringId shortcut_rotate_construction_object = 712; constexpr StringId shortcut_toggle_underground_view = 713; constexpr StringId shortcut_toggle_hide_foreground_tracks = 714; constexpr StringId shortcut_toggle_hide_foreground_scenery = 715; constexpr StringId shortcut_toggle_height_marks_on_land = 716; constexpr StringId shortcut_toggle_height_marks_on_tracks = 717; constexpr StringId shortcut_toggle_dir_arrows_on_tracks = 718; constexpr StringId shortcut_adjust_land = 719; constexpr StringId shortcut_adjust_water = 720; constexpr StringId shortcut_plant_trees = 721; constexpr StringId shortcut_bulldoze_area = 722; constexpr StringId shortcut_build_tracks = 723; constexpr StringId shortcut_build_roads = 724; constexpr StringId shortcut_build_airports = 725; constexpr StringId shortcut_build_ship_ports = 726; constexpr StringId shortcut_build_new_vehicles = 727; constexpr StringId shortcut_show_vehicles_list = 728; constexpr StringId shortcut_show_stations_list = 729; constexpr StringId shortcut_show_towns_list = 730; constexpr StringId shortcut_show_industries_list = 731; constexpr StringId shortcut_show_map = 732; constexpr StringId shortcut_show_companies_list = 733; constexpr StringId shortcut_show_company_information = 734; constexpr StringId shortcut_show_finances = 735; constexpr StringId shortcut_show_announcements_list = 736; constexpr StringId shortcut_screenshot = 737; constexpr StringId shortcut_toggle_last_announcement = 738; constexpr StringId shortcut_send_message = 739; constexpr StringId shortcut_key_base = 740; constexpr StringId keyboard_backspace = 748; constexpr StringId keyboard_tab = 749; constexpr StringId keyboard_return = 753; constexpr StringId keyboard_alt_menu = 758; constexpr StringId keyboard_pause = 759; constexpr StringId keyboard_caps = 760; constexpr StringId keyboard_escape = 767; constexpr StringId keyboard_spacebar = 772; constexpr StringId keyboard_pageup = 773; constexpr StringId keyboard_pagedown = 774; constexpr StringId keyboard_end = 775; constexpr StringId keyboard_home = 776; constexpr StringId keyboard_left = 777; constexpr StringId keyboard_up = 778; constexpr StringId keyboard_right = 779; constexpr StringId keyboard_down = 780; constexpr StringId keyboard_insert = 785; constexpr StringId keyboard_delete = 786; constexpr StringId keyboard_numpad_0 = 836; constexpr StringId keyboard_numpad_1 = 837; constexpr StringId keyboard_numpad_2 = 838; constexpr StringId keyboard_numpad_3 = 839; constexpr StringId keyboard_numpad_4 = 840; constexpr StringId keyboard_numpad_5 = 841; constexpr StringId keyboard_numpad_6 = 842; constexpr StringId keyboard_numpad_7 = 843; constexpr StringId keyboard_numpad_8 = 844; constexpr StringId keyboard_numpad_9 = 845; constexpr StringId keyboard_numpad_multiply = 846; constexpr StringId keyboard_numpad_plus = 847; constexpr StringId keyboard_numpad_enter = 848; constexpr StringId keyboard_numpad_minus = 849; constexpr StringId keyboard_numpad_period = 850; constexpr StringId keyboard_numpad_divide = 851; constexpr StringId keyboard_numlock = 884; constexpr StringId keyboard_scroll = 885; constexpr StringId keyboard_shortcut_list_format = 996; constexpr StringId keyboard_shortcut_modifier_shift = 997; constexpr StringId keyboard_shortcut_modifier_ctrl = 998; constexpr StringId change_keyboard_shortcut = 999; constexpr StringId change_keyboard_shortcut_desc = 1000; constexpr StringId keyboard_shortcut_list_tip = 1001; constexpr StringId scroll_screen_edge = 1002; constexpr StringId scroll_screen_edge_tip = 1003; constexpr StringId customise_keys_tip = 1004; constexpr StringId title_map = 1005; constexpr StringId title_map_vehicles = 1006; constexpr StringId title_map_industries = 1007; constexpr StringId title_map_routes = 1008; constexpr StringId title_map_companies = 1009; constexpr StringId forced_software_buffer_mixing = UNUSED_STR(1010); constexpr StringId forced_software_buffer_mixing_tip = UNUSED_STR(1011); constexpr StringId tutorial_text = 1014; constexpr StringId tutorial_control = 1015; constexpr StringId loco_already_running = 1016; constexpr StringId music_acknowledgements_btn = 1017; constexpr StringId music_acknowledgements_caption = 1018; constexpr StringId music_copyright = 1019; constexpr StringId locomotion_title = 1020; constexpr StringId locomotion_title_credit = 1021; constexpr StringId long_dusty_road = 1022; constexpr StringId long_dusty_road_credit = 1023; constexpr StringId flying_high = 1024; constexpr StringId flying_high_credit = 1025; constexpr StringId gettin_on_the_gas = 1026; constexpr StringId gettin_on_the_gas_credit = 1027; constexpr StringId jumpin_the_rails = 1028; constexpr StringId jumpin_the_rails_credit = 1029; constexpr StringId smooth_running = 1030; constexpr StringId smooth_running_credit = 1031; constexpr StringId traffic_jam = 1032; constexpr StringId traffic_jam_credit = 1033; constexpr StringId never_stop_til_you_get_there = 1034; constexpr StringId never_stop_til_you_get_there_credit = 1035; constexpr StringId soaring_away = 1036; constexpr StringId soaring_away_credit = 1037; constexpr StringId techno_torture = 1038; constexpr StringId techno_torture_credit = 1039; constexpr StringId everlasting_high_rise = 1040; constexpr StringId everlasting_high_rise_credit = 1041; constexpr StringId solace = 1042; constexpr StringId solace_credit = 1043; constexpr StringId chrysanthemum = 1044; constexpr StringId chrysanthemum_credit = 1045; constexpr StringId eugenia = 1046; constexpr StringId eugenia_credit = 1047; constexpr StringId the_ragtime_dance = 1048; constexpr StringId the_ragtime_dance_credit = 1049; constexpr StringId easy_winners = 1050; constexpr StringId easy_winners_credit = 1051; constexpr StringId setting_off = 1052; constexpr StringId setting_off_credit = 1053; constexpr StringId a_travellers_seranade = 1054; constexpr StringId a_travellers_seranade_credit = 1055; constexpr StringId latino_trip = 1056; constexpr StringId latino_trip_credit = 1057; constexpr StringId a_good_head_of_steam = 1058; constexpr StringId a_good_head_of_steam_credit = 1059; constexpr StringId hop_to_the_bop = 1060; constexpr StringId hop_to_the_bop_credit = 1061; constexpr StringId the_city_lights = 1062; constexpr StringId the_city_lights_credit = 1063; constexpr StringId steamin_down_town = 1064; constexpr StringId steamin_down_town_credit = 1065; constexpr StringId bright_expectations = 1066; constexpr StringId bright_expectations_credit = 1067; constexpr StringId mo_station = 1068; constexpr StringId mo_station_credit = 1069; constexpr StringId far_out = 1070; constexpr StringId far_out_credit = 1071; constexpr StringId running_on_time = 1072; constexpr StringId running_on_time_credit = 1073; constexpr StringId get_me_to_gladstone_bay = 1074; constexpr StringId get_me_to_gladstone_bay_credit = 1075; constexpr StringId chuggin_along = 1076; constexpr StringId chuggin_along_credit = 1077; constexpr StringId dont_lose_your_rag = 1078; constexpr StringId dont_lose_your_rag_credit = 1079; constexpr StringId sandy_track_blues = 1080; constexpr StringId sandy_track_blues_credit = 1081; constexpr StringId error_unable_to_load_saved_game = 1082; constexpr StringId error_file_contains_invalid_data = 1083; constexpr StringId error_file_is_not_single_player_save = 1084; constexpr StringId error_file_is_not_two_player_save = 1085; constexpr StringId please_wait = 1086; constexpr StringId initialising = 1087; constexpr StringId loading = 1088; constexpr StringId installing_new_data = 1089; constexpr StringId white = 1090; constexpr StringId translucent = 1091; constexpr StringId construction_marker = 1092; constexpr StringId vehicles_min_scale = 1093; constexpr StringId station_names_min_scale = 1094; constexpr StringId full_scale = 1095; constexpr StringId half_scale = 1096; constexpr StringId quarter_scale = 1097; constexpr StringId eighth_scale = 1098; constexpr StringId vehicles_min_scale_tip = 1099; constexpr StringId station_names_min_scale_tip = 1100; constexpr StringId main_colour_scheme = 1101; constexpr StringId colour_steam_locomotives = 1102; constexpr StringId colour_diesel_locomotives = 1103; constexpr StringId colour_electric_locomotives = 1104; constexpr StringId colour_multiple_units = 1105; constexpr StringId colour_passenger_vehicles = 1106; constexpr StringId colour_freight_vehicles = 1107; constexpr StringId colour_buses = 1108; constexpr StringId colour_trucks = 1109; constexpr StringId colour_aircraft = 1110; constexpr StringId colour_ships = 1111; constexpr StringId tooltip_company_headquarters_and_details = 1112; constexpr StringId tooltip_company_owner_and_status = 1113; constexpr StringId tooltip_company_finances = 1114; constexpr StringId tooltip_cargo_delivered = 1115; constexpr StringId tooltip_company_colour_scheme = 1116; constexpr StringId tooltip_company_challenge_for_this_game = 1117; constexpr StringId special_colour_schemes_used_for = 1118; constexpr StringId tooltip_select_main_colour = 1119; constexpr StringId tooltip_select_secondary_colour = 1120; constexpr StringId tooltip_toggle_vehicle_colour_scheme = 1121; constexpr StringId stringid_trains = 1122; constexpr StringId stringid_buses = 1123; constexpr StringId stringid_trucks = 1124; constexpr StringId stringid_trams = 1125; constexpr StringId stringid_aircraft = 1126; constexpr StringId stringid_ships = 1127; constexpr StringId stringid_all_stations = 1128; constexpr StringId stringid_rail_stations = 1129; constexpr StringId stringid_road_stations = 1130; constexpr StringId stringid_airports = 1131; constexpr StringId stringid_ship_ports = 1132; constexpr StringId all_stations = 1133; constexpr StringId rail_stations = 1134; constexpr StringId road_stations = 1135; constexpr StringId airports = 1136; constexpr StringId ship_ports = 1137; constexpr StringId vehicle_list_status_2pos = 1138; constexpr StringId vehicle_list_status_3pos = 1139; constexpr StringId vehicle_list_profit_pos = 1140; constexpr StringId vehicle_list_profit_neg = 1141; constexpr StringId vehicle_list_age_year = 1142; constexpr StringId vehicle_list_age_years = 1143; constexpr StringId vehicle_list_reliability = 1144; constexpr StringId table_header_name = 1145; constexpr StringId table_header_name_desc = 1146; constexpr StringId table_header_monthly_profit = 1147; constexpr StringId table_header_monthly_profit_desc = 1148; constexpr StringId table_header_age = 1149; constexpr StringId table_header_age_desc = 1150; constexpr StringId table_header_reliability = 1151; constexpr StringId table_header_reliability_desc = 1152; constexpr StringId tooltip_sort_by_name = 1153; constexpr StringId tooltip_sort_by_profit = 1154; constexpr StringId tooltip_sort_by_age = 1155; constexpr StringId tooltip_sort_by_reliability = 1156; constexpr StringId vehicle_must_be_stopped = 1157; constexpr StringId vehicle_has_crashed = 1158; constexpr StringId vehicle_has_broken_down = 1159; constexpr StringId vehicle_is_stuck = 1160; constexpr StringId not_enough_space_or_vehicle_in_the_way = 1161; constexpr StringId vehicle_approaching_or_in_the_way = 1162; constexpr StringId cant_place_string_id_here = 1163; constexpr StringId cant_remove_string_id = 1164; constexpr StringId cant_pass_signal_at_danger = 1165; constexpr StringId this_vehicle_requires_stringid = 1166; constexpr StringId train_has_no_vehicles = 1167; constexpr StringId train_has_no_driving_cab = 1168; constexpr StringId train_needs_a_locomotive_or_power_car = 1169; constexpr StringId cargo_from = 1170; constexpr StringId cargo_empty = 1171; constexpr StringId cargo_capacity_tooltip = 1172; constexpr StringId cargo_capacity = 1173; constexpr StringId cargo_capacity_plus = 1174; constexpr StringId too_many_stations_in_game = 1175; constexpr StringId station_too_large = 1176; constexpr StringId town_must_be_built_first = 1177; constexpr StringId tab_map_overall = 1178; constexpr StringId tab_map_vehicles = 1179; constexpr StringId tab_map_industries = 1180; constexpr StringId tab_map_routes = 1181; constexpr StringId tab_map_ownership = 1182; constexpr StringId station_too_spread_out = 1183; constexpr StringId cant_add_pop_5_string_id_string_id = 1184; constexpr StringId cant_build_pop_5_string_id = 1185; constexpr StringId select_new_vehicle = 1186; constexpr StringId select_vehicle_to_add_to_string_id = 1187; constexpr StringId tooltip_build_new_train_vehicles = 1188; constexpr StringId tooltip_build_new_buses = 1189; constexpr StringId tooltip_build_new_trucks = 1190; constexpr StringId tooltip_build_new_trams = 1191; constexpr StringId tooltip_build_new_aircraft = 1192; constexpr StringId tooltip_build_new_ships = 1193; constexpr StringId tooltip_trains = 1194; constexpr StringId tooltip_buses = 1195; constexpr StringId tooltip_trucks = 1196; constexpr StringId tooltip_trams = 1197; constexpr StringId tooltip_aircraft = 1198; constexpr StringId tooltip_ships = 1199; constexpr StringId tooltip_all_stations = 1200; constexpr StringId tooltip_rail_stations = 1201; constexpr StringId tooltip_road_stations = 1202; constexpr StringId tooltip_airports = 1203; constexpr StringId tooltip_ship_ports = 1204; constexpr StringId tooltip_clear_land = 1205; constexpr StringId tooltip_plant_trees = 1206; constexpr StringId tooltip_adjust_land = 1207; constexpr StringId tooltip_adjust_water = 1208; constexpr StringId tooltip_build_walls = 1209; constexpr StringId tooltip_object_colour = 1210; constexpr StringId station_cargo = 1211; constexpr StringId station_cargo_en_route_start = 1212; constexpr StringId station_cargo_en_route_end = 1213; constexpr StringId no_space_for_more_vehicle_orders = 1214; constexpr StringId tooManyOrdersForThisVehicle = 1215; constexpr StringId local_mode_button = 1216; constexpr StringId express_mode_button = 1217; constexpr StringId no_route_defined = 1218; constexpr StringId orders_end = 1219; constexpr StringId orders_stop_at = 1220; constexpr StringId orders_route_through = 1221; constexpr StringId orders_route_thought_waypoint = 1222; constexpr StringId orders_unload_all = 1223; constexpr StringId orders_wait_for_full_load_of = 1224; constexpr StringId orders_unload_all2 = 1225; constexpr StringId orders_wait_for_full_load_of2 = 1226; constexpr StringId orders_current_order = 1227; constexpr StringId orders_cant_insert = 1228; constexpr StringId click_to_insert_new_order_route_through = 1229; constexpr StringId click_to_insert_new_order_stop_at = 1230; constexpr StringId click_again_to_change_last_order_route_through = 1231; constexpr StringId tooltip_route_insert_wait_full_cargo = 1232; constexpr StringId tooltip_route_insert_force_unload = 1233; constexpr StringId tooltip_route_skip_next_order = 1234; constexpr StringId tooltip_route_delete_order = 1235; constexpr StringId route_click_on_waypoint = 1236; constexpr StringId tooltip_route_scrollview = 1237; constexpr StringId tooltip_route_scrollview_copy = 1238; constexpr StringId stringid_stringid_wcolour3_stringid = 1239; constexpr StringId build_trains = 1240; constexpr StringId build_buses = 1241; constexpr StringId build_trucks = 1242; constexpr StringId build_trams = 1243; constexpr StringId build_aircraft = 1244; constexpr StringId build_ships = 1245; constexpr StringId can_only_be_placed_on_stringid = 1246; constexpr StringId road = 1247; constexpr StringId no_vehicles_available = 1248; constexpr StringId no_compatible_vehicles_available = 1249; constexpr StringId buffer_1250 = 1250; constexpr StringId stats_cost = 1251; constexpr StringId stats_requires = 1252; constexpr StringId stats_power = 1253; constexpr StringId stats_weight = 1254; constexpr StringId stats_max_speed = 1255; constexpr StringId stats_designed = 1256; constexpr StringId stats_capacity = 1257; constexpr StringId stats_plus_string = 1258; constexpr StringId stats_string_steep_slope = 1259; constexpr StringId stats_velocity_on_string = 1260; constexpr StringId stats_or_string = 1261; constexpr StringId stats_running_cost = 1262; constexpr StringId stats_refittable = 1263; constexpr StringId num_trains_singular = 1264; constexpr StringId num_buses_singular = 1265; constexpr StringId num_trucks_singular = 1266; constexpr StringId num_trams_singular = 1267; constexpr StringId num_aircrafts_singular = 1268; constexpr StringId num_ships_singular = 1269; constexpr StringId num_trains_plural = 1270; constexpr StringId num_buses_plural = 1271; constexpr StringId num_trucks_plural = 1272; constexpr StringId num_trams_plural = 1273; constexpr StringId num_aircrafts_plural = 1274; constexpr StringId num_ships_plural = 1275; constexpr StringId train = 1276; constexpr StringId bus = 1277; constexpr StringId truck = 1278; constexpr StringId tram = 1279; constexpr StringId aircraft = 1280; constexpr StringId ship = 1281; constexpr StringId total_stringid = 1282; constexpr StringId cargo_empty_2 = 1283; constexpr StringId vehicle_list_tooltip_load = 1284; constexpr StringId requires_an_extra_stringid = 1285; constexpr StringId tooltip_vehicles_for = 1286; constexpr StringId menu_sprite_stringid = 1287; constexpr StringId menu_nosprite_stringid = 1288; constexpr StringId menu_sprite_stringid_construction = 1289; constexpr StringId local_authority_refuses_permission = 1290; constexpr StringId title_towns = 1291; constexpr StringId title_build_new_towns = 1292; constexpr StringId title_build_new_buildings = 1293; constexpr StringId title_build_new_misc_buildings = 1294; constexpr StringId table_header_population = 1295; constexpr StringId table_header_population_desc = 1296; constexpr StringId tooltip_sort_population = 1297; constexpr StringId int_32 = 1298; constexpr StringId table_header_stations = 1299; constexpr StringId table_header_stations_desc = 1300; constexpr StringId tooltip_sort_stations = 1301; constexpr StringId town_size_and_population = 1304; constexpr StringId tooltip_sort_town_type = 1305; constexpr StringId table_header_town_type = 1306; constexpr StringId table_header_town_type_desc = 1307; constexpr StringId title_town_name = 1308; constexpr StringId prompt_type_new_town_name = 1309; constexpr StringId status_town_population = 1310; constexpr StringId error_cant_rename_town = 1311; constexpr StringId new_station = 1312; constexpr StringId new_station_buffer = 1313; constexpr StringId catchment_area_accepts = 1314; constexpr StringId catchment_area_produces = 1315; constexpr StringId catchment_area_nothing = 1316; constexpr StringId too_many_industries = 1317; constexpr StringId title_industries = 1318; constexpr StringId title_fund_new_industries = 1319; constexpr StringId title_build_new_industries = 1320; constexpr StringId tooltip_town_list = 1321; constexpr StringId tooltip_build_town = 1322; constexpr StringId tooltip_build_buildings = 1323; constexpr StringId tooltip_build_misc_buildings = 1324; constexpr StringId tooltip_industries_list = 1325; constexpr StringId tooltip_fund_new_industries = 1326; constexpr StringId tooltip_build_new_industries = 1327; constexpr StringId company_ai_name_ebony = 1328; constexpr StringId company_ai_name_silver = 1329; constexpr StringId company_ai_name_ivory = 1330; constexpr StringId company_ai_name_indigo = 1331; constexpr StringId company_ai_name_sapphire = 1332; constexpr StringId company_ai_name_emerald = 1333; constexpr StringId company_ai_name_golden = 1334; constexpr StringId company_ai_name_amber = 1335; constexpr StringId company_ai_name_bronze = 1336; constexpr StringId company_ai_name_burgundy = 1337; constexpr StringId company_ai_name_scarlet = 1338; constexpr StringId company_ai_name_string = 1339; constexpr StringId company_ai_name_pop_string = 1340; constexpr StringId company_ai_name_string_transport = 1341; constexpr StringId company_ai_name_string_express = 1342; constexpr StringId company_ai_name_string_lines = 1343; constexpr StringId company_ai_name_string_tracks = 1344; constexpr StringId company_ai_name_string_coaches = 1345; constexpr StringId company_ai_name_string_air = 1346; constexpr StringId company_ai_name_string_rail = 1347; constexpr StringId company_ai_name_string_carts = 1348; constexpr StringId company_ai_name_string_trains = 1349; constexpr StringId company_ai_name_string_haulage = 1350; constexpr StringId company_ai_name_string_shipping = 1351; constexpr StringId company_ai_name_string_freight = 1352; constexpr StringId company_ai_name_string_trucks = 1353; constexpr StringId wcolour2_headquarters = 1354; constexpr StringId window_owner = 1355; constexpr StringId interest_per_year = 1356; constexpr StringId population_graph_people = 1357; constexpr StringId population_graph_year = 1358; constexpr StringId title_town = 1359; constexpr StringId title_town_population = 1360; constexpr StringId title_town_local_authority = 1361; constexpr StringId title_industry_monthly_production = 1362; constexpr StringId title_statistics = 1363; constexpr StringId title_station = 1364; constexpr StringId demolish_this_industry = 1365; constexpr StringId industry_under_construction = 1366; constexpr StringId industry_producing = 1367; constexpr StringId industry_produces = 1368; constexpr StringId industry_produce = 1369; constexpr StringId cargo_to_produce = 1370; constexpr StringId industry_requires = 1371; constexpr StringId industry_require = 1372; constexpr StringId cargo_and = 1373; constexpr StringId cargo_or = 1374; constexpr StringId cargo_comma = 1375; constexpr StringId sort_industry_status = 1376; constexpr StringId sort_industry_production_transported = 1377; constexpr StringId industry_table_header_status = 1378; constexpr StringId industry_table_header_status_desc = 1379; constexpr StringId industry_table_header_production = 1380; constexpr StringId industry_table_header_production_desc = 1381; constexpr StringId sort_industry_name = 1382; constexpr StringId industry_table_header = 1383; constexpr StringId industry_table_header_desc = 1384; constexpr StringId no_industry_available = 1385; constexpr StringId tooltip_town = 1386; constexpr StringId tooltip_population_graph = 1387; constexpr StringId tooltip_town_ratings_each_company = 1388; constexpr StringId tooltip_industry = 1389; constexpr StringId tooltip_production_graph = 1390; constexpr StringId production_graph_label = 1391; constexpr StringId demolish_this_town = 1392; constexpr StringId cant_remove_town = 1393; constexpr StringId all_stations_near_this_town_must_be_removed_first = 1394; constexpr StringId too_close_to_another_town = 1395; constexpr StringId too_many_towns = 1396; constexpr StringId too_close_to_another_town_position_is_unsuitable = 1397; constexpr StringId tooltip_select_town_size = 1398; constexpr StringId town_size_1 = 1399; constexpr StringId town_size_2 = 1400; constexpr StringId town_size_3 = 1401; constexpr StringId town_size_4 = 1402; constexpr StringId town_size_5 = 1403; constexpr StringId town_size_6 = 1404; constexpr StringId town_size_7 = 1405; constexpr StringId town_size_8 = 1406; constexpr StringId town_size_label = 1407; constexpr StringId select_town_size = 1408; constexpr StringId expand_this_town = 1409; constexpr StringId too_close_to_another_industry = 1410; constexpr StringId town_must_be_built_nearby_first = 1410; constexpr StringId plant_cluster_selected_tree = 1412; constexpr StringId plant_cluster_random_tree = 1413; constexpr StringId tooltip_statistics = 1414; constexpr StringId received_cargo = 1415; constexpr StringId produced_cargo = 1416; constexpr StringId transported_cargo = 1417; constexpr StringId production_transported_percent = 1418; constexpr StringId industry_closing_down = 1419; constexpr StringId error_reason_belongs_to = 1420; constexpr StringId error_reason_stringid_belongs_to = 1421; constexpr StringId error_reason_signal_belongs_to = 1422; constexpr StringId station_cargo_rating_percent = 1423; constexpr StringId news_date = 1424; constexpr StringId title_messages = 1425; constexpr StringId tooltip_recent_messages = 1426; constexpr StringId tooltip_message_options = 1427; constexpr StringId title_message_options = 1428; constexpr StringId tiny_font_date = 1429; constexpr StringId waiting_cargo_separator = 1430; constexpr StringId waiting = 1431; constexpr StringId nothing_waiting = 1432; constexpr StringId table_header_status = 1433; constexpr StringId table_header_status_desc = 1434; constexpr StringId table_header_total_waiting = 1435; constexpr StringId table_header_total_waiting_desc = 1436; constexpr StringId table_header_accepts = 1437; constexpr StringId table_header_accepts_desc = 1438; constexpr StringId tooltip_sort_by_station_status = 1439; constexpr StringId tooltip_sort_by_total_units_waiting = 1440; constexpr StringId tooltip_sort_by_cargo_accepted = 1441; constexpr StringId num_units = 1442; constexpr StringId unit_separator = 1443; constexpr StringId station_accepts = 1444; constexpr StringId accepted_cargo_separator = 1445; constexpr StringId cargo_nothing_accepted = 1446; constexpr StringId tooltip_station = 1447; constexpr StringId tooltip_station_cargo = 1448; constexpr StringId tooltip_station_cargo_ratings = 1449; constexpr StringId demolition_not_allowed = 1450; constexpr StringId another_company_is_about_to_build_here = 1451; constexpr StringId vehicle_too_long = 1452; constexpr StringId tooltip_build_or_move_headquarters = 1453; constexpr StringId tooltip_change_owner_name = 1454; constexpr StringId not_yet_constructed = 1455; constexpr StringId title_name_company = 1456; constexpr StringId prompt_enter_new_company_name = 1457; constexpr StringId cannot_rename_this_company = 1458; constexpr StringId title_name_owner = 1459; constexpr StringId prompt_enter_new_name_for_owner = 1460; constexpr StringId cannot_change_owner_name = 1461; constexpr StringId headquarters = 1462; constexpr StringId stringid_headquarters = 1463; constexpr StringId stringid_local_authority_wont_allow_removal_in_use = 1464; constexpr StringId tooltip_select_company = 1465; constexpr StringId enter_host_address = 1483; constexpr StringId enter_host_address_description = 1484; constexpr StringId tooltip_display_options = 1486; constexpr StringId tooltip_sound_options = UNUSED_STR(1487); constexpr StringId tooltip_music_options = UNUSED_STR(1488); constexpr StringId tooltip_regional_options = 1489; constexpr StringId tooltip_control_options = 1490; constexpr StringId tooltip_miscellaneous_options = 1491; constexpr StringId options_title_display = 1492; constexpr StringId options_title_sound = UNUSED_STR(1493); constexpr StringId options_title_music = UNUSED_STR(1494); constexpr StringId options_title_regional = 1495; constexpr StringId options_title_controls = 1496; constexpr StringId options_title_miscellaneous = 1497; constexpr StringId use_preferred_currency_always = 1498; constexpr StringId use_preferred_currency_always_tip = 1499; constexpr StringId use_preferred_currency_new_game = 1500; constexpr StringId use_preferred_currency_new_game_tip = 1501; constexpr StringId current_game_currency_tip = 1502; constexpr StringId new_game_currency_tip = 1503; constexpr StringId current_game_currency = 1504; constexpr StringId new_game_currency = 1505; constexpr StringId preferred_currency_buffer = 1506; constexpr StringId company_major_news = 1507; constexpr StringId competitor_major_news = 1508; constexpr StringId company_minor_news = 1509; constexpr StringId competitor_minor_news = 1510; constexpr StringId general_news = 1511; constexpr StringId advice = 1512; constexpr StringId message_off = 1513; constexpr StringId message_ticker = 1514; constexpr StringId message_window = 1515; constexpr StringId vehicle_monthly_running_cost = 1516; constexpr StringId vehicle_monthly_profit = 1517; constexpr StringId forbid_trains = 1518; constexpr StringId forbid_buses = 1519; constexpr StringId forbid_trucks = 1520; constexpr StringId forbid_trams = 1521; constexpr StringId forbid_aircraft = 1522; constexpr StringId forbid_ships = 1523; constexpr StringId title_airport = 1524; constexpr StringId title_ship_port = 1525; constexpr StringId orderTypeNotValidForAircraft = 1526; constexpr StringId orderTypeNotValidForShips = 1527; constexpr StringId stationOwnedByAnotherCompany = 1528; constexpr StringId noWater = 1529; constexpr StringId water_channel_currently_needed_by_ships = 1530; constexpr StringId currently_in_use_by_at_least_one_vehicle = 1531; constexpr StringId refit_vehicle_tip = 1532; constexpr StringId cant_refit_vehicle = 1533; constexpr StringId requires_water_in_front_of_dock = 1534; constexpr StringId currently_playing = 1535; constexpr StringId music_controls_stop_tip = 1536; constexpr StringId music_controls_play_tip = 1537; constexpr StringId music_controls_next_tip = 1538; constexpr StringId play_only_music_from_current_era = 1539; constexpr StringId play_all_music = 1540; constexpr StringId play_custom_music_selection = 1541; constexpr StringId edit_music_selection = 1542; constexpr StringId edit_music_selection_tip = 1543; constexpr StringId music_selection_title = 1544; constexpr StringId music_selection_tooltip = 1545; constexpr StringId checkmark = 1546; constexpr StringId volume = UNUSED_STR(1547); constexpr StringId set_music_volume_tip = 1548; constexpr StringId menu_music_options = 1549; constexpr StringId company_face_selection_title = 1550; constexpr StringId tooltip_company_face_selection = 1551; constexpr StringId already_selected_for_another_company = 1552; constexpr StringId cant_select_face = 1553; constexpr StringId airport = 1554; constexpr StringId docks = 1555; constexpr StringId company_details_started = 1556; constexpr StringId company_details_performance = 1557; constexpr StringId company_details_performance_decreasing = 1558; constexpr StringId company_details_performance_increasing = 1559; constexpr StringId owner_label = 1560; constexpr StringId low = 1561; constexpr StringId medium = 1562; constexpr StringId high = 1563; constexpr StringId company_details_intelligence = 1564; constexpr StringId company_details_aggressiveness = 1565; constexpr StringId company_details_competitiveness = 1566; constexpr StringId title_multiplayer_toggle_tooltip = 1567; constexpr StringId single_player_mode = 1568; constexpr StringId two_player_mode_connected = 1569; constexpr StringId scenario_group_beginner = 1570; constexpr StringId scenario_group_easy = 1571; constexpr StringId scenario_group_medium = 1572; constexpr StringId scenario_group_challenging = 1573; constexpr StringId scenario_group_expert = 1574; constexpr StringId editor_step_object_selection = 1575; constexpr StringId editor_step_landscape = 1576; constexpr StringId editor_step_options = 1577; constexpr StringId editor_step_save = 1578; constexpr StringId editor_previous_step = 1579; constexpr StringId editor_next_step = 1580; constexpr StringId load_landscape = 1581; constexpr StringId save_landscape = 1582; constexpr StringId generating_landscape = 1583; constexpr StringId error_cant_clear_entire_area = 1584; constexpr StringId title_landscape_generation_options = 1585; constexpr StringId title_landscape_generation_land = 1586; constexpr StringId title_landscape_generation_forests = 1587; constexpr StringId title_landscape_generation_towns = 1588; constexpr StringId title_landscape_generation_industries = 1589; constexpr StringId tooltip_landscape_generation_options = 1590; constexpr StringId tooltip_landscape_generation_land = 1591; constexpr StringId tooltip_landscape_generation_forests = 1592; constexpr StringId tooltip_landscape_generation_towns = 1593; constexpr StringId tooltip_landscape_generation_industries = 1594; constexpr StringId music_none = 1595; constexpr StringId music_chuggin_along = 1596; constexpr StringId music_long_dusty_road = 1597; constexpr StringId music_flying_high = 1598; constexpr StringId music_gettin_on_the_gas = 1599; constexpr StringId music_jumpin_the_rails = 1600; constexpr StringId music_smooth_running = 1601; constexpr StringId music_traffic_jam = 1602; constexpr StringId music_never_stop_til_you_get_there = 1603; constexpr StringId music_soaring_away = 1604; constexpr StringId music_techno_torture = 1605; constexpr StringId music_everlasting_high_rise = 1606; constexpr StringId music_solace = 1607; constexpr StringId music_chrysanthemum = 1608; constexpr StringId music_eugenia = 1609; constexpr StringId music_the_ragtime_dance = 1610; constexpr StringId music_easy_winners = 1611; constexpr StringId music_setting_off = 1612; constexpr StringId music_a_travellers_serenade = 1613; constexpr StringId music_latino_trip = 1614; constexpr StringId music_a_good_head_of_steam = 1615; constexpr StringId music_hop_to_the_bop = 1616; constexpr StringId music_the_city_lights = 1617; constexpr StringId music_steamin_down_town = 1618; constexpr StringId music_bright_expectations = 1619; constexpr StringId music_mo_station = 1620; constexpr StringId music_far_out = 1621; constexpr StringId music_running_on_time = 1622; constexpr StringId music_get_me_to_gladstone_bay = 1623; constexpr StringId music_sandy_track_blues = 1624; constexpr StringId start_year_value = 1625; constexpr StringId start_year = 1626; constexpr StringId label_generate_random_landscape_when_game_starts = 1627; constexpr StringId tooltip_generate_random_landscape_when_game_starts = 1628; constexpr StringId button_generate_landscape = 1629; constexpr StringId tooltip_generate_random_landscape = 1630; constexpr StringId label_ok = 1631; constexpr StringId title_generate_new_landscape = 1632; constexpr StringId title_random_landscape_option = 1633; constexpr StringId prompt_confirm_generate_landscape = 1634; constexpr StringId prompt_confirm_random_landscape = 1635; constexpr StringId sea_level = 1636; constexpr StringId sea_level_units = 1637; constexpr StringId number_of_forests = 1638; constexpr StringId number_of_forests_value = 1639; constexpr StringId min_forest_radius = 1640; constexpr StringId min_forest_radius_blocks = 1641; constexpr StringId max_forest_radius = 1642; constexpr StringId max_forest_radius_blocks = 1643; constexpr StringId min_forest_density = 1644; constexpr StringId min_forest_density_percent = 1645; constexpr StringId max_forest_density = 1646; constexpr StringId max_forest_density_percent = 1647; constexpr StringId number_random_trees = 1648; constexpr StringId number_random_trees_value = 1649; constexpr StringId min_altitude_for_trees = 1650; constexpr StringId min_altitude_for_trees_height = 1651; constexpr StringId max_altitude_for_trees = 1652; constexpr StringId max_altitude_for_trees_height = 1653; constexpr StringId min_land_height = 1654; constexpr StringId min_land_height_units = 1655; constexpr StringId topography_style = 1656; constexpr StringId flat_land = 1657; constexpr StringId small_hills = 1658; constexpr StringId mountains = 1659; constexpr StringId half_mountains_half_hills = 1660; constexpr StringId half_mountains_half_flat = 1661; constexpr StringId hill_density = 1662; constexpr StringId hill_density_percent = 1663; constexpr StringId number_of_towns = 1664; constexpr StringId number_of_towns_value = 1665; constexpr StringId max_town_size = 1666; constexpr StringId industry_size_low = 1667; constexpr StringId industry_size_medium = 1668; constexpr StringId industry_size_high = 1669; constexpr StringId number_of_industries = 1670; constexpr StringId at_least_one_town_be_built = 1671; constexpr StringId cant_advance_to_next_editor_stage = 1672; constexpr StringId str_1673 = 1673; constexpr StringId tooltip_scenario_options = 1674; constexpr StringId tooltip_scenario_challenge = 1675; constexpr StringId tooltip_company_options = 1676; constexpr StringId tooltip_financial_options = 1677; constexpr StringId title_scenario_options = 1678; constexpr StringId title_scenario_challenge = 1679; constexpr StringId title_company_options = 1680; constexpr StringId title_financial_options = 1681; constexpr StringId max_competing_companies = 1682; constexpr StringId max_competing_companies_value = 1683; constexpr StringId delay_before_competing_companies_start = 1684; constexpr StringId delay_before_competing_companies_start_months = 1685; constexpr StringId selection_of_competing_companies = 1686; constexpr StringId preferred_intelligence = 1687; constexpr StringId preferred_aggressiveness = 1688; constexpr StringId preferred_competitiveness = 1689; constexpr StringId preference_any = 1690; constexpr StringId preference_low = 1691; constexpr StringId preference_medium = 1692; constexpr StringId preference_high = 1693; constexpr StringId starting_loan = 1694; constexpr StringId starting_loan_value = 1695; constexpr StringId max_loan_size = 1696; constexpr StringId max_loan_size_value = 1697; constexpr StringId loan_interest_rate = 1698; constexpr StringId loan_interest_rate_value = 1699; constexpr StringId change = 1700; constexpr StringId scenario_name_stringid = 1701; constexpr StringId scenario_group = 1702; constexpr StringId scenario_details = 1703; constexpr StringId scenario_name_title = 1704; constexpr StringId enter_name_for_scenario = 1705; constexpr StringId scenario_details_title = 1706; constexpr StringId enter_description_of_this_scenario = 1707; constexpr StringId no_details_yet = 1708; constexpr StringId unnamed = 1709; constexpr StringId landscape_save_failed = 1710; constexpr StringId scenario_save_failed = 1711; constexpr StringId chat_send_message = 1716; constexpr StringId chat_title = 1717; constexpr StringId chat_instructions = 1718; constexpr StringId buffer_1719 = 1719; constexpr StringId object_selection_designed = 1723; constexpr StringId object_selection_obsolete = 1724; constexpr StringId object_selection_power = 1725; constexpr StringId object_selection_weight = 1726; constexpr StringId object_selection_max_speed = 1727; constexpr StringId object_selection_capacity = 1728; constexpr StringId land_distribution_everywhere = 1730; constexpr StringId land_distribution_nowhere = 1731; constexpr StringId land_distribution_far_from_water = 1732; constexpr StringId land_distribution_near_water = 1733; constexpr StringId land_distribution_on_mountains = 1734; constexpr StringId land_distribution_far_from_mountains = 1735; constexpr StringId land_distribution_in_small_random_areas = 1736; constexpr StringId land_distribution_in_large_random_areas = 1737; constexpr StringId land_distribution_around_cliffs = 1738; constexpr StringId create_hills_right_up_to_edge_of_map = 1739; constexpr StringId title_menu_scenario_editor = 1740; constexpr StringId company_owner_name_transport = 1741; constexpr StringId menu_map = 1742; constexpr StringId dropdown_companies_list = 1743; constexpr StringId dropdown_company_performance = 1744; constexpr StringId title_company_list = 1745; constexpr StringId title_company_performance = 1746; constexpr StringId title_company_cargo_units = 1747; constexpr StringId title_company_values = 1748; constexpr StringId title_cargo_payment_rates = 1749; constexpr StringId tab_compare_companies = 1750; constexpr StringId tab_company_performance = 1751; constexpr StringId tab_cargo_graphs = 1752; constexpr StringId tab_company_values = 1753; constexpr StringId tab_cargo_payment_rates = 1754; constexpr StringId tooltip_sort_company_name = 1755; constexpr StringId tooltip_sort_company_status = 1756; constexpr StringId tooltip_sort_company_performance = 1757; constexpr StringId tooltip_sort_company_value = 1758; constexpr StringId table_header_company_name = 1759; constexpr StringId table_header_company_name_desc = 1760; constexpr StringId table_header_company_status = 1761; constexpr StringId table_header_company_status_desc = 1762; constexpr StringId table_header_company_performance = 1763; constexpr StringId table_header_company_performance_desc = 1764; constexpr StringId table_header_company_value = 1765; constexpr StringId table_header_company_value_desc = 1766; constexpr StringId table_item_company = 1767; constexpr StringId performance_index = 1768; constexpr StringId performance_index_decrease = 1769; constexpr StringId performance_index_increase = 1770; constexpr StringId company_value_currency = 1771; constexpr StringId corporate_rating_platelayer = 1772; constexpr StringId corporate_rating_engineer = 1773; constexpr StringId corporate_rating_traffic_manager = 1774; constexpr StringId corporate_rating_transport_coordinator = 1775; constexpr StringId corporate_rating_route_supervisor = 1776; constexpr StringId corporate_rating_director = 1777; constexpr StringId corporate_rating_chief_executive = 1778; constexpr StringId corporate_rating_chairman = 1779; constexpr StringId corporate_rating_president = 1780; constexpr StringId corporate_rating_tycoon = 1781; constexpr StringId company_singular = 1782; constexpr StringId companies_plural = 1783; constexpr StringId rawdate_short = 1784; constexpr StringId percentage_one_decimal_place = 1785; constexpr StringId graph_label_format = 1786; constexpr StringId cargo_units_delivered = 1787; constexpr StringId player_info_performance = 1788; constexpr StringId player_info_performance_decrease = 1789; constexpr StringId player_info_performance_increase = 1790; constexpr StringId small_company_value_currency = 1791; constexpr StringId small_black_string = 1792; constexpr StringId small_white_string = 1793; constexpr StringId airport_type_not_suitable_for_aircraft = 1794; constexpr StringId currency_symbol = 1795; constexpr StringId cargo_delivered_days = 1796; constexpr StringId cargo_delivered_currency = 1797; constexpr StringId cargo_deliver_graph_title = 1798; constexpr StringId cargo_transit_time = 1799; constexpr StringId toolbar_status_paused = 1800; constexpr StringId town_will_not_allow_airport_to_be_built_here = 1801; constexpr StringId map_key_towns = 1802; constexpr StringId map_key_industries = 1803; constexpr StringId map_key_roads = 1804; constexpr StringId map_key_railways = 1805; constexpr StringId map_key_stations = 1806; constexpr StringId map_key_vegetation = 1807; constexpr StringId map_routes_aircraft = 1808; constexpr StringId map_routes_ships = 1809; constexpr StringId company_status_empty = 1810; constexpr StringId company_status_building_track_road = 1811; constexpr StringId company_status_building_airport = 1812; constexpr StringId company_status_building_dock = 1813; constexpr StringId company_status_checking_services = 1814; constexpr StringId company_status_surveying_landscape = 1815; constexpr StringId company_status_bankrupt = 1816; constexpr StringId tooltip_speed_pause = 1817; constexpr StringId tooltip_speed_normal = 1818; constexpr StringId tooltip_speed_fast_forward = 1819; constexpr StringId tooltip_speed_extra_fast_forward = 1820; constexpr StringId randomly_generated_landscape = 1821; constexpr StringId challenge_start_date = 1822; constexpr StringId challenge_competing_companies_none = 1823; constexpr StringId challenge_competing_companies_up_to = 1824; constexpr StringId competition_not_starting_for_month = 1825; constexpr StringId competition_not_starting_for_months = 1826; constexpr StringId sale_value_of_vehicle = 1827; constexpr StringId last_income_na = 1828; constexpr StringId last_income_on_date = 1829; constexpr StringId transported_blocks_in_days = 1830; constexpr StringId building_earliest_construction_year = 1831; constexpr StringId building_latest_construction_year = 1832; constexpr StringId local_authority_ratings_transport_companies = 1833; constexpr StringId town_rating_appalling = 1834; constexpr StringId town_rating_poor = 1835; constexpr StringId town_rating_average = 1836; constexpr StringId town_rating_good = 1837; constexpr StringId town_rating_excellent = 1838; constexpr StringId town_rating_company_percentage_rank = 1839; constexpr StringId achieve_a_company_value_of = 1840; constexpr StringId achieve_a_monthly_profit_from_vehicles_of = 1841; constexpr StringId achieve_a_performance_index_of = 1842; constexpr StringId deliver = 1843; constexpr StringId and_be_the_top_performing_company = 1844; constexpr StringId and_be_one_of_the_top_3_performing_companies = 1845; constexpr StringId within_years = 1846; constexpr StringId by_the_end_of = 1847; constexpr StringId and_be_the_top_company = 1848; constexpr StringId and_be_within_the_top_companies = 1849; constexpr StringId with_a_time_limit = 1850; constexpr StringId challenge_label = 1851; constexpr StringId challenge_value = 1852; constexpr StringId objective_achieve_a_certain_company_value = 1853; constexpr StringId objective_achieve_a_certain_monthly_profit_from_vehicles = 1854; constexpr StringId objective_achieve_a_certain_performance_index = 1855; constexpr StringId objective_deliver_a_certain_amount_of_cargo = 1856; constexpr StringId challenge_monetary_value = 1857; constexpr StringId challenge_performance_index = 1858; constexpr StringId challenge_delivered_cargo = 1859; constexpr StringId time_limit_years_value = 1860; constexpr StringId completed_by_name_in_years_months = 1861; constexpr StringId success_you_completed_the_challenge_in_years_months = 1862; constexpr StringId failed_you_failed_to_complete_the_challenge = 1863; constexpr StringId beaten_by_other_player_completed_in_years_months = 1864; constexpr StringId progress_towards_completing_challenge_percent = 1865; constexpr StringId time_remaining_years_months = 1866; constexpr StringId cargo_delivered = 1867; constexpr StringId cargo_delivered_none = 1868; constexpr StringId title_exit_game = 1869; constexpr StringId company_is_bankrupt = 1870; constexpr StringId allow_industries_to_close_down_during_game = 1871; constexpr StringId allow_new_industries_to_start_up_during_game = 1872; constexpr StringId forbid_competing_companies_from_using = 1875; constexpr StringId forbid_player_companies_from_using = 1876; constexpr StringId vehicle_list_tooltip_stops_at_stringid = 1877; constexpr StringId vehicle_list_tooltip_comma_stringid = 1878; constexpr StringId tutorial_1_title = 1879; constexpr StringId tutorial_2_title = 1880; constexpr StringId tutorial_3_title = 1881; constexpr StringId tutorial_1_string_1 = 1882; constexpr StringId tutorial_1_string_2 = 1883; constexpr StringId tutorial_1_string_3 = 1884; constexpr StringId tutorial_1_string_4 = 1885; constexpr StringId tutorial_1_string_5 = 1886; constexpr StringId tutorial_1_string_6 = 1887; constexpr StringId tutorial_1_string_7 = 1888; constexpr StringId tutorial_1_string_8 = 1889; constexpr StringId tutorial_1_string_9 = 1890; constexpr StringId tutorial_1_string_10 = 1891; constexpr StringId tutorial_1_string_11 = 1892; constexpr StringId tutorial_1_string_12 = 1893; constexpr StringId tutorial_1_string_13 = 1894; constexpr StringId tutorial_1_string_14 = 1895; constexpr StringId tutorial_1_string_15 = 1896; constexpr StringId tutorial_1_string_16 = 1897; constexpr StringId tutorial_1_string_17 = 1898; constexpr StringId tutorial_2_string_1 = 1899; constexpr StringId tutorial_2_string_2 = 1900; constexpr StringId tutorial_2_string_3 = 1901; constexpr StringId tutorial_2_string_4 = 1902; constexpr StringId tutorial_2_string_5 = 1903; constexpr StringId tutorial_2_string_6 = 1904; constexpr StringId tutorial_2_string_7 = 1905; constexpr StringId tutorial_2_string_8 = 1906; constexpr StringId tutorial_2_string_9 = 1907; constexpr StringId tutorial_2_string_10 = 1908; constexpr StringId tutorial_2_string_11 = 1909; constexpr StringId tutorial_3_string_1 = 1910; constexpr StringId tutorial_3_string_2 = 1911; constexpr StringId tutorial_3_string_3 = 1912; constexpr StringId tutorial_3_string_4 = 1913; constexpr StringId tutorial_3_string_5 = 1914; constexpr StringId tutorial_3_string_6 = 1915; constexpr StringId tutorial_3_string_7 = 1916; constexpr StringId tutorial_3_string_8 = 1917; constexpr StringId tutorial_3_string_9 = 1918; constexpr StringId use_preferred_owner_name = 1919; constexpr StringId use_preferred_owner_name_tip = 1920; constexpr StringId wcolour2_preferred_owner_name = 1921; constexpr StringId title_preferred_owner_name = 1922; constexpr StringId enter_preferred_owner_name = 1923; constexpr StringId tiny_power = 1924; constexpr StringId tiny_brake = 1925; constexpr StringId tooltip_route_move_order_up = 1926; constexpr StringId tooltip_route_move_order_down = 1927; constexpr StringId atari_inc_credits_btn = UNUSED_STR(1929); constexpr StringId licenced_to_atari_inc = 1930; constexpr StringId atari_inc_credits_caption = UNUSED_STR(1931); constexpr StringId title_menu_chat_tooltip = 1933; constexpr StringId the_other_player = 1934; constexpr StringId error_the_other_player_has_exited_the_game = 1935; constexpr StringId intro_notice_0 = 1936; constexpr StringId intro_notice_1 = 1937; constexpr StringId intro_vehicle_notice_0 = 1938; constexpr StringId intro_vehicle_notice_1 = 1939; constexpr StringId intro_vehicle_notice_2 = 1940; constexpr StringId intro_vehicle_notice_3 = 1941; constexpr StringId intro_vehicle_notice_4 = 1942; // String ids 1943--1982 (some blank) were used in the Atari credits screen, but are now unused. constexpr StringId title_cargo_distance_graphs = 1983; constexpr StringId tab_cargo_distance_graphs = 1984; constexpr StringId last_journey_average_speed = 1985; constexpr StringId land = 1986; constexpr StringId air = 1987; constexpr StringId water = 1988; constexpr StringId train_2 = 1989; constexpr StringId bus_2 = 1990; constexpr StringId truck_2 = 1991; constexpr StringId tram_2 = 1992; constexpr StringId aircraft_2 = 1993; constexpr StringId ship_2 = 1994; constexpr StringId tab_speed_records = 1995; constexpr StringId title_speed_records = 1996; constexpr StringId land_speed_record = 1997; constexpr StringId air_speed_record = 1998; constexpr StringId water_speed_record = 1999; constexpr StringId record_date_achieved = 2000; constexpr StringId window_browse_input_caret = 2003; constexpr StringId window_browse_filename = 2004; constexpr StringId window_browse_folder = 2005; constexpr StringId window_browse_parent_folder_tooltip = 2006; constexpr StringId window_browse_company = 2007; constexpr StringId window_browse_date = 2008; constexpr StringId window_browse_challenge_progress = 2009; constexpr StringId window_browse_challenge_completed = 2010; constexpr StringId window_browse_challenge_failed = 2011; constexpr StringId replace_existing_file_prompt = 2012; constexpr StringId replace_existing_file_button = 2013; constexpr StringId delete_file_prompt = 2014; constexpr StringId delete_file_button = 2015; constexpr StringId error_invalid_filename = 2016; constexpr StringId title_industry_name = 2017; constexpr StringId prompt_enter_new_industry_name = 2018; constexpr StringId error_cant_rename_industry = 2019; constexpr StringId dropdown_bridge_stats = 2020; constexpr StringId position_1st = 2023; constexpr StringId position_2nd = 2024; constexpr StringId position_3rd = 2025; constexpr StringId position_4th = 2026; constexpr StringId position_5th = 2027; constexpr StringId position_6th = 2028; constexpr StringId position_7th = 2029; constexpr StringId position_8th = 2030; constexpr StringId position_9th = 2031; constexpr StringId position_10th = 2032; constexpr StringId position_11th = 2033; constexpr StringId position_12th = 2034; constexpr StringId position_13th = 2035; constexpr StringId position_14th = 2036; constexpr StringId position_15th = 2037; constexpr StringId num_selected_num_max = 2038; constexpr StringId buffer_2039 = 2039; constexpr StringId buffer_2040 = 2040; constexpr StringId data_for_following_object_not_found = 2042; constexpr StringId not_enough_space_for_graphics = 2043; constexpr StringId too_many_objects_of_this_type_selected = 2044; constexpr StringId the_following_object_must_be_selected_first = 2045; constexpr StringId this_object_is_currently_in_use = 2046; constexpr StringId this_object_is_required_by_another_object = 2047; constexpr StringId this_object_is_always_required = 2048; constexpr StringId error_unable_to_select_object = 2049; constexpr StringId error_unable_to_deselect_object = 2050; constexpr StringId invalid_selection_of_objects = 2051; constexpr StringId title_object_selection = 2052; constexpr StringId object_interface_styles = 2053; constexpr StringId object_sounds = 2054; constexpr StringId object_currency = 2055; constexpr StringId object_animation_effects = 2056; constexpr StringId object_cliffs = 2057; constexpr StringId object_water = 2058; constexpr StringId object_land = 2059; constexpr StringId object_town_names = 2060; constexpr StringId object_cargo = 2061; constexpr StringId object_walls = 2062; constexpr StringId object_signals = 2063; constexpr StringId object_level_crossing = 2064; constexpr StringId object_street_lights = 2065; constexpr StringId object_tunnels = 2066; constexpr StringId object_bridges = 2067; constexpr StringId object_track_stations = 2068; constexpr StringId object_track_extras = 2069; constexpr StringId object_tracks = 2070; constexpr StringId object_road_stations = 2071; constexpr StringId object_road_extras = 2072; constexpr StringId object_roads = 2073; constexpr StringId object_airports = 2074; constexpr StringId object_docks = 2075; constexpr StringId object_vehicles = 2076; constexpr StringId object_trees = 2077; constexpr StringId object_snow = 2078; constexpr StringId object_climate = 2079; constexpr StringId object_map_generation_data = 2080; constexpr StringId object_buildings = 2081; constexpr StringId object_scaffolding = 2082; constexpr StringId object_industries = 2083; constexpr StringId object_world_region = 2084; constexpr StringId object_company_owners = 2085; constexpr StringId object_scenario_descriptions = 2086; constexpr StringId tooltip_object_list = 2087; constexpr StringId missing_object_data_id_x = 2088; constexpr StringId export_plugin_objects = 2089; constexpr StringId export_plugin_objects_tip = 2090; constexpr StringId at_least_one_generic_dual_direction_road_type_must_be_selected = 2091; constexpr StringId scaffolding_type_must_be_selected = 2092; // Two unused strings below constexpr StringId object_selection_advanced = 2093; constexpr StringId object_selection_advanced_tooltip = 2094; constexpr StringId object_currency_big_font = 2095; constexpr StringId new_objects_installed_successfully = 2096; constexpr StringId industry_type_must_be_selected = 2097; constexpr StringId town_building_type_must_be_selected = 2098; constexpr StringId company_headquarter_building_type_must_be_selected = 2099; constexpr StringId only_one_company_headquarter_building_type_must_be_selected = 2100; constexpr StringId interface_type_must_be_selected = 2101; constexpr StringId vehicle_type_must_be_selected = 2102; constexpr StringId land_type_must_be_selected = 2103; constexpr StringId currency_type_must_be_selected = 2104; constexpr StringId water_type_must_be_selected = 2105; constexpr StringId town_name_type_must_be_selected = 2106; constexpr StringId level_crossing_type_must_be_selected = 2107; constexpr StringId street_light_type_must_be_selected = 2108; constexpr StringId snow_type_must_be_selected = 2109; constexpr StringId climate_type_must_be_selected = 2110; constexpr StringId map_generation_type_must_be_selected = 2111; constexpr StringId region_type_must_be_selected = 2112; constexpr StringId unit_mph = 2113; constexpr StringId unit_kmh = 2114; constexpr StringId unit_hour = 2115; constexpr StringId unit_hours = 2116; constexpr StringId unit_mins = 2117; constexpr StringId unit_min = 2118; constexpr StringId unit_secs = 2119; constexpr StringId unit_units = 2120; constexpr StringId unit_ft = 2121; constexpr StringId unit_m = 2122; constexpr StringId unit_hp = 2123; constexpr StringId unit_kW = 2124; constexpr StringId options_language = 2125; constexpr StringId disable_vehicle_breakdowns = 2126; constexpr StringId options_screen_mode = 2127; constexpr StringId options_mode_windowed = 2128; constexpr StringId options_mode_fullscreen = 2129; constexpr StringId options_mode_fullscreen_window = 2130; constexpr StringId default_audio_device_name = 2131; constexpr StringId window_scale_factor = 2132; constexpr StringId stepper_plus = 2133; constexpr StringId stepper_minus = 2134; constexpr StringId scale_formatted = 2135; constexpr StringId zoom_to_cursor = 2136; constexpr StringId zoom_to_cursor_tip = 2137; constexpr StringId play_title_music = 2138; constexpr StringId menu_quit_to_menu = 2139; constexpr StringId menu_exit_openloco = 2140; constexpr StringId disableAICompanies = 2141; constexpr StringId disableAICompanies_tip = 2142; constexpr StringId autosave_amount = 2143; constexpr StringId autosave_frequency = 2144; constexpr StringId autosave_never = 2145; constexpr StringId autosave_every_month = 2146; constexpr StringId autosave_every_x_months = 2147; constexpr StringId height_map_source = 2148; constexpr StringId generator_original = 2149; constexpr StringId generator_simplex = 2150; constexpr StringId dropdown_modify_vehicle = 2151; constexpr StringId dropdown_clone_vehicle = 2152; constexpr StringId cant_clone_vehicle = 2153; constexpr StringId dropdown_viewport_move = 2154; constexpr StringId dropdown_viewport_focus = 2155; constexpr StringId option_cheat_menu_enable = 2156; constexpr StringId tooltip_option_cheat_menu_enable = 2157; constexpr StringId cheat_enable_sandbox_mode = 2158; constexpr StringId cheat_allow_manual_driving = 2159; constexpr StringId cheat_allow_building_while_paused = 2160; constexpr StringId option_show_fps_counter = 2161; constexpr StringId option_show_fps_counter_tooltip = 2162; constexpr StringId option_uncap_fps = 2163; constexpr StringId option_uncap_fps_tooltip = 2164; constexpr StringId frame_hardware = 2165; constexpr StringId frame_map_rendering = 2166; constexpr StringId tile_inspector = 2167; constexpr StringId tile_inspector_select_btn_tooltip = 2168; constexpr StringId tile_inspector_element_type_surface = 2169; constexpr StringId tile_inspector_element_type_track = 2170; constexpr StringId tile_inspector_element_type_station = 2171; constexpr StringId tile_inspector_element_type_signal = 2172; constexpr StringId tile_inspector_element_type_building = 2173; constexpr StringId tile_inspector_element_type_tree = 2174; constexpr StringId tile_inspector_element_type_wall = 2175; constexpr StringId tile_inspector_element_type_road = 2176; constexpr StringId tile_inspector_element_type_industry = 2177; constexpr StringId tile_inspector_entry_two_pos = 2178; constexpr StringId tile_inspector_entry_three_pos = 2179; constexpr StringId tile_inspector_x_coord = 2180; constexpr StringId tile_inspector_y_coord = 2181; constexpr StringId tile_inspector_coord = 2182; constexpr StringId tile_element_data = 2183; constexpr StringId cheats = 2184; constexpr StringId financial_cheats = 2185; constexpr StringId company_cheats = 2186; constexpr StringId vehicle_cheats = 2187; constexpr StringId town_cheats = 2188; constexpr StringId cheat_clear_loan = 2189; constexpr StringId cheat_clear = 2190; constexpr StringId cheat_loan_value = 2191; constexpr StringId cheat_select_target_company = 2192; constexpr StringId cheat_select_cheat_to_apply = 2193; constexpr StringId cheat_switch_to_company = 2194; constexpr StringId cheat_acquire_company_assets = 2195; constexpr StringId cheat_toggle_bankruptcy = 2196; constexpr StringId cheat_toggle_jail_status = 2197; constexpr StringId cheat_increase_funds = 2198; constexpr StringId cheat_amount = 2199; constexpr StringId cheat_add = 2200; constexpr StringId cheat_set_vehicle_reliability = 2201; constexpr StringId cheat_reliability_zero = 2202; constexpr StringId cheat_reliability_hundred = 2203; constexpr StringId cheat_set_ratings = 2204; constexpr StringId cheat_ratings_min_10pct = 2205; constexpr StringId cheat_ratings_plus_10pct = 2206; constexpr StringId cheat_ratings_to_min = 2207; constexpr StringId cheat_ratings_to_max = 2208; constexpr StringId all_vehicles = 2209; constexpr StringId stopping_at_station = 2210; constexpr StringId transporting_cargo = 2211; constexpr StringId carrying_cargoid_sprite = 2212; constexpr StringId carrying_cargoid_sprite_selected = 2213; constexpr StringId no_station_selected = 2214; constexpr StringId no_cargo_selected = 2215; constexpr StringId tooltip_open_station_window_to_filter = 2216; constexpr StringId tooltip_select_cargo_type = 2217; constexpr StringId shortcut_construction_previous_tab = 2218; constexpr StringId shortcut_construction_next_tab = 2219; constexpr StringId shortcut_construction_previous_track_piece = 2220; constexpr StringId shortcut_construction_next_track_piece = 2221; constexpr StringId shortcut_construction_previous_slope = 2222; constexpr StringId shortcut_construction_next_slope = 2223; constexpr StringId shortcut_construction_build_at_current_pos = 2224; constexpr StringId shortcut_construction_remove_at_current_pos = 2225; constexpr StringId shortcut_construction_select_position = 2226; constexpr StringId trainsReverseAtSignals = 2227; constexpr StringId loan_autopay = 2228; constexpr StringId tooltip_loan_autopay = 2229; constexpr StringId cheat_year = 2230; constexpr StringId cheat_month = 2231; constexpr StringId cheat_day = 2232; constexpr StringId cheat_date_change_apply = 2233; constexpr StringId cheat_year_value = 2234; constexpr StringId cheat_month_value = 2235; constexpr StringId cheat_day_value = 2236; constexpr StringId date_daymonthyear = 2237; constexpr StringId shortcut_game_speed_normal = 2238; constexpr StringId shortcut_game_speed_fast_forward = 2239; constexpr StringId shortcut_game_speed_extra_fast_forward = 2240; constexpr StringId vehicle_capacity_stringid = 2241; constexpr StringId stats_obsolete = 2242; constexpr StringId vehicle_is_locked = 2243; constexpr StringId display_locked_vehicles = 2244; constexpr StringId tooltip_display_locked_vehicles = 2245; constexpr StringId stats_proposed_design = 2246; constexpr StringId allow_building_locked_vehicles = 2247; constexpr StringId tooltip_build_locked_vehicles = 2248; constexpr StringId cheat_build_vehicle_window = 2249; constexpr StringId tooltip_paint_landscape_tool = 2250; constexpr StringId invert_right_mouse_dragging = 2251; constexpr StringId tooltip_invert_right_mouse_dragging = 2252; constexpr StringId cash_popup_rendering = 2253; constexpr StringId tooltip_cash_popup_rendering = 2254; constexpr StringId startServer = 2255; constexpr StringId closeServer = 2256; constexpr StringId disconnect = 2257; constexpr StringId vehicle_car_count_and_length = 2258; constexpr StringId vehicle_length = 2259; constexpr StringId object_selection_length = 2260; constexpr StringId stats_length = 2261; constexpr StringId vehicle_details_tooltip_length = 2262; constexpr StringId num_characters_left_int_int = 2263; constexpr StringId menu_giant_screenshot = 2264; constexpr StringId object_selection_filename = 2265; constexpr StringId open_scenario_options = 2266; constexpr StringId open_object_selection = 2267; constexpr StringId gameplay_tweaks = 2268; constexpr StringId preferred_owner_name = 2269; constexpr StringId autosave_preferences = 2270; constexpr StringId disableTownExpansion = 2271; constexpr StringId disableTownExpansion_tip = 2272; constexpr StringId completeChallenge = 2273; constexpr StringId clearInput = 2274; constexpr StringId objectErrorWindowTitle = 2275; constexpr StringId objectErrorExplanation = 2276; constexpr StringId tableHeaderObjectId = 2277; constexpr StringId tableHeaderObjectType = 2278; constexpr StringId tableHeaderObjectChecksum = 2279; constexpr StringId playNewsSoundEffects = 2280; constexpr StringId playNewsSoundEffectsTip = 2281; constexpr StringId reverseOrderTableTooltip = 2282; constexpr StringId tileInspectorHeaderNameType = 2283; constexpr StringId tileInspectorHeaderBaseHeight = 2284; constexpr StringId tileInspectorHeaderClearHeight = 2285; constexpr StringId tileInspectorHeaderDirection = 2286; constexpr StringId tileInspectorHeaderGhost = 2287; constexpr StringId tileInspectorHeaderNameTypeTip = 2288; constexpr StringId tileInspectorHeaderBaseHeightTip = 2289; constexpr StringId tileInspectorHeaderClearHeightTip = 2290; constexpr StringId tileInspectorHeaderDirectionTip = 2291; constexpr StringId tileInspectorHeaderGhostTip = 2292; constexpr StringId objSelectionFilterBeginner = 2293; constexpr StringId objSelectionFilterAdvanced = 2294; constexpr StringId objSelectionFilterExpert = 2295; constexpr StringId objSelectionFilterVanilla = 2296; constexpr StringId objSelectionFilterCustom = 2297; constexpr StringId filterComponents = 2298; constexpr StringId sortByDesignYear = 2299; constexpr StringId sortByName = 2300; constexpr StringId componentUnpowered = 2301; constexpr StringId componentPowered = 2302; constexpr StringId componentUnlocked = 2303; constexpr StringId componentLocked = 2304; constexpr StringId filterCargoSupported = 2305; constexpr StringId allCargoTypes = 2306; constexpr StringId supportsCargoIdSprite = 2307; constexpr StringId supportsCargoIdSpriteSelected = 2308; constexpr StringId cargoIdSprite = 2309; constexpr StringId filterCargoless = 2310; constexpr StringId disableVehicleLoadingPenalty = 2311; constexpr StringId disableVehicleLoadingPenaltyTip = 2312; constexpr StringId menuSeeThroughBuildings = 2313; constexpr StringId menuSeeThroughRoads = 2314; constexpr StringId menuSeeThroughScenery = 2315; constexpr StringId menuSeeThroughTracks = 2316; constexpr StringId menuSeeThroughTrees = 2317; constexpr StringId shortcutSeeThroughBuildings = 2318; constexpr StringId shortcutSeeThroughRoads = 2319; constexpr StringId shortcutSeeThroughScenery = 2320; constexpr StringId shortcutSeeThroughTracks = 2321; constexpr StringId shortcutSeeThroughTrees = 2322; constexpr StringId mountainModeTooltip = 2323; constexpr StringId vehicleTrackBehaviour = 2324; constexpr StringId tooltip_title_company = 2325; constexpr StringId options_title_company = 2326; constexpr StringId preferredCompanyFace = 2327; constexpr StringId usePreferredCompanyFace = 2328; constexpr StringId usePreferredCompanyFaceTip = 2329; constexpr StringId currentPreferredFace = 2330; constexpr StringId selectPreferredCompanyOwnerFace = 2331; constexpr StringId disableStationSizeLimitLabel = 2332; constexpr StringId disableStationSizeLimitTooltip = 2333; constexpr StringId title_landscape_generation_water = 2334; constexpr StringId tooltip_landscape_generation_water = 2335; constexpr StringId landscapeOptionsGroupGeneral = 2336; constexpr StringId landscapeOptionsGroupGenerator = 2337; constexpr StringId landscapeOptionsCurrentHillObject = 2338; constexpr StringId landscapeOptionsSmoothingPasses = 2339; constexpr StringId generator_png_heightmap = 2340; constexpr StringId title_load_png_heightmap_file = 2341; constexpr StringId button_browse = 2342; constexpr StringId currentHeightmapFile = 2343; constexpr StringId noneSelected = 2344; constexpr StringId checkingScenarioFiles = 2345; constexpr StringId industry_table_header_production_last_month = 2346; constexpr StringId industry_table_header_production_last_month_desc = 2347; constexpr StringId sort_industry_production_last_month = 2348; constexpr StringId shortcut_show_options_window = 2349; constexpr StringId menuSeeThroughBridges = 2350; constexpr StringId shortcutSeeThroughBridges = 2351; constexpr StringId number_riverbeds = 2352; constexpr StringId minimum_river_width = 2353; constexpr StringId maximum_river_width = 2354; constexpr StringId riverbank_width = 2355; constexpr StringId meander_rate = 2356; constexpr StringId objSelectionFilterOpenLoco = 2357; constexpr StringId vehicleRepaintTool = 2358; constexpr StringId vehicleRepaintTooltip = 2359; constexpr StringId vehicleRepaintEntireVehicle = 2360; constexpr StringId title_options_rendering = 2361; constexpr StringId tooltip_options_rendering = 2362; constexpr StringId confirm_vehicle_component_sell_cargo_warning_title = 2363; constexpr StringId confirm_vehicle_component_sell_cargo_warning_message = 2364; constexpr StringId confirm_vehicle_component_sell_cargo_warning_confirm = 2365; constexpr StringId confirm_vehicle_component_refit_cargo_warning_title = 2366; constexpr StringId confirm_vehicle_component_refit_cargo_warning_message = 2367; constexpr StringId confirm_vehicle_component_refit_cargo_warning_confirm = 2368; constexpr StringId tooltip_audio_options = 2369; constexpr StringId options_title_audio = 2370; constexpr StringId frame_sound = 2371; constexpr StringId frame_jukebox = 2372; constexpr StringId music_volume = 2373; constexpr StringId show_company_ai_planning = 2374; constexpr StringId show_company_ai_planning_tip = 2375; constexpr StringId temporary_object_load_str_0 = 8192; constexpr StringId temporary_object_load_str_1 = 8193; constexpr StringId temporary_object_load_str_2 = 8194; constexpr StringId temporary_object_load_str_3 = 8195; constexpr StringId temporary_object_load_str_4 = 8196; constexpr StringId temporary_object_load_str_5 = 8197; constexpr StringId temporary_object_load_str_6 = 8198; constexpr StringId temporary_object_load_str_7 = 8199; constexpr StringId temporary_object_load_str_8 = 8200; constexpr StringId temporary_object_load_str_9 = 8201; constexpr StringId temporary_object_load_str_10 = 8202; constexpr StringId temporary_object_load_str_11 = 8203; constexpr StringId temporary_object_load_str_12 = 8204; constexpr StringId temporary_object_load_str_13 = 8205; constexpr StringId temporary_object_load_str_14 = 8206; constexpr StringId temporary_object_load_str_15 = 8207; constexpr StringId object_strings_begin = 8208; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/StringManager.cpp ```cpp #include "StringManager.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "StringIds.h" #include <OpenLoco/Diagnostics/Logging.h> #include <OpenLoco/Interop/Interop.hpp> #include <cassert> #include <cstring> using namespace OpenLoco::Interop; namespace OpenLoco::StringManager { // 0x2000 lang strings, 0x10 temp obj strings, 0x45E loaded obj strings constexpr size_t kNumStringPointers = 0x246E; // 9326 strings // Size for buffer strings that are used for temporary text storage static constexpr size_t kBufferStringSize = 512; static char _buffer_337[kBufferStringSize]; static char _buffer_338[kBufferStringSize]; static char _buffer_1250[kBufferStringSize]; static char _preferred_currency_buffer[kBufferStringSize]; static char _buffer_1719[kBufferStringSize]; static char _buffer_2039[kBufferStringSize]; static char _buffer_2040[kBufferStringSize]; // 0x005183FC // Initialize string pointer array with buffers for specific IDs static std::array<char*, kNumStringPointers> _strings = []() { std::array<char*, kNumStringPointers> strings = {}; // Assign pre-allocated buffers to specific string IDs strings[StringIds::buffer_337] = _buffer_337; strings[StringIds::buffer_338] = _buffer_338; strings[StringIds::buffer_1250] = _buffer_1250; strings[StringIds::preferred_currency_buffer] = _preferred_currency_buffer; strings[StringIds::buffer_1719] = _buffer_1719; strings[StringIds::buffer_2039] = _buffer_2039; strings[StringIds::buffer_2040] = _buffer_2040; return strings; }(); static auto& rawUserStrings() { return getGameState().userStrings; } // 0x0049650E void reset() { for (auto* str : rawUserStrings()) { *str = '\0'; } } const char* getString(StringId id) { if (id >= _strings.size()) { Diagnostics::Logging::error("Tried to access invalid string id: {}", id); return nullptr; } char* str = _strings[id]; return str; } void setString(StringId id, std::string_view value) { auto* dst = _strings[id]; std::memcpy(dst, value.data(), value.size()); dst[value.size()] = '\0'; } const char* swapString(StringId id, const char* src) { auto* dst = _strings[id]; _strings[id] = const_cast<char*>(src); return dst; } // 0x00496522 StringId userStringAllocate(char* str, bool mustBeUnique) { auto bestSlot = -1; for (auto i = 0u; i < Limits::kMaxUserStrings; ++i) { char* userStr = rawUserStrings()[i]; if (*userStr == '\0') { bestSlot = i; } else if (mustBeUnique) { if (strcmp(str, userStr) == 0) { GameCommands::setErrorText(StringIds::chosen_name_in_use); return StringIds::empty; } } } if (bestSlot == -1) { GameCommands::setErrorText(StringIds::too_many_names_in_use); return StringIds::empty; } char* userStr = rawUserStrings()[bestSlot]; strncpy(userStr, str, kUserStringSize); userStr[kUserStringSize - 1] = '\0'; return bestSlot + kUserStringsStart; } const char* getUserString(StringId id) { return rawUserStrings()[id]; } // 0x004965A6 void emptyUserString(StringId stringId) { if (!isUserString(stringId)) { return; } *rawUserStrings()[stringId - kUserStringsStart] = '\0'; } bool isUserString(StringId stringId) { if (stringId < kUserStringsStart || stringId >= kUserStringsEnd) { return false; } return true; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/StringManager.h ```h #pragma once #include "Types.hpp" #include <Engine/Limits.h> #include <cstddef> #include <cstdint> #include <string_view> #include <utility> #ifdef small #error "small is defined, likely by windows.h" #endif namespace OpenLoco { namespace StringIds { constexpr StringId null = 0xFFFF; } } namespace OpenLoco::StringManager { constexpr uint8_t kUserStringSize = 32; constexpr uint16_t kUserStringsStart = 0x8000; constexpr uint16_t kUserStringsEnd = kUserStringsStart + Limits::kMaxUserStrings; constexpr uint16_t kMaxTownNames = 345; constexpr uint16_t kTownNamesStart = 0x9EE7; constexpr uint16_t kTownNamesEnd = kTownNamesStart + kMaxTownNames; void reset(); void setString(StringId id, std::string_view value); const char* swapString(StringId id, const char* src); const char* getString(StringId id); StringId userStringAllocate(char* str, bool mustBeUnique); const char* getUserString(StringId id); void emptyUserString(StringId stringId); bool isUserString(StringId id); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/Unicode.cpp ```cpp #include "Unicode.h" #include <cstdint> namespace OpenLoco::Localisation { utf32_t readCodePoint(const utf8_t** string) { utf32_t read = 0; const utf8_t* ptr = *string; if ((ptr[0] & 0b10000000) == 0) { read = ptr[0]; *string += 1; } else if ((ptr[0] & 0b11100000) == 0b11000000) { read = ((ptr[0] & 0b11111) << 6) | (ptr[1] & 0b111111); *string += 2; } else if ((ptr[0] & 0b11110000) == 0b11100000) { read = ((ptr[0] & 0b1111) << 12) | ((ptr[1] & 0b111111) << 6) | (ptr[2] & 0b111111); *string += 3; } else if ((ptr[0] & 0b11111000) == 0b11110000) { read = ((ptr[0] & 0b111) << 18) | ((ptr[1] & 0b111111) << 12) | ((ptr[2] & 0b111111) << 6) | (ptr[3] & 0b111111); *string += 4; } return read; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Localisation/Unicode.h ```h #pragma once #include <cstdint> namespace OpenLoco::Localisation { using utf8_t = uint8_t; using utf32_t = uint32_t; utf32_t readCodePoint(const utf8_t** string); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/Audio.cpp ```cpp #include "Audio.h" #include "Channel.h" #include "Config.h" #include "Date.h" #include "Entities/EntityManager.h" #include "Environment.h" #include "Game.h" #include "GameStateFlags.h" #include "Jukebox.h" #include "Localisation/StringIds.h" #include "Logging.h" #include "Map/SurfaceElement.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Objects/ObjectManager.h" #include "Objects/SoundObject.h" #include "Objects/TreeObject.h" #include "SceneManager.h" #include "Ui/WindowManager.h" #include "VehicleChannel.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Core/FileStream.h> #include <array> #include <cassert> #include <numeric> #include <unordered_map> #ifdef _WIN32 #define __HAS_DEFAULT_DEVICE__ #endif using namespace OpenLoco::Environment; using namespace OpenLoco::Ui; using namespace OpenLoco::Utility; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Audio { struct AudioFormat { int32_t frequency{}; int32_t format{}; int32_t channels{}; }; static constexpr uint8_t kMaxVehicleSounds = 16; static constexpr int32_t kPlayAtCentre = 0x8000; static constexpr int32_t kPlayAtLocation = 0x8001; [[maybe_unused]] constexpr int32_t kNumSoundChannels = 16; static bool _audioIsInitialised = false; // 0x0050D1EC static bool _audioIsPaused = false; // 0x0050D554 static bool _audioIsEnabled = true; // 0x0050D555 static std::optional<PathId> _chosenAmbientNoisePathId = std::nullopt; // 0x0050D5B0 static uint8_t _numActiveVehicleSounds; // 0x0112C666 static std::vector<std::string> _devices; static std::vector<Channel> _channels; static std::vector<VehicleChannel> _vehicleChannels; static std::vector<Channel> _soundFX; static std::vector<uint32_t> _samples; static std::unordered_map<uint16_t, uint32_t> _objectSamples; static std::unordered_map<PathId, uint32_t> _musicSamples; static OpenAL::Device _device; static OpenAL::SourceManager _sourceManager; static OpenAL::BufferManager _bufferManager; static void playSound(SoundId id, const World::Pos3& loc, int32_t volume, int32_t pan, int32_t frequency); static void mixSound(SoundId id, bool loop, int32_t volume, int32_t pan, int32_t freq); static Channel* getChannel(ChannelId id) { auto index = static_cast<size_t>(id); if (index < _channels.size()) { return &_channels[index]; } return nullptr; } static uint32_t loadSoundFromWaveMemory(const WAVEFORMATEX& format, const void* pcm, size_t pcmLen) { const auto id = _bufferManager.allocate(std::span<const uint8_t>(reinterpret_cast<const uint8_t*>(pcm), pcmLen), format.nSamplesPerSec, format.nChannels == 2, format.wBitsPerSample); return id; } static std::vector<uint32_t> loadSoundsFromCSS(const fs::path& path) { Logging::verbose("loadSoundsFromCSS({})", path.string()); try { std::vector<uint32_t> results; FileStream fs(path, StreamMode::read); auto numSounds = fs.readValue<uint32_t>(); std::vector<uint32_t> soundOffsets(numSounds, 0); fs.read(soundOffsets.data(), numSounds * sizeof(uint32_t)); std::vector<std::byte> pcm; for (uint32_t i = 0; i < numSounds; i++) { // Navigate to beginning of wave data fs.setPosition(soundOffsets[i]); // Read length of wave data and load it into the pcm buffer auto pcmLen = fs.readValue<uint32_t>(); auto format = fs.readValue<WAVEFORMATEX>(); pcm.resize(pcmLen); fs.read(pcm.data(), pcmLen); results.push_back(loadSoundFromWaveMemory(format, pcm.data(), pcmLen)); } return results; } catch (const std::exception& ex) { Logging::error("loadSoundsFromCSS({}) failed: {}", path.string(), ex.what()); return {}; } } static void disposeSamples() { _samples.clear(); _objectSamples.clear(); _musicSamples.clear(); } static void disposeChannels() { _channels.clear(); _vehicleChannels.clear(); _soundFX.clear(); } static void reinitialise() { disposeDSound(); initialiseDSound(); } static size_t getDeviceIndex(const std::string_view& deviceName) { if (deviceName.empty()) { return 0; } const auto& devices = _devices; if (devices.empty()) { getDevices(); } auto fr = std::find(devices.begin(), devices.end(), deviceName); if (fr != devices.end()) { return fr - devices.begin(); } return std::numeric_limits<size_t>().max(); } // 0x00404E53 void initialiseDSound() { if (_devices.empty()) { _devices = getDevices(); } std::string deviceName{}; const auto& cfg = Config::get(); if (!cfg.audio.device.empty()) { if (std::find(std::begin(_devices), std::end(_devices), cfg.audio.device) != std::end(_devices)) { deviceName = cfg.audio.device; } } _device.open(deviceName); _channels.clear(); for (auto i = 0; i < 4; ++i) { const auto sourceId = _sourceManager.allocate(); _channels.push_back(Channel(sourceId)); } _vehicleChannels.clear(); for (auto i = 0; i < 10; ++i) { const auto sourceId = _sourceManager.allocate(); _vehicleChannels.push_back(Channel(sourceId)); } auto css1path = Environment::getPath(Environment::PathId::css1); _samples = loadSoundsFromCSS(css1path); _audioIsInitialised = true; } // 0x00404E58 void disposeDSound() { disposeChannels(); disposeSamples(); _sourceManager.dispose(); _bufferManager.dispose(); _device.close(); _audioIsInitialised = false; } // 0x00489BA1 void close() { if (_audioIsInitialised) { stopAmbientNoise(); stopVehicleNoise(); stopMusic(); for (auto& channel : _soundFX) { channel.stop(); } } } #ifdef __HAS_DEFAULT_DEVICE__ static const char* getDefaultDeviceName() { return StringManager::getString(StringIds::default_audio_device_name); } #endif const std::vector<std::string>& getDevices() { _devices.clear(); #ifdef __HAS_DEFAULT_DEVICE__ auto* ddChar = getDefaultDeviceName(); std::string defaultDevice = ddChar == nullptr ? "" : std::string(ddChar); if (!defaultDevice.empty()) { _devices.push_back(getDefaultDeviceName()); } #endif auto newDevices = _device.getAvailableDeviceNames(); for (auto& device : newDevices) { #ifdef __HAS_DEFAULT_DEVICE__ if (defaultDevice.empty() || device != defaultDevice) #endif { _devices.push_back(device); } } return _devices; } const char* getCurrentDeviceName() { auto index = getCurrentDevice(); if (index == 0) { #ifdef __HAS_DEFAULT_DEVICE__ return getDefaultDeviceName(); #else const auto& devices = _devices; if (devices.empty()) { getDevices(); } if (!devices.empty()) { return devices[0].c_str(); } #endif } const auto& cfg = Config::get(); return cfg.audio.device.c_str(); } size_t getCurrentDevice() { const auto& cfg = Config::get(); return getDeviceIndex(cfg.audio.device); } void setDevice(size_t index) { if (index < _devices.size()) { auto& cfg = Config::get(); #ifdef __HAS_DEFAULT_DEVICE__ if (index == 0) { cfg.audio.device = {}; } else #endif { cfg.audio.device = _devices[index]; } Config::write(); reinitialise(); } } // 0x00489C0A void toggleSound() { _audioIsEnabled = !_audioIsEnabled; if (_audioIsEnabled) { return; } stopVehicleNoise(); stopAmbientNoise(); stopMusic(); Config::write(); } // 0x00489C34 void pauseSound() { if (_audioIsPaused) { return; } _audioIsPaused = true; stopVehicleNoise(); stopAmbientNoise(); // Do not stop title screen music if (!SceneManager::isTitleMode()) { pauseMusic(); } } // 0x00489C58 void unpauseSound() { _audioIsPaused = false; unpauseMusic(); } static const SoundObject* getSoundObject(SoundId id) { auto idx = (int32_t)id & ~0x8000; return ObjectManager::get<SoundObject>(idx); } static Viewport* findBestViewportForSound(viewport_pos vpos) { auto w = WindowManager::find(WindowType::main, 0); if (w != nullptr) { auto viewport = w->viewports[0]; if (viewport != nullptr && viewport->contains(vpos)) { return viewport; } } for (auto i = (int32_t)WindowManager::count() - 1; i >= 0; i--) { w = WindowManager::get(i); if (w != nullptr && w->type != WindowType::main && w->type != WindowType::news) { auto viewport = w->viewports[0]; if (viewport != nullptr && viewport->contains(vpos)) { return viewport; } } } return nullptr; } // 0x004FEAB8 // Sound volume levels indexed by SoundId static constexpr std::array<int32_t, 32> kSoundVolumeTable = { { // clang-format off 0, 0, 0, 0, 0, -400, 0, 0, 0, 0, 0, -500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1900, 0, 0, 0, -600, -600, -600, -600, -600, -600, // clang-format on } }; static int32_t getVolumeForSoundId(SoundId id) { if (isObjectSoundId(id)) { auto obj = getSoundObject(id); if (obj != nullptr) { return obj->volume; } return 0; } else { return kSoundVolumeTable[static_cast<int32_t>(id)]; } } static int32_t calculateVolumeFromViewport([[maybe_unused]] SoundId id, const World::Pos3& mpos, const Viewport& viewport) { auto volume = 0; auto zVol = 0; auto tile = World::TileManager::get(mpos); if (!tile.isNull()) { auto surface = tile.surface(); if (surface != nullptr) { if ((surface->baseHeight()) - 5 > mpos.z) { zVol = 8; } } volume = ((-1024 * viewport.zoom - 1) << zVol) + 1; } return volume; } void playSound(SoundId id, const World::Pos3& loc) { playSound(id, loc, kPlayAtLocation); } void playSound(SoundId id, int32_t pan) { playSound(id, {}, pan); } static VehicleChannel* getFreeVehicleChannel() { for (auto& vc : _vehicleChannels) { if (vc.isFree()) { return &vc; } } return nullptr; } bool shouldSoundLoop(SoundId id) { loco_global<uint8_t[64], 0x0050D514> _unk_50D514; if (isObjectSoundId(id)) { auto obj = getSoundObject(id); return obj->shouldLoop != 0; } else { return _unk_50D514[(int32_t)id * 2] != 0; } } // 0x0048A4BF void playSound(Vehicles::VehicleSoundPlayer* v) { if ((v->soundFlags & Vehicles::SoundFlags::flag0) != Vehicles::SoundFlags::none) { Logging::verbose("playSound(vehicle #{})", enumValue(v->id)); auto vc = getFreeVehicleChannel(); if (vc != nullptr) { vc->begin(v->id); } } } // 0x00489F1B void playSound(SoundId id, const World::Pos3& loc, int32_t volume, int32_t frequency) { playSound(id, loc, volume, kPlayAtLocation, frequency); } // 0x00489CB5 void playSound(SoundId id, const World::Pos3& loc, int32_t pan) { playSound(id, loc, 0, pan, 22050); } constexpr int32_t kVpSizeMin = 64; // Note check if defined in viewport.hpp int32_t calculatePan(const coord_t coord, const int32_t screenSize) { const auto relativePosition = (coord << 16) / std::max(screenSize, kVpSizeMin); return (relativePosition - (1 << 15)) / 16; } // 0x00489CB5 / 0x00489F1B // pan is in UI pixels or known constant void playSound(SoundId id, const World::Pos3& loc, int32_t volume, int32_t pan, int32_t frequency) { if (_audioIsEnabled) { volume += getVolumeForSoundId(id); if (pan == kPlayAtLocation) { auto vpos = World::gameToScreen(loc, WindowManager::getCurrentRotation()); auto viewport = findBestViewportForSound(vpos); if (viewport == nullptr) { return; } volume += calculateVolumeFromViewport(id, loc, *viewport); pan = viewport->viewportToScreen(vpos).x; if (volume < -10000) { return; } } else if (pan == kPlayAtCentre) { pan = 0; } if (pan != 0) { pan = calculatePan(pan, Ui::width()); } mixSound(id, 0, volume, pan, frequency); } } std::optional<uint32_t> getSoundSample(SoundId id) { if (isObjectSoundId(id)) { // TODO this is not getting deallocated when sound objects unloaded // TODO use a LRU queue for object samples auto sr = _objectSamples.find((uint16_t)id); if (sr == _objectSamples.end()) { auto obj = getSoundObject(id); if (obj != nullptr) { const auto* data = obj->getData(); assert(data != nullptr); assert(data->offset == 8); _objectSamples[static_cast<size_t>(id)] = loadSoundFromWaveMemory(data->pcmHeader, data->pcm(), data->length); return _objectSamples[static_cast<size_t>(id)]; } } else { return sr->second; } } else if (static_cast<size_t>(id) < _samples.size()) { return _samples[static_cast<size_t>(id)]; } return std::nullopt; } static void mixSound(SoundId id, bool loop, int32_t volume, int32_t pan, int32_t freq) { Logging::verbose("mixSound({}, {}, {}, {}, {})", enumValue(id), loop ? "true" : "false", volume, pan, freq); auto sample = getSoundSample(id); if (sample) { auto freeChannel = std::find_if(std::begin(_soundFX), std::end(_soundFX), [](auto& channel) { return !channel.isPlaying(); }); Channel* channel = nullptr; if (freeChannel == std::end(_soundFX)) { _soundFX.push_back(Channel(_sourceManager.allocate())); channel = &_soundFX.back(); } else { channel = &*freeChannel; } channel->load(*sample); channel->setVolume(volume); channel->setFrequency(freq); channel->setPan(pan); channel->play(loop); } } // 0x0048A18C void updateSounds() { if (_soundFX.empty()) { return; } for (auto& channel : _soundFX) { if (!channel.isPlaying()) { channel.stop(); // This forces deallocation of buffer } } } static std::optional<uint32_t> loadMusicSample(PathId asset) { auto res = _musicSamples.find(asset); if (res != std::end(_musicSamples)) { return res->second; } const auto path = Environment::getPath(asset); try { FileStream fs(path, StreamMode::read); const auto sig = fs.readValue<uint32_t>(); if (sig != 0x46464952) // RIFF { throw Exception::RuntimeError("Invalid signature."); } fs.readValue<uint32_t>(); // size const auto riffType = fs.readValue<uint32_t>(); if (riffType != 0x45564157) // WAVE { throw Exception::RuntimeError("Invalid format."); } const auto fmtMarker = fs.readValue<uint32_t>(); // This can be 'fmt\0' or 'fmt ' if (fmtMarker != 0x20746d66 && fmtMarker != 0x00746d66) { throw Exception::RuntimeError("Invalid format marker."); } fs.readValue<uint32_t>(); // header size const auto typeFormat = fs.readValue<uint16_t>(); if (typeFormat != 1) { throw Exception::RuntimeError("Invalid format type, expected PCM."); } const auto channels = fs.readValue<uint16_t>(); const auto sampleRate = fs.readValue<uint32_t>(); fs.readValue<uint32_t>(); fs.readValue<uint16_t>(); const auto bits = fs.readValue<uint16_t>(); const auto dataMarker = fs.readValue<uint32_t>(); if (dataMarker != 0x61746164) // data { throw Exception::RuntimeError("Invalid data marker."); } const auto pcmLen = fs.readValue<uint32_t>(); std::vector<std::uint8_t> pcm(pcmLen); fs.read(pcm.data(), pcmLen); const auto id = _bufferManager.allocate(std::span<const uint8_t>(pcm.data(), pcmLen), sampleRate, channels == 2, bits); _musicSamples[asset] = id; return id; } catch (const std::exception& ex) { Logging::error("Unable to load music sample '{}': {}", path, ex.what()); return std::nullopt; } } // 0x00401A05 static void stopChannel(ChannelId id) { Logging::verbose("stopChannel({})", static_cast<int>(id)); auto channel = getChannel(id); if (channel != nullptr) { channel->stop(); } } // 0x0048A268 static void triggerVehicleSoundIfInView(Vehicles::VehicleSoundPlayer* v) { if (v == nullptr) { return; } if (v->drivingSoundId == SoundObjectId::null) { return; } // TODO: left or top? if (v->spriteLeft == Location::null) { return; } if (_numActiveVehicleSounds >= kMaxVehicleSounds) { return; } auto spritePosition = viewport_pos(v->spriteLeft, v->spriteTop); // First, check if vehicle appears in the main viewport auto main = WindowManager::getMainWindow(); if (main != nullptr && main->viewports[0] != nullptr) { auto viewport = main->viewports[0]; ViewportRect extendedViewport = {}; auto quarterWidth = viewport->viewWidth / 4; auto quarterHeight = viewport->viewHeight / 4; extendedViewport.left = viewport->viewX - quarterWidth; extendedViewport.top = viewport->viewY - quarterHeight; extendedViewport.right = viewport->viewX + viewport->viewWidth + quarterWidth; extendedViewport.bottom = viewport->viewY + viewport->viewHeight + quarterHeight; if (extendedViewport.contains(spritePosition)) { // jump + return _numActiveVehicleSounds += 1; v->soundFlags |= Vehicles::SoundFlags::flag0; v->soundWindowType = main->type; v->soundWindowNumber = main->number; return; } } if (WindowManager::count() == 0) { return; } // Check if vehicle appears in any other (windowed) viewport for (auto i = (int32_t)WindowManager::count() - 1; i >= 0; i--) { auto w = WindowManager::get(i); if (w->type == WindowType::main) { continue; } if (w->type == WindowType::news) { continue; } auto viewport = w->viewports[0]; if (viewport == nullptr) { continue; } if (viewport->contains(spritePosition)) { _numActiveVehicleSounds += 1; v->soundFlags |= Vehicles::SoundFlags::flag0; v->soundWindowType = w->type; v->soundWindowNumber = w->number; return; } } } // 0x004FEB58 static void processVehicleForSound(Vehicles::VehicleSoundPlayer* v, int32_t step) { switch (step) { case 0: // 0x048A262 v->soundFlags &= ~Vehicles::SoundFlags::flag0; break; case 1: // 0x048A268 if ((v->soundFlags & Vehicles::SoundFlags::flag1) == Vehicles::SoundFlags::none) { triggerVehicleSoundIfInView(v); } break; case 2: // 0x048A395 if ((v->soundFlags & Vehicles::SoundFlags::flag1) != Vehicles::SoundFlags::none) { triggerVehicleSoundIfInView(v); } break; case 3: playSound(v); break; } } // 0x0048A1FA static void processVehicleSounds(int32_t step) { if (step == 0) { _numActiveVehicleSounds = 0; } for (auto* v : VehicleManager::VehicleList()) { Vehicles::Vehicle train(*v); processVehicleForSound(reinterpret_cast<Vehicles::VehicleSoundPlayer*>(train.veh2), step); processVehicleForSound(reinterpret_cast<Vehicles::VehicleSoundPlayer*>(train.tail), step); } } // 0x48A73B void updateVehicleNoise() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded)) { if (!_audioIsPaused && _audioIsEnabled) { processVehicleSounds(0); processVehicleSounds(1); processVehicleSounds(2); for (auto& vc : _vehicleChannels) { vc.update(); } processVehicleSounds(3); } } } // 0x00489C6A void stopVehicleNoise() { for (auto& vc : _vehicleChannels) { vc.stop(); } } void stopVehicleNoise(EntityId head) { Vehicles::Vehicle train(head); for (auto& vc : _vehicleChannels) { if (vc.getId() == train.veh2->id || vc.getId() == train.tail->id) { vc.stop(); } } } static constexpr auto kAmbientMinVolume = -3500; static constexpr auto kAmbientVolumeChangePerTick = 100; static constexpr auto kAmbientNumWaterTilesForOcean = 60; static constexpr auto kAmbientNumTreeTilesForForest = 30; static constexpr auto kAmbientNumMountainTilesForWilderness = 60; static constexpr int32_t getAmbientMaxVolume(uint8_t zoom) { constexpr int32_t _volumes[]{ -1200, -2000, -3000, -3000 }; return _volumes[zoom]; } // 0x0048ACFD void updateAmbientNoise() { if (!_audioIsInitialised || _audioIsPaused || !_audioIsEnabled) { return; } auto* mainViewport = WindowManager::getMainViewport(); std::optional<PathId> newAmbientSound = std::nullopt; int32_t maxVolume = kAmbientMinVolume; if (Game::hasFlags(GameStateFlags::tileManagerLoaded) && mainViewport != nullptr) { maxVolume = getAmbientMaxVolume(mainViewport->zoom); const auto centre = mainViewport->getCentreMapPosition(); const auto topLeft = World::toTileSpace(centre) - World::TilePos2{ 5, 5 }; const auto bottomRight = topLeft + World::TilePos2{ 11, 11 }; const auto searchRange = World::getClampedRange(topLeft, bottomRight); size_t waterCount = 0; // bl size_t wildernessCount = 0; // bh size_t treeCount = 0; // cx for (auto& tilePos : searchRange) { const auto tile = World::TileManager::get(tilePos); bool passedSurface = false; for (const auto& el : tile) { auto* elSurface = el.as<World::SurfaceElement>(); if (elSurface != nullptr) { passedSurface = true; if (elSurface->water() != 0) { waterCount++; break; } else if (elSurface->snowCoverage() && elSurface->isLast()) { wildernessCount++; break; } else if (elSurface->baseZ() >= 64 && elSurface->isLast()) { wildernessCount++; break; } continue; } auto* elTree = el.as<World::TreeElement>(); if (passedSurface && elTree != nullptr) { const auto* treeObj = ObjectManager::get<TreeObject>(elTree->treeObjectId()); if (!treeObj->hasFlags(TreeObjectFlags::droughtResistant)) { treeCount++; } } } } if (waterCount > kAmbientNumWaterTilesForOcean) { newAmbientSound = PathId::css3; } else if (wildernessCount > kAmbientNumMountainTilesForWilderness) { newAmbientSound = PathId::css2; } else if (treeCount > kAmbientNumTreeTilesForForest) { newAmbientSound = PathId::css4; } } auto* channel = getChannel(ChannelId::ambient); if (channel == nullptr) { return; } // TODO: Consider changing this so that we ask if the channel is playing a certain // buffer instead of storing what buffer is playing indirectly through the global // variable _chosenAmbientNoisePathId // In these situations quieten until channel stopped if (!newAmbientSound.has_value() || (channel->isPlaying() && _chosenAmbientNoisePathId != *newAmbientSound)) { const auto newVolume = channel->getAttributes().volume - kAmbientVolumeChangePerTick; if (newVolume < kAmbientMinVolume) { _chosenAmbientNoisePathId = std::nullopt; channel->stop(); } else { channel->setVolume(newVolume); } return; } if (_chosenAmbientNoisePathId != *newAmbientSound) { auto musicBuffer = loadMusicSample(*newAmbientSound); if (musicBuffer.has_value()) { channel->load(*musicBuffer); channel->setVolume(kAmbientMinVolume); channel->play(true); _chosenAmbientNoisePathId = *newAmbientSound; } } else { auto newVolume = std::min(channel->getAttributes().volume + kAmbientVolumeChangePerTick, maxVolume); channel->setVolume(newVolume); } } // 0x0048ABE3 void stopAmbientNoise() { loco_global<uint32_t, 0x0050D5AC> _50D5AC; if (_audioIsInitialised && _50D5AC != 1) { stopChannel(ChannelId::ambient); _50D5AC = 1; } } // 0x0048AA0C void revalidateCurrentTrack() { const auto currentTrack = Jukebox::getCurrentTrack(); if (currentTrack == Jukebox::kNoSong) { return; } using Config::MusicPlaylistType; const auto& cfg = Config::get(); bool trackStillApplies = true; switch (cfg.audio.playlist) { case MusicPlaylistType::currentEra: { auto currentYear = getCurrentYear(); const auto& info = Jukebox::getMusicInfo(currentTrack); if (currentYear < info.startYear || currentYear > info.endYear) { trackStillApplies = false; } break; } case MusicPlaylistType::all: return; case MusicPlaylistType::custom: if (!cfg.audio.customJukebox[currentTrack]) { trackStillApplies = false; } break; } if (!trackStillApplies) { stopMusic(); Jukebox::resetJukebox(); } } // 0x0048A78D void playBackgroundMusic() { auto& cfg = Config::get(); if (cfg.audio.playJukeboxMusic == 0 || SceneManager::isTitleMode() || SceneManager::isEditorMode() || SceneManager::isPaused()) { return; } auto* channel = getChannel(ChannelId::music); if (channel == nullptr) { return; } if (!channel->isPlaying()) { // Set the next song to play and load its info const auto& mi = Jukebox::changeTrack(); playMusic(mi.pathId, cfg.audio.mainVolume, false); WindowManager::invalidate(WindowType::options); } } // 0x0048AC66 // previously called void playTitleScreenMusic() void playMusic(PathId sample, int32_t volume, bool loop) { auto* channel = getChannel(ChannelId::music); if (!_audioIsInitialised || _audioIsPaused || !_audioIsEnabled || channel == nullptr) { return; } channel->stop(); auto musicSample = loadMusicSample(sample); if (channel->load(*musicSample)) { channel->setVolume(volume); channel->play(loop); } } // 0x0048AAD2 void resetMusic() { stopMusic(); Jukebox::resetJukebox(); } // 0x0048AAE8 // void stopBackgroundMusic() // merged into Audio::stopMusic // 0x0048AC2B // previously called void stopTitleMusic() void stopMusic() { auto* channel = getChannel(ChannelId::music); if (_audioIsInitialised && channel != nullptr && (channel->isPlaying() || channel->isPaused())) { channel->stop(); } } void pauseMusic() { auto* channel = getChannel(ChannelId::music); if (_audioIsInitialised && channel != nullptr && channel->isPlaying()) { channel->pause(); } } void unpauseMusic() { auto* channel = getChannel(ChannelId::music); if (_audioIsInitialised && channel != nullptr && channel->isPaused()) { channel->unpause(); } } void resetSoundObjects() { for (auto& sample : _objectSamples) { _bufferManager.deAllocate(sample.second); } _objectSamples.clear(); } bool isAudioEnabled() { return _audioIsEnabled; } // 0x0048AA67 void setBgmVolume(int32_t volume) { auto& cfg = Config::get().audio; if (cfg.mainVolume == volume) { return; } cfg.mainVolume = volume; Config::write(); auto* channel = getChannel(ChannelId::music); if (channel == nullptr) { return; } if (_audioIsInitialised && Jukebox::getCurrentTrack() != Jukebox::kNoSong) { channel->setVolume(volume); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/Audio.h ```h #pragma once #include "Location.hpp" #include "Types.hpp" #include <OpenLoco/Engine/World.hpp> #include <optional> #include <string> #include <vector> namespace OpenLoco::Vehicles { struct VehicleSoundPlayer; } namespace OpenLoco::Environment { enum class PathId : uint8_t; } namespace OpenLoco::Audio { // TODO: This should only be a byte needs to be split off from sound object enum class SoundId : uint16_t { clickDown = 0, clickUp = 1, clickPress = 2, construct = 3, demolish = 4, income = 5, crash = 6, water = 7, splash1 = 8, splash2 = 9, waypoint = 10, notification = 11, openWindow = 12, applause1 = 13, error = 14, multiplayerConnected = 15, multiplayerDisconnected = 16, demolishTree = 17, demolishBuilding = 18, vehiclePlace = 19, vehiclePickup = 20, constructShip = 21, ticker = 22, applause2 = 23, newsOooh = 24, newsAwww = 25, breakdown1 = 26, breakdown2 = 27, breakdown3 = 28, breakdown4 = 29, breakdown5 = 30, breakdown6 = 31, null = 0xFF }; enum class ChannelId { music, unk_1, ambient, title_deprecated, vehicle_0, // * 10 }; constexpr int32_t kNumReservedChannels = 4 + 10; #pragma pack(push, 1) struct WAVEFORMATEX { int16_t wFormatTag; int16_t nChannels; int32_t nSamplesPerSec; int32_t nAvgBytesPerSec; int16_t nBlockAlign; int16_t wBitsPerSample; int16_t cbSize; }; #pragma pack(pop) void initialiseDSound(); void disposeDSound(); void close(); const std::vector<std::string>& getDevices(); const char* getCurrentDeviceName(); size_t getCurrentDevice(); void setDevice(size_t index); std::optional<uint32_t> getSoundSample(SoundId id); bool shouldSoundLoop(SoundId id); void toggleSound(); void pauseSound(); void unpauseSound(); void playSound(Vehicles::VehicleSoundPlayer* t); void playSound(SoundId id, const World::Pos3& loc); // FOR HOOKS ONLY DO NOT USE THIS FUNCTION FOR OPENLOCO CODE // INSTEAD USE playSound(SoundId id, const Map::Pos3& loc) OR playSound(SoundId id, int32_t pan) void playSound(SoundId id, const World::Pos3& loc, int32_t pan); void playSound(SoundId id, int32_t pan); void playSound(SoundId id, const World::Pos3& loc, int32_t volume, int32_t frequency); void updateSounds(); void setBgmVolume(int32_t volume); void updateVehicleNoise(); void stopVehicleNoise(); void stopVehicleNoise(EntityId head); void updateAmbientNoise(); void stopAmbientNoise(); void revalidateCurrentTrack(); void resetMusic(); void playBackgroundMusic(); void stopMusic(); void pauseMusic(); void unpauseMusic(); void playMusic(Environment::PathId sample, int32_t volume, bool loop); void resetSoundObjects(); bool isAudioEnabled(); constexpr bool isObjectSoundId(SoundId id) { return static_cast<int32_t>(id) & 0x8000; } constexpr SoundId makeObjectSoundId(SoundObjectId_t id) { return static_cast<SoundId>((static_cast<int32_t>(id) | 0x8000)); } int32_t calculatePan(const coord_t coord, const int32_t screenSize); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/Channel.cpp ```cpp #include "Channel.h" #include "Logging.h" #include <utility> namespace OpenLoco::Audio { bool Channel::load(uint32_t buffer) { _source.setBuffer(buffer); _isLoaded = true; return true; } bool Channel::play(bool loop) { if (_isLoaded == false) { return false; } _source.setLooping(loop); _source.play(); return true; } bool Channel::pause() { if (_isLoaded == false) { return false; } _source.pause(); return true; } bool Channel::unpause() { if (_isLoaded == false) { return false; } _source.play(); return true; } void Channel::stop() { _source.stop(); _source.setBuffer(0); // Unload buffer allowing destruct of buffers _isLoaded = false; } void Channel::setVolume(int32_t volume) { _attributes.volume = volume; _source.setGain(OpenAL::volumeFromLoco(volume)); } void Channel::setPan(int32_t pan) { _attributes.pan = pan; _source.setPan(OpenAL::panFromLoco(pan)); } void Channel::setFrequency(int32_t freq) { _attributes.freq = freq; // If frequency is around zero don't adjust the frequency at all // this matches dsound's DSBFREQUENCY_MIN == 100Hz that vanilla used if (std::abs(freq) < 100) { _source.setPitch(1.0f); } else { _source.setPitch(OpenAL::freqFromLoco(freq)); } } bool Channel::isPaused() const { return _source.isPaused(); } bool Channel::isPlaying() const { return _source.isPlaying(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/Channel.h ```h #pragma once #include "OpenAL.h" namespace OpenLoco::Audio { class Channel { public: static constexpr int32_t kUndefinedId = -1; struct Attributes { int32_t volume{}; int32_t pan{}; int32_t freq{}; }; private: OpenAL::Source _source; bool _isLoaded = false; Attributes _attributes; public: Channel(OpenAL::Source source) : _source(source) , _attributes{} { } bool load(uint32_t buffer); bool play(bool loop); bool pause(); bool unpause(); void stop(); void setVolume(int32_t volume); void setPan(int32_t pan); void setFrequency(int32_t freq); bool isPaused() const; bool isPlaying() const; const OpenAL::Source& getSource() const { return _source; } const Attributes& getAttributes() const { return _attributes; } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/OpenAL.cpp ```cpp #include "OpenAL.h" #include <AL/al.h> #include <AL/alc.h> #include <algorithm> #include <cmath> namespace OpenAL { void Device::open(const std::string& name) { if (_isOpen) { _context.close(); alcCloseDevice(_device); } if (name.empty()) { // Open default device _device = alcOpenDevice(nullptr); } else { // requires c string so cant make name string_view _device = alcOpenDevice(name.c_str()); } _context.open(_device); _isOpen = true; } void Device::close() { if (_isOpen) { _context.close(); alcCloseDevice(_device); _device = nullptr; _isOpen = false; } } Device::~Device() { // Although we should close on destruction this is causing a hang if destruction happens during process exit. Revisit when standalone // close(); } std::vector<std::string> Device::getAvailableDeviceNames() const { const ALCchar* devices = alcGetString(nullptr, ALC_ALL_DEVICES_SPECIFIER); std::vector<std::string> devicesVec; const char* ptr = devices; do { devicesVec.push_back(std::string(ptr)); ptr += devicesVec.back().size() + 1; } while (*ptr != '\0'); return devicesVec; } void Context::open(ALCdevice* device) { _context = alcCreateContext(device, nullptr); // OpenLoco only ever needs the one context so make this one current for lifetime alcMakeContextCurrent(_context); _isOpen = true; } void Context::close() { if (_isOpen) { alcMakeContextCurrent(nullptr); alcDestroyContext(_context); _context = nullptr; _isOpen = false; } } Context::~Context() { // Although we should close on destruction this is causing a hang if destruction happens during process exit. Revisit when standalone // close(); } void Source::pause() { alSourcePause(_id); } void Source::play() { alSourcePlay(_id); } void Source::stop() { alSourceStop(_id); } void Source::setBuffer(uint32_t bufferId) { alSourcei(_id, AL_BUFFER, bufferId); } void Source::setPitch(float value) { alSourcef(_id, AL_PITCH, value); } void Source::setGain(float value) { alSourcef(_id, AL_GAIN, value); } void Source::setPosition(float x, float y, float z) { alSource3f(_id, AL_POSITION, x, y, z); } void Source::setPan(float value) { alSourcef(_id, AL_ROLLOFF_FACTOR, 0.0f); alSourcei(_id, AL_SOURCE_RELATIVE, AL_TRUE); alSource3f(_id, AL_POSITION, value, 0.0f, -std::sqrt(1.0f - value * value)); } void Source::setLooping(bool value) { alSourcei(_id, AL_LOOPING, value ? AL_TRUE : AL_FALSE); } bool Source::isPaused() const { int32_t value = AL_PAUSED; alGetSourcei(_id, AL_SOURCE_STATE, &value); return value == AL_PAUSED; } bool Source::isPlaying() const { int32_t value = AL_PLAYING; alGetSourcei(_id, AL_SOURCE_STATE, &value); return value == AL_PLAYING; } float volumeFromLoco(int32_t volume) { // NOTE: Needs further adjustment // volume is in 100th dB so to convert 10 ^ ((volume / 100) / 20) const auto alVol = std::pow(10.0f, static_cast<float>(volume) / 2000.0f); return alVol; } float freqFromLoco(int32_t freq) { return freq / 22000.0f; } float panFromLoco(int32_t pan) { constexpr auto kRange = 4096.0f; return pan / kRange; } BufferManager::~BufferManager() { dispose(); } uint32_t BufferManager::allocate(std::span<const uint8_t> data, uint32_t sampleRate, bool stereo, uint8_t bits) { uint32_t id = 0; alGenBuffers(1, &id); _buffers.push_back(id); uint32_t format = 0; if (stereo) { if (bits == 8) { format = AL_FORMAT_STEREO8; } else { format = AL_FORMAT_STEREO16; } } else { if (bits == 8) { format = AL_FORMAT_MONO8; } else { format = AL_FORMAT_MONO16; } } alBufferData(id, format, data.data(), data.size(), sampleRate); return id; } void BufferManager::deAllocate(uint32_t id) { alDeleteBuffers(1, &id); _buffers.erase(std::remove(std::begin(_buffers), std::end(_buffers), id)); } void BufferManager::dispose() { alDeleteBuffers(_buffers.size(), _buffers.data()); _buffers.clear(); } SourceManager::~SourceManager() { dispose(); } Source SourceManager::allocate() { uint32_t id = 0; alGenSources(1, &id); _sources.push_back(id); return Source(id); } void SourceManager::deAllocate(const Source& source) { const auto id = source.getId(); alDeleteSources(1, &id); _sources.erase(std::remove(std::begin(_sources), std::end(_sources), id)); } void SourceManager::dispose() { alDeleteSources(_sources.size(), _sources.data()); _sources.clear(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/OpenAL.h ```h #pragma once #include <AL/alc.h> #include <cstdint> #include <span> #include <string> #include <vector> // TODO: When ubuntu dependencies upreved remove AL/alc.h and forward declare ALCcontext and ALCdevice namespace OpenAL { class Source { private: uint32_t _id; public: Source(uint32_t id) : _id(id) { } void pause(); void play(); void stop(); void setBuffer(uint32_t bufferId); // value to be of the range 0.0f -> 1.0f void setPitch(float value); // value to be of the range 0.0f -> 1.0f void setGain(float value); void setPosition(float x, float y, float z); // value to be of the range -0.5f -> 0.5f void setPan(float value); void setLooping(bool value); bool isPaused() const; bool isPlaying() const; uint32_t getId() const { return _id; } }; class Context { private: ALCcontext* _context = nullptr; bool _isOpen = false; public: ~Context(); void close(); void open(ALCdevice* device); }; class Device { private: ALCdevice* _device = nullptr; Context _context; bool _isOpen = false; public: ~Device(); void open(const std::string& name); void close(); std::vector<std::string> getAvailableDeviceNames() const; }; class BufferManager { std::vector<uint32_t> _buffers; public: ~BufferManager(); uint32_t allocate(std::span<const uint8_t> data, uint32_t sampleRate, bool stereo, uint8_t bits); void deAllocate(uint32_t id); void dispose(); }; class SourceManager { std::vector<uint32_t> _sources; public: ~SourceManager(); Source allocate(); void deAllocate(const Source& source); void dispose(); }; float volumeFromLoco(int32_t volume); float freqFromLoco(int32_t freq); float panFromLoco(int32_t pan); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/VehicleChannel.cpp ```cpp #include "VehicleChannel.h" #include "Entities/EntityManager.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Audio { // Vehicle Volume is multiplied by the modifier then divided by 8 to get in terms of hundredth decibels // 255 represents full volume // 0 represents no volume constexpr int8_t kVolumeModifierZoomIncrement = -35; // 13.7% decrease in volume for each zoom increment (up to 2) constexpr int8_t kVolumeModifierUnderground = -28; // 11.0% decrease in volume when underground constexpr uint8_t kVolumeModifierMax = 255; constexpr int32_t kVolumeMin = -100'00; // hundredth decibels (-100dB) // Calculated min is 255*255/8=8128 but original has done 256*256/8=8192 // We have kept original value but could be changed to correctly represent the full range of volume constexpr int32_t kVehicleVolumeCalcMin = -81'91; // hundredth decibels (-81.91dB) constexpr int32_t kPanFalloffStart = 2048; constexpr int32_t kPanFalloffEnd = 3072; static int8_t getZoomVolumeModifier(uint8_t zoom) { return std::min<uint8_t>(zoom, 2) * kVolumeModifierZoomIncrement; } static int8_t getUndergroundVolumeModifier(const World::Pos3& pos) { if (pos.x == Location::null || !World::validCoords(pos)) { return 0; } auto* surface = World::TileManager::get(pos).surface(); if (surface->baseHeight() > pos.z) { return kVolumeModifierUnderground; } return 0; } static uint8_t getFalloffModifier(int32_t pan) { const auto absPan = std::abs(pan); uint8_t falloffModifier = kVolumeModifierMax; // This in theory is the max viewport width/height (might not be valid for modern screens) if (absPan > kPanFalloffStart) { if (absPan > kPanFalloffEnd) { falloffModifier = 0; } else { falloffModifier = static_cast<uint8_t>(std::min<uint16_t>((kPanFalloffEnd - absPan) / 4, kVolumeModifierMax)); } } return falloffModifier; } // 0x0048A590 static std::pair<SoundId, Channel::Attributes> getChannelAttributesFromVehicle(const Vehicles::VehicleSoundPlayer* v) { auto* w = Ui::WindowManager::find(v->soundWindowType, v->soundWindowNumber); auto* viewport = w->viewports[0]; const auto uiPoint = viewport->viewportToScreen({ v->spriteLeft, v->spriteTop }); const auto zoomVolumeModifier = getZoomVolumeModifier(viewport->zoom); const auto panX = calculatePan(uiPoint.x, Ui::width()); const auto panY = calculatePan(uiPoint.y, Ui::height()); const auto undergroundVolumeModifier = getUndergroundVolumeModifier(v->position); const auto xFalloffModifier = getFalloffModifier(panX); const auto yFalloffModifier = getFalloffModifier(panY); const auto falloffVolumeModifier = std::min(xFalloffModifier, yFalloffModifier); const auto overallVolumeModifier = std::max(falloffVolumeModifier + undergroundVolumeModifier + zoomVolumeModifier, 0); // volume is in hundredth decibels max decrease in volume is -100dB. const auto volume = std::max(((v->drivingSoundVolume * overallVolumeModifier) / 8) + kVehicleVolumeCalcMin, kVolumeMin); return { makeObjectSoundId(v->drivingSoundId), { volume, panX, v->drivingSoundFrequency } }; } void VehicleChannel::begin(EntityId vid) { auto v = EntityManager::get<Vehicles::VehicleBase>(vid); if (v == nullptr) { return; } auto* vSoundPlayer = v->getSoundPlayer(); if (vSoundPlayer == nullptr) { return; } auto [sid, sa] = getChannelAttributesFromVehicle(vSoundPlayer); auto loop = Audio::shouldSoundLoop(sid); auto sample = Audio::getSoundSample(sid); if (sample) { _vehicleId = vid; _soundId = sid; _channel.load(*sample); _channel.play(loop); _channel.setVolume(sa.volume); _channel.setPan(sa.pan); _channel.setFrequency(sa.freq); } } void VehicleChannel::update() { if (isFree()) { return; } auto v = EntityManager::get<Vehicles::VehicleBase>(_vehicleId); if (v == nullptr) { stop(); return; } if (!v->hasSoundPlayer()) { stop(); return; } auto* vSoundPlayer = v->getSoundPlayer(); if (vSoundPlayer == nullptr || ((vSoundPlayer->soundFlags & Vehicles::SoundFlags::flag0) == Vehicles::SoundFlags::none)) { stop(); return; } auto [sid, sa] = getChannelAttributesFromVehicle(vSoundPlayer); if (_soundId != sid) { stop(); return; } vSoundPlayer->soundFlags &= ~Vehicles::SoundFlags::flag0; const auto& attributes = _channel.getAttributes(); if (attributes.volume != sa.volume) { _channel.setVolume(sa.volume); } if (attributes.pan != sa.pan) { _channel.setPan(sa.pan); } if (attributes.freq != sa.freq) { _channel.setFrequency(sa.freq); } } void VehicleChannel::stop() { _channel.stop(); _vehicleId = EntityId::null; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Audio/VehicleChannel.h ```h #pragma once #include "Audio.h" #include "Channel.h" namespace OpenLoco::Audio { class VehicleChannel { private: Channel _channel; EntityId _vehicleId = EntityId::null; SoundId _soundId{}; public: VehicleChannel(const Channel& channel) : _channel(channel) { } bool isFree() const { return _vehicleId == EntityId::null; } EntityId getId() const { return _vehicleId; } void begin(EntityId vid); void update(); void stop(); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/OrderManager.cpp ```cpp #include "OrderManager.h" #include "GameState.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "S5/Limits.h" #include "ScenarioOptions.h" #include "Ui/WindowManager.h" #include "Vehicle.h" #include "Vehicles/OrderManager.h" #include "Vehicles/VehicleManager.h" #include "World/StationManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Diagnostics/Logging.h> #include <sfl/static_vector.hpp> #include <sstream> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Vehicles { // 0x004FE070 static constexpr std::array<uint8_t, 6> kOrderSizes = { sizeof(OrderEnd), sizeof(OrderStopAt), sizeof(OrderRouteThrough), sizeof(OrderRouteWaypoint), sizeof(OrderUnloadAll), sizeof(OrderWaitFor), }; // 0x004B49F8 void OrderStation::setFormatArguments(FormatArguments& args) const { auto station = StationManager::get(getStation()); args.push(station->name); args.push(station->town); } // 0x004B4A31 void OrderCargo::setFormatArguments(FormatArguments& args) const { auto cargoObj = ObjectManager::get<CargoObject>(getCargo()); args.push(cargoObj->name); args.push(cargoObj->unitInlineSprite); } Order* OrderRingView::atIndex(const uint8_t index) const { auto size = std::distance(begin(), end()); if (index >= size) { return nullptr; } auto chosenOrder = std::next(begin(), index); return &(*chosenOrder); } OrderRingView::Iterator& OrderRingView::Iterator::operator++() { if (enumValue(_currentOrder->getType()) >= std::size(kOrderSizes)) { throw Exception::RuntimeError("Invalid order type!"); } auto* newOrders = reinterpret_cast<uint8_t*>(_currentOrder) + kOrderSizes[static_cast<uint8_t>(_currentOrder->getType())]; _currentOrder = reinterpret_cast<Order*>(newOrders); if (_currentOrder->getType() == OrderType::End) { _currentOrder = _beginOrderTable; _hasLooped = true; } return *this; } OrderRingView::Iterator OrderRingView::begin() const { auto* orderTable = OrderManager::orders(); return Iterator(&orderTable[_beginTableOffset], &orderTable[_beginTableOffset + _currentOrderOffset]); } OrderRingView::Iterator OrderRingView::end() const { return begin(); } } namespace OpenLoco::Vehicles::OrderManager { static sfl::static_vector<NumDisplayFrame, Limits::kMaxOrdersPerVehicle> _displayFrames; std::span<const NumDisplayFrame> displayFrames() { return _displayFrames; } Order* orders() { return reinterpret_cast<Order*>(getGameState().orders); } uint32_t& orderTableLength() { return getGameState().orderTableLength; } void shiftOrdersLeft(const uint32_t offsetToShiftTowards, const int16_t sizeToShiftBy) { std::rotate(&orders()[offsetToShiftTowards], &orders()[offsetToShiftTowards + sizeToShiftBy], &orders()[orderTableLength()]); } void shiftOrdersRight(const uint32_t offsetToShiftFrom, const int16_t sizeToShiftBy) { std::rotate(&orders()[offsetToShiftFrom], &orders()[orderTableLength()], &orders()[orderTableLength() + sizeToShiftBy]); } // 0x00470795 void reoffsetVehicleOrderTables(const uint32_t removeOrderTableOffset, const int16_t sizeOfRemovedOrderTable) { for (auto head : VehicleManager::VehicleList()) { if (head->orderTableOffset >= removeOrderTableOffset) { head->orderTableOffset += sizeOfRemovedOrderTable; } } for (auto& frame : _displayFrames) { if (frame.orderOffset >= removeOrderTableOffset) { frame.orderOffset += sizeOfRemovedOrderTable; } } } bool spaceLeftInGlobalOrderTableForOrder(const Order* order) { return orderTableLength() + kOrderSizes[enumValue(order->getType())] <= Limits::kMaxOrders; } bool spaceLeftInVehicleOrderTable(VehicleHead* head) { auto ring = head->getCurrentOrders(); size_t size = std::distance(ring.begin(), ring.end()); return size < Limits::kMaxOrdersPerVehicle; } // 0x004704AB void insertOrder(VehicleHead* head, uint16_t orderOffset, const Order* order) { assert(order->getType() != OrderType::End && orderOffset < head->sizeOfOrderTable); auto insOrderLength = kOrderSizes[enumValue(order->getType())]; // Shift current order to compensate for the new order. // For empty order tables, let current order point to the first order. if (head->sizeOfOrderTable > 1 && head->currentOrder >= orderOffset) { head->currentOrder += insOrderLength; } head->sizeOfOrderTable += insOrderLength; // Shift existing orders to make room for the new one shiftOrdersRight(head->orderTableOffset + orderOffset, insOrderLength); // Bookkeeping: change order table size orderTableLength() += insOrderLength; // Calculate destination offset and copy data auto rawOrder = order->getRaw(); auto dest = reinterpret_cast<uint8_t*>(orders() + head->orderTableOffset + orderOffset); std::memcpy(dest, &rawOrder, insOrderLength); // Recalculate order offsets for other vehicles reoffsetVehicleOrderTables(head->orderTableOffset + 1, insOrderLength); } // 0x004705C0 void deleteOrder(VehicleHead* head, uint16_t orderOffset) { assert(orderOffset < head->sizeOfOrderTable); // Find out what type the selected order is OrderRingView orders(head->orderTableOffset, orderOffset); auto& selectedOrder = *(orders.begin()); auto removeOrderSize = kOrderSizes[enumValue(selectedOrder.getType())]; head->sizeOfOrderTable -= removeOrderSize; // Are we removing an order that appears before the current order? Move back a bit if (head->currentOrder > orderOffset) { head->currentOrder -= removeOrderSize; } // Ensure we don't move beyond the order table size if (head->currentOrder + 1 >= head->sizeOfOrderTable) { head->currentOrder = 0; } // Move orders in the order table, effectively removing the order shiftOrdersLeft(head->orderTableOffset + orderOffset, removeOrderSize); // Bookkeeping: change order table size orderTableLength() -= removeOrderSize; // Compensate other vehicles to use new table offsets reoffsetVehicleOrderTables(head->orderTableOffset + orderOffset + 1, -removeOrderSize); } // 0x004702F7 void zeroUnusedOrderTable() { // Zero all the unused entries after the end of the order table std::fill(std::begin(getGameState().orders) + orderTableLength(), std::end(getGameState().orders), 0); } // 0x004702EC void reset() { // No need to zero order table as it will get cleaned up on save orderTableLength() = 0; } // 0x00470334 // Remove vehicle ?orders? void freeOrders(VehicleHead* const head) { // Copy the offset as it will get modified during sub_470795 const auto offset = head->orderTableOffset; const auto size = head->sizeOfOrderTable; reoffsetVehicleOrderTables(offset, -size); // Shift orders table left to remove empty orders shiftOrdersLeft(offset, size); orderTableLength() -= head->sizeOfOrderTable; } // 0x00470312 void allocateOrders(VehicleHead& head) { OrderEnd end{}; constexpr auto insOrderLength = kOrderSizes[enumValue(OrderEnd::kType)]; head.orderTableOffset = orderTableLength(); // Bookkeeping: change order table size orderTableLength() += insOrderLength; head.currentOrder = 0; head.sizeOfOrderTable = insOrderLength; // Calculate destination offset and copy data auto rawOrder = end.getRaw(); auto dest = reinterpret_cast<uint8_t*>(orders() + head.orderTableOffset); std::memcpy(dest, &rawOrder, insOrderLength); } // 0x00470B76 std::pair<World::Pos3, std::string> generateOrderUiStringAndLoc(uint32_t orderOffset, uint8_t orderNum) { std::stringstream ss; ss << ControlCodes::inlineSpriteStr; auto imageId = Gfx::recolour(ImageIds::getNumberCircle(orderNum), Colour::white); ss.write(reinterpret_cast<const char*>(&imageId), 4); OrderRingView orderRing(orderOffset); auto order = orderRing.begin(); World::Pos3 pos{}; switch (order->getType()) { case Vehicles::OrderType::StopAt: { auto* stopAt = order->as<Vehicles::OrderStopAt>(); // 0x00470B7D auto* station = StationManager::get(stopAt->getStation()); pos = World::Pos3{ station->x, station->y, station->z } + World::Pos3{ 0, 0, 30 }; ss << ControlCodes::Colour::white; for (auto nextOrder = order + 1; nextOrder != order; ++nextOrder) { if (!nextOrder->hasFlags(Vehicles::OrderFlags::HasCargo)) { break; } auto* unload = nextOrder->as<Vehicles::OrderUnloadAll>(); auto* waitFor = nextOrder->as<Vehicles::OrderWaitFor>(); const CargoObject* cargoObj = nullptr; if (unload != nullptr) { ss << " - "; cargoObj = ObjectManager::get<CargoObject>(unload->getCargo()); } else if (waitFor != nullptr) { ss << " + "; cargoObj = ObjectManager::get<CargoObject>(waitFor->getCargo()); } else { // Not possible break; } ss << ControlCodes::inlineSpriteStr; ss.write(reinterpret_cast<const char*>(&cargoObj->unitInlineSprite), 4); } break; } case Vehicles::OrderType::RouteThrough: { // 0x00470C25 auto* station = StationManager::get(order->as<Vehicles::OrderRouteThrough>()->getStation()); pos = World::Pos3{ station->x, station->y, station->z } + World::Pos3{ 0, 0, 30 }; break; } case Vehicles::OrderType::RouteWaypoint: // 0x00470C6F pos = order->as<Vehicles::OrderRouteWaypoint>()->getWaypoint() + World::Pos3{ 16, 16, 8 }; break; case Vehicles::OrderType::End: case Vehicles::OrderType::UnloadAll: case Vehicles::OrderType::WaitFor: return { {}, {} }; } ss << std::endl; return { pos, ss.str() }; } // 0x00470824 void generateNumDisplayFrames(Vehicles::VehicleHead* head) { World::setMapSelectionFlags(World::MapSelectionFlags::unk_04); Gfx::invalidateScreen(); _displayFrames.clear(); auto orders = Vehicles::OrderRingView(head->orderTableOffset); uint8_t i = 0; for (auto& order : orders) { if (!order.hasFlags(Vehicles::OrderFlags::HasNumber)) { continue; } NumDisplayFrame newFrame; newFrame.orderOffset = order.getOffset(); auto lineNumber = 0; auto* stationOrder = order.as<Vehicles::OrderStation>(); auto* waypointOrder = order.as<Vehicles::OrderRouteWaypoint>(); if (stationOrder != nullptr) { lineNumber++; // station labels start on line 0 so add 1 for the number const auto stationId = stationOrder->getStation(); for (auto innerOrder = orders.begin(); innerOrder->getOffset() != order.getOffset(); ++innerOrder) { auto* innerStationOrder = innerOrder->as<Vehicles::OrderStation>(); if (innerStationOrder == nullptr) { continue; } if (stationId == innerStationOrder->getStation()) { lineNumber++; } } } else if (waypointOrder != nullptr) { const auto rawOrder = order.getRaw(); for (auto innerOrder = orders.begin(); innerOrder->getOffset() != order.getOffset(); ++innerOrder) { if (rawOrder == innerOrder->getRaw()) { lineNumber++; } } } // For some reason save only a byte when this could in theory be larger newFrame.lineNumber = static_cast<uint8_t>(lineNumber); _displayFrames.push_back(newFrame); i++; } i = 1; for (auto& unk : _displayFrames) { auto order = Vehicles::OrderRingView(unk.orderOffset, 0).begin(); if (!order->hasFlags(Vehicles::OrderFlags::HasNumber)) { continue; } auto [loc, str] = generateOrderUiStringAndLoc(order->getOffset(), i); const auto pos = World::gameToScreen(loc, Ui::WindowManager::getCurrentRotation()); auto stringWidth = Gfx::TextRenderer::getStringWidth(Gfx::Font::medium_bold, str.c_str()); for (auto zoom = 0; zoom < 4; ++zoom) { // The first line of the label will always be at the centre // of the station/waypoint. This works out where the subsequent // lines of the label will end up. auto width = (stringWidth + 3) << zoom; auto numberHeight = (unk.lineNumber * 10 /* lineHeight TODO make same as Windows::Vehicle.cpp lineHeight */) << zoom; auto firstLineHeight = 11 << zoom; auto midX = width / 2; auto midFirstLineY = firstLineHeight / 2; unk.frame.left[zoom] = (pos.x - midX) >> zoom; unk.frame.right[zoom] = (pos.x + midX) >> zoom; unk.frame.top[zoom] = (pos.y - midFirstLineY + numberHeight) >> zoom; unk.frame.bottom[zoom] = (pos.y + midFirstLineY + numberHeight) >> zoom; } i++; } } uint16_t reverseVehicleOrderTable(uint16_t tableOffset, uint16_t orderOfInterest) { // Currently the use of std:: algorithms is not feasible due to variable order lengths // TODO: simplify this after the changing the data structure for the order table // Retrieve list of raw orders std::vector<uint64_t> rawOrders{}; Vehicles::OrderRingView orderTable(tableOffset); for (auto& order : orderTable) { rawOrders.push_back(order.getRaw()); } // Nothing to do? Bail early if (rawOrders.size() == 0) { return orderOfInterest; } // Keep track of the type of the order of interest auto ooiType = orders()[tableOffset + orderOfInterest].getType(); // Figure out where the order table starts in memory auto firstOrder = reinterpret_cast<uint8_t*>(orderTable.atIndex(0)); auto dest = firstOrder; // Write reversed list over existing list for (auto it = rawOrders.rbegin(); it != rawOrders.rend(); ++it) { auto rawOrder = *it; auto orderType = rawOrder & 0x7; if (orderType >= std::size(kOrderSizes)) { throw Exception::OutOfRange("Order type is greater than the order size table"); } auto orderLength = kOrderSizes[orderType]; std::memcpy(dest, &rawOrder, orderLength); dest += orderLength; } // Figure out the new position of the order of interest auto newOOIOffset = dest - orderOfInterest - kOrderSizes[enumValue(ooiType)]; return newOOIOffset - firstOrder; } uint8_t swapAdjacentOrders(Order& a, Order& b) { // Currently the use of std:: algorithms is not feasible due to variable order lengths // TODO: simplify this after the changing the data structure for the order table const auto rawOrderA = a.getRaw(); const auto rawOrderB = b.getRaw(); const auto lengthOrderA = kOrderSizes[enumValue(a.getType())]; const auto lengthOrderB = kOrderSizes[enumValue(b.getType())]; // Ensure the two orders are indeed adjacent assert(&a + lengthOrderA == &b); // Copy B over A, and append B right after const auto dest = reinterpret_cast<uint8_t*>(&a); std::memcpy(dest, &rawOrderB, lengthOrderB); std::memcpy(dest + lengthOrderB, &rawOrderA, lengthOrderA); // Return the length with which to offset return lengthOrderB; } // 0x0047062B void removeOrdersForStation(const StationId stationId) { for (auto i = 0U; i < orderTableLength();) { auto& order = orders()[i]; auto* stationOrder = order.as<OrderStation>(); if (stationOrder != nullptr) { if (stationOrder->getStation() == stationId) { // Find the vehicle that has the order for (auto* head : VehicleManager::VehicleList()) { if (head->orderTableOffset >= i && i < head->orderTableOffset + head->sizeOfOrderTable) { deleteOrder(head, i); break; } } } } i += kOrderSizes[enumValue(order.getType())]; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/OrderManager.h ```h #pragma once #include "LabelFrame.h" #include "Types.hpp" #include "Vehicles/Orders.h" #include <OpenLoco/Engine/World.hpp> #include <cstdint> #include <span> #include <string> namespace OpenLoco::Vehicles { struct VehicleHead; struct OrderRingView { public: struct Iterator { private: Order* _beginOrderTable; Order* _currentOrder; bool _hasLooped = false; public: Iterator(Order* beginOrderTable, Order* currentOrder) : _beginOrderTable(beginOrderTable) , _currentOrder(currentOrder) { // Prevent empty tables looping if (_currentOrder->getType() == OrderType::End) { _hasLooped = true; } } Iterator& operator++(); Iterator operator++(int) { Iterator res = *this; ++(*this); return res; } Iterator operator+(int32_t amount) const { Iterator res = *this; while (amount-- != 0) { res++; } return res; } bool operator==(Iterator other) const { return _currentOrder == other._currentOrder && (_hasLooped || other._hasLooped); } Order& operator*() { return *_currentOrder; } const Order& operator*() const { return *_currentOrder; } Order* operator->() { return _currentOrder; } const Order* operator->() const { return _currentOrder; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = Order; using pointer = const Order*; using reference = const Order&; using iterator_category = std::forward_iterator_tag; }; private: uint32_t _beginTableOffset; uint32_t _currentOrderOffset; public: // currentOrderOffset is relative to beginTableOffset and is where the ring will begin and end OrderRingView(uint32_t beginTableOffset, uint32_t currentOrderOffset = 0) : _beginTableOffset(beginTableOffset) , _currentOrderOffset(currentOrderOffset) { } OrderRingView::Iterator begin() const; OrderRingView::Iterator end() const; Order* atIndex(const uint8_t index) const; }; } namespace OpenLoco::Vehicles::OrderManager { struct NumDisplayFrame { uint32_t orderOffset; // 0x0 LabelFrame frame; // 0x4 uint8_t lineNumber; // 0x24 }; Order* orders(); uint32_t& orderTableLength(); void shiftOrdersLeft(const uint32_t offsetToShiftTowards, const int16_t sizeToShiftBy); void shiftOrdersRight(const uint32_t offsetToShiftFrom, const int16_t sizeToShiftBy); void reoffsetVehicleOrderTables(const uint32_t removeOrderTableOffset, const int16_t sizeOfRemovedOrderTable); bool spaceLeftInGlobalOrderTableForOrder(const Order* order); bool spaceLeftInVehicleOrderTable(VehicleHead* head); void insertOrder(VehicleHead* head, uint16_t orderOffset, const Order* order); void deleteOrder(VehicleHead* head, uint16_t orderOffset); void zeroUnusedOrderTable(); void reset(); void freeOrders(VehicleHead* const head); void allocateOrders(VehicleHead& head); std::pair<World::Pos3, std::string> generateOrderUiStringAndLoc(uint32_t orderOffset, uint8_t orderNum); void generateNumDisplayFrames(Vehicles::VehicleHead* head); std::span<const NumDisplayFrame> displayFrames(); uint16_t reverseVehicleOrderTable(uint16_t tableOffset, uint16_t orderOfInterest); uint8_t swapAdjacentOrders(Order& a, Order& b); void removeOrdersForStation(const StationId stationId); void fixCorruptWaypointOrders(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Orders.cpp ```cpp #include "Orders.h" #include "Map/Tile.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Vehicles/OrderManager.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Vehicles { // 0x004FE088 TODO: Rework into class static constexpr OrderFlags kOrderFlags[] = { OrderFlags::none, OrderFlags::IsRoutable | OrderFlags::HasNumber | OrderFlags::HasStation, OrderFlags::IsRoutable | OrderFlags::HasNumber | OrderFlags::HasStation, OrderFlags::IsRoutable | OrderFlags::HasNumber, OrderFlags::HasCargo, OrderFlags::HasCargo, }; bool Order::hasFlags(const OrderFlags flag) const { return (kOrderFlags[static_cast<uint8_t>(getType())] & flag) != OrderFlags::none; } template<typename T> std::shared_ptr<Order> orderClone(const Order& order) { auto* o = order.as<T>(); return o != nullptr ? std::make_shared<T>(*o) : nullptr; } std::shared_ptr<Order> Order::clone() const { switch (getType()) { case OrderType::End: return orderClone<OrderEnd>(*this); case OrderType::StopAt: return orderClone<OrderStopAt>(*this); case OrderType::RouteThrough: return orderClone<OrderRouteThrough>(*this); case OrderType::RouteWaypoint: return orderClone<OrderRouteWaypoint>(*this); case OrderType::UnloadAll: return orderClone<OrderUnloadAll>(*this); case OrderType::WaitFor: return orderClone<OrderWaitFor>(*this); } return {}; } void OrderRouteWaypoint::setWaypoint(const World::TilePos2& pos, const uint8_t baseZ) { _type &= ~0x80; _type |= ((pos.x & 0x100) >> 1); _data[0] = pos.x & 0xFF; _data[2] = pos.y & 0xFF; _data[1] = baseZ; _data[1] |= ((pos.y & 0x100) >> 1); } void OrderRouteWaypoint::setDirection(const uint8_t direction) { _data[3] &= ~0x7; _data[3] |= direction & 0x7; } void OrderRouteWaypoint::setTrackId(const uint8_t trackId) { _data[3] &= ~0xF8; _data[3] |= (trackId & 0x1F) << 3; _data[4] = (trackId >> 5) & 0x1; } World::Pos3 OrderRouteWaypoint::getWaypoint() const { World::Pos3 loc{}; loc.x = ((static_cast<int16_t>(_type & 0x80) << 1) | _data[0]) * World::kTileSize; loc.y = ((static_cast<int16_t>(_data[1] & 0x80) << 1) | _data[2]) * World::kTileSize; loc.z = (_data[1] & 0x7F) * 8; return loc; } uint8_t OrderRouteWaypoint::getDirection() const { return _data[3] & 0x7; } uint8_t OrderRouteWaypoint::getTrackId() const { return (_data[3] >> 3) | ((_data[4] & 0x1) << 5); } uint32_t Order::getOffset() const { return this - OrderManager::orders(); } uint64_t Order::getRaw() const { uint64_t ret = 0; ret = _type; switch (getType()) { case OrderType::RouteThrough: { auto* route = as<OrderRouteThrough>(); if (route != nullptr) { ret |= static_cast<uint64_t>(route->_data) << 8; } break; } case OrderType::RouteWaypoint: { auto* route = as<OrderRouteWaypoint>(); if (route != nullptr) { ret |= static_cast<uint64_t>(route->_data[0]) << 8; ret |= static_cast<uint64_t>(route->_data[1]) << 16; ret |= static_cast<uint64_t>(route->_data[2]) << 24; ret |= static_cast<uint64_t>(route->_data[3]) << 32; ret |= static_cast<uint64_t>(route->_data[4]) << 40; } break; } case OrderType::StopAt: { auto* stop = as<OrderStopAt>(); if (stop != nullptr) { ret |= static_cast<uint64_t>(stop->_data) << 8; } break; } case OrderType::End: case OrderType::UnloadAll: case OrderType::WaitFor: // These are all one byte and no more data to save break; } return ret; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Orders.h ```h #pragma once #include "Map/Tile.h" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <iterator> #include <memory> namespace OpenLoco::Vehicles { enum class OrderType : uint8_t { End, StopAt, RouteThrough, RouteWaypoint, UnloadAll, WaitFor }; enum class OrderFlags : uint8_t { none = 0U, IsRoutable = 1U << 0, HasNumber = 1U << 1, HasCargo = 1U << 2, HasStation = 1U << 3, }; OPENLOCO_ENABLE_ENUM_OPERATORS(OrderFlags) #pragma pack(push, 1) struct Order { uint8_t _type = 0; // 0x0 protected: Order() = default; public: OrderType getType() const { return OrderType(_type & 0x7); } void setType(OrderType type) { _type &= ~0x7; _type |= static_cast<uint8_t>(type); } uint32_t getOffset() const; std::shared_ptr<Order> clone() const; uint64_t getRaw() const; bool hasFlags(const OrderFlags flag) const; template<typename T> constexpr bool is() const { return getType() == T::kType; } template<typename T> T* as() { return is<T>() ? reinterpret_cast<T*>(this) : nullptr; } template<typename T> const T* as() const { return is<T>() ? reinterpret_cast<const T*>(this) : nullptr; } }; static_assert(sizeof(Order) == 1, "Size of order must be 1 for pointer arithmetic to work in OrderTableView"); struct OrderEnd : Order { static constexpr OrderType kType = OrderType::End; OrderEnd() { setType(kType); } }; struct OrderStation : Order { uint8_t _data = 0; // 0x1 StationId getStation() const { return StationId(((_type & 0xC0) << 2) | _data); } void setStation(const StationId station) { _type &= ~(0xC0); _type |= (enumValue(station) >> 2) & 0xC0; _data = enumValue(station) & 0xFF; } void setFormatArguments(FormatArguments& args) const; }; struct OrderStopAt : OrderStation { static constexpr OrderType kType = OrderType::StopAt; OrderStopAt(const StationId station) { setType(kType); setStation(station); } }; struct OrderRouteThrough : OrderStation { static constexpr OrderType kType = OrderType::RouteThrough; OrderRouteThrough(const StationId station) { setType(kType); setStation(station); } }; template<> constexpr bool Order::is<OrderStation>() const { if (is<OrderStopAt>()) { return true; } return is<OrderRouteThrough>(); } struct OrderRouteWaypoint : Order { static constexpr OrderType kType = OrderType::RouteWaypoint; uint8_t _data[5] = { 0 }; // 0x1 - 0x6 OrderRouteWaypoint(const World::TilePos2& pos, const uint8_t baseZ, const uint8_t direction, const uint8_t trackId) { setType(kType); setWaypoint(pos, baseZ); setDirection(direction); setTrackId(trackId); } void setWaypoint(const World::TilePos2& pos, const uint8_t baseZ); void setDirection(const uint8_t direction); void setTrackId(const uint8_t trackId); World::Pos3 getWaypoint() const; uint8_t getDirection() const; uint8_t getTrackId() const; }; struct OrderCargo : Order { uint8_t getCargo() const { return _type >> 3; } void setCargo(const uint8_t cargo) { _type &= ~0xF8; _type |= (cargo & 0x1F) << 3; } void setFormatArguments(FormatArguments& args) const; }; struct OrderUnloadAll : OrderCargo { static constexpr OrderType kType = OrderType::UnloadAll; OrderUnloadAll(const uint8_t cargo) { setType(kType); setCargo(cargo); } }; struct OrderWaitFor : OrderCargo { static constexpr OrderType kType = OrderType::WaitFor; OrderWaitFor(const uint8_t cargo) { setType(kType); setCargo(cargo); } }; #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Routing.cpp ```cpp #include "Routing.h" #include "Economy/Economy.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Map/AnimationManager.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/Track/TrackModSection.h" #include "Map/TrackElement.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Vehicle.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <sfl/static_vector.hpp> namespace OpenLoco::Vehicles { using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::Track; enum class TrackNetworkSearchFlags : uint16_t { none = 0, unk0 = 1U << 0, unk1 = 1U << 1, unk2 = 1U << 2, }; OPENLOCO_ENABLE_ENUM_OPERATORS(TrackNetworkSearchFlags); struct LocationOfInterest { World::Pos3 loc; uint16_t trackAndDirection; // This is a TaD with a AdditionalTaDFlags::hasSignal bit CompanyId company; uint8_t trackType; bool operator==(const LocationOfInterest& rhs) const { return (loc == rhs.loc) && (trackAndDirection == rhs.trackAndDirection) && (company == rhs.company) && (trackType == rhs.trackType); } TrackAndDirection::_TrackAndDirection tad() const { return TrackAndDirection::_TrackAndDirection((trackAndDirection & 0x1F8) >> 3, trackAndDirection & 0x7); } TrackAndDirection::_RoadAndDirection rad() const { return TrackAndDirection::_RoadAndDirection((trackAndDirection & 0x78) >> 3, trackAndDirection & 0x7); } }; // Note: This is not binary identical to vanilla so cannot be hooked! struct LocationOfInterestHashSet { static constexpr auto kMinFreeSlots = 100; // There must always be at least 100 free slots otherwise the hashset gets very inefficient private: class Iterator { uint16_t _index; const LocationOfInterestHashSet& _map; public: Iterator(uint16_t index, const LocationOfInterestHashSet& map) : _index(index) , _map(map) { findAllocatedEntry(); } void findAllocatedEntry() { while (_index < _map.mapSize && _map.locs[_index].loc == World::Pos3{ -1, -1, 0 }) { _index++; } } Iterator& operator++() { _index++; findAllocatedEntry(); return *this; } Iterator operator++(int) { Iterator retval = *this; ++(*this); return retval; } bool operator==(const Iterator& other) const { return _index == other._index; } LocationOfInterest operator*() const { return _map.get(_index); } // iterator traits using difference_type = std::ptrdiff_t; using value_type = LocationOfInterest; using pointer = LocationOfInterest*; using reference = LocationOfInterest&; using iterator_category = std::forward_iterator_tag; }; public: sfl::static_vector<LocationOfInterest, 4096> locs; size_t count; uint16_t mapSize; uint16_t mapSizeMask; uint16_t maxEntries; LocationOfInterestHashSet(uint16_t _maxSize) : count() , mapSize(_maxSize) , mapSizeMask(_maxSize - 1) , maxEntries(_maxSize - kMinFreeSlots) { assert(_maxSize <= locs.static_capacity); assert((mapSize & (mapSizeMask)) == 0); // Only works with powers of 2 locs.resize(mapSize); std::fill(std::begin(locs), std::end(locs), LocationOfInterest{ World::Pos3{ -1, -1, 0 }, 0, CompanyId::null, 0 }); } LocationOfInterest get(const uint16_t index) const { return locs[index]; } constexpr uint16_t hash(const LocationOfInterest& interest) const { return ((((interest.loc.x ^ interest.loc.z) / 32) ^ interest.loc.y) ^ interest.trackAndDirection) & mapSizeMask; } // 0x004A38DE & 0x004A3972 bool tryAdd(LocationOfInterest& interest) { auto index = hash(interest); for (; locs[index].loc != World::Pos3{ -1, -1, 0 }; ++index, index &= mapSizeMask) { if (get(index) == interest) { return false; } } if (count >= maxEntries) { return false; } locs[index] = interest; count++; return true; } Iterator begin() const { return Iterator(0, *this); } Iterator end() const { return Iterator(mapSize, *this); } }; // using FilterFunction = bool (*)(const LocationOfInterest& interest); // TODO C++20 make these concepts // using TransformFunction = void (*)(const LocationOfInterestHashSet& hashSet); // TODO C++20 make these concepts constexpr auto kNullTransformFunction = [](const LocationOfInterestHashSet&) {}; static loco_global<TrackNetworkSearchFlags, 0x01135FA6> _findTrackNetworkFlags; static loco_global<uint8_t, 0x01136085> _1136085; static std::optional<std::pair<World::SignalElement*, World::TrackElement*>> findSignalOnTrack(const World::Pos3& signalLoc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint8_t trackType, const uint8_t index) { auto tile = World::TileManager::get(signalLoc); for (auto& el : tile) { if (el.baseZ() != signalLoc.z / 4) { continue; } auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (!elTrack->hasSignal()) { continue; } if (elTrack->rotation() != trackAndDirection.cardinalDirection()) { continue; } if (elTrack->sequenceIndex() != index) { continue; } if (elTrack->trackObjectId() != trackType) { continue; } if (elTrack->trackId() != trackAndDirection.id()) { continue; } return std::make_pair(elTrack->next()->as<SignalElement>(), elTrack); } return std::nullopt; } // 0x0048963F but only when flags are 0xXXXX_XXXA SignalStateFlags getSignalState(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint8_t trackType, uint32_t flags) { auto trackStart = loc; if (trackAndDirection.isReversed()) { auto& trackSize = World::TrackData::getUnkTrack(trackAndDirection._data); trackStart += trackSize.pos; if (trackSize.rotationEnd < 12) { trackStart -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } flags ^= (1ULL << 31); } auto& trackPieces = World::TrackData::getTrackPiece(trackAndDirection.id()); auto& trackPiece = trackPieces[0]; auto signalLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, trackAndDirection.cardinalDirection()), 0 }; signalLoc.z += trackPiece.z; auto res = findSignalOnTrack(signalLoc, trackAndDirection, trackType, trackPiece.index); if (!res) { return SignalStateFlags::none; } auto* elSignal = res->first; // edx auto& signalSide = (flags & (1ULL << 31)) ? elSignal->getRight() : elSignal->getLeft(); auto ret = SignalStateFlags::none; if (signalSide.isOccupied()) { ret |= SignalStateFlags::occupied; } if (!signalSide.hasSignal()) { ret |= SignalStateFlags::blockedNoRoute; } if (flags & (1ULL << 31)) { if (!elSignal->getLeft().hasSignal() || elSignal->isLeftGhost()) { ret |= SignalStateFlags::occupiedOneWay; } if (elSignal->isRightGhost() && elSignal->getLeft().hasSignal()) { ret |= SignalStateFlags::blockedNoRoute; } } else { if (!elSignal->getRight().hasSignal() || elSignal->isRightGhost()) { ret |= SignalStateFlags::occupiedOneWay; } if (elSignal->isLeftGhost() && elSignal->getRight().hasSignal()) { ret |= SignalStateFlags::blockedNoRoute; } } return ret; } // 0x0048963F void setSignalState(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint8_t trackType, uint32_t flags) { const auto unk1 = flags & 0xFFFF; assert(unk1 != 10); // Only happens if wrong function was called call getSignalState auto trackStart = loc; if (trackAndDirection.isReversed()) { auto& trackSize = World::TrackData::getUnkTrack(trackAndDirection._data); trackStart += trackSize.pos; if (trackSize.rotationEnd < 12) { trackStart -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } flags ^= (1ULL << 31); } auto& trackPieces = World::TrackData::getTrackPiece(trackAndDirection.id()); for (auto& trackPiece : trackPieces) { auto signalLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, trackAndDirection.cardinalDirection()), 0 }; signalLoc.z += trackPiece.z; auto res = findSignalOnTrack(signalLoc, trackAndDirection, trackType, trackPiece.index); if (!res) { // This shouldn't happen I think. Either way useful in debug to know. assert(false); return; } auto [elSignal, foundTrack] = *res; // edx auto& signalSide = (flags & (1ULL << 31)) ? elSignal->getRight() : elSignal->getLeft(); if (unk1 == 16) { uint8_t lightStates = 0; if (flags & (1ULL << 30)) { lightStates |= 1 << 2; if (flags & (1ULL << 28)) { lightStates |= 1 << 0; } } if (flags & (1ULL << 29)) { lightStates |= 1 << 3; if (flags & (1ULL << 27)) { lightStates |= 1 << 1; } } if (signalSide.allLights() != lightStates) { bool shouldInvalidate = false; signalSide.setAllLights(lightStates); if (flags & (1ULL << 31)) { shouldInvalidate = foundTrack->sequenceIndex() == 0; } else { shouldInvalidate = foundTrack->isFlag6(); } if (shouldInvalidate) { Ui::ViewportManager::invalidate(signalLoc, signalLoc.z, signalLoc.z + 24, ZoomLevel::half); } } } else if (unk1 == 8) { signalSide.setIsOccupied(true); } else if (unk1 > 8) { signalSide.setIsOccupied(false); } else { signalSide.setUnk4(unk1 & 0x3); if ((unk1 & 0x3) == 0) { // Clear lights 0b1100_0000 signalSide.setAllLights(signalSide.allLights() & 0xC); } bool animate = false; if (flags & (1ULL << 31)) { if (foundTrack->isFlag6()) { animate = true; } } else { if (foundTrack->sequenceIndex() == 0) { animate = true; } } if (animate) { World::AnimationManager::createAnimation(0, signalLoc, signalLoc.z / 4); Ui::ViewportManager::invalidate(signalLoc, signalLoc.z, signalLoc.z + 24, ZoomLevel::half); } } } } // 0x004A2AF0 // Passes occupied state via _routingTransformData // Returns true for signal block end static bool findOccupationByBlock(const LocationOfInterest& interest, uint16_t& routingTransformData) { auto nextLoc = interest.loc; const auto tad = interest.tad(); auto& trackSize = World::TrackData::getUnkTrack(tad._data); nextLoc += trackSize.pos; if (trackSize.rotationEnd < 12) { nextLoc -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } auto backwardTaD = tad; backwardTaD.setReversed(!backwardTaD.isReversed()); const auto startLoc = tad.isReversed() ? nextLoc : interest.loc; for (const auto& trackPiece : TrackData::getTrackPiece(tad.id())) { const auto rotPos = Math::Vector::rotate(Pos2{ trackPiece.x, trackPiece.y }, tad.cardinalDirection()); const auto trackLoc = Pos2{ startLoc } + rotPos; for (auto* entity : EntityManager::EntityTileList(trackLoc)) { auto* vehicle = entity->asBase<Vehicles::VehicleBase>(); if (vehicle == nullptr) { continue; } if (vehicle->has38Flags(Vehicles::Flags38::unk_0 | Vehicles::Flags38::unk_2)) { continue; } if (vehicle->getTrackLoc() == interest.loc && vehicle->getTrackAndDirection().track == tad) { routingTransformData = 1; break; } if (vehicle->getTrackLoc() == nextLoc && vehicle->getTrackAndDirection().track == backwardTaD) { routingTransformData = 1; break; } } } return interest.trackAndDirection & World::Track::AdditionalTaDFlags::hasSignal; } // 0x004A2CE7 static void setSignalsOccupiedState(const LocationOfInterestHashSet& hashSet, const uint16_t& routingTransformData) { for (const auto& interest : hashSet) { if (!(interest.trackAndDirection & World::Track::AdditionalTaDFlags::hasSignal)) { continue; } bool isOccupied = routingTransformData & 1; uint32_t flags = (1ULL << 31) | (isOccupied ? 8ULL : 9ULL); setSignalState(interest.loc, interest.tad(), interest.trackType, flags); } } // 0x004A2D4C static bool sub_4A2D4C(const LocationOfInterest& interest, uint16_t& unk) { if (!(interest.trackAndDirection & World::Track::AdditionalTaDFlags::hasSignal)) { return false; } if ((getSignalState(interest.loc, interest.tad(), interest.trackType, (1ULL << 31)) & SignalStateFlags::occupied) != SignalStateFlags::none) { unk |= (1 << 0); } else { unk |= (1 << 1); } return true; } // The hash map can have a maximum of 4096 entries so the queue can't be larger than that. using LocationOfInterestQueue = sfl::static_vector<LocationOfInterest, 4096>; template<typename FilterFunction> static void findAllUsableTrackInNetwork(LocationOfInterestQueue& additionalTrackToCheck, const LocationOfInterest& initialInterest, FilterFunction&& filterFunction, LocationOfInterestHashSet& hashSet); // 0x004A313B & 0x004A35B7 // Iterates all individual tiles of a track piece to find tracks that need inspection template<typename FilterFunction> static void findAllUsableTrackPieces(LocationOfInterestQueue& additionalTrackToCheck, const LocationOfInterest& interest, FilterFunction&& filterFunction, LocationOfInterestHashSet& hashSet) { if ((_findTrackNetworkFlags & TrackNetworkSearchFlags::unk2) == TrackNetworkSearchFlags::none) { return; } const auto tad = interest.tad(); auto nextLoc = interest.loc; if (tad.isReversed()) { auto& trackSize = World::TrackData::getUnkTrack(tad._data); nextLoc += trackSize.pos; if (trackSize.rotationEnd < 12) { nextLoc -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } } for (auto& piece : World::TrackData::getTrackPiece(tad.id())) { const auto connectFlags = piece.connectFlags[tad.cardinalDirection()]; const auto pieceLoc = nextLoc + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, tad.cardinalDirection()), piece.z }; auto tile = World::TileManager::get(pieceLoc); for (auto& el : tile) { if (el.baseZ() != pieceLoc.z / 4) { continue; } auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->isAiAllocated() || elTrack->isGhost()) { continue; } const auto& targetPiece = World::TrackData::getTrackPiece(elTrack->trackId())[elTrack->sequenceIndex()]; const auto targetConnectFlags = targetPiece.connectFlags[elTrack->rotation()]; if ((targetConnectFlags & connectFlags) == 0) { continue; } // If identical then no need to keep checking if (elTrack->rotation() == tad.cardinalDirection() && elTrack->sequenceIndex() == piece.index && elTrack->trackObjectId() == interest.trackType && elTrack->trackId() == tad.id()) { continue; } const auto startTargetPos2 = World::Pos2{ pieceLoc } - Math::Vector::rotate(World::Pos2{ targetPiece.x, targetPiece.y }, elTrack->rotation()); const auto startTargetPos = World::Pos3{ startTargetPos2, static_cast<int16_t>(elTrack->baseHeight() - targetPiece.z) }; TrackAndDirection::_TrackAndDirection tad2(elTrack->trackId(), elTrack->rotation()); LocationOfInterest newInterest{ startTargetPos, tad2._data, elTrack->owner(), elTrack->trackObjectId() }; if (hashSet.tryAdd(newInterest)) { if (!filterFunction(newInterest)) { findAllUsableTrackPieces(additionalTrackToCheck, newInterest, filterFunction, hashSet); additionalTrackToCheck.push_back(newInterest); } } auto& trackSize = World::TrackData::getUnkTrack(tad2._data); auto endTargetPos = startTargetPos + trackSize.pos; if (trackSize.rotationEnd < 12) { endTargetPos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } tad2.setReversed(!tad2.isReversed()); LocationOfInterest newInterestR{ endTargetPos, tad2._data, elTrack->owner(), elTrack->trackObjectId() }; if (hashSet.tryAdd(newInterestR)) { if (!filterFunction(newInterestR)) { findAllUsableTrackPieces(additionalTrackToCheck, newInterestR, filterFunction, hashSet); additionalTrackToCheck.push_back(newInterestR); } } } } } // 0x004A2FE6 & 0x004A3462 template<typename FilterFunction> static void findAllUsableTrackInNetwork(LocationOfInterestQueue& additionalTrackToCheck, const LocationOfInterest& initialInterest, FilterFunction&& filterFunction, LocationOfInterestHashSet& hashSet) { const auto [trackEndLoc, trackEndRotation] = World::Track::getTrackConnectionEnd(initialInterest.loc, initialInterest.tad()._data); auto tc = World::Track::getTrackConnections(trackEndLoc, trackEndRotation, initialInterest.company, initialInterest.trackType, 0, 0); if (!tc.connections.empty()) { for (auto c : tc.connections) { uint16_t trackAndDirection2 = c & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; LocationOfInterest interest{ trackEndLoc, trackAndDirection2, initialInterest.company, initialInterest.trackType }; if (hashSet.tryAdd(interest)) { if (!filterFunction(interest)) { findAllUsableTrackPieces(additionalTrackToCheck, interest, filterFunction, hashSet); additionalTrackToCheck.push_back(interest); } } } } else { _1136085 = *_1136085 | (1 << 0); } if ((_findTrackNetworkFlags & TrackNetworkSearchFlags::unk1) == TrackNetworkSearchFlags::none) { // odd logic here clearing a flag in a branch that can never hit auto nextLoc = initialInterest.loc; auto& trackSize = World::TrackData::getUnkTrack(initialInterest.tad()._data); nextLoc += trackSize.pos; if (trackSize.rotationEnd < 12) { nextLoc -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } const auto rotation = World::kReverseRotation[trackSize.rotationEnd]; auto tc2 = World::Track::getTrackConnections(nextLoc, rotation, initialInterest.company, initialInterest.trackType, 0, 0); for (auto c : tc2.connections) { uint16_t trackAndDirection2 = c & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; LocationOfInterest interest{ nextLoc, trackAndDirection2, initialInterest.company, initialInterest.trackType }; if (hashSet.tryAdd(interest)) { if (!filterFunction(interest)) { findAllUsableTrackPieces(additionalTrackToCheck, interest, filterFunction, hashSet); additionalTrackToCheck.push_back(interest); } } } } } constexpr size_t kSignalHashSetSize = 0x400; constexpr size_t kTrackModHashSetSize = 0x1000; // 0x004A2E46 & 0x004A2DE4 template<typename FilterFunction, typename TransformFunction> static void findAllTracksFilterTransform(LocationOfInterestHashSet& interestMap, TrackNetworkSearchFlags searchFlags, const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType, FilterFunction&& filterFunction, TransformFunction&& transformFunction) { // _1135F06 = &interestMap; // _filterFunction = filterFunction; // _transformFunction = transformFunction; // _1135F0A = 0; _findTrackNetworkFlags = searchFlags; // Note: This function and its call chain findAllUsableTrackInNetwork and findAllUsableTrackPieces have been modified // to not be recursive anymore. LocationOfInterestQueue trackToCheck{ LocationOfInterest{ loc, trackAndDirection._data, company, trackType } }; while (!trackToCheck.empty()) { const auto interest = trackToCheck.back(); trackToCheck.pop_back(); findAllUsableTrackInNetwork(trackToCheck, interest, filterFunction, interestMap); } transformFunction(interestMap); } template<typename FilterFunction> static void findAllUsableRoadInNetwork(LocationOfInterestQueue& additionalRoadToCheck, const LocationOfInterest& initialInterest, FilterFunction&& filterFunction, LocationOfInterestHashSet& hashSet); // 0x00479EFA // Iterates all individual tiles of a road piece to find roads that need inspection template<typename FilterFunction> static void findAllUsableRoadPieces(LocationOfInterestQueue& additionalRoadToCheck, const LocationOfInterest& interest, FilterFunction&& filterFunction, LocationOfInterestHashSet& hashSet) { if ((_findTrackNetworkFlags & TrackNetworkSearchFlags::unk2) == TrackNetworkSearchFlags::none) { return; } const auto rad = interest.rad(); auto nextLoc = interest.loc; if (rad.isReversed()) { auto& roadSize = World::TrackData::getUnkRoad(rad._data); nextLoc += roadSize.pos; if (roadSize.rotationEnd < 12) { nextLoc -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } } for (auto& piece : World::TrackData::getRoadPiece(rad.id())) { const auto connectFlags = piece.connectFlags[rad.cardinalDirection()]; const auto pieceLoc = nextLoc + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rad.cardinalDirection()), piece.z }; auto tile = World::TileManager::get(pieceLoc); for (auto& el : tile) { if (el.baseZ() != pieceLoc.z / 4) { continue; } auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } const auto& targetPiece = World::TrackData::getRoadPiece(elRoad->roadId())[elRoad->sequenceIndex()]; const auto targetConnectFlags = targetPiece.connectFlags[elRoad->rotation()]; if ((targetConnectFlags & connectFlags) == 0) { continue; } // If identical then no need to keep checking if (elRoad->rotation() == rad.cardinalDirection() && elRoad->sequenceIndex() == piece.index && elRoad->roadObjectId() == interest.trackType && elRoad->roadId() == rad.id()) { continue; } const auto startTargetPos2 = World::Pos2{ pieceLoc } - Math::Vector::rotate(World::Pos2{ targetPiece.x, targetPiece.y }, elRoad->rotation()); const auto startTargetPos = World::Pos3{ startTargetPos2, static_cast<int16_t>(elRoad->baseHeight() - targetPiece.z) }; TrackAndDirection::_RoadAndDirection tad2(elRoad->roadId(), elRoad->rotation()); LocationOfInterest newInterest{ startTargetPos, tad2._data, elRoad->owner(), elRoad->roadObjectId() }; if (hashSet.tryAdd(newInterest)) { if (!filterFunction(newInterest)) { findAllUsableRoadPieces(additionalRoadToCheck, newInterest, filterFunction, hashSet); additionalRoadToCheck.push_back(newInterest); } } auto& roadSize = World::TrackData::getUnkRoad(tad2._data); auto endTargetPos = startTargetPos + roadSize.pos; if (roadSize.rotationEnd < 12) { endTargetPos -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } tad2.setReversed(!tad2.isReversed()); LocationOfInterest newInterestR{ endTargetPos, tad2._data, elRoad->owner(), elRoad->roadObjectId() }; if (hashSet.tryAdd(newInterestR)) { if (!filterFunction(newInterestR)) { findAllUsableRoadPieces(additionalRoadToCheck, newInterestR, filterFunction, hashSet); additionalRoadToCheck.push_back(newInterestR); } } } } } // 0x00479DB1 template<typename FilterFunction> static void findAllUsableRoadInNetwork(LocationOfInterestQueue& additionalRoadToCheck, const LocationOfInterest& initialInterest, FilterFunction&& filterFunction, LocationOfInterestHashSet& hashSet) { const auto [roadEndLoc, roadEndRotation] = World::Track::getRoadConnectionEnd(initialInterest.loc, initialInterest.rad()._data); auto tc = World::Track::getRoadConnections(roadEndLoc, roadEndRotation, initialInterest.company, initialInterest.trackType, 0, 0); if (!tc.connections.empty()) { for (auto c : tc.connections) { uint16_t trackAndDirection2 = c & World::Track::AdditionalTaDFlags::basicRaDWithSignalMask; LocationOfInterest interest{ roadEndLoc, trackAndDirection2, initialInterest.company, initialInterest.trackType }; if (hashSet.tryAdd(interest)) { if (!filterFunction(interest)) { findAllUsableRoadPieces(additionalRoadToCheck, interest, filterFunction, hashSet); additionalRoadToCheck.push_back(interest); } } } } else { _1136085 = *_1136085 | (1 << 0); } if ((_findTrackNetworkFlags & TrackNetworkSearchFlags::unk1) == TrackNetworkSearchFlags::none) { // odd logic here clearing a flag in a branch that can never hit auto nextLoc = initialInterest.loc; auto& roadSize = World::TrackData::getUnkRoad(initialInterest.rad()._data); nextLoc += roadSize.pos; if (roadSize.rotationEnd < 12) { nextLoc -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } const auto rotation = World::kReverseRotation[roadSize.rotationEnd]; auto tc2 = World::Track::getRoadConnections(nextLoc, rotation, initialInterest.company, initialInterest.trackType, 0, 0); for (auto c : tc2.connections) { uint16_t trackAndDirection2 = c & World::Track::AdditionalTaDFlags::basicRaDWithSignalMask; LocationOfInterest interest{ nextLoc, trackAndDirection2, initialInterest.company, initialInterest.trackType }; if (hashSet.tryAdd(interest)) { if (!filterFunction(interest)) { findAllUsableRoadPieces(additionalRoadToCheck, interest, filterFunction, hashSet); additionalRoadToCheck.push_back(interest); } } } } } template<typename FilterFunction, typename TransformFunction> static void findAllRoadsFilterTransform(LocationOfInterestHashSet& interestMap, TrackNetworkSearchFlags searchFlags, const World::Pos3& loc, const TrackAndDirection::_RoadAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType, FilterFunction&& filterFunction, TransformFunction&& transformFunction) { // _1135F06 = &interestMap; // _filterFunction = filterFunction; // _transformFunction = transformFunction; // _1135F0A = 0; _findTrackNetworkFlags = searchFlags; // Note: This function and its call chain findAllUsableTrackInNetwork and findAllUsableTrackPieces have been modified // to not be recursive anymore. LocationOfInterestQueue roadToCheck{ LocationOfInterest{ loc, trackAndDirection._data, company, trackType } }; while (!roadToCheck.empty()) { const auto interest = roadToCheck.back(); roadToCheck.pop_back(); findAllUsableRoadInNetwork(roadToCheck, interest, filterFunction, interestMap); } transformFunction(interestMap); } // 0x004A2AD7 void sub_4A2AD7(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType) { // 0x001135F88 uint16_t routingTransformData = 0; auto filterFunction = [&routingTransformData](const LocationOfInterest& interest) { return findOccupationByBlock(interest, routingTransformData); }; auto transformFunction = [&routingTransformData](const LocationOfInterestHashSet& interestMap) { setSignalsOccupiedState(interestMap, routingTransformData); }; LocationOfInterestHashSet interestMap{ kSignalHashSetSize }; findAllTracksFilterTransform( interestMap, TrackNetworkSearchFlags::unk0 | TrackNetworkSearchFlags::unk2, loc, trackAndDirection, company, trackType, filterFunction, transformFunction); } // 0x004A2A39 bool isBlockOccupied(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType) { // 0x001135F88 uint16_t routingTransformData = 0; auto filterFunction = [&routingTransformData](const LocationOfInterest& interest) { return findOccupationByBlock(interest, routingTransformData); }; LocationOfInterestHashSet interestMap{ kSignalHashSetSize }; findAllTracksFilterTransform( interestMap, TrackNetworkSearchFlags::unk0 | TrackNetworkSearchFlags::unk2, loc, trackAndDirection, company, trackType, filterFunction, [](LocationOfInterestHashSet&) {}); return routingTransformData & 1; } // 0x004AC217 // Passes occupied state via _routingTransformData // Returns true for signal block end static bool setReverseSignalOccupied(const LocationOfInterest& interest) { if (!(interest.trackAndDirection & World::Track::AdditionalTaDFlags::hasSignal)) { return false; } setSignalState(interest.loc, interest.tad(), interest.trackType, (1ULL << 31) | (8)); return true; } void setReverseSignalOccupiedInBlock(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType) { LocationOfInterestHashSet interestMap{ kSignalHashSetSize }; findAllTracksFilterTransform( interestMap, TrackNetworkSearchFlags::unk0 | TrackNetworkSearchFlags::unk2, loc, trackAndDirection, company, trackType, setReverseSignalOccupied, [](LocationOfInterestHashSet&) {}); } // 0x004A2A58 uint8_t sub_4A2A58(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType) { // 0x001135F88 uint16_t unk = 0; LocationOfInterestHashSet interestMap{ kSignalHashSetSize }; auto filterFunction = [&unk](const LocationOfInterest& interest) { return sub_4A2D4C(interest, unk); }; findAllTracksFilterTransform( interestMap, TrackNetworkSearchFlags::unk0 | TrackNetworkSearchFlags::unk2, loc, trackAndDirection, company, trackType, filterFunction, kNullTransformFunction); return unk; } // 0x004A2AA1 // Passes state via _routingTransformData static bool sub_4A2AA1(const LocationOfInterest& interest, uint16_t& routingTransformData) { if (!(interest.trackAndDirection & World::Track::AdditionalTaDFlags::hasSignal)) { return false; } const auto signalState = getSignalState(interest.loc, interest.tad(), interest.trackType, 0); const bool occupiedOneWay = (signalState & SignalStateFlags::occupiedOneWay) != SignalStateFlags::none; // ??? Not sure why we are doing this const bool clearRoute = ((signalState & SignalStateFlags::blockedNoRoute) == SignalStateFlags::none) && ((signalState & SignalStateFlags::occupied) == SignalStateFlags::none); if (occupiedOneWay || clearRoute) { routingTransformData |= (1 << 0); } return true; } uint8_t sub_4A2A77(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType) { uint16_t routingTransformData = 0; _1136085 = 0; auto filterFunction = [&routingTransformData](const LocationOfInterest& interest) { return sub_4A2AA1(interest, routingTransformData); }; LocationOfInterestHashSet interestMap{ kSignalHashSetSize }; findAllTracksFilterTransform( interestMap, TrackNetworkSearchFlags::unk0 | TrackNetworkSearchFlags::unk1, loc, trackAndDirection, company, trackType, filterFunction, [](LocationOfInterestHashSet&) {}); if (_1136085 & (1U << 0)) { routingTransformData |= (1U << 1); } return routingTransformData; } // 0x004A5D94 static bool applyTrackModToTrack(const LocationOfInterest& interest, const uint8_t flags, LocationOfInterestHashSet* hashSet, ModSection modSelection, uint8_t trackObjectId, uint8_t trackModObjectIds, currency32_t& totalCost, CompanyId companyId, bool& hasFailedAllPlacement) { // If not in single segment mode then we should add the reverse // direction of track to the hashset to prevent it being visited. // This is because track mods do not have directions so applying // to the reverse would do nothing (or worse double spend) if (hashSet != nullptr) { LocationOfInterest reverseInterest = interest; reverseInterest.loc = interest.loc; const auto tad = interest.tad(); auto& trackSize = World::TrackData::getUnkTrack(tad._data); reverseInterest.loc += trackSize.pos; if (trackSize.rotationEnd < 12) { reverseInterest.loc -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } reverseInterest.trackAndDirection ^= (1 << 2); // Reverse flag hashSet->tryAdd(reverseInterest); } auto* trackObj = ObjectManager::get<TrackObject>(trackObjectId); bool placementFailure = false; for (auto i = 0; i < 4; ++i) { if (!(trackModObjectIds & (1U << i))) { continue; } auto* trackModObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); const auto pieceFlags = TrackData::getTrackMiscData(interest.tad().id()).compatibleFlags; if ((trackModObj->trackPieces & pieceFlags) != pieceFlags) { //_1135F64 |= (1 << 0); placement failed at least once placementFailure = true; break; } } if (!placementFailure) { auto trackStart = interest.loc; const auto tad = interest.tad(); if (tad.isReversed()) { auto& trackSize = World::TrackData::getUnkTrack(tad._data); trackStart += trackSize.pos; if (trackSize.rotationEnd < 12) { trackStart -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } } for (auto& trackPiece : TrackData::getTrackPiece(tad.id())) { auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, tad.cardinalDirection()), 0 }; trackLoc.z += trackPiece.z; auto tile = TileManager::get(trackLoc); World::TrackElement* elTrack = nullptr; for (auto& el : tile) { elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != trackLoc.z) { continue; } if (elTrack->rotation() != tad.cardinalDirection()) { continue; } if (elTrack->sequenceIndex() != trackPiece.index) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if (elTrack->trackId() != tad.id()) { continue; } break; } if (elTrack == nullptr) { placementFailure = true; break; } if (trackPiece.index == 0) { // increment successful placement count hasFailedAllPlacement = false; // For each track mod // Get mod cost (changes depending on track id) for (auto i = 0; i < 4; ++i) { if (!(trackModObjectIds & (1U << i))) { continue; } if (elTrack->mods() & (1U << i)) { continue; } auto* trackModObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); const auto baseCost = Economy::getInflationAdjustedCost(trackModObj->buildCostFactor, trackModObj->costIndex, 10); const auto cost = (baseCost * TrackData::getTrackMiscData(tad.id()).costFactor) / 256; totalCost += cost; } } if (flags & GameCommands::Flags::apply) { bool invalidate = false; if (flags & GameCommands::Flags::ghost) { if (CompanyManager::getControllingId() == companyId) { elTrack->setHasGhostMods(true); invalidate = true; } } else { for (auto i = 0; i < 4; ++i) { if (trackModObjectIds & (1U << i)) { elTrack->setMod(i, true); } } invalidate = true; } if (invalidate) { Ui::ViewportManager::invalidate(trackLoc, elTrack->baseHeight(), elTrack->clearHeight(), ZoomLevel::half); } } } } if (modSelection == ModSection::block) { return interest.trackAndDirection & Track::AdditionalTaDFlags::hasSignal; } return false; } // 0x004A6136 static bool removeTrackModToTrack(const LocationOfInterest& interest, const uint8_t flags, LocationOfInterestHashSet* hashSet, ModSection modSelection, uint8_t trackObjectId, uint8_t trackModObjectIds, currency32_t& totalCost, CompanyId companyId) { // If not in single segment mode then we should add the reverse // direction of track to the hashset to prevent it being visited. // This is because track mods do not have directions so applying // to the reverse would do nothing (or worse double spend) if (hashSet != nullptr) { LocationOfInterest reverseInterest = interest; reverseInterest.loc = interest.loc; const auto tad = interest.tad(); auto& trackSize = World::TrackData::getUnkTrack(tad._data); reverseInterest.loc += trackSize.pos; if (trackSize.rotationEnd < 12) { reverseInterest.loc -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } reverseInterest.trackAndDirection ^= (1 << 2); // Reverse flag hashSet->tryAdd(reverseInterest); } auto* trackObj = ObjectManager::get<TrackObject>(trackObjectId); auto trackStart = interest.loc; const auto tad = interest.tad(); if (tad.isReversed()) { auto& trackSize = World::TrackData::getUnkTrack(tad._data); trackStart += trackSize.pos; if (trackSize.rotationEnd < 12) { trackStart -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } } for (auto& trackPiece : TrackData::getTrackPiece(tad.id())) { auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, tad.cardinalDirection()), 0 }; trackLoc.z += trackPiece.z; auto tile = TileManager::get(trackLoc); World::TrackElement* elTrack = nullptr; for (auto& el : tile) { elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != trackLoc.z) { continue; } if (elTrack->rotation() != tad.cardinalDirection()) { continue; } if (elTrack->sequenceIndex() != trackPiece.index) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if (elTrack->trackId() != tad.id()) { continue; } break; } if (elTrack == nullptr) { break; } if (trackPiece.index == 0) { // For each track mod // Get mod cost (changes depending on track id) for (auto i = 0; i < 4; ++i) { if (!(trackModObjectIds & (1U << i))) { continue; } if (!(elTrack->mods() & (1U << i))) { continue; } auto* trackModObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); const auto baseCost = Economy::getInflationAdjustedCost(trackModObj->sellCostFactor, trackModObj->costIndex, 10); const auto cost = (baseCost * TrackData::getTrackMiscData(tad.id()).costFactor) / 256; totalCost += cost; } } if (flags & GameCommands::Flags::apply) { bool invalidate = false; if (flags & GameCommands::Flags::ghost) { if (CompanyManager::getControllingId() == companyId) { elTrack->setHasGhostMods(false); invalidate = true; } } else { for (auto i = 0; i < 4; ++i) { if (trackModObjectIds & (1U << i)) { elTrack->setMod(i, false); } } invalidate = true; } if (invalidate) { Ui::ViewportManager::invalidate(trackLoc, elTrack->baseHeight(), elTrack->clearHeight(), ZoomLevel::half); } } } if (modSelection == ModSection::block) { return interest.trackAndDirection & Track::AdditionalTaDFlags::hasSignal; } return false; } ApplyTrackModsResult applyTrackModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_TrackAndDirection trackAndDirection, CompanyId company, uint8_t trackType, uint8_t flags, ModSection modSelection, uint8_t trackModObjIds) { ApplyTrackModsResult result{}; result.cost = 0; result.allPlacementsFailed = true; result.networkTooComplex = false; if (modSelection == Track::ModSection::single) { LocationOfInterest interest{ pos, trackAndDirection._data, company, trackType }; applyTrackModToTrack(interest, flags, nullptr, modSelection, trackType, trackModObjIds, result.cost, company, result.allPlacementsFailed); return result; } LocationOfInterestHashSet interestHashSet{ kTrackModHashSetSize }; auto filterFunction = [flags, modSelection, trackType, trackModObjIds, &result, company, &interestHashSet](const LocationOfInterest& interest) { return applyTrackModToTrack(interest, flags, &interestHashSet, modSelection, trackType, trackModObjIds, result.cost, company, result.allPlacementsFailed); }; findAllTracksFilterTransform(interestHashSet, TrackNetworkSearchFlags::unk0, pos, trackAndDirection, company, trackType, filterFunction, kNullTransformFunction); result.networkTooComplex = interestHashSet.count >= interestHashSet.maxEntries; return result; } currency32_t removeTrackModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_TrackAndDirection trackAndDirection, CompanyId company, uint8_t trackType, uint8_t flags, ModSection modSelection, uint8_t trackModObjIds) { currency32_t cost = 0; if (modSelection == Track::ModSection::single) { LocationOfInterest interest{ pos, trackAndDirection._data, company, trackType }; removeTrackModToTrack(interest, flags, nullptr, modSelection, trackType, trackModObjIds, cost, company); return cost; } LocationOfInterestHashSet interestHashSet{ kTrackModHashSetSize }; auto filterFunction = [flags, modSelection, trackType, trackModObjIds, &cost, company, &interestHashSet](const LocationOfInterest& interest) { return removeTrackModToTrack(interest, flags, &interestHashSet, modSelection, trackType, trackModObjIds, cost, company); }; findAllTracksFilterTransform(interestHashSet, TrackNetworkSearchFlags::unk0, pos, trackAndDirection, company, trackType, filterFunction, kNullTransformFunction); return cost; } // 0x0047A5E6 static bool applyRoadModToRoad(const LocationOfInterest& interest, const uint8_t flags, LocationOfInterestHashSet* hashSet, ModSection modSelection, uint8_t roadObjectId, uint8_t roadModObjectIds, currency32_t& totalCost, CompanyId companyId, bool& hasFailedAllPlacement) { // If not in single segment mode then we should add the reverse // direction of track to the hashset to prevent it being visited. // This is because track mods do not have directions so applying // to the reverse would do nothing (or worse double spend) if (hashSet != nullptr) { LocationOfInterest reverseInterest = interest; reverseInterest.loc = interest.loc; const auto rad = interest.rad(); auto& roadSize = World::TrackData::getUnkRoad(rad._data); reverseInterest.loc += roadSize.pos; if (roadSize.rotationEnd < 12) { reverseInterest.loc -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } reverseInterest.trackAndDirection ^= (1 << 2); // Reverse flag hashSet->tryAdd(reverseInterest); } auto* roadObj = ObjectManager::get<RoadObject>(roadObjectId); bool placementFailure = false; for (auto i = 0; i < 2; ++i) { if (!(roadModObjectIds & (1U << i))) { continue; } auto* roadModObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); const auto pieceFlags = TrackData::getRoadMiscData(interest.rad().id()).compatibleFlags; if ((roadModObj->roadPieces & pieceFlags) != pieceFlags) { //_1135F64 |= (1 << 0); placement failed at least once placementFailure = true; break; } } if (!placementFailure) { auto roadStart = interest.loc; const auto rad = interest.rad(); if (rad.isReversed()) { auto& roadSize = World::TrackData::getUnkRoad(rad._data); roadStart += roadSize.pos; if (roadSize.rotationEnd < 12) { roadStart -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } } for (auto& roadPiece : TrackData::getRoadPiece(rad.id())) { auto roadLoc = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece.x, roadPiece.y }, rad.cardinalDirection()), 0 }; roadLoc.z += roadPiece.z; auto tile = TileManager::get(roadLoc); World::RoadElement* elRoad = nullptr; for (auto& el : tile) { elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != roadLoc.z) { continue; } if (elRoad->rotation() != rad.cardinalDirection()) { continue; } if (elRoad->sequenceIndex() != roadPiece.index) { continue; } if (elRoad->roadObjectId() != roadObjectId) { continue; } if (elRoad->roadId() != rad.id()) { continue; } break; } if (elRoad == nullptr) { placementFailure = true; break; } if (roadPiece.index == 0) { // increment successful placement count hasFailedAllPlacement = false; // For each road mod // Get mod cost (changes depending on road id) for (auto i = 0; i < 2; ++i) { if (!(roadModObjectIds & (1U << i))) { continue; } if (elRoad->mods() & (1U << i)) { continue; } auto* roadModObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); const auto baseCost = Economy::getInflationAdjustedCost(roadModObj->buildCostFactor, roadModObj->costIndex, 10); const auto cost = (baseCost * TrackData::getRoadMiscData(rad.id()).costFactor) / 256; totalCost += cost; } } if (flags & GameCommands::Flags::apply) { bool invalidate = false; if (flags & GameCommands::Flags::ghost) { if (CompanyManager::getControllingId() == companyId) { elRoad->setHasGhostMods(true); invalidate = true; } } else { for (auto i = 0; i < 2; ++i) { if (roadModObjectIds & (1U << i)) { elRoad->setMod(i, true); } } invalidate = true; } if (invalidate) { Ui::ViewportManager::invalidate(roadLoc, elRoad->baseHeight(), elRoad->clearHeight(), ZoomLevel::half); } } } } if (modSelection == ModSection::block) { return interest.trackAndDirection & Track::AdditionalTaDFlags::hasSignal; } return false; } ApplyTrackModsResult applyRoadModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_RoadAndDirection roadAndDirection, CompanyId company, uint8_t roadType, uint8_t flags, ModSection modSelection, uint8_t roadModObjIds) { ApplyTrackModsResult result{}; result.cost = 0; result.allPlacementsFailed = true; result.networkTooComplex = false; if (modSelection == Track::ModSection::single) { LocationOfInterest interest{ pos, roadAndDirection._data, company, roadType }; applyRoadModToRoad(interest, flags, nullptr, modSelection, roadType, roadModObjIds, result.cost, company, result.allPlacementsFailed); return result; } LocationOfInterestHashSet interestHashSet{ kTrackModHashSetSize }; auto filterFunction = [flags, modSelection, roadType, roadModObjIds, &result, company, &interestHashSet](const LocationOfInterest& interest) { return applyRoadModToRoad(interest, flags, &interestHashSet, modSelection, roadType, roadModObjIds, result.cost, company, result.allPlacementsFailed); }; findAllRoadsFilterTransform(interestHashSet, TrackNetworkSearchFlags::unk0, pos, roadAndDirection, company, roadType, filterFunction, kNullTransformFunction); result.networkTooComplex = interestHashSet.count >= interestHashSet.maxEntries; return result; } // 0x0047A8F0 static bool removeRoadModToTrack(const LocationOfInterest& interest, const uint8_t flags, LocationOfInterestHashSet* hashSet, ModSection modSelection, uint8_t roadObjectId, uint8_t roadModObjectIds, currency32_t& totalCost, CompanyId companyId) { // If not in single segment mode then we should add the reverse // direction of track to the hashset to prevent it being visited. // This is because track mods do not have directions so applying // to the reverse would do nothing (or worse double spend) if (hashSet != nullptr) { LocationOfInterest reverseInterest = interest; reverseInterest.loc = interest.loc; const auto rad = interest.rad(); auto& roadSize = World::TrackData::getUnkRoad(rad._data); reverseInterest.loc += roadSize.pos; if (roadSize.rotationEnd < 12) { reverseInterest.loc -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } reverseInterest.trackAndDirection ^= (1 << 2); // Reverse flag hashSet->tryAdd(reverseInterest); } auto* roadObj = ObjectManager::get<RoadObject>(roadObjectId); auto roadStart = interest.loc; const auto rad = interest.rad(); if (rad.isReversed()) { auto& roadSize = World::TrackData::getUnkRoad(rad._data); roadStart += roadSize.pos; if (roadSize.rotationEnd < 12) { roadStart -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } } for (auto& roadPiece : TrackData::getRoadPiece(rad.id())) { auto roadLoc = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece.x, roadPiece.y }, rad.cardinalDirection()), 0 }; roadLoc.z += roadPiece.z; auto tile = TileManager::get(roadLoc); World::RoadElement* elRoad = nullptr; for (auto& el : tile) { elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != roadLoc.z) { continue; } if (elRoad->rotation() != rad.cardinalDirection()) { continue; } if (elRoad->sequenceIndex() != roadPiece.index) { continue; } if (elRoad->roadObjectId() != roadObjectId) { continue; } if (elRoad->roadId() != rad.id()) { continue; } break; } if (elRoad == nullptr) { break; } if (roadPiece.index == 0) { // For each track mod // Get mod cost (changes depending on track id) for (auto i = 0; i < 2; ++i) { if (!(roadModObjectIds & (1U << i))) { continue; } if (!(elRoad->mods() & (1U << i))) { continue; } auto* roadModObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); const auto baseCost = Economy::getInflationAdjustedCost(roadModObj->sellCostFactor, roadModObj->costIndex, 10); const auto cost = (baseCost * TrackData::getRoadMiscData(rad.id()).costFactor) / 256; totalCost += cost; } } if (flags & GameCommands::Flags::apply) { bool invalidate = false; if (flags & GameCommands::Flags::ghost) { if (CompanyManager::getControllingId() == companyId) { elRoad->setHasGhostMods(false); invalidate = true; } } else { for (auto i = 0; i < 4; ++i) { if (roadModObjectIds & (1U << i)) { elRoad->setMod(i, false); } } invalidate = true; } if (invalidate) { Ui::ViewportManager::invalidate(roadLoc, elRoad->baseHeight(), elRoad->clearHeight(), ZoomLevel::half); } } } if (modSelection == ModSection::block) { return interest.trackAndDirection & Track::AdditionalTaDFlags::hasSignal; } return false; } currency32_t removeRoadModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_RoadAndDirection roadAndDirection, CompanyId company, uint8_t roadType, uint8_t flags, World::Track::ModSection modSelection, uint8_t roadModObjIds) { currency32_t cost = 0; if (modSelection == Track::ModSection::single) { LocationOfInterest interest{ pos, roadAndDirection._data, company, roadType }; removeRoadModToTrack(interest, flags, nullptr, modSelection, roadType, roadModObjIds, cost, company); return cost; } LocationOfInterestHashSet interestHashSet{ kTrackModHashSetSize }; auto filterFunction = [flags, modSelection, roadType, roadModObjIds, &cost, company, &interestHashSet](const LocationOfInterest& interest) { return removeRoadModToTrack(interest, flags, &interestHashSet, modSelection, roadType, roadModObjIds, cost, company); }; findAllRoadsFilterTransform(interestHashSet, TrackNetworkSearchFlags::unk0, pos, roadAndDirection, company, roadType, filterFunction, kNullTransformFunction); return cost; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Routing.h ```h #pragma once #include "Engine/Limits.h" #include <cstdint> namespace OpenLoco::Vehicles { #pragma pack(push, 1) struct RoutingHandle { uint16_t _data; constexpr RoutingHandle(const uint16_t vehicleRef, const uint8_t index) : _data((vehicleRef * Limits::kMaxRoutingsPerVehicle) | index) { } constexpr uint16_t getVehicleRef() const { return _data / Limits::kMaxRoutingsPerVehicle; } constexpr uint8_t getIndex() const { return _data % Limits::kMaxRoutingsPerVehicle; } constexpr void setIndex(uint8_t newIndex) { _data &= ~(Limits::kMaxRoutingsPerVehicle - 1); _data |= newIndex & (Limits::kMaxRoutingsPerVehicle - 1); } bool operator==(const RoutingHandle other) const { return _data == other._data; } }; static_assert(sizeof(RoutingHandle) == 2); #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/RoutingManager.cpp ```cpp #include "RoutingManager.h" #include "GameState.h" #include <algorithm> namespace OpenLoco::Vehicles::RoutingManager { static auto& routings() { return getGameState().routings; } static std::optional<uint16_t> findFreeRoutingVehicleRef() { const auto& routingArr = routings(); const auto res = std::find_if(std::begin(routingArr), std::end(routingArr), [](const auto& route) { return route[0] == kRoutingNull; }); if (res == std::end(routingArr)) { return std::nullopt; } return std::distance(std::begin(routingArr), res); } void resetRoutings(const RoutingHandle handle) { auto& vehRoutingArr = routings()[handle.getVehicleRef()]; std::fill(std::begin(vehRoutingArr), std::end(vehRoutingArr), kAllocatedButFreeRouting); } bool isEmptyRoutingSlotAvailable() { return findFreeRoutingVehicleRef().has_value(); } // 0x004B1E00 std::optional<RoutingHandle> getAndAllocateFreeRoutingHandle() { auto vehicleRef = findFreeRoutingVehicleRef(); if (vehicleRef.has_value()) { auto& vehRoutingArr = routings()[*vehicleRef]; std::fill(std::begin(vehRoutingArr), std::end(vehRoutingArr), kAllocatedButFreeRouting); return { RoutingHandle(*vehicleRef, 0) }; } return std::nullopt; } uint16_t getRouting(const RoutingHandle handle) { return routings()[handle.getVehicleRef()][handle.getIndex()]; } void setRouting(const RoutingHandle handle, uint16_t routing) { routings()[handle.getVehicleRef()][handle.getIndex()] = routing; } void freeRouting(const RoutingHandle handle) { setRouting(handle, kAllocatedButFreeRouting); } // 0x004B1E77 void freeRoutingHandle(const RoutingHandle handle) { auto& vehRoutingArr = routings()[handle.getVehicleRef()]; std::fill(std::begin(vehRoutingArr), std::end(vehRoutingArr), kRoutingNull); } // 0x004A8810 void resetRoutingTable() { std::fill_n(&routings()[0][0], Limits::kMaxVehicles * Limits::kMaxRoutingsPerVehicle, kRoutingNull); } RingView::Iterator::Iterator(const RoutingHandle& begin, bool isEnd, Direction direction) : _current(begin) , _isEnd(isEnd) , _direction(direction) { if (routings()[_current.getVehicleRef()][_current.getIndex()] == kAllocatedButFreeRouting) { _hasLooped = true; } } RingView::Iterator& RingView::Iterator::operator++() { if (_direction == Direction::reverse) { return --*this; } _current.setIndex((_current.getIndex() + 1) & 0x3F); if (_current.getIndex() == 0) { _hasLooped = true; } return *this; } RingView::Iterator& RingView::Iterator::operator--() { _current.setIndex((_current.getIndex() - 1) & 0x3F); if (_current.getIndex() == 0x3F) { _hasLooped = true; } return *this; } bool RingView::Iterator::operator==(const RingView::Iterator& other) const { if ((_hasLooped || other._hasLooped) && _current == other._current) { return true; } // If this is an end iterator then its value is implied to be kAllocatedButFreeRouting if (_isEnd) { return routings()[other._current.getVehicleRef()][other._current.getIndex()] == kAllocatedButFreeRouting; } if (other._isEnd) { return routings()[_current.getVehicleRef()][_current.getIndex()] == kAllocatedButFreeRouting; } return false; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/RoutingManager.h ```h #pragma once #include "Routing.h" #include <iterator> #include <optional> #include <string> #include <utility> #include <vector> namespace OpenLoco::Vehicles::RoutingManager { constexpr uint16_t kAllocatedButFreeRouting = 0xFFFEU; // Indicates that this array entry is allocated to a vehicle but no routing has been set. constexpr uint16_t kRoutingNull = 0xFFFFU; // Indicates that this array entry is unallocated to any vehicle. std::optional<RoutingHandle> getAndAllocateFreeRoutingHandle(); void freeRoutingHandle(const RoutingHandle handle); // Returns a routing. Each routing represents a track/road piece that a train is on or has reserved // See OpenLoco::World::Track::AdditionalTadFlags for bits of the routing uint16_t getRouting(const RoutingHandle handle); void setRouting(const RoutingHandle handle, uint16_t routing); void freeRouting(const RoutingHandle handle); // Equivalent of calling freeRouting on all routings for a single vehicle void resetRoutings(const RoutingHandle handle); bool isEmptyRoutingSlotAvailable(); void resetRoutingTable(); struct RingView { private: struct Iterator { enum class Direction : bool { forward, reverse, }; private: RoutingHandle _current; bool _hasLooped = false; bool _isEnd = false; Direction _direction = Direction::forward; public: Iterator(const RoutingHandle& begin, bool isEnd, Direction direction); Iterator& operator++(); Iterator operator++(int) { Iterator res = *this; ++(*this); return res; } Iterator& operator--(); Iterator operator--(int) { Iterator res = *this; --(*this); return res; } bool operator==(const Iterator& other) const; RoutingHandle& operator*() { return _current; } const RoutingHandle& operator*() const { return _current; } RoutingHandle& operator->() { return _current; } const RoutingHandle& operator->() const { return _current; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = RoutingHandle; using pointer = const RoutingHandle*; using reference = const RoutingHandle&; using iterator_category = std::bidirectional_iterator_tag; }; RoutingHandle _begin; public: // currentOrderOffset is relative to beginTableOffset and is where the ring will begin and end RingView(const RoutingHandle begin) : _begin(begin) { } RingView::Iterator begin() const { return Iterator(_begin, false, Iterator::Direction::forward); } RingView::Iterator end() const { return Iterator(_begin, true, Iterator::Direction::forward); } auto rbegin() const { return Iterator(_begin, false, Iterator::Direction::reverse); } auto rend() const { return Iterator(_begin, true, Iterator::Direction::reverse); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Vehicle.cpp ```cpp #include "Vehicle.h" #include "Effects/ExplosionEffect.h" #include "Effects/VehicleCrashEffect.h" #include "Entities/EntityManager.h" #include "GameState.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/Track/SubpositionData.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "MessageManager.h" #include "Objects/AirportObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "RoutingManager.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Vehicles { static loco_global<UpdateVar1136114Flags, 0x01136114> _vehicleUpdate_var_1136114; static loco_global<EntityId, 0x0113610E> _vehicleUpdate_collisionCarComponent; static constexpr int32_t kObjDistToHighPrecisionDistance = 2179; #pragma pack(push, 1) // There are some common elements in the vehicle components at various offsets these can be accessed via VehicleBase struct VehicleCommon : VehicleBase { ColourScheme colourScheme; // 0x24 EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles Flags38 var_38; // 0x38 uint8_t pad_39; EntityId nextCarId; // 0x3A uint8_t pad_3C[0x42 - 0x3C]; TransportMode mode; // 0x42 field same in all vehicles }; static_assert(sizeof(VehicleCommon) == 0x43); // Can't use offset_of change this to last field if more found #pragma pack(pop) ColourScheme VehicleBase::getColourScheme() { auto* veh = reinterpret_cast<VehicleCommon*>(this); return veh->colourScheme; } void VehicleBase::setColourScheme(ColourScheme colourScheme) { auto* veh = reinterpret_cast<VehicleCommon*>(this); veh->colourScheme = colourScheme; } VehicleBase* VehicleBase::nextVehicle() { return EntityManager::get<VehicleBase>(nextEntityId); } VehicleBase* VehicleBase::nextVehicleComponent() { auto* veh = reinterpret_cast<VehicleCommon*>(this); return EntityManager::get<VehicleBase>(veh->nextCarId); } VehicleBase* VehicleBase::previousVehicleComponent() { auto head = EntityManager::get<VehicleBase>(this->getHead()); while (head->nextVehicleComponent() != this) { head = head->nextVehicleComponent(); } return head; } TransportMode VehicleBase::getTransportMode() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->mode; } Flags38 VehicleBase::getFlags38() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->var_38; } uint8_t VehicleBase::getTrackType() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->trackType; } World::Pos3 VehicleBase::getTrackLoc() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return World::Pos3(veh->tileX, veh->tileY, veh->tileBaseZ * World::kSmallZStep); } TrackAndDirection VehicleBase::getTrackAndDirection() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->trackAndDirection; } RoutingHandle VehicleBase::getRoutingHandle() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->routingHandle; } EntityId VehicleBase::getHead() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->head; } int32_t VehicleBase::getRemainingDistance() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->remainingDistance; } void VehicleBase::setNextCar(const EntityId newNextCar) { auto* veh = reinterpret_cast<VehicleCommon*>(this); veh->nextCarId = newNextCar; } EntityId VehicleBase::getNextCar() const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return veh->nextCarId; } bool VehicleBase::has38Flags(Flags38 flagsToTest) const { const auto* veh = reinterpret_cast<const VehicleCommon*>(this); return (veh->var_38 & flagsToTest) != Flags38::none; } bool VehicleBase::hasVehicleFlags(VehicleFlags flagsToTest) const { const auto* ent = reinterpret_cast<const EntityBase*>(this); return (ent->vehicleFlags & flagsToTest) != VehicleFlags::none; } // 0x004AA407 void VehicleBase::explodeComponent() { auto subType = getSubType(); assert(subType == VehicleEntityType::bogie || subType == VehicleEntityType::body_start || subType == VehicleEntityType::body_continued); const auto pos = position + World::Pos3{ 0, 0, 22 }; Audio::playSound(Audio::SoundId::crash, pos); ExplosionCloud::create(pos); const auto numParticles = std::min(spriteWidth / 4, 7); for (auto i = 0; i < numParticles; ++i) { ColourScheme colourScheme = (subType == VehicleEntityType::bogie) ? reinterpret_cast<VehicleBogie*>(this)->colourScheme : reinterpret_cast<VehicleBody*>(this)->colourScheme; VehicleCrashParticle::create(pos, colourScheme); } } // 0x004AA464 void VehicleBase::destroyTrain() { Vehicle train(this->getHead()); if (train.head->status != Status::crashed && train.head->status != Status::stuck) { train.head->status = Status::crashed; train.head->crashedTimeout = 0; if (train.head->owner == getGameState().playerCompanies[0]) { MessageManager::post( MessageType::vehicleCrashed, train.head->owner, (uint16_t)train.head->id, 0xFFFF, 0xFFFF); } } train.cars.applyToComponents([](auto& carComponent) { carComponent.refundCost = 0; }); train.head->totalRefundCost = 0; Speed32 currentSpeed = train.veh2->currentSpeed; train.veh2->motorState = MotorState::stopped; train.cars.applyToComponents([&](auto& carComponent) { if (carComponent.isVehicleBogie()) { carComponent.asVehicleBogie()->var_5A = currentSpeed.getRaw(); } }); if (this->getSubType() == VehicleEntityType::vehicle_2) { auto* bogie = train.cars.firstCar.front; if (!train.cars.empty()) { bogie->var_5A |= (1U << 31); bogie->tileX = 0; bogie->tileY = 0; bogie->tileBaseZ = 0; } } else if (this->getSubType() == VehicleEntityType::bogie) { VehicleBogie* bogie = this->asVehicleBogie(); bogie->var_5A |= (1U << 31); bogie->tileX = 0; bogie->tileY = 0; bogie->tileBaseZ = 0; } else { VehicleBogie* explodeBogie = nullptr; for (auto& car : train.cars) { for (auto& carComponent : car) { explodeBogie = carComponent.back; if (carComponent.body == this) { break; } } } if (explodeBogie != nullptr) { explodeBogie->var_5A |= (1U << 31); explodeBogie->tileX = 0; explodeBogie->tileY = 0; explodeBogie->tileBaseZ = 0; } } } static bool updateRoadMotionNewRoadPiece(VehicleCommon& component) { auto newRoutingHandle = component.routingHandle; auto newIndex = newRoutingHandle.getIndex() + 1; newRoutingHandle.setIndex(newIndex); const auto routing = RoutingManager::getRouting(newRoutingHandle); if (routing != RoutingManager::kAllocatedButFreeRouting) { Vehicle train(component.head); if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m15)) { if (train.veh1->routingHandle == component.routingHandle) { setUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m03); return false; } } World::Pos3 pos(component.tileX, component.tileY, component.tileBaseZ * World::kSmallZStep); auto [nextPos, nextRot] = World::Track::getRoadConnectionEnd(pos, component.trackAndDirection.road.basicRad()); const auto tc = World::Track::getRoadConnections(nextPos, nextRot, component.owner, component.trackType, train.head->var_53, 0); bool routingFound = false; for (auto& connection : tc.connections) { if ((connection & World::Track::AdditionalTaDFlags::basicRaDMask) == (routing & World::Track::AdditionalTaDFlags::basicRaDMask)) { routingFound = true; break; } } if (!routingFound) { setUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound); return false; } component.routingHandle = newRoutingHandle; const auto oldTaD = component.trackAndDirection.road._data; component.trackAndDirection.road._data = routing & 0x1FF; if (component.isVehicle2()) { component.asVehicle2()->var_4F = tc.roadObjectId; } pos += World::TrackData::getUnkRoad(oldTaD & World::Track::AdditionalTaDFlags::basicRaDMask).pos; component.tileX = pos.x; component.tileY = pos.y; component.tileBaseZ = pos.z / World::kSmallZStep; return true; } return false; } static bool updateTrackMotionNewTrackPiece(VehicleCommon& component) { auto newRoutingHandle = component.routingHandle; auto newIndex = newRoutingHandle.getIndex() + 1; newRoutingHandle.setIndex(newIndex); const auto routing = RoutingManager::getRouting(newRoutingHandle); if (routing != RoutingManager::kAllocatedButFreeRouting) { Vehicle train(component.head); if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m15)) { if (train.veh1->routingHandle == component.routingHandle) { setUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m03); return false; } } World::Pos3 pos(component.tileX, component.tileY, component.tileBaseZ * World::kSmallZStep); auto [nextPos, nextRot] = World::Track::getTrackConnectionEnd(pos, component.trackAndDirection.track._data); const auto tc = World::Track::getTrackConnections(nextPos, nextRot, component.owner, component.trackType, train.head->var_53, 0); if (tc.hasLevelCrossing) { setUpdateVar1136114Flags(UpdateVar1136114Flags::approachingGradeCrossing); } bool routingFound = false; for (auto& connection : tc.connections) { if ((connection & World::Track::AdditionalTaDFlags::basicTaDMask) == (routing & World::Track::AdditionalTaDFlags::basicTaDMask)) { routingFound = true; break; } } if (!routingFound) { setUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound); return false; } component.routingHandle = newRoutingHandle; const auto oldTaD = component.trackAndDirection.track._data; component.trackAndDirection.track._data = routing & World::Track::AdditionalTaDFlags::basicTaDMask; pos += World::TrackData::getUnkTrack(oldTaD).pos; component.tileX = pos.x; component.tileY = pos.y; component.tileBaseZ = pos.z / World::kSmallZStep; return true; } return false; } // If candidate within 8 vehicle components of src we ignore a self collision // TODO: If we stored the car index this could be simplified static bool ignoreSelfCollision(VehicleBase& sourceVehicleId, const VehicleBase& candidateVehicleId) { auto* src = &sourceVehicleId; for (uint32_t i = 0; i < 8; ++i) { src = src->nextVehicleComponent(); if (src == nullptr) { return false; } if (src == &candidateVehicleId) { return true; } } return false; } // 0x004B1876 EntityId checkForCollisions(VehicleBogie& bogie, World::Pos3& loc) { if (bogie.mode != TransportMode::rail) { return EntityId::null; } Vehicle srcTrain(bogie.head); for (const auto& nearby : kMooreNeighbourhood) { const auto inspectionPos = World::toTileSpace(loc) + nearby; for (auto* entity : EntityManager::EntityTileList(World::toWorldSpace(inspectionPos))) { auto* vehicleBase = entity->asBase<VehicleBase>(); if (vehicleBase == nullptr || vehicleBase == &bogie) { continue; } if (vehicleBase->getTransportMode() != TransportMode::rail) { continue; } const auto zDiff = std::abs(loc.z - vehicleBase->position.z); if (zDiff > 16) { continue; } // vanilla did some overflow checks here but since we promote to int it shouldn't be needed const auto distance = Math::Vector::manhattanDistance2D(vehicleBase->position, loc); if (distance >= 12) { continue; } const auto subType = vehicleBase->getSubType(); // Does it actually have a collidable body if (subType != VehicleEntityType::body_continued && subType != VehicleEntityType::body_start && subType != VehicleEntityType::bogie) { continue; } if (vehicleBase->owner != bogie.owner) { continue; } // This is an optimisation compared to vanilla if (vehicleBase->getHead() != bogie.head) { return vehicleBase->id; } if (ignoreSelfCollision(bogie, *vehicleBase)) { continue; } if (ignoreSelfCollision(*vehicleBase, bogie)) { continue; } return vehicleBase->id; } } return EntityId::null; } // 0x0047C7FA static int32_t updateRoadMotion(VehicleCommon& component, int32_t distance) { component.remainingDistance += distance; bool hasMoved = false; auto returnValue = 0; auto intermediatePosition = component.position; while (component.remainingDistance >= 0x368A) { hasMoved = true; auto newSubPosition = component.subPosition + 1U; const auto subPositionDataSize = World::TrackData::getRoadSubPositon(component.trackAndDirection.road._data).size(); // This means we have moved forward by a road piece if (newSubPosition >= subPositionDataSize) { if (!updateRoadMotionNewRoadPiece(component)) { returnValue = component.remainingDistance - 0x3689; component.remainingDistance = 0x3689; setUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00); break; } else { newSubPosition = 0; } } // 0x0047C95B component.subPosition = newSubPosition; const auto& moveData = World::TrackData::getRoadSubPositon(component.trackAndDirection.road._data)[newSubPosition]; const auto nextNewPosition = moveData.loc + World::Pos3(component.tileX, component.tileY, component.tileBaseZ * World::kSmallZStep); component.remainingDistance -= kMovementNibbleToDistance[getMovementNibble(intermediatePosition, nextNewPosition)]; intermediatePosition = nextNewPosition; component.spriteYaw = moveData.yaw; component.spritePitch = moveData.pitch; if (component.isVehicleBogie()) { // collision checks auto collideResult = checkForCollisions(*component.asVehicleBogie(), intermediatePosition); if (collideResult != EntityId::null) { setUpdateVar1136114Flags(UpdateVar1136114Flags::crashed); _vehicleUpdate_collisionCarComponent = collideResult; } } } if (hasMoved) { Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); component.moveTo(intermediatePosition); Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); } return returnValue; } static int32_t updateTrackMotion(VehicleCommon& component, int32_t distance) { if (component.mode == TransportMode::road) { return updateRoadMotion(component, distance); } else if (component.mode == TransportMode::rail) { component.remainingDistance += distance; bool hasMoved = false; auto returnValue = 0; auto intermediatePosition = component.position; while (component.remainingDistance >= 0x368A) { hasMoved = true; auto newSubPosition = component.subPosition + 1U; const auto subPositionDataSize = World::TrackData::getTrackSubPositon(component.trackAndDirection.track._data).size(); // This means we have moved forward by a track piece if (newSubPosition >= subPositionDataSize) { if (!updateTrackMotionNewTrackPiece(component)) { returnValue = component.remainingDistance - 0x3689; component.remainingDistance = 0x3689; setUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00); break; } else { newSubPosition = 0; } } // 0x004B1761 component.subPosition = newSubPosition; const auto& moveData = World::TrackData::getTrackSubPositon(component.trackAndDirection.track._data)[newSubPosition]; const auto nextNewPosition = moveData.loc + World::Pos3(component.tileX, component.tileY, component.tileBaseZ * World::kSmallZStep); component.remainingDistance -= kMovementNibbleToDistance[getMovementNibble(intermediatePosition, nextNewPosition)]; intermediatePosition = nextNewPosition; component.spriteYaw = moveData.yaw; component.spritePitch = moveData.pitch; if (component.isVehicleBogie()) { // collision checks auto collideResult = checkForCollisions(*component.asVehicleBogie(), intermediatePosition); if (collideResult != EntityId::null) { setUpdateVar1136114Flags(UpdateVar1136114Flags::crashed); _vehicleUpdate_collisionCarComponent = collideResult; } } } if (hasMoved) { Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); component.moveTo(intermediatePosition); Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); } return returnValue; } else { assert(false); return 0; } } // 0x004B15FF int32_t VehicleBase::updateTrackMotion(int32_t unk1) { return Vehicles::updateTrackMotion(*reinterpret_cast<VehicleCommon*>(this), unk1); } // 0x0047D959 // ax : loc.x // cx : loc.y // dl : loc.z / 4 // bp : trackAndDirection // ebp : bp | (setOccupied << 31) // returns dh : trackType uint8_t VehicleBase::sub_47D959(const World::Pos3& loc, const TrackAndDirection::_RoadAndDirection trackAndDirection, const bool setOccupied) { auto trackType = getTrackType(); auto tile = World::TileManager::get(loc); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } const auto heightDiff = std::abs(loc.z / 4 - elRoad->baseZ()); if (heightDiff > 4) { continue; } if (elRoad->rotation() != trackAndDirection.cardinalDirection()) { continue; } if (elRoad->roadId() != trackAndDirection.id()) { continue; } if (elRoad->isAiAllocated()) { continue; } const auto newUnk4u = World::TrackData::getRoadOccupationMask(trackAndDirection._data >> 2) >> 4; if (setOccupied) { elRoad->setUnk4u(elRoad->unk4u() | newUnk4u); } else { elRoad->setUnk4u(elRoad->unk4u() & (~newUnk4u)); } if (getTrackType() == 0xFF) { if (getGameState().roadObjectIdIsNotTram & (1 << elRoad->roadObjectId())) { elRoad->setUnk7_40(true); trackType = elRoad->roadObjectId(); } } else { trackType = getTrackType(); } } return trackType; } bool VehicleBase::updateComponent() { switch (getSubType()) { case VehicleEntityType::head: return !asVehicleHead()->update(); case VehicleEntityType::vehicle_1: return !asVehicle1()->update(); case VehicleEntityType::vehicle_2: return !asVehicle2()->update(); case VehicleEntityType::bogie: return !asVehicleBogie()->update(); case VehicleEntityType::body_start: case VehicleEntityType::body_continued: return !asVehicleBody()->update(); case VehicleEntityType::tail: return !asVehicleTail()->update(); default: break; } return false; } CarComponent::CarComponent(VehicleBase*& component) { front = component->asVehicleBogie(); if (front == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } back = component->asVehicleBogie(); if (back == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } body = component->asVehicleBody(); if (body == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } } Vehicle::Vehicle(EntityId _head) { auto component = EntityManager::get<VehicleBase>(_head); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } head = component->asVehicleHead(); if (head == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } veh1 = component->asVehicle1(); if (veh1 == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } veh2 = component->asVehicle2(); if (veh2 == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } if (component->getSubType() != VehicleEntityType::tail) { cars = Cars{ Car{ component } }; } while (component->getSubType() != VehicleEntityType::tail) { component = component->nextVehicleComponent(); if (component == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } } tail = component->asVehicleTail(); } // 0x00426790 AirportObjectFlags VehicleBogie::getCompatibleAirportType() { auto* vehObj = ObjectManager::get<VehicleObject>(objectId); if (vehObj->hasFlags(VehicleObjectFlags::aircraftIsHelicopter)) { return AirportObjectFlags::acceptsHelicopter; } if (vehObj->weight < 50) { return AirportObjectFlags::acceptsHeavyPlanes | AirportObjectFlags::acceptsLightPlanes; } return AirportObjectFlags::acceptsHeavyPlanes; } // 0x004AF16A void removeAllCargo(CarComponent& carComponent) { carComponent.front->secondaryCargo.qty = 0; carComponent.back->secondaryCargo.qty = 0; carComponent.body->primaryCargo.qty = 0; auto* head = EntityManager::get<VehicleHead>(carComponent.front->head); if (head == nullptr) { throw Exception::RuntimeError("Invalid Vehicle head"); } head->updateTrainProperties(); Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(head->id)); // Vanilla called updateCargoSprite on the bogies but that does nothing so skipping that. carComponent.body->updateCargoSprite(); } // 0x004AFFF3 // esi: frontBogie // returns new front bogie as esi VehicleBogie* flipCar(VehicleBogie& frontBogie) { Vehicle train(frontBogie.head); auto precedingVehicleComponent = frontBogie.previousVehicleComponent(); CarComponent oldFirstComponent; sfl::static_vector<CarComponent, VehicleObject::kMaxCarComponents> components; for (auto& car : train.cars) { if (car.front->id != frontBogie.id) { continue; } oldFirstComponent = car; for (CarComponent& component : car) { std::swap(component.front->objectSpriteType, component.back->objectSpriteType); component.body->var_38 ^= Flags38::isReversed; components.push_back(component); } break; } // if the Car is only one CarComponent we don't have to swap any values if (components.size() == 1) { return &frontBogie; } CarComponent& newFirstComponent = components.back(); newFirstComponent.body->setSubType(VehicleEntityType::body_start); precedingVehicleComponent->setNextCar(newFirstComponent.front->id); // set the new last component to point to the next car if (oldFirstComponent.body == nullptr) { throw Exception::RuntimeError("oldFirstComponent.body was nullptr"); } oldFirstComponent.body->setNextCar(newFirstComponent.body->nextCarId); for (int i = components.size() - 2; i >= 0; i--) { components[i].body->setSubType(VehicleEntityType::body_continued); if (components[i + 1].body != nullptr) { components[i + 1].body->setNextCar(components[i].front->id); } } newFirstComponent.body->primaryCargo = oldFirstComponent.body->primaryCargo; newFirstComponent.body->breakdownFlags = oldFirstComponent.body->breakdownFlags; newFirstComponent.body->breakdownTimeout = oldFirstComponent.body->breakdownTimeout; newFirstComponent.front->secondaryCargo = oldFirstComponent.front->secondaryCargo; newFirstComponent.front->breakdownFlags = oldFirstComponent.front->breakdownFlags; newFirstComponent.front->breakdownTimeout = oldFirstComponent.front->breakdownTimeout; newFirstComponent.front->totalCarWeight = oldFirstComponent.front->totalCarWeight; newFirstComponent.front->reliability = oldFirstComponent.front->reliability; newFirstComponent.front->timeoutToBreakdown = oldFirstComponent.front->timeoutToBreakdown; // vanilla does not reset every value oldFirstComponent.body->primaryCargo.acceptedTypes = 0; oldFirstComponent.body->primaryCargo.type = 0xFF; oldFirstComponent.body->primaryCargo.maxQty = 0; oldFirstComponent.body->primaryCargo.qty = 0; oldFirstComponent.body->primaryCargo.numDays = 0; oldFirstComponent.front->secondaryCargo.acceptedTypes = 0; oldFirstComponent.front->secondaryCargo.type = 0xFF; oldFirstComponent.front->secondaryCargo.maxQty = 0; oldFirstComponent.front->secondaryCargo.qty = 0; oldFirstComponent.front->secondaryCargo.numDays = 0; oldFirstComponent.body->breakdownFlags = BreakdownFlags::none; oldFirstComponent.body->breakdownTimeout = 0; oldFirstComponent.front->breakdownFlags = BreakdownFlags::none; oldFirstComponent.front->breakdownTimeout = 0; return newFirstComponent.front; } // 0x004AF4D6 // source: esi // dest: edi // returns nothing void insertCarBefore(VehicleBogie& source, VehicleBase& dest) { if (source.id == dest.id) { return; } Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(source.head)); Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(dest.getHead())); Ui::WindowManager::invalidate(Ui::WindowType::vehicleList); Vehicle sourceTrain(source.head); auto precedingSourceComponent = source.previousVehicleComponent(); for (auto& car : sourceTrain.cars) { if (car.front->id != source.id) { continue; } auto* lastBody = car.body; for (auto& component : car) { component.front->head = dest.getHead(); component.back->head = dest.getHead(); component.body->head = dest.getHead(); lastBody = component.body; } precedingSourceComponent->setNextCar(lastBody->nextCarId); lastBody->nextCarId = dest.id; break; } auto precedingDestComponent = dest.previousVehicleComponent(); precedingDestComponent->setNextCar(source.id); } // 0x004AF5E1 // esi: head // returns nothing void connectJacobsBogies(VehicleHead& head) { /* Jacobs Bogie connections are completely invisible until a jacob's bogie connection is made. The visible body of the car is another CarComponent that is either the first CarComponent (if a connection is available only at the back of the Car), the middle CarComponent (if there are two connections available), or the last CarComponent (if a connection is available only at the front of the Car). The comments in the code assume that two connections are available, and refer to each CarComponent as the First, Last, and Body CarComponent. The bodies of these invisible CarComponents are used to store the flag that the jacob's bogie connection is available. If the first CarComponent of a Car sees that the previous CarComponent has the flag, and it has the flag as well, a connection will be made. If the last CarComponent of a Car is flagged for a connection, it will reset to default without checking if the next component should connect, and the connection will be re-made by the next Car, if necessary. This is eaiser than verifying that the connection is made correctly. */ Vehicle train(head); auto componentsFound = 0; CarComponent previousCarComponent; CarComponent secondPreviousCarComponent; for (auto& car : train.cars) { if (car.body->has38Flags(Flags38::jacobsBogieAvailable)) { auto frontBogieOfNext = car.body->nextVehicleComponent(); if (frontBogieOfNext == nullptr) { throw Exception::RuntimeError("connectJacobsBogies frontBogieOfNext was unexpectedly nullptr"); } // Body's component CarComponent nextComponent = CarComponent(frontBogieOfNext); // Create First's jacob's bogie connection // Change from vanilla: this case occurred after the code in the else-block and the else-block was not conditional. if (componentsFound >= 1 && previousCarComponent.body->has38Flags(Flags38::jacobsBogieAvailable)) { if (componentsFound < 2) { throw Exception::RuntimeError("connectJacobsBogies tried to connect jacob's bogie without secondPreviousCarComponent"); } auto frontObject = ObjectManager::get<VehicleObject>(car.front->objectId); car.front->objectSpriteType = frontObject->carComponents[car.front->bodyIndex].frontBogieSpriteInd; // set my body's front bogie to invisible nextComponent.front->objectSpriteType = 0xFF; // set previous car's body's rear bogie to invisible secondPreviousCarComponent.back->objectSpriteType = 0xFF; } // Reset First's jacob's bogie connection else { car.front->objectSpriteType = 0xFF; car.back->objectSpriteType = 0xFF; car.body->objectSpriteType = 0xFF; auto bodyObject = ObjectManager::get<VehicleObject>(nextComponent.body->objectId); nextComponent.front->objectSpriteType = bodyObject->carComponents[nextComponent.body->bodyIndex].frontBogieSpriteInd; if (nextComponent.body->has38Flags(Flags38::isReversed)) { // Change from vanilla: set bogie orientation based on body's object nextComponent.front->objectSpriteType = bodyObject->carComponents[nextComponent.body->bodyIndex].backBogieSpriteInd; } } } for (auto& component : car) { // Reset Last jacob's bogie connection // Jacobs bogie flag is only set on the first and last CarComponent of the car, it cannot be set on middle one(s) if (component.body->has38Flags(Flags38::jacobsBogieAvailable) && component.body->getSubType() == VehicleEntityType::body_continued) { if (componentsFound == 0) { throw Exception::RuntimeError("connectJacobsBogies reached end of Car without previousCarComponent"); } component.front->objectSpriteType = 0xFF; component.back->objectSpriteType = 0xFF; component.body->objectSpriteType = 0xFF; // Change from vanilla: gets bogie's object instead of body's object auto carLastBogieObject = ObjectManager::get<VehicleObject>(previousCarComponent.back->objectId); previousCarComponent.back->objectSpriteType = carLastBogieObject->carComponents[previousCarComponent.back->bodyIndex].backBogieSpriteInd; if (previousCarComponent.body->has38Flags(Flags38::isReversed)) { // Change from vanilla: sets bogie orientation based on body's object previousCarComponent.back->objectSpriteType = carLastBogieObject->carComponents[previousCarComponent.back->bodyIndex].frontBogieSpriteInd; } } secondPreviousCarComponent = previousCarComponent; previousCarComponent = component; componentsFound++; } } } // 0x004B1C48 // Applies the vehicle object lengths to the bogies of the train // with some specified starting distance. Bodies are not set as // they are calculated later based on the positions of the bogies. // returns the final distance static int32_t applyVehicleObjectLengthToBogies(Vehicle& train, const int32_t startDistance) { auto distance = startDistance; for (auto& car : train.cars) { const auto* vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); assert(std::distance(car.begin(), car.end()) == vehicleObj->numCarComponents); if (car.body->has38Flags(Flags38::isReversed)) { auto objCarIndex = vehicleObj->numCarComponents - 1; for (auto& component : car) { auto& objCar = vehicleObj->carComponents[objCarIndex]; const auto frontLength = objCar.backBogiePosition * -kObjDistToHighPrecisionDistance; component.front->remainingDistance = distance + frontLength; if (objCar.bodySpriteInd != 0xFFU) { const auto bodyLength = vehicleObj->bodySprites[objCar.bodySpriteInd & 0x7F].halfLength * -(kObjDistToHighPrecisionDistance * 2); distance += bodyLength; } const auto backLength = objCar.frontBogiePosition * kObjDistToHighPrecisionDistance; component.back->remainingDistance = distance + backLength; objCarIndex--; } } else { auto objCarIndex = 0; for (auto& component : car) { auto& objCar = vehicleObj->carComponents[objCarIndex]; const auto frontLength = objCar.frontBogiePosition * -kObjDistToHighPrecisionDistance; component.front->remainingDistance = distance + frontLength; if (objCar.bodySpriteInd != 0xFFU) { const auto bodyLength = vehicleObj->bodySprites[objCar.bodySpriteInd & 0x7F].halfLength * -(kObjDistToHighPrecisionDistance * 2); distance += bodyLength; } const auto backLength = objCar.backBogiePosition * kObjDistToHighPrecisionDistance; component.back->remainingDistance = distance + backLength; objCarIndex++; } } } return distance; } // 0x004AE2AB // head: esi void applyVehicleObjectLength(Vehicle& train) { // We want the tail to have a remaining distance of 0 // so we first apply the lengths from 0 then take the return // length and set that as the negative start offset and reapply const auto negStartDistance = -applyVehicleObjectLengthToBogies(train, 0); train.head->remainingDistance = negStartDistance; train.veh1->remainingDistance = negStartDistance; train.veh2->remainingDistance = negStartDistance; applyVehicleObjectLengthToBogies(train, negStartDistance); train.tail->remainingDistance = 0; } bool hasUpdateVar1136114Flags(UpdateVar1136114Flags flags) { return (*_vehicleUpdate_var_1136114 & flags) != UpdateVar1136114Flags::none; } void resetUpdateVar1136114Flags() { _vehicleUpdate_var_1136114 = UpdateVar1136114Flags::none; } void setUpdateVar1136114Flags(UpdateVar1136114Flags flags) { _vehicleUpdate_var_1136114 |= flags; } void unsetUpdateVar1136114Flags(UpdateVar1136114Flags flags) { _vehicleUpdate_var_1136114 &= ~flags; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Vehicle.h ```h #pragma once #include "Audio/Audio.h" #include "Entities/Entity.h" #include "Map/Track/TrackModSection.h" #include "Objects/AirportObject.h" #include "Objects/ObjectManager.h" #include "Objects/VehicleObject.h" #include "Routing.h" #include "Speed.hpp" #include "Types.hpp" #include "Ui/Window.h" #include "Ui/WindowType.h" #include "World/Company.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Exception.hpp> namespace OpenLoco { enum class AirportObjectFlags : uint16_t; } namespace OpenLoco::Vehicles { using CargoTotalArray = std::array<uint32_t, ObjectManager::getMaxObjects(ObjectType::cargo)>; constexpr auto kMaxRoadVehicleLength = 176; // TODO: Units? constexpr uint8_t kWheelSlippingDuration = 64; // In ticks enum class MotorState : uint8_t { stopped = 0, accelerating = 1, coasting = 2, braking = 3, stoppedOnIncline = 4, airplaneAtTaxiSpeed = 5, }; enum class Flags38 : uint8_t { none = 0U, unk_0 = 1U << 0, isReversed = 1U << 1, unk_2 = 1U << 2, jacobsBogieAvailable = 1U << 3, isGhost = 1U << 4, fasterAroundCurves = 1U << 5, }; OPENLOCO_ENABLE_ENUM_OPERATORS(Flags38); enum class Flags48 : uint8_t // veh1 Signal flags? { none = 0U, passSignal = 1U << 0, expressMode = 1U << 1, flag2 = 1U << 2 // cargo related? }; OPENLOCO_ENABLE_ENUM_OPERATORS(Flags48); enum class Flags73 : uint8_t // veh2 Train breakdown flags { none = 0U, isBrokenDown = 1U << 0, isStillPowered = 1U << 1 }; OPENLOCO_ENABLE_ENUM_OPERATORS(Flags73); enum class WaterMotionFlags : uint32_t { none = 0U, isStopping = 1U << 0, isLeavingDock = 1U << 1, hasReachedDock = 1U << 16, hasReachedADestination = 1U << 17, }; OPENLOCO_ENABLE_ENUM_OPERATORS(WaterMotionFlags); enum class SoundFlags : uint16_t { none = 0U, flag0 = 1U << 0, flag1 = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(SoundFlags); enum class UpdateVar1136114Flags : uint32_t { none = 0U, unk_m00 = (1U << 0), noRouteFound = (1U << 1), crashed = (1U << 2), unk_m03 = (1U << 3), approachingGradeCrossing = (1U << 4), unk_m15 = (1U << 15), }; OPENLOCO_ENABLE_ENUM_OPERATORS(UpdateVar1136114Flags); bool hasUpdateVar1136114Flags(UpdateVar1136114Flags flags); void resetUpdateVar1136114Flags(); void setUpdateVar1136114Flags(UpdateVar1136114Flags flags); void unsetUpdateVar1136114Flags(UpdateVar1136114Flags flags); enum class Status : uint8_t { unk_0 = 0, // no position (not placed) stopped = 1, travelling = 2, waitingAtSignal = 3, approaching = 4, unloading = 5, loading = 6, brokenDown = 7, crashed = 8, stuck = 9, landing = 10, taxiing1 = 11, taxiing2 = 12, takingOff = 13, }; struct OrderRingView; struct VehicleHead; struct Vehicle1; struct Vehicle2; struct VehicleBogie; struct VehicleBody; struct VehicleTail; struct VehicleSoundPlayer; enum class BreakdownFlags : uint8_t { none = 0U, unk_0 = 1U << 0, breakdownPending = 1U << 1, brokenDown = 1U << 2, journeyStarted = 1U << 3, // The journey start meta data has been filled in }; OPENLOCO_ENABLE_ENUM_OPERATORS(BreakdownFlags); enum class VehicleEntityType : uint8_t { head = 0, vehicle_1, vehicle_2, bogie, body_start, body_continued, tail, }; struct VehicleStatus { StringId status1; uint32_t status1Args; StringId status2; uint32_t status2Args; }; constexpr uint8_t kAirportMovementNodeNull = 0xFF; constexpr uint8_t kAirportMovementNoValidEdge = 0xFE; #pragma pack(push, 1) struct TrackAndDirection { struct _TrackAndDirection { uint16_t _data; constexpr _TrackAndDirection(uint8_t id, uint8_t direction) : _data((id << 3) | direction) { } constexpr uint8_t id() const { return (_data >> 3) & 0x3F; } constexpr uint8_t cardinalDirection() const { return _data & 0x3; } constexpr bool isReversed() const { return _data & (1 << 2); } constexpr void setReversed(bool state) { _data &= ~(1 << 2); _data |= state ? (1 << 2) : 0; } constexpr bool operator==(const _TrackAndDirection other) const { return _data == other._data; } }; struct _RoadAndDirection { uint16_t _data; constexpr _RoadAndDirection(uint8_t id, uint8_t direction) : _data((id << 3) | direction) { } constexpr uint8_t id() const { return (_data >> 3) & 0xF; } constexpr uint8_t cardinalDirection() const { return _data & 0x3; } // Used by road and tram vehicles to indicate side constexpr bool isReversed() const { return _data & (1 << 2); } constexpr void setReversed(bool state) { _data &= ~(1 << 2); _data |= state ? (1 << 2) : 0; } constexpr uint8_t basicRad() const { return _data & 0x7F; } // Vehicles can be in overtaking lane (trams can stay in that lane) constexpr bool isOvertaking() const { return _data & (1 << 7); } // Related to road vehicles turning around constexpr bool isChangingLane() const { return _data & (1 << 8); } constexpr bool operator==(const _RoadAndDirection other) const { return _data == other._data; } }; union { _TrackAndDirection track; _RoadAndDirection road; }; constexpr TrackAndDirection(uint8_t id, uint8_t direction) : track(id, direction) { } }; static_assert(sizeof(TrackAndDirection) == 2); // TODO move to a different header enum class SignalStateFlags : uint8_t { none = 0U, occupied = 1U << 0, // Signal occupied with a vehicle (can be one or two way) blockedNoRoute = 1U << 1, // There is no route through the signal at any time (e.g. one way signal and we are going the wrong way) occupiedOneWay = 1U << 2, // Signal occupied with a vehicle and signal is one way }; OPENLOCO_ENABLE_ENUM_OPERATORS(SignalStateFlags); constexpr uint8_t getMovementNibble(const World::Pos3& pos1, const World::Pos3& pos2) { uint8_t nibble = 0; if (pos1.x != pos2.x) { nibble |= (1U << 0); } if (pos1.y != pos2.y) { nibble |= (1U << 1); } if (pos1.z != pos2.z) { nibble |= (1U << 2); } return nibble; } // 0x00500120 constexpr std::array<uint32_t, 8> kMovementNibbleToDistance = { 0, 0x220C, 0x220C, 0x3027, 0x199A, 0x2A99, 0x2A99, 0x3689, }; // 0x00500244 constexpr std::array<World::TilePos2, 9> kMooreNeighbourhood = { World::TilePos2{ 0, 0 }, World::TilePos2{ 0, 1 }, World::TilePos2{ 1, 1 }, World::TilePos2{ 1, 0 }, World::TilePos2{ 1, -1 }, World::TilePos2{ 0, -1 }, World::TilePos2{ -1, -1 }, World::TilePos2{ -1, 0 }, World::TilePos2{ -1, 1 }, }; void setSignalState(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint8_t trackType, uint32_t flags); SignalStateFlags getSignalState(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint8_t trackType, uint32_t flags); void sub_4A2AD7(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType); void setReverseSignalOccupiedInBlock(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType); bool isBlockOccupied(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType); uint8_t sub_4A2A58(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType); uint8_t sub_4A2A77(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const CompanyId company, const uint8_t trackType); struct ApplyTrackModsResult { currency32_t cost; bool networkTooComplex; bool allPlacementsFailed; }; ApplyTrackModsResult applyTrackModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_TrackAndDirection trackAndDirection, CompanyId company, uint8_t trackType, uint8_t flags, World::Track::ModSection modSelection, uint8_t trackModObjIds); currency32_t removeTrackModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_TrackAndDirection trackAndDirection, CompanyId company, uint8_t trackType, uint8_t flags, World::Track::ModSection modSelection, uint8_t trackModObjIds); ApplyTrackModsResult applyRoadModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_RoadAndDirection roadAndDirection, CompanyId company, uint8_t roadType, uint8_t flags, World::Track::ModSection modSelection, uint8_t roadModObjIds); currency32_t removeRoadModsToTrackNetwork(const World::Pos3& pos, Vehicles::TrackAndDirection::_RoadAndDirection roadAndDirection, CompanyId company, uint8_t roadType, uint8_t flags, World::Track::ModSection modSelection, uint8_t roadModObjIds); void leaveLevelCrossing(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint16_t unk); enum class RoadOccupationFlags : uint8_t { none = 0U, isLaneOccupied = 1U << 0, isLevelCrossingClosed = 1U << 1, hasLevelCrossing = 1U << 2, hasStation = 1U << 3, isOneWay = 1U << 4, }; OPENLOCO_ENABLE_ENUM_OPERATORS(RoadOccupationFlags); RoadOccupationFlags getRoadOccupation(const World::Pos3 pos, const TrackAndDirection::_RoadAndDirection tad); EntityId checkForCollisions(VehicleBogie& bogie, World::Pos3& loc); void playPickupSound(Vehicles::Vehicle2* veh2); void playPlacedownSound(const World::Pos3 pos); struct VehicleBase : EntityBase { static constexpr auto kBaseType = EntityBaseType::vehicle; private: template<VehicleEntityType SubType> bool is() const { return getSubType() == SubType; } template<typename TType, VehicleEntityType TClass> TType* as() const { // This can not use reinterpret_cast due to being a const member without considerable more code if (!is<TClass>()) { throw Exception::RuntimeError("Malformed vehicle. Incorrect subType!"); } return (TType*)this; } template<typename TType> TType* as() const { return as<TType, TType::kVehicleThingType>(); } public: VehicleEntityType getSubType() const { return VehicleEntityType(EntityBase::getSubType()); } void setSubType(const VehicleEntityType newType) { EntityBase::setSubType(static_cast<uint8_t>(newType)); } bool isVehicleHead() const { return is<VehicleEntityType::head>(); } VehicleHead* asVehicleHead() const { return as<VehicleHead>(); } bool isVehicle1() const { return is<VehicleEntityType::vehicle_1>(); } Vehicle1* asVehicle1() const { return as<Vehicle1>(); } bool isVehicle2() const { return is<VehicleEntityType::vehicle_2>(); } Vehicle2* asVehicle2() const { return as<Vehicle2>(); } bool isVehicleBogie() const { return is<VehicleEntityType::bogie>(); } VehicleBogie* asVehicleBogie() const { return as<VehicleBogie>(); } bool isVehicleBody() const { return is<VehicleEntityType::body_start>() || is<VehicleEntityType::body_continued>(); } VehicleBody* asVehicleBody() const { if (is<VehicleEntityType::body_start>()) { return as<VehicleBody, VehicleEntityType::body_start>(); } return as<VehicleBody, VehicleEntityType::body_continued>(); } bool hasSoundPlayer() { return is<VehicleEntityType::vehicle_2>() || is<VehicleEntityType::tail>(); } VehicleSoundPlayer* getSoundPlayer() const { if (is<VehicleEntityType::vehicle_2>()) { return as<VehicleSoundPlayer, VehicleEntityType::vehicle_2>(); } return as<VehicleSoundPlayer, VehicleEntityType::tail>(); } bool isVehicleTail() const { return is<VehicleEntityType::tail>(); } VehicleTail* asVehicleTail() const { return as<VehicleTail>(); } TransportMode getTransportMode() const; Flags38 getFlags38() const; uint8_t getTrackType() const; World::Pos3 getTrackLoc() const; TrackAndDirection getTrackAndDirection() const; RoutingHandle getRoutingHandle() const; EntityId getHead() const; int32_t getRemainingDistance() const; void setNextCar(const EntityId newNextCar); EntityId getNextCar() const; bool has38Flags(Flags38 flagsToTest) const; bool hasVehicleFlags(VehicleFlags flagsToTest) const; VehicleBase* nextVehicle(); VehicleBase* nextVehicleComponent(); VehicleBase* previousVehicleComponent(); ColourScheme getColourScheme(); void setColourScheme(ColourScheme colourScheme); bool updateComponent(); void explodeComponent(); void destroyTrain(); uint8_t sub_47D959(const World::Pos3& loc, const TrackAndDirection::_RoadAndDirection trackAndDirection, const bool setOccupied); int32_t updateTrackMotion(int32_t unk1); }; struct VehicleSoundPlayer : VehicleBase { uint8_t pad_24[0x44 - 0x24]; SoundObjectId_t drivingSoundId; // 0x44 uint8_t drivingSoundVolume; // 0x45 channel attribute volume related uint16_t drivingSoundFrequency; // 0x46 channel attribute frequency uint16_t objectId; // 0x48 vehicle object (used for sound) SoundFlags soundFlags; // 0x4A Ui::WindowNumber_t soundWindowNumber; // 0x4C Ui::WindowType soundWindowType; // 0x4E uint8_t pad_4F[0x56 - 0x4F]; uint32_t var_56; uint8_t pad_5A[0x73 - 0x5A]; uint8_t var_73; }; static_assert(sizeof(VehicleSoundPlayer) == 0x74); // Can't use offset_of change this to last field if more found struct VehicleCargo { uint32_t acceptedTypes; // 0x48 uint8_t type; // 0x4C uint8_t maxQty; // 0x4D StationId townFrom; // 0x4E uint8_t numDays; // 0x50 uint8_t qty; // 0x51 }; static_assert(sizeof(VehicleCargo) == 0xA); struct Sub4ACEE7Result { uint8_t status; uint8_t flags; StationId stationId; }; struct VehicleHead : VehicleBase { static constexpr auto kVehicleThingType = VehicleEntityType::head; uint8_t pad_24[0x26 - 0x24]; EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles orderId * maxNumRoutingSteps Flags38 var_38; uint8_t pad_39; // 0x39 EntityId nextCarId; // 0x3A int32_t var_3C; // 0x3C uint8_t pad_40[0x2]; // 0x40 TransportMode mode; // 0x42 field same in all vehicles uint8_t pad_43; int16_t ordinalNumber; // 0x44 uint32_t orderTableOffset; // 0x46 offset into Order Table uint16_t currentOrder; // 0x4A offset, combine with orderTableOffset uint16_t sizeOfOrderTable; // 0x4C size of Order Table uint32_t trainAcceptedCargoTypes; // 0x4E uint8_t var_52; uint8_t var_53; // 0x53 mods? StationId stationId; // 0x54 uint16_t cargoTransferTimeout; // 0x56 uint32_t var_58; uint8_t var_5C; Status status; // 0x5D VehicleType vehicleType; // 0x5E BreakdownFlags breakdownFlags; // 0x5F uint8_t aiThoughtId; // 0x60 0xFFU for null World::Pos2 aiPlacementPos; // 0x61 uint16_t aiPlacementTaD; // 0x65 for air/water this is just rotation uint8_t aiPlacementBaseZ; // 0x67 uint8_t airportMovementEdge; // 0x68 uint32_t totalRefundCost; // 0x69 uint8_t crashedTimeout; // 0x6D int8_t manualPower; // 0x6E manual power control VehicleFlags::manualControl World::Pos2 journeyStartPos; // 0x6F journey start position uint32_t journeyStartTicks; // 0x73 ticks since journey start Speed16 lastAverageSpeed; // 0x77 uint8_t restartStoppedCarsTimeout; // 0x79 timeout before auto starting trams/buses public: bool isVehicleTypeCompatible(const uint16_t vehicleTypeId); void updateBreakdown(); void updateVehicle(); bool update(); void updateMonthly(); void updateDaily(); VehicleStatus getStatus() const; OrderRingView getCurrentOrders() const; bool isPlaced() const { return tileX != -1 && !has38Flags(Flags38::isGhost); } bool hasAnyCargo(); char* generateCargoTotalString(char* buffer); char* generateCargoCapacityString(char* buffer); char* cargoLUTToString(CargoTotalArray& cargoTotals, char* buffer); bool canBeModified() const; void liftUpVehicle(); void updateTrainProperties(); currency32_t calculateRunningCost() const; void sub_4AD778(); void sub_4AD93A(); void sub_4ADB47(bool unk); uint32_t getCarCount() const; void applyBreakdownToTrain(); void landCrashedUpdate(); void updateSegmentCrashed(); void autoLayoutTrain(); uint32_t getVehicleTotalLength() const; constexpr bool hasBreakdownFlags(BreakdownFlags flagsToTest) const { return (breakdownFlags & flagsToTest) != BreakdownFlags::none; } void movePlaneTo(const World::Pos3& newLoc, const uint8_t newYaw, const Pitch newPitch); void moveBoatTo(const World::Pos3& loc, const uint8_t yaw, const Pitch pitch); Sub4ACEE7Result sub_4ACEE7(uint32_t unk1, uint32_t var_113612C); private: void updateDrivingSounds(); void updateDrivingSound(VehicleSoundPlayer* soundPlayer); void updateDrivingSoundNone(VehicleSoundPlayer* soundPlayer); void updateDrivingSoundFriction(VehicleSoundPlayer* soundPlayer, const VehicleObjectFrictionSound* snd); void updateSimpleMotorSound(VehicleSoundPlayer* soundPlayer, const VehicleSimpleMotorSound* snd); void updateGearboxMotorSound(VehicleSoundPlayer* soundPlayer, const VehicleGearboxMotorSound* snd); bool updateLand(); bool sub_4A8DB7(); bool tryReverse(); bool sub_4A8CB6(); bool sub_4A8C81(); bool landTryBeginUnloading(); bool landLoadingUpdate(); bool landNormalMovementUpdate(); bool trainNormalMovementUpdate(uint8_t al, uint8_t flags, StationId nextStation); bool roadNormalMovementUpdate(uint8_t al, StationId nextStation); bool landReverseFromSignal(); bool updateAir(); bool airplaneLoadingUpdate(); bool sub_4A95CB(); bool sub_4A9348(uint8_t newMovementEdge, uint16_t targetZ); bool airplaneApproachTarget(uint16_t targetZ); std::pair<Status, Speed16> airplaneGetNewStatus(); uint8_t airportGetNextMovementEdge(uint8_t curEdge); std::tuple<uint32_t, uint16_t, uint8_t> sub_427122(); std::pair<AirportMovementNodeFlags, World::Pos3> airportGetMovementEdgeTarget(StationId targetStation, uint8_t curEdge); bool updateWater(); void tryCreateInitialMovementSound(); void setStationVisitedTypes(); void checkIfAtOrderStation(); void updateLastJourneyAverageSpeed(); void beginUnloading(); void beginLoading(); WaterMotionFlags updateWaterMotion(WaterMotionFlags flags); uint8_t getLoadingModifier(const VehicleBogie* bogie); bool updateUnloadCargoComponent(VehicleCargo& cargo, VehicleBogie* bogie); void updateUnloadCargo(); bool updateLoadCargoComponent(VehicleCargo& cargo, VehicleBogie* bogie); bool updateLoadCargo(); void beginNewJourney(); void advanceToNextRoutableOrder(); Status sub_427BF2(); void produceLeavingDockSound(); void produceTouchdownAirportSound(); uint8_t sub_4AA36A(); bool sub_4AC1C2(); bool opposingTrainAtSignal(); bool pathingShouldReverse(); StationId manualFindTrainStationAtLocation(); bool isOnExpectedRoadOrTrack(); VehicleStatus getStatusTravelling() const; void getSecondStatus(VehicleStatus& vehStatus) const; void updateLastIncomeStats(uint8_t cargoType, uint16_t cargoQty, uint16_t cargoDist, uint8_t cargoAge, currency32_t profit); void calculateRefundCost(); }; static_assert(sizeof(VehicleHead) == 0x7A); // Can't use offset_of change this to last field if more found struct IncomeStats { int32_t day; // 0x53 uint8_t cargoTypes[4]; // 0x57 uint16_t cargoQtys[4]; // 0x5B uint16_t cargoDistances[4]; // 0x63 uint8_t cargoAges[4]; // 0x6B currency32_t cargoProfits[4]; // 0x6F void beginNewIncome(); bool addToStats(uint8_t cargoType, uint16_t cargoQty, uint16_t cargoDist, uint8_t cargoAge, currency32_t profit); }; static_assert(sizeof(IncomeStats) == 0x2C); struct Vehicle1 : VehicleBase { static constexpr auto kVehicleThingType = VehicleEntityType::vehicle_1; uint8_t pad_24[0x26 - 0x24]; EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles Flags38 var_38; uint8_t pad_39; // 0x39 EntityId nextCarId; // 0x3A int32_t var_3C; // 0x3C uint8_t pad_40[0x2]; // 0x40 TransportMode mode; // 0x42 field same in all vehicles uint8_t pad_43; Speed16 targetSpeed; // 0x44 uint16_t timeAtSignal; // 0x46 Flags48 var_48; uint8_t var_49; // 0x49 rackrail mod? uint32_t dayCreated; // 0x4A uint16_t var_4E; uint16_t var_50; uint8_t var_52; IncomeStats lastIncome; // 0x53 bool update(); bool updateRoad(); bool updateRail(); int32_t updateRoadMotion(int32_t distance); }; static_assert(sizeof(Vehicle1) == 0x7F); // Can't use offset_of change this to last field if more found struct Vehicle2 : VehicleBase { static constexpr auto kVehicleThingType = VehicleEntityType::vehicle_2; uint8_t pad_24[0x26 - 0x24]; EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles Flags38 var_38; uint8_t pad_39; // 0x39 EntityId nextCarId; // 0x3A int32_t var_3C; // 0x3C field same in all vehicles unread for veh2 uint8_t pad_40[0x42 - 0x40]; // 0x40 TransportMode mode; // 0x42 field same in all vehicles uint8_t pad_43; SoundObjectId_t drivingSoundId; // 0x44 uint8_t drivingSoundVolume; // 0x45 channel attribute volume related uint16_t drivingSoundFrequency; // 0x46 channel attribute frequency uint16_t objectId; // 0x48 vehicle object (used for sound) SoundFlags soundFlags; // 0x4A common with tail Ui::WindowNumber_t soundWindowNumber; // 0x4C common with tail Ui::WindowType soundWindowType; // 0x4E common with tail int8_t var_4F; uint16_t totalPower; // 0x50 maybe not used by aircraft and ship uint16_t totalWeight; // 0x52 Speed16 maxSpeed; // 0x54 Speed32 currentSpeed; // 0x56 MotorState motorState; uint8_t brakeLightTimeout; Speed16 rackRailMaxSpeed; // 0x5C currency32_t curMonthRevenue; // 0x5E monthly revenue currency32_t profit[4]; // 0x62 last 4 months net profit uint8_t reliability; // 0x72 Flags73 var_73; // 0x73 (bit 0 = broken down, bit 1 = still powered) bool has73Flags(Flags73 flagsToTest) const; bool update(); bool sub_4A9F20(); currency32_t totalRecentProfit() const { return profit[0] + profit[1] + profit[2] + profit[3]; } }; static_assert(sizeof(Vehicle2) == 0x74); // Can't use offset_of change this to last field if more found struct VehicleBody : VehicleBase { static constexpr auto kVehicleThingType = VehicleEntityType::body_continued; ColourScheme colourScheme; // 0x24 EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles Flags38 var_38; uint8_t objectSpriteType; // 0x39 EntityId nextCarId; // 0x3A int32_t var_3C; // 0x3C field same in all vehicles unread for body uint16_t objectId; // 0x40 TransportMode mode; // 0x42 uint8_t pad_43; int16_t var_44; uint8_t animationFrame; // 0x46 roll/animation sprite index uint8_t cargoFrame; // 0x47 cargo sprite index VehicleCargo primaryCargo; // 0x48 uint8_t pad_52[0x54 - 0x52]; uint8_t bodyIndex; // 0x54 int8_t chuffSoundIndex; uint32_t creationDay; // 0x56 uint32_t var_5A; uint8_t wheelSlipping; // 0x5E timeout that counts up BreakdownFlags breakdownFlags; // 0x5F uint16_t pad_60; // 0x60 uint32_t refundCost; // 0x62 uint8_t pad_66[0x6A - 0x66]; uint8_t breakdownTimeout; // 0x6A (likely unused) const VehicleObject* getObject() const; bool update(); void secondaryAnimationUpdate(); void updateSegmentCrashed(); void sub_4AAB0B(); void updateCargoSprite(); constexpr bool hasBreakdownFlags(BreakdownFlags flagsToTest) const { return (breakdownFlags & flagsToTest) != BreakdownFlags::none; } void sub_4AC255(VehicleBogie* backBogie, VehicleBogie* frontBogie); private: void animationUpdate(); void steamPuffsAnimationUpdate(uint8_t num, int32_t var_05); void dieselExhaust1AnimationUpdate(uint8_t num, int32_t var_05); void dieselExhaust2AnimationUpdate(uint8_t num, int32_t var_05); void electricSpark1AnimationUpdate(uint8_t num, int32_t var_05); void electricSpark2AnimationUpdate(uint8_t num, int32_t var_05); void shipWakeAnimationUpdate(uint8_t num, int32_t var_05); Pitch updateSpritePitchSteepSlopes(uint16_t xyOffset, int16_t zOffset); Pitch updateSpritePitch(uint16_t xyOffset, int16_t zOffset); }; static_assert(sizeof(VehicleBody) == 0x6B); // Can't use offset_of change this to last field if more found uint8_t calculateYaw0FromVector(int16_t xDiff, int16_t yDiff); uint8_t calculateYaw1FromVectorPlane(int16_t xDiff, int16_t yDiff); uint8_t calculateYaw1FromVector(int16_t xDiff, int16_t yDiff); uint8_t calculateYaw4FromVector(int16_t xOffset, int16_t yOffset); struct VehicleBogie : VehicleBase { static constexpr auto kVehicleThingType = VehicleEntityType::bogie; ColourScheme colourScheme; // 0x24 EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles Flags38 var_38; uint8_t objectSpriteType; // 0x39 EntityId nextCarId; // 0x3A int32_t var_3C; // 0x3C field same in all vehicles unread for bogie uint16_t objectId; // 0x40 TransportMode mode; // 0x42 field same in all vehicles uint8_t pad_43; uint16_t var_44; uint8_t animationIndex; // 0x46 animation index uint8_t var_47; // 0x47 cargo sprite index (unused) VehicleCargo secondaryCargo; // 0x48 Note back bogie cannot carry cargo always check type uint16_t totalCarWeight; // 0x52 only valid for first bogie of car uint8_t bodyIndex; // 0x54 uint8_t pad_55; uint32_t creationDay; // 0x56 uint32_t var_5A; uint8_t wheelSlipping; // 0x5E timeout that counts up BreakdownFlags breakdownFlags; uint8_t var_60; uint8_t var_61; uint32_t refundCost; // 0x62 front bogies only uint16_t reliability; // 0x66 front bogies only uint16_t timeoutToBreakdown; // 0x68 front bogies only (days) counts down to the next breakdown 0xFFFFU disables this uint8_t breakdownTimeout; // 0x6A front bogies only (days) public: AirportObjectFlags getCompatibleAirportType(); bool update(); void updateSegmentCrashed(); bool isOnRackRail(); constexpr bool hasBreakdownFlags(BreakdownFlags flagsToTest) const { return (breakdownFlags & flagsToTest) != BreakdownFlags::none; } private: void updateRoll(); void collision(); }; static_assert(sizeof(VehicleBogie) == 0x6B); // Can't use offset_of change this to last field if more found void sub_4BA873(VehicleBogie& vehBogie); struct VehicleTail : VehicleBase { static constexpr auto kVehicleThingType = VehicleEntityType::tail; uint8_t pad_24[0x26 - 0x24]; EntityId head; // 0x26 int32_t remainingDistance; // 0x28 TrackAndDirection trackAndDirection; // 0x2C uint16_t subPosition; // 0x2E int16_t tileX; // 0x30 int16_t tileY; // 0x32 World::SmallZ tileBaseZ; // 0x34 uint8_t trackType; // 0x35 field same in all vehicles RoutingHandle routingHandle; // 0x36 field same in all vehicles Flags38 var_38; uint8_t pad_39; // 0x39 EntityId nextCarId; // 0x3A int32_t var_3C; // 0x3C field same in all vehicles unread for tail uint8_t pad_40[0x42 - 0x40]; // 0x40 TransportMode mode; // 0x42 field same in all vehicles uint8_t pad_43; SoundObjectId_t drivingSoundId; // 0x44 uint8_t drivingSoundVolume; // 0x45 channel attribute volume related uint16_t drivingSoundFrequency; // 0x46 channel attribute frequency uint16_t objectId; // 0x48 vehicle object (used for sound) SoundFlags soundFlags; // 0x4A common with veh_2 Ui::WindowNumber_t soundWindowNumber; // 0x4C common with veh_2 Ui::WindowType soundWindowType; // 0x4E common with veh_2 uint16_t trainDanglingTimeout; // 0x4F counts up when no cars on train bool update(); }; static_assert(sizeof(VehicleTail) == 0x51); // Can't use offset_of change this to last field if more found void liftUpTail(VehicleTail& tail); #pragma pack(pop) struct CarComponent { VehicleBogie* front = nullptr; VehicleBogie* back = nullptr; VehicleBody* body = nullptr; CarComponent(VehicleBase*& component); CarComponent() = default; template<typename TFunc> void applyToComponents(TFunc&& func) const { func(*front); func(*back); func(*body); } }; struct Car : public CarComponent { class CarComponentIter { private: CarComponent current; VehicleBase* nextVehicleComponent = nullptr; public: CarComponentIter(const CarComponent* carComponent) { if (carComponent == nullptr) { nextVehicleComponent = nullptr; return; } current = *carComponent; nextVehicleComponent = current.body->nextVehicleComponent(); } CarComponentIter& operator++() { if (nextVehicleComponent == nullptr) { return *this; } if (nextVehicleComponent->getSubType() == VehicleEntityType::tail) { nextVehicleComponent = nullptr; return *this; } CarComponent next{ nextVehicleComponent }; if (next.body == nullptr || next.body->getSubType() == VehicleEntityType::body_start) { nextVehicleComponent = nullptr; return *this; } current = next; return *this; } CarComponentIter operator++(int) { CarComponentIter retval = *this; ++(*this); return retval; } bool operator==(CarComponentIter other) const { return nextVehicleComponent == other.nextVehicleComponent; } constexpr CarComponent& operator*() { return current; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = CarComponent; using pointer = CarComponent*; using reference = CarComponent&; using iterator_category = std::forward_iterator_tag; }; CarComponentIter begin() const { return CarComponentIter(this); } CarComponentIter end() const { return CarComponentIter(nullptr); } Car(VehicleBase*& component) : CarComponent(component) { } Car() = default; template<typename TFunc> void applyToComponents(TFunc&& func) const { for (auto& carComponent : *this) { carComponent.applyToComponents(func); } } }; struct Vehicle { struct Cars { Car firstCar; class CarIter { private: Car current; VehicleBase* nextVehicleComponent = nullptr; public: CarIter(const Car* carComponent) { if (carComponent == nullptr || carComponent->body == nullptr) { nextVehicleComponent = nullptr; return; } current = *carComponent; nextVehicleComponent = current.body->nextVehicleComponent(); } CarIter& operator++() { if (nextVehicleComponent == nullptr) { return *this; } while (nextVehicleComponent->getSubType() != VehicleEntityType::tail) { Car next{ nextVehicleComponent }; if (next.body == nullptr) { break; } if (next.body->getSubType() == VehicleEntityType::body_start) { current = next; return *this; } } nextVehicleComponent = nullptr; return *this; } CarIter operator++(int) { CarIter retval = *this; ++(*this); return retval; } bool operator==(CarIter other) const { return nextVehicleComponent == other.nextVehicleComponent; } constexpr Car& operator*() { return current; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = Car; using pointer = Car*; using reference = Car&; using iterator_category = std::forward_iterator_tag; }; CarIter begin() const { return CarIter(&firstCar); } CarIter end() const { return CarIter(nullptr); } std::size_t size() const { if (firstCar.body == nullptr) { return 0; } return std::distance(begin(), end()); } bool empty() const { if (firstCar.body == nullptr) { return true; } return false; } Cars(Car&& _firstCar) : firstCar(_firstCar) { } Cars() = default; template<typename TFunc> void applyToComponents(TFunc&& func) const { for (auto& car : *this) { car.applyToComponents(func); } } }; VehicleHead* head; Vehicle1* veh1; Vehicle2* veh2; VehicleTail* tail; Cars cars; Vehicle(const VehicleHead& _head) : Vehicle(_head.id) { } Vehicle(EntityId _head); template<typename TFunc> void applyToComponents(TFunc&& func) const { func(*head); func(*veh1); func(*veh2); cars.applyToComponents(func); func(*tail); } }; // TODO: move this? uint32_t getNumUnitsForCargo(uint32_t maxPrimaryCargo, uint8_t primaryCargoId, uint8_t newCargoId); void removeAllCargo(CarComponent& carComponent); struct VehicleCommon; /* flipCar * Reverses a Car in-place and returns the new front bogie * frontBogie: front bogie of the Car * returns new front bogie of the Car */ VehicleBogie* flipCar(VehicleBogie& frontBogie); /* insertCarBefore * Takes source vehicle out of its train and puts it in front of the destination vehicle in the destination train. * Source and destination trains can be the same. * source: front bogie of the Car to move * dest: VehicleBogie or VehicleTail to place Car before * returns nothing */ void insertCarBefore(VehicleBogie& source, VehicleBase& dest); bool canVehiclesCouple(const uint16_t newVehicleTypeId, const uint16_t sourceVehicleTypeId); void connectJacobsBogies(VehicleHead& head); void applyVehicleObjectLength(Vehicle& train); bool positionVehicleOnTrack(VehicleHead& head); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Vehicle1.cpp ```cpp #include "Entities/EntityManager.h" #include "Map/TileManager.h" #include "Map/Track/SubpositionData.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Objects/BridgeObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "RoutingManager.h" #include "Vehicle.h" #include "ViewportManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; namespace OpenLoco::Vehicles { static loco_global<int32_t, 0x0113612C> _vehicleUpdate_var_113612C; // Speed static loco_global<Speed32, 0x01136134> _vehicleUpdate_var_1136134; // Speed // If distance travelled in one tick this is the speed constexpr Speed32 speedFromDistanceInATick(int32_t distance) { return Speed32(distance * 2); } constexpr int32_t distanceTraveledInATick(Speed32 speed) { return (speed / 2).getRaw(); } static_assert(distanceTraveledInATick(speedFromDistanceInATick(100)) == 100); // 0x004A9788 bool Vehicle1::update() { switch (mode) { case TransportMode::air: case TransportMode::water: return true; case TransportMode::road: return updateRoad(); case TransportMode::rail: return updateRail(); default: return false; } } // 0x004A9969 bool Vehicle1::updateRoad() { uint16_t curveSpeedFraction = std::numeric_limits<uint16_t>::max(); Speed16 newTargetSpeed = kSpeed16Max; RoutingManager::RingView ring(routingHandle); bool isOnRackRail = false; for (auto iter = ring.rbegin(); iter != ring.rend(); ++iter) { auto res = RoutingManager::getRouting(*iter); isOnRackRail |= (res & (1 << 13)) != 0; // rackrail uint8_t roadId = (res >> 3) & 0xF; curveSpeedFraction = std::min(curveSpeedFraction, World::TrackData::getRoadMiscData(roadId).curveSpeedFraction); if (res & (1 << 12)) { const auto* bridgeObj = ObjectManager::get<BridgeObject>((res & 0xE00) >> 9); if (bridgeObj->maxSpeed != kSpeed16Null) { newTargetSpeed = std::min(bridgeObj->maxSpeed, newTargetSpeed); } } } Vehicle train(head); if (train.veh2->var_4F != -1) { const auto* roadObj = ObjectManager::get<RoadObject>(train.veh2->var_4F); const Speed32 fractionalSpeed = Speed32(static_cast<uint32_t>(curveSpeedFraction) * roadObj->maxSpeed.getRaw()); newTargetSpeed = std::min(toSpeed16(fractionalSpeed + 1.0_mph), newTargetSpeed); newTargetSpeed = std::max(newTargetSpeed, 12_mph); if (train.head->has38Flags(Flags38::fasterAroundCurves)) { newTargetSpeed += newTargetSpeed / 4; newTargetSpeed = std::min(roadObj->maxSpeed, newTargetSpeed); } } else { const Speed32 fractionalSpeed = Speed32(static_cast<uint32_t>(curveSpeedFraction) * (60_mph).getRaw()); newTargetSpeed = toSpeed16(fractionalSpeed); } newTargetSpeed = std::min(newTargetSpeed, train.veh2->maxSpeed); if (isOnRackRail) { newTargetSpeed = std::min(newTargetSpeed, train.veh2->rackRailMaxSpeed); } // TODO: Original CS Bug. Fix when we diverge on replays // newTargetSpeed = std::min(newTargetSpeed, toSpeed16(speedFromDistanceInATick(var_3C)) + 5_mph); newTargetSpeed = std::min(newTargetSpeed, Speed16(static_cast<uint32_t>(var_3C) >> 15) + 5_mph); if ((train.head->hasVehicleFlags(VehicleFlags::manualControl) && train.head->manualPower <= -20) || train.head->hasVehicleFlags(VehicleFlags::commandStop)) { if (train.veh2->currentSpeed == 0.0_mph) { newTargetSpeed = 0_mph; } } targetSpeed = newTargetSpeed; _vehicleUpdate_var_1136134 = newTargetSpeed; int32_t distance1 = distanceTraveledInATick(train.veh2->currentSpeed) - var_3C; const auto unk2 = std::max(_vehicleUpdate_var_113612C * 4, 0xCC48); distance1 = std::min(distance1, unk2); var_3C += distance1 - updateRoadMotion(distance1); if (!hasUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound)) { return true; } train.head->sub_4AD93A(); if (train.head->status == Status::approaching) { train.head->status = Status::travelling; } return true; } // 0x004B98DA static void railProduceCrossingWhistle(const Vehicle2& veh2) { Vehicle train{ veh2.head }; auto* vehObj = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); if (vehObj->numStartSounds == 0) { return; } gPrng1().randNext(); // TODO: Remove when we can diverge from vanilla const auto soundNum = (vehObj->numStartSounds & NumStartSounds::kMask) - 1; const auto soundObjId = vehObj->startSounds[soundNum]; const auto height = World::TileManager::getHeight(veh2.position); const auto volume = veh2.position.z < height.landHeight ? -1500 : 0; Audio::playSound(Audio::makeObjectSoundId(soundObjId), veh2.position + World::Pos3{ 0, 0, 22 }, volume, 22050); } // 0x004A97A6 bool Vehicle1::updateRail() { Vehicle train{ head }; uint16_t curveSpeedFraction = std::numeric_limits<uint16_t>::max(); Speed16 newTargetSpeed = kSpeed16Max; bool isOnRackRail = false; if (!train.head->hasVehicleFlags(VehicleFlags::manualControl)) { RoutingManager::RingView ring(routingHandle); for (auto iter = ring.rbegin(); iter != ring.rend(); ++iter) { auto res = RoutingManager::getRouting(*iter); isOnRackRail |= (res & (1U << 13)) != 0; // rackrail uint8_t trackId = (res >> 3) & 0x3F; curveSpeedFraction = std::min(curveSpeedFraction, World::TrackData::getTrackMiscData(trackId).curveSpeedFraction); if (res & (1U << 12)) { const auto* bridgeObj = ObjectManager::get<BridgeObject>((res & 0xE00) >> 9); if (bridgeObj->maxSpeed != kSpeed16Null) { newTargetSpeed = std::min(bridgeObj->maxSpeed, newTargetSpeed); } } } } const auto* trackObj = ObjectManager::get<TrackObject>(trackType); const Speed32 fractionalSpeed = Speed32(static_cast<uint32_t>(curveSpeedFraction) * trackObj->curveSpeed.getRaw()); newTargetSpeed = std::min(toSpeed16(fractionalSpeed + 1.0_mph), newTargetSpeed); if (train.head->has38Flags(Flags38::fasterAroundCurves)) { newTargetSpeed += newTargetSpeed / 4; newTargetSpeed = std::min(trackObj->curveSpeed, newTargetSpeed); } const auto veh2MaxSpeed = [veh2 = train.veh2]() { if (veh2->has73Flags(Flags73::isBrokenDown)) { return veh2->maxSpeed / 4; } return veh2->maxSpeed; }(); newTargetSpeed = std::min(newTargetSpeed, veh2MaxSpeed); if (isOnRackRail) { newTargetSpeed = std::min(newTargetSpeed, train.veh2->rackRailMaxSpeed); } if (!train.head->hasVehicleFlags(VehicleFlags::manualControl)) { // TODO: Original CS Bug. Fix when we diverge on replays // newTargetSpeed = std::min(newTargetSpeed, toSpeed16(speedFromDistanceInATick(var_3C)) + 5_mph); newTargetSpeed = std::min(newTargetSpeed, Speed16(static_cast<uint32_t>(var_3C) >> 15) + 5_mph); } if ((train.head->hasVehicleFlags(VehicleFlags::manualControl) && train.head->manualPower <= -20) || train.head->hasVehicleFlags(VehicleFlags::commandStop)) { if (train.veh2->currentSpeed == 0.0_mph) { newTargetSpeed = 0_mph; } } targetSpeed = newTargetSpeed; _vehicleUpdate_var_1136134 = newTargetSpeed; int32_t distance1 = distanceTraveledInATick(train.veh2->currentSpeed) - var_3C; const auto unk2 = std::max(_vehicleUpdate_var_113612C * 4, 0xCC48); distance1 = std::min(distance1, unk2); resetUpdateVar1136114Flags(); var_3C += distance1 - updateTrackMotion(distance1); if (!hasUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound)) { if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::approachingGradeCrossing)) { railProduceCrossingWhistle(*train.veh2); } return true; } train.head->sub_4AD93A(); if (train.head->status == Status::approaching) { train.head->status = Status::travelling; } return true; } enum class OvertakeResult { overtakeAvailble, noOvertakeAvailble, mayBeOvertaken, }; // 0x0047CD78 // ax : pos.x // cx : pos.y // dl : pos.z / World::kSmallZStep // ebp : tad // esi : veh1 // // return mayBeOvertaken == high carry flag // overtakeAvailable 0x0112C328 == 5 // noOvertakeAvailable 0x0112C328 == 0 static OvertakeResult getRoadOvertakeAvailability(const Vehicle1& veh1, World::Pos3 pos, uint16_t tad) { OvertakeResult result = OvertakeResult::noOvertakeAvailble; for (const auto& nearby : kMooreNeighbourhood) { const auto inspectionPos = World::toTileSpace(pos) + nearby; for (auto* entity : EntityManager::EntityTileList(World::toWorldSpace(inspectionPos))) { auto* vehicleBase = entity->asBase<VehicleBase>(); if (vehicleBase == nullptr || !vehicleBase->isVehicleTail()) { continue; } auto* vehicleTail = vehicleBase->asVehicleTail(); if (vehicleTail == nullptr) { continue; } if (vehicleTail->getTransportMode() != TransportMode::road) { continue; } if (vehicleTail->tileBaseZ * World::kSmallZStep != pos.z) { continue; } if (vehicleTail->tileX != pos.x || vehicleTail->tileY != pos.y) { continue; } if ((vehicleTail->trackAndDirection.road._data & World::Track::AdditionalTaDFlags::basicTaDMask) != (tad & World::Track::AdditionalTaDFlags::basicTaDMask)) { continue; } // Perhaps a little expensive to do this (we don't do it on rail vehicles for example) Vehicle train(vehicleTail->head); if (train.veh1->var_3C < 0x220C0) { continue; } if ((train.veh2->var_73 & Flags73::isBrokenDown) != Flags73::none) { continue; } if (veh1.var_3C < train.veh1->var_3C) { return OvertakeResult::mayBeOvertaken; } auto* veh2 = EntityManager::get<Vehicle2>(veh1.nextCarId); if (veh2 == nullptr) { continue; } if (veh2->maxSpeed <= train.veh2->maxSpeed) { return OvertakeResult::mayBeOvertaken; } result = OvertakeResult::overtakeAvailble; } } return result; } // 0x0047D308 static bool veh1UpdateRoadMotionNewRoadPiece(Vehicle1& veh1) { auto newRoutingHandle = veh1.routingHandle; auto newIndex = newRoutingHandle.getIndex() + 1; newRoutingHandle.setIndex(newIndex); const auto routing = RoutingManager::getRouting(newRoutingHandle); if (routing == RoutingManager::kAllocatedButFreeRouting) { return false; } const auto newPos = World::Pos3(veh1.tileX, veh1.tileY, veh1.tileBaseZ * World::kSmallZStep) + World::TrackData::getUnkRoad(veh1.trackAndDirection.road.basicRad()).pos; TrackAndDirection::_RoadAndDirection newRad(0, 0); newRad._data = routing & 0x1FFU; veh1.sub_47D959(newPos, newRad, true); veh1.routingHandle = newRoutingHandle; veh1.trackAndDirection.road = newRad; veh1.tileX = newPos.x; veh1.tileY = newPos.y; veh1.tileBaseZ = newPos.z / World::kSmallZStep; return true; } // 0x0047D2D6 // veh1 : esi // numRoadPieces : ah // return eax static int32_t vehicle1UpdateRoadMotionByPieces(Vehicle1& veh1, const uint8_t numRoadPieces) { auto intermediatePosition = veh1.position; auto distanceMoved = 0; for (auto i = 0; i < numRoadPieces;) { auto newSubPosition = veh1.subPosition + 1U; const auto subPositionDataSize = World::TrackData::getRoadSubPositon(veh1.trackAndDirection.road._data).size(); // This means we have moved forward by a road piece if (newSubPosition >= subPositionDataSize) { if (!veh1UpdateRoadMotionNewRoadPiece(veh1)) { // This seems wrong but its what vanilla does // Todo investigate if we should return 0 or actually move // the vehicle return distanceMoved; } else { newSubPosition = 0; i++; } } veh1.subPosition = newSubPosition; const auto& moveData = World::TrackData::getRoadSubPositon(veh1.trackAndDirection.road._data)[newSubPosition]; const auto nextNewPosition = moveData.loc + World::Pos3(veh1.tileX, veh1.tileY, veh1.tileBaseZ * World::kSmallZStep); distanceMoved += kMovementNibbleToDistance[getMovementNibble(intermediatePosition, nextNewPosition)]; intermediatePosition = nextNewPosition; veh1.spriteYaw = moveData.yaw; veh1.spritePitch = moveData.pitch; } veh1.moveTo(intermediatePosition); return distanceMoved; } // 0x0047D1B4 // Similar to the others but doesn't update the vehicle // due to that it must take reference to all the variables static bool veh1UpdateRoadMotionNewRoadPieceNoMove(World::Pos3& pos, RoutingHandle& handle, TrackAndDirection::_RoadAndDirection& rad) { auto newIndex = handle.getIndex() + 1; handle.setIndex(newIndex); const auto routing = RoutingManager::getRouting(handle); if (routing == RoutingManager::kAllocatedButFreeRouting) { return false; } pos += World::TrackData::getUnkRoad(rad.basicRad()).pos; rad._data = routing & 0x1FFU; return true; } // 0x0047D142 // veh1 : esi // numRoadPieces : ah // return eax static int32_t vehicle1UpdateRoadMotionByPiecesNoMove(Vehicle1& veh1, const uint8_t numRoadPieces) { auto intermediatePosition = veh1.position; auto distanceMoved = 0; auto pos = World::Pos3(veh1.tileX, veh1.tileY, veh1.tileBaseZ * World::kSmallZStep); auto rad = veh1.trackAndDirection.road; auto handle = veh1.routingHandle; auto subPosition = veh1.subPosition; for (auto i = 0; i < numRoadPieces;) { auto newSubPosition = subPosition + 1U; const auto subPositionDataSize = World::TrackData::getRoadSubPositon(rad._data).size(); // This means we have moved forward by a road piece if (newSubPosition >= subPositionDataSize) { if (!veh1UpdateRoadMotionNewRoadPieceNoMove(pos, handle, rad)) { return distanceMoved; } else { newSubPosition = 0; i++; } } subPosition = newSubPosition; const auto& moveData = World::TrackData::getRoadSubPositon(rad._data)[newSubPosition]; const auto nextNewPosition = moveData.loc + pos; distanceMoved += kMovementNibbleToDistance[getMovementNibble(intermediatePosition, nextNewPosition)]; intermediatePosition = nextNewPosition; } return distanceMoved; } // 0x0047D46F // veh1 : esi // numRoadPieces : ah static void applyOvertakeToVehicle1(Vehicle1& veh1, uint8_t numRoadPieces) { const auto noOvertakeDistance = vehicle1UpdateRoadMotionByPiecesNoMove(veh1, numRoadPieces); auto routingRing = RoutingManager::RingView(veh1.routingHandle); auto iter = ++routingRing.begin(); constexpr auto kResetRouting = static_cast<uint16_t>(~(World::Track::AdditionalTaDFlags::isChangingLane | World::Track::AdditionalTaDFlags::isOvertaking)); for (auto i = 0; i < numRoadPieces; ++iter, ++i) { if (iter == routingRing.end()) { break; } const auto routing = RoutingManager::getRouting(*iter); if (i == 0) { RoutingManager::setRouting(*iter, (routing & kResetRouting) | World::Track::AdditionalTaDFlags::isChangingLane); } else if (i == (numRoadPieces - 1)) { RoutingManager::setRouting(*iter, (routing & kResetRouting) | World::Track::AdditionalTaDFlags::isChangingLane | World::Track::AdditionalTaDFlags::isOvertaking); } else { RoutingManager::setRouting(*iter, (routing & kResetRouting) | World::Track::AdditionalTaDFlags::isOvertaking); } } const auto newDistance = vehicle1UpdateRoadMotionByPieces(veh1, numRoadPieces); veh1.var_3C += newDistance; auto* head = EntityManager::get<VehicleHead>(veh1.head); head->var_3C += newDistance - noOvertakeDistance; } // 0x0047D52B // veh1 : esi // numRoadPieces : ah static void applyChangeLaneToVehicle1(Vehicle1& veh1, uint8_t numRoadPieces) { const auto noOvertakeDistance = vehicle1UpdateRoadMotionByPiecesNoMove(veh1, numRoadPieces); auto routingRing = RoutingManager::RingView(veh1.routingHandle); auto iter = ++routingRing.begin(); constexpr auto kResetRouting = static_cast<uint16_t>(~(World::Track::AdditionalTaDFlags::isChangingLane | World::Track::AdditionalTaDFlags::isOvertaking)); for (auto i = 0; i < numRoadPieces; ++iter, ++i) { if (iter == routingRing.end()) { break; } const auto routing = RoutingManager::getRouting(*iter); if (i == 0) { RoutingManager::setRouting(*iter, (routing & kResetRouting) | World::Track::AdditionalTaDFlags::isChangingLane); } else { RoutingManager::setRouting(*iter, (routing & kResetRouting) | World::Track::AdditionalTaDFlags::isOvertaking); } } const auto newDistance = vehicle1UpdateRoadMotionByPieces(veh1, numRoadPieces); veh1.var_3C += newDistance; auto* head = EntityManager::get<VehicleHead>(veh1.head); head->var_3C += newDistance - noOvertakeDistance; head->trackAndDirection.road._data &= kResetRouting; head->trackAndDirection.road._data |= numRoadPieces <= 1 ? World::Track::AdditionalTaDFlags::isChangingLane : World::Track::AdditionalTaDFlags::isOvertaking; } enum class LookaheadType { // These were flags in the original but you only ever had // one at a time so have been changed to an enum none, // 0 overtake, // 1 << 0 noRoute, // 1 << 1 levelCrossing, // 1 << 2 changeLane, // 1 << 3 }; struct LookaheadResult { LookaheadType type; uint8_t numRoadPieces; }; // 0x0047CEB7 // veh1 : esi // return : type : al, numRoadPieces : ah static LookaheadResult lookaheadRoad(Vehicle1& veh1) { const auto startPos = World::Pos3(veh1.tileX, veh1.tileY, veh1.tileBaseZ * World::kSmallZStep); uint8_t numRoadPieces = 0; auto pos = startPos + World::TrackData::getUnkRoad(veh1.trackAndDirection.road.basicRad()).pos; numRoadPieces++; auto routings = RoutingManager::RingView(veh1.routingHandle); auto routingIter = routings.begin(); if (routingIter == routings.end()) { return LookaheadResult{ LookaheadType::none, 0 }; } routingIter++; if (routingIter == routings.end()) { return LookaheadResult{ LookaheadType::none, 0 }; } auto routing = RoutingManager::getRouting(*routingIter); TrackAndDirection::_RoadAndDirection tad(0, 0); tad._data = routing & World::Track::AdditionalTaDFlags::basicTaDMask; const auto occupationFlags = getRoadOccupation(pos, tad); if ((occupationFlags & RoadOccupationFlags::hasLevelCrossing) != RoadOccupationFlags::none) { // 0x0047D0B9 if ((occupationFlags & (RoadOccupationFlags::isLaneOccupied | RoadOccupationFlags::isLevelCrossingClosed)) != RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::noRoute, 0 }; } ++numRoadPieces; for (; numRoadPieces < 255; ++numRoadPieces) { pos += World::TrackData::getUnkRoad(tad.basicRad()).pos; routingIter++; if (routingIter == routings.end()) { return LookaheadResult{ LookaheadType::noRoute, 0 }; } tad._data = RoutingManager::getRouting(*routingIter) & World::Track::AdditionalTaDFlags::basicTaDMask; const auto fwdOccupationFlags = getRoadOccupation(pos, tad); if ((fwdOccupationFlags & (RoadOccupationFlags::isLaneOccupied | RoadOccupationFlags::isLevelCrossingClosed)) != RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::noRoute, 0 }; } if ((fwdOccupationFlags & RoadOccupationFlags::hasLevelCrossing) == RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::levelCrossing, numRoadPieces }; } } return LookaheadResult{ LookaheadType::noRoute, 0 }; } else { OvertakeResult overtakeResult = OvertakeResult::overtakeAvailble; if ((occupationFlags & RoadOccupationFlags::isLaneOccupied) != RoadOccupationFlags::none) { overtakeResult = getRoadOvertakeAvailability(veh1, pos, tad._data); if (overtakeResult == OvertakeResult::mayBeOvertaken) { return LookaheadResult{ LookaheadType::none, 0 }; } } else { // 0x0047CF32 auto nextRoutingIter = routingIter; nextRoutingIter++; const auto nextPos = pos + World::TrackData::getUnkRoad(tad.basicRad()).pos; if (nextRoutingIter == routings.end()) { return LookaheadResult{ LookaheadType::none, 0 }; } auto nextRouting = RoutingManager::getRouting(*nextRoutingIter); TrackAndDirection::_RoadAndDirection nextTad(0, 0); nextTad._data = nextRouting & World::Track::AdditionalTaDFlags::basicTaDMask; const auto nextOccupationFlags = getRoadOccupation(nextPos, nextTad); if ((nextOccupationFlags & RoadOccupationFlags::isLaneOccupied) == RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::none, 0 }; } overtakeResult = getRoadOvertakeAvailability(veh1, nextPos, nextTad._data); if (overtakeResult == OvertakeResult::mayBeOvertaken) { return LookaheadResult{ LookaheadType::none, 0 }; } } // 0x0047CFB5 const auto& roadObj = ObjectManager::get<RoadObject>(veh1.trackType); if (!roadObj->hasFlags(RoadObjectFlags::isRoad)) { return LookaheadResult{ LookaheadType::none, 0 }; } if (tad.isChangingLane() || tad.isOvertaking()) { return LookaheadResult{ LookaheadType::none, 0 }; } auto backToFrontTad = tad; backToFrontTad._data ^= (1U << 7); auto btfOccupationFlags = getRoadOccupation(pos, backToFrontTad); if ((btfOccupationFlags & (RoadOccupationFlags::hasLevelCrossing | RoadOccupationFlags::isLaneOccupied)) != RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::none, 0 }; } const auto unkCount = overtakeResult == OvertakeResult::overtakeAvailble ? 5 : 0; ++numRoadPieces; auto i = 0; for (; numRoadPieces < 11; ++numRoadPieces) { pos += World::TrackData::getUnkRoad(tad.basicRad()).pos; routingIter++; if (routingIter == routings.end()) { if ((btfOccupationFlags & RoadOccupationFlags::hasStation) == RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::none, 0 }; } return LookaheadResult{ LookaheadType::changeLane, static_cast<uint8_t>(numRoadPieces - 1) }; } tad._data = RoutingManager::getRouting(*routingIter) & World::Track::AdditionalTaDFlags::basicTaDMask; backToFrontTad = tad; backToFrontTad._data ^= (1U << 7); btfOccupationFlags = getRoadOccupation(pos, backToFrontTad); if ((btfOccupationFlags & (RoadOccupationFlags::hasLevelCrossing | RoadOccupationFlags::isLaneOccupied)) != RoadOccupationFlags::none) { return LookaheadResult{ LookaheadType::none, 0 }; } const auto fwdOccupationFlags = getRoadOccupation(pos, tad); if ((fwdOccupationFlags & RoadOccupationFlags::isLaneOccupied) != RoadOccupationFlags::none) { i = 0; continue; } i++; if (i <= unkCount) { continue; } return LookaheadResult{ LookaheadType::overtake, numRoadPieces }; } return LookaheadResult{ LookaheadType::none, 0 }; } } enum class RoadMotionNewPieceResult { // New piece processed and any left over distance to process should be processed by parent function continueUpdate, // We have reached the end of the update processing for some reason e.g. invalid route parent function // should update the position and return left over distance noFurther, // When this happens parent function does not require any further processing and should return 0 performedLookahead, }; // 0x0047CABF static RoadMotionNewPieceResult updateRoadMotionNewRoadPiece(Vehicle1& component) { auto newRoutingHandle = component.routingHandle; auto newIndex = newRoutingHandle.getIndex() + 1; newRoutingHandle.setIndex(newIndex); const auto routing = RoutingManager::getRouting(newRoutingHandle); if (routing == RoutingManager::kAllocatedButFreeRouting) { return RoadMotionNewPieceResult::noFurther; } auto* head = EntityManager::get<VehicleHead>(component.head); if (head->var_52 != 1) { auto res = lookaheadRoad(component); switch (res.type) { case LookaheadType::none: break; case LookaheadType::overtake: applyOvertakeToVehicle1(component, res.numRoadPieces); return RoadMotionNewPieceResult::performedLookahead; case LookaheadType::noRoute: return RoadMotionNewPieceResult::noFurther; case LookaheadType::levelCrossing: component.var_3C += vehicle1UpdateRoadMotionByPieces(component, res.numRoadPieces); return RoadMotionNewPieceResult::performedLookahead; case LookaheadType::changeLane: applyChangeLaneToVehicle1(component, res.numRoadPieces); return RoadMotionNewPieceResult::performedLookahead; } } World::Pos3 pos(component.tileX, component.tileY, component.tileBaseZ * World::kSmallZStep); auto [nextPos, nextRot] = World::Track::getRoadConnectionEnd(pos, component.trackAndDirection.road.basicRad()); const auto tc = World::Track::getRoadConnections(nextPos, nextRot, component.owner, head->trackType, head->var_53, 0); auto newRad = TrackAndDirection::_RoadAndDirection(0, 0); newRad._data = routing & 0x1FFU; const auto basicRad = routing & World::Track::AdditionalTaDFlags::basicRaDMask; bool routingFound = false; for (auto& connection : tc.connections) { if ((connection & World::Track::AdditionalTaDFlags::basicRaDMask) == basicRad) { routingFound = true; break; } } if (!routingFound) { setUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound); return RoadMotionNewPieceResult::noFurther; } auto occupation = getRoadOccupation(nextPos, newRad); const auto invalidOccupationFlags = RoadOccupationFlags::isLaneOccupied | (head->var_52 != 1 ? RoadOccupationFlags::isLevelCrossingClosed : RoadOccupationFlags::none); if ((occupation & invalidOccupationFlags) != RoadOccupationFlags::none) { return RoadMotionNewPieceResult::noFurther; } const auto newTrackType = component.sub_47D959(nextPos, newRad, true); component.trackType = newTrackType; component.routingHandle = newRoutingHandle; component.trackAndDirection.road = newRad; component.tileX = nextPos.x; component.tileY = nextPos.y; component.tileBaseZ = nextPos.z / World::kSmallZStep; return RoadMotionNewPieceResult::continueUpdate; } // 0x0047CA71 int32_t Vehicle1::updateRoadMotion(const int32_t distance) { resetUpdateVar1136114Flags(); this->remainingDistance += distance; bool hasMoved = false; auto returnValue = 0; auto intermediatePosition = this->position; while (this->remainingDistance >= 0x368A) { hasMoved = true; auto newSubPosition = this->subPosition + 1U; const auto subPositionDataSize = World::TrackData::getRoadSubPositon(this->trackAndDirection.road._data).size(); // This means we have moved forward by a road piece if (newSubPosition >= subPositionDataSize) { auto newPieceRes = updateRoadMotionNewRoadPiece(*this); if (newPieceRes == RoadMotionNewPieceResult::noFurther) { returnValue = this->remainingDistance - 0x3689; this->remainingDistance = 0x3689; setUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00); break; } else if (newPieceRes == RoadMotionNewPieceResult::performedLookahead) { return 0; } else { newSubPosition = 0; } } // 0x0047C95B this->subPosition = newSubPosition; const auto& moveData = World::TrackData::getRoadSubPositon(this->trackAndDirection.road._data)[newSubPosition]; const auto nextNewPosition = moveData.loc + World::Pos3(this->tileX, this->tileY, this->tileBaseZ * World::kSmallZStep); this->remainingDistance -= kMovementNibbleToDistance[getMovementNibble(intermediatePosition, nextNewPosition)]; intermediatePosition = nextNewPosition; this->spriteYaw = moveData.yaw; this->spritePitch = moveData.pitch; } if (hasMoved) { Ui::ViewportManager::invalidate(this, ZoomLevel::eighth); this->moveTo(intermediatePosition); Ui::ViewportManager::invalidate(this, ZoomLevel::eighth); } return returnValue; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/Vehicle2.cpp ```cpp #include "MessageManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "Tutorial.h" #include "Vehicle.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; namespace OpenLoco::Vehicles { static loco_global<int32_t, 0x0113612C> _vehicleUpdate_var_113612C; // Speed static loco_global<int32_t, 0x01136130> _vehicleUpdate_var_1136130; // Speed static loco_global<Speed32, 0x01136134> _vehicleUpdate_var_1136134; // Speed static loco_global<VehicleHead*, 0x01136118> _vehicleUpdate_head; constexpr const uint8_t kBrakeLightTimeout = 7; // values are pre *256 for maths // Lateral force due to gravity due to Pitch possibly SIN(angle) * 256 * 256 static constexpr std::array<int32_t, 13> _500170{ 0, -6645, -13223, -19182, -24963, 6645, 13223, 19182, 24963, -11290, 11290, -21628, 21628, }; // 0x004A9BA0 static bool shouldStartWheelSlipping(const Vehicle& train, VehicleBogie& frontBogie) { const auto* vehObject = ObjectManager::get<VehicleObject>(frontBogie.objectId); if (!vehObject->hasFlags(VehicleObjectFlags::canWheelslip) || vehObject->power == 0) { return false; } if (train.head->status != Status::travelling) { return false; } if (train.veh2->motorState == MotorState::coasting || train.veh2->currentSpeed > 10.0_mph) { return false; } // Only start wheel slipping if it is not wheel slipping already if (frontBogie.wheelSlipping != 0) { return false; } if (Tutorial::state() != Tutorial::State::none) { return false; } if (train.head->hasVehicleFlags(VehicleFlags::manualControl) && train.head->manualPower <= 10) { return false; } const auto tot1 = 128ULL * vehObject->power * train.veh2->totalWeight; const auto tot2 = frontBogie.totalCarWeight * train.veh2->totalPower; auto fraction = tot2 == 0 ? tot1 : tot1 / tot2; fraction = std::min(fraction, 2'000ULL); if (fraction < static_cast<uint16_t>(gPrng1().randNext(0xFFFF))) { return false; } if (frontBogie.mode == TransportMode::rail) { const auto* trackObj = ObjectManager::get<TrackObject>(frontBogie.trackType); if (trackObj->hasFlags(TrackObjectFlags::unk_01)) { return false; } if (trackObj->hasFlags(TrackObjectFlags::unk_00)) { if (frontBogie.isOnRackRail()) { return false; } } } else { if (frontBogie.trackType == 0xFF) { return false; } const auto* roadObj = ObjectManager::get<RoadObject>(frontBogie.trackType); if (roadObj->hasFlags(RoadObjectFlags::unk_04)) { return false; } if (roadObj->hasFlags(RoadObjectFlags::unk_05)) { if (frontBogie.isOnRackRail()) { return false; } } } return true; } bool Vehicle2::has73Flags(Flags73 flagsToTest) const { return (var_73 & flagsToTest) != Flags73::none; } // 0x004A9B0B bool Vehicle2::update() { if (mode == TransportMode::air || mode == TransportMode::water) { return true; } motorState = MotorState::accelerating; const auto speedDiff = currentSpeed - *_vehicleUpdate_var_1136134; if (speedDiff > 0.0_mph) { motorState = MotorState::braking; const auto newSpeed = currentSpeed - (currentSpeed / 64 + 0.18311_mph); currentSpeed = std::max(newSpeed, std::max(*_vehicleUpdate_var_1136134, 5.0_mph)); return sub_4A9F20(); } if (!(*_vehicleUpdate_head)->hasVehicleFlags(VehicleFlags::manualControl)) { if (speedDiff >= -1.5_mph) { motorState = MotorState::coasting; } if (currentSpeed == 0.0_mph) { motorState = MotorState::stopped; } } Vehicle train(head); train.cars.applyToComponents([](auto& component) { // If the vehicle is wheel slipping, then its wheel slipping value is incremented. if (component.wheelSlipping != 0) { component.wheelSlipping++; if (component.wheelSlipping >= kWheelSlippingDuration) { component.wheelSlipping = 0; } } }); bool isOnRackRail = true; // Note has been inverted bool isWheelSlipping = false; int32_t ebp = 0; for (auto& car : train.cars) { auto* frontBogie = car.front; if (shouldStartWheelSlipping(train, *frontBogie)) { car.applyToComponents([](auto& component) { component.wheelSlipping = 1; }); } if (frontBogie->wheelSlipping != 0) { isWheelSlipping = true; } if (_500170[enumValue(frontBogie->spritePitch)] <= -19182) { const auto* vehObject = ObjectManager::get<VehicleObject>(frontBogie->objectId); if (vehObject->power != 0) { isOnRackRail &= frontBogie->isOnRackRail(); } } ebp += (frontBogie->totalCarWeight * _500170[enumValue(frontBogie->spritePitch)]) >> 8; } if (!isOnRackRail) { ebp /= 2; if (!train.head->hasVehicleFlags(VehicleFlags::unk_0)) { motorState = MotorState::stoppedOnIncline; if (currentSpeed <= 3.0_mph && train.head->owner == CompanyManager::getControllingId()) { MessageManager::post(MessageType::vehicleSlipped, train.head->owner, enumValue(train.head->id), 0xFFFF); } } } if (isOnRackRail && !isWheelSlipping) { // calculating power when it's broken down const auto power = has73Flags(Flags73::isBrokenDown) ? totalPower / 4 : totalPower; if (train.head->hasVehicleFlags(VehicleFlags::manualControl)) { const auto manualSpeed = train.head->manualPower; if (manualSpeed < 0) { if (manualSpeed <= -10) { motorState = MotorState::braking; } else { motorState = MotorState::coasting; } } else { if (manualSpeed >= 10) { motorState = MotorState::accelerating; } else { motorState = MotorState::coasting; } } ebp += ((power * 2048) * manualSpeed) / (totalWeight * 40); } else { ebp += (power * 2048) / totalWeight; } } const auto speedSquare = toSpeed16(currentSpeed).getRaw() * toSpeed16(currentSpeed).getRaw(); ebp -= speedSquare; auto speedAdjustment = std::min(Speed32(ebp), 0.5_mph); // Vanilla did some funky maths that interpreted signed speeds as unsigned // to behave similar we will set the speedAdjustment to 0.5_mph when negative speed if (currentSpeed < 0.0_mph) { speedAdjustment = 0.5_mph; } auto newSpeed = speedAdjustment + currentSpeed; if (speedAdjustment < 0.0_mph) { auto minSpeed = 5.0_mph; if (train.head->hasVehicleFlags(VehicleFlags::manualControl) || !isOnRackRail) { minSpeed = 0.0_mph; } if (currentSpeed >= minSpeed) { newSpeed = std::max(newSpeed, minSpeed); } } if (!train.head->hasVehicleFlags(VehicleFlags::manualControl)) { // Vanilla did some funky maths that interpreted signed speeds as unsigned // to behave similar we always take the vehicleUpdate_var_1136134 on negative speed if (newSpeed < 0.0_mph) { newSpeed = *_vehicleUpdate_var_1136134; } else { newSpeed = std::min(newSpeed, *_vehicleUpdate_var_1136134); } } currentSpeed = newSpeed; return sub_4A9F20(); } // 0x004A9F20 bool Vehicle2::sub_4A9F20() { Vehicle train(head); resetUpdateVar1136114Flags(); setUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m15); auto res = updateTrackMotion(_vehicleUpdate_var_113612C); _vehicleUpdate_var_113612C = _vehicleUpdate_var_113612C - res; _vehicleUpdate_var_1136130 = _vehicleUpdate_var_1136130 - res; if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound)) { destroyTrain(); return false; } if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00)) { if (!train.head->hasVehicleFlags(VehicleFlags::manualControl)) { currentSpeed = 0.0_mph; motorState = MotorState::stopped; } } if (motorState == MotorState::stoppedOnIncline) { _vehicleUpdate_var_1136130 = _vehicleUpdate_var_113612C + 0x1388; } train.head->var_3C -= _vehicleUpdate_var_113612C; train.veh1->var_3C -= _vehicleUpdate_var_113612C; if (motorState == MotorState::braking) { if (brakeLightTimeout == 0) { invalidateSprite(); train.veh1->invalidateSprite(); train.tail->invalidateSprite(); train.cars.applyToComponents([](auto& component) { component.invalidateSprite(); }); } brakeLightTimeout = kBrakeLightTimeout; return true; } else { if (brakeLightTimeout == 0) { return true; } brakeLightTimeout--; if (brakeLightTimeout == 0) { invalidateSprite(); train.veh1->invalidateSprite(); train.tail->invalidateSprite(); train.cars.applyToComponents([](auto& component) { component.invalidateSprite(); }); } return true; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleBody.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Effects/Effect.h" #include "Effects/ExhaustEffect.h" #include "Entities/EntityManager.h" #include "GameState.h" #include "Graphics/Gfx.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Objects/SteamObject.h" #include "Objects/VehicleObject.h" #include "Random.h" #include "ScenarioManager.h" #include "Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Trigonometry.hpp> #include <cassert> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; namespace OpenLoco::Vehicles { static loco_global<VehicleHead*, 0x01136118> _vehicleUpdate_head; static loco_global<Vehicle2*, 0x01136120> _vehicleUpdate_2; static loco_global<VehicleBogie*, 0x01136124> _vehicleUpdate_frontBogie; static loco_global<VehicleBogie*, 0x01136128> _vehicleUpdate_backBogie; static loco_global<int32_t, 0x01136130> _vehicleUpdate_var_1136130; // Speed static loco_global<bool, 0x01136237> _vehicleUpdate_frontBogieHasMoved; static loco_global<bool, 0x01136238> _vehicleUpdate_backBogieHasMoved; static loco_global<int8_t[88], 0x004F865C> _vehicle_arr_4F865C; // cargoType related? // 0x00503E5C static constexpr Pitch kVehicleBodyIndexToPitch[] = { Pitch::flat, Pitch::up6deg, Pitch::up12deg, Pitch::up18deg, Pitch::up25deg, Pitch::flat, // Not a straight number count Pitch::down6deg, Pitch::down12deg, Pitch::down18deg, Pitch::down25deg, }; const VehicleObject* VehicleBody::getObject() const { return ObjectManager::get<VehicleObject>(objectId); } // 0x004AA1D0 bool VehicleBody::update() { if (mode == TransportMode::air || mode == TransportMode::water) { animationUpdate(); return true; } if (_vehicleUpdate_frontBogieHasMoved || _vehicleUpdate_backBogieHasMoved) { invalidateSprite(); sub_4AC255(_vehicleUpdate_backBogie, _vehicleUpdate_frontBogie); invalidateSprite(); } uint32_t backup1136130 = _vehicleUpdate_var_1136130; if (wheelSlipping != 0) { int32_t var_1136130 = wheelSlipping; if (wheelSlipping > kWheelSlippingDuration / 2) { var_1136130 = kWheelSlippingDuration - var_1136130; } _vehicleUpdate_var_1136130 += var_1136130 * 320 + 500; } animationUpdate(); sub_4AAB0B(); _vehicleUpdate_var_1136130 = backup1136130; return true; } // 0x004AAC4E void VehicleBody::animationUpdate() { if (has38Flags(Flags38::isGhost)) { return; } VehicleHead* headVeh = _vehicleUpdate_head; if ((headVeh->status == Status::crashed) || (headVeh->status == Status::stuck)) { return; } const auto* vehicleObject = getObject(); int32_t emitterHorizontalPos = vehicleObject->carComponents[bodyIndex].emitterHorizontalPos; if (emitterHorizontalPos == 0) { return; } emitterHorizontalPos -= 0x80; switch (vehicleObject->animation[0].type) { case EmitterAnimationType::none: break; case EmitterAnimationType::steam_puff1: case EmitterAnimationType::steam_puff2: case EmitterAnimationType::steam_puff3: steamPuffsAnimationUpdate(0, emitterHorizontalPos); break; case EmitterAnimationType::diesel_exhaust1: dieselExhaust1AnimationUpdate(0, emitterHorizontalPos); break; case EmitterAnimationType::electric_spark1: electricSpark1AnimationUpdate(0, emitterHorizontalPos); break; case EmitterAnimationType::electric_spark2: electricSpark2AnimationUpdate(0, emitterHorizontalPos); break; case EmitterAnimationType::diesel_exhaust2: dieselExhaust2AnimationUpdate(0, emitterHorizontalPos); break; case EmitterAnimationType::ship_wake: shipWakeAnimationUpdate(0, emitterHorizontalPos); break; default: assert(false); break; } secondaryAnimationUpdate(); } // 0x004AA904 void VehicleBody::updateSegmentCrashed() { invalidateSprite(); sub_4AC255(_vehicleUpdate_backBogie, _vehicleUpdate_frontBogie); invalidateSprite(); animationUpdate(); sub_4AAB0B(); if (!hasVehicleFlags(VehicleFlags::unk_5)) { VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; VehicleBogie* backBogie = _vehicleUpdate_backBogie; if (frontBogie->hasVehicleFlags(VehicleFlags::unk_5) || backBogie->hasVehicleFlags(VehicleFlags::unk_5)) { explodeComponent(); this->vehicleFlags |= VehicleFlags::unk_5; } } } // 0x004AAB0B void VehicleBody::sub_4AAB0B() { int32_t eax = _vehicleUpdate_var_1136130 >> 3; if (has38Flags(Flags38::isReversed)) { eax = -eax; } var_44 += eax & 0xFFFF; if (objectSpriteType == 0xFF) { return; } const auto* vehicleObj = getObject(); uint8_t targetAnimationFrame = 0; if (vehicleObj->bodySprites[objectSpriteType].hasFlags(BodySpriteFlags::hasSpeedAnimation)) { Vehicle2* veh3 = _vehicleUpdate_2; targetAnimationFrame = veh3->currentSpeed / (vehicleObj->speed / vehicleObj->bodySprites[objectSpriteType].numAnimationFrames); targetAnimationFrame = std::min<uint8_t>(targetAnimationFrame, vehicleObj->bodySprites[objectSpriteType].numAnimationFrames - 1); } else if (vehicleObj->bodySprites[objectSpriteType].numRollFrames != 1) { VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; Vehicle2* veh3 = _vehicleUpdate_2; targetAnimationFrame = animationFrame; int8_t targetTiltFrame = 0; if (veh3->currentSpeed < 35.0_mph) { targetTiltFrame = 0; } else { targetTiltFrame = _vehicle_arr_4F865C[frontBogie->trackAndDirection.track._data >> 2]; // S-bend if ((frontBogie->trackAndDirection.track.id() == 12) || (frontBogie->trackAndDirection.track.id() == 13)) { if (frontBogie->subPosition >= 48) { targetTiltFrame = -targetTiltFrame; } } if (targetTiltFrame < 0) { if (has38Flags(Flags38::isReversed)) { targetTiltFrame = 2; if (targetAnimationFrame != 0 && targetAnimationFrame != targetTiltFrame) { targetTiltFrame = 0; } } else { targetTiltFrame = 1; if (targetAnimationFrame != 0 && targetAnimationFrame != targetTiltFrame) { targetTiltFrame = 0; } } } else if (targetTiltFrame > 0) { if (has38Flags(Flags38::isReversed)) { targetTiltFrame = 1; if (targetAnimationFrame != 0 && targetAnimationFrame != targetTiltFrame) { targetTiltFrame = 0; } } else { targetTiltFrame = 2; if (targetAnimationFrame != 0 && targetAnimationFrame != targetTiltFrame) { targetTiltFrame = 0; } } } else { targetTiltFrame = 0; } } targetAnimationFrame = targetTiltFrame; } else { targetAnimationFrame = (var_44 >> 12) & (vehicleObj->bodySprites[objectSpriteType].numAnimationFrames - 1); } if (animationFrame != targetAnimationFrame) { animationFrame = targetAnimationFrame; invalidateSprite(); } } static uint8_t calculateYaw2FromVector(int16_t xDiff, int16_t yDiff); static uint8_t calculateYaw3FromVector(int16_t xDiff, int16_t yDiff); // 0x004AC255 void VehicleBody::sub_4AC255(VehicleBogie* back_bogie, VehicleBogie* front_bogie) { auto midPoint = (front_bogie->position + back_bogie->position) / 2; moveTo(midPoint); if (objectSpriteType == 0xFF) { return; } auto bogieDifference = front_bogie->position - back_bogie->position; auto distanceBetweenBogies = Math::Vector::distance2D(front_bogie->position, back_bogie->position); const auto* vehObj = getObject(); if (vehObj->bodySprites[objectSpriteType].hasFlags(BodySpriteFlags::hasSteepSprites)) { spritePitch = updateSpritePitchSteepSlopes(distanceBetweenBogies, bogieDifference.z); } else { spritePitch = updateSpritePitch(distanceBetweenBogies, bogieDifference.z); } // If the sprite_pitch is a transition there is always 4 bits for yaw if (static_cast<uint8_t>(spritePitch) & 1) { spriteYaw = calculateYaw1FromVector(bogieDifference.x, bogieDifference.y); } else { auto sprite = vehObj->bodySprites[objectSpriteType]; uint8_t i = spritePitch == Pitch::flat ? sprite.flatYawAccuracy : sprite.slopedYawAccuracy; switch (i) { case 0: spriteYaw = calculateYaw0FromVector(bogieDifference.x, bogieDifference.y); break; case 1: spriteYaw = calculateYaw1FromVector(bogieDifference.x, bogieDifference.y); break; case 2: spriteYaw = calculateYaw2FromVector(bogieDifference.x, bogieDifference.y); break; case 3: spriteYaw = calculateYaw3FromVector(bogieDifference.x, bogieDifference.y); break; case 4: spriteYaw = calculateYaw4FromVector(bogieDifference.x, bogieDifference.y); break; } } } // 0x004BF4DA Pitch VehicleBody::updateSpritePitchSteepSlopes(uint16_t xyOffset, int16_t zOffset) { uint32_t i = 0; if (zOffset < 0) { i = 5; zOffset = -zOffset; } uint32_t xyz = std::numeric_limits<uint32_t>::max(); if (xyOffset != 0) { xyz = (static_cast<uint64_t>(zOffset) << 16) / xyOffset; } if (xyz > 10064) { i += 2; if (xyz >= 20500) { i++; if (xyz >= 22000) { i++; } } } else { if (xyz >= 3331) { i++; } } return kVehicleBodyIndexToPitch[i]; } // 0x004BF49D Pitch VehicleBody::updateSpritePitch(uint16_t xyOffset, int16_t zOffset) { uint32_t i = 0; if (zOffset < 0) { i = 5; zOffset = -zOffset; } uint32_t xyz = std::numeric_limits<uint32_t>::max(); if (xyOffset != 0) { xyz = (static_cast<uint64_t>(zOffset) << 16) / xyOffset; } if (xyz >= 3331) { i++; if (xyz >= 9000) { i++; } } return kVehicleBodyIndexToPitch[i]; } // 0x004BF52B For yaw of 3 bits uint8_t calculateYaw0FromVector(int16_t xDiff, int16_t yDiff) { uint32_t i = 0; if (xDiff < 0) { i += 2; xDiff = -xDiff; } if (yDiff < 0) { i += 4; yDiff = -yDiff; } uint32_t xy = std::numeric_limits<uint32_t>::max(); if (yDiff != 0) { xy = (static_cast<uint64_t>(xDiff) << 16) / yDiff; } if (xy >= 65536) { i++; } // 0x00503E66 constexpr uint8_t kIndexToYaw[] = { 16, 32, 16, 0, 48, 32, 48, 0 }; return kIndexToYaw[i]; } // 0x004BF56B For yaw of 3 bits (special plane version) uint8_t calculateYaw1FromVectorPlane(int16_t xDiff, int16_t yDiff) { uint32_t i = 0; if (xDiff < 0) { i += 3; xDiff = -xDiff; } if (yDiff < 0) { i += 6; yDiff = -yDiff; } uint32_t xy = std::numeric_limits<uint32_t>::max(); if (yDiff != 0) { xy = (static_cast<uint64_t>(xDiff) << 16) / yDiff; } if (xy >= 3434) { i++; if (xy >= 1250501) { i++; } } // 0x00503E6E constexpr uint8_t kIndexToYaw[] = { 16, 24, 32, 16, 8, 0, 48, 40, 32, 48, 56, 0 }; return kIndexToYaw[i]; } // 0x004BF5B3 For yaw of 4 bits uint8_t calculateYaw1FromVector(int16_t xDiff, int16_t yDiff) { uint32_t i = 0; if (xDiff < 0) { i += 3; xDiff = -xDiff; } if (yDiff < 0) { i += 6; yDiff = -yDiff; } uint32_t xy = std::numeric_limits<uint32_t>::max(); if (yDiff != 0) { xy = (static_cast<uint64_t>(xDiff) << 16) / yDiff; } if (xy >= 27146) { i++; if (xy >= 158218) { i++; } } // 0x00503E6E constexpr uint8_t kIndexToYaw[] = { 16, 24, 32, 16, 8, 0, 48, 40, 32, 48, 56, 0 }; return kIndexToYaw[i]; } // 0x004BF5FB For yaw of 5 bits static uint8_t calculateYaw2FromVector(int16_t xDiff, int16_t yDiff) { uint32_t i = 0; if (xDiff < 0) { i += 5; xDiff = -xDiff; } if (yDiff < 0) { i += 10; yDiff = -yDiff; } uint32_t xy = std::numeric_limits<uint32_t>::max(); if (yDiff != 0) { xy = (static_cast<uint64_t>(xDiff) << 16) / yDiff; } if (xy >= 43790) { i += 2; if (xy >= 98082) { i++; if (xy >= 329472) { i++; } } } else { if (xy >= 13036) { i++; } } // 0x00503E7A constexpr uint8_t kIndexToYaw[] = { 16, 20, 24, 28, 32, 16, 12, 8, 4, 0, 48, 44, 40, 36, 32, 48, 52, 56, 60, 0 }; return kIndexToYaw[i]; } // 0x004BF657 For yaw of 6 bits static uint8_t calculateYaw3FromVector(int16_t xDiff, int16_t yDiff) { uint32_t i = 0; if (xDiff < 0) { i += 9; xDiff = -xDiff; } if (yDiff < 0) { i += 18; yDiff = -yDiff; } uint32_t xy = std::numeric_limits<uint32_t>::max(); if (yDiff != 0) { xy = (static_cast<uint64_t>(xDiff) << 16) / yDiff; } if (xy >= 79856) { if (xy >= 216043) { i += 7; if (xy >= 665398) { i++; } } else { i += 5; if (xy >= 122609) { i++; } } } else { if (xy >= 19880) { if (xy >= 35030) { i += 3; if (xy >= 53784) { i++; } } else { i += 2; } } else { if (xy >= 6455) { i++; } } } // 0x00503E8E constexpr uint8_t kIndexToYaw[] = { 16, 18, 20, 22, 24, 26, 28, 30, 32, 16, 14, 12, 10, 8, 6, 4, 2, 0, 48, 46, 44, 42, 40, 38, 36, 34, 32, 48, 50, 52, 54, 56, 58, 60, 62, 0 }; return kIndexToYaw[i]; } // 0x004BF6DF For yaw of 7 bits uint8_t calculateYaw4FromVector(int16_t xDiff, int16_t yDiff) { uint32_t i = 0; if (xDiff < 0) { i += 17; xDiff = -xDiff; } if (yDiff < 0) { i += 34; yDiff = -yDiff; } uint32_t xy = std::numeric_limits<uint32_t>::max(); if (yDiff != 0) { xy = (static_cast<uint64_t>(xDiff) << 16) / yDiff; } if (xy >= 72308) { if (xy >= 183161) { if (xy >= 441808) { i += 15; if (xy >= 1334016) { i++; } } else { i += 13; if (xy >= 261634) { i++; } } } else { if (xy >= 109340) { i += 11; if (xy >= 138564) { i++; } } else { i += 9; if (xy >= 88365) { i++; } } } } else { if (xy >= 23449) { if (xy >= 39281) { i += 6; if (xy >= 48605) { i++; if (xy >= 59398) { i++; } } } else { i += 4; if (xy >= 30996) { i++; } } } else { if (xy >= 9721) { i += 2; if (xy >= 16416) { i++; } } else { if (xy >= 3220) { i++; } } } } // 0x00503EB2 constexpr uint8_t kIndexToYaw[] = { 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0 }; return kIndexToYaw[i]; } // 0x004AB655 void VehicleBody::secondaryAnimationUpdate() { const auto* vehicleObject = getObject(); uint8_t emitterHorizontalPos = vehicleObject->carComponents[bodyIndex].emitterHorizontalPos; if (emitterHorizontalPos == 0) { return; } emitterHorizontalPos -= 0x80; switch (vehicleObject->animation[1].type) { case EmitterAnimationType::none: return; case EmitterAnimationType::steam_puff1: case EmitterAnimationType::steam_puff2: case EmitterAnimationType::steam_puff3: steamPuffsAnimationUpdate(1, emitterHorizontalPos); break; case EmitterAnimationType::diesel_exhaust1: dieselExhaust1AnimationUpdate(1, emitterHorizontalPos); break; case EmitterAnimationType::electric_spark1: electricSpark1AnimationUpdate(1, emitterHorizontalPos); break; case EmitterAnimationType::electric_spark2: electricSpark2AnimationUpdate(1, emitterHorizontalPos); break; case EmitterAnimationType::diesel_exhaust2: dieselExhaust2AnimationUpdate(1, emitterHorizontalPos); break; case EmitterAnimationType::ship_wake: shipWakeAnimationUpdate(1, emitterHorizontalPos); break; default: assert(false); break; } } // 0x004AB688, 0x004AACA5 void VehicleBody::steamPuffsAnimationUpdate(uint8_t num, int32_t emitterHorizontalPos) { const auto* vehicleObject = getObject(); VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; VehicleBogie* backBogie = _vehicleUpdate_backBogie; if (frontBogie->hasBreakdownFlags(BreakdownFlags::brokenDown)) { return; } Vehicle2* veh_2 = _vehicleUpdate_2; bool soundCode = false; if (veh_2->motorState == MotorState::accelerating || veh_2->motorState == MotorState::stoppedOnIncline) { soundCode = true; } bool tickCalc = true; if (veh_2->motorState != MotorState::stopped && veh_2->currentSpeed >= 1.0_mph) { tickCalc = false; } auto _var_44 = var_44; // Reversing if (has38Flags(Flags38::isReversed)) { emitterHorizontalPos = -emitterHorizontalPos; _var_44 = -_var_44; } if (tickCalc && (soundCode == false)) { if (ScenarioManager::getScenarioTicks() & 7) { return; } } else { if (_vehicleUpdate_var_1136130 + (uint16_t)(_var_44 * 8) < std::numeric_limits<uint16_t>::max()) { return; } } emitterHorizontalPos += 64; auto xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->animation[num].emitterVerticalPos, spritePitch, spriteYaw); auto bogieDifference = backBogie->position - frontBogie->position; auto smokeLoc = bogieDifference * emitterHorizontalPos / 128 + frontBogie->position + World::Pos3(xyFactor.x, xyFactor.y, vehicleObject->animation[num].emitterVerticalPos); Exhaust::create(smokeLoc, vehicleObject->animation[num].objectId | (soundCode ? 0 : 0x80)); if (soundCode == false) { return; } chuffSoundIndex++; const SteamObject* steamObj = ObjectManager::get<SteamObject>(vehicleObject->animation[num].objectId); if (chuffSoundIndex >= ((uint8_t)vehicleObject->animation[num].type) + 1) { chuffSoundIndex = 0; } if (veh_2->currentSpeed > 15.0_mph) { return; } bool stationFound = false; // play tunnel sounds if the locomotive is in a station below a bridge if (steamObj->hasFlags(SteamObjectFlags::hasTunnelSounds)) { auto tile = World::TileManager::get(frontBogie->tileX, frontBogie->tileY); for (auto& el : tile) { if (stationFound && !(el.isGhost() || el.isAiAllocated())) { break; } else { stationFound = false; } auto* track = el.as<World::TrackElement>(); if (track == nullptr) { continue; } if (track->baseZ() != frontBogie->tileBaseZ) { continue; } if (track->trackId() != frontBogie->trackAndDirection.track.id()) { continue; } if (track->rotation() != frontBogie->trackAndDirection.track.cardinalDirection()) { continue; } if (!track->hasStationElement()) { continue; } if (!track->isLast()) { stationFound = true; } } } if (stationFound) { auto soundId = steamObj->soundEffects[chuffSoundIndex + (steamObj->numSoundEffects / 2)]; int32_t volume = 0 - (veh_2->currentSpeed.getRaw() >> 9); auto height = World::TileManager::getHeight(smokeLoc).landHeight; if (smokeLoc.z <= height) { volume -= 1500; } Audio::playSound(Audio::makeObjectSoundId(soundId), smokeLoc, volume, 22050); } else { auto soundModifier = steamObj->numSoundEffects / 2; if (!steamObj->hasFlags(SteamObjectFlags::hasTunnelSounds)) { soundModifier = 0; } auto underSoundId = steamObj->soundEffects[soundModifier + chuffSoundIndex]; auto soundId = steamObj->soundEffects[chuffSoundIndex]; int32_t volume = 0 - (veh_2->currentSpeed.getRaw() >> 9); auto height = World::TileManager::getHeight(smokeLoc).landHeight; if (smokeLoc.z <= height) { soundId = underSoundId; volume -= 1500; } if (volume > -400) { volume = -400; } Audio::playSound(Audio::makeObjectSoundId(soundId), smokeLoc, volume, 22050); } } // 0x004AB9DD & 0x004AAFFA void VehicleBody::dieselExhaust1AnimationUpdate(uint8_t num, int32_t emitterHorizontalPos) { VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; VehicleBogie* backBogie = _vehicleUpdate_backBogie; if (frontBogie->hasBreakdownFlags(BreakdownFlags::brokenDown)) { return; } VehicleHead* headVeh = _vehicleUpdate_head; Vehicle2* veh_2 = _vehicleUpdate_2; const auto* vehicleObject = getObject(); if (headVeh->vehicleType == VehicleType::ship) { if (veh_2->currentSpeed == 0.0_mph) { return; } if (has38Flags(Flags38::isReversed)) { emitterHorizontalPos = -emitterHorizontalPos; } if (ScenarioManager::getScenarioTicks() & 3) { return; } auto positionFactor = vehicleObject->bodySprites[0].halfLength * emitterHorizontalPos / 256; auto invertedDirection = spriteYaw ^ (1 << 5); auto xyFactor = Math::Trigonometry::computeXYVector(positionFactor, invertedDirection) / 2; World::Pos3 loc = position + World::Pos3(xyFactor.x, xyFactor.y, vehicleObject->animation[num].emitterVerticalPos); Exhaust::create(loc, vehicleObject->animation[num].objectId); } else { if (veh_2->motorState != MotorState::accelerating) { return; } if (has38Flags(Flags38::isReversed)) { emitterHorizontalPos = -emitterHorizontalPos; } if (ScenarioManager::getScenarioTicks() & 3) { return; } if (wheelSlipping != 0) { return; } emitterHorizontalPos += 64; auto bogieDifference = backBogie->position - frontBogie->position; auto xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->animation[num].emitterVerticalPos, spritePitch, spriteYaw); auto loc = bogieDifference * emitterHorizontalPos / 128 + frontBogie->position + World::Pos3(xyFactor.x, xyFactor.y, vehicleObject->animation[num].emitterVerticalPos); Exhaust::create(loc, vehicleObject->animation[num].objectId); } } // 0x004ABB5A & 0x004AB177 void VehicleBody::dieselExhaust2AnimationUpdate(uint8_t num, int32_t emitterHorizontalPos) { VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; VehicleBogie* backBogie = _vehicleUpdate_backBogie; if (frontBogie->hasBreakdownFlags(BreakdownFlags::brokenDown)) { return; } Vehicle2* veh_2 = _vehicleUpdate_2; const auto* vehicleObject = getObject(); if (veh_2->motorState != MotorState::accelerating) { return; } if (veh_2->currentSpeed > 14.0_mph) { return; } if (has38Flags(Flags38::isReversed)) { emitterHorizontalPos = -emitterHorizontalPos; } if (ScenarioManager::getScenarioTicks() & 7) { return; } emitterHorizontalPos += 64; auto bogieDifference = backBogie->position - frontBogie->position; auto xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->animation[num].emitterVerticalPos, spritePitch, spriteYaw); auto loc = bogieDifference * emitterHorizontalPos / 128 + frontBogie->position + World::Pos3(xyFactor.x, xyFactor.y, vehicleObject->animation[num].emitterVerticalPos); // 90 degrees C.W. auto yaw = (spriteYaw + 16) & 0x3F; auto unkFactor = 5; if (getGameState().trafficHandedness != 0) { unkFactor = -5; } xyFactor = Math::Trigonometry::computeXYVector(unkFactor, yaw); loc.x += xyFactor.x; loc.y += xyFactor.y; Exhaust::create(loc, vehicleObject->animation[num].objectId); } // 0x004ABDAD & 0x004AB3CA void VehicleBody::electricSpark1AnimationUpdate(uint8_t num, int32_t emitterHorizontalPos) { VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; VehicleBogie* backBogie = _vehicleUpdate_backBogie; if (frontBogie->hasBreakdownFlags(BreakdownFlags::brokenDown)) { return; } Vehicle2* veh_2 = _vehicleUpdate_2; const auto* vehicleObject = getObject(); if (veh_2->motorState != MotorState::coasting && veh_2->motorState != MotorState::accelerating) { return; } auto _var_44 = var_44; if (has38Flags(Flags38::isReversed)) { emitterHorizontalPos = -emitterHorizontalPos; _var_44 = -var_44; } if (((uint16_t)_vehicleUpdate_var_1136130) + ((uint16_t)_var_44 * 8) < std::numeric_limits<uint16_t>::max()) { return; } emitterHorizontalPos += 64; if (gPrng1().randNext(std::numeric_limits<uint16_t>::max()) > 819) { return; } auto bogieDifference = backBogie->position - frontBogie->position; auto xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->animation[num].emitterVerticalPos, spritePitch, spriteYaw); auto loc = bogieDifference * emitterHorizontalPos / 128 + frontBogie->position + World::Pos3(xyFactor.x, xyFactor.y, vehicleObject->animation[num].emitterVerticalPos); Exhaust::create(loc, vehicleObject->animation[num].objectId); } // 0x004ABEC3 & 0x004AB4E0 void VehicleBody::electricSpark2AnimationUpdate(uint8_t num, int32_t emitterHorizontalPos) { VehicleBogie* frontBogie = _vehicleUpdate_frontBogie; VehicleBogie* backBogie = _vehicleUpdate_backBogie; if (frontBogie->hasBreakdownFlags(BreakdownFlags::brokenDown)) { return; } Vehicle2* veh_2 = _vehicleUpdate_2; const auto* vehicleObject = getObject(); if (veh_2->motorState != MotorState::coasting && veh_2->motorState != MotorState::accelerating) { return; } auto _var_44 = var_44; if (has38Flags(Flags38::isReversed)) { emitterHorizontalPos = -emitterHorizontalPos; _var_44 = -var_44; } if (((uint16_t)_vehicleUpdate_var_1136130) + ((uint16_t)_var_44 * 8) < std::numeric_limits<uint16_t>::max()) { return; } emitterHorizontalPos += 64; if (gPrng1().randNext(std::numeric_limits<uint16_t>::max()) > 936) { return; } auto bogieDifference = backBogie->position - frontBogie->position; auto xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->animation[num].emitterVerticalPos, spritePitch, spriteYaw); auto loc = bogieDifference * emitterHorizontalPos / 128 + frontBogie->position + World::Pos3(xyFactor.x, xyFactor.y, vehicleObject->animation[num].emitterVerticalPos); // 90 degrees C.W. auto yaw = (spriteYaw + 16) & 0x3F; auto firstBogie = has38Flags(Flags38::isReversed) ? backBogie : frontBogie; auto unkFactor = 5; if (!World::TrackData::getTrackMiscData(firstBogie->trackAndDirection.road._data >> 3).sparkDirection) { unkFactor = -5; } if (firstBogie->trackAndDirection.road.isReversed()) { unkFactor = -unkFactor; } xyFactor = Math::Trigonometry::computeXYVector(unkFactor, yaw); loc.x += xyFactor.x; loc.y += xyFactor.y; Exhaust::create(loc, vehicleObject->animation[num].objectId); } // 0x004ABC8A & 0x004AB2A7 void VehicleBody::shipWakeAnimationUpdate(uint8_t num, int32_t) { Vehicle2* veh_2 = _vehicleUpdate_2; const auto* vehicleObject = getObject(); if (veh_2->motorState == MotorState::stopped) { return; } if (veh_2->currentSpeed < 6.0_mph) { return; } auto frequency = 32; if (veh_2->currentSpeed >= 9.0_mph) { frequency = 16; if (veh_2->currentSpeed >= 13.0_mph) { frequency = 8; if (veh_2->currentSpeed >= 25.0_mph) { frequency = 4; } } } if ((ScenarioManager::getScenarioTicks() % frequency) != 0) { return; } auto positionFactor = vehicleObject->bodySprites[0].halfLength; auto invertedDirection = spriteYaw ^ (1 << 5); auto xyFactor = Math::Trigonometry::computeXYVector(positionFactor, invertedDirection) / 4; World::Pos3 loc = position + World::Pos3(xyFactor.x, xyFactor.y, 0); // 90 degrees C.W. auto yaw = (spriteYaw + 16) & 0x3F; xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->shipWakeSpacing, yaw) / 2; loc.x += xyFactor.x; loc.y += xyFactor.y; Exhaust::create(loc, vehicleObject->animation[num].objectId); if (vehicleObject->shipWakeSpacing == 0) { return; } // 90 degrees C.C.W. yaw = (spriteYaw - 16) & 0x3F; xyFactor = Math::Trigonometry::computeXYVector(vehicleObject->shipWakeSpacing, yaw) / 2; loc.x += xyFactor.x; loc.y += xyFactor.y; Exhaust::create(loc, vehicleObject->animation[num].objectId); } // 0x004AC039 // Note: Vanilla often called this from bogies which would // just return immediately void VehicleBody::updateCargoSprite() { if (objectSpriteType == 0xFF) { return; } if (primaryCargo.maxQty == 0) { return; } const auto* vehicleObj = getObject(); auto& bodySprite = vehicleObj->bodySprites[objectSpriteType]; auto percentageFull = std::min((primaryCargo.qty * 256) / primaryCargo.maxQty, 255); auto spriteIndex = (percentageFull * bodySprite.numCargoLoadFrames) / 256; if (spriteIndex != 0) { spriteIndex += vehicleObj->cargoTypeSpriteOffsets[primaryCargo.type]; } spriteIndex *= bodySprite.numAnimationFrames; if (spriteIndex != cargoFrame) { cargoFrame = spriteIndex; invalidateSprite(); } } // 0x0042F6B6 // TODO: move this? uint32_t getNumUnitsForCargo(uint32_t maxPrimaryCargo, uint8_t primaryCargoId, uint8_t newCargoId) { auto cargoObjA = ObjectManager::get<CargoObject>(primaryCargoId); auto cargoObjB = ObjectManager::get<CargoObject>(newCargoId); return (cargoObjA->unitSize * maxPrimaryCargo) / cargoObjB->unitSize; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleBogie.cpp ```cpp #include "Effects/ExplosionEffect.h" #include "Effects/SplashEffect.h" #include "Effects/VehicleCrashEffect.h" #include "Entities/EntityManager.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Trigonometry.hpp> #include <cstdint> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; namespace OpenLoco::Vehicles { static loco_global<VehicleBogie*, 0x01136124> _vehicleUpdate_frontBogie; static loco_global<VehicleBogie*, 0x01136128> _vehicleUpdate_backBogie; static loco_global<bool, 0x01136237> _vehicleUpdate_frontBogieHasMoved; // remainingDistance related? static loco_global<bool, 0x01136238> _vehicleUpdate_backBogieHasMoved; // remainingDistance related? static loco_global<int32_t, 0x0113612C> _vehicleUpdate_var_113612C; // Speed static loco_global<int32_t, 0x01136130> _vehicleUpdate_var_1136130; // Speed static loco_global<EntityId, 0x0113610E> _vehicleUpdate_collisionCarComponent; template<typename T> void applyDestructionToComponent(T& component) { component.explodeComponent(); component.var_5A &= ~(1u << 31); component.var_5A >>= 3; component.var_5A |= (1u << 31); } // 0x004AA008 bool VehicleBogie::update() { _vehicleUpdate_frontBogie = _vehicleUpdate_backBogie; _vehicleUpdate_backBogie = this; if (mode == TransportMode::air || mode == TransportMode::water) { return true; } const auto oldPos = position; resetUpdateVar1136114Flags(); updateTrackMotion(_vehicleUpdate_var_113612C); const auto hasMoved = oldPos != position; _vehicleUpdate_backBogieHasMoved = _vehicleUpdate_frontBogieHasMoved; _vehicleUpdate_frontBogieHasMoved = hasMoved; const int32_t stash1136130 = _vehicleUpdate_var_1136130; if (wheelSlipping != 0) { auto unk = wheelSlipping; if (unk > kWheelSlippingDuration / 2) { unk = kWheelSlippingDuration - unk; } _vehicleUpdate_var_1136130 = 500 + unk * 320; } updateRoll(); _vehicleUpdate_var_1136130 = stash1136130; if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound)) { destroyTrain(); return false; } else if (!hasUpdateVar1136114Flags(UpdateVar1136114Flags::crashed)) { return true; } collision(); return false; } // 0x004AAC02 void VehicleBogie::updateRoll() { auto unk = _vehicleUpdate_var_1136130 / 8; if (has38Flags(Flags38::isReversed)) { unk = -unk; } var_44 += unk; if (objectSpriteType != 0xFF) { auto* vehObj = ObjectManager::get<VehicleObject>(objectId); auto& bogieSprites = vehObj->bogieSprites[objectSpriteType]; const auto newAnimationIndex = (bogieSprites.numAnimationFrames - 1) & (var_44 / 4096); if (newAnimationIndex != animationIndex) { animationIndex = newAnimationIndex; invalidateSprite(); } } } // To replace several instances of the same exact code in // VehicleBogie::updateSegmentCrashed(). Returns true if the // vehicle crashed in the process. static bool rotateAndExplodeIfNotAlreadyExploded(VehicleBogie& bogie, bool direction) { const auto slightlyRotated = direction ? 4 : -4; bogie.spriteYaw = (bogie.spriteYaw + slightlyRotated) & 0x3F; // explode, if we haven't already if (!bogie.hasVehicleFlags(VehicleFlags::unk_5)) { bogie.explodeComponent(); bogie.vehicleFlags |= VehicleFlags::unk_5; return true; } else { return false; } } // 0x00462893 static bool checkForTileCollision(const World::Pos3 pos) { const auto xNibble = pos.x & 0x1F; const auto yNibble = pos.y & 0x1F; uint8_t occupiedQuarter = 0U; if (xNibble < 16) { occupiedQuarter = 1U << 2; if (yNibble >= 16) { occupiedQuarter = 1U << 3; } } else { occupiedQuarter = 1U << 0; if (yNibble < 16) { occupiedQuarter = 1U << 1; } } const auto tile = World::TileManager::get(pos); for (auto& el : tile) { if (pos.z < el.baseHeight()) { continue; } if (pos.z >= el.clearHeight()) { continue; } if (el.occupiedQuarter() & occupiedQuarter) { return true; } } return false; } // 0x0004AA959 static bool destroyedBogieCheckForCollision(VehicleBogie& bogie, World::Pos3& pos) { if (checkForTileCollision(pos)) { return true; } return checkForCollisions(bogie, pos) != EntityId::null; } // 0x004AA68E void VehicleBogie::updateSegmentCrashed() { _vehicleUpdate_frontBogie = _vehicleUpdate_backBogie; _vehicleUpdate_backBogie = this; Speed32 speed = Speed32(var_5A & 0x7FFFFFFF); bool isComponentDestroyed = this->var_5A & (1U << 31); speed = speed - (speed / 64); if (speed <= 2.0_mph) { speed = 0.0_mph; } this->var_5A = speed.getRaw() | (isComponentDestroyed ? (1U << 31) : 0); _vehicleUpdate_var_113612C = speed.getRaw() / 128; _vehicleUpdate_var_1136130 = speed.getRaw() / 128; this->updateRoll(); if (isComponentDestroyed) { if (speed >= 1.0_mph) { const auto distanceTravelled = speed.getRaw() / 16; auto xyDistance = Math::Trigonometry::computeXYVector(distanceTravelled, spriteYaw); uint16_t xDistanceLow = xyDistance.x & 0x0000FFFF; uint16_t yDistanceLow = xyDistance.y & 0x0000FFFF; // This is being casted to uint32_t as we want a negative value to round away from zero // this is due to splitting the precision of the distance into two parts World::Pos2 distanceWorld(static_cast<uint32_t>(xyDistance.x) / 65536, static_cast<uint32_t>(xyDistance.y) / 65536); // We are storing the lower precision in tileX and tileY they aren't actually being used as tileX and tileY. // Yay reusing fields for different purposes means we need to be careful with the sign of the type int32_t newTileX = static_cast<uint16_t>(this->tileX) + xDistanceLow; if (newTileX >= 0x00010000) { distanceWorld.x++; } this->tileX = newTileX & 0x0000FFFF; int32_t newTileY = static_cast<uint16_t>(this->tileY) + yDistanceLow; if (newTileY >= 0x00010000) { distanceWorld.y++; } this->tileY = newTileY & 0x0000FFFF; this->tileBaseZ++; int16_t zDistance = this->tileBaseZ / 32; // Calculate new position - but don't update yet!! This is pushed to the stack. World::Pos3 newPosition{ position + World::Pos3(distanceWorld, -zDistance) }; if (!destroyedBogieCheckForCollision(*this, position)) { World::Pos3 positionToTest = { newPosition.x, newPosition.y, this->position.z }; if (destroyedBogieCheckForCollision(*this, positionToTest)) { newPosition.x = this->position.x; newPosition.y = this->position.y; if (speed >= 5.0_mph) { rotateAndExplodeIfNotAlreadyExploded(*this, true); } this->var_5A = ((speed / 2).getRaw() | (1U << 31)); } if (destroyedBogieCheckForCollision(*this, newPosition)) { newPosition.z = this->position.z; if (this->tileBaseZ >= 0x0A) { rotateAndExplodeIfNotAlreadyExploded(*this, false); } this->tileBaseZ = 0; } } const auto newTileHeight = World::TileManager::getHeight(newPosition); if (newTileHeight.landHeight >= this->position.z || newTileHeight.landHeight >= newPosition.z) { if (newTileHeight.landHeight < this->position.z && newTileHeight.landHeight >= newPosition.z) { newPosition.z = this->position.z; this->tileBaseZ = 0; } newPosition.x = this->position.x; newPosition.y = this->position.y; if (speed >= 5.0_mph) { rotateAndExplodeIfNotAlreadyExploded(*this, true); } this->var_5A = ((speed / 2).getRaw() | (1U << 31)); } if (newTileHeight.waterHeight != 0 && newTileHeight.waterHeight < this->position.z && newTileHeight.waterHeight >= newPosition.z) { this->spriteYaw = (this->spriteYaw + 4) & 0x3F; if (!this->hasVehicleFlags(VehicleFlags::unk_5)) { World::Pos3 splashPos{ this->position.x, this->position.y, newTileHeight.waterHeight }; Splash::create(splashPos); Audio::playSound(Audio::SoundId::splash2, splashPos); this->vehicleFlags |= VehicleFlags::unk_5; } } this->moveTo(newPosition); this->invalidateSprite(); } } else { resetUpdateVar1136114Flags(); if (this->mode != TransportMode::road) { this->updateTrackMotion(_vehicleUpdate_var_113612C); if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00 | UpdateVar1136114Flags::noRouteFound)) { this->var_5A |= 1U << 31; } } } } // 0x004AA0DF void VehicleBogie::collision() { destroyTrain(); applyDestructionToComponent(*this); vehicleFlags |= VehicleFlags::unk_5; // Apply collision to the whole car Vehicle train(head); bool end = false; for (auto& car : train.cars) { for (auto& carComponent : car) { if (carComponent.front == this || carComponent.back == this) { applyDestructionToComponent(*carComponent.body); end = true; break; } } if (end) { break; } } // Apply Collision to collided train auto* collideEntity = EntityManager::get<EntityBase>(_vehicleUpdate_collisionCarComponent); auto* collideCarComponent = collideEntity->asBase<VehicleBase>(); if (collideCarComponent != nullptr) { Vehicle collideTrain(collideCarComponent->getHead()); if (collideTrain.head->status != Status::crashed) { collideCarComponent->destroyTrain(); } for (auto& car : train.cars) { for (auto& carComponent : car) { if (carComponent.front == collideCarComponent) { applyDestructionToComponent(*carComponent.front); } if (carComponent.back == collideCarComponent) { applyDestructionToComponent(*carComponent.back); } if (carComponent.front == collideCarComponent || carComponent.back == collideCarComponent || carComponent.body == collideCarComponent) { applyDestructionToComponent(*carComponent.body); return; } } } } } // 0x004AA984 static bool isOnRackRailRail(const VehicleBogie& bogie) { auto* trackObj = ObjectManager::get<TrackObject>(bogie.trackType); if (!trackObj->hasFlags(TrackObjectFlags::unk_00)) { return true; } auto* vehObj = ObjectManager::get<VehicleObject>(bogie.objectId); if (!vehObj->hasFlags(VehicleObjectFlags::rackRail)) { return false; } const auto tile = World::TileManager::get(World::Pos2{ bogie.tileX, bogie.tileY }); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseZ() != bogie.tileBaseZ) { continue; } if (elTrack->rotation() != bogie.trackAndDirection.track.cardinalDirection()) { continue; } if (elTrack->trackId() != bogie.trackAndDirection.track.id()) { continue; } for (auto i = 0; i < 4; ++i) { if (elTrack->hasMod(i) && trackObj->mods[i] == vehObj->rackRailType) { return true; } } } return false; } // 0x004AA50 static bool isOnRackRailRoad(const VehicleBogie& bogie) { if (bogie.trackType == 0xFFU) { return true; } auto* roadObj = ObjectManager::get<RoadObject>(bogie.trackType); if (!roadObj->hasFlags(RoadObjectFlags::unk_05)) { return true; } auto* vehObj = ObjectManager::get<VehicleObject>(bogie.objectId); if (!vehObj->hasFlags(VehicleObjectFlags::rackRail)) { return false; } const auto tile = World::TileManager::get(World::Pos2{ bogie.tileX, bogie.tileY }); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseZ() != bogie.tileBaseZ) { continue; } if (elRoad->rotation() != bogie.trackAndDirection.road.cardinalDirection()) { continue; } if (elRoad->roadId() != bogie.trackAndDirection.road.id()) { continue; } for (auto i = 0; i < 2; ++i) { if (elRoad->hasMod(i) && roadObj->mods[i] == vehObj->rackRailType) { return true; } } } return false; } // 0x004AA97A bool VehicleBogie::isOnRackRail() { if (mode == TransportMode::rail) { return isOnRackRailRail(*this); } else if (mode == TransportMode::road) { return isOnRackRailRoad(*this); } else { assert(false); return false; } } // 0x004BA873 // esi : vehBogie void sub_4BA873(VehicleBogie& vehBogie) { vehBogie.timeoutToBreakdown = 0xFFFF; if (vehBogie.reliability != 0) { int32_t reliabilityFactor = vehBogie.reliability / 256; reliabilityFactor *= reliabilityFactor; reliabilityFactor /= 16; auto& prng = gPrng1(); int32_t randVal = (prng.randNext(65535) * (reliabilityFactor / 2)) / 65536; reliabilityFactor -= reliabilityFactor / 4; reliabilityFactor += randVal; vehBogie.timeoutToBreakdown = static_cast<uint16_t>(std::max(4, reliabilityFactor)); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleDraw.cpp ```cpp #include "VehicleDraw.h" #include "Entities/Entity.h" #include "Graphics/Gfx.h" #include "Graphics/ImageId.h" #include "Graphics/SoftwareDrawingContext.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Map/Tile.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/VehicleObject.h" #include "Vehicle.h" #include "Viewport.hpp" #include "World/CompanyManager.h" #include <OpenLoco/Engine/Ui/Point.hpp> #include <OpenLoco/Math/Trigonometry.hpp> #include <array> #include <sfl/static_vector.hpp> namespace OpenLoco { // 0x00503F20 static constexpr std::array<uint8_t, 8> _503F20{ 4, 3, 2, 1, 0, 0, 0, 0 }; static uint32_t getBodyImageIndexPitchDefault(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (sprite.hasFlags(BodySpriteFlags::rotationalSymmetry)) { yaw &= 0x1F; } uint32_t imageIndex = (yaw >> _503F20[sprite.flatYawAccuracy]) * sprite.numFramesPerRotation; imageIndex += sprite.flatImageId; return imageIndex; } static uint32_t getBodyImageIndexPitchUp12Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasGentleSprites)) { return getBodyImageIndexPitchDefault(sprite, yaw); } auto imageOffset = sprite.hasFlags(BodySpriteFlags::rotationalSymmetry) ? 4 : 8; uint32_t imageIndex = ((yaw >> _503F20[sprite.slopedYawAccuracy]) + imageOffset) * sprite.numFramesPerRotation; imageIndex += sprite.gentleImageId; return imageIndex; } static uint32_t getBodyImageIndexPitchDown12Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasGentleSprites)) { return getBodyImageIndexPitchDefault(sprite, yaw); } if (sprite.hasFlags(BodySpriteFlags::rotationalSymmetry)) { yaw ^= (1 << 5); } else { yaw += (1 << 6); } return getBodyImageIndexPitchUp12Deg(sprite, yaw); } static uint32_t getBodyImageIndexPitchUp6Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasGentleSprites)) { return getBodyImageIndexPitchDefault(sprite, yaw); } yaw += 7; yaw >>= 4; yaw &= 0x3; return yaw * sprite.numFramesPerRotation + sprite.gentleImageId; } static uint32_t getBodyImageIndexPitchDown6Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasGentleSprites)) { return getBodyImageIndexPitchDefault(sprite, yaw); } if (sprite.hasFlags(BodySpriteFlags::rotationalSymmetry)) { yaw ^= (1 << 5); return getBodyImageIndexPitchUp6Deg(sprite, yaw); } else { yaw += 7; yaw >>= 4; yaw &= 0x3; yaw += 4; return yaw * sprite.numFramesPerRotation + sprite.gentleImageId; } } static uint32_t getBodyImageIndexPitchUp25Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasSteepSprites)) { return getBodyImageIndexPitchUp12Deg(sprite, yaw); } auto imageOffset = sprite.hasFlags(BodySpriteFlags::rotationalSymmetry) ? 4 : 8; uint32_t imageIndex = ((yaw >> _503F20[sprite.slopedYawAccuracy]) + imageOffset) * sprite.numFramesPerRotation; imageIndex += sprite.steepImageId; return imageIndex; } static uint32_t getBodyImageIndexPitchDown25Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasSteepSprites)) { return getBodyImageIndexPitchDown12Deg(sprite, yaw); } if (sprite.hasFlags(BodySpriteFlags::rotationalSymmetry)) { yaw ^= (1 << 5); } else { yaw += (1 << 6); } return getBodyImageIndexPitchUp25Deg(sprite, yaw); } static uint32_t getBodyImageIndexPitchUp18Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasSteepSprites)) { return getBodyImageIndexPitchUp12Deg(sprite, yaw); } yaw += 7; yaw >>= 4; yaw &= 0x3; return yaw * sprite.numFramesPerRotation + sprite.steepImageId; } static uint32_t getBodyImageIndexPitchDown18Deg(const VehicleObjectBodySprite& sprite, uint8_t yaw) { if (!sprite.hasFlags(BodySpriteFlags::hasSteepSprites)) { return getBodyImageIndexPitchDown12Deg(sprite, yaw); } if (sprite.hasFlags(BodySpriteFlags::rotationalSymmetry)) { yaw ^= (1 << 5); return getBodyImageIndexPitchUp18Deg(sprite, yaw); } else { yaw += 7; yaw >>= 4; yaw &= 0x3; yaw += 4; return yaw * sprite.numFramesPerRotation + sprite.steepImageId; } } static uint32_t getPitchBodyImageIndex(const VehicleObjectBodySprite& sprite, const Pitch pitch, const uint8_t yaw) { uint32_t pitchImageIndex; switch (pitch) { case Pitch::flat: pitchImageIndex = getBodyImageIndexPitchDefault(sprite, yaw); break; case Pitch::up12deg: pitchImageIndex = getBodyImageIndexPitchUp12Deg(sprite, yaw); break; case Pitch::down12deg: pitchImageIndex = getBodyImageIndexPitchDown12Deg(sprite, yaw); break; case Pitch::up6deg: pitchImageIndex = getBodyImageIndexPitchUp6Deg(sprite, yaw); break; case Pitch::down6deg: pitchImageIndex = getBodyImageIndexPitchDown6Deg(sprite, yaw); break; case Pitch::up25deg: pitchImageIndex = getBodyImageIndexPitchUp25Deg(sprite, yaw); break; case Pitch::down25deg: pitchImageIndex = getBodyImageIndexPitchDown25Deg(sprite, yaw); break; case Pitch::up18deg: pitchImageIndex = getBodyImageIndexPitchUp18Deg(sprite, yaw); break; case Pitch::down18deg: pitchImageIndex = getBodyImageIndexPitchDown18Deg(sprite, yaw); break; default: pitchImageIndex = getBodyImageIndexPitchDefault(sprite, yaw); break; } return pitchImageIndex; } uint32_t getBodyImageIndex(const VehicleObjectBodySprite& sprite, const Pitch pitch, const uint8_t yaw, const uint8_t roll, const uint8_t cargoIndex) { const auto pitchImageIndex = getPitchBodyImageIndex(sprite, pitch, yaw); return pitchImageIndex + roll + cargoIndex; } uint32_t getBrakingImageIndex(const VehicleObjectBodySprite& sprite, const Pitch pitch, const uint8_t yaw) { const auto pitchImageIndex = getPitchBodyImageIndex(sprite, pitch, yaw); // Braking image is the last frame for a rotation return pitchImageIndex + sprite.numFramesPerRotation - 1; } constexpr std::array<uint8_t, 8> kUnk500264 = { 0, 1, 1, 1, 0, 2, 2, 2, }; struct DrawItem { ImageId image; int32_t dist; bool isBody; }; static void drawItem(Gfx::DrawingContext& drawingCtx, Ui::Point offset, const DrawItem& item, int32_t midDist, uint8_t yaw) { const auto factor = midDist - item.dist; const auto unk1 = Math::Trigonometry::computeXYVector(factor, yaw) / 4; const auto p1 = World::gameToScreen(World::Pos3(unk1.x, unk1.y, 0), 0); drawingCtx.drawImage(offset + Ui::Point(p1.x, p1.y), item.image); } struct DrawItems { // Max num items is kMaxBodySprites * (2 bogies + 1 body) sfl::static_vector<DrawItem, VehicleObject::kMaxBodySprites * (2 + 1)> items; int32_t totalDistance; }; static DrawItems getDrawItemsForVehicle(const VehicleObject& vehObject, const uint8_t yaw, const uint8_t roll, const ColourScheme colourScheme) { DrawItems drawItems{}; const auto unk11360E8 = kUnk500264[roll & 0x7]; for (auto i = 0; i < vehObject.numCarComponents; ++i) { if (vehObject.hasFlags(VehicleObjectFlags::jacobsBogieFront) && i == 0) { continue; } if (vehObject.hasFlags(VehicleObjectFlags::jacobsBogieRear) && i + 1 == vehObject.numCarComponents) { continue; } auto& componentObject = vehObject.carComponents[i]; // 0x01136172 auto unkDist = componentObject.frontBogiePosition; if (componentObject.frontBogieSpriteInd != SpriteIndex::null && (vehObject.mode == TransportMode::rail || vehObject.mode == TransportMode::road)) { auto unk = yaw; if (componentObject.bodySpriteInd & SpriteIndex::isReversed) { unk ^= 1U << 5; } unk /= 2; auto& bogieSprites = vehObject.bogieSprites[componentObject.frontBogieSpriteInd]; if (bogieSprites.hasFlags(BogieSpriteFlags::rotationalSymmetry)) { unk &= 0xFU; } const auto rollIndex = (bogieSprites.numFramesPerRotation - 1) & roll; auto spriteIndex = bogieSprites.numFramesPerRotation * unk + rollIndex + bogieSprites.flatImageIds; drawItems.items.push_back(DrawItem{ ImageId(spriteIndex, colourScheme), drawItems.totalDistance + unkDist, false }); } auto carComponentLength = 0; auto backBogieDist = drawItems.totalDistance; if (componentObject.bodySpriteInd != SpriteIndex::null) { auto& bodySprites = vehObject.bodySprites[componentObject.bodySpriteInd & ~(1U << 7)]; carComponentLength = bodySprites.halfLength * 2; backBogieDist += carComponentLength; } auto unk1136174 = componentObject.backBogiePosition; backBogieDist -= componentObject.backBogiePosition; if (componentObject.backBogieSpriteInd != SpriteIndex::null && (vehObject.mode == TransportMode::rail || vehObject.mode == TransportMode::road)) { auto unk = yaw; if (!(componentObject.bodySpriteInd & SpriteIndex::isReversed)) { unk ^= 1U << 5; } unk /= 2; auto& bogieSprites = vehObject.bogieSprites[componentObject.backBogieSpriteInd]; if (bogieSprites.hasFlags(BogieSpriteFlags::rotationalSymmetry)) { unk &= 0xFU; } const auto rollIndex = (bogieSprites.numFramesPerRotation - 1) & roll; auto spriteIndex = bogieSprites.numFramesPerRotation * unk + rollIndex + bogieSprites.flatImageIds; drawItems.items.push_back(DrawItem{ ImageId(spriteIndex, colourScheme), backBogieDist, false }); } auto bodyDist = drawItems.totalDistance + (unkDist + carComponentLength - unk1136174) / 2; if (componentObject.bodySpriteInd != SpriteIndex::null) { auto& bodySprites = vehObject.bodySprites[componentObject.bodySpriteInd & ~SpriteIndex::isReversed]; auto unk = yaw; if (componentObject.bodySpriteInd & SpriteIndex::isReversed) { unk ^= 1U << 5; } uint8_t rollIndex = 0; if (!bodySprites.hasFlags(BodySpriteFlags::hasSpeedAnimation)) { rollIndex = (bodySprites.numAnimationFrames - 1) & roll; } if (bodySprites.numRollFrames != 1) { rollIndex += unk11360E8; } auto spriteIndex = getBodyImageIndex(bodySprites, Pitch::flat, unk, rollIndex, 0); drawItems.items.push_back(DrawItem{ ImageId(spriteIndex, colourScheme), bodyDist, true }); } drawItems.totalDistance += carComponentLength; } return drawItems; } static DrawItems getDrawItemsForVehicle(const VehicleObject& vehObject, const uint8_t yaw, const Vehicles::Car& car, const VehicleInlineMode mode) { Vehicles::Vehicle train(car.front->head); DrawItems drawItems{}; const auto isCarReversed = car.body->has38Flags(Vehicles::Flags38::isReversed); const auto isAnimated = mode == VehicleInlineMode::animated; uint8_t componentIndex = isCarReversed ? vehObject.numCarComponents - 1 : 0; for (auto& carComponent : car) { auto& componentObject = vehObject.carComponents[componentIndex]; // 0x01136172 auto unkDist = isCarReversed ? componentObject.backBogiePosition : componentObject.frontBogiePosition; if (carComponent.front->objectSpriteType != SpriteIndex::null && (vehObject.mode == TransportMode::rail || vehObject.mode == TransportMode::road)) { auto unk = yaw; if (carComponent.front->has38Flags(Vehicles::Flags38::isReversed)) { unk ^= 1U << 5; } unk /= 2; auto& bogieSprites = vehObject.bogieSprites[carComponent.front->objectSpriteType]; if (bogieSprites.hasFlags(BogieSpriteFlags::rotationalSymmetry)) { unk &= 0xFU; } const auto animationIndex = isAnimated ? carComponent.front->animationIndex : 0; auto spriteIndex = bogieSprites.numFramesPerRotation * unk + animationIndex + bogieSprites.flatImageIds; drawItems.items.push_back(DrawItem{ ImageId(spriteIndex, carComponent.front->colourScheme), drawItems.totalDistance + unkDist, false }); } auto carComponentLength = 0; auto backBogieDist = drawItems.totalDistance; if (componentObject.bodySpriteInd != SpriteIndex::null) { auto& bodySprites = vehObject.bodySprites[componentObject.bodySpriteInd & ~(1U << 7)]; carComponentLength = bodySprites.halfLength * 2; backBogieDist += carComponentLength; } auto unk1136174 = isCarReversed ? componentObject.frontBogiePosition : componentObject.backBogiePosition; backBogieDist -= unk1136174; if (carComponent.back->objectSpriteType != SpriteIndex::null && (vehObject.mode == TransportMode::rail || vehObject.mode == TransportMode::road)) { auto unk = yaw; if (carComponent.back->has38Flags(Vehicles::Flags38::isReversed)) { unk ^= 1U << 5; } unk /= 2; auto& bogieSprites = vehObject.bogieSprites[carComponent.back->objectSpriteType]; if (bogieSprites.hasFlags(BogieSpriteFlags::rotationalSymmetry)) { unk &= 0xFU; } const auto animationIndex = isAnimated ? carComponent.back->animationIndex : 0; auto spriteIndex = bogieSprites.numFramesPerRotation * unk + animationIndex + bogieSprites.flatImageIds; drawItems.items.push_back(DrawItem{ ImageId(spriteIndex, carComponent.back->colourScheme), backBogieDist, false }); } auto bodyDist = drawItems.totalDistance + (unkDist + carComponentLength - unk1136174) / 2; if (carComponent.body->objectSpriteType != SpriteIndex::null) { auto& bodySprites = vehObject.bodySprites[carComponent.body->objectSpriteType]; auto unk = yaw; if (carComponent.body->has38Flags(Vehicles::Flags38::isReversed)) { unk ^= 1U << 5; } auto rollIndex = isAnimated ? carComponent.body->animationFrame : 0; auto spriteIndex = getBodyImageIndex(bodySprites, Pitch::flat, unk, rollIndex, carComponent.body->cargoFrame); drawItems.items.push_back(DrawItem{ ImageId(spriteIndex, carComponent.body->colourScheme), bodyDist, true }); if (isAnimated && bodySprites.hasFlags(BodySpriteFlags::hasBrakingLights) && train.veh2->brakeLightTimeout != 0) { const auto brakingImageIndex = getBrakingImageIndex(bodySprites, Pitch::flat, yaw); drawItems.items.push_back(DrawItem{ ImageId(brakingImageIndex, carComponent.body->colourScheme), bodyDist, true }); } } drawItems.totalDistance += carComponentLength; if (isCarReversed) { componentIndex--; } else { componentIndex++; } } return drawItems; } static int32_t getVehicleObjectYDisplayOffset(const VehicleObject& vehObject) { auto trackType = vehObject.trackType; if (vehObject.mode == TransportMode::road) { if (trackType != 0xFFU) { return ObjectManager::get<RoadObject>(trackType)->displayOffset; } } else { if (trackType == 0xFFU) { return 3; } else { return ObjectManager::get<TrackObject>(trackType)->displayOffset; } } return 0; } // 0x004B777B void drawVehicleOverview(Gfx::DrawingContext& drawingCtx, Ui::Point offset, const VehicleObject& vehObject, const uint8_t yaw, const uint8_t roll, const ColourScheme colourScheme) { offset.y += getVehicleObjectYDisplayOffset(vehObject); // 0x01136152 stores offset.x // 0x01136154 stores offset.y const auto drawItems = getDrawItemsForVehicle(vehObject, yaw, roll, colourScheme); const auto midDist = drawItems.totalDistance / 2; // First draw all the bogies for (auto& item : drawItems.items) { if (!item.isBody) { drawItem(drawingCtx, offset, item, midDist, yaw); } } // Then draw the bodies forward/backward depending on where we are in the rotation if (yaw >= 8 && yaw < 40) { for (auto iter = drawItems.items.rbegin(); iter != drawItems.items.rend(); ++iter) { auto& item = *iter; if (item.isBody) { drawItem(drawingCtx, offset, item, midDist, yaw); } } } else { for (auto& item : drawItems.items) { if (item.isBody) { drawItem(drawingCtx, offset, item, midDist, yaw); } } } } static ColourScheme getCompanyVehicleColourScheme(CompanyId companyId, const VehicleObject& vehObject) { auto* company = CompanyManager::get(companyId); auto colourScheme = company->mainColours; if (company->customVehicleColoursSet & (1 << vehObject.colourType)) { colourScheme = company->vehicleColours[vehObject.colourType - 1]; } return colourScheme; } // 0x004B7741 void drawVehicleOverview(Gfx::DrawingContext& drawingCtx, Ui::Point offset, int16_t vehicleTypeIdx, uint8_t yaw, uint8_t roll, CompanyId companyId) { auto* vehObject = ObjectManager::get<VehicleObject>(vehicleTypeIdx); auto colourScheme = getCompanyVehicleColourScheme(companyId, *vehObject); drawVehicleOverview(drawingCtx, offset, *vehObject, yaw, roll, colourScheme); } static DrawItems toScreenDistDrawItems(const DrawItems& drawItems, const uint8_t yaw) { DrawItems screenDistDrawItems{}; const auto getScreenDistance = [](int32_t gameDist, uint8_t yaw) { const auto unk1 = Math::Trigonometry::computeXYVector(gameDist, yaw); const auto p1 = World::gameToScreen(World::Pos3(unk1.x, unk1.y, 0), 0); // This /4 is meant to be after the compute but we need to carry it to here // to keep precision high return -p1.x / 4; }; screenDistDrawItems.totalDistance = getScreenDistance(drawItems.totalDistance, yaw); for (auto& item : drawItems.items) { screenDistDrawItems.items.push_back(DrawItem{ item.image, getScreenDistance(item.dist, yaw), item.isBody }); } return screenDistDrawItems; } // 0x004B7711 & 0x004B745B int16_t drawVehicleInline(Gfx::DrawingContext& drawingCtx, int16_t vehicleTypeIdx, CompanyId company, Ui::Point loc) { // This has been simplified from vanilla. loc.y += 19; auto* vehObject = ObjectManager::get<VehicleObject>(vehicleTypeIdx); loc.y += getVehicleObjectYDisplayOffset(*vehObject); auto colourScheme = getCompanyVehicleColourScheme(company, *vehObject); const auto yaw = 40; const auto drawItems = getDrawItemsForVehicle(*vehObject, yaw, 0, colourScheme); auto screenDistDrawItems = toScreenDistDrawItems(drawItems, yaw); // Draw all bogies for (auto& item : screenDistDrawItems.items) { if (item.isBody) { continue; } drawingCtx.drawImage(loc + Ui::Point(item.dist, 0), item.image); } // Then draw the bodies for (auto& item : screenDistDrawItems.items) { if (!item.isBody) { continue; } drawingCtx.drawImage(loc + Ui::Point(item.dist, 0), item.image); } return screenDistDrawItems.totalDistance; } // 0x004B6D93 int16_t drawVehicleInline(Gfx::DrawingContext& drawingCtx, const Vehicles::Car& car, Ui::Point loc, VehicleInlineMode mode, VehiclePartsToDraw parts, std::optional<Colour> disabled) { // This has been simplified from vanilla. loc.y += 19; auto* vehObject = ObjectManager::get<VehicleObject>(car.front->objectId); loc.y += getVehicleObjectYDisplayOffset(*vehObject); const auto yaw = 40; const auto drawItems = getDrawItemsForVehicle(*vehObject, yaw, car, mode); auto screenDistDrawItems = toScreenDistDrawItems(drawItems, yaw); for (auto& item : screenDistDrawItems.items) { if (parts == VehiclePartsToDraw::bodies && !item.isBody) { continue; } if (parts == VehiclePartsToDraw::bogies && item.isBody) { continue; } if (disabled.has_value()) { const auto shade1 = Colours::getShade(disabled.value(), 5); const auto shade2 = Colours::getShade(disabled.value(), 3); drawingCtx.drawImageSolid(loc + Ui::Point(item.dist, 0) + Ui::Point(1, 1), item.image, shade1); drawingCtx.drawImageSolid(loc + Ui::Point(item.dist, 0), item.image, shade2); } else { drawingCtx.drawImage(loc + Ui::Point(item.dist, 0), item.image); } } return screenDistDrawItems.totalDistance; } int16_t getWidthVehicleInline(const Vehicles::Car& car) { auto* vehObject = ObjectManager::get<VehicleObject>(car.front->objectId); const auto yaw = 40; const auto drawItems = getDrawItemsForVehicle(*vehObject, yaw, car, VehicleInlineMode::basic); auto screenDistDrawItems = toScreenDistDrawItems(drawItems, yaw); return screenDistDrawItems.totalDistance; } // 0x004B6D43 int16_t drawTrainInline(Gfx::DrawingContext& drawingCtx, const Vehicles::Vehicle& train, Ui::Point loc) { const auto startX = loc.x; for (auto& car : train.cars) { loc.x += drawVehicleInline(drawingCtx, car, loc, VehicleInlineMode::animated, VehiclePartsToDraw::bogies); } loc.x = startX; for (auto& car : train.cars) { loc.x += drawVehicleInline(drawingCtx, car, loc, VehicleInlineMode::animated, VehiclePartsToDraw::bodies); } return loc.x; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleDraw.h ```h #include "Types.hpp" #include <OpenLoco/Engine/Ui/Point.hpp> #include <optional> namespace OpenLoco { namespace Gfx { class DrawingContext; } namespace Vehicles { struct Car; struct Vehicle; } struct VehicleObject; struct VehicleObjectBodySprite; enum class Pitch : uint8_t; // roll/animationFrame uint32_t getBodyImageIndex(const VehicleObjectBodySprite& sprite, const Pitch pitch, const uint8_t yaw, const uint8_t roll, const uint8_t cargoIndex); uint32_t getBrakingImageIndex(const VehicleObjectBodySprite& sprite, const Pitch pitch, const uint8_t yaw); void drawVehicleOverview(Gfx::DrawingContext& drawingCtx, Ui::Point offset, const VehicleObject& vehObject, const uint8_t yaw, const uint8_t roll, const ColourScheme colourScheme); void drawVehicleOverview(Gfx::DrawingContext& drawingCtx, Ui::Point offset, int16_t vehicleTypeIdx, uint8_t yaw, uint8_t roll, CompanyId companyId); int16_t drawVehicleInline(Gfx::DrawingContext& drawingCtx, int16_t vehicleTypeIdx, CompanyId company, Ui::Point loc); enum class VehicleInlineMode : bool { basic, animated }; enum class VehiclePartsToDraw : uint8_t { bogies, bodies }; int16_t drawVehicleInline(Gfx::DrawingContext& drawingCtx, const Vehicles::Car& car, Ui::Point loc, VehicleInlineMode mode, VehiclePartsToDraw parts, std::optional<Colour> disabled = std::nullopt); int16_t getWidthVehicleInline(const Vehicles::Car& car); int16_t drawTrainInline(Gfx::DrawingContext& drawingCtx, const Vehicles::Vehicle& train, Ui::Point loc); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleHead.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "Economy/Economy.h" #include "Effects/Effect.h" #include "Effects/SmokeEffect.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Vehicles/VehicleChangeRunningMode.h" #include "GameCommands/Vehicles/VehicleSell.h" #include "GameState.h" #include "Graphics/Gfx.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/Track/SubpositionData.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "MessageManager.h" #include "Objects/AirportObject.h" #include "Objects/CargoObject.h" #include "Objects/DockObject.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackObject.h" #include "Objects/VehicleObject.h" #include "OrderManager.h" #include "Orders.h" #include "Random.h" #include "RoutingManager.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "Tutorial.h" #include "Ui/WindowManager.h" #include "Vehicle.h" #include "VehicleManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/CompanyRecords.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Bound.hpp> #include <OpenLoco/Math/Trigonometry.hpp> #include <cassert> #include <numeric> #include <optional> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; using namespace OpenLoco::World; namespace OpenLoco::Vehicles { static loco_global<uint32_t, 0x011360D0> _vehicleUpdate_manhattanDistanceToStation; static loco_global<VehicleHead*, 0x01136118> _vehicleUpdate_head; static loco_global<Vehicle1*, 0x0113611C> _vehicleUpdate_1; static loco_global<Vehicle2*, 0x01136120> _vehicleUpdate_2; static loco_global<VehicleBogie*, 0x01136124> _vehicleUpdate_frontBogie; static loco_global<VehicleBogie*, 0x01136128> _vehicleUpdate_backBogie; static loco_global<int32_t, 0x0113612C> _vehicleUpdate_var_113612C; // Speed static loco_global<int32_t, 0x01136130> _vehicleUpdate_var_1136130; // Speed static loco_global<int16_t, 0x01136168> _vehicleUpdate_targetZ; static loco_global<uint16_t, 0x01136458> _1136458; // Actually just a bool static loco_global<Status, 0x0113646C> _vehicleUpdate_initialStatus; static loco_global<uint8_t, 0x0113646D> _vehicleUpdate_helicopterTargetYaw; static loco_global<AirportMovementNodeFlags, 0x00525BB0> _vehicleUpdate_helicopterAirportMovement; static loco_global<uint32_t, 0x0112C30C> _vehicleUpdate_compatibleRoadStationTypes; static loco_global<int8_t[88], 0x004F865C> _vehicle_arr_4F865C; // This is static move to TrackData static loco_global<SignalStateFlags, 0x005220BC> _vehicleManagerIgnoreSignalFlagsMasks; static loco_global<uint8_t, 0x0113623B> _vehicleMangled_113623B; // This shouldn't be used as it will be mangled but it is static constexpr uint16_t kTrainOneWaySignalTimeout = 1920; static constexpr uint16_t kTrainTwoWaySignalTimeout = 640; static constexpr uint16_t kBusSignalTimeout = 960; // Time to wait before turning around at barriers static constexpr uint16_t kTramSignalTimeout = 2880; // Time to wait before turning around at barriers static constexpr uint8_t kAiSellCrashedVehicleTimeout = 14; // Number of days after a crash before selling static constexpr uint8_t kRestartStoppedRoadVehiclesTimeout = 20; // Number of days before stopped road vehicle (bus and tram) is restarted static constexpr uint16_t kReliabilityLossPerDay = 4; static constexpr uint16_t kReliabilityLossPerDayObsolete = 10; // In order of preference when finding a route enum class RouteSignalState : uint32_t { noSignals = 1, signalClear = 2, signalBlockedOneWay = 3, signalBlockedTwoWay = 4, signalNoRoute = 6, // E.g. its a one way track and we are going the wrong way null = 0xFFFFFFFFU, }; struct RoutingResult { uint16_t bestDistToTarget; // 0x01136448 uint32_t bestTrackWeighting; // 0x01136444 RouteSignalState signalState; // 0x0113644C }; struct Sub4AC3D3State { RoutingResult result; // The following are now in result // RouteSignalState signalState; // 0x01136450 // uint16_t bestDistToTarget; // 0x01136456 // uint32_t bestTrackWeighting; // 0x0113643C uint16_t hadNewResult; // 0x01136458 }; static uint16_t roadLongestPathing(VehicleHead& head, const World::Pos3 pos, const Track::RoadConnections& rc, const uint8_t requiredMods, const uint8_t queryMods); static uint16_t roadPathing(VehicleHead& head, const World::Pos3 pos, const Track::RoadConnections& rc, const uint8_t requiredMods, const uint8_t queryMods, const uint32_t allowedStationTypes, bool isSecondRun, Sub4AC3D3State& state); static uint16_t trackLongestPathing(VehicleHead& head, const World::Pos3 pos, const Track::TrackConnections& tc, const uint8_t requiredMods, const uint8_t queryMods); static uint16_t trackPathing(VehicleHead& head, const World::Pos3 pos, const Track::TrackConnections& tc, const uint8_t requiredMods, const uint8_t queryMods, bool isSecondRun, Sub4AC3D3State& state); struct WaterPathingResult { World::Pos2 headTarget; StationId stationId; // If stationId is null, stationPosition is invalid World::Pos3 stationPos; constexpr WaterPathingResult(const World::Pos2 headTarget, const StationId stationId, const World::Pos3 stationPos) : headTarget(headTarget) , stationId(stationId) , stationPos(stationPos) { } explicit constexpr WaterPathingResult(const World::Pos2 headTarget) : headTarget(headTarget) , stationId(StationId::null) , stationPos({}) { } }; static WaterPathingResult waterPathfind(const VehicleHead& head); void VehicleHead::updateVehicle() { // TODO: Refactor to use the Vehicle super class VehicleBase* v = this; while (v != nullptr) { if (v->updateComponent()) { break; } v = v->nextVehicleComponent(); } } // 0x004A8B81 bool VehicleHead::update() { Vehicle train(head); _vehicleUpdate_head = train.head; _vehicleUpdate_1 = train.veh1; _vehicleUpdate_2 = train.veh2; _vehicleUpdate_initialStatus = status; updateDrivingSounds(); _vehicleUpdate_frontBogie = reinterpret_cast<VehicleBogie*>(0xFFFFFFFF); _vehicleUpdate_backBogie = reinterpret_cast<VehicleBogie*>(0xFFFFFFFF); Vehicle2* veh2 = _vehicleUpdate_2; _vehicleUpdate_var_113612C = veh2->currentSpeed.getRaw() >> 7; _vehicleUpdate_var_1136130 = veh2->currentSpeed.getRaw() >> 7; if (var_5C != 0) { var_5C--; } if (tileX == -1) { if (!train.cars.empty()) { return false; } train.tail->trainDanglingTimeout++; if (train.tail->trainDanglingTimeout < 960) { return false; } VehicleManager::deleteTrain(*this); return false; } updateBreakdown(); bool continueUpdating = true; switch (mode) { case TransportMode::rail: case TransportMode::road: continueUpdating = updateLand(); break; case TransportMode::air: continueUpdating = updateAir(); break; case TransportMode::water: continueUpdating = updateWater(); break; } if (continueUpdating) { tryCreateInitialMovementSound(); } return continueUpdating; } // 0x004C3C65 void VehicleHead::updateMonthly() { Vehicle train(head); if ((tileX != -1) && !has38Flags(Flags38::isGhost)) { constexpr ExpenditureType vehTypeToCost[] = { ExpenditureType::TrainRunningCosts, ExpenditureType::BusRunningCosts, ExpenditureType::TruckRunningCosts, ExpenditureType::TramRunningCosts, ExpenditureType::AircraftRunningCosts, ExpenditureType::ShipRunningCosts, }; const auto costs = calculateRunningCost(); CompanyManager::applyPaymentToCompany(owner, costs, vehTypeToCost[enumValue(vehicleType)]); const auto monthlyProfit = train.veh2->curMonthRevenue - costs; auto& profitHist = train.veh2->profit; std::rotate(std::begin(profitHist), std::end(profitHist) - 1, std::end(profitHist)); profitHist[0] = monthlyProfit; train.veh2->curMonthRevenue = 0; Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(id)); } for (auto& car : train.cars) { // Reduce the refund cost by 0.78% each month car.front->refundCost -= car.front->refundCost / 128; } calculateRefundCost(); } // 0x004B8340 static void recalculateTrainMinReliability(VehicleHead& head) { Vehicle train(head); const auto getReliability = [](const Car& car) -> uint16_t { if (car.front->reliability == 0) { return 0xFFFFU; } return car.front->reliability; }; const auto reliabilityPredicate = [&getReliability](const Car& carLhs, const Car& carRhs) { return getReliability(carLhs) < getReliability(carRhs); }; auto minReliability = 0xFFFFU; if (!train.cars.empty()) { minReliability = (*std::min_element(train.cars.begin(), train.cars.end(), reliabilityPredicate)).front->reliability; } train.veh2->reliability = minReliability == 0xFFFFU ? 0 : minReliability / 256; } // 0x004B9509 void VehicleHead::updateDaily() { bool resetStoppedTimeout = true; if (status == Status::stopped) { if (mode == TransportMode::road) { if (tileX != -1 && hasVehicleFlags(VehicleFlags::commandStop)) { if (Tutorial::state() == Tutorial::State::none) { restartStoppedCarsTimeout++; if (restartStoppedCarsTimeout >= kRestartStoppedRoadVehiclesTimeout) { GameCommands::VehicleChangeRunningModeArgs args{}; args.head = head; args.mode = GameCommands::VehicleChangeRunningModeArgs::Mode::startVehicle; auto regs = static_cast<Interop::registers>(args); regs.bl = GameCommands::Flags::apply; GameCommands::vehicleChangeRunningMode(regs); if (static_cast<uint32_t>(regs.ebx) == GameCommands::FAILURE) { liftUpVehicle(); } } else { resetStoppedTimeout = false; } } else { resetStoppedTimeout = false; } } } else { resetStoppedTimeout = false; } } if (resetStoppedTimeout) { restartStoppedCarsTimeout = 0; } if (status == Status::crashed || status == Status::stuck) { crashedTimeout = Math::Bound::add(crashedTimeout, 1U); if (!CompanyManager::isPlayerCompany(owner)) { if (crashedTimeout >= kAiSellCrashedVehicleTimeout && aiThoughtId != 0xFF) { auto* aiCompany = CompanyManager::get(owner); auto& aiThought = aiCompany->aiThoughts[aiThoughtId]; const auto toBeRemovedId = id; sub_4AD778(); status = Status::stopped; Vehicle train(*this); train.veh2->currentSpeed = 0_mph; auto stashOwner = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(owner); GameCommands::VehicleSellArgs args{}; args.car = toBeRemovedId; GameCommands::doCommand(args, GameCommands::Flags::apply); // 'this' pointer is invalid at this point! GameCommands::setUpdatingCompanyId(stashOwner); removeEntityFromThought(aiThought, toBeRemovedId); return; } } } Vehicle train(*this); for (auto& car : train.cars) { // Bit of overkill iterating the whole car // as only the first carComponent has cargo // but matches vanilla. Remove when confirmed // not used. for (auto& carComponent : car) { if (carComponent.front->secondaryCargo.qty != 0) { carComponent.front->secondaryCargo.numDays = Math::Bound::add(carComponent.front->secondaryCargo.numDays, 1U); } // Bit of overkill as back doesn't hold cargo but // it matches vanilla. Remove when confirmed not used if (carComponent.back->secondaryCargo.qty != 0) { carComponent.back->secondaryCargo.numDays = Math::Bound::add(carComponent.back->secondaryCargo.numDays, 1U); } if (carComponent.body->primaryCargo.qty != 0) { carComponent.body->primaryCargo.numDays = Math::Bound::add(carComponent.body->primaryCargo.numDays, 1U); } } } for (auto& car : train.cars) { auto& front = *car.front; if (front.reliability == 0) { continue; } if (front.hasBreakdownFlags(BreakdownFlags::brokenDown)) { front.breakdownTimeout--; if (front.breakdownTimeout == 0) { front.breakdownFlags &= ~BreakdownFlags::brokenDown; applyBreakdownToTrain(); } } else if (front.timeoutToBreakdown != 0xFFFFU) { front.timeoutToBreakdown = Math::Bound::sub(front.timeoutToBreakdown, 1U); if (front.timeoutToBreakdown == 0) { sub_4BA873(front); front.breakdownFlags |= BreakdownFlags::breakdownPending; } } auto newReliability = front.reliability; auto* vehObj = ObjectManager::get<VehicleObject>(front.objectId); newReliability -= vehObj->obsolete <= getCurrentYear() ? kReliabilityLossPerDayObsolete : kReliabilityLossPerDay; newReliability = std::max<uint16_t>(newReliability, 100); front.reliability = newReliability; } recalculateTrainMinReliability(*this); } // 0x004BA8D4 void VehicleHead::updateBreakdown() { switch (status) { case Status::unk_0: case Status::stopped: case Status::waitingAtSignal: case Status::unloading: case Status::loading: case Status::crashed: case Status::stuck: return; case Status::travelling: case Status::approaching: case Status::brokenDown: case Status::landing: case Status::taxiing1: case Status::taxiing2: case Status::takingOff: break; } Vehicle train(head); for (auto& car : train.cars) { if (car.front->hasBreakdownFlags(BreakdownFlags::brokenDown)) { if ((ScenarioManager::getScenarioTicks() & 3) == 0) { auto v2 = car.body; // body Smoke::create(v2->position + World::Pos3{ 0, 0, 4 }); } } if (car.front->hasBreakdownFlags(BreakdownFlags::breakdownPending) && !SceneManager::isTitleMode()) { auto newConfig = Config::get(); if (!newConfig.breakdownsDisabled) { car.front->breakdownFlags &= ~BreakdownFlags::breakdownPending; car.front->breakdownFlags |= BreakdownFlags::brokenDown; car.front->breakdownTimeout = 5; applyBreakdownToTrain(); auto soundId = (Audio::SoundId)gPrng1().randNext(26, 26 + 5); Audio::playSound(soundId, car.body->position + World::Pos3{ 0, 0, 22 }); } } } } // 0x004BAA76 void VehicleHead::applyBreakdownToTrain() { Vehicle train(head); bool isBrokenDown = false; bool trainStillPowered = false; // Check only the first bogie on each car for breakdown flags for (const auto& car : train.cars) { auto* vehObj = ObjectManager::get<VehicleObject>(car.front->objectId); if (vehObj == nullptr) { continue; } // Unpowered vehicles can not breakdown if (vehObj->power == 0) { continue; } if (car.front->hasBreakdownFlags(BreakdownFlags::brokenDown)) { isBrokenDown = true; } else { trainStillPowered = true; } } if (isBrokenDown) { if (trainStillPowered) { train.veh2->var_73 |= Flags73::isBrokenDown | Flags73::isStillPowered; } else { train.veh2->var_73 |= Flags73::isBrokenDown; train.veh2->var_73 &= ~Flags73::isStillPowered; } } else { train.veh2->var_73 &= ~(Flags73::isBrokenDown | Flags73::isStillPowered); } } struct CarMetaData { EntityId frontId; VehicleObjectFlags flags; uint16_t power; bool isReversed; // At start matches wasReversed could be modified during the function bool wasReversed; constexpr bool hasFlags(VehicleObjectFlags flagsToTest) const { return (flags & flagsToTest) != VehicleObjectFlags::none; } }; // 0x004AF7A4 void VehicleHead::autoLayoutTrain() { Vehicle train(*this); if (train.cars.empty()) { return; } // This function has been modified from vanilla but it should // produce the same results. Vanilla version performed a lot // of flipping and inserting to reorder the cars. This version // does the final flipping/inserting in one go at the end. // Pretty safe to assume this as its hard to exceed 30 // you can do about ~200 if you use some tricks assert(train.cars.size() < 100); sfl::static_vector<CarMetaData, 100> carData; for (auto& car : train.cars) { auto* vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); CarMetaData data{}; data.frontId = car.front->id; data.flags = vehicleObj->flags; data.power = vehicleObj->power; data.isReversed = car.body->has38Flags(Flags38::isReversed); data.wasReversed = car.body->has38Flags(Flags38::isReversed); carData.push_back(data); } auto pushCarToFront = [&carData](const size_t index) { std::rotate(carData.begin(), carData.begin() + index, carData.begin() + index + 1); }; auto pushCarToBack = [&carData](const size_t index) { std::rotate(carData.begin() + index, carData.begin() + index + 1, carData.end()); }; if (!hasVehicleFlags(VehicleFlags::shuntCheat)) { // Places first powered car at front of train for (auto i = 0U; i < carData.size(); ++i) { auto& cd = carData[i]; if (cd.power != 0) { pushCarToFront(i); break; } } } { // Alternate forward/backward if VehicleObjectFlags::alternatingDirection set bool curIsReversed = false; for (auto& cd : carData) { if (cd.hasFlags(VehicleObjectFlags::alternatingDirection)) { cd.isReversed = curIsReversed; curIsReversed ^= true; } } } if (!hasVehicleFlags(VehicleFlags::shuntCheat)) { // Places first car with VehicleObjectFlags::topAndTailPosition to the front of train // and last car with VehicleObjectFlags::topAndTailPosition to the back of the train // If there is only one topAndTailPosition car and it isn't at the front due to other // rules it will be placed at the back of the train bool isFirst = true; auto lastTopTail = -1; for (auto i = 0U; i < carData.size(); ++i) { auto& cd = carData[i]; if (cd.power != 0 || cd.hasFlags(VehicleObjectFlags::topAndTailPosition)) { if (isFirst) { if (cd.hasFlags(VehicleObjectFlags::topAndTailPosition)) { cd.isReversed = false; pushCarToFront(i); } isFirst = false; continue; } if (cd.hasFlags(VehicleObjectFlags::topAndTailPosition)) { lastTopTail = i; } } isFirst = false; } if (lastTopTail != -1) { auto& cd = carData[lastTopTail]; cd.isReversed = true; pushCarToBack(lastTopTail); } } // 0x004AFBC0 if (!hasVehicleFlags(VehicleFlags::shuntCheat)) { // Places all cars with VehicleObjectFlags::centerPosition in the middle of the train const auto numMiddles = std::count_if(carData.begin(), carData.end(), [](auto& d) { return d.hasFlags(VehicleObjectFlags::centerPosition); }); const auto middle = (carData.size() / 2) + 1; if (middle < carData.size()) { std::stable_partition(carData.begin(), carData.end(), [](auto& a) { return !a.hasFlags(VehicleObjectFlags::centerPosition); }); const auto middleStart = middle - numMiddles / 2; const auto middleEnd = middleStart + numMiddles; std::rotate(carData.begin() + middleStart, carData.begin() + middleEnd, carData.end()); } } if (!hasVehicleFlags(VehicleFlags::shuntCheat)) { // If there are at least 4 cars with VehicleObjectFlags::flag_04 places 2 of them in the middle of the train // This flag is used to create train sets comprised of 2 double ended trains const auto numFlag4s = std::count_if(carData.begin(), carData.end(), [](auto& d) { return d.hasFlags(VehicleObjectFlags::flag_04); }); if (numFlag4s >= 4) { uint8_t moveCount = 0; const auto middle = (carData.size() / 2) + 1; std::array<CarMetaData, 2> toBeMoved{}; if (middle < carData.size()) { for (auto i = 1U; i < carData.size() - 1; ++i) { auto& cd = carData[i]; if (cd.hasFlags(VehicleObjectFlags::flag_04)) { toBeMoved[moveCount++] = cd; carData.erase(carData.begin() + i); i--; if (moveCount == 2) { break; } } } carData.insert(carData.begin() + middle - 1, toBeMoved[0]); carData.insert(carData.begin() + middle, toBeMoved[1]); } } } if (!hasVehicleFlags(VehicleFlags::shuntCheat)) { // Apply the reordering and flipping VehicleBase* dest = train.tail; for (auto i = carData.size(); i > 0; --i) { auto& cd = carData[i - 1]; auto* frontCar = EntityManager::get<VehicleBogie>(cd.frontId); if (frontCar == nullptr) { continue; } if (cd.isReversed != cd.wasReversed) { frontCar = flipCar(*frontCar); } insertCarBefore(*frontCar, *dest); dest = frontCar; } } // Train is invalid after insertCarBefore train = Vehicle(*this); { bool front = true; for (auto& car : train.cars) { auto* vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); if (!vehicleObj->hasFlags(VehicleObjectFlags::alternatingCarSprite)) { continue; } car.body->bodyIndex = front ? 0 : 1; car.body->objectSpriteType = vehicleObj->carComponents[car.body->bodyIndex].bodySpriteInd & ~SpriteIndex::isReversed; front ^= true; } } connectJacobsBogies(*this); } // 0x004B90F0 // eax : newVehicleTypeId // ebx : sourceVehicleTypeId; bool canVehiclesCouple(const uint16_t newVehicleTypeId, const uint16_t sourceVehicleTypeId) { auto newObject = ObjectManager::get<VehicleObject>(newVehicleTypeId); // edi auto sourceObject = ObjectManager::get<VehicleObject>(sourceVehicleTypeId); // esi if (newObject->hasFlags(VehicleObjectFlags::cannotCoupleToSelf) && sourceObject->hasFlags(VehicleObjectFlags::cannotCoupleToSelf)) { GameCommands::setErrorText(StringIds::incompatible_vehicle); return false; } if (newVehicleTypeId == sourceVehicleTypeId) { return true; } for (auto i = 0; i < newObject->numCompatibleVehicles; ++i) { if (newObject->compatibleVehicles[i] == sourceVehicleTypeId) { return true; } } if (sourceObject->numCompatibleVehicles != 0) { for (auto i = 0; i < sourceObject->numCompatibleVehicles; ++i) { if (sourceObject->compatibleVehicles[i] == newVehicleTypeId) { return true; } } } if ((newObject->numCompatibleVehicles != 0) || (sourceObject->numCompatibleVehicles != 0)) { GameCommands::setErrorText(StringIds::incompatible_vehicle); return false; } return true; } // 0x004B97B7 uint32_t VehicleHead::getVehicleTotalLength() const { auto totalLength = 0; Vehicle train(head); for (const auto& car : train.cars) { totalLength += car.body->getObject()->getLength(); } return totalLength; } uint32_t VehicleHead::getCarCount() const { Vehicle train(head); return train.cars.size(); } // 0x004B8FA2 // esi : self // ax : vehicleTypeId bool VehicleHead::isVehicleTypeCompatible(const uint16_t vehicleTypeId) // TODO: const { auto newObject = ObjectManager::get<VehicleObject>(vehicleTypeId); if (newObject->mode == TransportMode::air || newObject->mode == TransportMode::water) { Vehicle train(head); if (!train.cars.empty()) { GameCommands::setErrorText(StringIds::incompatible_vehicle); return false; } } else { if (newObject->trackType != trackType) { GameCommands::setErrorText(StringIds::incompatible_vehicle); return false; } } if (newObject->mode != mode) { GameCommands::setErrorText(StringIds::incompatible_vehicle); return false; } if (newObject->type != vehicleType) { GameCommands::setErrorText(StringIds::incompatible_vehicle); return false; } { Vehicle train(head); for (const auto& car : train.cars) { // The objectId is the same for all vehicle components and car components of a car if (!canVehiclesCouple(vehicleTypeId, car.front->objectId)) { return false; } } } if (mode != TransportMode::road) { return true; } if (trackType != 0xFF) { return true; } auto curTotalLength = getVehicleTotalLength(); auto additionalNewLength = ObjectManager::get<VehicleObject>(vehicleTypeId)->getLength(); if (curTotalLength + additionalNewLength > kMaxRoadVehicleLength) { GameCommands::setErrorText(StringIds::vehicle_too_long); return false; } return true; } // 0x004B671C VehicleStatus VehicleHead::getStatus() const { VehicleStatus vehStatus = {}; vehStatus.status2 = StringIds::null; if (tileX == -1) { vehStatus.status1 = StringIds::vehicle_status_no_position; return vehStatus; } Vehicle train(head); if (train.veh2->has73Flags(Flags73::isBrokenDown)) { vehStatus.status1 = StringIds::vehicle_status_broken_down; return vehStatus; } switch (status) { case Status::unk_0: vehStatus.status1 = StringIds::vehicle_status_no_position; return vehStatus; case Status::stopped: vehStatus.status1 = StringIds::vehicle_status_stopped; return vehStatus; case Status::travelling: case Status::waitingAtSignal: return getStatusTravelling(); case Status::approaching: { if (stationId == StationId::null) { return getStatusTravelling(); } vehStatus.status1 = StringIds::vehicle_status_approaching; auto station = StationManager::get(stationId); vehStatus.status1Args = station->name | (enumValue(station->town) << 16); getSecondStatus(vehStatus); return vehStatus; } case Status::unloading: { if (stationId == StationId::null) { return getStatusTravelling(); } vehStatus.status1 = StringIds::vehicle_status_unloading; auto station = StationManager::get(stationId); vehStatus.status1Args = station->name | (enumValue(station->town) << 16); return vehStatus; } case Status::loading: { if (stationId == StationId::null) { return getStatusTravelling(); } vehStatus.status1 = StringIds::vehicle_status_loading; auto station = StationManager::get(stationId); vehStatus.status1Args = station->name | (enumValue(station->town) << 16); return vehStatus; } case Status::brokenDown: vehStatus.status1 = StringIds::vehicle_status_broken_down; return vehStatus; case Status::crashed: vehStatus.status1 = StringIds::vehicle_status_crashed; return vehStatus; case Status::stuck: vehStatus.status1 = StringIds::vehicle_status_stuck; return vehStatus; case Status::landing: { if (stationId == StationId::null) { return getStatusTravelling(); } vehStatus.status1 = StringIds::vehicle_status_landing; auto station = StationManager::get(stationId); vehStatus.status1Args = station->name | (enumValue(station->town) << 16); getSecondStatus(vehStatus); return vehStatus; } case Status::taxiing1: case Status::taxiing2: { if (stationId == StationId::null) { return getStatusTravelling(); } vehStatus.status1 = StringIds::vehicle_status_taxiing; auto station = StationManager::get(stationId); vehStatus.status1Args = station->name | (enumValue(station->town) << 16); getSecondStatus(vehStatus); return vehStatus; } case Status::takingOff: { if (stationId == StationId::null) { return getStatusTravelling(); } vehStatus.status1 = StringIds::vehicle_status_taking_off; auto station = StationManager::get(stationId); vehStatus.status1Args = station->name | (enumValue(station->town) << 16); getSecondStatus(vehStatus); return vehStatus; } } return vehStatus; } // 0x004B6885 VehicleStatus VehicleHead::getStatusTravelling() const { VehicleStatus vehStatus{}; if (hasVehicleFlags(VehicleFlags::commandStop) || (hasVehicleFlags(VehicleFlags::manualControl) && manualPower <= -20)) { vehStatus.status1 = StringIds::vehicle_status_stopping; } else if (sizeOfOrderTable == 1) { vehStatus.status1 = StringIds::vehicle_status_travelling; } else { bool stopFound = false; auto orders = getCurrentOrders(); for (auto& order : orders) { auto* stopOrder = order.as<OrderStopAt>(); if (stopOrder == nullptr) { continue; } stopFound = true; auto* station = StationManager::get(stopOrder->getStation()); vehStatus.status1 = StringIds::vehicle_status_heading_for; vehStatus.status1Args = (enumValue(station->town) << 16) | station->name; break; } if (!stopFound) { vehStatus.status1 = StringIds::vehicle_status_travelling; } } getSecondStatus(vehStatus); return vehStatus; } // 0x004B691C void VehicleHead::getSecondStatus(VehicleStatus& vehStatus) const { Vehicle train(head); if (status == Status::waitingAtSignal) { vehStatus.status2 = StringIds::vehicle_status_waiting_at_signal; } else { vehStatus.status2 = StringIds::vehicle_status_at_velocity; vehStatus.status2Args = toSpeed16(train.veh2->currentSpeed).getRaw(); } } // 0x004A8882 void VehicleHead::updateDrivingSounds() { Vehicle train(head); updateDrivingSound(train.veh2->getSoundPlayer()); updateDrivingSound(train.tail->getSoundPlayer()); } // 0x004A88A6 void VehicleHead::updateDrivingSound(VehicleSoundPlayer* soundPlayer) { if (tileX == -1 || status == Status::crashed || status == Status::stuck || has38Flags(Flags38::isGhost) || soundPlayer->objectId == 0xFFFF) { updateDrivingSoundNone(soundPlayer); return; } auto vehicleObject = ObjectManager::get<VehicleObject>(soundPlayer->objectId); switch (vehicleObject->drivingSoundType) { case DrivingSoundType::none: updateDrivingSoundNone(soundPlayer); break; case DrivingSoundType::friction: updateDrivingSoundFriction(soundPlayer, &vehicleObject->sound.friction); break; case DrivingSoundType::simpleMotor: updateSimpleMotorSound(soundPlayer, &vehicleObject->sound.simpleMotor); break; case DrivingSoundType::gearboxMotor: updateGearboxMotorSound(soundPlayer, &vehicleObject->sound.gearboxMotor); break; default: break; } } // 0x004A8B7C void VehicleHead::updateDrivingSoundNone(VehicleSoundPlayer* soundPlayer) { soundPlayer->drivingSoundId = 0xFF; } // 0x004A88F7 void VehicleHead::updateDrivingSoundFriction(VehicleSoundPlayer* soundPlayer, const VehicleObjectFrictionSound* snd) { Vehicle2* vehType2_2 = _vehicleUpdate_2; if (vehType2_2->currentSpeed < snd->minSpeed) { updateDrivingSoundNone(soundPlayer); return; } auto speedDiff = vehType2_2->currentSpeed - snd->minSpeed; soundPlayer->drivingSoundFrequency = (speedDiff.getRaw() >> snd->speedFreqFactor) + snd->baseFrequency; auto volume = (speedDiff.getRaw() >> snd->speedVolumeFactor) + snd->baseVolume; soundPlayer->drivingSoundVolume = std::min<uint8_t>(volume, snd->maxVolume); soundPlayer->drivingSoundId = snd->soundObjectId; } // 0x004A8937 void VehicleHead::updateSimpleMotorSound(VehicleSoundPlayer* soundPlayer, const VehicleSimpleMotorSound* snd) { Vehicle train(head); if (soundPlayer->isVehicle2()) { if (vehicleType != VehicleType::ship && vehicleType != VehicleType::aircraft) { // Can be a type 6 or bogie if (train.cars.empty()) { assert(false); } if (train.cars.firstCar.front->hasBreakdownFlags(BreakdownFlags::brokenDown)) { updateDrivingSoundNone(soundPlayer); return; } } } Vehicle2* vehType2_2 = _vehicleUpdate_2; uint16_t targetFrequency = snd->idleFrequency; uint8_t targetVolume = snd->idleVolume; if (vehType2_2->motorState == MotorState::accelerating && (!(soundPlayer->isVehicle2()) || train.cars.firstCar.front->wheelSlipping == 0)) { targetFrequency = snd->accelerationBaseFreq + (vehType2_2->currentSpeed.getRaw() >> snd->speedFreqFactor); targetVolume = snd->acclerationVolume; } else if (vehType2_2->motorState == MotorState::coasting && vehType2_2->currentSpeed >= 12.0_mph) { targetFrequency = snd->coastingFrequency; targetVolume = snd->coastingVolume; } if (soundPlayer->drivingSoundId == 0xFF) { // Half soundPlayer->drivingSoundVolume = snd->idleVolume >> 1; // Quarter soundPlayer->drivingSoundFrequency = snd->idleFrequency >> 2; soundPlayer->drivingSoundId = snd->soundObjectId; return; } if (soundPlayer->drivingSoundFrequency != targetFrequency) { if (soundPlayer->drivingSoundFrequency > targetFrequency) { soundPlayer->drivingSoundFrequency = std::max<uint16_t>(targetFrequency, soundPlayer->drivingSoundFrequency - snd->freqDecreaseStep); } else { soundPlayer->drivingSoundFrequency = std::min<uint16_t>(targetFrequency, soundPlayer->drivingSoundFrequency + snd->freqIncreaseStep); } } if (soundPlayer->drivingSoundVolume != targetVolume) { if (soundPlayer->drivingSoundVolume > targetVolume) { soundPlayer->drivingSoundVolume = std::max<uint8_t>(targetVolume, soundPlayer->drivingSoundVolume - snd->volumeDecreaseStep); } else { soundPlayer->drivingSoundVolume = std::min<uint8_t>(targetVolume, soundPlayer->drivingSoundVolume + snd->volumeIncreaseStep); } } soundPlayer->drivingSoundId = snd->soundObjectId; } // 0x004A8A39 void VehicleHead::updateGearboxMotorSound(VehicleSoundPlayer* soundPlayer, const VehicleGearboxMotorSound* snd) { Vehicle train(head); if (soundPlayer->isVehicle2()) { if (vehicleType != VehicleType::ship && vehicleType != VehicleType::aircraft) { // Can be a type 6 or bogie if (train.cars.empty()) { assert(false); } if (train.cars.firstCar.front->hasBreakdownFlags(BreakdownFlags::brokenDown)) { updateDrivingSoundNone(soundPlayer); return; } } } Vehicle2* vehType2_2 = _vehicleUpdate_2; uint16_t targetFrequency = 0; uint8_t targetVolume = 0; bool transmissionInGear = vehType2_2->motorState == MotorState::accelerating; if (vehType2_2->motorState == MotorState::coasting || vehType2_2->motorState == MotorState::braking) { targetVolume = snd->coastingVolume; if (vehType2_2->currentSpeed < 12.0_mph) { targetFrequency = snd->idleFrequency; } else { transmissionInGear = true; } } else if (vehType2_2->motorState == MotorState::accelerating) { targetVolume = snd->acceleratingVolume; } else { targetFrequency = snd->idleFrequency; targetVolume = snd->idleVolume; } if (transmissionInGear == true) { if (!(soundPlayer->isVehicle2()) || train.cars.firstCar.front->wheelSlipping == 0) { auto speed = std::max(vehType2_2->currentSpeed, 7.0_mph); auto frequency = snd->firstGearFrequency; if (speed >= snd->firstGearSpeed) { frequency -= snd->secondGearFreqOffset; if (speed >= snd->secondGearSpeed) { frequency -= snd->thirdGearFreqOffset; if (speed >= snd->thirdGearSpeed) { frequency -= snd->fourthGearFreqOffset; } } } targetFrequency = (speed.getRaw() >> snd->speedFreqFactor) + frequency; } else { targetFrequency = snd->idleFrequency; targetVolume = snd->idleVolume; } } if (soundPlayer->drivingSoundId == 0xFF) { // Half soundPlayer->drivingSoundVolume = snd->idleVolume >> 1; // Quarter soundPlayer->drivingSoundFrequency = snd->idleFrequency >> 2; soundPlayer->drivingSoundId = snd->soundObjectId; return; } if (soundPlayer->drivingSoundFrequency != targetFrequency) { if (soundPlayer->drivingSoundFrequency > targetFrequency) { targetVolume = snd->coastingVolume; soundPlayer->drivingSoundFrequency = std::max<uint16_t>(targetFrequency, soundPlayer->drivingSoundFrequency - snd->freqDecreaseStep); } else { soundPlayer->drivingSoundFrequency = std::min<uint16_t>(targetFrequency, soundPlayer->drivingSoundFrequency + snd->freqIncreaseStep); } } if (soundPlayer->drivingSoundVolume != targetVolume) { if (soundPlayer->drivingSoundVolume > targetVolume) { soundPlayer->drivingSoundVolume = std::max<uint8_t>(targetVolume, soundPlayer->drivingSoundVolume - snd->volumeDecreaseStep); } else { soundPlayer->drivingSoundVolume = std::min<uint8_t>(targetVolume, soundPlayer->drivingSoundVolume + snd->volumeIncreaseStep); } } soundPlayer->drivingSoundId = snd->soundObjectId; } // Returns veh1, veh2 position static std::pair<Pos2, Pos2> calculateNextPosition(const uint8_t yaw, const World::Pos2& curPos, const Vehicle1* veh1, const Speed32 speed) { auto dist = Math::Trigonometry::computeXYVector(speed.getRaw() >> 5, yaw); auto bigCoordX = veh1->var_4E + (curPos.x << 16) + dist.x; auto bigCoordY = veh1->var_50 + (curPos.y << 16) + dist.y; Pos2 veh1Pos = { static_cast<int16_t>(bigCoordX & 0xFFFF), static_cast<int16_t>(bigCoordY & 0xFFFF) }; Pos2 veh2Pos = { static_cast<int16_t>(bigCoordX >> 16), static_cast<int16_t>(bigCoordY >> 16) }; return std::make_pair(veh1Pos, veh2Pos); } // 0x004A8C11 bool VehicleHead::updateLand() { Vehicle2* vehType2 = _vehicleUpdate_2; // If don't have any running issue and is approaching if ((!vehType2->has73Flags(Flags73::isBrokenDown) || vehType2->has73Flags(Flags73::isStillPowered)) && status == Status::approaching) { if (mode == TransportMode::road) { uint8_t bl = sub_4AA36A(); if (bl == 1) { return sub_4A8DB7(); } else if (bl == 2) { return tryReverse(); } } if (hasVehicleFlags(VehicleFlags::commandStop)) { return sub_4A8CB6(); } else if (hasVehicleFlags(VehicleFlags::manualControl)) { if (manualPower <= -20) { return sub_4A8C81(); } } return landTryBeginUnloading(); } if (status == Status::unloading) { updateUnloadCargo(); return true; } else if (status == Status::loading) { return landLoadingUpdate(); } else if (status == Status::crashed) { landCrashedUpdate(); return false; } else if (status == Status::stuck) { return false; } else { status = Status::travelling; if (!vehType2->has73Flags(Flags73::isBrokenDown) || vehType2->has73Flags(Flags73::isStillPowered)) { if (!hasVehicleFlags(VehicleFlags::manualControl) || manualPower > -20) { if (!hasVehicleFlags(VehicleFlags::commandStop)) { return landNormalMovementUpdate(); } else { return sub_4A8CB6(); } } else { return sub_4A8C81(); } } else { return sub_4A8CB6(); } } } // 0x004AA36A // 0: None of the below // 1: reached first timeout at signal // 2: give up and reverse at signal uint8_t VehicleHead::sub_4AA36A() { Vehicle train(head); if (train.veh2->routingHandle != train.veh1->routingHandle || train.veh2->subPosition != train.veh1->subPosition) { train.veh1->timeAtSignal = 0; return 0; } auto param1 = 160; auto turnaroundAtSignalTimeout = kBusSignalTimeout; if (trackType == 0xFF || ObjectManager::get<RoadObject>(trackType)->hasFlags(RoadObjectFlags::isRoad)) { if (train.veh1->trackAndDirection.road.isOvertaking()) { param1 = 128; turnaroundAtSignalTimeout = 544; } } else { // Tram turnaroundAtSignalTimeout = kTramSignalTimeout; if (train.veh1->trackAndDirection.road.isOvertaking()) { param1 = 64; turnaroundAtSignalTimeout = 128; } } train.veh1->timeAtSignal++; if (train.veh1->timeAtSignal == param1) { return 1; } if (train.veh1->timeAtSignal == turnaroundAtSignalTimeout) { var_5C = 40; return 2; } return 0; } // 0x004A8DB7 bool VehicleHead::sub_4A8DB7() { sub_4AD778(); if (status == Status::approaching) { status = Status::travelling; } return true; } // 0x004A8F22 bool VehicleHead::tryReverse() { if (isOnExpectedRoadOrTrack()) { auto temp = var_52; var_52 = 1; sub_4ADB47(false); var_52 = temp; return true; } else { Vehicle train(head); train.veh2->destroyTrain(); return false; } } // 0x004A8CB6 bool VehicleHead::sub_4A8CB6() { Vehicle1* vehType1 = _vehicleUpdate_1; if (position != vehType1->position) { sub_4AD93A(); if (status == Status::approaching) { stationId = StationId::null; status = Status::travelling; } } Vehicle train(head); auto* vehType2 = train.veh2; if (vehType2->routingHandle != routingHandle || vehType2->subPosition != subPosition) { return true; } status = Status::stopped; vehType2 = _vehicleUpdate_2; if (vehType2->has73Flags(Flags73::isBrokenDown)) { stationId = StationId::null; status = Status::brokenDown; } return true; } // 0x004A8C81 bool VehicleHead::sub_4A8C81() { Vehicle2* vehType2 = _vehicleUpdate_2; if (vehType2->currentSpeed > 1.0_mph) { return landNormalMovementUpdate(); } auto foundStationId = manualFindTrainStationAtLocation(); if (foundStationId == StationId::null) { return sub_4A8CB6(); } stationId = foundStationId; setStationVisitedTypes(); checkIfAtOrderStation(); updateLastJourneyAverageSpeed(); beginUnloading(); return sub_4A8CB6(); } // 0x004A8FAC // Checks if at the desired station and then begins unloading if at it bool VehicleHead::landTryBeginUnloading() { Vehicle train(head); if (routingHandle != train.veh2->routingHandle || train.veh2->subPosition != subPosition) { return true; } // Manual control is going too fast at this point to stop at the station if (hasVehicleFlags(VehicleFlags::manualControl)) { return true; } setStationVisitedTypes(); checkIfAtOrderStation(); updateLastJourneyAverageSpeed(); beginUnloading(); return true; } // 0x004A9011 bool VehicleHead::landLoadingUpdate() { if (updateLoadCargo()) { return true; } beginNewJourney(); status = Status::stopped; advanceToNextRoutableOrder(); if (hasVehicleFlags(VehicleFlags::manualControl)) { return true; } if (pathingShouldReverse()) { return tryReverse(); } return true; } // 0x004A8D48 bool VehicleHead::landNormalMovementUpdate() { advanceToNextRoutableOrder(); auto [al, flags, nextStation] = sub_4ACEE7(0xD4CB00, _vehicleUpdate_var_113612C); if (mode == TransportMode::road) { return roadNormalMovementUpdate(al, nextStation); } else { return trainNormalMovementUpdate(al, flags, nextStation); } } // 0x004A8D8F bool VehicleHead::roadNormalMovementUpdate(uint8_t al, StationId nextStation) { uint8_t bl = sub_4AA36A(); if (bl == 1) { return sub_4A8DB7(); } else if (bl == 2) { return tryReverse(); } else if (al == 4) { status = Status::approaching; stationId = nextStation; return true; } else if (al == 2) { Vehicle train(head); if (routingHandle != train.veh2->routingHandle || train.veh2->subPosition != subPosition) { return true; } return tryReverse(); } else { return true; } } // 0x004A8D63 bool VehicleHead::trainNormalMovementUpdate(uint8_t al, uint8_t flags, StationId nextStation) { Vehicle train(head); if (al == 4) { status = Status::approaching; stationId = nextStation; return true; } else if (al == 3) { if (train.veh2->routingHandle != routingHandle || train.veh2->subPosition != subPosition) { return true; } status = Status::waitingAtSignal; if (!Config::get().trainsReverseAtSignals) { return true; } auto* vehType1 = train.veh1; vehType1->timeAtSignal++; if (hasVehicleFlags(VehicleFlags::manualControl)) { var_5C = 2; vehType1->var_48 |= Flags48::passSignal; return true; } // if one-way or two-way signal?? if (flags & (1 << 1)) { if (vehType1->timeAtSignal >= kTrainOneWaySignalTimeout) { if (flags & (1 << 7)) { return landReverseFromSignal(); } if (sub_4AC1C2()) { var_5C = 2; vehType1->var_48 |= Flags48::passSignal; return true; } return landReverseFromSignal(); } // Keep waiting at the signal return true; } else { if (!(vehType1->timeAtSignal & 0x3F)) { if (!(flags & (1 << 7))) { if (sub_4AC1C2()) { var_5C = 2; vehType1->var_48 |= Flags48::passSignal; return true; } } if (opposingTrainAtSignal()) { return landReverseFromSignal(); } } if (vehType1->timeAtSignal >= kTrainTwoWaySignalTimeout) { return landReverseFromSignal(); } // Keep waiting at the signal return true; } } else { train.veh1->timeAtSignal = 0; if (al == 2) { if (hasVehicleFlags(VehicleFlags::manualControl)) { auto* vehType2 = train.veh2; if (vehType2->routingHandle != routingHandle || vehType2->subPosition != subPosition) { return landReverseFromSignal(); } // Crash vehType2->destroyTrain(); return false; } return landReverseFromSignal(); } else { return true; } } } // 0x004A8ED9 bool VehicleHead::landReverseFromSignal() { Vehicle train(head); train.veh1->timeAtSignal = 0; if (routingHandle != train.veh2->routingHandle || train.veh2->subPosition != subPosition) { return true; } return tryReverse(); } // 0x004A9051 bool VehicleHead::updateAir() { Vehicle2* vehType2 = _vehicleUpdate_2; if (vehType2->currentSpeed >= 20.0_mph) { _vehicleUpdate_var_1136130 = 0x4000; } else { _vehicleUpdate_var_1136130 = 0x2000; } Vehicle train(head); train.cars.firstCar.body->sub_4AAB0B(); if (status == Status::stopped) { if (!hasVehicleFlags(VehicleFlags::commandStop)) { setStationVisitedTypes(); checkIfAtOrderStation(); beginUnloading(); } return true; } else if (status == Status::unloading) { updateUnloadCargo(); return true; } else if (status == Status::loading) { return airplaneLoadingUpdate(); } status = Status::travelling; auto [newStatus, targetSpeed] = airplaneGetNewStatus(); status = newStatus; Vehicle1* vehType1 = _vehicleUpdate_1; vehType1->targetSpeed = targetSpeed; advanceToNextRoutableOrder(); Speed32 type1speed = vehType1->targetSpeed; auto type2speed = vehType2->currentSpeed; if (type2speed == type1speed) { vehType2->motorState = MotorState::airplaneAtTaxiSpeed; if (type2speed != 20.0_mph) { vehType2->motorState = MotorState::coasting; } } else if (type2speed > type1speed) { vehType2->motorState = MotorState::coasting; auto decelerationAmount = 2.0_mph; if (type2speed >= 130.0_mph) { decelerationAmount = 5.0_mph; if (type2speed >= 400.0_mph) { decelerationAmount = 11.0_mph; if (type2speed >= 600.0_mph) { decelerationAmount = 25.0_mph; } } } if (type1speed == 20.0_mph) { vehType2->motorState = MotorState::braking; } type2speed = std::max<Speed32>(0.0_mph, type2speed - decelerationAmount); type2speed = std::max<Speed32>(type1speed, type2speed); vehType2->currentSpeed = type2speed; } else { vehType2->motorState = MotorState::accelerating; type2speed += 2.0_mph; type2speed = std::min<Speed32>(type2speed, type1speed); vehType2->currentSpeed = type2speed; } auto [manhattanDistance, targetZ, targetYaw] = sub_427122(); _vehicleUpdate_manhattanDistanceToStation = manhattanDistance; _vehicleUpdate_targetZ = targetZ; // Helicopter if ((_vehicleUpdate_helicopterAirportMovement & (AirportMovementNodeFlags::heliTakeoffEnd)) != AirportMovementNodeFlags::none) { _vehicleUpdate_helicopterTargetYaw = targetYaw; targetYaw = spriteYaw; vehType2->motorState = MotorState::accelerating; if (targetZ < position.z) { vehType2->motorState = MotorState::coasting; } } if (targetYaw != spriteYaw) { if (((targetYaw - spriteYaw) & 0x3F) > 0x20) { spriteYaw--; } else { spriteYaw++; } spriteYaw &= 0x3F; } Pitch targetPitch = Pitch::flat; auto vehObject = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); if (vehType2->currentSpeed < 50.0_mph && vehObject->hasFlags(VehicleObjectFlags::aircraftIsTaildragger)) { targetPitch = Pitch::up12deg; } if (targetZ > position.z) { if (vehType2->currentSpeed <= 350.0_mph) { targetPitch = Pitch::up12deg; } } if (targetZ < position.z) { if (vehType2->currentSpeed <= 180.0_mph && vehObject->hasFlags(VehicleObjectFlags::aircraftFlaresLanding)) { targetPitch = Pitch::up12deg; } } if (targetPitch != spritePitch) { if (targetPitch < spritePitch) { spritePitch = Pitch(static_cast<uint8_t>(spritePitch) - 1); } else { spritePitch = Pitch(static_cast<uint8_t>(spritePitch) + 1); } } // Helicopter if ((_vehicleUpdate_helicopterAirportMovement & AirportMovementNodeFlags::heliTakeoffEnd) != AirportMovementNodeFlags::none) { vehType2->currentSpeed = 8.0_mph; if (targetZ != position.z) { return airplaneApproachTarget(targetZ); } } else { uint32_t targetTolerance = 480; if (airportMovementEdge != kAirportMovementNodeNull) { targetTolerance = 5; if (vehType2->currentSpeed >= 70.0_mph) { targetTolerance = 30; } } if (manhattanDistance > targetTolerance) { return airplaneApproachTarget(targetZ); } } if (stationId != StationId::null && airportMovementEdge != kAirportMovementNodeNull) { auto flags = airportGetMovementEdgeTarget(stationId, airportMovementEdge).first; if ((flags & AirportMovementNodeFlags::touchdown) != AirportMovementNodeFlags::none) { produceTouchdownAirportSound(); } if ((flags & AirportMovementNodeFlags::taxiing) != AirportMovementNodeFlags::none) { updateLastJourneyAverageSpeed(); } if ((flags & AirportMovementNodeFlags::terminal) != AirportMovementNodeFlags::none) { return sub_4A95CB(); } } auto movementEdge = kAirportMovementNodeNull; if (stationId != StationId::null) { movementEdge = airportMovementEdge; } auto newMovementEdge = airportGetNextMovementEdge(movementEdge); if (newMovementEdge != static_cast<uint8_t>(-2)) { return sub_4A9348(newMovementEdge, targetZ); } if (vehType2->currentSpeed > 30.0_mph) { return airplaneApproachTarget(targetZ); } else { vehType2->currentSpeed = 0.0_mph; vehType2->motorState = MotorState::stopped; return true; } } // 0x004273DF std::pair<Status, Speed16> VehicleHead::airplaneGetNewStatus() { Vehicle train(head); if (stationId == StationId::null || airportMovementEdge == kAirportMovementNodeNull) { auto veh2 = train.veh2; auto targetSpeed = veh2->maxSpeed; if (veh2->has73Flags(Flags73::isBrokenDown)) { targetSpeed = veh2->rackRailMaxSpeed; } return std::make_pair(Status::travelling, targetSpeed); } auto station = StationManager::get(stationId); Pos3 loc = station->airportStartPos; auto tile = World::TileManager::get(loc); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != loc.z / 4) { continue; } auto airportObject = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementEdges = airportObject->getMovementEdges(); uint8_t al = movementEdges[airportMovementEdge].var_03; uint8_t cl = movementEdges[airportMovementEdge].var_00; auto veh2 = train.veh2; if (al != 0) { if (cl == 1 || al != 2) { if (al == 1) { return std::make_pair(Status::landing, veh2->rackRailMaxSpeed); } else if (al == 3) { return std::make_pair(Status::landing, 0_mph); } else if (al == 4) { return std::make_pair(Status::taxiing1, 20_mph); } else { return std::make_pair(Status::approaching, veh2->rackRailMaxSpeed); } } } if (cl == 2) { auto targetSpeed = veh2->maxSpeed; if (veh2->has73Flags(Flags73::isBrokenDown)) { targetSpeed = veh2->rackRailMaxSpeed; } return std::make_pair(Status::takingOff, targetSpeed); } else if (cl == 3) { return std::make_pair(Status::takingOff, 0_mph); } else { return std::make_pair(Status::taxiing2, 20_mph); } } // Tile not found. Todo: fail gracefully assert(false); return std::make_pair(Status::travelling, train.veh2->maxSpeed); } // 0x004A95CB bool VehicleHead::sub_4A95CB() { if (hasVehicleFlags(VehicleFlags::commandStop)) { status = Status::stopped; Vehicle2* vehType2 = _vehicleUpdate_2; vehType2->currentSpeed = 0.0_mph; } else { setStationVisitedTypes(); checkIfAtOrderStation(); beginUnloading(); } return true; } // 0x004A95F5 bool VehicleHead::airplaneLoadingUpdate() { Vehicle2* vehType2 = _vehicleUpdate_2; vehType2->currentSpeed = 0.0_mph; vehType2->motorState = MotorState::stopped; if (updateLoadCargo()) { return true; } advanceToNextRoutableOrder(); status = Status::travelling; status = airplaneGetNewStatus().first; auto movementEdge = kAirportMovementNodeNull; if (stationId != StationId::null) { movementEdge = airportMovementEdge; } auto newMovementEdge = airportGetNextMovementEdge(movementEdge); if (newMovementEdge != static_cast<uint8_t>(-2)) { // Strangely the original would enter this function with an // uninitialised targetZ. We will pass a valid z. return sub_4A9348(newMovementEdge, position.z); } status = Status::loading; return true; } // 0x004A94A9 bool VehicleHead::airplaneApproachTarget(uint16_t targetZ) { auto yaw = spriteYaw; // Helicopter if ((_vehicleUpdate_helicopterAirportMovement & AirportMovementNodeFlags::heliTakeoffEnd) != AirportMovementNodeFlags::none) { yaw = _vehicleUpdate_helicopterTargetYaw; } Vehicle1* vehType1 = _vehicleUpdate_1; Vehicle2* vehType2 = _vehicleUpdate_2; auto [veh1Loc, veh2Loc] = calculateNextPosition( yaw, position, vehType1, vehType2->currentSpeed); Pos3 newLoc(veh2Loc.x, veh2Loc.y, targetZ); vehType1->var_4E = veh1Loc.x; vehType1->var_50 = veh1Loc.y; if (targetZ != position.z) { // Final section of landing / helicopter if (_vehicleUpdate_manhattanDistanceToStation <= 28) { int16_t zShift = 1; if (vehType2->currentSpeed >= 50.0_mph) { zShift++; if (vehType2->currentSpeed >= 100.0_mph) { zShift++; } } if (targetZ < position.z) { newLoc.z = std::max<int16_t>(targetZ, position.z - zShift); } else if (targetZ > position.z) { newLoc.z = std::min<int16_t>(targetZ, position.z + zShift); } } else { int32_t zDiff = targetZ - position.z; // We want a SAR instruction so use >>5 int32_t param1 = (zDiff * toSpeed16(vehType2->currentSpeed).getRaw()) >> 5; int32_t param2 = _vehicleUpdate_manhattanDistanceToStation - 18; auto modulo = param1 % param2; if (modulo < 0) { newLoc.z = position.z + param1 / param2 - 1; } else { newLoc.z = position.z + param1 / param2 + 1; } } } movePlaneTo(newLoc, spriteYaw, spritePitch); return true; } bool VehicleHead::sub_4A9348(uint8_t newMovementEdge, uint16_t targetZ) { if (stationId != StationId::null && airportMovementEdge != kAirportMovementNodeNull) { StationManager::get(stationId)->airportMovementOccupiedEdges &= ~(1 << airportMovementEdge); } if (newMovementEdge == kAirportMovementNodeNull) { beginNewJourney(); if (sizeOfOrderTable == 1) { // 0x4a94a5 airportMovementEdge = kAirportMovementNodeNull; return airplaneApproachTarget(targetZ); } auto orders = getCurrentOrders(); auto* order = orders.begin()->as<OrderStopAt>(); if (order == nullptr) { airportMovementEdge = kAirportMovementNodeNull; return airplaneApproachTarget(targetZ); } StationId orderStationId = order->getStation(); auto station = StationManager::get(orderStationId); if (station == nullptr || (station->flags & StationFlags::flag_6) == StationFlags::none) { airportMovementEdge = kAirportMovementNodeNull; return airplaneApproachTarget(targetZ); } if (!CompanyManager::isPlayerCompany(owner)) { stationId = orderStationId; airportMovementEdge = kAirportMovementNodeNull; return airplaneApproachTarget(targetZ); } Pos3 loc = station->airportStartPos; auto tile = World::TileManager::get(loc); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != loc.z / 4) { continue; } auto airportObject = ObjectManager::get<AirportObject>(elStation->objectId()); Vehicle train(head); const auto airportType = train.cars.firstCar.front->getCompatibleAirportType(); if ((airportObject->flags & airportType) != AirportObjectFlags::none) { stationId = orderStationId; airportMovementEdge = kAirportMovementNodeNull; return airplaneApproachTarget(targetZ); } if (owner == CompanyManager::getControllingId()) { MessageManager::post( MessageType::unableToLandAtAirport, owner, enumValue(id), enumValue(orderStationId)); } airportMovementEdge = kAirportMovementNodeNull; return airplaneApproachTarget(targetZ); } // Todo: fail gracefully on tile not found assert(false); return true; // 0x004A938A } else { airportMovementEdge = newMovementEdge; if (stationId != StationId::null) { auto station = StationManager::get(stationId); station->airportMovementOccupiedEdges |= (1 << airportMovementEdge); } return airplaneApproachTarget(targetZ); } } // 0x004A9649 bool VehicleHead::updateWater() { Vehicle2* vehType2 = _vehicleUpdate_2; if (vehType2->currentSpeed >= 5.0_mph) { _vehicleUpdate_var_1136130 = 0x4000; } else { _vehicleUpdate_var_1136130 = 0x2000; } Vehicle train(head); train.cars.firstCar.body->sub_4AAB0B(); if (status == Status::stopped) { if (hasVehicleFlags(VehicleFlags::commandStop)) { return true; } if (stationId != StationId::null) { vehType2->currentSpeed = 0.0_mph; setStationVisitedTypes(); checkIfAtOrderStation(); updateLastJourneyAverageSpeed(); beginUnloading(); return true; } } if (hasVehicleFlags(VehicleFlags::commandStop)) { if ((updateWaterMotion(WaterMotionFlags::isStopping) & WaterMotionFlags::hasReachedADestination) == WaterMotionFlags::none) { return true; } status = Status::stopped; vehType2->currentSpeed = 0.0_mph; vehType2->motorState = MotorState::stopped; return true; } if (status == Status::unloading) { updateUnloadCargo(); return true; } else if (status == Status::loading) { if (updateLoadCargo()) { return true; } beginNewJourney(); advanceToNextRoutableOrder(); status = Status::travelling; status = sub_427BF2(); updateWaterMotion(WaterMotionFlags::isLeavingDock); produceLeavingDockSound(); return true; } else { status = Status::travelling; status = sub_427BF2(); advanceToNextRoutableOrder(); if ((updateWaterMotion(WaterMotionFlags::none) & WaterMotionFlags::hasReachedDock) == WaterMotionFlags::none) { return true; } if (hasVehicleFlags(VehicleFlags::commandStop)) { status = Status::stopped; vehType2->currentSpeed = 0.0_mph; vehType2->motorState = MotorState::stopped; return true; } vehType2->currentSpeed = 0.0_mph; setStationVisitedTypes(); checkIfAtOrderStation(); updateLastJourneyAverageSpeed(); beginUnloading(); return true; } } /** 0x00427122 * Seems to work out where to land or something like that. * manhattanDistance = regs.ebp * targetZ = regs.dx * targetYaw = regs.bl * airportFlags = _vehicleUpdate_var_525BB0 */ std::tuple<uint32_t, uint16_t, uint8_t> VehicleHead::sub_427122() { _vehicleUpdate_helicopterAirportMovement = AirportMovementNodeFlags::none; StationId targetStationId = StationId::null; std::optional<World::Pos3> targetPos{}; if (stationId == StationId::null) { auto orders = getCurrentOrders(); auto curOrder = orders.begin(); auto stationOrder = curOrder->as<OrderStation>(); if (curOrder->is<OrderRouteWaypoint>() || !(curOrder->hasFlags(OrderFlags::HasStation)) || stationOrder == nullptr) { targetStationId = stationId; } else { targetStationId = stationOrder->getStation(); } } else { if (airportMovementEdge == kAirportMovementNodeNull) { targetStationId = stationId; } else { auto station = StationManager::get(stationId); if ((station->flags & StationFlags::flag_6) == StationFlags::none) { targetStationId = stationId; } else { auto [flags, pos] = airportGetMovementEdgeTarget(stationId, airportMovementEdge); _vehicleUpdate_helicopterAirportMovement = flags; targetPos = pos; } } } if (!targetPos) { if (targetStationId == StationId::null) { targetPos = Pos3{ 6143, 6143, 960 }; } else { auto station = StationManager::get(targetStationId); targetPos = Pos3{ station->x, station->y, 960 }; if ((station->flags & StationFlags::flag_6) != StationFlags::none) { targetPos = Pos3{ station->airportStartPos.x, station->airportStartPos.y, 960 }; } } } auto xDiff = targetPos->x - position.x; auto yDiff = targetPos->y - position.y; auto targetYaw = calculateYaw1FromVectorPlane(xDiff, yDiff); // Manhattan distance to target auto manhattanDistance = Math::Vector::manhattanDistance2D(World::Pos2{ position }, World::Pos2{ *targetPos }); // Manhattan distance, targetZ, targetYaw return std::make_tuple(manhattanDistance, targetPos->z, targetYaw); } // 0x00427214 returns next movement edge or -2 if no valid edge or -1 for in flight uint8_t VehicleHead::airportGetNextMovementEdge(uint8_t curEdge) { auto station = StationManager::get(stationId); Pos3 loc = station->airportStartPos; auto tile = TileManager::get(loc); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != loc.z / 4) { continue; } auto airportObject = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementNodes = airportObject->getMovementNodes(); const auto movementEdges = airportObject->getMovementEdges(); if (curEdge == kAirportMovementNodeNull) { for (uint8_t movementEdge = 0; movementEdge < airportObject->numMovementEdges; movementEdge++) { const auto& transition = movementEdges[movementEdge]; if (!movementNodes[transition.curNode].hasFlags(AirportMovementNodeFlags::flag2)) { continue; } if (station->airportMovementOccupiedEdges & transition.mustBeClearEdges) { continue; } if (transition.atLeastOneClearEdges == 0) { return movementEdge; } auto occupiedAreas = station->airportMovementOccupiedEdges & transition.atLeastOneClearEdges; if (occupiedAreas == transition.atLeastOneClearEdges) { continue; } return movementEdge; } return kAirportMovementNoValidEdge; } else { uint8_t targetNode = movementEdges[curEdge].nextNode; if (status == Status::takingOff && movementNodes[targetNode].hasFlags(AirportMovementNodeFlags::takeoffEnd)) { return kAirportMovementNodeNull; } // 0x4272A5 Vehicle train(head); auto vehObject = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); if (vehObject->hasFlags(VehicleObjectFlags::aircraftIsHelicopter)) { for (uint8_t movementEdge = 0; movementEdge < airportObject->numMovementEdges; movementEdge++) { const auto& transition = movementEdges[movementEdge]; if (transition.curNode != targetNode) { continue; } if (movementNodes[transition.nextNode].hasFlags(AirportMovementNodeFlags::takeoffBegin)) { continue; } if (station->airportMovementOccupiedEdges & transition.mustBeClearEdges) { continue; } if (transition.atLeastOneClearEdges == 0) { return movementEdge; } auto occupiedAreas = station->airportMovementOccupiedEdges & transition.atLeastOneClearEdges; if (occupiedAreas == transition.atLeastOneClearEdges) { continue; } return movementEdge; } return kAirportMovementNoValidEdge; } else { for (uint8_t movementEdge = 0; movementEdge < airportObject->numMovementEdges; movementEdge++) { const auto& transition = movementEdges[movementEdge]; if (transition.curNode != targetNode) { continue; } if (movementNodes[transition.nextNode].hasFlags(AirportMovementNodeFlags::heliTakeoffBegin)) { continue; } if (station->airportMovementOccupiedEdges & transition.mustBeClearEdges) { continue; } if (transition.atLeastOneClearEdges == 0) { return movementEdge; } auto occupiedAreas = station->airportMovementOccupiedEdges & transition.atLeastOneClearEdges; if (occupiedAreas == transition.atLeastOneClearEdges) { continue; } return movementEdge; } return kAirportMovementNoValidEdge; } } } // Tile not found. Todo: fail gracefully assert(false); return kAirportMovementNodeNull; } // 0x00426E26 std::pair<AirportMovementNodeFlags, World::Pos3> VehicleHead::airportGetMovementEdgeTarget(StationId targetStation, uint8_t curEdge) { auto station = StationManager::get(targetStation); Pos3 stationLoc = station->airportStartPos; auto tile = TileManager::get(stationLoc); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != stationLoc.z / 4) { continue; } auto airportObject = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementNodes = airportObject->getMovementNodes(); const auto movementEdges = airportObject->getMovementEdges(); auto destinationNode = movementEdges[curEdge].nextNode; Pos2 loc2 = { static_cast<int16_t>(movementNodes[destinationNode].x - 16), static_cast<int16_t>(movementNodes[destinationNode].y - 16) }; loc2 = Math::Vector::rotate(loc2, elStation->rotation()); auto airportMovement = movementNodes[destinationNode]; loc2.x += 16 + stationLoc.x; loc2.y += 16 + stationLoc.y; Pos3 loc = { loc2.x, loc2.y, static_cast<int16_t>(movementNodes[destinationNode].z + stationLoc.z) }; if (!airportMovement.hasFlags(AirportMovementNodeFlags::taxiing)) { loc.z = stationLoc.z + 255; if (!airportMovement.hasFlags(AirportMovementNodeFlags::inFlight)) { loc.z = 960; } } return std::make_pair(airportMovement.flags, loc); } // Tile not found. Todo: fail gracefully assert(false); // Flags, location return std::make_pair(AirportMovementNodeFlags::none, World::Pos3{ 0, 0, 0 }); } // 0x004B980A void VehicleHead::tryCreateInitialMovementSound() { if (status != Status::travelling) { return; } if (_vehicleUpdate_initialStatus != Status::stopped && _vehicleUpdate_initialStatus != Status::waitingAtSignal) { return; } Vehicle train(head); const auto* vehObj = train.cars.firstCar.body->getObject(); if (vehObj != nullptr && vehObj->numStartSounds != 0) { auto numSounds = vehObj->numStartSounds & NumStartSounds::kMask; if (vehObj->numStartSounds & NumStartSounds::kHasCrossingWhistle) { // remove the crossing whistle from available sounds to play numSounds = std::max(numSounds - 1, 1); } auto randSoundIndex = gPrng1().randNext(numSounds - 1); auto randSoundId = Audio::makeObjectSoundId(vehObj->startSounds[randSoundIndex]); Vehicle2* veh2 = _vehicleUpdate_2; auto tileHeight = TileManager::getHeight(veh2->position); auto volume = 0; if (veh2->position.z < tileHeight.landHeight) { volume = -1500; } Audio::playSound(randSoundId, veh2->position + World::Pos3{ 0, 0, 22 }, volume, 22050); } } // 0x004B996F void VehicleHead::setStationVisitedTypes() { auto station = StationManager::get(stationId); station->var_3B2 |= (1 << static_cast<uint8_t>(vehicleType)); } // 0x004B9987 void VehicleHead::checkIfAtOrderStation() { OrderRingView orders(orderTableOffset, currentOrder); auto curOrder = orders.begin(); auto* orderStation = curOrder->as<OrderStation>(); if (orderStation == nullptr) { return; } if (orderStation->getStation() != stationId) { return; } curOrder++; currentOrder = curOrder->getOffset() - orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(id)); } // 0x004BACAF void VehicleHead::updateLastJourneyAverageSpeed() { if (!hasBreakdownFlags(BreakdownFlags::journeyStarted)) { return; } Vehicle train(*this); breakdownFlags &= ~BreakdownFlags::journeyStarted; const auto distanceTravelled = Math::Vector::distance2D(journeyStartPos, Pos2(train.veh2->position)); const auto timeInTicks = ScenarioManager::getScenarioTicks() - journeyStartTicks; auto modeModifier = [](TransportMode mode) { switch (mode) { default: case TransportMode::rail: case TransportMode::road: return 21; case TransportMode::air: return 36; case TransportMode::water: return 31; } }(mode); auto adjustedDistance = distanceTravelled * static_cast<int64_t>(modeModifier); auto adjustedTime = timeInTicks; // TODO: In the future (when we can diverge) we can just do a 64bit divide instead of // slowly bringing down the divisor and dividend by 2 until 32bit while (adjustedDistance > std::numeric_limits<uint32_t>::max()) { adjustedDistance >>= 1; adjustedTime >>= 1; } if (adjustedTime == 0) { return; } const auto averageSpeed = std::min(train.veh2->maxSpeed, Speed16(adjustedDistance / adjustedTime)); lastAverageSpeed = averageSpeed; Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(head)); const auto recordType = [](TransportMode mode) { switch (mode) { default: case TransportMode::rail: case TransportMode::road: return 0; case TransportMode::air: return 1; case TransportMode::water: return 2; } }(mode); auto records = CompanyManager::getRecords(); if (averageSpeed <= records.speed[recordType]) { return; } records.speed[recordType] = averageSpeed; records.date[recordType] = getCurrentDay(); records.company[recordType] = owner; CompanyManager::setRecords(records); MessageManager::post(MessageType::newSpeedRecord, owner, enumValue(head), enumValue(owner), recordType); companyEmotionEvent(owner, Emotion::happy); Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(owner)); } // 0x004B99E1 void VehicleHead::beginUnloading() { breakdownFlags &= ~BreakdownFlags::unk_0; status = Status::unloading; cargoTransferTimeout = 10; var_58 = 0; Vehicle train(head); train.cars.applyToComponents([](auto& component) { component.breakdownFlags |= BreakdownFlags::unk_0; }); } // 0x00426CA4 void VehicleHead::movePlaneTo(const World::Pos3& newLoc, const uint8_t newYaw, const Pitch newPitch) { Vehicle train(head); moveTo({ newLoc.x, newLoc.y, newLoc.z }); tileX = 0; train.veh1->moveTo({ newLoc.x, newLoc.y, newLoc.z }); train.veh1->tileX = 0; train.veh2->moveTo({ newLoc.x, newLoc.y, newLoc.z }); train.veh2->tileX = 0; // The first bogie of the plane is the shadow of the plane auto* shadow = train.cars.firstCar.front; shadow->invalidateSprite(); auto height = coord_t{ TileManager::getHeight(newLoc) }; shadow->moveTo({ newLoc.x, newLoc.y, height }); shadow->spriteYaw = newYaw; shadow->spritePitch = Pitch::flat; shadow->tileX = 0; shadow->invalidateSprite(); auto* body = train.cars.firstCar.body; body->invalidateSprite(); body->moveTo({ newLoc.x, newLoc.y, newLoc.z }); body->spriteYaw = newYaw; body->spritePitch = newPitch; body->tileX = 0; body->invalidateSprite(); } // 0x00427C05 // Input flags: // bit 0 : commandedToStop // bit 1 : isLeavingDock // Output flags: // bit 16 : reachedDock // bit 17 : reachedADestination WaterMotionFlags VehicleHead::updateWaterMotion(WaterMotionFlags flags) { Vehicle2* veh2 = _vehicleUpdate_2; // updates the current boats position and sets flags about position auto tile = TileManager::get(veh2->position); SurfaceElement* surface = tile.surface(); if (surface != nullptr) { auto waterHeight = surface->water(); if (waterHeight != 0) { if (surface->isIndustrial()) { surface->setIsIndustrialFlag(false); surface->setGrowthStage(0); } surface->setIndustry(IndustryId(0)); surface->setType6Flag(true); } } auto targetSpeed = 5_mph; if (stationId == StationId::null) { if ((flags & WaterMotionFlags::isStopping) == WaterMotionFlags::none) { if (!veh2->has73Flags(Flags73::isBrokenDown)) { targetSpeed = veh2->maxSpeed; } } } if (targetSpeed == veh2->currentSpeed) { veh2->motorState = MotorState::coasting; } else if (targetSpeed < veh2->currentSpeed) { veh2->motorState = MotorState::coasting; auto decelerationRate = 1.0_mph; if (veh2->currentSpeed >= 50.0_mph) { decelerationRate = 3.0_mph; } veh2->motorState = MotorState::braking; auto newSpeed = std::max(veh2->currentSpeed - decelerationRate, 0.0_mph); veh2->currentSpeed = std::max<Speed32>(targetSpeed, newSpeed); } else { veh2->motorState = MotorState::accelerating; veh2->currentSpeed = std::min<Speed32>(targetSpeed, veh2->currentSpeed + 0.333333_mph); } auto manhattanDistance = Math::Vector::manhattanDistance2D(World::Pos2{ position }, World::Pos2{ veh2->position }); auto targetTolerance = 3; if (veh2->currentSpeed >= 20.0_mph) { targetTolerance = 16; if (veh2->currentSpeed > 70.0_mph) { targetTolerance = 24; } } if (((flags & WaterMotionFlags::isLeavingDock) != WaterMotionFlags::none) || (manhattanDistance <= targetTolerance)) { flags |= WaterMotionFlags::hasReachedADestination; if ((stationId != StationId::null) && ((flags & WaterMotionFlags::isLeavingDock) == WaterMotionFlags::none)) { flags |= WaterMotionFlags::hasReachedDock; } if ((flags & WaterMotionFlags::isStopping) != WaterMotionFlags::none) { return flags; } OrderRingView orders(orderTableOffset, currentOrder); auto curOrder = orders.begin(); auto waypoint = curOrder->as<OrderRouteWaypoint>(); if (waypoint != nullptr) { auto point = waypoint->getWaypoint(); if (point.x == (position.x & 0xFFE0) && point.y == (position.y & 0xFFE0)) { currentOrder = (++curOrder)->getOffset() - orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(id)); } } if (((flags & WaterMotionFlags::isLeavingDock) == WaterMotionFlags::none) && (stationId != StationId::null)) { return flags; } if (stationId != StationId::null) { auto targetTile = TileManager::get(World::Pos2{ tileX, tileY }); StationElement* station = nullptr; for (auto& el : targetTile) { station = el.as<StationElement>(); if (station == nullptr) { continue; } if (station->isGhost() || station->isAiAllocated()) { continue; } if (station->baseZ() == tileBaseZ) { station->setFlag6(false); stationId = StationId::null; break; } } } auto pathingResult = waterPathfind(*this); moveTo({ pathingResult.headTarget, 32 }); if (pathingResult.stationId != StationId::null) { stationId = pathingResult.stationId; tileX = pathingResult.stationPos.x; tileY = pathingResult.stationPos.y; tileBaseZ = pathingResult.stationPos.z / 4; auto targetTile = TileManager::get(World::Pos2{ tileX, tileY }); StationElement* station = nullptr; for (auto& el : targetTile) { station = el.as<StationElement>(); if (station == nullptr) { continue; } if (station->isGhost() || station->isAiAllocated()) { continue; } if (station->baseZ() == tileBaseZ) { station->setFlag6(true); break; } } } } auto targetYaw = calculateYaw4FromVector(position.x - veh2->position.x, position.y - veh2->position.y); if (targetYaw != veh2->spriteYaw) { if (((targetYaw - veh2->spriteYaw) & 0x3F) > 0x20) { veh2->spriteYaw--; } else { veh2->spriteYaw++; } veh2->spriteYaw &= 0x3F; } Vehicle1* veh1 = _vehicleUpdate_1; auto [newVeh1Pos, newVeh2Pos] = calculateNextPosition(veh2->spriteYaw, veh2->position, veh1, veh2->currentSpeed); veh1->var_4E = newVeh1Pos.x; veh1->var_50 = newVeh1Pos.y; Pos3 newLocation = { newVeh2Pos.x, newVeh2Pos.y, veh2->position.z }; moveBoatTo(newLocation, veh2->spriteYaw, Pitch::flat); return flags; } // 0x00427B70 void VehicleHead::moveBoatTo(const Pos3& newLoc, const uint8_t yaw, const Pitch pitch) { Vehicle train(head); train.veh1->moveTo({ newLoc.x, newLoc.y, newLoc.z }); train.veh1->tileX = 0; train.veh2->moveTo({ newLoc.x, newLoc.y, newLoc.z }); train.veh2->tileX = 0; train.cars.firstCar.body->invalidateSprite(); train.cars.firstCar.body->moveTo({ newLoc.x, newLoc.y, newLoc.z }); train.cars.firstCar.body->spriteYaw = yaw; train.cars.firstCar.body->spritePitch = pitch; train.cars.firstCar.body->tileX = 0; train.cars.firstCar.body->invalidateSprite(); } uint8_t VehicleHead::getLoadingModifier(const VehicleBogie* bogie) { constexpr uint8_t kMinVehiclePastStationPenalty = 1; constexpr uint8_t kRailVehiclePastStationPenalty = 12; constexpr uint8_t kRoadVehiclePastStationPenalty = 2; switch (mode) { default: case TransportMode::air: case TransportMode::water: return kMinVehiclePastStationPenalty; case TransportMode::rail: { auto tile = World::TileManager::get(Pos2{ bogie->tileX, bogie->tileY }); auto direction = bogie->trackAndDirection.track.cardinalDirection(); auto trackId = bogie->trackAndDirection.track.id(); auto loadingModifier = Config::get().disableVehicleLoadPenaltyCheat ? kMinVehiclePastStationPenalty : kRailVehiclePastStationPenalty; auto* elStation = tile.trainStation(trackId, direction, bogie->tileBaseZ); if (elStation != nullptr) { if (elStation->isAiAllocated() || elStation->isGhost()) { break; } if (elStation->stationId() != stationId) { break; } loadingModifier = kMinVehiclePastStationPenalty; } return loadingModifier; } case TransportMode::road: { auto tile = World::TileManager::get(Pos2{ bogie->tileX, bogie->tileY }); auto direction = bogie->trackAndDirection.road.cardinalDirection(); auto roadId = bogie->trackAndDirection.road.id(); auto loadingModifier = Config::get().disableVehicleLoadPenaltyCheat ? kMinVehiclePastStationPenalty : kRoadVehiclePastStationPenalty; auto* elStation = tile.roadStation(roadId, direction, bogie->tileBaseZ); if (elStation != nullptr) { if (elStation->isAiAllocated() || elStation->isGhost()) { break; } if (elStation->stationId() != stationId) { break; } auto* roadStationObj = ObjectManager::get<RoadStationObject>(elStation->objectId()); if (!roadStationObj->hasFlags(RoadStationFlags::roadEnd)) { breakdownFlags |= BreakdownFlags::unk_0; } loadingModifier = kMinVehiclePastStationPenalty; } return loadingModifier; } } return kMinVehiclePastStationPenalty; } // 0x004B9A88 bool VehicleHead::updateUnloadCargoComponent(VehicleCargo& cargo, VehicleBogie* bogie) { if (cargo.qty == 0) { return false; } if (stationId == StationId::null) { return false; } auto* station = StationManager::get(stationId); auto& cargoStats = station->cargoStats[cargo.type]; if (cargoStats.isAccepted()) { station->deliverCargoToTown(cargo.type, cargo.qty); auto* sourceStation = StationManager::get(cargo.townFrom); auto stationLoc = World::Pos2{ station->x, station->y }; auto sourceLoc = World::Pos2{ sourceStation->x, sourceStation->y }; auto tilesDistance = Math::Vector::distance2D(stationLoc, sourceLoc) / 32; Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(owner)); auto* company = CompanyManager::get(owner); company->cargoUnitsTotalDelivered += cargo.qty; auto cargoDist = static_cast<uint32_t>(std::min<uint64_t>(static_cast<uint64_t>(cargo.qty) * tilesDistance, std::numeric_limits<uint32_t>::max())); company->cargoUnitsTotalDistance += cargoDist; auto cargoPayment = CompanyManager::calculateDeliveredCargoPayment(cargo.type, cargo.qty, tilesDistance, cargo.numDays); company->cargoDelivered[cargo.type] = Math::Bound::add(company->cargoDelivered[cargo.type], cargo.qty); updateLastIncomeStats(cargo.type, cargo.qty, tilesDistance, cargo.numDays, cargoPayment); var_58 += cargoPayment; station->var_3B1 = 0; station->flags |= StationFlags::flag_8; if (cargoStats.industryId != IndustryId::null) { auto* industry = IndustryManager::get(cargoStats.industryId); const auto* industryObj = industry->getObject(); for (auto i = 0; i < 3; ++i) { if (industryObj->requiredCargoType[i] != cargo.type) { continue; } industry->receivedCargoQuantityDailyTotal[i] = Math::Bound::add(industry->receivedCargoQuantityDailyTotal[i], cargo.qty); industry->receivedCargoQuantityMonthlyTotal[i] = Math::Bound::add(industry->receivedCargoQuantityMonthlyTotal[i], cargo.qty); } if (!(industry->history_min_production[0] & (1ULL << cargo.type))) { industry->history_min_production[0] |= 1ULL << cargo.type; MessageManager::post(MessageType::workersCelebrate, owner, enumValue(id), enumValue(cargoStats.industryId), enumValue(cargoStats.industryId) | (cargo.type << 8)); } auto* town = TownManager::get(industry->town); town->var_1A8 |= 1ULL << cargo.type; town = TownManager::get(station->town); town->var_1A8 |= 1ULL << cargo.type; } auto* town = TownManager::get(station->town); if (!(town->var_1A8 & (1ULL << cargo.type))) { town->var_1A8 |= 1ULL << cargo.type; MessageManager::post(MessageType::citizensCelebrate, owner, enumValue(id), enumValue(station->town), enumValue(station->town) | (cargo.type << 8)); } if (cargoStats.isAccepted()) { cargoStats.flags |= StationCargoStatsFlags::flag3; } company->var_4A0 |= 1ULL << cargo.type; } else { auto orders = getCurrentOrders(); for (auto& order : orders) { if (!(order.hasFlags(OrderFlags::HasCargo))) { return false; } auto* unloadOrder = order.as<OrderUnloadAll>(); if (unloadOrder == nullptr) { continue; } if (unloadOrder->getCargo() != cargo.type) { continue; } break; } const bool stationHadPreviousCargo = cargoStats.quantity != 0; cargoStats.quantity = Math::Bound::add(cargoStats.quantity, cargo.qty); station->updateCargoDistribution(); cargoStats.enrouteAge = Math::Bound::add(cargoStats.enrouteAge, cargo.numDays); // Change from vanilla to deal with the cargo transfer bug: // Calculate the weighted average of the present and the delivered cargo if (stationHadPreviousCargo) { // enrouteAge = enrouteAge * (1 - addedQuantity / summedQuantity) const auto multiplier = (1 << 16) - (cargo.qty << 16) / cargoStats.quantity; cargoStats.enrouteAge = (cargoStats.enrouteAge * multiplier) >> 16; } bool setOrigin = true; if (cargoStats.origin != StationId::null) { auto* cargoSourceStation = StationManager::get(cargoStats.origin); auto stationLoc = World::Pos2{ station->x, station->y }; auto cargoSourceLoc = World::Pos2{ cargoSourceStation->x, cargoSourceStation->y }; auto stationSourceDistance = Math::Vector::distance2D(stationLoc, cargoSourceLoc); auto* sourceStation = StationManager::get(cargo.townFrom); auto sourceLoc = World::Pos2{ sourceStation->x, sourceStation->y }; auto cargoSourceDistance = Math::Vector::distance2D(stationLoc, sourceLoc); if (cargoSourceDistance > stationSourceDistance) { setOrigin = false; } } if (setOrigin) { cargoStats.origin = cargo.townFrom; } } uint8_t loadingModifier = getLoadingModifier(bogie); auto* cargoObj = ObjectManager::get<CargoObject>(cargo.type); cargoTransferTimeout = static_cast<uint16_t>(std::min<uint32_t>((cargoObj->cargoTransferTime * cargo.qty * loadingModifier) / 256, std::numeric_limits<uint16_t>::max())); cargo.qty = 0; updateTrainProperties(); Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(id)); return true; } void VehicleHead::beginLoading() { status = Status::loading; cargoTransferTimeout = 10; Vehicle train(head); train.cars.applyToComponents([](auto& component) { component.breakdownFlags |= BreakdownFlags::unk_0; }); } // 0x004B9A2A void VehicleHead::updateUnloadCargo() { if (cargoTransferTimeout != 0) { cargoTransferTimeout--; return; } Vehicle train(head); for (auto& car : train.cars) { for (auto& carComponent : car) { if (carComponent.front->hasBreakdownFlags(BreakdownFlags::unk_0)) { carComponent.front->breakdownFlags &= ~BreakdownFlags::unk_0; if (carComponent.front->secondaryCargo.type == 0xFF) { return; } updateUnloadCargoComponent(carComponent.front->secondaryCargo, carComponent.front); return; } else if (carComponent.back->hasBreakdownFlags(BreakdownFlags::unk_0)) { carComponent.back->breakdownFlags &= ~BreakdownFlags::unk_0; return; } else if (carComponent.body->hasBreakdownFlags(BreakdownFlags::unk_0)) { carComponent.body->breakdownFlags &= ~BreakdownFlags::unk_0; if (carComponent.body->primaryCargo.type == 0xFF) { return; } if (updateUnloadCargoComponent(carComponent.body->primaryCargo, carComponent.back)) { carComponent.body->updateCargoSprite(); } return; } } } currency32_t cargoProfit = var_58; var_58 = 0; if (cargoProfit != 0) { if (aiThoughtId != 0xFF) { auto company = CompanyManager::get(owner); company->aiThoughts[aiThoughtId].var_80 += cargoProfit; } Vehicle2* veh2 = _vehicleUpdate_2; veh2->curMonthRevenue += cargoProfit; Vehicle1* veh1 = _vehicleUpdate_1; if (cargoProfit != 0) { veh1->var_48 |= Flags48::flag2; } CompanyManager::applyPaymentToCompany(owner, -cargoProfit, ExpenditureType(static_cast<uint8_t>(vehicleType) * 2)); auto loc = train.cars.firstCar.body->position + World::Pos3{ 0, 0, 28 }; CompanyManager::spendMoneyEffect(loc, owner, -cargoProfit); Audio::playSound(Audio::SoundId::income, loc); } beginLoading(); } // 0x004BA19D bool VehicleHead::updateLoadCargoComponent(VehicleCargo& cargo, VehicleBogie* bogie) { if (cargo.maxQty == 0) { return false; } if (stationId == StationId::null) { return false; } uint8_t loadingModifier = getLoadingModifier(bogie); auto* station = StationManager::get(stationId); auto orders = getCurrentOrders(); if (cargo.qty == 0) { // bitmask of cargo to wait for uint32_t cargoToWaitFor = 0; for (auto& order : orders) { auto* waitFor = order.as<OrderWaitFor>(); if (waitFor != nullptr) { cargoToWaitFor |= (1 << waitFor->getCargo()); } if (order.hasFlags(OrderFlags::IsRoutable)) { break; } } // bitmask of all cargo from orders uint32_t allPossibleCargoToWaitFor = 0; for (auto& order : orders) { auto* waitFor = order.as<OrderWaitFor>(); if (waitFor != nullptr) { allPossibleCargoToWaitFor |= (1 << waitFor->getCargo()); } } if (allPossibleCargoToWaitFor == 0) { allPossibleCargoToWaitFor = 0xFFFFFFFF; } auto acceptedCargo = cargo.acceptedTypes; uint8_t chosenCargo = 0xFF; uint16_t highestQty = 0; for (; acceptedCargo != 0;) { auto possibleCargo = Numerics::bitScanForward(acceptedCargo); acceptedCargo &= ~(1 << possibleCargo); if (!(allPossibleCargoToWaitFor & (1 << possibleCargo))) { continue; } if (cargoToWaitFor & (1 << possibleCargo)) { chosenCargo = possibleCargo; highestQty = std::numeric_limits<uint16_t>::max(); } else { if (highestQty < station->cargoStats[possibleCargo].quantity) { highestQty = station->cargoStats[possibleCargo].quantity; chosenCargo = possibleCargo; } } } if (highestQty != 0) { cargo.type = chosenCargo; } } for (auto& order : orders) { if (!order.hasFlags(OrderFlags::HasCargo)) { break; } auto* unloadAll = order.as<OrderUnloadAll>(); if (unloadAll != nullptr) { if (unloadAll->getCargo() == cargo.type) { return false; } } } if (cargo.qty == cargo.maxQty) { return false; } auto* cargoObj = ObjectManager::get<CargoObject>(cargo.type); auto& stationCargo = station->cargoStats[cargo.type]; auto qtyTransferred = std::min<uint16_t>(cargo.maxQty - cargo.qty, stationCargo.quantity); cargoTransferTimeout = static_cast<uint16_t>(std::min<uint32_t>((cargoObj->cargoTransferTime * qtyTransferred * loadingModifier) / 256, std::numeric_limits<uint16_t>::max())); if (stationCargo.quantity != 0) { if (cargo.qty == 0) { cargo.townFrom = stationCargo.origin; cargo.numDays = stationCargo.enrouteAge; } else { cargo.numDays = std::max(cargo.numDays, stationCargo.enrouteAge); auto* cargoSourceStation = StationManager::get(stationCargo.origin); auto stationLoc = World::Pos2{ station->x, station->y }; auto cargoSourceLoc = World::Pos2{ cargoSourceStation->x, cargoSourceStation->y }; auto stationSourceDistance = Math::Vector::distance2D(stationLoc, cargoSourceLoc); auto* sourceStation = StationManager::get(cargo.townFrom); auto sourceLoc = World::Pos2{ sourceStation->x, sourceStation->y }; auto cargoSourceDistance = Math::Vector::distance2D(stationLoc, sourceLoc); if (cargoSourceDistance >= stationSourceDistance) { cargo.townFrom = stationCargo.origin; } } } stationCargo.quantity -= qtyTransferred; station->updateCargoDistribution(); cargo.qty += qtyTransferred; const uint8_t typeAgeMap[] = { 0, 5, 3, 2, 0, 0 }; stationCargo.age = std::min(stationCargo.age, typeAgeMap[static_cast<uint8_t>(vehicleType)]); station->var_3B0 = 0; station->flags |= StationFlags::flag_7; Vehicle train(head); auto vehMaxSpeed = train.veh2->maxSpeed; auto carAgeFactor = static_cast<uint8_t>(std::min<uint32_t>(0xFF, (getCurrentDay() - bogie->creationDay) / 256)); if ((stationCargo.flags & StationCargoStatsFlags::flag2) != StationCargoStatsFlags::none) { stationCargo.vehicleSpeed = (stationCargo.vehicleSpeed + vehMaxSpeed) / 2; stationCargo.vehicleAge = (stationCargo.vehicleAge + carAgeFactor) / 2; } else { stationCargo.flags |= StationCargoStatsFlags::flag2; stationCargo.vehicleSpeed = vehMaxSpeed; stationCargo.vehicleAge = carAgeFactor; } auto* company = CompanyManager::get(owner); company->var_49C |= 1 << cargo.type; updateTrainProperties(); Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(id)); return true; } // 0x004BA142 returns false when loaded bool VehicleHead::updateLoadCargo() { if (cargoTransferTimeout != 0) { cargoTransferTimeout--; return true; } Vehicle train(head); for (auto& car : train.cars) { for (auto& carComponent : car) { if (carComponent.front->hasBreakdownFlags(BreakdownFlags::unk_0)) { carComponent.front->breakdownFlags &= ~BreakdownFlags::unk_0; if (carComponent.front->secondaryCargo.type == 0xFF) { return true; } updateLoadCargoComponent(carComponent.front->secondaryCargo, carComponent.front); return true; } else if (carComponent.back->hasBreakdownFlags(BreakdownFlags::unk_0)) { carComponent.back->breakdownFlags &= ~BreakdownFlags::unk_0; return true; } else if (carComponent.body->hasBreakdownFlags(BreakdownFlags::unk_0)) { carComponent.body->breakdownFlags &= ~BreakdownFlags::unk_0; if (carComponent.body->primaryCargo.type == 0xFF) { return true; } if (updateLoadCargoComponent(carComponent.body->primaryCargo, carComponent.back)) { carComponent.body->updateCargoSprite(); } return true; } } } auto orders = getCurrentOrders(); for (auto& order : orders) { if (!order.hasFlags(OrderFlags::HasCargo)) { currentOrder = order.getOffset() - orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(id)); break; } auto* waitFor = order.as<OrderWaitFor>(); if (waitFor == nullptr) { continue; } bool cantWait = false; for (auto& car : train.cars) { for (auto& carComponent : car) { if (carComponent.front->secondaryCargo.type == waitFor->getCargo() && carComponent.front->secondaryCargo.maxQty != carComponent.front->secondaryCargo.qty) { if (!hasBreakdownFlags(BreakdownFlags::unk_0)) { beginLoading(); return true; } if (owner == CompanyManager::getControllingId()) { MessageManager::post(MessageType::cantWaitForFullLoad, owner, enumValue(id), enumValue(stationId)); } cantWait = true; break; } if (carComponent.body->primaryCargo.type == waitFor->getCargo() && carComponent.body->primaryCargo.maxQty != carComponent.body->primaryCargo.qty) { if (!hasBreakdownFlags(BreakdownFlags::unk_0)) { beginLoading(); return true; } if (owner == CompanyManager::getControllingId()) { MessageManager::post(MessageType::cantWaitForFullLoad, owner, enumValue(id), enumValue(stationId)); } cantWait = true; break; } } if (cantWait) { break; } } } return false; } // 0x004BAC74 void VehicleHead::beginNewJourney() { // Set initial position for updateLastJourneyAverageSpeed Vehicle train(head); journeyStartTicks = ScenarioManager::getScenarioTicks(); journeyStartPos = Pos2(train.veh2->position); breakdownFlags |= BreakdownFlags::journeyStarted; } // 0x004707C0 void VehicleHead::advanceToNextRoutableOrder() { if (sizeOfOrderTable == 1) { return; } OrderRingView orders(orderTableOffset, currentOrder); for (auto& order : orders) { if (order.hasFlags(OrderFlags::IsRoutable)) { auto newOrder = order.getOffset() - orderTableOffset; if (newOrder != currentOrder) { currentOrder = newOrder; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(id)); } return; } } } // 0x00427BF2 Status VehicleHead::sub_427BF2() { return stationId == StationId::null ? Status::travelling : Status::approaching; } // 0x0042843E void VehicleHead::produceLeavingDockSound() { Vehicle train(head); const auto* vehObj = train.cars.firstCar.body->getObject(); if (vehObj != nullptr && vehObj->numStartSounds != 0) { auto randSoundIndex = gPrng1().randNext((vehObj->numStartSounds & NumStartSounds::kMask) - 1); auto randSoundId = Audio::makeObjectSoundId(vehObj->startSounds[randSoundIndex]); Vehicle2* veh2 = _vehicleUpdate_2; Audio::playSound(randSoundId, veh2->position + World::Pos3{ 0, 0, 22 }, 0, 22050); } } struct NearbyBoats { std::array<std::array<bool, 16>, 16> searchResult; // 0x00525BEC World::TilePos2 startTile; // 0x00525BE8 }; // 0x00427F1C static NearbyBoats findNearbyTilesWithBoats(const World::Pos2 pos) { const auto tilePosA = World::toTileSpace(pos) - World::TilePos2(7, 7); const auto tilePosB = World::toTileSpace(pos) + World::TilePos2(7, 7); NearbyBoats res{}; res.startTile = tilePosA; for (const auto& tileLoc : getClampedRange(tilePosA, tilePosB)) { for (auto* entity : EntityManager::EntityTileList(World::toWorldSpace(tileLoc))) { auto* vehicleEntity = entity->asBase<VehicleBase>(); if (vehicleEntity == nullptr) { continue; } if (vehicleEntity->getTransportMode() != TransportMode::water) { continue; } if (vehicleEntity->getSubType() != VehicleEntityType::body_start) { continue; } const auto resultLoc = tileLoc - res.startTile; res.searchResult[resultLoc.x][resultLoc.y] = true; } } return res; } // 0x00428379 static std::optional<WaterPathingResult> getDockTargetFromStation(StationId stationId) { auto* station = StationManager::get(stationId); for (auto i = 0U; i < station->stationTileSize; ++i) { // Remember z needs floored const auto& pos = station->stationTiles[i]; StationElement* elStation = [&pos]() -> World::StationElement* { auto tile = TileManager::get(pos); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->isGhost() || elStation->isAiAllocated()) { continue; } if (elStation->baseZ() != pos.z / World::kSmallZStep) { continue; } return elStation; } return nullptr; }(); if (elStation == nullptr) { continue; } if (elStation->stationType() != StationType::docks) { continue; } if (elStation->isFlag6()) { continue; } const auto* dockObj = ObjectManager::get<DockObject>(elStation->objectId()); const auto boatPos = Math::Vector::rotate(dockObj->boatPosition, elStation->rotation()) + pos; auto dockTarget = WaterPathingResult( boatPos + World::Pos2{ 32, 32 }, stationId, World::Pos3{ pos.x, pos.y, Numerics::floor2(pos.z, 4) }); return dockTarget; } return std::nullopt; } struct PathFindingResult { uint16_t bestScore; uint8_t cost; constexpr auto operator<=>(const PathFindingResult& rhs) const = default; }; // 0x00428237 static PathFindingResult waterPathfindToTarget(const World::TilePos2 tilePos, const MicroZ waterMicroZ, const World::TilePos2 targetOrderPos, const NearbyBoats& nearbyVehicles, uint8_t cost, const PathFindingResult& bestResult) { PathFindingResult result = bestResult; if (!validCoords(tilePos)) { return result; } auto tile = TileManager::get(tilePos); auto* elSurface = tile.surface(); if (elSurface->water() != waterMicroZ) { return result; } if (!elSurface->isLast()) { auto* elObsticle = elSurface->next(); if (elObsticle != nullptr && !elObsticle->isGhost() && !elObsticle->isAiAllocated()) { if (elObsticle->baseZ() / kMicroToSmallZStep - waterMicroZ < 1) { return result; } } } const auto nearbyIndex = tilePos - nearbyVehicles.startTile; // Vanilla made a mistake here so we only check nearby tiles if in range // TODO: When we diverge just change the cost check to >= 6 or increase the search result to 18x18 if (nearbyIndex.x >= 0 && nearbyIndex.x < 16 && nearbyIndex.y >= 0 && nearbyIndex.y < 16) { if (nearbyVehicles.searchResult[nearbyIndex.x][nearbyIndex.y]) { return result; } } auto distToTarget = toWorldSpace(tilePos - targetOrderPos); distToTarget.x = std::abs(distToTarget.x); distToTarget.y = std::abs(distToTarget.y); // Lower is better const uint16_t score = std::max(distToTarget.x, distToTarget.y) + std::min(distToTarget.x, distToTarget.y) / 16; auto newResult = PathFindingResult{ score, cost }; result = std::min(result, newResult); if (score != 0) { if (cost >= 7) { return result; } cost++; for (auto i = 0U; i < 4; ++i) { result = waterPathfindToTarget(tilePos + toTileSpace(kRotationOffset[i]), waterMicroZ, targetOrderPos, nearbyVehicles, cost, result); } } return result; } // 0x00427FC9 static WaterPathingResult waterPathfind(const VehicleHead& head) { const auto nearbyVehicles = findNearbyTilesWithBoats(head.position); auto orders = head.getCurrentOrders(); auto curOrder = orders.begin(); auto* stationOrder = curOrder->as<OrderStation>(); auto* routeOrder = curOrder->as<OrderRouteWaypoint>(); std::optional<WaterPathingResult> dockRes = std::nullopt; // 0x00525BC6 World::TilePos2 targetOrderPos{}; if (routeOrder != nullptr) { targetOrderPos = toTileSpace(routeOrder->getWaypoint()); } else if (stationOrder != nullptr) { auto targetStationId = stationOrder->getStation(); dockRes = getDockTargetFromStation(targetStationId); if (dockRes.has_value()) { targetOrderPos = toTileSpace(dockRes->headTarget); } else { auto* station = StationManager::get(targetStationId); targetOrderPos = toTileSpace(Pos2{ station->x, station->y }); } } else { targetOrderPos = toTileSpace(head.position); } Vehicle train(head); const auto& veh2 = *train.veh2; // 0x00525BE3 const uint8_t curRotation = ((veh2.spriteYaw + 7) >> 4) & 3; const auto initialTile = toTileSpace(head.position); const auto waterMicroZ = veh2.position.z / World::kMicroZStep; PathFindingResult bestResult{ std::numeric_limits<uint16_t>::max(), std::numeric_limits<uint8_t>::max() }; uint8_t bestResultDirection = 0xFFU; for (auto i = 0U; i < 4; ++i) { const auto tilePos = initialTile + toTileSpace(kRotationOffset[i]); PathFindingResult initResult{ std::numeric_limits<uint16_t>::max(), std::numeric_limits<uint8_t>::max() }; const auto pathResult = waterPathfindToTarget(tilePos, waterMicroZ, targetOrderPos, nearbyVehicles, 0, initResult); if (pathResult != initResult && (pathResult < bestResult || (pathResult == bestResult && i == curRotation))) { bestResult = pathResult; bestResultDirection = i; } } if (bestResultDirection == 0xFF) { return WaterPathingResult(toWorldSpace(initialTile) + World::Pos2(16, 16)); } if (dockRes.has_value() && bestResult == PathFindingResult{ 0, 0 }) { return dockRes.value(); } else { const auto targetPos = toWorldSpace(initialTile) + kRotationOffset[bestResultDirection] + World::Pos2(16, 16); return WaterPathingResult(targetPos); } } // 0x0042750E void VehicleHead::produceTouchdownAirportSound() { Vehicle train(head); const auto* vehObj = train.cars.firstCar.body->getObject(); if (vehObj != nullptr && vehObj->numStartSounds != 0) { auto randSoundIndex = gPrng1().randNext((vehObj->numStartSounds & NumStartSounds::kMask) - 1); auto randSoundId = Audio::makeObjectSoundId(vehObj->startSounds[randSoundIndex]); Vehicle2* veh2 = _vehicleUpdate_2; Audio::playSound(randSoundId, veh2->position + World::Pos3{ 0, 0, 22 }, 0, 22050); } } // 0x0047C722 static void sub_47C722(VehicleHead& head) { head.var_38 |= Flags38::unk_2; auto train = Vehicle(head); auto& veh1 = *train.veh1; // Clear out all routings after the first one RoutingManager::RingView ring(veh1.routingHandle); for (auto& handle : ring) { if (handle != veh1.routingHandle) { RoutingManager::setRouting(handle, RoutingManager::kAllocatedButFreeRouting); } } head.tileX = veh1.tileX; head.tileY = veh1.tileY; head.tileBaseZ = veh1.tileBaseZ; head.routingHandle = veh1.routingHandle; head.remainingDistance = veh1.remainingDistance; head.var_3C = veh1.var_3C; head.var_38 &= ~Flags38::unk_2; head.subPosition = veh1.subPosition; head.trackAndDirection = veh1.trackAndDirection; head.moveTo(veh1.position); } // 0x004AD778 void VehicleHead::sub_4AD778() { Vehicle train(head); auto& veh1 = *train.veh1; auto& veh2 = *train.veh2; if (mode == TransportMode::road) { // 0x0047C5B0 sub_47C722(*this); var_38 |= Flags38::unk_2; veh1.var_38 |= Flags38::unk_2; auto pos = World::Pos3(veh2.tileX, veh2.tileY, veh2.tileBaseZ * World::kSmallZStep); auto ring = RoutingManager::RingView(veh2.routingHandle); for (auto& handle : ring) { const auto routing = RoutingManager::getRouting(handle); TrackAndDirection::_RoadAndDirection tad{ 0, 0 }; tad._data = routing & World::Track::AdditionalTaDFlags::basicTaDMask; if (handle != veh2.routingHandle) { veh2.sub_47D959(pos, tad, false); } pos += World::TrackData::getUnkRoad(tad.basicRad()).pos; if (handle != veh2.routingHandle) { RoutingManager::setRouting(handle, RoutingManager::kAllocatedButFreeRouting); } } } else { // 0x004AD782 var_38 |= Flags38::unk_2; veh1.var_38 |= Flags38::unk_2; const auto companyId = veh2.owner; const auto trackObjId = veh2.trackType; auto pos = World::Pos3(veh2.tileX, veh2.tileY, veh2.tileBaseZ * World::kSmallZStep); RoutingManager::RingView ring(veh2.routingHandle); for (auto& handle : ring) { const auto routing = RoutingManager::getRouting(handle); TrackAndDirection::_TrackAndDirection tad{ 0, 0 }; tad._data = routing & World::Track::AdditionalTaDFlags::basicTaDMask; const auto hasSignal = routing & World::Track::AdditionalTaDFlags::hasSignal; { TrackAndDirection::_TrackAndDirection signaledTad = tad; signaledTad._data |= (routing & World::Track::AdditionalTaDFlags::hasSignal); sub_4A2AD7(pos, signaledTad, companyId, trackObjId); } if (handle != veh2.routingHandle) { if (hasSignal) { setSignalState(pos, tad, trackObjId, 0); } leaveLevelCrossing(pos, tad, 9); } pos += World::TrackData::getUnkTrack(tad._data).pos; // Clear out all routings after the first one if (handle != veh2.routingHandle) { RoutingManager::setRouting(handle, RoutingManager::kAllocatedButFreeRouting); } } } tileX = veh2.tileX; tileY = veh2.tileY; tileBaseZ = veh2.tileBaseZ; routingHandle = veh2.routingHandle; remainingDistance = veh2.remainingDistance; var_3C = 0; var_38 &= ~(Flags38::unk_2); trackAndDirection = veh2.trackAndDirection; subPosition = veh2.subPosition; moveTo(veh2.position); veh1.tileX = veh2.tileX; veh1.tileY = veh2.tileY; veh1.tileBaseZ = veh2.tileBaseZ; veh1.routingHandle = veh2.routingHandle; veh1.remainingDistance = veh2.remainingDistance; veh1.var_3C = 0; veh1.var_38 &= ~(Flags38::unk_2); veh1.trackAndDirection = veh2.trackAndDirection; veh1.subPosition = veh2.subPosition; veh1.moveTo(veh2.position); } // 0x004AA625 void VehicleHead::landCrashedUpdate() { VehicleBase* currentVehicle = this; while (currentVehicle != nullptr) { switch (currentVehicle->getSubType()) { case VehicleEntityType::head: currentVehicle->asVehicleHead()->updateSegmentCrashed(); break; case VehicleEntityType::bogie: currentVehicle->asVehicleBogie()->updateSegmentCrashed(); break; case VehicleEntityType::body_start: case VehicleEntityType::body_continued: currentVehicle->asVehicleBody()->updateSegmentCrashed(); break; case VehicleEntityType::vehicle_1: case VehicleEntityType::vehicle_2: case VehicleEntityType::tail: break; } currentVehicle = currentVehicle->nextVehicleComponent(); } } // 0x004AA64B void VehicleHead::updateSegmentCrashed() { Vehicle train(head); _vehicleUpdate_head = this; _vehicleUpdate_frontBogie = reinterpret_cast<VehicleBogie*>(0xFFFFFFFF); _vehicleUpdate_backBogie = reinterpret_cast<VehicleBogie*>(0xFFFFFFFF); _vehicleUpdate_1 = train.veh1; _vehicleUpdate_2 = train.veh2; } // 0x004A3EF6 // pos.x : ax // pos.y : cx // pos.z : dx // tad : ebp // // ebp clobbered, dl will have rotation, dh will have track id. // return: pos : ax, cx, di static World::Pos3 getTrackStartFromTad(World::Pos3 pos, uint16_t tad) { World::Pos3 adjustedPos = pos; if (tad & (1U << 2)) { auto& trackSize = World::TrackData::getUnkTrack(tad); adjustedPos += trackSize.pos; if (trackSize.rotationEnd < 12) { adjustedPos -= World::Pos3{ kRotationOffset[trackSize.rotationEnd], 0 }; } } return adjustedPos; } // 0x004A3EF6 // pos.x : ax // pos.y : cx // pos.z : dx // tad : ebp // trackType : bh static void bringTrackElementToFront(World::Pos3 pos, uint8_t trackType, uint16_t tad) { // TRACK only const auto trackStart = getTrackStartFromTad(pos, tad); const auto trackId = (tad >> 3) & 0x3F; const auto rotation = tad & 0x3; const auto& trackPieces = World::TrackData::getTrackPiece(trackId); for (auto& piece : trackPieces) { const auto piecePos = trackStart + World::Pos3(Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z); Ui::ViewportManager::invalidate(piecePos, piecePos.z, piecePos.z + 32); auto tile = TileManager::get(piecePos); World::TrackElement* beginTrackElement = nullptr; World::TrackElement* lastTrackElement = nullptr; for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { beginTrackElement = nullptr; continue; } if (elTrack->baseHeight() != piecePos.z) { beginTrackElement = nullptr; continue; } if (beginTrackElement == nullptr) { beginTrackElement = elTrack; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->sequenceIndex() != piece.index) { continue; } if (elTrack->trackObjectId() != trackType) { continue; } if (elTrack->trackId() != trackId) { continue; } if (elTrack->hasSignal() || elTrack->hasStationElement()) { break; } lastTrackElement = elTrack; break; } if (lastTrackElement == nullptr || beginTrackElement == nullptr || beginTrackElement == lastTrackElement) { continue; } // Move the track element we are on to the front of the list of track elements const bool isLastElement = lastTrackElement->isLast(); lastTrackElement->setLastFlag(false); auto* iter = lastTrackElement; while (iter > beginTrackElement) { std::swap(*iter, *(iter - 1)); iter--; } lastTrackElement->setLastFlag(isLastElement); } } // 0x0047DA8D static Sub4ACEE7Result sub_47DA8D(VehicleHead& head, uint32_t unk1, uint32_t var_113612C) { // ROAD only // 0x0112C30C uint32_t compatibleStations = 0U; for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::roadStation); ++i) { auto* roadStationObj = ObjectManager::get<RoadStationObject>(i); if (roadStationObj == nullptr) { continue; } if (roadStationObj->hasFlags(RoadStationFlags::passenger)) { if (head.trainAcceptedCargoTypes & (1U << roadStationObj->cargoType)) { compatibleStations |= (1U << i); } } else if (roadStationObj->hasFlags(RoadStationFlags::freight)) { // Eh? is this a not accepted cargo type if (!(head.trainAcceptedCargoTypes & (1U << roadStationObj->cargoType))) { compatibleStations |= (1U << i); } } else { compatibleStations |= (1U << i); } } _vehicleUpdate_compatibleRoadStationTypes = compatibleStations; { auto routings = RoutingManager::RingView(head.routingHandle); auto iter = routings.begin(); iter++; iter++; if (RoutingManager::getRouting(*iter) != RoutingManager::kAllocatedButFreeRouting) { return Sub4ACEE7Result{ 1, 0, StationId::null }; } if (RoutingManager::getRouting(*++iter) != RoutingManager::kAllocatedButFreeRouting) { return Sub4ACEE7Result{ 1, 0, StationId::null }; } } resetUpdateVar1136114Flags(); if (head.var_52 == 1) { head.remainingDistance += head.updateTrackMotion(0); } else { const int32_t distance1 = unk1 - head.var_3C; const auto distance2 = std::max(var_113612C * 4, 0xCC48U); const auto distance = std::min<int32_t>(distance1, distance2); head.var_3C += distance - head.updateTrackMotion(distance); } // NOTE: head.routingHandle can be modified by updateTrackMotion if (!hasUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00)) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } const auto pos = World::Pos3(head.tileX, head.tileY, head.tileBaseZ * World::kSmallZStep); const auto roadId = head.trackAndDirection.road.id(); const auto rotation = head.trackAndDirection.road.cardinalDirection(); const auto tile = TileManager::get(pos); auto elStation = tile.roadStation(roadId, rotation, head.tileBaseZ); if (elStation != nullptr && (elStation->isGhost() || elStation->isAiAllocated())) { elStation = nullptr; } // 0x011361F6 const auto tileStationId = elStation != nullptr ? elStation->stationId() : StationId::null; // 0x0112C32B const auto stationObjId = elStation != nullptr ? elStation->objectId() : 0xFF; auto train = Vehicle(head); const auto requiredMods = head.var_53; const auto queryMods = train.veh1->var_49; auto [nextPos, nextRotation] = World::Track::getRoadConnectionEnd(pos, head.trackAndDirection.road.basicRad()); const bool isOneWay = head.var_5C == 0 && head.var_52 != 1; auto tc = isOneWay ? World::Track::getRoadConnectionsOneWay(nextPos, nextRotation, head.owner, head.trackType, requiredMods, queryMods) : World::Track::getRoadConnections(nextPos, nextRotation, head.owner, head.trackType, requiredMods, queryMods); if (head.var_52 != 1 && tileStationId != StationId::null && tileStationId != tc.stationId && compatibleStations & (1U << stationObjId)) { auto orders = OrderRingView(head.orderTableOffset, head.currentOrder); auto curOrder = orders.begin(); auto* stationOrder = curOrder->as<OrderStation>(); bool stationProcessed = false; if (stationOrder != nullptr) { if (stationOrder->is<OrderStopAt>()) { if (tileStationId == stationOrder->getStation()) { return Sub4ACEE7Result{ 4, 0, tileStationId }; } } else if (stationOrder->is<OrderRouteThrough>()) { if (tileStationId == stationOrder->getStation()) { curOrder++; head.currentOrder = curOrder->getOffset() - head.orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head.id)); stationProcessed = true; } } } // Handles the non-express stop at any station we pass case if (!stationProcessed) { if (head.stationId != tileStationId && (train.veh1->var_48 & Flags48::expressMode) == Flags48::none) { auto* station = StationManager::get(tileStationId); if (station->owner == train.veh1->owner) { return Sub4ACEE7Result{ 4, 0, tileStationId }; } } } } if (tc.connections.empty()) { return Sub4ACEE7Result{ 2, 0, StationId::null }; } // 0x0047DD74 uint16_t connection = tc.connections[0]; if (tc.connections.size() > 1) { if (head.var_52 == 1) { connection = roadLongestPathing(head, nextPos, tc, requiredMods, queryMods); } else { Sub4AC3D3State state{}; connection = roadPathing(head, nextPos, tc, requiredMods, queryMods, compatibleStations, false, state); } connection |= (1U << 14); } if (head.trackAndDirection.road.isOvertaking() ^ head.trackAndDirection.road.isChangingLane()) { connection ^= World::Track::AdditionalTaDFlags::isOvertaking; if (head.var_52 != 1) { if (head.trackType != 0xFFU) { auto* roadObj = ObjectManager::get<RoadObject>(head.trackType); if (roadObj->hasFlags(RoadObjectFlags::isRoad)) { connection ^= World::Track::AdditionalTaDFlags::isChangingLane; } } else { connection ^= World::Track::AdditionalTaDFlags::isChangingLane; } } } // 0x0047DDFB auto routings = RoutingManager::RingView(head.routingHandle); const auto& nextHandle = *++(routings.begin()); RoutingManager::setRouting(nextHandle, connection); if (head.var_52 == 1) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } auto curOrder = OrderRingView(head.orderTableOffset, head.currentOrder).begin(); auto* waypointOrder = curOrder->as<OrderRouteWaypoint>(); if (waypointOrder == nullptr) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } auto curPos = World::Pos3(head.tileX, head.tileY, head.tileBaseZ * World::kSmallZStep); curPos += World::TrackData::getUnkRoad(head.trackAndDirection.road.basicRad()).pos; if (curPos != waypointOrder->getWaypoint()) { auto& trackSize = World::TrackData::getUnkRoad(connection & World::Track::AdditionalTaDFlags::basicRaDMask); auto connectPos = curPos + trackSize.pos; if (trackSize.rotationEnd < 12) { connectPos -= World::Pos3{ kRotationOffset[trackSize.rotationEnd], 0 }; } if (connectPos != waypointOrder->getWaypoint()) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } } curOrder++; head.currentOrder = curOrder->getOffset() - head.orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head.id)); return Sub4ACEE7Result{ 0, 0, StationId::null }; } // 0x004AD24C // Updates the target signal (targetPos, targetRouting, targetTrackType) to reflect // the state of the signal based on newRouting (and the track connections, tc). static void updateJunctionSignalLights(World::Pos3 targetPos, uint16_t targetRouting, uint8_t targetTrackType, uint16_t newRouting, const World::Track::TrackConnections& tc) { TrackAndDirection::_TrackAndDirection tad{ 0, 0 }; tad._data = targetRouting & World::Track::AdditionalTaDFlags::basicTaDMask; sfl::static_vector<int8_t, 16> unk113621F; for (const auto& otherConnection : tc.connections) { unk113621F.push_back(_vehicle_arr_4F865C[(otherConnection & World::Track::AdditionalTaDFlags::basicTaDMask) >> 2]); } const auto curUnk = _vehicle_arr_4F865C[(newRouting & World::Track::AdditionalTaDFlags::basicTaDMask) >> 2]; int8_t cl = unk113621F[0]; int8_t ch = unk113621F[0]; uint32_t ebp = 0; for (auto i = 1U; i < unk113621F.size(); ++i) { const auto unk = unk113621F[i]; cl = std::min(cl, unk); ch = std::max(ch, unk); const auto absUnk = std::abs(unk); const auto absUnk2 = std::abs(unk113621F[ebp]); if (absUnk < absUnk2) { ebp = i; } } const auto ah = unk113621F[ebp]; uint32_t lightStateFlags = 0x10; if (ah != cl) { lightStateFlags |= 1U << 30; if (curUnk < ah) { lightStateFlags |= 1U << 28; } } if (ah != ch) { lightStateFlags |= 1U << 29; if (curUnk > ah) { lightStateFlags |= 1U << 27; } } setSignalState(targetPos, tad, targetTrackType, lightStateFlags); } // 0x004ACEF1 static Sub4ACEE7Result sub_4ACEF1(VehicleHead& head, uint32_t unk1, uint32_t var_113612C) { // TRACK only // Identical to ROAD { auto routings = RoutingManager::RingView(head.routingHandle); auto iter = routings.begin(); iter++; iter++; if (RoutingManager::getRouting(*iter) != RoutingManager::kAllocatedButFreeRouting) { return Sub4ACEE7Result{ 1, 0, StationId::null }; } if (RoutingManager::getRouting(*++iter) != RoutingManager::kAllocatedButFreeRouting) { return Sub4ACEE7Result{ 1, 0, StationId::null }; } } // Identical to ROAD resetUpdateVar1136114Flags(); if (head.var_52 == 1) { head.remainingDistance += head.updateTrackMotion(0); } else { const int32_t distance1 = unk1 - head.var_3C; const auto distance2 = std::max(var_113612C * 4, 0xCC48U); const auto distance = std::min<int32_t>(distance1, distance2); head.var_3C += distance - head.updateTrackMotion(distance); } // NOTE: head.routingHandle may have changed here due to updateTrackMotion if (!hasUpdateVar1136114Flags(UpdateVar1136114Flags::unk_m00)) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } // Similar to ROAD (calls Track equivalents) const auto pos = World::Pos3(head.tileX, head.tileY, head.tileBaseZ * World::kSmallZStep); const auto trackId = head.trackAndDirection.track.id(); const auto rotation = head.trackAndDirection.track.cardinalDirection(); const auto tile = TileManager::get(pos); auto elStation = tile.trainStation(trackId, rotation, head.tileBaseZ); if (elStation != nullptr && (elStation->isGhost() || elStation->isAiAllocated())) { elStation = nullptr; } // 0x011361F6 const auto tileStationId = elStation != nullptr ? elStation->stationId() : StationId::null; auto train = Vehicle(head); const auto requiredMods = head.var_53; const auto queryMods = train.veh1->var_49; auto [nextPos, nextRotation] = World::Track::getTrackConnectionEnd(pos, head.trackAndDirection.track._data); // Quite a few differences to ROAD auto tc = World::Track::getTrackConnections(nextPos, nextRotation, head.owner, head.trackType, requiredMods, queryMods); if (head.var_52 != 1 && tileStationId != StationId::null && tileStationId != tc.stationId) { auto orders = OrderRingView(head.orderTableOffset, head.currentOrder); auto curOrder = orders.begin(); auto* stationOrder = curOrder->as<OrderStation>(); bool stationProcessed = false; if (stationOrder != nullptr) { if (stationOrder->is<OrderStopAt>()) { if (tileStationId == stationOrder->getStation()) { // Why? unsure why manual control needs this stationProcessed = true; if (!head.hasVehicleFlags(VehicleFlags::manualControl)) { return Sub4ACEE7Result{ 4, 0, tileStationId }; } } } else if (stationOrder->is<OrderRouteThrough>()) { if (tileStationId == stationOrder->getStation()) { curOrder++; head.currentOrder = curOrder->getOffset() - head.orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head.id)); stationProcessed = true; } } } // Handles the non-express stop at any station we pass case if (!stationProcessed) { if (head.stationId != tileStationId && (train.veh1->var_48 & Flags48::expressMode) == Flags48::none) { return Sub4ACEE7Result{ 4, 0, tileStationId }; } } } // 0x004AD13C if (tc.connections.empty()) { return Sub4ACEE7Result{ 2, 0, StationId::null }; } auto routings = RoutingManager::RingView(head.routingHandle); uint16_t connection = tc.connections[0]; if (tc.connections.size() > 1) { if (head.var_52 == 1) { connection = trackLongestPathing(head, nextPos, tc, requiredMods, queryMods); } else { Sub4AC3D3State state{}; connection = trackPathing(head, nextPos, tc, requiredMods, queryMods, false, state); } connection |= (1U << 14); // 0x004AD16E bringTrackElementToFront(nextPos, head.trackType, connection & World::Track::AdditionalTaDFlags::basicTaDMask); // Simplified from vanilla as I'm pretty sure its the same // NOT CONVINCED ITS THE SAME! // Walk backwards through the routings to find the previous signal // so we can work set its signal lights auto iter2 = routings.begin(); auto reversePos = pos; for (auto i = 0; i < 6; ++i, --iter2) { if (RoutingManager::getRouting(*iter2) == RoutingManager::kAllocatedButFreeRouting) { break; } const auto reverseRouting = RoutingManager::getRouting(*iter2); if (*iter2 != *routings.begin()) { auto& trackSize = World::TrackData::getUnkTrack(reverseRouting & World::Track::AdditionalTaDFlags::basicTaDMask); reversePos -= trackSize.pos; } if (reverseRouting & World::Track::AdditionalTaDFlags::hasSignal) { // 0x004AD24C updateJunctionSignalLights(reversePos, reverseRouting, head.trackType, connection, tc); break; } else if (reverseRouting & (1U << 14)) { break; } } } else { // 0x004AD347 if (tc.hasLevelCrossing) { TrackAndDirection::_TrackAndDirection tad{ 0, 0 }; tad._data = connection & World::Track::AdditionalTaDFlags::basicTaDMask; leaveLevelCrossing(nextPos, tad, 8); } if (connection & World::Track::AdditionalTaDFlags::hasSignal) { // 0x004AD3A3 TrackAndDirection::_TrackAndDirection tad{ 0, 0 }; tad._data = connection & World::Track::AdditionalTaDFlags::basicTaDMask; const auto signalState = getSignalState(nextPos, tad, head.trackType, 0U) & *_vehicleManagerIgnoreSignalFlagsMasks; if ((signalState & SignalStateFlags::blockedNoRoute) != SignalStateFlags::none) { return Sub4ACEE7Result{ 2, 0, StationId::null }; } else if ((signalState & SignalStateFlags::occupied) != SignalStateFlags::none) { // 0x004AD3F8 const auto reverseSignalState = getSignalState(nextPos, tad, head.trackType, 1U << 31); _vehicleMangled_113623B = enumValue(reverseSignalState); if (head.var_5C == 0) { train.veh1->var_48 &= ~Flags48::passSignal; return Sub4ACEE7Result{ 3, enumValue(reverseSignalState), StationId::null }; } } else { // 0x004AD469 if ((train.veh1->var_48 & Flags48::passSignal) != Flags48::none) { train.veh1->var_48 &= ~Flags48::passSignal; if (isBlockOccupied(nextPos, tad, head.owner, head.trackType)) { setSignalState(nextPos, tad, head.trackType, 8); return Sub4ACEE7Result{ 3, *_vehicleMangled_113623B, StationId::null }; } } if ((signalState & SignalStateFlags::occupiedOneWay) != SignalStateFlags::none) { // 0x004AD490 if (train.veh1->var_52 != 0) { _vehicleMangled_113623B = *_vehicleMangled_113623B | (1U << 7); train.veh1->var_52--; return Sub4ACEE7Result{ 3, *_vehicleMangled_113623B, StationId::null }; } else { if (!(sub_4A2A77(nextPos, tad, head.owner, head.trackType) & ((1U << 0) | (1U << 1)))) { _vehicleMangled_113623B = *_vehicleMangled_113623B | (1U << 7); train.veh1->var_52 = 55; return Sub4ACEE7Result{ 3, *_vehicleMangled_113623B, StationId::null }; } } } } // 0x004AD4B1 setReverseSignalOccupiedInBlock(nextPos, tad, head.owner, head.trackType); if (head.var_5C == 0) { setSignalState(nextPos, tad, head.trackType, 1); } uint8_t edi = 2; auto reversePos = pos; for (auto iter3 = routings.begin(); RoutingManager::getRouting(*iter3) != RoutingManager::kAllocatedButFreeRouting; --iter3) { const auto reverseRouting = RoutingManager::getRouting(*iter3); if (*iter3 != *routings.begin()) { auto& trackSize = World::TrackData::getUnkTrack(reverseRouting & World::Track::AdditionalTaDFlags::basicTaDMask); reversePos -= trackSize.pos; } if (reverseRouting & World::Track::AdditionalTaDFlags::hasSignal) { auto reverseTad = TrackAndDirection::_TrackAndDirection{ 0, 0 }; reverseTad._data = reverseRouting & World::Track::AdditionalTaDFlags::basicTaDMask; setSignalState(reversePos, reverseTad, head.trackType, edi); edi = std::min(edi + 1, 3); } } } } // 0x004AD5F1 // Mostly the same as ROAD but with track equivalent functions const auto& nextHandle = *++(routings.begin()); RoutingManager::setRouting(nextHandle, connection); if (head.var_52 == 1) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } auto curOrder = OrderRingView(head.orderTableOffset, head.currentOrder).begin(); auto* waypointOrder = curOrder->as<OrderRouteWaypoint>(); if (waypointOrder == nullptr) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } auto curPos = nextPos; const auto waypointTaD = (waypointOrder->getTrackId() << 3) | waypointOrder->getDirection(); if (curPos != waypointOrder->getWaypoint() || (connection & World::Track::AdditionalTaDFlags::basicTaDMask) != waypointTaD) { auto& trackSize = World::TrackData::getUnkTrack(connection & World::Track::AdditionalTaDFlags::basicTaDMask); auto connectPos = curPos + trackSize.pos; if (trackSize.rotationEnd < 12) { connectPos -= World::Pos3{ kRotationOffset[trackSize.rotationEnd], 0 }; } auto reverseTaD = (connection & World::Track::AdditionalTaDFlags::basicTaDMask); reverseTaD ^= (1U << 2); reverseTaD &= ~0x3; reverseTaD |= World::kReverseRotation[trackSize.rotationEnd] & 0x3; if (connectPos != waypointOrder->getWaypoint() || reverseTaD != waypointTaD) { return Sub4ACEE7Result{ 0, 0, StationId::null }; } } curOrder++; head.currentOrder = curOrder->getOffset() - head.orderTableOffset; Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head.id)); return Sub4ACEE7Result{ 0, 0, StationId::null }; } // 0x004ACEE7 Sub4ACEE7Result VehicleHead::sub_4ACEE7(uint32_t unk1, uint32_t var_113612C) { if (mode == TransportMode::road) { return sub_47DA8D(*this, unk1, var_113612C); } else { return sub_4ACEF1(*this, unk1, var_113612C); } } // 0x004AC1C2 bool VehicleHead::sub_4AC1C2() { const auto [nextPos, rotation] = World::Track::getTrackConnectionEnd(getTrackLoc(), trackAndDirection.track._data); auto tc = World::Track::getTrackConnections(nextPos, rotation, owner, trackType, 0, 0); if (tc.connections.size() != 1) { return false; } TrackAndDirection::_TrackAndDirection tad((tc.connections.front() & World::Track::AdditionalTaDFlags::basicTaDMask) >> 3, tc.connections.front() & 0x7); return sub_4A2A58(nextPos, tad, owner, trackType) & (1 << 1); } // 0x004AC0A3 bool VehicleHead::opposingTrainAtSignal() { // Works out if there is an opposing train in the tile 2 ahead (i.e. waiting at a signal) // The train could be on any of the multiple connections on that tile. const auto [nextPos, rotation] = World::Track::getTrackConnectionEnd(getTrackLoc(), trackAndDirection.track._data); auto tc1 = World::Track::getTrackConnections(nextPos, rotation, owner, trackType, 0, 0); if (tc1.connections.size() != 1) { return false; } const auto [nextNextPos, nextRotation] = World::Track::getTrackConnectionEnd(nextPos, tc1.connections.front() & Track::AdditionalTaDFlags::basicTaDMask); auto tc2 = World::Track::getTrackConnections(nextNextPos, nextRotation, owner, trackType, 0, 0); if (tc2.connections.empty()) { return false; } for (auto c : tc2.connections) { TrackAndDirection::_TrackAndDirection tad{ 0, 0 }; tad._data = c & Track::AdditionalTaDFlags::basicTaDMask; auto& trackSize = World::TrackData::getUnkTrack(tad._data); auto pos = nextNextPos + trackSize.pos; if (trackSize.rotationEnd < 12) { pos -= World::Pos3{ kRotationOffset[trackSize.rotationEnd], 0 }; } auto reverseTad = tad; reverseTad.setReversed(!tad.isReversed()); for (auto* v : VehicleManager::VehicleList()) { Vehicle vehicle(v->head); auto* veh2 = vehicle.veh2; if (veh2->tileX == pos.x && veh2->tileY == pos.y && veh2->tileBaseZ == pos.z / World::kSmallZStep && veh2->trackAndDirection.track == reverseTad) { return true; } } } return false; } struct Sub4AC884State { uint16_t recursionDepth; // 0x0113642C uint16_t unkFlags; // 0x0113642E this is a result uint32_t totalTrackWeighting; // 0x01136430 }; static void roadAimlessWanderPathingRecurse(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods, Sub4AC884State& state) { if (state.recursionDepth >= 5) { return; } auto curPos = pos; TrackAndDirection::_RoadAndDirection curTad{ 0, 0 }; curTad._data = tad; for (; true;) { state.totalTrackWeighting += World::TrackData::getRoadMiscData(curTad.id()).unkWeighting; if (state.totalTrackWeighting > 1280) { break; } auto [nextPos, nextRotation] = Track::getRoadConnectionEnd(curPos, curTad._data & World::Track::AdditionalTaDFlags::basicTaDMask); auto tc = World::Track::getRoadConnectionsOneWay(nextPos, nextRotation, companyId, roadObjectId, requiredMods, queryMods); if (tc.connections.empty()) { break; } curPos = nextPos; curTad._data = tc.connections.front() & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; if (tc.connections.size() == 1) { continue; } for (auto& connection : tc.connections) { const auto connectTad = connection & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; auto recurseState = state; recurseState.recursionDepth++; roadAimlessWanderPathingRecurse(curPos, connectTad, companyId, roadObjectId, requiredMods, queryMods, recurseState); state.unkFlags |= recurseState.unkFlags; } break; } } // 0x0047E481 // pos.x : ax // pos.y : cx // pos.z : dx // tad : bp // companyId : bl // trackType : bh // requiredMods : 0x0113601A // queryMods : 0x0113601B // state : see above static uint16_t roadAimlessWanderPathing(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods) { Sub4AC884State state{}; roadAimlessWanderPathingRecurse(pos, tad, companyId, roadObjectId, requiredMods, queryMods, state); return state.unkFlags; } // TODO: Move to TrackData static constexpr std::array<uint8_t, 10> k4F7338Lane0{ 0b0100'0001, // straight 0b0100'0000, // leftCurveVerySmall 0b0100'0101, // rightCurveVerySmall 0b0100'0000, // leftCurveSmall 0b0100'0000, // rightCurveSmall 0b0100'0001, // straightSlopeUp 0b0100'0001, // straightSlopeDown 0b0100'0001, // straightSteepSlopeUp 0b0100'0001, // straightSteepSlopeDown 0b0101'0000, // turnaround }; static constexpr std::array<uint8_t, 10> k4F7338Lane1{ 0b0001'0100, // straight 0b0001'0101, // leftCurveVerySmall 0b0001'0000, // rightCurveVerySmall 0b0001'0000, // leftCurveSmall 0b0001'0000, // rightCurveSmall 0b0001'0100, // straightSlopeUp 0b0001'0100, // straightSlopeDown 0b0001'0100, // straightSteepSlopeUp 0b0001'0100, // straightSteepSlopeDown 0b0101'0000, // turnaround }; static constexpr std::array<std::array<uint8_t, 10>, 2> k4F7338{ k4F7338Lane0, k4F7338Lane1, }; static constexpr std::array<std::array<uint8_t, 10>, 2> kRightHand4F7338{ k4F7338Lane1, k4F7338Lane0, }; // 0x0112C32C static const std::array<std::array<uint8_t, 10>, 2>& getRoadUnkThing() { // TODO: rework after 0x0047D9F2 is implemented and hooked return getGameState().trafficHandedness ? kRightHand4F7338 : k4F7338; } // 0x0047D5D6 // pos.x : ax // pos.y : cx // pos.z : dl * kWorld::kSmallZStep // tad : bp (was ebp need to check high word is zero) // return: dh RoadOccupationFlags getRoadOccupation(const World::Pos3 pos, const TrackAndDirection::_RoadAndDirection tad) { if (World::TrackData::getRoadMiscData(tad.id()).reverseLane != 1) { // 0x0047D6F2 bool isBackToFront = tad.isOvertaking(); auto startPos = pos; if (tad.isReversed()) { auto& roadSize = World::TrackData::getUnkRoad(tad.basicRad()); startPos += roadSize.pos; if (roadSize.rotationEnd < 12) { startPos -= World::Pos3{ kRotationOffset[roadSize.rotationEnd], 0 }; } isBackToFront = !isBackToFront; } const auto startRot = tad.cardinalDirection(); const auto roadId = tad.id(); const World::RoadElement* compatibleElRoad = nullptr; const auto& roadPieces = TrackData::getRoadPiece(roadId); for (const auto& piece : roadPieces) { const auto curPos = startPos + World::Pos3(Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, startRot), piece.z); const auto tile = TileManager::get(curPos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (std::abs(elRoad->baseZ() - (curPos.z / World::kSmallZStep)) > 4) { continue; } bool isCompatible = elRoad->rotation() == startRot || elRoad->sequenceIndex() == piece.index; bool isOverLap = !isCompatible || elRoad->roadId() != roadId; if (isCompatible) { compatibleElRoad = elRoad; } const uint8_t lane = isBackToFront ^ isOverLap ? 0b10 : 0b01; if (!(elRoad->unk4u() & lane)) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (roadObj->hasFlags(RoadObjectFlags::isOneWay)) { return RoadOccupationFlags::isOneWay | RoadOccupationFlags::isLaneOccupied; } return RoadOccupationFlags::isLaneOccupied; } } if (compatibleElRoad == nullptr) { return RoadOccupationFlags::none; } auto* roadObj = ObjectManager::get<RoadObject>(compatibleElRoad->roadObjectId()); if (roadObj->hasFlags(RoadObjectFlags::isOneWay)) { return RoadOccupationFlags::isOneWay; } return RoadOccupationFlags::none; } else { // 0x0047D5EF const auto tile = TileManager::get(pos); const auto rotation = tad.cardinalDirection() * 2; const auto dh = std::rotl(getRoadUnkThing()[tad.isOvertaking() ^ tad.isReversed()][tad.id()], rotation); RoadOccupationFlags res = RoadOccupationFlags::none; for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (std::abs(elRoad->baseZ() - (pos.z / World::kSmallZStep)) > 4) { continue; } if (elRoad->hasStationElement()) { res |= RoadOccupationFlags::hasStation; } const auto al = std::rotl(getRoadUnkThing()[0][elRoad->roadId()], elRoad->rotation() * 2); if (al & dh) { if (elRoad->hasLevelCrossing()) { res |= RoadOccupationFlags::hasLevelCrossing; if (elRoad->hasUnk7_10()) { res |= RoadOccupationFlags::isLevelCrossingClosed; } } if (elRoad->unk4u() & 0b01) { res |= RoadOccupationFlags::isLaneOccupied; } const auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (roadObj->hasFlags(RoadObjectFlags::isOneWay)) { res |= RoadOccupationFlags::isOneWay; } } const auto al2 = std::rotl(getRoadUnkThing()[1][elRoad->roadId()], elRoad->rotation() * 2); if (al2 & dh) { if (elRoad->hasLevelCrossing()) { res |= RoadOccupationFlags::hasLevelCrossing; if (elRoad->hasUnk7_10()) { res |= RoadOccupationFlags::isLevelCrossingClosed; } } if (elRoad->unk4u() & 0b10) { res |= RoadOccupationFlags::isLaneOccupied; } const auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (roadObj->hasFlags(RoadObjectFlags::isOneWay)) { res |= RoadOccupationFlags::isOneWay; } } } return res; } } struct Sub4AC94FState { uint16_t recursionDepth; // 0x0113642C uint32_t totalTrackWeighting; // 0x01136430 RoutingResult result; }; struct Sub4AC94FTarget { StationId stationId; // 0x0113644A Pos3 pos; // 0x0113645A uint16_t tad; // 0x01136460 Pos3 reversePos; // 0x01136462 uint16_t reverseTad; // 0x01136468 }; // 0x004AC9FD & 0x0047E5E8 // Returns true if this is the best route so far and we should stop processing this route. // Unsure why we continue processing the route if it is not the best route static bool processReachedTargetRouteEnd(Sub4AC94FState& state) { if (state.result.bestDistToTarget != 0 || state.totalTrackWeighting <= state.result.bestTrackWeighting) { state.result.bestDistToTarget = 0; state.result.bestTrackWeighting = state.totalTrackWeighting; if (state.result.signalState == RouteSignalState::null) { state.result.signalState = RouteSignalState::noSignals; // This is the No signals best root } return true; } return false; } // 0x0047E582 static void roadUpdateDistanceToTarget(const Pos3 curPos, const Sub4AC94FTarget& target, Sub4AC94FState& state) { const auto dist = Math::Vector::manhattanDistance3D(curPos, target.pos); if (dist <= state.result.bestDistToTarget) { if (dist < state.result.bestDistToTarget || state.totalTrackWeighting <= state.result.bestTrackWeighting) { state.result.bestDistToTarget = static_cast<uint16_t>(dist); state.result.bestTrackWeighting = state.totalTrackWeighting; } } } static void roadTargetedPathingRecurse(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods, const uint32_t allowedStationTypes, const Sub4AC94FTarget& target, Sub4AC94FState& state) { // 0x01135FAE (copy in from the tc) StationId curStationId = StationId::null; uint8_t curStationObjId = 0; if (state.recursionDepth >= 5) { return; } auto curPos = pos; TrackAndDirection::_RoadAndDirection curTad{ 0, 0 }; curTad._data = tad; for (; true;) { bool hasReachedTarget = false; if (target.stationId != StationId::null) { if (curStationId == target.stationId) { if (allowedStationTypes & (1U << curStationObjId)) { const auto forwardRes = getRoadOccupation(curPos, curTad); if ((forwardRes & RoadOccupationFlags::hasStation) != RoadOccupationFlags::none) { if ((forwardRes & RoadOccupationFlags::isLaneOccupied) == RoadOccupationFlags::none) { hasReachedTarget = true; } else { auto reverseTad = curTad; reverseTad.setReversed(!reverseTad.isReversed()); const auto backwardRes = getRoadOccupation(curPos, reverseTad); if ((backwardRes & RoadOccupationFlags::isLaneOccupied) == RoadOccupationFlags::none) { hasReachedTarget = true; } } } } } } else { if (curPos == target.pos && (curTad.basicRad()) == target.tad) { hasReachedTarget = true; } else if (curPos == target.reversePos && (curTad.basicRad()) == target.reverseTad) { hasReachedTarget = true; } } if (hasReachedTarget) { if (processReachedTargetRouteEnd(state)) { break; } } else { roadUpdateDistanceToTarget(curPos, target, state); } // 0x0047E696 state.totalTrackWeighting += World::TrackData::getRoadMiscData(curTad.id()).unkWeighting; if (state.totalTrackWeighting > 1280) { break; } auto [nextPos, nextRotation] = Track::getRoadConnectionEnd(curPos, curTad.basicRad()); auto rc = World::Track::getRoadConnectionsOneWay(nextPos, nextRotation, companyId, roadObjectId, requiredMods, queryMods); if (rc.connections.empty()) { break; } curPos = nextPos; curTad._data = rc.connections.front() & 0x807FU; curStationId = rc.stationId; curStationObjId = rc.stationObjectId; if (rc.connections.size() == 1) { continue; } for (auto& connection : rc.connections) { const auto connectTad = connection & 0x807FU; auto recurseState = state; recurseState.recursionDepth++; roadTargetedPathingRecurse(curPos, connectTad, companyId, roadObjectId, requiredMods, queryMods, allowedStationTypes, target, recurseState); // TODO: May need to copy over results state.result.signalState = std::min(state.result.signalState, recurseState.result.signalState); state.result.bestDistToTarget = recurseState.result.bestDistToTarget; state.result.bestTrackWeighting = recurseState.result.bestTrackWeighting; } break; } } // 0x0047E50A // pos.x : ax // pos.y : cx // pos.z : dx // tad : bp // companyId : bl // trackType : bh // requiredMods : 0x0113601A // queryMods : 0x0113601B // allowedStationTypes : 0x0112C30C // target : see above // state : see above static RoutingResult roadTargetedPathing(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods, const uint32_t allowedStationTypes, const Sub4AC94FTarget& target) { Sub4AC94FState state{}; state.result.bestDistToTarget = std::numeric_limits<uint16_t>::max(); state.result.bestTrackWeighting = std::numeric_limits<uint32_t>::max(); state.result.signalState = RouteSignalState::null; roadTargetedPathingRecurse(pos, tad, companyId, roadObjectId, requiredMods, queryMods, allowedStationTypes, target, state); return state.result; } constexpr static std::array<uint16_t, 8> k500234 = { 10, 0, 70, 70, 40, 40, 70, 70, }; // 0x0047E2B6 static bool isRoadRoutingResultBetter(const RoutingResult& base, const RoutingResult& newResult) { // Routing results for road only have two signal states: null and noSignals (route found to destination) // Unfortunately vanilla copied over some logic from track which has more signal // state and so the logic here is a bit convoluted. const bool newReachedTarget = newResult.bestDistToTarget == 0; const bool baseReachedTarget = base.bestDistToTarget == 0; // None of this logic makes much sense but i think it matches vanilla if (newReachedTarget && newResult.signalState != RouteSignalState::null) { if (base.signalState == RouteSignalState::null) { return true; } if (!baseReachedTarget) { return true; } return newResult.bestTrackWeighting < base.bestTrackWeighting; } if (baseReachedTarget && base.signalState != RouteSignalState::null) { return false; } if (newResult.signalState == RouteSignalState::null) { if (newResult.bestDistToTarget < base.bestDistToTarget) { return true; } else if (newResult.bestDistToTarget == base.bestDistToTarget) { return newResult.bestTrackWeighting < base.bestTrackWeighting; } return false; } else { if (base.signalState == RouteSignalState::null) { return true; } if (newResult.bestDistToTarget < base.bestDistToTarget) { return true; } else if (newResult.bestDistToTarget == base.bestDistToTarget) { return newResult.bestTrackWeighting < base.bestTrackWeighting; } return false; } // TODO: Replace the above with the following when we want to diverge from vanilla // // if (newResult.signalState < base.signalState) //{ // return true; //} //// Road only has two signal states so we don't need to consider > base.signalState // if (newResult.bestDistToTarget < base.bestDistToTarget) //{ // return true; // } // else if (newResult.bestDistToTarget == base.bestDistToTarget) //{ // return newResult.bestTrackWeighting < base.bestTrackWeighting; // } // return false; } // 0x0047DFD0 static uint16_t roadPathing(VehicleHead& head, const World::Pos3 pos, const Track::RoadConnections& rc, const uint8_t requiredMods, const uint8_t queryMods, const uint32_t allowedStationTypes, bool isSecondRun, Sub4AC3D3State& state) { // ROAD only state.hadNewResult = 0; // isSecondRun is a second run flag if (!isSecondRun) { state.result.signalState = RouteSignalState::null; } // 0x01136438 uint32_t randVal = gPrng1().randNext(); const auto companyId = head.owner; const auto roadObjId = head.trackType; // TODO: Lots of similar code to track auto orders = head.getCurrentOrders(); auto curOrder = orders.begin(); auto* stationOrder = curOrder->as<OrderStation>(); auto* routeOrder = curOrder->as<OrderRouteWaypoint>(); if (stationOrder != nullptr || routeOrder != nullptr) { Sub4AC94FTarget target{}; if (stationOrder != nullptr) { // 0x0047E0F3 target.stationId = stationOrder->getStation(); auto* station = StationManager::get(target.stationId); target.pos = World::Pos3{ station->x, station->y, station->z }; } else { // 0x0047E033 target.stationId = StationId::null; target.pos = routeOrder->getWaypoint(); target.tad = (routeOrder->getTrackId() << 3) | routeOrder->getDirection(); const auto& trackSize = TrackData::getUnkRoad(target.tad); target.reversePos = target.pos + trackSize.pos; if (trackSize.rotationEnd < 12) { target.reversePos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } target.reverseTad = target.tad ^ (1U << 2); // Reverse } // 0x004AC5F5 uint32_t bestConnection = 0; for (auto i = 0U; i < rc.connections.size(); ++i) { const auto connection = rc.connections[i] & World::Track::AdditionalTaDFlags::basicRaDWithSignalMask; const auto connectionTad = connection & World::Track::AdditionalTaDFlags::basicRaDMask; if ((pos == target.pos && connectionTad == target.tad) || (pos == target.reversePos && connectionTad == target.reverseTad)) { state.result.signalState = RouteSignalState::noSignals; state.result.bestDistToTarget = 0; state.result.bestTrackWeighting = 0; state.hadNewResult = 1; return rc.connections[i]; } auto newResult = roadTargetedPathing(pos, connection, companyId, roadObjId, requiredMods, queryMods, allowedStationTypes, target); if ((state.hadNewResult == 0 && !isSecondRun) || isRoadRoutingResultBetter(state.result, newResult)) { // 0x004AC807 state.result = newResult; state.hadNewResult = 1; bestConnection = i; } // 0x004AC83C } return rc.connections[bestConnection]; } else { uint16_t bestValue = 0; uint16_t bestConnection = 0; // aimless wander pathing for (auto i = 0U; i < rc.connections.size(); ++i) { const auto connection = rc.connections[i] & World::Track::AdditionalTaDFlags::basicRaDWithSignalMask; const auto flags = roadAimlessWanderPathing(pos, connection, companyId, roadObjId, requiredMods, queryMods); const auto newValue = k500234[flags] + (randVal & 0x7); if (newValue >= bestValue) { bestValue = newValue; bestConnection = i; } randVal = std::rotr(randVal, 3); } return rc.connections[bestConnection]; } } struct Sub47E72FState { uint16_t recursionDepth; // 0x0113642C uint32_t totalTrackWeighting; // 0x01136430 uint32_t bestTrackWeighting; // 0x01136434 }; static void roadLongestPathingCalculateRecurse(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods, Sub47E72FState& state) { if (state.recursionDepth >= 5) { return; } auto curPos = pos; TrackAndDirection::_RoadAndDirection curTad{ 0, 0 }; curTad._data = tad; for (; true;) { // TODO: This is a vanilla mistake where it accesses the wrong data! // CHANGE THIS WHEN WE DIVERGE FROM VANILLA state.totalTrackWeighting += World::TrackData::getTrackMiscData(curTad.id()).unkWeighting; // state.totalTrackWeighting += World::TrackData::getRoadMiscData(curTad.id()).unkWeighting; if (state.totalTrackWeighting > 1280) { break; } state.bestTrackWeighting = std::max(state.bestTrackWeighting, state.totalTrackWeighting); auto [nextPos, nextRotation] = Track::getRoadConnectionEnd(curPos, curTad._data & World::Track::AdditionalTaDFlags::basicTaDMask); auto tc = World::Track::getRoadConnections(nextPos, nextRotation, companyId, roadObjectId, requiredMods, queryMods); if (tc.connections.empty()) { break; } curPos = nextPos; curTad._data = tc.connections.front() & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; if (tc.connections.size() == 1) { continue; } for (auto& connection : tc.connections) { const auto connectTad = connection & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; auto recurseState = state; recurseState.recursionDepth++; roadLongestPathingCalculateRecurse(curPos, connectTad, companyId, roadObjectId, requiredMods, queryMods, recurseState); state.bestTrackWeighting = recurseState.bestTrackWeighting; } break; } } // 0x0047E72F // pos.x : ax // pos.y : cx // pos.z : dx // tad : bp // companyId : bl // trackType : bh // requiredMods : 0x0113601A // queryMods : 0x0113601B static uint16_t roadLongestPathingCalculate(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods) { Sub47E72FState state{}; roadLongestPathingCalculateRecurse(pos, tad, companyId, roadObjectId, requiredMods, queryMods, state); return state.bestTrackWeighting; } // 0x0047DF4A // Finds the longest road at a junction static uint16_t roadLongestPathing(VehicleHead& head, const World::Pos3 pos, const Track::RoadConnections& rc, const uint8_t requiredMods, const uint8_t queryMods) { // ROAD only const auto companyId = head.owner; const auto roadObjId = head.trackType; uint16_t bestValue = 0; uint16_t bestConnection = 0; // No target pathing for (auto i = 0U; i < rc.connections.size(); ++i) { const auto connection = rc.connections[i] & World::Track::AdditionalTaDFlags::basicRaDWithSignalMask; const auto newValue = roadLongestPathingCalculate(pos, connection, companyId, roadObjId, requiredMods, queryMods); if (newValue >= bestValue) { bestValue = newValue; bestConnection = i; } } return rc.connections[bestConnection]; } static void trackLongestPathingCalculateRecurse(const World::Pos3 pos, const uint16_t tad, const CompanyId companyId, const uint8_t trackType, const uint8_t requiredMods, const uint8_t queryMods, Sub47E72FState& state) { if (state.recursionDepth >= 5) { return; } auto curPos = pos; TrackAndDirection::_TrackAndDirection curTad{ 0, 0 }; curTad._data = tad; for (; true;) { if (curTad._data & World::Track::AdditionalTaDFlags::hasSignal) { TrackAndDirection::_TrackAndDirection basicTad{ 0, 0 }; basicTad._data = curTad._data & ~World::Track::AdditionalTaDFlags::hasSignal; const auto sigState = ``` > [truncated] --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleManager.cpp ```cpp #include "VehicleManager.h" #include "Date.h" #include "Entities/EntityManager.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Vehicles/VehiclePickupAir.h" #include "GameCommands/Vehicles/VehiclePickupWater.h" #include "GameState.h" #include "GameStateFlags.h" #include "Map/Track/SubpositionData.h" #include "Map/Track/TrackData.h" #include "MessageManager.h" #include "OrderManager.h" #include "Orders.h" #include "RoutingManager.h" #include "SceneManager.h" #include "Ui/WindowManager.h" #include "Vehicle.h" #include "World/Company.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::VehicleManager { static loco_global<Vehicles::SignalStateFlags, 0x005220BC> _vehicleManagerIgnoreSignalFlagsMasks; // 0x004A8826 void update() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded) && !SceneManager::isEditorMode()) { for (auto* v : VehicleList()) { v->updateVehicle(); } } } // 0x004C3C54 void updateMonthly() { for (auto v : VehicleList()) { v->updateMonthly(); } } // 0x004B94CF void updateDaily() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded) && !SceneManager::isEditorMode()) { for (auto* v : VehicleList()) { v->updateDaily(); } Ui::WindowManager::invalidate(Ui::WindowType::vehicleList); } } // 0x004C39D4 uint16_t determineAvailableVehicleTypes(const Company& company) { uint16_t availableTypes = 0; for (uint32_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::vehicle); ++i) { if (!company.unlockedVehicles[i]) { continue; } const auto* vehObj = ObjectManager::get<VehicleObject>(i); if (vehObj == nullptr) { continue; } availableTypes |= 1U << enumValue(vehObj->type); } return availableTypes; } static BitSet<224> determineUnlockedVehicles(const Company& company) { const auto curYear = getCurrentYear(); BitSet<224> unlockedVehicles{}; for (uint32_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::vehicle); ++i) { const auto* vehObj = ObjectManager::get<VehicleObject>(i); if (vehObj == nullptr) { continue; } if (curYear < vehObj->designed) { continue; } if (curYear >= vehObj->obsolete) { continue; } const auto forbiddenVehicles = CompanyManager::isPlayerCompany(company.id()) ? getGameState().forbiddenVehiclesPlayers : getGameState().forbiddenVehiclesCompetitors; if (forbiddenVehicles & (1U << enumValue(vehObj->type))) { continue; } unlockedVehicles.set(i, true); } return unlockedVehicles; } // 0x004C3A0C void determineAvailableVehicles(Company& company) { company.unlockedVehicles = determineUnlockedVehicles(company); company.availableVehicles = determineAvailableVehicleTypes(company); } template<typename T> static void moveComponentToSubPosition(T& base) { base.invalidateSprite(); if (base.getTransportMode() == TransportMode::road) { auto& moveInfo = World::TrackData::getRoadSubPositon(base.getTrackAndDirection().road._data)[base.subPosition]; const auto newPos = World::Pos3{ base.tileX, base.tileY, base.tileBaseZ * World::kSmallZStep } + moveInfo.loc; base.spriteYaw = moveInfo.yaw; base.spritePitch = moveInfo.pitch; base.moveTo(newPos); } else { auto& moveInfo = World::TrackData::getTrackSubPositon(base.getTrackAndDirection().track._data)[base.subPosition]; const auto newPos = World::Pos3{ base.tileX, base.tileY, base.tileBaseZ * World::kSmallZStep } + moveInfo.loc; base.spriteYaw = moveInfo.yaw; base.spritePitch = moveInfo.pitch; base.moveTo(newPos); } base.invalidateSprite(); } // 0x004B05E4 PlaceDownResult placeDownVehicle(Vehicles::VehicleHead* const head, const coord_t x, const coord_t y, const uint8_t baseZ, const Vehicles::TrackAndDirection& unk1, const uint16_t unk2) { const auto pos = World::Pos3{ x, y, baseZ * World::kSmallZStep }; if (head->tileX != -1) { return PlaceDownResult::Okay; } auto subPosition = 0; World::Pos3 reversePos = pos; Vehicles::TrackAndDirection reverseTad = unk1; if (head->mode != TransportMode::road) { if (Vehicles::sub_4A2A58(pos, unk1.track, head->owner, head->trackType) & (1U << 0)) { return PlaceDownResult::Unk1; } if (Vehicles::isBlockOccupied(pos, unk1.track, head->owner, head->trackType)) { return PlaceDownResult::Unk1; } const auto subPositionLength = World::TrackData::getTrackSubPositon(unk1.track._data).size(); subPosition = subPositionLength - 1 - unk2; const auto& trackSize = World::TrackData::getUnkTrack(unk1.track._data); reversePos += trackSize.pos; if (trackSize.rotationEnd < 12) { reversePos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } reverseTad.track.setReversed(!unk1.track.isReversed()); } else { const auto subPositionLength = World::TrackData::getRoadSubPositon(unk1.road._data).size(); subPosition = subPositionLength - 1 - unk2; const auto& roadSize = World::TrackData::getUnkRoad(unk1.road.basicRad()); reversePos += roadSize.pos; if (roadSize.rotationEnd < 12) { reversePos -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } reverseTad.road.setReversed(!unk1.road.isReversed()); reverseTad.road._data ^= (1U << 7); if (reverseTad.road.isChangingLane()) { reverseTad.road._data ^= (1U << 7); if (!reverseTad.road.isOvertaking()) { reverseTad.road._data ^= (1U << 8); } } } Vehicles::RoutingManager::resetRoutings(head->routingHandle); Vehicles::RoutingManager::setRouting(head->routingHandle, reverseTad.track._data); if (head->mode == TransportMode::road) { if ((Vehicles::getRoadOccupation(reversePos, reverseTad.road) & (Vehicles::RoadOccupationFlags::isLaneOccupied | Vehicles::RoadOccupationFlags::isLevelCrossingClosed)) != Vehicles::RoadOccupationFlags::none) { return PlaceDownResult::Unk1; } } else { if (Vehicles::sub_4A2A58(reversePos, reverseTad.track, head->owner, head->trackType) & (1U << 0)) { return PlaceDownResult::Unk1; } if (Vehicles::isBlockOccupied(reversePos, reverseTad.track, head->owner, head->trackType)) { return PlaceDownResult::Unk1; } } // 0x004B077E auto train = Vehicles::Vehicle(*head); train.applyToComponents([&reversePos, reverseTad, subPosition, head](auto& component) { component.routingHandle = head->routingHandle; component.tileX = reversePos.x; component.tileY = reversePos.y; component.tileBaseZ = reversePos.z / World::kSmallZStep; component.subPosition = subPosition; component.trackAndDirection = reverseTad; component.remainingDistance = 0; component.var_3C = 0; moveComponentToSubPosition(component); }); _vehicleManagerIgnoreSignalFlagsMasks &= ~(Vehicles::SignalStateFlags::occupiedOneWay | Vehicles::SignalStateFlags::blockedNoRoute); Vehicles::applyVehicleObjectLength(train); auto oldVar52 = head->var_52; head->var_52 = 1; const bool failure = Vehicles::positionVehicleOnTrack(*head); head->var_52 = oldVar52; _vehicleManagerIgnoreSignalFlagsMasks |= (Vehicles::SignalStateFlags::occupiedOneWay | Vehicles::SignalStateFlags::blockedNoRoute); if (failure) { head->liftUpVehicle(); return PlaceDownResult::Unk0; } head->var_52 = 1; head->sub_4ADB47(true); head->var_52 = oldVar52; head->status = Vehicles::Status::stopped; train.veh1->var_48 |= Vehicles::Flags48::flag2; return PlaceDownResult::Okay; } // 0x004B93DC void resetIfHeadingForStation(const StationId stationId) { for (auto* v : VehicleList()) { Vehicles::Vehicle train(*v); // Stop train from heading to the station if (train.head->stationId == stationId) { train.head->stationId = StationId::null; } // Remove any station references from cargo // NOTE: Deletes the cargo! for (auto& car : train.cars) { for (auto& carComponent : car) { if (carComponent.front->secondaryCargo.townFrom == stationId) { carComponent.front->secondaryCargo.qty = 0; } if (carComponent.back->secondaryCargo.townFrom == stationId) { carComponent.back->secondaryCargo.qty = 0; } if (carComponent.body->primaryCargo.townFrom == stationId) { carComponent.body->primaryCargo.qty = 0; } } } } } // 0x004AEFB5 void deleteCar(Vehicles::Car& car) { Ui::WindowManager::invalidate(Ui::WindowType::vehicle, enumValue(car.front->head)); Ui::WindowManager::invalidate(Ui::WindowType::vehicleList); // Component before this car Vehicles::VehicleBase* previous = [&car]() { // Points to one behind the iterator Vehicles::VehicleBase* previousIter = nullptr; for (auto* iter = EntityManager::get<Vehicles::VehicleBase>(car.front->head); iter != car.front; iter = iter->nextVehicleComponent()) { previousIter = iter; } return previousIter; }(); // Component after this car Vehicles::VehicleBase* next = [&car]() { auto carIter = car.begin(); // Points to one behind the iterator auto previousCarIter = carIter; while (carIter != car.end()) { previousCarIter = carIter; carIter++; } // Last component of a car component is a body return (*previousCarIter).body->nextVehicleComponent(); }(); // Remove the whole car from the linked list previous->setNextCar(next->id); for (auto* toDeleteComponent = static_cast<Vehicles::VehicleBase*>(car.front); toDeleteComponent != next;) { // Must fetch the next before deleting the current! auto* nextDeletion = toDeleteComponent->nextVehicleComponent(); EntityManager::freeEntity(toDeleteComponent); toDeleteComponent = nextDeletion; } } // 0x004AF06E void deleteTrain(Vehicles::VehicleHead& head) { Vehicles::Vehicle train(head); EntityId viewportFollowEntity = train.veh2->id; auto main = Ui::WindowManager::getMainWindow(); if (Ui::Windows::Main::viewportIsFocusedOnEntity(*main, viewportFollowEntity)) { Ui::Windows::Main::viewportUnfocusFromEntity(*main); } Ui::WindowManager::close(Ui::WindowType::vehicle, enumValue(head.id)); auto* vehListWnd = Ui::WindowManager::find(Ui::WindowType::vehicleList, enumValue(head.owner)); if (vehListWnd != nullptr) { vehListWnd->invalidate(); Ui::Windows::VehicleList::removeTrainFromList(*vehListWnd, head.id); } // Change to vanilla, update the build window to a valid train auto* vehBuildWnd = Ui::WindowManager::find(Ui::WindowType::buildVehicle, enumValue(head.owner)); if (vehBuildWnd != nullptr) { vehBuildWnd->invalidate(); Ui::Windows::BuildVehicle::sub_4B92A5(vehBuildWnd); } // 0x004AF0A3 switch (head.mode) { case TransportMode::road: case TransportMode::rail: head.liftUpVehicle(); break; case TransportMode::air: { // Calling this GC directly as we need the result immediately // perhaps in the future this could be changed. GameCommands::VehiclePickupAirArgs airArgs{}; airArgs.head = head.id; registers regs = static_cast<registers>(airArgs); regs.bl = GameCommands::Flags::apply; GameCommands::vehiclePickupAir(regs); break; } case TransportMode::water: { // Calling this GC directly as we need the result immediately // perhaps in the future this could be changed. GameCommands::VehiclePickupWaterArgs waterArgs{}; waterArgs.head = head.id; registers regs = static_cast<registers>(waterArgs); regs.bl = GameCommands::Flags::apply; GameCommands::vehiclePickupWater(regs); } } auto* nextVeh = train.veh2->nextVehicleComponent(); while (nextVeh != nullptr && !nextVeh->isVehicleTail()) { Vehicles::Car car(nextVeh); deleteCar(car); nextVeh = train.veh2->nextVehicleComponent(); } Audio::stopVehicleNoise(head.id); Vehicles::RoutingManager::freeRoutingHandle(head.routingHandle); Vehicles::OrderManager::freeOrders(&head); MessageManager::removeAllSubjectRefs(enumValue(head.id), MessageItemArgumentType::vehicle); const auto companyId = head.owner; CompanyManager::get(companyId)->clearOwnerStatusForDeletedVehicle(head.id); EntityManager::freeEntity(train.tail); EntityManager::freeEntity(train.veh2); EntityManager::freeEntity(train.veh1); EntityManager::freeEntity(train.head); CompanyManager::get(companyId)->recalculateTransportCounts(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleManager.h ```h #pragma once #include "Entities/EntityManager.h" #include "Types.hpp" namespace OpenLoco { struct Company; } namespace OpenLoco::Vehicles { struct VehicleHead; struct Car; struct TrackAndDirection; } namespace OpenLoco::VehicleManager { using VehicleList = EntityManager::EntityList<EntityManager::EntityListIterator<Vehicles::VehicleHead>, EntityManager::EntityListType::vehicleHead>; void update(); void updateMonthly(); void updateDaily(); void determineAvailableVehicles(Company& company); uint16_t determineAvailableVehicleTypes(const Company& company); void resetIfHeadingForStation(const StationId stationId); void deleteTrain(Vehicles::VehicleHead& head); void deleteCar(Vehicles::Car& car); enum class PlaceDownResult { Okay, Unk0, Unk1 }; PlaceDownResult placeDownVehicle(Vehicles::VehicleHead* const head, const coord_t x, const coord_t y, const uint8_t baseZ, const Vehicles::TrackAndDirection& unk1, const uint16_t unk2); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Vehicles/VehicleTail.cpp ```cpp #include "Entities/EntityManager.h" #include "Map/AnimationManager.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "RoutingManager.h" #include "Vehicle.h" #include "ViewportManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; using namespace OpenLoco::World; namespace OpenLoco::Vehicles { static loco_global<int32_t, 0x0113612C> _vehicleUpdate_var_113612C; // Speed // 0x004794BC // This is enter level crossing if unk==8 and leave level crossing if unk==9 void leaveLevelCrossing(const World::Pos3& loc, const TrackAndDirection::_TrackAndDirection trackAndDirection, const uint16_t unk) { auto levelCrossingLoc = loc; if (trackAndDirection.isReversed()) { auto& trackSize = World::TrackData::getUnkTrack(trackAndDirection._data); levelCrossingLoc += trackSize.pos; if (trackSize.rotationEnd < 12) { levelCrossingLoc -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } } auto& trackPiece = World::TrackData::getTrackPiece(trackAndDirection.id()); levelCrossingLoc += World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece[0].x, trackPiece[0].y }, trackAndDirection.cardinalDirection()), 0 }; levelCrossingLoc.z += trackPiece[0].z; auto tile = World::TileManager::get(levelCrossingLoc); for (auto& el : tile) { if (el.baseZ() != levelCrossingLoc.z / 4) { continue; } auto* road = el.as<RoadElement>(); if (road == nullptr) { continue; } if (road->roadId() != 0) { continue; } road->setUnk7_10(false); if (unk != 8) { continue; } road->setUnk7_10(true); World::AnimationManager::createAnimation(1, levelCrossingLoc, levelCrossingLoc.z / 4); } Ui::ViewportManager::invalidate(levelCrossingLoc, levelCrossingLoc.z, levelCrossingLoc.z + 32, ZoomLevel::full); } // 0x004AA24A bool VehicleTail::update() { if (mode == TransportMode::air || mode == TransportMode::water) { return true; } const auto _oldRoutingHandle = routingHandle; const World::Pos3 _oldTilePos = World::Pos3(tileX, tileY, tileBaseZ * World::kSmallZStep); resetUpdateVar1136114Flags(); updateTrackMotion(*_vehicleUpdate_var_113612C); if (hasUpdateVar1136114Flags(UpdateVar1136114Flags::noRouteFound)) { destroyTrain(); return false; } if (_oldRoutingHandle == routingHandle) { return true; } const auto ref = RoutingManager::getRouting(_oldRoutingHandle); TrackAndDirection trackAndDir((ref & 0x1F8) >> 3, ref & 0x7); RoutingManager::freeRouting(_oldRoutingHandle); if (mode == TransportMode::road) { sub_47D959(_oldTilePos, trackAndDir.road, false); } else { if (ref & (1 << 15)) { setSignalState(_oldTilePos, trackAndDir.track, trackType, 0); } const auto& trackSize = World::TrackData::getUnkTrack(ref & World::Track::AdditionalTaDFlags::basicTaDMask); auto nextTile = _oldTilePos + trackSize.pos; if (trackSize.rotationEnd < 12) { nextTile -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } auto trackAndDirection2 = trackAndDir; trackAndDirection2.track.setReversed(!trackAndDirection2.track.isReversed()); sub_4A2AD7(nextTile, trackAndDirection2.track, owner, trackType); leaveLevelCrossing(_oldTilePos, trackAndDir.track, 9); } return true; } // 0x004B090F void liftUpTail(VehicleTail& tail) { if (tail.mode == TransportMode::road) { const auto tailPos = World::Pos3(tail.tileX, tail.tileY, tail.tileBaseZ * World::kSmallZStep); auto pos = tailPos; RoutingManager::RingView ring(tail.routingHandle); for (const auto& handle : ring) { const auto routing = RoutingManager::getRouting(handle); auto tad = TrackAndDirection::_RoadAndDirection(0, 0); tad._data = routing & Track::AdditionalTaDFlags::basicTaDMask; tail.sub_47D959(pos, tad, false); pos += World::TrackData::getUnkRoad(tad.basicRad()).pos; } } else { const auto tailPos = World::Pos3(tail.tileX, tail.tileY, tail.tileBaseZ * World::kSmallZStep); { TrackAndDirection::_TrackAndDirection tad{ 0, 0 }; tad._data = RoutingManager::getRouting(tail.routingHandle) & Track::AdditionalTaDFlags::basicTaDMask; auto& trackSize = World::TrackData::getUnkTrack(tad._data); auto pos = tailPos + trackSize.pos; if (trackSize.rotationEnd < 12) { pos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } tad.setReversed(!tad.isReversed()); sub_4A2AD7(pos, tad, tail.owner, tail.trackType); } auto pos = tailPos; RoutingManager::RingView ring(tail.routingHandle); for (const auto& handle : ring) { const auto routing = RoutingManager::getRouting(handle); auto tad = TrackAndDirection::_TrackAndDirection(0, 0); tad._data = routing & Track::AdditionalTaDFlags::basicTaDMask; sub_4A2AD7(pos, tad, tail.owner, tail.trackType); if (routing & Track::AdditionalTaDFlags::hasSignal) { setSignalState(pos, tad, tail.trackType, 0); } leaveLevelCrossing(pos, tad, 9); pos += World::TrackData::getUnkTrack(tad._data).pos; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Economy/Currency.h ```h #pragma once #include <compare> #include <cstdint> namespace OpenLoco { using currency32_t = int32_t; #pragma pack(push, 1) struct currency48_t { uint32_t var_00 = 0; int16_t var_04 = 0; constexpr currency48_t(int32_t currency) : currency48_t(static_cast<int64_t>(currency)) { } constexpr currency48_t(int64_t currency) { var_00 = currency & 0xFFFFFFFF; var_04 = (currency >> 32) & 0xFFFF; } constexpr int64_t asInt64() const { return var_00 | (static_cast<int64_t>(var_04) << 32); } constexpr currency48_t operator+(const currency32_t& rhs) { return currency48_t(asInt64() + rhs); } constexpr currency48_t operator+(const currency48_t& rhs) { return currency48_t(asInt64() + rhs.asInt64()); } constexpr currency48_t& operator+=(const currency32_t& rhs) { auto sum = currency48_t(asInt64() + rhs); return *this = sum; } constexpr currency48_t& operator+=(const currency48_t& rhs) { auto sum = currency48_t(asInt64() + rhs.asInt64()); return *this = sum; } constexpr currency48_t operator-(const currency32_t& rhs) { return currency48_t(asInt64() - rhs); } constexpr currency48_t operator-(const currency48_t& rhs) { return currency48_t(asInt64() - rhs.asInt64()); } constexpr currency48_t& operator-=(const currency32_t& rhs) { auto sum = currency48_t(asInt64() - rhs); return *this = sum; } constexpr currency48_t& operator-=(const currency48_t& rhs) { auto sum = currency48_t(asInt64() - rhs.asInt64()); return *this = sum; } constexpr bool operator==(const currency48_t& rhs) const { return asInt64() == rhs.asInt64(); } constexpr std::strong_ordering operator<=>(const currency48_t& rhs) const { return asInt64() <=> rhs.asInt64(); } }; #pragma pack(pop) static_assert(sizeof(currency48_t) == 6); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Economy/Economy.cpp ```cpp #include "Economy.h" #include "GameState.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Ui/WindowManager.h" #include "Ui/WindowType.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Economy { static constexpr uint32_t kInflationFactors[32] = { 20, 20, 20, 20, 23, 20, 23, 23, 20, 17, 17, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, }; static currency32_t _deliveredCargoPayment[32][60]; // 0x009C68F8 static auto& currencyMultiplicationFactors() { return getGameState().currencyMultiplicationFactor; } // NB: This is not used for anything due to a mistake in original inflation calculation // looks as if it was meant to be extra precision for the currencyMultiplicationFactor // Always 0. static auto& unusedCurrencyMultiplicationFactors() { return getGameState().unusedCurrencyMultiplicationFactor; } // 0x004375F7 void buildDeliveredCargoPaymentsTable() { for (uint8_t cargoItem = 0; cargoItem < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoItem) { auto* cargoObj = ObjectManager::get<CargoObject>(cargoItem); if (cargoObj == nullptr) { continue; } for (uint16_t numDays = 2; numDays < 122; numDays += 2) { _deliveredCargoPayment[cargoItem][(numDays / 2) - 1] = CompanyManager::calculateDeliveredCargoPayment(cargoItem, 100, 10, numDays); } } } std::span<currency32_t> getDeliveryCargoPaymentsTable(uint8_t cargoType) { return std::span(_deliveredCargoPayment[cargoType]); } uint32_t getCurrencyMultiplicationFactor(uint8_t costIndex) { return currencyMultiplicationFactors()[costIndex]; } // 0x0046E239 // NB: called in setInflationForYear below, as well in OpenLoco::::dateTick. void updateMonthly() { auto& factors = currencyMultiplicationFactors(); for (uint8_t i = 0; i < 32; i++) { factors[i] += (static_cast<uint64_t>(kInflationFactors[i]) * factors[i]) >> 12; } buildDeliveredCargoPaymentsTable(); Ui::WindowManager::invalidate(Ui::WindowType::companyList); Ui::WindowManager::invalidate(Ui::WindowType::buildVehicle); Ui::WindowManager::invalidate(Ui::WindowType::construction); Ui::WindowManager::invalidate(Ui::WindowType::terraform); Ui::WindowManager::invalidate(Ui::WindowType::industryList); } // 0x0046E2C0 void setInflationForYear(uint16_t year) { auto& factors = currencyMultiplicationFactors(); auto& unusedFactors = unusedCurrencyMultiplicationFactors(); for (uint8_t i = 0; i < 32; i++) { factors[i] = 1024; unusedFactors[i] = 0; } // OpenLoco allows 1800 as the minimum year, whereas Locomotion uses 1900. // Treat years before 1900 as though they were 1900 to not change vanilla scenarios. const uint32_t baseYear = std::clamp<uint32_t>(year, 1900, 2030) - 1900; for (uint32_t monthCount = baseYear * 12; monthCount > 0; monthCount--) { updateMonthly(); } } currency32_t getInflationAdjustedCost(int16_t costFactor, uint8_t costIndex, uint8_t divisor) { const auto val = costFactor * static_cast<int64_t>(currencyMultiplicationFactors()[costIndex]); assert(divisor < 63); const auto result = val / (1LL << divisor); assert(result <= static_cast<int64_t>(std::numeric_limits<int32_t>::max()) && result >= static_cast<int64_t>(std::numeric_limits<int32_t>::min())); return result; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Economy/Economy.h ```h #pragma once #include "Currency.h" #include <cstdint> #include <span> namespace OpenLoco::Economy { void updateMonthly(); void setInflationForYear(uint16_t year); currency32_t getInflationAdjustedCost(int16_t costFactor, uint8_t costIndex, uint8_t divisor); void buildDeliveredCargoPaymentsTable(); std::span<currency32_t> getDeliveryCargoPaymentsTable(uint8_t cargoType); uint32_t getCurrencyMultiplicationFactor(uint8_t costIndex); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Economy/Expenditures.h ```h #pragma once #include "Types.hpp" namespace OpenLoco { enum ExpenditureType : uint8_t { TrainIncome, TrainRunningCosts, BusIncome, BusRunningCosts, TruckIncome, TruckRunningCosts, TramIncome, TramRunningCosts, AircraftIncome, AircraftRunningCosts, ShipIncome, ShipRunningCosts, Construction, VehiclePurchases, VehicleDisposals, LoanInterest, Miscellaneous, Count }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Interop/Hooks.cpp ```cpp #include "Hooks.h" #include <cassert> #include <cstdio> #include <cstring> #include <system_error> #ifndef _WIN32 #include <sys/mman.h> #include <unistd.h> #endif void OpenLoco::Interop::loadSections() { #ifndef _WIN32 int32_t err = mprotect((void*)0x401000, 0x4d7000 - 0x401000, PROT_READ | PROT_WRITE | PROT_EXEC); if (err != 0) { perror("mprotect"); } err = mprotect((void*)0x4d7000, 0x1162000 - 0x4d7000, PROT_READ | PROT_WRITE); if (err != 0) { perror("mprotect"); } #endif } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Interop/Hooks.h ```h #pragma once namespace OpenLoco::Interop { void loadSections(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/Paint.cpp ```cpp #include "Paint.h" #include "Config.h" #include "Game.h" #include "GameStateFlags.h" #include "Graphics/Gfx.h" #include "Graphics/PaletteMap.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Localisation/StringManager.h" #include "Logging.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "PaintEntity.h" #include "PaintRoad.h" #include "PaintTile.h" #include "Ui/ViewportInteraction.h" #include "Ui/WindowManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Ui::ViewportInteraction; namespace OpenLoco::Paint { PaintSession::PaintSession(const Gfx::RenderTarget& rt, const SessionOptions& options) { _renderTarget = &rt; _lastPS = nullptr; for (auto& quadrant : _quadrants) { quadrant = nullptr; } _quadrantBackIndex = std::numeric_limits<uint32_t>::max(); _quadrantFrontIndex = 0; _lastPaintString = nullptr; _paintStringHead = nullptr; _viewFlags = options.viewFlags; currentRotation = options.rotation; // TODO: unused _foregroundCullingHeight = options.foregroundCullHeight; } void PaintSession::setEntityPosition(const World::Pos2& pos) { _spritePositionX = pos.x; _spritePositionY = pos.y; } void PaintSession::setMapPosition(const World::Pos2& pos) { _mapPosition = pos; } void PaintSession::setUnkPosition(const World::Pos2& pos) { _unkPositionX = pos.x; _unkPositionY = pos.y; } void PaintSession::setVpPosition(const Ui::Point& pos) { _vpPositionX = pos.x; _vpPositionY = pos.y; } void PaintSession::resetTileColumn(const Ui::Point& pos) { setVpPosition(pos); _didPassSurface = false; setBridgeEntry(kNullBridgeEntry); _525CF8 = SegmentFlags::none; _trackRoadAdditionSupports = TrackRoadAdditionSupports{}; std::fill(std::begin(_trackRoadPaintStructs), std::end(_trackRoadPaintStructs), nullptr); std::fill(std::begin(_trackRoadAdditionsPaintStructs), std::end(_trackRoadAdditionsPaintStructs), nullptr); _roadMergeExits = 0; _roadMergeStreetlightType = 0; } void PaintSession::setMaxHeight(const World::Pos2& loc) { auto tile = World::TileManager::get(loc); uint8_t maxClearZ = 0; for (const auto& el : tile) { maxClearZ = std::max(maxClearZ, el.clearZ()); const auto* surface = el.as<World::SurfaceElement>(); if (!surface) { continue; } if (surface->water()) { maxClearZ = std::max<uint8_t>(maxClearZ, surface->water() * World::kMicroToSmallZStep); } if (surface->isIndustrial()) { maxClearZ = std::max<uint8_t>(maxClearZ, surface->clearZ() + 24); } } _maxHeight = (maxClearZ * World::kSmallZStep) + 32; } /* * Flips the X axis so 1 and 3 are swapped 0 and 2 will stay the same. * { 0, 3, 2, 1 } */ inline constexpr uint8_t directionFlipXAxis(const uint8_t direction) { return (direction * 3) % 4; } static int32_t remapPositionToQuadrant(const PaintStruct& ps, uint8_t rotation) { constexpr auto mapRangeMax = kMaxPaintQuadrants * World::kTileSize; constexpr auto mapRangeCenter = mapRangeMax / 2; const auto x = ps.bounds.mins.x; const auto y = ps.bounds.mins.y; // NOTE: We are not calling CoordsXY::Rotate on purpose to mix in the additional // value without a secondary switch. switch (rotation & 3) { case 0: return x + y; case 1: // Because one component may be the maximum we add the centre to be a positive value. return (y - x) + mapRangeCenter; case 2: // If both components would be the maximum it would be the negative xy, to be positive add max. return (-(y + x)) + mapRangeMax; case 3: // Same as 1 but inverted. return (x - y) + mapRangeCenter; } return 0; } void PaintSession::addPSToQuadrant(PaintStruct& ps) { const auto positionHash = remapPositionToQuadrant(ps, currentRotation); // Values below zero or above MaxPaintQuadrants are void, corners also share the same quadrant as void. const uint32_t paintQuadrantIndex = std::clamp(positionHash / World::kTileSize, 0, kMaxPaintQuadrants - 1); ps.quadrantIndex = paintQuadrantIndex; ps.nextQuadrantPS = _quadrants[paintQuadrantIndex]; _quadrants[paintQuadrantIndex] = &ps; _quadrantBackIndex = std::min(_quadrantBackIndex, paintQuadrantIndex); _quadrantFrontIndex = std::max(_quadrantFrontIndex, paintQuadrantIndex); } // 0x004FD120 PaintStringStruct* PaintSession::addToStringPlotList(const uint32_t amount, const StringId stringId, const uint16_t z, const int16_t xOffset, const int8_t* yOffsets, const uint16_t colour) { auto* psString = allocatePaintStruct<PaintStringStruct>(); if (psString == nullptr) { return nullptr; } psString->stringId = stringId; psString->next = nullptr; psString->yOffsets = yOffsets; psString->colour = colour; FormatArguments fmtArgs{ psString->argsBuf }; fmtArgs.push(amount); const auto& vpPos = World::gameToScreen(World::Pos3(getSpritePosition(), z), currentRotation); psString->vpPos.x = vpPos.x + xOffset; psString->vpPos.y = vpPos.y; attachStringStruct(*psString); return psString; } // 0x004FD130 PaintStruct* PaintSession::addToPlotListAsParent(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxSize) { return addToPlotListAsParent(imageId, offset, offset, boundBoxSize); } static constexpr bool imageWithinRT(const Ui::viewport_pos& imagePos, const Gfx::G1Element& g1, const Gfx::RenderTarget& rt) { int32_t left = imagePos.x + g1.xOffset; int32_t bottom = imagePos.y + g1.yOffset; int32_t right = left + g1.width; int32_t top = bottom + g1.height; if (right <= rt.x) { return false; } if (top <= rt.y) { return false; } if (left >= rt.x + rt.width) { return false; } if (bottom >= rt.y + rt.height) { return false; } return true; } static constexpr World::Pos3 rotateBoundBoxSize(const World::Pos3& bbSize, const uint8_t rotation) { auto output = bbSize; // This probably rotates the variables so they're relative to rotation 0. // Uses same rotations as directionFlipXAxis switch (rotation) { case 0: output.x--; output.y--; output = World::Pos3{ Math::Vector::rotate(output, 0), output.z }; break; case 1: output.x--; output = World::Pos3{ Math::Vector::rotate(output, 3), output.z }; break; case 2: output = World::Pos3{ Math::Vector::rotate(output, 2), output.z }; break; case 3: output.y--; output = World::Pos3{ Math::Vector::rotate(output, 1), output.z }; break; } return output; } // 0x004FD140 PaintStruct* PaintSession::addToPlotListAsParent(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { _lastPS = nullptr; auto* ps = createNormalPaintStruct(imageId, offset, boundBoxOffset, boundBoxSize); if (ps != nullptr) { _lastPS = ps; addPSToQuadrant(*ps); } return ps; } // 0x004FD150 PaintStruct* PaintSession::addToPlotList4FD150(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { // This is identical to addToPlotListAsParent but the offset.x and offset.y are 0 return addToPlotListAsParent(imageId, offset, boundBoxOffset, boundBoxSize); } // 0x004FD200 PaintStruct* PaintSession::addToPlotList4FD200(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { _lastPS = nullptr; auto* ps = createNormalPaintStruct(imageId, offset, boundBoxOffset, boundBoxSize); if (ps == nullptr) { return nullptr; } const auto rtLeft = getRenderTarget()->x; const auto rtRight = getRenderTarget()->x + getRenderTarget()->width; auto newMins = ps->bounds.mins; // The following uses the fact that gameToScreen calculates the // screen x to be y - x of the map coordinate. It is then back // calculating the x and y so that they would within the render // target size when converted. switch (getRotation()) { case 0: if (newMins.y - newMins.x < rtLeft) { newMins.y = newMins.x + rtLeft; } if (newMins.y - newMins.x > rtRight) { newMins.x = newMins.y - rtRight; } break; case 1: if (-newMins.y - newMins.x < rtLeft) { newMins.x = -newMins.y - rtLeft; } if (-newMins.y - newMins.x > rtRight) { newMins.y = -newMins.x - rtRight; } break; case 2: if (-newMins.y + newMins.x < rtLeft) { newMins.y = newMins.x - rtLeft; } if (-newMins.y + newMins.x > rtRight) { newMins.x = newMins.y + rtRight; } break; case 3: if (newMins.y + newMins.x < rtLeft) { newMins.x = -newMins.y + rtLeft; } if (newMins.y + newMins.x > rtRight) { newMins.y = -newMins.x + rtRight; } break; } ps->bounds.mins = newMins; _lastPS = ps; addPSToQuadrant(*ps); return ps; } // 0x004FD1E0 PaintStruct* PaintSession::addToPlotListAsChild(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { if (_lastPS == nullptr) { return addToPlotListAsParent(imageId, offset, boundBoxOffset, boundBoxSize); } auto* ps = createNormalPaintStruct(imageId, offset, boundBoxOffset, boundBoxSize); if (ps == nullptr) { return nullptr; } _lastPS->children = ps; _lastPS = ps; return ps; } // 0x004FD170 PaintStruct* PaintSession::addToPlotListTrackRoad(ImageId imageId, uint32_t priority, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { _lastPS = nullptr; auto* ps = createNormalPaintStruct(imageId, offset, boundBoxOffset, boundBoxSize); if (ps != nullptr) { _lastPS = ps; auto* lastTRS = _trackRoadPaintStructs[priority]; _trackRoadPaintStructs[priority] = ps; ps->children = lastTRS; } return ps; } // 0x004FD180 PaintStruct* PaintSession::addToPlotListTrackRoadAddition(ImageId imageId, uint32_t priority, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { _lastPS = nullptr; auto* ps = createNormalPaintStruct(imageId, offset, boundBoxOffset, boundBoxSize); if (ps != nullptr) { _lastPS = ps; auto* lastTRS = _trackRoadAdditionsPaintStructs[priority]; _trackRoadAdditionsPaintStructs[priority] = ps; ps->children = lastTRS; } return ps; } // 0x0045E779 AttachedPaintStruct* PaintSession::attachToPrevious(ImageId imageId, const Ui::Point& offset) { if (_lastPS == nullptr) { return nullptr; } auto* attached = allocatePaintStruct<AttachedPaintStruct>(); if (attached == nullptr) { return nullptr; } attached->imageId = imageId; attached->vpPos = offset; attached->next = _lastPS->attachedPS; _lastPS->attachedPS = attached; return attached; } void PaintSession::setSegmentsSupportHeight(const SegmentFlags segments, const uint16_t height, const uint8_t slope) { for (int32_t s = 0; s < 9; s++) { if ((segments & kSegmentOffsets[s]) != SegmentFlags::none) { setSegmentSupportHeight(s, height, slope); } } } void PaintSession::setSegmentSupportHeight(const uint8_t segment, const uint16_t height, const uint8_t slope) { _supportSegments[segment].height = height; if (height != 0xFFFF) { _supportSegments[segment].slope = slope; _supportSegments[segment].var_03 = 0; } } void PaintSession::setGeneralSupportHeight(const uint16_t height, const uint8_t slope) { _support.height = height; _support.slope = slope; _support.var_03 = 0; } void PaintSession::resetTunnels() { std::fill(std::begin(_tunnelCounts), std::end(_tunnelCounts), 0); _tunnels0[0].height = 0xFF; _tunnels1[0].height = 0xFF; _tunnels2[0].height = 0xFF; _tunnels3[0].height = 0xFF; } void PaintSession::insertTunnel(coord_t z, uint8_t tunnelType, uint8_t edge) { TunnelEntry entry{ static_cast<World::MicroZ>(z / World::kMicroZStep), tunnelType }; auto& tunnelCount = _tunnelCounts[edge]; auto tunnels = getTunnels(edge); bool insert = true; if (tunnelCount > 0) { if (tunnels[tunnelCount - 1] == entry) { insert = false; } } if (insert) { tunnels[tunnelCount] = entry; tunnels[tunnelCount + 1] = { 0xFF, 0xFFU }; tunnelCount++; } } void PaintSession::insertTunnels(const std::array<int16_t, 4>& tunnelHeights, coord_t height, uint8_t tunnelType) { for (auto edge = 0U; edge < tunnelHeights.size(); edge++) { if (tunnelHeights[edge] != -1) { insertTunnel(tunnelHeights[edge] + height, tunnelType, edge); } } } struct GenerationParameters { World::Pos2 mapLoc; uint16_t numVerticalQuadrants; std::array<World::Pos2, 5> additionalQuadrants; World::Pos2 nextVerticalQuadrant; }; template<uint8_t rotation> GenerationParameters generateParameters(const Gfx::RenderTarget* rt) { // TODO: Work out what these constants represent uint16_t numVerticalQuadrants = (rt->height + (rotation == 0 ? 1040 : 1056)) >> 5; auto mapLoc = Ui::viewportCoordToMapCoord( Numerics::floor2(rt->x, 32), Numerics::floor2(rt->y - 16, 32), 0, rotation); if constexpr (rotation & 1) { mapLoc.y -= 16; } mapLoc.x = Numerics::floor2(mapLoc.x, 32); mapLoc.y = Numerics::floor2(mapLoc.y, 32); constexpr auto direction = directionFlipXAxis(rotation); constexpr std::array<World::Pos2, 5> additionalQuadrants = { Math::Vector::rotate(World::Pos2{ -32, 32 }, direction), Math::Vector::rotate(World::Pos2{ 0, 32 }, direction), Math::Vector::rotate(World::Pos2{ 32, 0 }, direction), Math::Vector::rotate(World::Pos2{ 32, -32 }, direction), Math::Vector::rotate(World::Pos2{ -32, 64 }, direction), }; constexpr auto nextVerticalQuadrant = Math::Vector::rotate(World::Pos2{ 32, 32 }, direction); return { mapLoc, numVerticalQuadrants, additionalQuadrants, nextVerticalQuadrant }; } void PaintSession::generateTilesAndEntities(GenerationParameters&& p) { for (; p.numVerticalQuadrants > 0; --p.numVerticalQuadrants) { paintTileElements(*this, p.mapLoc); paintEntities(*this, p.mapLoc); auto loc1 = p.mapLoc + p.additionalQuadrants[0]; paintTileElements2(*this, loc1); paintEntities(*this, loc1); auto loc2 = p.mapLoc + p.additionalQuadrants[1]; paintTileElements(*this, loc2); paintEntities(*this, loc2); auto loc3 = p.mapLoc + p.additionalQuadrants[2]; paintTileElements2(*this, loc3); paintEntities(*this, loc3); auto loc4 = p.mapLoc + p.additionalQuadrants[3]; paintEntities2(*this, loc4); auto loc5 = p.mapLoc + p.additionalQuadrants[4]; paintEntities2(*this, loc5); p.mapLoc += p.nextVerticalQuadrant; } } void PaintSession::attachStringStruct(PaintStringStruct& psString) { auto* previous = _lastPaintString; _lastPaintString = &psString; if (previous == nullptr) { _paintStringHead = &psString; } else { previous->next = &psString; } } PaintStruct* PaintSession::createNormalPaintStruct(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { auto* const g1 = Gfx::getG1Element(imageId.getIndex()); if (g1 == nullptr) { return nullptr; } const auto swappedRotation = directionFlipXAxis(currentRotation); auto swappedRotCoord = World::Pos3{ Math::Vector::rotate(offset, swappedRotation), offset.z }; swappedRotCoord += World::Pos3{ getSpritePosition(), 0 }; const auto vpPos = World::gameToScreen(swappedRotCoord, currentRotation); if (!imageWithinRT(vpPos, *g1, *_renderTarget)) { return nullptr; } const auto rotBoundBoxOffset = World::Pos3{ Math::Vector::rotate(boundBoxOffset, swappedRotation), boundBoxOffset.z }; const auto rotBoundBoxSize = rotateBoundBoxSize(boundBoxSize, currentRotation); auto* ps = allocatePaintStruct<PaintStruct>(); if (ps == nullptr) { return nullptr; } const auto spritePos = getSpritePosition(); ps->imageId = imageId; ps->vpPos = { vpPos.x, vpPos.y }; ps->bounds.mins = rotBoundBoxOffset + World::Pos3{ spritePos.x, spritePos.y, 0 }; ps->bounds.maxs = rotBoundBoxOffset + rotBoundBoxSize + World::Pos3{ spritePos.x, spritePos.y, 0 }; ps->flags = PaintStructFlags::none; ps->attachedPS = nullptr; ps->children = nullptr; ps->type = _itemType; ps->modId = _trackModId; ps->mapPos = _mapPosition; ps->tileElement = reinterpret_cast<World::TileElement*>(_currentItem); return ps; } // 0x004622A2 void PaintSession::generate() { if (!Game::hasFlags(GameStateFlags::tileManagerLoaded)) { return; } switch (currentRotation) { case 0: generateTilesAndEntities(generateParameters<0>(getRenderTarget())); break; case 1: generateTilesAndEntities(generateParameters<1>(getRenderTarget())); break; case 2: generateTilesAndEntities(generateParameters<2>(getRenderTarget())); break; case 3: generateTilesAndEntities(generateParameters<3>(getRenderTarget())); break; } } template<uint8_t TRotation> static bool checkBoundingBox(const PaintStructBoundBox& initialBBox, const PaintStructBoundBox& currentBBox) { if constexpr (TRotation == 0) { if (initialBBox.maxs.z >= currentBBox.mins.z && initialBBox.maxs.y >= currentBBox.mins.y && initialBBox.maxs.x >= currentBBox.mins.x && !(initialBBox.mins.z < currentBBox.maxs.z && initialBBox.mins.y < currentBBox.maxs.y && initialBBox.mins.x < currentBBox.maxs.x)) { return true; } } else if constexpr (TRotation == 1) { if (initialBBox.maxs.z >= currentBBox.mins.z && initialBBox.maxs.y >= currentBBox.mins.y && initialBBox.maxs.x < currentBBox.mins.x && !(initialBBox.mins.z < currentBBox.maxs.z && initialBBox.mins.y < currentBBox.maxs.y && initialBBox.mins.x >= currentBBox.maxs.x)) { return true; } } else if constexpr (TRotation == 2) { if (initialBBox.maxs.z >= currentBBox.mins.z && initialBBox.maxs.y < currentBBox.mins.y && initialBBox.maxs.x < currentBBox.mins.x && !(initialBBox.mins.z < currentBBox.maxs.z && initialBBox.mins.y >= currentBBox.maxs.y && initialBBox.mins.x >= currentBBox.maxs.x)) { return true; } } else if constexpr (TRotation == 3) { if (initialBBox.maxs.z >= currentBBox.mins.z && initialBBox.maxs.y < currentBBox.mins.y && initialBBox.maxs.x >= currentBBox.mins.x && !(initialBBox.mins.z < currentBBox.maxs.z && initialBBox.mins.y >= currentBBox.maxs.y && initialBBox.mins.x < currentBBox.maxs.x)) { return true; } } return false; } template<uint8_t _TRotation> static PaintStruct* arrangeStructsHelperRotation(PaintStruct* psNext, const uint16_t quadrantIndex, const QuadrantFlags flag) { PaintStruct* ps = nullptr; // Get the first node in the specified quadrant. do { ps = psNext; psNext = psNext->nextQuadrantPS; if (psNext == nullptr) { return ps; } } while (quadrantIndex > psNext->quadrantIndex); // We keep track of the first node in the quadrant so the next call with a higher quadrant index // can use this node to skip some iterations. auto* psQuadrantEntry = ps; // Visit all nodes in the linked quadrant list and determine their current // sorting relevancy. auto* psTemp = ps; do { ps = ps->nextQuadrantPS; if (ps == nullptr) { break; } if (ps->quadrantIndex > quadrantIndex + 1) { // Outside of the range. ps->quadrantFlags = QuadrantFlags::outsideQuadrant; } else if (ps->quadrantIndex == quadrantIndex + 1) { // Is neighbour and requires a visit. ps->quadrantFlags = QuadrantFlags::neighbour | QuadrantFlags::pendingVisit; } else if (ps->quadrantIndex == quadrantIndex) { // In specified quadrant, requires visit. ps->quadrantFlags = flag | QuadrantFlags::pendingVisit; } } while (ps->quadrantIndex <= quadrantIndex + 1); ps = psTemp; // Iterate all nodes in the current list and re-order them based on // the current rotation and their bounding box. while (true) { // Get the first pending node in the quadrant list while (true) { psNext = ps->nextQuadrantPS; if (psNext == nullptr) { // End of the current list. return psQuadrantEntry; } if (psNext->hasQuadrantFlags(QuadrantFlags::outsideQuadrant)) { // Reached point outside of specified quadrant. return psQuadrantEntry; } if (psNext->hasQuadrantFlags(QuadrantFlags::pendingVisit)) { // Found node to check on. break; } ps = psNext; } // Mark visited. psNext->quadrantFlags &= ~QuadrantFlags::pendingVisit; psTemp = ps; // Compare current node against the remaining children. const PaintStructBoundBox& initialBBox = psNext->bounds; while (true) { ps = psNext; psNext = psNext->nextQuadrantPS; if (psNext == nullptr) { break; } if (psNext->hasQuadrantFlags(QuadrantFlags::outsideQuadrant)) { break; } if (!psNext->hasQuadrantFlags(QuadrantFlags::neighbour)) { continue; } const PaintStructBoundBox& currentBBox = psNext->bounds; const bool compareResult = checkBoundingBox<_TRotation>(initialBBox, currentBBox); if (compareResult) { // Child node intersects with current node, move behind. ps->nextQuadrantPS = psNext->nextQuadrantPS; PaintStruct* ps_temp2 = psTemp->nextQuadrantPS; psTemp->nextQuadrantPS = psNext; psNext->nextQuadrantPS = ps_temp2; psNext = ps; } } ps = psTemp; } } static PaintStruct* arrangeStructsHelper(PaintStruct* psNext, uint16_t quadrantIndex, QuadrantFlags flag, uint8_t rotation) { switch (rotation) { case 0: return arrangeStructsHelperRotation<0>(psNext, quadrantIndex, flag); case 1: return arrangeStructsHelperRotation<1>(psNext, quadrantIndex, flag); case 2: return arrangeStructsHelperRotation<2>(psNext, quadrantIndex, flag); case 3: return arrangeStructsHelperRotation<3>(psNext, quadrantIndex, flag); } return nullptr; } // 0x0045E7B5 void PaintSession::arrangeStructs() { PaintStruct psHead{}; auto* ps = &psHead; uint32_t quadrantIndex = _quadrantBackIndex; if (quadrantIndex == std::numeric_limits<uint32_t>::max()) { return; } do { PaintStruct* psNext = _quadrants[quadrantIndex]; if (psNext != nullptr) { ps->nextQuadrantPS = psNext; do { ps = psNext; psNext = psNext->nextQuadrantPS; } while (psNext != nullptr); } } while (++quadrantIndex <= _quadrantFrontIndex); PaintStruct* psCache = arrangeStructsHelper( &psHead, _quadrantBackIndex & 0xFFFF, QuadrantFlags::neighbour, currentRotation); quadrantIndex = _quadrantBackIndex; while (++quadrantIndex < _quadrantFrontIndex) { psCache = arrangeStructsHelper(psCache, quadrantIndex & 0xFFFF, QuadrantFlags::none, currentRotation); } _paintHead = psHead.nextQuadrantPS; } static bool isTypeCullableBuilding(const Ui::ViewportInteraction::InteractionItem type) { switch (type) { case Ui::ViewportInteraction::InteractionItem::building: case Ui::ViewportInteraction::InteractionItem::industry: case Ui::ViewportInteraction::InteractionItem::headquarterBuilding: case Ui::ViewportInteraction::InteractionItem::airport: case Ui::ViewportInteraction::InteractionItem::dock: return true; default: return false; } } static bool isTypeCullableRoad(const Ui::ViewportInteraction::InteractionItem type) { switch (type) { case Ui::ViewportInteraction::InteractionItem::roadStation: case Ui::ViewportInteraction::InteractionItem::road: case Ui::ViewportInteraction::InteractionItem::roadExtra: return true; default: return false; } } static bool isTypeCullableScenery(const Ui::ViewportInteraction::InteractionItem type) { switch (type) { case Ui::ViewportInteraction::InteractionItem::wall: return true; default: return false; } } static bool isTypeCullableBridge(const Ui::ViewportInteraction::InteractionItem type) { return (type == Ui::ViewportInteraction::InteractionItem::bridge); } static bool isTypeCullableTrack(const Ui::ViewportInteraction::InteractionItem type) { switch (type) { case Ui::ViewportInteraction::InteractionItem::track: case Ui::ViewportInteraction::InteractionItem::trackExtra: case Ui::ViewportInteraction::InteractionItem::signal: case Ui::ViewportInteraction::InteractionItem::trainStation: return true; default: return false; } } static bool isTypeCullableTree(const Ui::ViewportInteraction::InteractionItem type) { switch (type) { case Ui::ViewportInteraction::InteractionItem::industryTree: case Ui::ViewportInteraction::InteractionItem::tree: return true; default: return false; } } static bool shouldTryCullPaintStruct(const PaintStruct& ps, const Ui::ViewportFlags viewFlags) { if ((viewFlags & Ui::ViewportFlags::seeThroughTracks) != Ui::ViewportFlags::none) { if (isTypeCullableTrack(ps.type)) { return true; } } if ((viewFlags & Ui::ViewportFlags::seeThroughRoads) != Ui::ViewportFlags::none) { if (isTypeCullableRoad(ps.type)) { return true; } } if ((viewFlags & Ui::ViewportFlags::seeThroughTrees) != Ui::ViewportFlags::none) { if (isTypeCullableTree(ps.type)) { return true; } } if ((viewFlags & Ui::ViewportFlags::seeThroughScenery) != Ui::ViewportFlags::none) { if (isTypeCullableScenery(ps.type)) { return true; } } if ((viewFlags & Ui::ViewportFlags::seeThroughBuildings) != Ui::ViewportFlags::none) { if (isTypeCullableBuilding(ps.type)) { return true; } } if (((viewFlags & Ui::ViewportFlags::seeThroughBridges) != Ui::ViewportFlags::none) && (isTypeCullableBridge(ps.type))) { return true; } return false; } static bool cullPaintStructImage(const ImageId& imageId, const Ui::ViewportFlags viewFlags) { if ((viewFlags & Ui::ViewportFlags::underground_view) != Ui::ViewportFlags::none) { return true; } if (imageId.isBlended()) { return true; } return false; } static void drawStruct(const Gfx::RenderTarget& rt, Gfx::DrawingContext& drawingCtx, const PaintStruct& ps, const bool shouldCull) { auto imageId = ps.imageId; if (shouldCull) { imageId = ImageId(imageId.getIndex()).withTranslucency(ExtColour::unk30); } auto imagePos = ps.vpPos; if (ps.type == Ui::ViewportInteraction::InteractionItem::entity) { const auto zoomAlign = 1U << rt.zoomLevel; imagePos.x = Numerics::floor2(imagePos.x, zoomAlign); imagePos.y = Numerics::floor2(imagePos.y, zoomAlign); } if ((ps.flags & PaintStructFlags::hasMaskedImage) != PaintStructFlags::none) { drawingCtx.drawImageMasked(imagePos, imageId, ps.maskedImageId); } else { drawingCtx.drawImage(imagePos, imageId); } } static void drawAttachStruct(const Gfx::RenderTarget& rt, Gfx::DrawingContext& drawingCtx, const PaintStruct& ps, const AttachedPaintStruct& attachPs, const bool shouldCull) { auto imageId = attachPs.imageId; if (shouldCull) { imageId = ImageId(imageId.getIndex()).withTranslucency(ExtColour::unk30); } Ui::Point imagePos = ps.vpPos + attachPs.vpPos; if (rt.zoomLevel != 0) { imagePos.x = Numerics::floor2(imagePos.x, 2); imagePos.y = Numerics::floor2(imagePos.y, 2); } if ((attachPs.flags & PaintStructFlags::hasMaskedImage) != PaintStructFlags::none) { drawingCtx.drawImageMasked(imagePos, imageId, attachPs.maskedImageId); } else { drawingCtx.drawImage(imagePos, imageId); } } static void drawAllAttachedStructs(const Gfx::RenderTarget& rt, Gfx::DrawingContext& drawingCtx, const PaintStruct& ps, const Ui::ViewportFlags viewFlags) { for (const auto* attachPs = ps.attachedPS; attachPs != nullptr; attachPs = attachPs->next) { const bool shouldCullAttach = shouldTryCullPaintStruct(ps, viewFlags); if (shouldCullAttach) { if (cullPaintStructImage(attachPs->imageId, viewFlags)) { continue; } } drawAttachStruct(rt, drawingCtx, ps, *attachPs, shouldCullAttach); } } // 0x0045EA23 void PaintSession::drawStructs(Gfx::DrawingContext& drawingCtx) { const Gfx::RenderTarget& rt = drawingCtx.currentRenderTarget(); for (const auto* ps = _paintHead; ps != nullptr; ps = ps->nextQuadrantPS) { const bool shouldCull = shouldTryCullPaintStruct(*ps, _viewFlags); if (shouldCull) { if (cullPaintStructImage(ps->imageId, _viewFlags)) { continue; } } drawStruct(rt, drawingCtx, *ps, shouldCull); // Draw any children this might have for (const auto* childPs = ps->children; childPs != nullptr; childPs = childPs->children) { const bool shouldCullChild = shouldTryCullPaintStruct(*childPs, _viewFlags); if (shouldCullChild) { if (cullPaintStructImage(childPs->imageId, _viewFlags)) { continue; } } drawStruct(rt, drawingCtx, *childPs, shouldCullChild); drawAllAttachedStructs(rt, drawingCtx, *childPs, _viewFlags); } // Draw any attachments to the struct drawAllAttachedStructs(rt, drawingCtx, *ps, _viewFlags); } } // 0x0045A60E void PaintSession::drawStringStructs(Gfx::DrawingContext& drawingCtx) { PaintStringStruct* psString = _paintStringHead; if (psString == nullptr) { return; } Gfx::RenderTarget unZoomedRt = drawingCtx.currentRenderTarget(); const auto zoom = unZoomedRt.zoomLevel; unZoomedRt.zoomLevel = 0; unZoomedRt.x >>= zoom; unZoomedRt.y >>= zoom; unZoomedRt.width >>= zoom; unZoomedRt.height >>= zoom; drawingCtx.pushRenderTarget(unZoomedRt); auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(zoom == 0 ? Gfx::Font::medium_bold : Gfx::Font::small); char buffer[512]{}; for (; psString != nullptr; psString = psString->next) { Ui::Point loc(psString->vpPos.x >> zoom, psString->vpPos.y >> zoom); StringManager::formatString(buffer, psString->stringId, psString->argsBuf); Ui::WindowManager::setWindowColours(Ui::WindowColour::primary, AdvancedColour(static_cast<Colour>(psString->colour))); Ui::WindowManager::setWindowColours(Ui::WindowColour::secondary, AdvancedColour(static_cast<Colour>(psString->colour))); tr.drawStringYOffsets(loc, Colour::black, buffer, psString->yOffsets); } drawingCtx.popRenderTarget(); } // 0x00447C21 static bool isPixelPresentBMP( const ImageId image, const Gfx::G1Element& g1, const Ui::Point& coords, const Gfx::PaletteMap::View paletteMap) { const auto* index = g1.offset + (coords.y * g1.width) + coords.x; // Needs investigation as it has no consideration for pure BMP maps. if (!g1.hasFlags(Gfx::G1ElementFlags::hasTransparency)) { return false; } if (image.hasPrimary()) { return paletteMap[*index] != 0; } return (*index != 0); } // 0x00447D26 static bool isPixelPresentRLE(const Gfx::G1Element& g1, const Ui::Point& coords) { const uint16_t* data16 = reinterpret_cast<const uint16_t*>(g1.offset); uint16_t startOffset = data16[coords.y]; const uint8_t* data8 = static_cast<const uint8_t*>(g1.offset) + startOffset; bool lastDataLine = false; while (!lastDataLine) { int32_t numPixels = *data8++; uint8_t pixelRunStart = *data8++; lastDataLine = numPixels & 0x80; numPixels &= 0x7F; data8 += numPixels; if (pixelRunStart <= coords.x && coords.x < pixelRunStart + numPixels) { return true; } } return false; } // 0x00447A5F static bool isSpriteInteractedWithPaletteSet(const Gfx::RenderTarget* rt, ImageId imageId, const Ui::Point& coords, const Gfx::PaletteMap::View paletteMap) { const auto* g1 = Gfx::getG1Element(imageId.getIndex()); if (g1 == nullptr) { return false; } auto zoomLevel = rt->zoomLevel; Ui::Point interactionPoint{ rt->x, rt->y }; Ui::Point origin = coords; if (zoomLevel > 0) { if (g1->hasFlags(Gfx::G1ElementFlags::noZoomDraw)) { return false; } while (g1->hasFlags(Gfx::G1ElementFlags::hasZoomSprites) && zoomLevel > 0) { imageId = ImageId(imageId.getIndex() - g1->zoomOffset); g1 = Gfx::getG1Element(imageId.getIndex()); if (g1 == nullptr || g1->hasFlags(Gfx::G1ElementFlags::noZoomDraw)) { return false; } zoomLevel = zoomLevel - 1; interactionPoint.x >>= 1; interactionPoint.y >>= 1; origin.x >>= 1; origin.y >>= 1; } } origin.x += g1->xOffset; origin.y += g1->yOffset; interactionPoint -= origin; if (interactionPoint.x < 0 || interactionPoint.y < 0 || interactionPoint.x >= g1->width || interactionPoint.y >= g1->height) { return false; } if (g1->hasFlags(Gfx::G1ElementFlags::isRLECompressed)) { return isPixelPresentRLE(*g1, interactionPoint); } if (!g1->hasFlags(Gfx::G1ElementFlags::unk1)) { return isPixelPresentBMP(imageId, *g1, interactionPoint, paletteMap); } return false; } // 0x00447A0E static bool isSpriteInteractedWith(const Gfx::RenderTarget* rt, ImageId imageId, const Ui::Point& coords) { auto paletteMap = Gfx::PaletteMap::getDefault(); if (imageId.hasPrimary()) { ExtColour index = imageId.hasSecondary() ? static_cast<ExtColour>(imageId.getPrimary()) : imageId.getRemap(); if (auto pm = Gfx::PaletteMap::getForColour(index)) { paletteMap = *pm; } } return isSpriteInteractedWithPaletteSet(rt, imageId, coords, paletteMap); } // 0x0045EDFC static bool isPSSpriteTypeInFilter(const InteractionItem spriteType, InteractionItemFlags filter) { constexpr InteractionItemFlags interactionItemToFilter[] = { InteractionItemFlags::none, InteractionItemFlags::surface, InteractionItemFlags::surface, InteractionItemFlags::entity, InteractionItemFlags::track, InteractionItemFlags::trackExtra, InteractionItemFlags::signal, InteractionItemFlags::station, InteractionItemFlags::station, InteractionItemFlags::station, InteractionItemFlags::station, InteractionItemFlags::water, InteractionItemFlags::tree, InteractionItemFlags::wall, InteractionItemFlags::townLabel, InteractionItemFlags::stationLabel, InteractionItemFlags::roadAndTram, InteractionItemFlags::roadAndTramExtra, InteractionItemFlags::none, InteractionItemFlags::building, InteractionItemFlags::industry, InteractionItemFlags::headquarterBuilding, }; if (spriteType == InteractionItem::noInteraction || spriteType == InteractionItem::bridge) // 18 as a type seems to not exist. { return false; } InteractionItemFlags mask = interactionItemToFilter[static_cast<size_t>(spriteType)]; if ((filter & mask) != InteractionItemFlags::none) { return false; } return true; } static std::optional<InteractionArg> getAttachedInteractionInfo(const Gfx::RenderTarget& rt, const InteractionItemFlags flags, const PaintStruct& ps) { std::optional<InteractionArg> info = std::nullopt; for (auto* attachedPS = ps.attachedPS; attachedPS != nullptr; attachedPS = attachedPS->next) { if (isSpriteInteractedWith(&rt, attachedPS->imageId, attachedPS->vpPos + ps.vpPos)) { if (isPSSpriteTypeInFilter(ps.type, flags)) { info = { ps }; } } } return info; } // 0x0045ED91 [[nodiscard]] InteractionArg PaintSession::getNormalInteractionInfo(const InteractionItemFlags flags) { InteractionArg info{}; for (auto* ps = _paintHead; ps != nullptr; ps = ps->nextQuadrantPS) { // Check main paint struct if (isSpriteInteractedWith(getRenderTarget(), ps->imageId, ps->vpPos)) { if (isPSSpriteTypeInFilter(ps->type, flags)) { info = { *ps }; } } // Check children paint structs for (const auto* childPs = ps->children; childPs != nullptr; childPs = childPs->children) { if (isSpriteInteractedWith(getRenderTarget(), childPs->imageId, childPs->vpPos)) { if (isPSSpriteTypeInFilter(childPs->type, flags)) { info = { *childPs }; } } auto attachedInfo = getAttachedInteractionInfo(*getRenderTarget(), flags, *childPs); if (attachedInfo.has_value()) { info = attachedInfo.value(); } } // Check attached to main paint struct auto attachedInfo = getAttachedInteractionInfo(*getRenderTarget(), flags, *ps); if (attachedInfo.has_value()) { info = attachedInfo.value(); } } return info; } // 0x0048DDE4 [[nodiscard]] InteractionArg PaintSession::getStationNameInteractionInfo(const InteractionItemFlags flags) { InteractionArg interaction{}; if ((flags & InteractionItemFlags::stationLabel) != InteractionItemFlags::none) { return interaction; } auto rect = _renderTarget->getDrawableRect(); for (auto& station : StationManager::stations()) { if ((station.flags & StationFlags::flag_5) != StationFlags::none) { continue; } if (!station.labelFrame.contains(rect, _renderTarget->zoomLevel)) { continue; } interaction.type = InteractionItem::stationLabel; interaction.value = enumValue(station.id()); interaction.pos.x = station.x; interaction.pos.y = station.y; } return interaction; } // 0x0049773D [[nodiscard]] InteractionArg PaintSession::getTownNameInteractionInfo(const InteractionItemFlags flags) { InteractionArg interaction{}; if ((flags & InteractionItemFlags::townLabel) != InteractionItemFlags::none) { return interaction; } auto rect = _renderTarget->getDrawableRect(); for (auto& town : TownManager::towns()) { if (!town.labelFrame.contains(rect, _renderTarget->zoomLevel)) { continue; } interaction.type = InteractionItem::townLabel; interaction.value = enumValue(town.id()); interaction.pos.x = town.x; interaction.pos.y = town.y; } return interaction; } static PaintStruct* getLastChild(PaintStruct& ps) { auto* lastChild = &ps; for (; lastChild->children != nullptr; lastChild = lastChild->children) { ; } return lastChild; } static PaintStruct* appendTogetherStructs(std::span<PaintStruct*> paintStructs) { PaintStruct* routeEntry = nullptr; // Append all of the paint structs together onto the route entry as children in order of array PaintStruct* lastEntry = nullptr; for (auto* entry : paintStructs) { if (entry == nullptr) { continue; } if (lastEntry == nullptr) { routeEntry = entry; } else { lastEntry->children = entry; } lastEntry = getLastChild(*entry); } // Reset table now that we have appended into one std::fill(std::begin(paintStructs), std::end(paintStructs), nullptr); return routeEntry; } // 0x0045CABF, 0x0045CAF4, 0x0045CB29, 0x0045CB5A, 0x0045CC73, 0x0045CCA8, 0x0045CCDD, 0x0045CD0E static PaintStructBoundBox getMinMaxXYBounding(PaintStruct& routeEntry, uint8_t rotation) { auto [mins, maxs] = routeEntry.bounds; switch (rotation) { case 0: for (auto* child = routeEntry.children; child != nullptr; child = child->children) { mins.x = std::min(mins.x, child->bounds.mins.x); mins.y = std::min(mins.y, child->bounds.mins.y); maxs.x = std::max(maxs.x, child->bounds.maxs.x); maxs.y = std::max(maxs.y, child->bounds.maxs.y); } break; case 1: for (auto* child = routeEntry.children; child != nullptr; child = child->children) { mins.x = std::max(mins.x, child->bounds.mins.x); mins.y = std::min(mins.y, child->bounds.mins.y); maxs.x = std::min(maxs.x, child->bounds.maxs.x); maxs.y = std::max(maxs.y, child->bounds.maxs.y); } break; case 2: for (auto* child = routeEntry.children; child != nullptr; child = child->children) { mins.x = std::max(mins.x, child->bounds.mins.x); mins.y = std::max(mins.y, child->bounds.mins.y); maxs.x = std::min(maxs.x, child->bounds.maxs.x); maxs.y = std::min(maxs.y, child->bounds.maxs.y); } break; case 3: for (auto* child = routeEntry.children; child != nullptr; child = child->children) { mins.x = std::min(mins.x, child->bounds.mins.x); mins.y = std::max(mins.y, child->bounds.mins.y); maxs.x = std::max(maxs.x, child->bounds.maxs.x); maxs.y = std::min(maxs.y, child->bounds.maxs.y); } break; } return { mins, maxs }; } void PaintSession::finaliseOrdering(std::span<PaintStruct*> paintStructs) { auto* routeEntry = appendTogetherStructs(paintStructs); if (routeEntry == nullptr) { return; } routeEntry->bounds = getMinMaxXYBounding(*routeEntry, getRotation()); addPSToQuadrant(*routeEntry); } // 0x0045CA67 void PaintSession::finaliseTrackRoadOrdering() { finaliseOrdering(_trackRoadPaintStructs); } // 0x0045CC1B void PaintSession::finaliseTrackRoadAdditionsOrdering() { finaliseOrdering(_trackRoadAdditionsPaintStructs); } // Note: Size includes for 1 extra at end that should never be anything other than 0xFF, 0xFF or 0, 0 std::span<TunnelEntry> PaintSession::getTunnels(uint8_t edge) { switch (edge) { case 0: return _tunnels0; case 1: return _tunnels1; case 2: return _tunnels2; case 3: return _tunnels3; } return std::span<TunnelEntry>(); } bool showAiPlanningGhosts() { return Config::get().showAiPlanningAsGhosts; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/Paint.h ```h #pragma once #include "Graphics/ImageId.h" #include "Localisation/FormatArguments.hpp" #include "Types.hpp" #include "Viewport.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/Ui/Point.hpp> #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <array> #include <sfl/static_vector.hpp> #include <span> namespace OpenLoco::World { struct TileElement; } namespace OpenLoco { struct EntityBase; } namespace OpenLoco::Ui::ViewportInteraction { struct InteractionArg; enum class InteractionItem : uint8_t; enum class InteractionItemFlags : uint32_t; } namespace OpenLoco::Gfx { struct RenderTarget; } namespace OpenLoco::Paint { enum class SegmentFlags : uint16_t { none = 0U, x0y0 = 1U << 0, // 0: (x:0, y:0) x2y0 = 1U << 1, // 2: (x:2, y:0) x0y2 = 1U << 2, // 6: (x:0, y:2) x2y2 = 1U << 3, // 8: (x:2, y:2) x1y1 = 1U << 4, // 4: (x:1, y:1) x1y0 = 1U << 5, // 1: (x:1, y:0) x0y1 = 1U << 6, // 3: (x:0, y:1) x2y1 = 1U << 7, // 5: (x:2, y:1) x1y2 = 1U << 8, // 7: (x:1, y:2) all = x0y0 | x2y0 | x0y2 | x2y2 | x1y1 | x1y0 | x0y1 | x2y1 | x1y2, }; OPENLOCO_ENABLE_ENUM_OPERATORS(SegmentFlags); // Handy array for converting a bit index to the flag constexpr std::array<SegmentFlags, 9> kSegmentOffsets = { SegmentFlags::x0y0, SegmentFlags::x2y0, SegmentFlags::x0y2, SegmentFlags::x2y2, SegmentFlags::x1y1, SegmentFlags::x1y0, SegmentFlags::x0y1, SegmentFlags::x2y1, SegmentFlags::x1y2 }; namespace { constexpr std::array<std::array<uint8_t, 4>, 4> kSegMap1 = { std::array<uint8_t, 4>{ 0, 1, 2, 3 }, std::array<uint8_t, 4>{ 2, 0, 3, 1 }, std::array<uint8_t, 4>{ 3, 2, 1, 0 }, std::array<uint8_t, 4>{ 1, 3, 0, 2 }, }; constexpr std::array<std::array<uint8_t, 4>, 4> kSegMap2 = { std::array<uint8_t, 4>{ 0, 1, 2, 3 }, std::array<uint8_t, 4>{ 1, 3, 0, 2 }, std::array<uint8_t, 4>{ 3, 2, 1, 0 }, std::array<uint8_t, 4>{ 2, 0, 3, 1 }, }; } constexpr SegmentFlags rotlSegmentFlags(SegmentFlags val, uint8_t rotation) { SegmentFlags ret = SegmentFlags::none; const auto _val = enumValue(val); for (auto i = 0U; i < 4; ++i) { if (_val & (1U << i)) { ret |= static_cast<SegmentFlags>(1U << kSegMap1[rotation][i]); } } for (auto i = 5U; i < 9; ++i) { if (_val & (1U << i)) { ret |= static_cast<SegmentFlags>(1U << (kSegMap2[rotation][i - 5] + 5)); } } return ret | (val & SegmentFlags::x1y1); } static_assert(rotlSegmentFlags(SegmentFlags::x0y1 | SegmentFlags::x1y1 | SegmentFlags::x2y1, 0) == (SegmentFlags::x0y1 | SegmentFlags::x1y1 | SegmentFlags::x2y1)); // Used by both AttachedPaintStruct and PaintStruct enum class PaintStructFlags : uint8_t { none = 0U, hasMaskedImage = 1U << 0, }; OPENLOCO_ENABLE_ENUM_OPERATORS(PaintStructFlags); struct AttachedPaintStruct { AttachedPaintStruct* next; ImageId imageId; ImageId maskedImageId; Ui::Point vpPos; PaintStructFlags flags; }; struct PaintStringStruct { PaintStringStruct* next; const int8_t* yOffsets; FormatArgumentsBuffer argsBuf; Ui::Point vpPos; StringId stringId; uint16_t colour; }; struct PaintStructBoundBox { World::Pos3 mins; World::Pos3 maxs; }; enum class QuadrantFlags : uint8_t { none = 0U, pendingVisit = 1U << 0, outsideQuadrant = 1U << 7, neighbour = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(QuadrantFlags); struct PaintStruct { PaintStructBoundBox bounds; AttachedPaintStruct* attachedPS; PaintStruct* nextQuadrantPS; union { World::TileElement* tileElement; EntityBase* entity; }; ImageId imageId; ImageId maskedImageId; PaintStruct* children; Ui::Point vpPos; World::Pos2 mapPos; uint16_t quadrantIndex; uint16_t pad_2A; uint8_t modId; // used for track mods and signal sides PaintStructFlags flags; QuadrantFlags quadrantFlags; Ui::ViewportInteraction::InteractionItem type; constexpr bool hasQuadrantFlags(QuadrantFlags flagsToTest) const { return (quadrantFlags & flagsToTest) != QuadrantFlags::none; } }; struct SupportHeight { uint16_t height; uint8_t slope; uint8_t var_03; // Used by general support height only }; struct TunnelEntry { World::MicroZ height; uint8_t type; constexpr bool operator==(const TunnelEntry&) const = default; }; struct BridgeEntry { ImageId imageBase; // 0x00525CF2 uint32_t padImage1; // 0x00525CE8 used only in bridge paint here just to keep struct size uint32_t padImage2; // 0x00525CEC used only in bridge paint here just to keep struct size uint16_t subType; // 0x00525CE6 int16_t height; // 0x00525CE4 uint8_t edgesQuarters; // 0x00525CF0 uint8_t objectId; // 0x00525CF1 constexpr BridgeEntry() = default; constexpr BridgeEntry(coord_t _height, uint8_t _subType, uint8_t edges, uint8_t quarters, uint8_t _objectId, ImageId _imageBase) : imageBase(_imageBase) , padImage1(0) , padImage2(0) , subType(_subType) , height(_height) , edgesQuarters((edges << 4U) | quarters) , objectId(_objectId) {}; bool isEmpty() const { return height == -1; } }; constexpr auto kNullBridgeEntry = BridgeEntry(-1, 0, 0, 0, 0, ImageId(0)); struct TrackRoadAdditionSupports { int16_t height; // 0x00F003F4 support height 0 == no supports at all SegmentFlags occupiedSegments; // 0x00F003F6 segments that the support can't be placed uint32_t segmentImages[9]; // 0x00F003F8 0 == no support here uint8_t segmentFrequency[9]; // 0x00F0041C fewer bits set == higher frequency of supports Ui::ViewportInteraction::InteractionItem segmentInteractionType[9]; // 0x00F00425 why isn't mod id set??? void* segmentInteractionItem[9]; // 0x00F0042E }; struct GenerationParameters; struct SessionOptions { uint8_t rotation; int16_t foregroundCullHeight; Ui::ViewportFlags viewFlags; constexpr bool hasFlags(Ui::ViewportFlags flagsToTest) const { return (viewFlags & flagsToTest) != Ui::ViewportFlags::none; } }; static constexpr auto kMaxPaintEntries = 4000U; static constexpr auto kMaxPaintQuadrants = 1024; struct PaintSession { public: PaintSession(const Gfx::RenderTarget& rt, const SessionOptions& options); void generate(); void arrangeStructs(); void drawStructs(Gfx::DrawingContext& drawingCtx); void drawStringStructs(Gfx::DrawingContext& drawingCtx); [[nodiscard]] Ui::ViewportInteraction::InteractionArg getNormalInteractionInfo(const Ui::ViewportInteraction::InteractionItemFlags flags); [[nodiscard]] Ui::ViewportInteraction::InteractionArg getStationNameInteractionInfo(const Ui::ViewportInteraction::InteractionItemFlags flags); [[nodiscard]] Ui::ViewportInteraction::InteractionArg getTownNameInteractionInfo(const Ui::ViewportInteraction::InteractionItemFlags flags); const Gfx::RenderTarget* getRenderTarget() { return _renderTarget; } uint8_t getRotation() { return currentRotation; } void setRotation(uint8_t rotation) { currentRotation = rotation; } int16_t getMaxHeight() { return _maxHeight; } uint32_t getRoadExits() { return _roadMergeExits; } void setRoadExits(uint32_t value) { _roadMergeExits = value; } uint32_t getMergeRoadBaseImage() { return _roadMergeBaseImage; } void setMergeRoadBaseImage(uint32_t value) { _roadMergeBaseImage = value; } int16_t getMergeRoadHeight() { return _roadMergeHeight; } void setMergeRoadHeight(int16_t value) { _roadMergeHeight = value; } uint16_t getMergeRoadStreetlight() { return _roadMergeStreetlightType; } void setMergeRoadStreetlight(uint16_t value) { _roadMergeStreetlightType = value; } int16_t getAdditionSupportHeight() { return _trackRoadAdditionSupports.height; } const TrackRoadAdditionSupports& getAdditionSupport() { return _trackRoadAdditionSupports; } void setAdditionSupport(const TrackRoadAdditionSupports& newValue) { _trackRoadAdditionSupports = newValue; } const SupportHeight& getGeneralSupportHeight() { return _support; } const SupportHeight& getSupportHeight(uint8_t segment) { return _supportSegments[segment]; } const BridgeEntry& getBridgeEntry() { return _bridgeEntry; } SegmentFlags get525CF8() { return _525CF8; } int16_t getWaterHeight() { return _waterHeight; } int16_t getWaterHeight2() { return _waterHeight2; } int16_t getSurfaceHeight() { return _surfaceHeight; } uint8_t getSurfaceSlope() { return _surfaceSlope; } SegmentFlags getOccupiedAdditionSupportSegments() { return _trackRoadAdditionSupports.occupiedSegments; } World::Pos2 getUnkPosition() { return World::Pos2{ _unkPositionX, _unkPositionY }; } World::Pos2 getSpritePosition() { return World::Pos2{ _spritePositionX, _spritePositionY }; } Ui::ViewportFlags getViewFlags() { return _viewFlags; } // TileElement or Entity void setCurrentItem(void* item) { _currentItem = item; } void* getCurrentItem() { return _currentItem; } void setItemType(const Ui::ViewportInteraction::InteractionItem type) { _itemType = type; } Ui::ViewportInteraction::InteractionItem getItemType() { return _itemType; } void setTrackModId(const uint8_t mod) { _trackModId = mod; } void setEntityPosition(const World::Pos2& pos); void setMapPosition(const World::Pos2& pos); void setUnkPosition(const World::Pos2& pos); void setVpPosition(const Ui::Point& pos); void setUnkVpY(const uint16_t y) { _unkVpPositionY = y; } void setSegmentsSupportHeight(const SegmentFlags segments, const uint16_t height, const uint8_t slope); void setSegmentSupportHeight(const uint8_t segment, const uint16_t height, const uint8_t slope); void setGeneralSupportHeight(const uint16_t height, const uint8_t slope); void setMaxHeight(const World::Pos2& loc); void set525CF8(const SegmentFlags segments) { _525CF8 = segments; } void setOccupiedAdditionSupportSegments(const SegmentFlags newValue) { _trackRoadAdditionSupports.occupiedSegments = newValue; } void setBridgeEntry(const BridgeEntry newValue) { _bridgeEntry = newValue; } void resetTileColumn(const Ui::Point& pos); void resetTunnels(); void resetLastPS() { _lastPS = nullptr; } void setBoundingBoxOffset(const World::Pos3& bbox) { _boundingBoxOffset = bbox; } World::Pos3 getBoundingBoxOffset() const { return _boundingBoxOffset; } void finaliseTrackRoadOrdering(); void finaliseTrackRoadAdditionsOrdering(); std::span<TunnelEntry> getTunnels(uint8_t edge); void insertTunnel(coord_t z, uint8_t tunnelType, uint8_t edge); void insertTunnels(const std::array<int16_t, 4>& tunnelHeights, coord_t height, uint8_t tunnelType); void setDidPassSurface(bool value) { _didPassSurface = value; } void setSurfaceSlope(uint8_t slope) { _surfaceSlope = slope; } void setSurfaceHeight(int16_t height) { _surfaceHeight = height; } void setWaterHeight(int16_t height) { _waterHeight = height; } void setWaterHeight2(int16_t height) { _waterHeight2 = height; } PaintStruct* getLastPS() { return _lastPS; } void setLastPS(PaintStruct* ps) { _lastPS = ps; } /* * @param amount @<eax> * @param stringId @<bx> * @param z @<dx> * @param xOffset @<si> * @param yOffsets @<edi> * @param rotation @<ebp> * @param colour @<0xE3F0A8> */ PaintStringStruct* addToStringPlotList(const uint32_t amount, const StringId stringId, const uint16_t z, const int16_t xOffset, const int8_t* yOffsets, const uint16_t colour); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param offsetX @<al> * @param offsetY @<cl> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> */ PaintStruct* addToPlotListAsParent(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxSize); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param offsetX @<al> * @param offsetY @<cl> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> * @param boundBoxOffsetX @<0xE3F0A0> * @param boundBoxOffsetY @<0xE3F0A2> * @param boundBoxOffsetZ @<0xE3F0A4> */ PaintStruct* addToPlotListAsParent(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> * @param boundBoxOffsetX @<0xE3F0A0> * @param boundBoxOffsetY @<0xE3F0A2> * @param boundBoxOffsetZ @<0xE3F0A4> */ PaintStruct* addToPlotList4FD150(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param offsetX @<al> * @param offsetY @<cl> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> * @param boundBoxOffsetX @<0xE3F0A0> * @param boundBoxOffsetY @<0xE3F0A2> * @param boundBoxOffsetZ @<0xE3F0A4> */ PaintStruct* addToPlotListAsChild(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param priority @<ecx> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> * @param boundBoxOffsetX @<0xE3F0A0> * @param boundBoxOffsetY @<0xE3F0A2> * @param boundBoxOffsetZ @<0xE3F0A4> */ PaintStruct* addToPlotListTrackRoad(ImageId imageId, uint32_t priority, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param priority @<ecx> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> * @param boundBoxOffsetX @<0xE3F0A0> * @param boundBoxOffsetY @<0xE3F0A2> * @param boundBoxOffsetZ @<0xE3F0A4> */ PaintStruct* addToPlotListTrackRoadAddition(ImageId imageId, uint32_t priority, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); /* * @param rotation @<ebp> * @param imageId @<ebx> * @param offsetX @<al> * @param offsetY @<cl> * @param offsetZ @<dx> * @param boundBoxLengthX @<di> * @param boundBoxLengthY @<si> * @param boundBoxLengthZ @<ah> * @param boundBoxOffsetX @<0xE3F0A0> * @param boundBoxOffsetY @<0xE3F0A2> * @param boundBoxOffsetZ @<0xE3F0A4> */ PaintStruct* addToPlotList4FD200(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); /* * @param imageId @<ebx> * @param offsetX @<ax> * @param offsetY @<cx> */ AttachedPaintStruct* attachToPrevious(ImageId imageId, const Ui::Point& offset); private: void generateTilesAndEntities(GenerationParameters&& p); void finaliseOrdering(std::span<PaintStruct*> paintStructs); union PaintEntry { PaintStruct basic; AttachedPaintStruct attached; PaintStringStruct string; PaintEntry() {} }; assert_struct_size(PaintEntry, 0x34); // Do not null-initialize this, its too expensive, this is storage. sfl::static_vector<PaintEntry, kMaxPaintEntries> _paintEntries; const Gfx::RenderTarget* _renderTarget{}; PaintStruct* _paintHead{}; coord_t _spritePositionX{}; coord_t _unkPositionX{}; int16_t _vpPositionX{}; coord_t _spritePositionY{}; coord_t _unkPositionY{}; int16_t _vpPositionY{}; int16_t _unkVpPositionY{}; bool _didPassSurface{}; World::Pos3 _boundingBoxOffset{}; int16_t _foregroundCullingHeight{}; Ui::ViewportInteraction::InteractionItem _itemType{}; uint8_t _trackModId{}; World::Pos2 _mapPosition{}; void* _currentItem{}; uint8_t currentRotation{}; // new field set from 0x00E3F0B8 but split out into this struct as separate item Ui::ViewportFlags _viewFlags{}; std::array<PaintStruct*, kMaxPaintQuadrants> _quadrants; uint32_t _quadrantBackIndex; uint32_t _quadrantFrontIndex; std::array<PaintStruct*, 5> _trackRoadPaintStructs; std::array<PaintStruct*, 2> _trackRoadAdditionsPaintStructs; int32_t _E400EC{}; int16_t _E400F0{}; int16_t _E400F2{}; int32_t _E400F4{}; int32_t _E400F8{}; int32_t _E400FC{}; int32_t _E40100{}; int16_t _E40104{}; int32_t _E40108{}; int32_t _E4010C{}; int32_t _E40110{}; PaintStringStruct* _paintStringHead{}; PaintStringStruct* _lastPaintString{}; PaintStruct* _lastPS{}; // Different globals that don't really belong to PaintSession. std::array<uint8_t, 4> _tunnelCounts{}; std::array<TunnelEntry, 33> _tunnels0{}; // There are only 32 entries but 33 and -1 are also writeable for marking the end/start std::array<TunnelEntry, 33> _tunnels1{}; // There are only 32 entries but 33 and -1 are also writeable for marking the end/start std::array<TunnelEntry, 33> _tunnels2{}; // There are only 32 entries but 33 and -1 are also writeable for marking the end/start std::array<TunnelEntry, 33> _tunnels3{}; // There are only 32 entries but 33 and -1 are also writeable for marking the end/start BridgeEntry _bridgeEntry{}; SegmentFlags _525CF8{}; const void* _currentlyDrawnItem{}; int16_t _maxHeight{}; TrackRoadAdditionSupports _trackRoadAdditionSupports{}; SupportHeight _supportSegments[9]{}; SupportHeight _support{}; int16_t _waterHeight{}; int16_t _waterHeight2{}; uint8_t _surfaceSlope{}; int16_t _surfaceHeight{}; uint32_t _roadMergeBaseImage{}; uint32_t _roadMergeExits{}; int16_t _roadMergeHeight{}; uint16_t _roadMergeStreetlightType{}; // From OpenRCT2 equivalent fields not found yet or new // AttachedPaintStruct* unkF1AD2C; // no equivalent // PaintStruct* woodenSupportsPrependTo; // uint8_t verticalTunnelHeight; // const Map::TileElement* surfaceElement; // Map::TileElement* pathElementOnSameHeight; // Map::TileElement* trackElementOnSameHeight; // uint8_t unk141E9DB; // uint32_t trackColours[4]; template<typename T> T* allocatePaintStruct() { static_assert(std::same_as<T, PaintStruct> || std::same_as<T, AttachedPaintStruct> || std::same_as<T, PaintStringStruct>); if (_paintEntries.full()) { return nullptr; } auto& ps = _paintEntries.emplace_back(); auto* specificPs = reinterpret_cast<T*>(&ps); *specificPs = {}; // Zero out the struct return specificPs; } void attachStringStruct(PaintStringStruct& psString); void addPSToQuadrant(PaintStruct& ps); PaintStruct* createNormalPaintStruct(ImageId imageId, const World::Pos3& offset, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); }; bool showAiPlanningGhosts(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintAirport.cpp ```cpp #include "PaintAirport.h" #include "Graphics/RenderTarget.h" #include "Map/StationElement.h" #include "Objects/AirportObject.h" #include "Objects/ObjectManager.h" #include "Paint.h" #include "ScenarioManager.h" #include "Ui/ViewportInteraction.h" #include "World/CompanyManager.h" namespace OpenLoco::Paint { // TODO: Docks, Airport, Building, Industry all have very similar code... constexpr World::Pos3 kImageOffsetBase1x1 = { 16, 16, 0 }; constexpr World::Pos3 kImageOffsetBase2x2 = { 0, 0, 0 }; constexpr World::Pos3 kBBOffsetBase1x1 = { 3, 3, 0 }; constexpr World::Pos3 kBBOffsetBase2x2 = { -8, -8, 0 }; constexpr World::Pos3 kBBSizeBase1x1 = { 26, 26, 0 }; constexpr World::Pos3 kBBSizeBase2x2 = { 38, 38, 0 }; static void paintAirportBuilding(PaintSession& session, const World::StationElement& elStation, const AirportObject& airportObj, const World::Pos3& imageOffset, const World::Pos3& bbOffset, const World::Pos3& bbSize, const ImageId& baseColour, const uint8_t rotation) { // 0xE0C3A0 const auto ticks = ScenarioManager::getScenarioTicks(); const auto variation = elStation.buildingType(); const auto parts = airportObj.getBuildingParts(variation); const auto heights = airportObj.getBuildingPartHeights(); const auto animations = airportObj.getBuildingPartAnimations(); auto sectionImageOffset = imageOffset; for (const auto part : parts) { const auto partAnimation = animations[part]; auto frameMask = partAnimation.numFrames - 1; auto cl = partAnimation.animationSpeed & 0x7F; auto tickThing = ticks >> cl; if (partAnimation.animationSpeed & (1 << 7)) { auto pos = World::toTileSpace(session.getUnkPosition()); tickThing += pos.x * 5; tickThing += pos.y * 3; } const auto adjustedPart = part + (frameMask & tickThing); const auto sectionHeight = heights[adjustedPart]; const uint32_t imageIdx = adjustedPart * 4 + airportObj.buildingImage + rotation; ImageId image = baseColour.withIndex(imageIdx); session.addToPlotListAsChild(image, sectionImageOffset, bbOffset, bbSize); sectionImageOffset.z += sectionHeight; } } // 0x0048B4D0 void paintAirport(PaintSession& session, const World::StationElement& elStation) { session.setItemType(Ui::ViewportInteraction::InteractionItem::airport); auto* airportObj = ObjectManager::get<AirportObject>(elStation.objectId()); const auto companyColour = CompanyManager::getCompanyColour(elStation.owner()); ImageId baseColour(0, companyColour); if (elStation.isGhost()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); baseColour = Gfx::applyGhostToImage(0); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } // Combine this with any imageId const uint8_t rotation = (session.getRotation() + elStation.rotation()) & 0x3; const auto variation = elStation.buildingType(); // Odd... different to industry, building, dock auto clearHeight = 0; const auto heights = airportObj->getBuildingPartHeights(); for (auto part : airportObj->getBuildingParts(variation)) { clearHeight += heights[part]; } // ceil to 4 clearHeight += 3; clearHeight &= ~3; const int16_t bbLengthZ = std::min(clearHeight, 128) - 2; const auto baseHeight = elStation.baseHeight(); bool isMultiTile = airportObj->largeTiles & (1U << variation); // Note: Image offsets will change as you move up the building but bboffset/size does not const World::Pos3 imageOffset = (isMultiTile ? kImageOffsetBase2x2 : kImageOffsetBase1x1) + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbOffset = (isMultiTile ? kBBOffsetBase2x2 : kBBOffsetBase1x1) + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbSize = (isMultiTile ? kBBSizeBase2x2 : kBBSizeBase1x1) + World::Pos3{ 0, 0, bbLengthZ }; session.resetLastPS(); // Odd... if (airportObj->hasFlags(AirportObjectFlags::hasShadows)) { if (session.getRenderTarget()->zoomLevel <= 1) { const auto shadowImageOffset = variation * 4 + airportObj->image + rotation + 1; const ImageId shadowImage = ImageId(shadowImageOffset).withTranslucency(Colours::getShadow(Colour::orange)); if (isMultiTile) { session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } else { session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } } } if (isMultiTile) { const auto sequenceIndex = elStation.sequenceIndex(); // Only the front of the 2x2 area will draw. Images are sized to overlap into the other tiles. if ((sequenceIndex ^ (1 << 1)) == ((-session.getRotation()) & 0x3)) { paintAirportBuilding(session, elStation, *airportObj, imageOffset, bbOffset, bbSize, baseColour, rotation); } session.setSegmentsSupportHeight(SegmentFlags::all, 0xFFFF, 0); session.setGeneralSupportHeight(0xFFFF, 0); // TODO: Check if this works previously would not set slope to zero } else { paintAirportBuilding(session, elStation, *airportObj, imageOffset, bbOffset, bbSize, baseColour, rotation); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintAirport.h ```h #pragma once namespace OpenLoco::World { struct StationElement; } namespace OpenLoco::Paint { struct PaintSession; void paintAirport(PaintSession& session, const World::StationElement& elStation); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintBridge.cpp ```cpp #include "PaintBridge.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Objects/BridgeObject.h" #include "Objects/ObjectManager.h" #include "Paint.h" #include "Ui/ViewportInteraction.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::Paint { struct DeckImages { uint32_t deck; uint32_t wallLhs; uint32_t wallRhs; }; // Based on 0x004F91FE constexpr std::array<DeckImages, 16> k4F91FE = { DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeNE0, Bridge::ImageIds::deckWallLhsGentleSlopeNE0, Bridge::ImageIds::deckWallRhsGentleSlopeNE0, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeNE1, Bridge::ImageIds::deckWallLhsGentleSlopeNE1, Bridge::ImageIds::deckWallRhsGentleSlopeNE1, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeSE0, Bridge::ImageIds::deckWallLhsGentleSlopeSE0, Bridge::ImageIds::deckWallRhsGentleSlopeSE0, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeSE1, Bridge::ImageIds::deckWallLhsGentleSlopeSE1, Bridge::ImageIds::deckWallRhsGentleSlopeSE1, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeSW0, Bridge::ImageIds::deckWallLhsGentleSlopeSW0, Bridge::ImageIds::deckWallRhsGentleSlopeSW0, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeSW1, Bridge::ImageIds::deckWallLhsGentleSlopeSW1, Bridge::ImageIds::deckWallRhsGentleSlopeSW1, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeNW0, Bridge::ImageIds::deckWallLhsGentleSlopeNW0, Bridge::ImageIds::deckWallRhsGentleSlopeNW0, }, DeckImages{ Bridge::ImageIds::deckBaseGentleSlopeNW1, Bridge::ImageIds::deckWallLhsGentleSlopeNW1, Bridge::ImageIds::deckWallRhsGentleSlopeNW1, }, DeckImages{ Bridge::ImageIds::deckBaseSteepSlopeNE, Bridge::ImageIds::deckWallLhsSteepSlopeNE, Bridge::ImageIds::deckWallRhsSteepSlopeNE, }, DeckImages{ Bridge::ImageIds::deckBaseSteepSlopeSE, Bridge::ImageIds::deckWallLhsSteepSlopeSE, Bridge::ImageIds::deckWallRhsSteepSlopeSE, }, DeckImages{ Bridge::ImageIds::deckBaseSteepSlopeSW, Bridge::ImageIds::deckWallLhsSteepSlopeSW, Bridge::ImageIds::deckWallRhsSteepSlopeSW, }, DeckImages{ Bridge::ImageIds::deckBaseSteepSlopeNW, Bridge::ImageIds::deckWallLhsSteepSlopeNW, Bridge::ImageIds::deckWallRhsSteepSlopeNW, }, DeckImages{ Bridge::ImageIds::deckBaseSlopedCurveEdge0, 0, 0, }, DeckImages{ Bridge::ImageIds::deckBaseSlopedCurveEdge1, 0, 0, }, DeckImages{ Bridge::ImageIds::deckBaseSlopedCurveEdge2, 0, 0, }, DeckImages{ Bridge::ImageIds::deckBaseSlopedCurveEdge3, 0, 0, }, }; struct SpanImages { uint32_t deck; uint32_t supportHeaderLhs; uint32_t supportHeaderRhs; uint32_t wallLhs; uint32_t wallRhs; uint32_t roof; }; std::array<std::array<SpanImages, 4>, 2> kSpanImages = { std::array<SpanImages, 4>{ SpanImages{ Bridge::ImageIds::deckBaseNEspan0, Bridge::ImageIds::supportHeaderLhsNEspan0, Bridge::ImageIds::supportHeaderRhsNEspan0, Bridge::ImageIds::deckWallLhsNEspan0, Bridge::ImageIds::deckWallRhsNEspan0, Bridge::ImageIds::roofNEspan0 }, SpanImages{ Bridge::ImageIds::deckBaseNEspan1, Bridge::ImageIds::supportHeaderLhsNEspan1, Bridge::ImageIds::supportHeaderRhsNEspan1, Bridge::ImageIds::deckWallLhsNEspan1, Bridge::ImageIds::deckWallRhsNEspan1, Bridge::ImageIds::roofNEspan1 }, SpanImages{ Bridge::ImageIds::deckBaseNEspan2, Bridge::ImageIds::supportHeaderLhsNEspan2, Bridge::ImageIds::supportHeaderRhsNEspan2, Bridge::ImageIds::deckWallLhsNEspan2, Bridge::ImageIds::deckWallRhsNEspan2, Bridge::ImageIds::roofNEspan2 }, SpanImages{ Bridge::ImageIds::deckBaseNEspan3, Bridge::ImageIds::supportHeaderLhsNEspan3, Bridge::ImageIds::supportHeaderRhsNEspan3, Bridge::ImageIds::deckWallLhsNEspan3, Bridge::ImageIds::deckWallRhsNEspan3, Bridge::ImageIds::roofNEspan3 }, }, std::array<SpanImages, 4>{ SpanImages{ Bridge::ImageIds::deckBaseSWspan0, Bridge::ImageIds::supportHeaderLhsSWspan0, Bridge::ImageIds::supportHeaderRhsSWspan0, Bridge::ImageIds::deckWallLhsSWspan0, Bridge::ImageIds::deckWallRhsSWspan0, Bridge::ImageIds::roofSWspan0 }, SpanImages{ Bridge::ImageIds::deckBaseSWspan1, Bridge::ImageIds::supportHeaderLhsSWspan1, Bridge::ImageIds::supportHeaderRhsSWspan1, Bridge::ImageIds::deckWallLhsSWspan1, Bridge::ImageIds::deckWallRhsSWspan1, Bridge::ImageIds::roofSWspan1 }, SpanImages{ Bridge::ImageIds::deckBaseSWspan2, Bridge::ImageIds::supportHeaderLhsSWspan2, Bridge::ImageIds::supportHeaderRhsSWspan2, Bridge::ImageIds::deckWallLhsSWspan2, Bridge::ImageIds::deckWallRhsSWspan2, Bridge::ImageIds::roofSWspan2 }, SpanImages{ Bridge::ImageIds::deckBaseSWspan3, Bridge::ImageIds::supportHeaderLhsSWspan3, Bridge::ImageIds::supportHeaderRhsSWspan3, Bridge::ImageIds::deckWallLhsSWspan3, Bridge::ImageIds::deckWallRhsSWspan3, Bridge::ImageIds::roofSWspan3 }, }, }; constexpr std::array<uint16_t, 17> k4F91DC = { 0, 5, 5, 9, 9, 5, 5, 9, 9, 5, 9, 5, 9, 17, 33, 65, 129, }; // Based on 0x004F905C constexpr std::array<uint32_t, 32> kSlopeToSupportEdgeImageRhsNE = { 0, Bridge::ImageIds::supportSegmentRhsSlope2NE, Bridge::ImageIds::supportSegmentRhsSlope1NE, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope2NE, Bridge::ImageIds::supportSegmentRhsSlope1NE, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope2NE, Bridge::ImageIds::supportSegmentRhsSlope1NE, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope2NE, Bridge::ImageIds::supportSegmentRhsSlope1NE, 0, 0, 0, 0, 0, 0, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope1NE, 0, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope2NE, 0, Bridge::ImageIds::supportSegmentRhsSlope2NE, Bridge::ImageIds::supportSegmentRhsSlope1NE, 0, }; // Based on 0x004F909C constexpr std::array<uint32_t, 32> kSlopeToSupportEdgeImageLhsNE = { 0, 0, 0, 0, Bridge::ImageIds::supportSegmentLhsSlope1NE, Bridge::ImageIds::supportSegmentLhsSlope1NE, Bridge::ImageIds::supportSegmentLhsSlope1NE, Bridge::ImageIds::supportSegmentLhsSlope1NE, Bridge::ImageIds::supportSegmentLhsSlope2NE, Bridge::ImageIds::supportSegmentLhsSlope2NE, Bridge::ImageIds::supportSegmentLhsSlope2NE, Bridge::ImageIds::supportSegmentLhsSlope2NE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Bridge::ImageIds::supportSegmentLhsSlope1NE, 0, 0, 0, Bridge::ImageIds::supportSegmentLhsSlope2NE, 0, Bridge::ImageIds::supportSegmentLhsSlope2NE, Bridge::ImageIds::supportSegmentLhsSlope1NE, 0, }; constexpr std::array<int16_t, 32> k4F8F5C = { 0, 16, 16, 16, 0, 16, 16, 16, 0, 16, 16, 16, 0, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 32, 0, 16, 16, 0 }; constexpr std::array<int16_t, 32> k4F8F9C = { 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 16, 0, 32, 32, 0, }; constexpr std::array<int16_t, 32> k4F8FDC = { 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 16, 0, 16, 32, 0, }; constexpr std::array<int16_t, 32> k4F901C = { 0, 16, 0, 16, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 32, 0, 32, 16, 0, }; // Based on 0x004F90DC constexpr std::array<uint32_t, 32> kSlopeToSupportEdgeImageLhsSW = { 0, 0, Bridge::ImageIds::supportSegmentLhsSlope2SW, Bridge::ImageIds::supportSegmentLhsSlope2SW, Bridge::ImageIds::supportSegmentLhsSlope1SW, Bridge::ImageIds::supportSegmentLhsSlope1SW, 0, 0, 0, 0, Bridge::ImageIds::supportSegmentLhsSlope2SW, Bridge::ImageIds::supportSegmentLhsSlope2SW, Bridge::ImageIds::supportSegmentLhsSlope1SW, Bridge::ImageIds::supportSegmentLhsSlope1SW, 0, 0, 0, 0, 0, 0, 0, 0, 0, Bridge::ImageIds::supportSegmentLhsSlope2SW, 0, 0, 0, Bridge::ImageIds::supportSegmentLhsSlope2SW, 0, Bridge::ImageIds::supportSegmentLhsSlope1SW, Bridge::ImageIds::supportSegmentLhsSlope1SW, 0, }; // Based on 0x004F911C constexpr std::array<uint32_t, 32> kSlopeToSupportEdgeImageRhsSW = { 0, Bridge::ImageIds::supportSegmentRhsSlope2SW, 0, Bridge::ImageIds::supportSegmentRhsSlope2SW, 0, Bridge::ImageIds::supportSegmentRhsSlope2SW, 0, Bridge::ImageIds::supportSegmentRhsSlope2SW, Bridge::ImageIds::supportSegmentRhsSlope1SW, 0, Bridge::ImageIds::supportSegmentRhsSlope1SW, 0, Bridge::ImageIds::supportSegmentRhsSlope1SW, 0, Bridge::ImageIds::supportSegmentRhsSlope1SW, 0, 0, 0, 0, 0, 0, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope2SW, 0, 0, 0, Bridge::ImageIds::supportSegmentRhsSlope2SW, 0, Bridge::ImageIds::supportSegmentRhsSlope1SW, Bridge::ImageIds::supportSegmentRhsSlope1SW, 0, }; constexpr std::array<int16_t, 32> k4F915C = { 0, 0, 16, 16, 0, 0, 16, 16, 0, 0, 16, 16, 0, 0, 16, 16, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 16, 0, 0, 16, 0 }; constexpr std::array<int16_t, 32> k4F919C = { 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 32, 16, 0, }; // DUPLICTED FROM PAINTSURFACE // 0x004FD97E // Truncates a SurfaceSlope slope into only the representable values // input is SurfaceSlope 0 <-> 31 with some unrepresentable // output is 0 <-> 18 // unrepresentable will be displayed at 0 (flat) static constexpr std::array<uint8_t, 32> kSlopeToDisplaySlope = { 0, 2, 1, 3, 8, 10, 9, 11, 4, 6, 5, 7, 12, 14, 13, 15, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 18, 15, 0, }; static constexpr std::array<std::array<uint32_t, 19>, 5> kSlopeToBridgeShadow = { std::array<uint32_t, 19>{ ImageIds::bridgeShadowFullTileSlope0, ImageIds::bridgeShadowFullTileSlope1, ImageIds::bridgeShadowFullTileSlope2, ImageIds::bridgeShadowFullTileSlope3, ImageIds::bridgeShadowFullTileSlope4, ImageIds::bridgeShadowFullTileSlope5, ImageIds::bridgeShadowFullTileSlope6, ImageIds::bridgeShadowFullTileSlope7, ImageIds::bridgeShadowFullTileSlope8, ImageIds::bridgeShadowFullTileSlope9, ImageIds::bridgeShadowFullTileSlope10, ImageIds::bridgeShadowFullTileSlope11, ImageIds::bridgeShadowFullTileSlope12, ImageIds::bridgeShadowFullTileSlope13, ImageIds::bridgeShadowFullTileSlope14, ImageIds::bridgeShadowFullTileSlope15, ImageIds::bridgeShadowFullTileSlope16, ImageIds::bridgeShadowFullTileSlope17, ImageIds::bridgeShadowFullTileSlope18, }, std::array<uint32_t, 19>{ ImageIds::bridgeShadowQuarter0Slope0, ImageIds::bridgeShadowQuarter0Slope1, ImageIds::bridgeShadowQuarter0Slope2, ImageIds::bridgeShadowQuarter0Slope3, ImageIds::bridgeShadowQuarter0Slope4, ImageIds::bridgeShadowQuarter0Slope5, ImageIds::bridgeShadowQuarter0Slope6, ImageIds::bridgeShadowQuarter0Slope7, ImageIds::bridgeShadowQuarter0Slope8, ImageIds::bridgeShadowQuarter0Slope9, ImageIds::bridgeShadowQuarter0Slope10, ImageIds::bridgeShadowQuarter0Slope11, ImageIds::bridgeShadowQuarter0Slope12, ImageIds::bridgeShadowQuarter0Slope13, ImageIds::bridgeShadowQuarter0Slope14, ImageIds::bridgeShadowQuarter0Slope15, ImageIds::bridgeShadowQuarter0Slope16, ImageIds::bridgeShadowQuarter0Slope17, ImageIds::bridgeShadowQuarter0Slope18, }, std::array<uint32_t, 19>{ ImageIds::bridgeShadowQuarter1Slope0, ImageIds::bridgeShadowQuarter1Slope1, ImageIds::bridgeShadowQuarter1Slope2, ImageIds::bridgeShadowQuarter1Slope3, ImageIds::bridgeShadowQuarter1Slope4, ImageIds::bridgeShadowQuarter1Slope5, ImageIds::bridgeShadowQuarter1Slope6, ImageIds::bridgeShadowQuarter1Slope7, ImageIds::bridgeShadowQuarter1Slope8, ImageIds::bridgeShadowQuarter1Slope9, ImageIds::bridgeShadowQuarter1Slope10, ImageIds::bridgeShadowQuarter1Slope11, ImageIds::bridgeShadowQuarter1Slope12, ImageIds::bridgeShadowQuarter1Slope13, ImageIds::bridgeShadowQuarter1Slope14, ImageIds::bridgeShadowQuarter1Slope15, ImageIds::bridgeShadowQuarter1Slope16, ImageIds::bridgeShadowQuarter1Slope17, ImageIds::bridgeShadowQuarter1Slope18, }, std::array<uint32_t, 19>{ ImageIds::bridgeShadowQuarter2Slope0, ImageIds::bridgeShadowQuarter2Slope1, ImageIds::bridgeShadowQuarter2Slope2, ImageIds::bridgeShadowQuarter2Slope3, ImageIds::bridgeShadowQuarter2Slope4, ImageIds::bridgeShadowQuarter2Slope5, ImageIds::bridgeShadowQuarter2Slope6, ImageIds::bridgeShadowQuarter2Slope7, ImageIds::bridgeShadowQuarter2Slope8, ImageIds::bridgeShadowQuarter2Slope9, ImageIds::bridgeShadowQuarter2Slope10, ImageIds::bridgeShadowQuarter2Slope11, ImageIds::bridgeShadowQuarter2Slope12, ImageIds::bridgeShadowQuarter2Slope13, ImageIds::bridgeShadowQuarter2Slope14, ImageIds::bridgeShadowQuarter2Slope15, ImageIds::bridgeShadowQuarter2Slope16, ImageIds::bridgeShadowQuarter2Slope17, ImageIds::bridgeShadowQuarter2Slope18, }, std::array<uint32_t, 19>{ ImageIds::bridgeShadowQuarter3Slope0, ImageIds::bridgeShadowQuarter3Slope1, ImageIds::bridgeShadowQuarter3Slope2, ImageIds::bridgeShadowQuarter3Slope3, ImageIds::bridgeShadowQuarter3Slope4, ImageIds::bridgeShadowQuarter3Slope5, ImageIds::bridgeShadowQuarter3Slope6, ImageIds::bridgeShadowQuarter3Slope7, ImageIds::bridgeShadowQuarter3Slope8, ImageIds::bridgeShadowQuarter3Slope9, ImageIds::bridgeShadowQuarter3Slope10, ImageIds::bridgeShadowQuarter3Slope11, ImageIds::bridgeShadowQuarter3Slope12, ImageIds::bridgeShadowQuarter3Slope13, ImageIds::bridgeShadowQuarter3Slope14, ImageIds::bridgeShadowQuarter3Slope15, ImageIds::bridgeShadowQuarter3Slope16, ImageIds::bridgeShadowQuarter3Slope17, ImageIds::bridgeShadowQuarter3Slope18, }, }; constexpr auto kTwosToOnesCompliment = std::to_array<TilePos2>( { { 0, 0 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, }); struct SupportLengths { int16_t lhsSupportLength; // dx int16_t rhsSupportLength; // 0x00525CFC }; static void paintFlatSingleQuarterNoSupport(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, const std::array<uint32_t, 3>& imageIndexs, const World::Pos3& wallBoundingBoxOffset) { const auto baseHeightOffset = World::Pos3{ 0, 0, bridgeEntry.height }; if ((bridgeObj.flags & BridgeObjectFlags::hasRoof) != BridgeObjectFlags::none) { const auto roofImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndexs[0]); constexpr World::Pos3 bbOffset = { 0, 0, 30 }; constexpr World::Pos3 bbLength = { 32, 32, 0 }; session.addToPlotList4FD150(roofImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } const auto offset = baseHeightOffset - World::Pos3{ 0, 0, 16 }; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndexs[1]); constexpr World::Pos3 bbOffset2 = { 0, 0, 14 }; constexpr World::Pos3 bbLength2 = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset2 + offset, bbLength2); if (bridgeEntry.subType == 0) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndexs[2]); constexpr World::Pos3 bbLength3 = { 2, 2, 26 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, wallBoundingBoxOffset + baseHeightOffset, bbLength3); } } // 0x0042C36D static void paintSupportDiagonal(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, int16_t lhsSupportLength, int16_t rhsSupportLength, const int16_t supportHeight) { { auto rhsSupportHeight = supportHeight; while (rhsSupportLength >= 16) { const bool is16section = rhsSupportLength == 16 || ((rhsSupportHeight - 16) == session.getWaterHeight()); const int16_t sectionHeight = is16section ? 16 : 32; const auto bbLength = is16section ? World::Pos3{ 2, 2, 15 } : World::Pos3{ 2, 2, 31 }; const auto imageIndex = is16section ? Bridge::ImageIds::supportSegmentEdge3Lhs16SW : Bridge::ImageIds::supportSegmentEdge3Lhs32SW; rhsSupportHeight -= sectionHeight; rhsSupportLength -= sectionHeight; const auto supportSectionImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndex); const auto heightOffset = World::Pos3{ 0, 0, rhsSupportHeight }; constexpr World::Pos3 bbOffset = { 30, 0, 0 }; session.addToPlotList4FD150(supportSectionImage, heightOffset, bbOffset + heightOffset, bbLength); } } { auto lhsSupportHeight = supportHeight; while (lhsSupportLength >= 16) { const bool is16section = lhsSupportLength == 16 || ((lhsSupportHeight - 16) == session.getWaterHeight()); const int16_t sectionHeight = is16section ? 16 : 32; const auto bbLength = is16section ? World::Pos3{ 2, 2, 15 } : World::Pos3{ 2, 2, 31 }; const auto imageIndex = is16section ? Bridge::ImageIds::supportSegmentEdge3Rhs16SW : Bridge::ImageIds::supportSegmentEdge3Rhs32SW; lhsSupportLength -= sectionHeight; lhsSupportHeight -= sectionHeight; const auto supportSectionImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndex); const auto heightOffset = World::Pos3{ 0, 0, lhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 30, 0 }; session.addToPlotList4FD150(supportSectionImage, heightOffset, bbOffset + heightOffset, bbLength); } } } // 0x0042BF7F static void paintSupportNE(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, const uint8_t pillarSpacing, int16_t lhsSupportLength, int16_t rhsSupportLength, const int16_t supportHeight, const uint32_t supportEdgeLhsImage, const uint32_t supportEdgeRhsImage) { if (pillarSpacing & (1U << 0)) { auto lhsSupportHeight = supportHeight; while (lhsSupportLength >= 16) { const bool is16section = lhsSupportLength == 16 || ((lhsSupportHeight - 16) == session.getWaterHeight()); const int16_t sectionHeight = is16section ? 16 : 32; const auto bbLength = is16section ? World::Pos3{ 2, 32, 15 } : World::Pos3{ 2, 32, 31 }; const auto imageIndex = is16section ? Bridge::ImageIds::supportSegmentLhs16NE : Bridge::ImageIds::supportSegmentLhs32NE; lhsSupportLength -= sectionHeight; lhsSupportHeight -= sectionHeight; const auto supportSectionImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndex); const auto heightOffset = World::Pos3{ 0, 0, lhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 0, 0 }; session.addToPlotList4FD150(supportSectionImage, heightOffset, bbOffset + heightOffset, bbLength); } if (supportEdgeLhsImage != 0) { lhsSupportHeight -= 16; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(supportEdgeLhsImage); const auto heightOffset = World::Pos3{ 0, 0, lhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 0, 0 }; constexpr World::Pos3 bbLength = { 2, 32, 14 }; session.addToPlotList4FD150(image, heightOffset, bbOffset + heightOffset, bbLength); } } if (pillarSpacing & (1U << 1)) { auto rhsSupportHeight = supportHeight; while (rhsSupportLength >= 16) { const bool is16section = rhsSupportLength == 16 || ((rhsSupportHeight - 16) == session.getWaterHeight()); const int16_t sectionHeight = is16section ? 16 : 32; const auto bbLength = is16section ? World::Pos3{ 2, 32, 15 } : World::Pos3{ 2, 32, 31 }; const auto imageIndex = is16section ? Bridge::ImageIds::supportSegmentRhs16NE : Bridge::ImageIds::supportSegmentRhs32NE; rhsSupportLength -= sectionHeight; rhsSupportHeight -= sectionHeight; const auto supportSectionImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndex); const auto heightOffset = World::Pos3{ 0, 0, rhsSupportHeight }; constexpr World::Pos3 bbOffset = { 30, 0, 0 }; session.addToPlotList4FD150(supportSectionImage, heightOffset, bbOffset + heightOffset, bbLength); } if (supportEdgeRhsImage != 0) { rhsSupportHeight -= 16; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(supportEdgeRhsImage); const auto heightOffset = World::Pos3{ 0, 0, rhsSupportHeight }; constexpr World::Pos3 bbOffset = { 30, 0, 0 }; constexpr World::Pos3 bbLength = { 2, 32, 14 }; session.addToPlotList4FD150(image, heightOffset, bbOffset + heightOffset, bbLength); } } } // 0x0042C176 static void paintSupportSW(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, const uint8_t pillarSpacing, int16_t lhsSupportLength, int16_t rhsSupportLength, const int16_t supportHeight, const uint32_t supportEdgeLhsImage, const uint32_t supportEdgeRhsImage) { if (pillarSpacing & (1U << 0)) { auto lhsSupportHeight = supportHeight; while (lhsSupportLength >= 16) { const bool is16section = lhsSupportLength == 16 || ((lhsSupportHeight - 16) == session.getWaterHeight()); const int16_t sectionHeight = is16section ? 16 : 32; const auto bbLength = is16section ? World::Pos3{ 32, 2, 15 } : World::Pos3{ 32, 2, 31 }; const auto imageIndex = is16section ? Bridge::ImageIds::supportSegmentLhs16SW : Bridge::ImageIds::supportSegmentLhs32SW; lhsSupportLength -= sectionHeight; lhsSupportHeight -= sectionHeight; const auto supportSectionImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndex); const auto heightOffset = World::Pos3{ 0, 0, lhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 0, 0 }; session.addToPlotList4FD150(supportSectionImage, heightOffset, bbOffset + heightOffset, bbLength); } if (supportEdgeLhsImage != 0) { lhsSupportHeight -= 16; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(supportEdgeLhsImage); const auto heightOffset = World::Pos3{ 0, 0, lhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 0, 0 }; constexpr World::Pos3 bbLength = { 32, 2, 14 }; session.addToPlotList4FD150(image, heightOffset, bbOffset + heightOffset, bbLength); } } if (pillarSpacing & (1U << 1)) { auto rhsSupportHeight = supportHeight; while (rhsSupportLength >= 16) { const bool is16section = rhsSupportLength == 16 || ((rhsSupportHeight - 16) == session.getWaterHeight()); const int16_t sectionHeight = is16section ? 16 : 32; const auto bbLength = is16section ? World::Pos3{ 32, 2, 15 } : World::Pos3{ 32, 2, 31 }; const auto imageIndex = is16section ? Bridge::ImageIds::supportSegmentRhs16SW : Bridge::ImageIds::supportSegmentRhs32SW; rhsSupportLength -= sectionHeight; rhsSupportHeight -= sectionHeight; const auto supportSectionImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(imageIndex); const auto heightOffset = World::Pos3{ 0, 0, rhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 30, 0 }; session.addToPlotList4FD150(supportSectionImage, heightOffset, bbOffset + heightOffset, bbLength); } if (supportEdgeRhsImage != 0) { rhsSupportHeight -= 16; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(supportEdgeRhsImage); const auto heightOffset = World::Pos3{ 0, 0, rhsSupportHeight }; constexpr World::Pos3 bbOffset = { 0, 30, 0 }; constexpr World::Pos3 bbLength = { 32, 2, 14 }; session.addToPlotList4FD150(image, heightOffset, bbOffset + heightOffset, bbLength); } } } // SPECIAL needs to do the front supports to ground as well // 0x0042BCD5 static void paintFlatSingleQuarterSupportFront(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, const int16_t supportLength, const uint8_t slope) { const auto baseHeightOffset = World::Pos3{ 0, 0, bridgeEntry.height }; if ((bridgeObj.flags & BridgeObjectFlags::hasRoof) != BridgeObjectFlags::none) { const auto roofImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(Bridge::ImageIds::roofEdge3); constexpr World::Pos3 bbOffset = { 0, 0, 30 }; constexpr World::Pos3 bbLength = { 32, 32, 0 }; session.addToPlotList4FD150(roofImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } const auto supportLengths = [&session, &bridgeObj, &bridgeEntry, supportLength, slope]() -> std::optional<SupportLengths> { if (session.getSupportHeight(1).height == 0xFFFFU) { return std::nullopt; } if (session.getSupportHeight(2).height == 0xFFFFU) { return std::nullopt; } int16_t unkHeight = supportLength - bridgeObj.deckDepth; if (unkHeight < 0) { return std::nullopt; } if (bridgeObj.deckDepth == 32) { unkHeight = bridgeEntry.height - 16; if (unkHeight == session.getWaterHeight()) { return std::nullopt; } } const int16_t rhsSupportLength = unkHeight - k4F915C[slope]; if (rhsSupportLength < 0) { return std::nullopt; } const int16_t lhsSupportLenght = unkHeight - k4F919C[slope]; if (unkHeight < 0) { return std::nullopt; } return SupportLengths{ lhsSupportLenght, rhsSupportLength }; }(); if (supportLengths.has_value()) { // 0x0042BD9C const auto& [lhsSupportLenght, rhsSupportLength] = supportLengths.value(); const auto supportHeight = bridgeEntry.height - bridgeObj.deckDepth; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(Bridge::ImageIds::deckBaseWithSupportHeaderEdge3); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; constexpr World::Pos3 bbOffset = { 0, 0, 14 }; constexpr World::Pos3 bbLength = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); paintSupportDiagonal(session, bridgeObj, bridgeEntry, lhsSupportLenght, rhsSupportLength, supportHeight); } else { // 0x0042BE22 const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(Bridge::ImageIds::deckBaseNoSupportEdge3); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, 16 }; constexpr World::Pos3 bbOffset = { 0, 0, 14 }; constexpr World::Pos3 bbLength = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } // 0x0042BE77 if (bridgeEntry.subType == 0) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(Bridge::ImageIds::deckWallEdge3); constexpr World::Pos3 bbOffset = { 17, 17, 2 }; constexpr World::Pos3 bbLength3 = { 2, 2, 24 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength3); } } // 0x0042B4DC static void paintBridgeNE(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, const int16_t supportLength, const uint8_t slope, const uint8_t pillarSpacing, const SpanImages& spanImages) { const auto baseHeightOffset = World::Pos3{ 0, 0, bridgeEntry.height }; if ((bridgeObj.flags & BridgeObjectFlags::hasRoof) != BridgeObjectFlags::none) { const auto roofImageIdx = (bridgeEntry.edgesQuarters & 0xF0) == 0xF0 ? Bridge::ImageIds::roofFullTile : spanImages.roof; const auto roofImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(roofImageIdx); constexpr World::Pos3 bbOffset = { 0, 0, 30 }; constexpr World::Pos3 bbLength = { 32, 32, 0 }; session.addToPlotList4FD150(roofImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } const auto supportLengths = [&session, &bridgeEntry, &bridgeObj, pillarSpacing, supportLength, slope]() -> std::optional<SupportLengths> { if ((bridgeEntry.edgesQuarters & ((1U << 5) | (1U << 4))) == ((1U << 5) | (1U << 4))) { return std::nullopt; } if (pillarSpacing & (1U << 1)) { if (session.getSupportHeight(1).height == 0xFFFFU || session.getSupportHeight(3).height == 0xFFFFU || session.getSupportHeight(7).height == 0xFFFFU) { return std::nullopt; } } if (pillarSpacing & (1U << 0)) { if (session.getSupportHeight(0).height == 0xFFFFU || session.getSupportHeight(2).height == 0xFFFFU || session.getSupportHeight(6).height == 0xFFFFU) { return std::nullopt; } } int16_t unkHeight = supportLength - bridgeObj.deckDepth; if (unkHeight < 0) { return std::nullopt; } if (bridgeObj.deckDepth == 32) { unkHeight = bridgeEntry.height - 16; if (unkHeight == session.getWaterHeight()) { return std::nullopt; } } const int16_t rhsSupportLength = unkHeight - k4F8F5C[slope]; if (rhsSupportLength < 0) { return std::nullopt; } const int16_t lhsSupportLength = unkHeight - k4F8F9C[slope]; if (lhsSupportLength < 0) { return std::nullopt; } return SupportLengths{ lhsSupportLength, rhsSupportLength }; }(); if (supportLengths.has_value()) { const auto& [lhsSupportLength, rhsSupportLength] = supportLengths.value(); const auto supportEdgeRhsImage = kSlopeToSupportEdgeImageRhsNE[slope]; const auto supportEdgeLhsImage = kSlopeToSupportEdgeImageLhsNE[slope]; const auto supportHeight = bridgeEntry.height - bridgeObj.deckDepth; { const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(spanImages.deck); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; const World::Pos3 bbOffset = { 0, 0, static_cast<int16_t>(bridgeObj.deckDepth - 2) }; constexpr World::Pos3 bbLength = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } { const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(spanImages.supportHeaderLhs); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; constexpr World::Pos3 bbOffset = { 0, 0, 0 }; const World::Pos3 bbLength = { 2, 32, static_cast<int16_t>(bridgeObj.deckDepth - 3) }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } { const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(spanImages.supportHeaderRhs); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; constexpr World::Pos3 bbOffset = { 30, 0, 0 }; const World::Pos3 bbLength = { 2, 32, static_cast<int16_t>(bridgeObj.deckDepth - 3) }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } paintSupportNE(session, bridgeObj, bridgeEntry, pillarSpacing, lhsSupportLength, rhsSupportLength, supportHeight, supportEdgeLhsImage, supportEdgeRhsImage); } else { const auto baseImageIdx = (bridgeEntry.edgesQuarters & 0xF0) == 0xF0 ? Bridge::ImageIds::deckBaseNoSupport : spanImages.deck; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(baseImageIdx); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, 16 }; constexpr World::Pos3 bbOffset = { 0, 0, 14 }; constexpr World::Pos3 bbLength = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } } // 0x0042B25D static void paintBridgeSW(PaintSession& session, const BridgeObject& bridgeObj, const BridgeEntry& bridgeEntry, const int16_t supportLength, const uint8_t slope, const uint8_t pillarSpacing, const SpanImages& spanImages) { const auto baseHeightOffset = World::Pos3{ 0, 0, bridgeEntry.height }; if ((bridgeObj.flags & BridgeObjectFlags::hasRoof) != BridgeObjectFlags::none) { const auto roofImageIdx = (bridgeEntry.edgesQuarters & 0xF0) == 0xF0 ? Bridge::ImageIds::roofFullTile : spanImages.roof; const auto roofImage = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(roofImageIdx); constexpr World::Pos3 bbOffset = { 0, 0, 30 }; constexpr World::Pos3 bbLength = { 32, 32, 0 }; session.addToPlotList4FD150(roofImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } const auto supportLengths = [&session, &bridgeEntry, &bridgeObj, pillarSpacing, supportLength, slope]() -> std::optional<SupportLengths> { if ((bridgeEntry.edgesQuarters & ((1U << 6) | (1U << 5))) == ((1U << 6) | (1U << 5))) { return std::nullopt; } if (pillarSpacing & (1U << 0)) { if (session.getSupportHeight(0).height == 0xFFFFU || session.getSupportHeight(1).height == 0xFFFFU || session.getSupportHeight(5).height == 0xFFFFU) { return std::nullopt; } } if (pillarSpacing & (1U << 1)) { if (session.getSupportHeight(2).height == 0xFFFFU || session.getSupportHeight(3).height == 0xFFFFU || session.getSupportHeight(8).height == 0xFFFFU) { return std::nullopt; } } int16_t unkHeight = supportLength - bridgeObj.deckDepth; if (unkHeight < 0) { return std::nullopt; } if (bridgeObj.deckDepth == 32) { unkHeight = bridgeEntry.height - 16; if (unkHeight == session.getWaterHeight()) { return std::nullopt; } } const int16_t rhsSupportLength = unkHeight - k4F901C[slope]; if (rhsSupportLength < 0) { return std::nullopt; } const int16_t lhsSupportLength = unkHeight - k4F8FDC[slope]; if (lhsSupportLength < 0) { return std::nullopt; } return SupportLengths{ lhsSupportLength, rhsSupportLength }; }(); if (supportLengths.has_value()) { const auto& [lhsSupportLength, rhsSupportLength] = supportLengths.value(); const auto supportEdgeRhsImage = kSlopeToSupportEdgeImageRhsSW[slope]; const auto supportEdgeLhsImage = kSlopeToSupportEdgeImageLhsSW[slope]; const auto supportHeight = bridgeEntry.height - bridgeObj.deckDepth; { const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(spanImages.deck); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; const World::Pos3 bbOffset = { 0, 0, static_cast<int16_t>(bridgeObj.deckDepth - 2) }; constexpr World::Pos3 bbLength = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } { const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(spanImages.supportHeaderLhs); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; constexpr World::Pos3 bbOffset = { 0, 0, 0 }; const World::Pos3 bbLength = { 32, 2, static_cast<int16_t>(bridgeObj.deckDepth - 3) }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } { const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(spanImages.supportHeaderRhs); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, bridgeObj.deckDepth }; constexpr World::Pos3 bbOffset = { 0, 30, 0 }; const World::Pos3 bbLength = { 32, 2, static_cast<int16_t>(bridgeObj.deckDepth - 3) }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } paintSupportSW(session, bridgeObj, bridgeEntry, pillarSpacing, lhsSupportLength, rhsSupportLength, supportHeight, supportEdgeLhsImage, supportEdgeRhsImage); } else { const auto baseImageIdx = (bridgeEntry.edgesQuarters & 0xF0) == 0xF0 ? Bridge::ImageIds::deckBaseNoSupport : spanImages.deck; const auto image = bridgeEntry.imageBase.withIndex(bridgeObj.image).withIndexOffset(baseImageIdx); const auto offset = baseHeightOffset - World::Pos3{ 0, 0, 16 }; constexpr World::Pos3 bbOffset = { 0, 0, 14 }; constexpr World::Pos3 bbLength = { 32, 32, 1 }; session.addToPlotList4FD150(image, offset, bbOffset + offset, bbLength); } } // 0x0042AC9C bool paintBridge(PaintSession& session) { session.setItemType(Ui::ViewportInteraction::InteractionItem::bridge); auto& bridgeEntry = session.getBridgeEntry(); if (bridgeEntry.isEmpty()) { return false; } const auto genHeight = Numerics::ceil2(session.getGeneralSupportHeight().height, 16); const auto supportLength = bridgeEntry.height - genHeight; if (supportLength < 0) { return false; } auto* bridgeObj = ObjectManager::get<BridgeObject>(bridgeEntry.objectId); // Height to the base of the bridge platform const auto baseHeightOffset = World::Pos3{ 0, 0, bridgeEntry.height }; if (k4F91DC[bridgeEntry.subType] & (1U << 0)) { const auto& deckImages = k4F91FE[bridgeEntry.subType - 1]; const auto deckImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(deckImages.deck); constexpr World::Pos3 bbOffset = { 2, 2, 0 }; constexpr World::Pos3 bbLength = { 28, 28, 1 }; session.addToPlotList4FD150(deckImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); if (k4F91DC[bridgeEntry.subType] & (1U << 2)) { if (!(bridgeEntry.edgesQuarters & (1U << 7))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(deckImages.wallLhs); constexpr World::Pos3 bbOffset2 = { 2, 0, 8 }; constexpr World::Pos3 bbLength2 = { 28, 1, 30 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset2 + baseHeightOffset, bbLength2); } if (!(bridgeEntry.edgesQuarters & (1U << 5))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(deckImages.wallRhs); constexpr World::Pos3 bbOffset2 = { 1, 30, 8 }; constexpr World::Pos3 bbLength2 = { 29, 1, 30 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset2 + baseHeightOffset, bbLength2); } } if (k4F91DC[bridgeEntry.subType] & (1U << 3)) { if (!(bridgeEntry.edgesQuarters & (1U << 4))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(deckImages.wallLhs); constexpr World::Pos3 bbOffset2 = { 0, 2, 8 }; constexpr World::Pos3 bbLength2 = { 1, 28, 30 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset2 + baseHeightOffset, bbLength2); } if (!(bridgeEntry.edgesQuarters & (1U << 6))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(deckImages.wallRhs); constexpr World::Pos3 bbOffset2 = { 30, 1, 8 }; constexpr World::Pos3 bbLength2 = { 1, 29, 30 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset2 + baseHeightOffset, bbLength2); } } auto offset2 = baseHeightOffset + World::Pos3{ 0, 0, 8 }; if (k4F91DC[bridgeEntry.subType] & (1U << 4)) { const auto image2 = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(Bridge::ImageIds::deckWallEdge0); constexpr World::Pos3 bbOffset2 = { 22, 24, 0 }; constexpr World::Pos3 bbLength2 = { 2, 2, 26 }; session.addToPlotList4FD150(image2, offset2, bbOffset2 + offset2, bbLength2); } if (k4F91DC[bridgeEntry.subType] & (1U << 5)) { const auto image2 = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(Bridge::ImageIds::deckWallEdge1); constexpr World::Pos3 bbOffset2 = { 7, 7, 0 }; constexpr World::Pos3 bbLength2 = { 2, 2, 26 }; session.addToPlotList4FD150(image2, offset2, bbOffset2 + offset2, bbLength2); } if (k4F91DC[bridgeEntry.subType] & (1U << 6)) { const auto image2 = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(Bridge::ImageIds::deckWallEdge2); constexpr World::Pos3 bbOffset2 = { 24, 22, 0 }; constexpr World::Pos3 bbLength2 = { 2, 2, 26 }; session.addToPlotList4FD150(image2, offset2, bbOffset2 + offset2, bbLength2); } if (k4F91DC[bridgeEntry.subType] & (1U << 7)) { const auto image2 = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(Bridge::ImageIds::deckWallEdge3); constexpr World::Pos3 bbOffset2 = { 17, 17, 2 }; constexpr World::Pos3 bbLength2 = { 2, 2, 24 }; session.addToPlotList4FD150(image2, offset2, bbOffset2 + offset2, bbLength2); } } if (!(session.getGeneralSupportHeight().slope & (1U << 5)) && supportLength == 0) { // No shadows generated for this return true; } // Shadow image changes depending on the deck quarters occupied auto shadowType = 0U; const uint8_t slope = session.getGeneralSupportHeight().slope & 0x1FU; const uint8_t quarters = bridgeEntry.edgesQuarters & 0xFU; switch (quarters) { case 1: { // 0x0042B9BA shadowType = 4; paintFlatSingleQuarterNoSupport(session, *bridgeObj, bridgeEntry, { Bridge::ImageIds::roofEdge0, Bridge::ImageIds::deckBaseNoSupportEdge0, Bridge::ImageIds::deckWallEdge0 }, { 22, 24, 0 }); } break; case 2: { // 0x0042BAC3 shadowType = 2; paintFlatSingleQuarterNoSupport(session, *bridgeObj, bridgeEntry, { Bridge::ImageIds::roofEdge1, Bridge::ImageIds::deckBaseNoSupportEdge1, Bridge::ImageIds::deckWallEdge1 }, { 7, 7, 0 }); } break; case 4: // 0x0042BBCC shadowType = 3; paintFlatSingleQuarterNoSupport(session, *bridgeObj, bridgeEntry, { Bridge::ImageIds::roofEdge2, Bridge::ImageIds::deckBaseNoSupportEdge2, Bridge::ImageIds::deckWallEdge2 }, { 24, 22, 0 }); break; case 8: // 0x0042BCD5 // SPECIAL needs to do the front supports to ground as well shadowType = 1; paintFlatSingleQuarterSupportFront(session, *bridgeObj, bridgeEntry, supportLength, slope); break; default: { // 0x0042B08A auto unkTile = World::toTileSpace(Math::Vector::rotate(session.getUnkPosition(), session.getRotation())) + kTwosToOnesCompliment[session.getRotation()]; unkTile.x &= bridgeObj->spanLength - 1; unkTile.y &= bridgeObj->spanLength - 1; const auto xPillarSpacing = bridgeObj->pillarSpacing / (1U << (unkTile.x * 2)); const auto yPillarSpacing = bridgeObj->pillarSpacing / (1U << (unkTile.y * 2)); const auto& xSpanImages = kSpanImages[0][unkTile.x]; const auto& ySpanImages = kSpanImages[1][unkTile.y]; bool bridgeRotation = [&session, &bridgeEntry]() { switch (session.getRotation()) { case 0: case 2: return ( !(bridgeEntry.edgesQuarters & (1U << 5)) || !(bridgeEntry.edgesQuarters & (1U << 7))); case 1: case 3: return !( !(bridgeEntry.edgesQuarters & (1U << 6)) || !(bridgeEntry.edgesQuarters & (1U << 4))); } return false; }(); if (bridgeRotation) { paintBridgeNE(session, *bridgeObj, bridgeEntry, supportLength, slope, xPillarSpacing, xSpanImages); } else { paintBridgeSW(session, *bridgeObj, bridgeEntry, supportLength, slope, yPillarSpacing, ySpanImages); } // 0x0042B837 if (bridgeEntry.subType == 0) { if (!(bridgeEntry.edgesQuarters & (1U << 7))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(xSpanImages.wallLhs); constexpr World::Pos3 bbOffset = { 2, 0, 0 }; constexpr World::Pos3 bbLength = { 28, 1, 26 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } if (!(bridgeEntry.edgesQuarters & (1U << 4))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(ySpanImages.wallLhs); constexpr World::Pos3 bbOffset = { 0, 2, 0 }; constexpr World::Pos3 bbLength = { 1, 28, 26 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } if (!(bridgeEntry.edgesQuarters & (1U << 5))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(xSpanImages.wallRhs); constexpr World::Pos3 bbOffset = { 0, 30, 2 }; constexpr World::Pos3 bbLength = { 28, 1, 24 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } if (!(bridgeEntry.edgesQuarters & (1U << 6))) { const auto wallImage = bridgeEntry.imageBase.withIndex(bridgeObj->image).withIndexOffset(ySpanImages.wallRhs); constexpr World::Pos3 bbOffset = { 30, 2, 2 }; constexpr World::Pos3 bbLength = { 1, 28, 24 }; session.addToPlotList4FD150(wallImage, baseHeightOffset, bbOffset + baseHeightOffset, bbLength); } } break; } } // 0x0042BED2 // Paint shadow if (session.getRenderTarget()->zoomLevel <= 1) { auto displaySlope = 0; auto height = session.getWaterHeight2(); if (height == 0) { height = session.getSurfaceHeight(); displaySlope = kSlopeToDisplaySlope[session.getSurfaceSlope()]; } const auto shadowImage = ImageId(kSlopeToBridgeShadow[shadowType][displaySlope]).withTranslucency(ExtColour::unk32); const World::Pos3 heightOffset = { 0, 0, height }; constexpr World::Pos3 bbOffset2 = { 15, 15, 1 }; constexpr World::Pos3 bbLength2 = { 2, 2, 1 }; session.addToPlotList4FD150(shadowImage, heightOffset, bbOffset2 + heightOffset, bbLength2); } return true; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintBridge.h ```h #pragma once namespace OpenLoco::Paint { struct PaintSession; bool paintBridge(PaintSession& session); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintBuilding.cpp ```cpp #include "PaintBuilding.h" #include "Graphics/RenderTarget.h" #include "Map/BuildingElement.h" #include "Objects/BuildingObject.h" #include "Objects/ObjectManager.h" #include "Objects/ScaffoldingObject.h" #include "Paint.h" #include "ScenarioManager.h" #include "Ui/ViewportInteraction.h" namespace OpenLoco::Paint { // TODO: Docks, Airport, Building, Industry all have very similar code... constexpr World::Pos3 kImageOffsetBase1x1 = { 16, 16, 0 }; constexpr World::Pos3 kImageOffsetBase2x2 = { 0, 0, 0 }; constexpr World::Pos3 kBBOffsetBase1x1 = { 3, 3, 0 }; constexpr World::Pos3 kBBOffsetBase2x2 = { -8, -8, 0 }; constexpr World::Pos3 kBBSizeBase1x1 = { 26, 26, 0 }; constexpr World::Pos3 kBBSizeBase2x2 = { 38, 38, 0 }; static void paintBuildingBuilding(PaintSession& session, const World::BuildingElement& elBuilding, const BuildingObject& buildingObj, const World::Pos3& imageOffset, const World::Pos3& bbOffset, const World::Pos3& bbSize, const ImageId& baseColour, const uint8_t rotation, const bool isMultiTile) { // 0xE0C3A0 auto ticks = ScenarioManager::getScenarioTicks(); uint8_t numSections = 0xF0; // 0xF0 represents all sections completed // Only used when under construction uint8_t sectionProgress = 0; if (!elBuilding.isConstructed()) { ticks = 0; numSections = elBuilding.age(); sectionProgress = elBuilding.unk5u(); } uint32_t variation = elBuilding.variation(); const auto parts = buildingObj.getBuildingParts(variation); // 0x00525D4F uint8_t totalSectionHeight = 0; if (numSections != 0xF0) { int8_t sectionCount = numSections; const auto partHeights = buildingObj.getBuildingPartHeights(); for (const auto part : parts) { totalSectionHeight += partHeights[part]; sectionCount--; if (sectionCount == -1) { totalSectionHeight = std::max<uint8_t>(1, totalSectionHeight); break; } } } // 0x00525D30 (note this should be combined with a applyGhostToImage) const auto scaffoldingColour = buildingObj.scaffoldingColour; const auto scaffSegType = buildingObj.scaffoldingSegmentType; if (totalSectionHeight != 0 && scaffSegType != 0xFF) { const auto* scaffObj = ObjectManager::get<ScaffoldingObject>(); const auto segmentHeight = scaffObj->segmentHeights[scaffSegType]; const auto& scaffImages = isMultiTile ? getScaffoldingImages(scaffSegType).get2x2() : getScaffoldingImages(scaffSegType).get1x1(); uint32_t baseScaffImageIdx = scaffObj->image; ImageId baseScaffImage{}; if (elBuilding.isGhost()) { baseScaffImage = Gfx::applyGhostToImage(baseScaffImageIdx); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } else { baseScaffImage = ImageId(baseScaffImageIdx, scaffoldingColour); } ImageId scaffImage = baseScaffImage.withIndexOffset(scaffImages.back); auto segmentImageOffset = imageOffset; for (coord_t remainingHeight = totalSectionHeight; remainingHeight > 0; remainingHeight -= segmentHeight, segmentImageOffset.z += segmentHeight) { session.addToPlotListAsChild(scaffImage, segmentImageOffset, bbOffset, bbSize); } } int8_t sectionCount = numSections; auto sectionImageOffset = imageOffset; const auto partHeights = buildingObj.getBuildingPartHeights(); const auto partAnimations = buildingObj.getBuildingPartAnimations(); for (const auto part : parts) { if (sectionCount == -1) { break; } const auto partAnimation = partAnimations[part]; auto adjustedPart = part; auto frameMask = partAnimation.numFrames - 1; auto cl = partAnimation.animationSpeed & 0x7F; auto tickThing = ticks >> cl; if (partAnimation.animationSpeed & (1 << 7)) { auto pos = World::toTileSpace(session.getUnkPosition()); tickThing += pos.x * 5; tickThing += pos.y * 3; } adjustedPart += frameMask & tickThing; const auto sectionHeight = partHeights[adjustedPart]; const uint32_t imageIdx = adjustedPart * 4 + buildingObj.image + rotation; ImageId image = baseColour.withIndex(imageIdx); if (sectionCount == 0 && !baseColour.isBlended()) { image = image.withNoiseMask((sectionProgress + 1) & 0x7); } session.addToPlotListAsChild(image, sectionImageOffset, bbOffset, bbSize); sectionImageOffset.z += sectionHeight; sectionCount--; } if (totalSectionHeight != 0 && scaffSegType != 0xFF) { const auto* scaffObj = ObjectManager::get<ScaffoldingObject>(); const auto segmentHeight = scaffObj->segmentHeights[scaffSegType]; const auto& scaffImages = isMultiTile ? getScaffoldingImages(scaffSegType).get2x2() : getScaffoldingImages(scaffSegType).get1x1(); uint32_t baseScaffImageIdx = scaffObj->image; ImageId baseScaffImage{}; if (elBuilding.isGhost()) { baseScaffImage = Gfx::applyGhostToImage(baseScaffImageIdx); } else { baseScaffImage = ImageId(baseScaffImageIdx, scaffoldingColour); } auto scaffImage = baseScaffImage.withIndexOffset(scaffImages.front); auto segmentImageOffset = imageOffset; for (coord_t remainingHeight = totalSectionHeight; remainingHeight > 0; remainingHeight -= segmentHeight, segmentImageOffset.z += segmentHeight) { session.addToPlotListAsChild(scaffImage, segmentImageOffset, bbOffset, bbSize); } scaffImage = baseScaffImage.withIndexOffset(scaffImages.getRoof(rotation)); session.addToPlotListAsChild(scaffImage, segmentImageOffset, bbOffset, bbSize); } if (totalSectionHeight == 0) { for (auto animIdx = 0; animIdx < buildingObj.numElevatorSequences; ++animIdx) { auto sequence = buildingObj.getElevatorHeightSequence(animIdx); auto tickThing = ScenarioManager::getScenarioTicks() / 2; auto pos = World::toTileSpace(session.getUnkPosition()); tickThing += pos.x * 8; tickThing += pos.y * 8; // Sequence is always a power of 2 so (& -1) is like modulo const auto seqIdx = tickThing & (sequence.size() - 1); const auto elevatorHeight = sequence[seqIdx]; const auto image = baseColour.withIndex(buildingObj.image + buildingObj.numParts * 4 + animIdx * 4 + rotation); const auto offset = imageOffset + World::Pos3(0, 0, elevatorHeight); session.addToPlotListAsChild(image, offset, bbOffset, bbSize); } } } // 0x0042C6C4 void paintBuilding(PaintSession& session, const World::BuildingElement& elBuilding) { session.setItemType(Ui::ViewportInteraction::InteractionItem::building); auto* buildingObj = elBuilding.getObject(); if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters)) { session.setItemType(Ui::ViewportInteraction::InteractionItem::headquarterBuilding); } ImageId baseColour(0, elBuilding.colour()); if (elBuilding.isGhost()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); baseColour = Gfx::applyGhostToImage(0); } // Combine this with any imageId const uint8_t rotation = (session.getRotation() + elBuilding.rotation()) & 0x3; // 0x00525D4E const int16_t bbLengthZ = std::min(elBuilding.clearHeight() - elBuilding.baseHeight(), 128) - 2; // 0x00525D18 const auto variation = elBuilding.variation(); const auto baseHeight = elBuilding.baseHeight(); bool isMultiTile = buildingObj->hasFlags(BuildingObjectFlags::largeTile); // Note: Image offsets will change as you move up the building but bboffset/size does not const World::Pos3 imageOffset = (isMultiTile ? kImageOffsetBase2x2 : kImageOffsetBase1x1) + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbOffset = (isMultiTile ? kBBOffsetBase2x2 : kBBOffsetBase1x1) + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbSize = (isMultiTile ? kBBSizeBase2x2 : kBBSizeBase1x1) + World::Pos3{ 0, 0, bbLengthZ }; session.resetLastPS(); // Odd... if (buildingObj->hasFlags(BuildingObjectFlags::hasShadows)) { if (session.getRenderTarget()->zoomLevel <= 1) { const auto shadowImageOffset = (buildingObj->numParts + buildingObj->numElevatorSequences + variation) * 4 + buildingObj->image + rotation; const ImageId shadowImage = ImageId(shadowImageOffset).withTranslucency(Colours::getShadow(Colour::orange)); if (isMultiTile) { session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } else { session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } } } if (isMultiTile) { const auto sequenceIndex = elBuilding.sequenceIndex(); // Only the front of the 2x2 area will draw. Images are sized to overlap into the other tiles. if ((sequenceIndex ^ (1 << 1)) == ((-session.getRotation()) & 0x3)) { paintBuildingBuilding(session, elBuilding, *buildingObj, imageOffset, bbOffset, bbSize, baseColour, rotation, isMultiTile); } session.setSegmentsSupportHeight(SegmentFlags::all, 0xFFFF, 0); session.setGeneralSupportHeight(0xFFFF, 0); // TODO: Check if this works previously would not set slope to zero } else { paintBuildingBuilding(session, elBuilding, *buildingObj, imageOffset, bbOffset, bbSize, baseColour, rotation, isMultiTile); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintBuilding.h ```h #pragma once namespace OpenLoco::World { struct BuildingElement; } namespace OpenLoco::Paint { struct PaintSession; void paintBuilding(PaintSession& session, const World::BuildingElement& elBuilding); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintDocks.cpp ```cpp #include "PaintDocks.h" #include "Graphics/RenderTarget.h" #include "Map/StationElement.h" #include "Objects/DockObject.h" #include "Objects/ObjectManager.h" #include "Paint.h" #include "ScenarioManager.h" #include "Ui/ViewportInteraction.h" #include "World/CompanyManager.h" namespace OpenLoco::Paint { // TODO: Docks, Airport, Building, Industry all have very similar code... constexpr World::Pos3 kImageOffsetBase2x2 = { 0, 0, 0 }; constexpr World::Pos3 kBBOffsetBase2x2 = { -8, -8, 0 }; constexpr World::Pos3 kBBSizeBase2x2 = { 38, 38, 0 }; static void paintDocksBuilding(PaintSession& session, const World::StationElement& elStation, const DockObject& dockObj, const World::Pos3& imageOffset, const World::Pos3& bbOffset, const World::Pos3& bbSize, const ImageId& baseColour, const uint8_t rotation) { const auto ticks = ScenarioManager::getScenarioTicks(); const auto variation = elStation.buildingType(); const auto parts = dockObj.getBuildingParts(variation); auto sectionImageOffset = imageOffset; const auto partHeights = dockObj.getBuildingPartHeights(); const auto partAnimations = dockObj.getBuildingPartAnimations(); for (const auto part : parts) { const auto partAnimation = partAnimations[part]; const auto frameMask = partAnimation.numFrames - 1; const auto cl = partAnimation.animationSpeed & 0x7F; auto tickThing = ticks >> cl; if (partAnimation.animationSpeed & (1 << 7)) { const auto pos = World::toTileSpace(session.getUnkPosition()); tickThing += pos.x * 5; tickThing += pos.y * 3; } const auto adjustedPart = part + (frameMask & tickThing); const auto sectionHeight = partHeights[adjustedPart]; const uint32_t imageIdx = adjustedPart * 4 + dockObj.buildingImage + rotation; const auto image = baseColour.withIndex(imageIdx); session.addToPlotListAsChild(image, sectionImageOffset, bbOffset, bbSize); sectionImageOffset.z += sectionHeight; } } // 0x0048B86E void paintDocks(PaintSession& session, const World::StationElement& elStation) { session.setItemType(Ui::ViewportInteraction::InteractionItem::dock); auto* dockObj = ObjectManager::get<DockObject>(elStation.objectId()); const auto companyColour = CompanyManager::getCompanyColour(elStation.owner()); ImageId baseColour(0, companyColour); if (elStation.isGhost()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); baseColour = Gfx::applyGhostToImage(0); // TODO: apply company colour if playerCompanyID != elTrack.owner()?s } // Combine this with any imageId const auto rotation = (session.getRotation() + elStation.rotation()) & 0x3; const int16_t bbLengthZ = std::min(elStation.clearHeight() - elStation.baseHeight(), 128) - 2; const auto baseHeight = elStation.baseHeight(); const auto variation = elStation.buildingType(); // Note: Image offsets will change as you move up the building but bboffset/size does not const World::Pos3 imageOffset = kImageOffsetBase2x2 + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbOffset = kBBOffsetBase2x2 + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbSize = kBBSizeBase2x2 + World::Pos3{ 0, 0, bbLengthZ }; session.resetLastPS(); // Odd... if (dockObj->hasFlags(DockObjectFlags::hasShadows)) { if (session.getRenderTarget()->zoomLevel <= 1) { const auto shadowImageOffset = variation * 4 + dockObj->image + rotation + 1; const ImageId shadowImage = ImageId(shadowImageOffset).withTranslucency(Colours::getShadow(Colour::orange)); session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } } const auto sequenceIndex = elStation.sequenceIndex(); // Only the front of the 2x2 area will draw. Images are sized to overlap into the other tiles. if ((sequenceIndex ^ (1 << 1)) == ((-session.getRotation()) & 0x3)) { paintDocksBuilding(session, elStation, *dockObj, imageOffset, bbOffset, bbSize, baseColour, rotation); } session.setSegmentsSupportHeight(SegmentFlags::all, 0xFFFF, 0); session.setGeneralSupportHeight(0xFFFF, 0); // TODO: Check if this works previously would not set slope to zero } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintDocks.h ```h #pragma once namespace OpenLoco::World { struct StationElement; } namespace OpenLoco::Paint { struct PaintSession; void paintDocks(PaintSession& session, const World::StationElement& elStation); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintEffectEntity.cpp ```cpp #include "PaintEffectEntity.h" #include "Config.h" #include "Effects/ExhaustEffect.h" #include "Effects/ExplosionEffect.h" #include "Effects/ExplosionSmokeEffect.h" #include "Effects/FireballEffect.h" #include "Effects/MoneyEffect.h" #include "Effects/SmokeEffect.h" #include "Effects/SplashEffect.h" #include "Effects/VehicleCrashEffect.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Localisation/StringIds.h" #include "Map/Tile.h" #include "Objects/SteamObject.h" #include "Paint.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <cassert> #include <unordered_map> using namespace OpenLoco::Interop; namespace OpenLoco::Paint { // 004FAAC8 // This is an array of 22 signed int8 elements which are repeating 20 times, can be optimized after C++ implementation of 0x004FD120 - addToStringPlotList // clang-format off static constexpr int8_t kWiggleYOffsets[440] = { 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, -1, -2, -2, -3, -3, -2, -2, -1, }; // clang-format on // 0x00440331 static void paintExhaustEntity(PaintSession& session, Exhaust* exhaustEntity) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 1) { return; } const auto* steamObject = exhaustEntity->getObject(); const auto& frameInfo = steamObject->getFramesInfo(exhaustEntity->isSubObjType1()); const auto imageId = ImageId{ frameInfo.second[exhaustEntity->frameNum].imageOffset + steamObject->baseImageId + steamObject->var_0A }; if (!steamObject->hasFlags(SteamObjectFlags::unk3)) { session.addToPlotListAsParent(imageId, { 0, 0, exhaustEntity->position.z }, { 1, 1, 0 }); } else { session.addToPlotListAsParent(imageId, { 0, 0, exhaustEntity->position.z }, { -12, -12, exhaustEntity->position.z }, { 24, 24, 0 }); } } // 0x004403C5 static void paintRedGreenCurrencyEntity(PaintSession& session, MoneyEffect* moneyEffect) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 1) { return; } const StringId stringId = moneyEffect->amount >= 0 ? StringIds::format_currency_income_green : StringIds::format_currency_expense_red_negative; uint32_t currencyAmount = abs(moneyEffect->amount); const int8_t* yOffsets = &kWiggleYOffsets[moneyEffect->wiggle]; session.addToStringPlotList(currencyAmount, stringId, moneyEffect->position.z, moneyEffect->offsetX, yOffsets, 0); } // 0x00440400 static void paintWindowCurrencyEntity(PaintSession& session, MoneyEffect* moneyEffect) { if (!Config::get().cashPopupRendering) { return; } const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 1) { return; } const StringId stringId = moneyEffect->amount >= 0 ? StringIds::format_currency_income_in_company_colour : StringIds::format_currency_expense_in_company_colour_negative; uint32_t currencyAmount = abs(moneyEffect->amount); const int8_t* yOffsets = &kWiggleYOffsets[moneyEffect->wiggle]; auto companyColour = CompanyManager::getCompanyColour(moneyEffect->var_2E); session.addToStringPlotList(currencyAmount, stringId, moneyEffect->position.z, moneyEffect->offsetX, yOffsets, enumValue(companyColour)); } // 0x0044044E static void paintVehicleCrashParticleEntity(PaintSession& session, VehicleCrashParticle* particle) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel != 0) { return; } static const std::unordered_map<int, const std::array<uint32_t, 12>> kVehicleCrashParticleImageIds = { { 0, { ImageIds::vehicle_crash_0_00, ImageIds::vehicle_crash_0_01, ImageIds::vehicle_crash_0_02, ImageIds::vehicle_crash_0_03, ImageIds::vehicle_crash_0_04, ImageIds::vehicle_crash_0_05, ImageIds::vehicle_crash_0_06, ImageIds::vehicle_crash_0_07, ImageIds::vehicle_crash_0_08, ImageIds::vehicle_crash_0_09, ImageIds::vehicle_crash_0_10, ImageIds::vehicle_crash_0_11 } }, { 1, { ImageIds::vehicle_crash_1_00, ImageIds::vehicle_crash_1_01, ImageIds::vehicle_crash_1_02, ImageIds::vehicle_crash_1_03, ImageIds::vehicle_crash_1_04, ImageIds::vehicle_crash_1_05, ImageIds::vehicle_crash_1_06, ImageIds::vehicle_crash_1_07, ImageIds::vehicle_crash_1_08, ImageIds::vehicle_crash_1_09, ImageIds::vehicle_crash_1_10, ImageIds::vehicle_crash_1_11 } }, { 2, { ImageIds::vehicle_crash_2_00, ImageIds::vehicle_crash_2_01, ImageIds::vehicle_crash_2_02, ImageIds::vehicle_crash_2_03, ImageIds::vehicle_crash_2_04, ImageIds::vehicle_crash_2_05, ImageIds::vehicle_crash_2_06, ImageIds::vehicle_crash_2_07, ImageIds::vehicle_crash_2_08, ImageIds::vehicle_crash_2_09, ImageIds::vehicle_crash_2_10, ImageIds::vehicle_crash_2_11 } }, { 3, { ImageIds::vehicle_crash_3_00, ImageIds::vehicle_crash_3_01, ImageIds::vehicle_crash_3_02, ImageIds::vehicle_crash_3_03, ImageIds::vehicle_crash_3_04, ImageIds::vehicle_crash_3_05, ImageIds::vehicle_crash_3_06, ImageIds::vehicle_crash_3_07, ImageIds::vehicle_crash_3_08, ImageIds::vehicle_crash_3_09, ImageIds::vehicle_crash_3_10, ImageIds::vehicle_crash_3_11 } }, { 4, { ImageIds::vehicle_crash_4_00, ImageIds::vehicle_crash_4_01, ImageIds::vehicle_crash_4_02, ImageIds::vehicle_crash_4_03, ImageIds::vehicle_crash_4_04, ImageIds::vehicle_crash_4_05, ImageIds::vehicle_crash_4_06, ImageIds::vehicle_crash_4_07, ImageIds::vehicle_crash_4_08, ImageIds::vehicle_crash_4_09, ImageIds::vehicle_crash_4_10, ImageIds::vehicle_crash_4_11 } } }; assert(static_cast<size_t>(particle->frame / 256) < 12); assert((particle->crashedSpriteBase) < 5); const auto imageId = ImageId{ kVehicleCrashParticleImageIds.at(particle->crashedSpriteBase).at(particle->frame / 256), particle->colourScheme }; session.addToPlotListAsParent(imageId, { 0, 0, particle->position.z }, { 1, 1, 0 }); } // 0x0044051C static void paintExplosionCloudEntity(PaintSession& session, ExplosionCloud* particle) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 2) { return; } static constexpr std::array<uint32_t, 18> kExplosionCloudImageIds = { ImageIds::explosion_cloud_00, ImageIds::explosion_cloud_01, ImageIds::explosion_cloud_02, ImageIds::explosion_cloud_03, ImageIds::explosion_cloud_04, ImageIds::explosion_cloud_05, ImageIds::explosion_cloud_06, ImageIds::explosion_cloud_07, ImageIds::explosion_cloud_08, ImageIds::explosion_cloud_09, ImageIds::explosion_cloud_10, ImageIds::explosion_cloud_11, ImageIds::explosion_cloud_12, ImageIds::explosion_cloud_13, ImageIds::explosion_cloud_14, ImageIds::explosion_cloud_15, ImageIds::explosion_cloud_16, ImageIds::explosion_cloud_17 }; assert(static_cast<size_t>(particle->frame / 256) < kExplosionCloudImageIds.size()); const auto imageId = ImageId{ kExplosionCloudImageIds.at(particle->frame / 256) }; session.addToPlotListAsParent(imageId, { 0, 0, particle->position.z }, { 1, 1, 0 }); } // 0x00440557 static void paintSplashEntity(PaintSession& session, Splash* particle) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 2) { return; } static constexpr std::array<uint32_t, 28> kSplashImageIds = { ImageIds::splash_00, ImageIds::splash_01, ImageIds::splash_02, ImageIds::splash_03, ImageIds::splash_04, ImageIds::splash_05, ImageIds::splash_06, ImageIds::splash_07, ImageIds::splash_08, ImageIds::splash_09, ImageIds::splash_10, ImageIds::splash_11, ImageIds::splash_12, ImageIds::splash_13, ImageIds::splash_14, ImageIds::splash_15, ImageIds::splash_16, ImageIds::splash_17, ImageIds::splash_18, ImageIds::splash_19, ImageIds::splash_20, ImageIds::splash_21, ImageIds::splash_22, ImageIds::splash_23, ImageIds::splash_24, ImageIds::splash_25, ImageIds::splash_26, ImageIds::splash_27 }; assert(static_cast<size_t>(particle->frame / 256) < kSplashImageIds.size()); const auto imageId = ImageId{ kSplashImageIds.at(particle->frame / 256) }; session.addToPlotListAsParent(imageId, { 0, 0, particle->position.z }, { 1, 1, 0 }); } // 0x00440592 static void paintFireballEntity(PaintSession& session, Fireball* particle) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 2) { return; } static constexpr std::array<uint32_t, 31> kFireballImageIds = { ImageIds::fireball_00, ImageIds::fireball_01, ImageIds::fireball_02, ImageIds::fireball_03, ImageIds::fireball_04, ImageIds::fireball_05, ImageIds::fireball_06, ImageIds::fireball_07, ImageIds::fireball_08, ImageIds::fireball_09, ImageIds::fireball_10, ImageIds::fireball_11, ImageIds::fireball_12, ImageIds::fireball_13, ImageIds::fireball_14, ImageIds::fireball_15, ImageIds::fireball_16, ImageIds::fireball_17, ImageIds::fireball_18, ImageIds::fireball_19, ImageIds::fireball_20, ImageIds::fireball_21, ImageIds::fireball_22, ImageIds::fireball_23, ImageIds::fireball_24, ImageIds::fireball_25, ImageIds::fireball_26, ImageIds::fireball_27, ImageIds::fireball_28, ImageIds::fireball_29, ImageIds::fireball_30 }; assert(static_cast<size_t>(particle->frame / 256) < kFireballImageIds.size()); const auto imageId = ImageId{ kFireballImageIds.at(particle->frame / 256) }; session.addToPlotListAsParent(imageId, { 0, 0, particle->position.z }, { 1, 1, 0 }); } // 0x004404A6 static void paintExplosionSmokeEntity(PaintSession& session, ExplosionSmoke* particle) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 1) { return; } static constexpr std::array<uint32_t, 10> kExplosionSmokeImageIds = { ImageIds::explosion_smoke_00, ImageIds::explosion_smoke_01, ImageIds::explosion_smoke_02, ImageIds::explosion_smoke_03, ImageIds::explosion_smoke_04, ImageIds::explosion_smoke_05, ImageIds::explosion_smoke_06, ImageIds::explosion_smoke_07, ImageIds::explosion_smoke_08, ImageIds::explosion_smoke_09 }; assert(static_cast<size_t>(particle->frame / 256) < kExplosionSmokeImageIds.size()); const auto imageId = ImageId{ kExplosionSmokeImageIds.at(particle->frame / 256) }; session.addToPlotListAsParent(imageId, { 0, 0, particle->position.z }, { 1, 1, 0 }); } // 0x004404E1 static void paintSmokeEntity(PaintSession& session, Smoke* particle) { const Gfx::RenderTarget* rt = session.getRenderTarget(); if (rt->zoomLevel > 1) { return; } static constexpr std::array<uint32_t, 12> kSmokeImageIds = { ImageIds::smoke_00, ImageIds::smoke_01, ImageIds::smoke_02, ImageIds::smoke_03, ImageIds::smoke_04, ImageIds::smoke_05, ImageIds::smoke_06, ImageIds::smoke_07, ImageIds::smoke_08, ImageIds::smoke_09, ImageIds::smoke_10, ImageIds::smoke_11 }; assert(static_cast<size_t>(particle->frame / 256) < kSmokeImageIds.size()); const auto imageId = ImageId{ kSmokeImageIds.at(particle->frame / 256) }; session.addToPlotListAsParent(imageId, { 0, 0, particle->position.z }, { 1, 1, 0 }); } // 0x00440325 void paintEffectEntity(PaintSession& session, EffectEntity* base) { switch (base->getSubType()) { case EffectType::exhaust: // 0 { paintExhaustEntity(session, base->asExhaust()); break; } case EffectType::redGreenCurrency: // 1 { paintRedGreenCurrencyEntity(session, base->asRedGreenCurrency()); break; } case EffectType::windowCurrency: // 2 { paintWindowCurrencyEntity(session, base->asWindowCurrency()); break; } case EffectType::vehicleCrashParticle: // 3 { paintVehicleCrashParticleEntity(session, base->asVehicleCrashParticle()); break; } case EffectType::explosionCloud: // 4 { paintExplosionCloudEntity(session, base->asExplosionCloud()); break; } case EffectType::splash: // 5 { paintSplashEntity(session, base->asSplash()); break; } case EffectType::fireball: // 6 { paintFireballEntity(session, base->asFireball()); break; } case EffectType::explosionSmoke: // 7 { paintExplosionSmokeEntity(session, base->asExplosionSmoke()); break; } case EffectType::smoke: // 8 { paintSmokeEntity(session, base->asSmoke()); break; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintEffectEntity.h ```h #pragma once #include "Effects/Effect.h" #include "Paint.h" namespace OpenLoco::Paint { /* * @param base->x @<ax> * @param base->y @<cx> * @param base->z @<dx> * @param ((base->sprite_yaw + (session.getRotation() << 4)) & 0x3F) @<ebx> * @param base @<esi> */ void paintEffectEntity(PaintSession& session, EffectEntity* base); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintEntity.cpp ```cpp #include "PaintEntity.h" #include "Config.h" #include "Effects/Effect.h" #include "Entities/EntityManager.h" #include "Graphics/RenderTarget.h" #include "Map/Tile.h" #include "Paint.h" #include "PaintEffectEntity.h" #include "PaintVehicle.h" #include "Ui/ViewportInteraction.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Ui::ViewportInteraction; namespace OpenLoco::Paint { template<typename FilterType> static void paintEntitiesWithFilter(PaintSession& session, const World::Pos2& loc, FilterType&& filter) { auto* rt = session.getRenderTarget(); if (Config::get().vehiclesMinScale < rt->zoomLevel) { return; } if (loc.x >= 0x4000 || loc.y >= 0x4000) { return; } EntityManager::EntityTileList entities(loc); for (auto* entity : entities) { // TODO: Create a rect from context dims auto left = rt->x; auto top = rt->y; auto right = left + rt->width; auto bottom = top + rt->height; // TODO: Create a rect from sprite dims and use a contains function if (entity->spriteTop > bottom) { continue; } if (entity->spriteBottom <= top) { continue; } if (entity->spriteLeft > right) { continue; } if (entity->spriteRight <= left) { continue; } if (!filter(entity)) { continue; } session.setCurrentItem(entity); session.setEntityPosition(entity->position); session.setItemType(InteractionItem::entity); switch (entity->baseType) { case EntityBaseType::vehicle: paintVehicleEntity(session, entity->asBase<Vehicles::VehicleBase>()); break; case EntityBaseType::effect: paintEffectEntity(session, entity->asBase<EffectEntity>()); break; case EntityBaseType::null: // Nothing to paint break; } } } // 0x0046FA88 void paintEntities(PaintSession& session, const World::Pos2& loc) { paintEntitiesWithFilter(session, loc, [](const EntityBase*) { return true; }); } static bool isEntityFlyingOrFloating(const EntityBase* entity) { auto* vehicle = entity->asBase<Vehicles::VehicleBase>(); if (vehicle == nullptr) { return false; } switch (vehicle->getTransportMode()) { case TransportMode::air: case TransportMode::water: return true; case TransportMode::rail: case TransportMode::road: return false; } return false; } // 0x0046FB67 void paintEntities2(PaintSession& session, const World::Pos2& loc) { paintEntitiesWithFilter(session, loc, isEntityFlyingOrFloating); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintEntity.h ```h #pragma once #include "Types.hpp" #include <OpenLoco/Engine/World.hpp> namespace OpenLoco::Paint { struct PaintSession; void paintEntities(PaintSession& session, const World::Pos2& loc); void paintEntities2(PaintSession& session, const World::Pos2& loc); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintIndustry.cpp ```cpp #include "PaintIndustry.h" #include "Graphics/RenderTarget.h" #include "Map/IndustryElement.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Objects/ScaffoldingObject.h" #include "Paint.h" #include "ScenarioManager.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" #include "World/Industry.h" namespace OpenLoco::Paint { // TODO: Docks, Airport, Building, Industry all have very similar code... constexpr World::Pos3 kImageOffsetBase1x1 = { 16, 16, 0 }; constexpr World::Pos3 kImageOffsetBase2x2 = { 0, 0, 0 }; constexpr World::Pos3 kBBOffsetBase1x1 = { 3, 3, 0 }; constexpr World::Pos3 kBBOffsetBase2x2 = { -8, -8, 0 }; constexpr World::Pos3 kBBSizeBase1x1 = { 26, 26, 0 }; constexpr World::Pos3 kBBSizeBase2x2 = { 38, 38, 0 }; static void paintIndustryBuilding(PaintSession& session, const World::IndustryElement& elIndustry, const IndustryObject& indObj, const World::Pos3& imageOffset, const World::Pos3& bbOffset, const World::Pos3& bbSize, const ImageId& baseColour, const uint8_t rotation, const bool isMultiTile) { // 0xE0C3A0 auto ticks = ScenarioManager::getScenarioTicks(); uint8_t numSections = 0xF0; // 0xF0 represents all sections completed // Only used when under construction uint8_t sectionProgress = 0; if (!elIndustry.isConstructed()) { ticks = 0; numSections = elIndustry.var_6_003F(); sectionProgress = elIndustry.sectionProgress(); } std::span<const std::uint8_t> animationSequence{}; if ((elIndustry.var_6_003F() & (1 << 5)) && (elIndustry.var_6_003F() & (1 << 4))) { animationSequence = indObj.getAnimationSequence(elIndustry.var_6_003F() & 0x3); } uint32_t buildingType = elIndustry.buildingType(); const auto buildingParts = indObj.getBuildingParts(buildingType); const auto partHeights = indObj.getBuildingPartHeights(); const auto buildingPartAnims = indObj.getBuildingPartAnimations(); // 0x00525D4F uint8_t totalSectionHeight = 0; if (numSections != 0xF0) { int8_t sectionCount = numSections; for (const auto buildingPart : buildingParts) { totalSectionHeight += partHeights[buildingPart]; sectionCount--; if (sectionCount == -1) { totalSectionHeight = std::max<uint8_t>(1, totalSectionHeight); break; } } } // 0x00525D30 (note this should be combined with a applyGhostToImage) const auto scaffoldingColour = indObj.scaffoldingColour; const auto scaffSegType = indObj.scaffoldingSegmentType; if (totalSectionHeight != 0 && scaffSegType != 0xFF) { const auto* scaffObj = ObjectManager::get<ScaffoldingObject>(); const auto segmentHeight = scaffObj->segmentHeights[scaffSegType]; const auto& scaffImages = isMultiTile ? getScaffoldingImages(scaffSegType).get2x2() : getScaffoldingImages(scaffSegType).get1x1(); uint32_t baseScaffImageIdx = scaffObj->image; ImageId baseScaffImage{}; if (elIndustry.isGhost()) { baseScaffImage = Gfx::applyGhostToImage(baseScaffImageIdx); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } else { baseScaffImage = ImageId(baseScaffImageIdx, scaffoldingColour); } ImageId scaffImage = baseScaffImage.withIndexOffset(scaffImages.back); auto segmentImageOffset = imageOffset; for (coord_t remainingHeight = totalSectionHeight; remainingHeight > 0; remainingHeight -= segmentHeight, segmentImageOffset.z += segmentHeight) { session.addToPlotListAsChild(scaffImage, segmentImageOffset, bbOffset, bbSize); } } int8_t sectionCount = numSections; auto sectionImageOffset = imageOffset; for (const auto buildingPart : buildingParts) { if (sectionCount == -1) { break; } auto& buildingAnimation = buildingPartAnims[buildingPart]; auto adjustedBuildingPart = buildingPart; if (buildingAnimation.numFrames) { auto frameMask = buildingAnimation.numFrames - 1; auto cl = buildingAnimation.animationSpeed & 0x7F; auto tickThing = ticks >> cl; if (buildingAnimation.animationSpeed & (1 << 7)) { auto pos = World::toTileSpace(session.getUnkPosition()); tickThing += pos.x * 5; tickThing += pos.y * 3; } adjustedBuildingPart += frameMask & tickThing; } else { if (!animationSequence.empty()) { auto tickThing = (ticks >> buildingAnimation.animationSpeed) & (animationSequence.size() - 1); adjustedBuildingPart += animationSequence[tickThing]; } } const auto sectionHeight = partHeights[adjustedBuildingPart]; const uint32_t imageIdx = adjustedBuildingPart * 4 + indObj.buildingImageIds + rotation; ImageId image = baseColour.withIndex(imageIdx); if (sectionCount == 0 && !baseColour.isBlended()) { image = image.withNoiseMask((sectionProgress + 1) & 0x7); } session.addToPlotListAsChild(image, sectionImageOffset, bbOffset, bbSize); sectionImageOffset.z += sectionHeight; sectionCount--; } if (totalSectionHeight != 0 && scaffSegType != 0xFF) { const auto* scaffObj = ObjectManager::get<ScaffoldingObject>(); const auto segmentHeight = scaffObj->segmentHeights[scaffSegType]; const auto& scaffImages = isMultiTile ? getScaffoldingImages(scaffSegType).get2x2() : getScaffoldingImages(scaffSegType).get1x1(); uint32_t baseScaffImageIdx = scaffObj->image; ImageId baseScaffImage{}; if (elIndustry.isGhost()) { baseScaffImage = Gfx::applyGhostToImage(baseScaffImageIdx); } else { baseScaffImage = ImageId(baseScaffImageIdx, scaffoldingColour); } auto scaffImage = baseScaffImage.withIndexOffset(scaffImages.front); auto segmentImageOffset = imageOffset; for (coord_t remainingHeight = totalSectionHeight; remainingHeight > 0; remainingHeight -= segmentHeight, segmentImageOffset.z += segmentHeight) { session.addToPlotListAsChild(scaffImage, segmentImageOffset, bbOffset, bbSize); } scaffImage = baseScaffImage.withIndexOffset(scaffImages.getRoof(rotation)); session.addToPlotListAsChild(scaffImage, segmentImageOffset, bbOffset, bbSize); } } // 0x00453C52 void paintIndustry(PaintSession& session, const World::IndustryElement& elIndustry) { session.setItemType(Ui::ViewportInteraction::InteractionItem::industry); auto* industry = elIndustry.industry(); auto* indObj = industry->getObject(); ImageId baseColour(0, elIndustry.var_6_F800()); if (elIndustry.isGhost()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); baseColour = Gfx::applyGhostToImage(0); } // Combine this with any imageId const uint8_t rotation = (session.getRotation() + elIndustry.rotation()) & 0x3; // 0x00525D4E const int16_t bbLengthZ = std::min(elIndustry.clearHeight() - elIndustry.baseHeight(), 128) - 2; // 0x00E0C3A4 uint32_t buildingType = elIndustry.buildingType(); const auto baseHeight = elIndustry.baseHeight(); bool isMultiTile = indObj->buildingSizeFlags & (1 << buildingType); // Note: Image offsets will change as you move up the building but bboffset/size does not const World::Pos3 imageOffset = (isMultiTile ? kImageOffsetBase2x2 : kImageOffsetBase1x1) + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbOffset = (isMultiTile ? kBBOffsetBase2x2 : kBBOffsetBase1x1) + World::Pos3{ 0, 0, baseHeight }; const World::Pos3 bbSize = (isMultiTile ? kBBSizeBase2x2 : kBBSizeBase1x1) + World::Pos3{ 0, 0, bbLengthZ }; session.resetLastPS(); // Odd... if (indObj->hasFlags(IndustryObjectFlags::hasShadows)) { if (session.getRenderTarget()->zoomLevel <= 1) { const auto shadowImageOffset = buildingType * 4 + indObj->shadowImageIds + rotation; const ImageId shadowImage = baseColour.withIndex(shadowImageOffset).withTranslucency(Colours::getShadow(elIndustry.var_6_F800())); if (isMultiTile) { session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } else { session.addToPlotListAsChild(shadowImage, imageOffset, bbOffset, bbSize); } } } if (isMultiTile) { uint8_t sequenceIndex = elIndustry.sequenceIndex(); // Only the front of the 2x2 area will draw. Images are sized to overlap into the other tiles. if ((sequenceIndex ^ (1 << 1)) == ((-session.getRotation()) & 0x3)) { paintIndustryBuilding(session, elIndustry, *indObj, imageOffset, bbOffset, bbSize, baseColour, rotation, isMultiTile); } session.setSegmentsSupportHeight(SegmentFlags::all, 0xFFFF, 0); session.setGeneralSupportHeight(0xFFFF, 0); // TODO: Check if this works previously would not set slope to zero } else { paintIndustryBuilding(session, elIndustry, *indObj, imageOffset, bbOffset, bbSize, baseColour, rotation, isMultiTile); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintIndustry.h ```h #pragma once namespace OpenLoco::World { struct IndustryElement; } namespace OpenLoco::Paint { struct PaintSession; void paintIndustry(PaintSession& session, const World::IndustryElement& elIndustry); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoad.cpp ```cpp #include "PaintRoad.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Logging.h" #include "Map/RoadElement.h" #include "Objects/LevelCrossingObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/StreetLightObject.h" #include "Paint.h" #include "PaintRoadAdditionsData.h" #include "PaintRoadCommonData.h" #include "PaintRoadStyle0Data.h" #include "PaintRoadStyle1Data.h" #include "PaintRoadStyle2Data.h" #include "PaintTileDecorations.h" #include "ScenarioManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Paint { static Interop::loco_global<uint8_t, 0x00522095> _byte_522095; static Interop::loco_global<uint8_t, 0x0050BF68> _byte_50BF68; struct RoadPaintCommon { ImageId roadBaseImageId; // 0x0112C280 with colours and image index set to base of roadObject image table ImageId bridgeColoursBaseImageId; // 0x01135F36 with only the colours set (image index not set!) uint8_t tunnelType; // 0x0113605E }; constexpr std::array<uint32_t, 4> kDefaultOneWayArrowImageIndexs{ ImageIds::one_way_direction_arrow_left_lane_north_east, ImageIds::one_way_direction_arrow_left_lane_south_east, ImageIds::one_way_direction_arrow_right_lane_south_west, ImageIds::one_way_direction_arrow_right_lane_north_east, }; constexpr std::array<uint32_t, 4> kSmallLeftCurveOneWayArrowImageIndexs{ ImageIds::one_way_direction_arrow_right_lane_north_east, ImageIds::one_way_direction_arrow_left_lane_north_east, ImageIds::one_way_direction_arrow_left_lane_south_east, ImageIds::one_way_direction_arrow_right_lane_south_west, }; constexpr std::array<uint32_t, 4> kSmallRightCurveOneWayArrowImageIndexs{ ImageIds::one_way_direction_arrow_left_lane_south_east, ImageIds::one_way_direction_arrow_right_lane_south_west, ImageIds::one_way_direction_arrow_right_lane_north_east, ImageIds::one_way_direction_arrow_left_lane_north_east, }; constexpr std::array<uint32_t, 4> kVerySmallLeftCurveOneWayArrowImageIndexs{ ImageIds::one_way_direction_arrow_right_lane_north, ImageIds::one_way_direction_arrow_right_lane_west_2, ImageIds::one_way_direction_arrow_right_lane_south_2, ImageIds::one_way_direction_arrow_right_lane_west, }; constexpr std::array<uint32_t, 4> kVerySmallRightCurveOneWayArrowImageIndexs{ ImageIds::one_way_direction_arrow_left_lane_east, ImageIds::one_way_direction_arrow_left_lane_south, ImageIds::one_way_direction_arrow_left_lane_east_2, ImageIds::one_way_direction_arrow_left_lane_north_2, }; constexpr std::array<std::array<std::array<uint32_t, 4>, 2>, 10> kOneWayArrowImageIndexs = { std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kDefaultOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kVerySmallLeftCurveOneWayArrowImageIndexs, kVerySmallLeftCurveOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kVerySmallRightCurveOneWayArrowImageIndexs, kVerySmallRightCurveOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kSmallLeftCurveOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kSmallRightCurveOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kDefaultOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kDefaultOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kDefaultOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kDefaultOneWayArrowImageIndexs, }, std::array<std::array<uint32_t, 4>, 2>{ kDefaultOneWayArrowImageIndexs, kDefaultOneWayArrowImageIndexs, }, }; // 0x00475DDF static void paintLevelCrossing(PaintSession& session, const ImageId baseRoadImageColour, const World::RoadElement& elRoad, const uint8_t rotation) { auto* crossingObj = ObjectManager::get<LevelCrossingObject>(elRoad.levelCrossingObjectId()); uint8_t frame = elRoad.unk6l(); if (frame != 0) { if (frame == 15) { frame = (((ScenarioManager::getScenarioTicks() / (1U << crossingObj->animationSpeed)) & (crossingObj->closingFrames - 1)) + crossingObj->closedFrames + 1); } } uint32_t imageIndex0 = crossingObj->image + ((rotation & 1) * 4) + (frame * 8); const auto height = elRoad.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; { const auto bbOffset = World::Pos3{ 2, 2, 1 } + heightOffset; const auto bbSize = World::Pos3{ 1, 1, 8 }; const auto image0 = baseRoadImageColour.withIndex(imageIndex0); session.addToPlotList4FD150(image0, heightOffset, bbOffset, bbSize); } { const auto bbOffset = World::Pos3{ 2, 30, 1 } + heightOffset; const auto bbSize = World::Pos3{ 1, 1, 8 }; const auto image1 = baseRoadImageColour.withIndex(imageIndex0 + 1); session.addToPlotList4FD150(image1, heightOffset, bbOffset, bbSize); } { const auto bbOffset = World::Pos3{ 30, 2, 1 } + heightOffset; const auto bbSize = World::Pos3{ 1, 1, 8 }; const auto image2 = baseRoadImageColour.withIndex(imageIndex0 + 2); session.addToPlotList4FD150(image2, heightOffset, bbOffset, bbSize); } const auto image3 = baseRoadImageColour.withIndex(imageIndex0 + 3); if (elRoad.unk6l() != 15) { const auto bbOffset = World::Pos3{ 30, 30, 1 } + heightOffset; const auto bbSize = World::Pos3{ 1, 1, 8 }; session.addToPlotList4FD150(image3, heightOffset, bbOffset, bbSize); } else { if (rotation & (1U << 0)) { const auto bbOffset = World::Pos3{ 17, 30, 1 } + heightOffset; const auto bbSize = World::Pos3{ 14, 1, 8 }; session.addToPlotList4FD150(image3, heightOffset, bbOffset, bbSize); } else { const auto bbOffset = World::Pos3{ 30, 17, 1 } + heightOffset; const auto bbSize = World::Pos3{ 1, 14, 8 }; session.addToPlotList4FD150(image3, heightOffset, bbOffset, bbSize); } } } constexpr std::array<std::array<uint32_t, 4>, 3> kStreetlightImageFromStyle = { std::array<uint32_t, 4>{ Streetlight::ImageIds::kStyle0NE, Streetlight::ImageIds::kStyle0SE, Streetlight::ImageIds::kStyle0SW, Streetlight::ImageIds::kStyle0NW, }, std::array<uint32_t, 4>{ Streetlight::ImageIds::kStyle1NE, Streetlight::ImageIds::kStyle1SE, Streetlight::ImageIds::kStyle1SW, Streetlight::ImageIds::kStyle1NW, }, std::array<uint32_t, 4>{ Streetlight::ImageIds::kStyle2NE, Streetlight::ImageIds::kStyle2SE, Streetlight::ImageIds::kStyle2SW, Streetlight::ImageIds::kStyle2NW, }, }; constexpr std::array<World::Pos3, 4> kStreetlightOffsets = { World::Pos3{ 2, 15, 0 }, World::Pos3{ 15, 28, 0 }, World::Pos3{ 28, 15, 0 }, World::Pos3{ 15, 2, 0 }, }; constexpr std::array<World::Pos3, 4> kStreetlightBoundingBoxOffsets = { World::Pos3{ 2, 15, 6 }, World::Pos3{ 15, 28, 6 }, World::Pos3{ 28, 15, 6 }, World::Pos3{ 15, 2, 6 }, }; constexpr auto kStreetlightBoundingBoxSizes = World::Pos3{ 1, 1, 6 }; static void paintRoadStreetlight(PaintSession& session, const int16_t baseHeight, const uint8_t style, const int16_t streetlightHeight, const uint8_t rotation) { assert(style < static_cast<int32_t>(kStreetlightImageFromStyle.size())); const auto imageIndexOffset = kStreetlightImageFromStyle[style][rotation]; const auto& streetlightObj = ObjectManager::get<StreetLightObject>(); const int16_t height = baseHeight + streetlightHeight; const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotListAsParent( ImageId(streetlightObj->image).withIndexOffset(imageIndexOffset), heightOffset + kStreetlightOffsets[rotation], heightOffset + kStreetlightBoundingBoxOffsets[rotation], kStreetlightBoundingBoxSizes); } static void paintRoadStreetlights(PaintSession& session, const World::RoadElement& elRoad, const std::array<int16_t, 4>& streetlightHeights) { auto r = 0; const auto style = elRoad.streetLightStyle() - 1; for (auto& height : streetlightHeights) { if (height != kNoStreetlight) { paintRoadStreetlight(session, elRoad.baseHeight(), style, height, r); } r++; } } namespace AdditionStyle1 { static void paintSupport(PaintSession& session, const RoadAdditionSupport& tppaSupport, const uint8_t rotation, const ImageId baseImageId, int16_t height) { TrackRoadAdditionSupports support{}; support.height = height + tppaSupport.height; support.occupiedSegments = session.getOccupiedAdditionSupportSegments(); uint8_t i = 0; auto segments = enumValue(tppaSupport.segments[rotation]); for (auto seg = Numerics::bitScanForward(segments); seg != -1; seg = Numerics::bitScanForward(segments)) { segments &= ~(1U << seg); assert(i < 2); support.segmentFrequency[seg] = tppaSupport.frequencies[rotation]; support.segmentImages[seg] = baseImageId.withIndexOffset(tppaSupport.imageIds[rotation][i * 2]).toUInt32(); support.segmentInteractionItem[seg] = session.getCurrentItem(); support.segmentInteractionType[seg] = session.getItemType(); i++; } session.setAdditionSupport(support); } static void paintRoadAdditionPPMergeable(PaintSession& session, const World::RoadElement& elRoad, const uint8_t rotation, const ImageId baseImageId, const RoadPaintAdditionPiece& tppa) { const auto height = elRoad.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotListTrackRoadAddition( baseImageId.withIndexOffset(tppa.imageIds[rotation]), 0, heightOffset, tppa.boundingBoxOffsets[rotation] + heightOffset, tppa.boundingBoxSizes[rotation]); if (tppa.supports.has_value()) { paintSupport(session, tppa.supports.value(), rotation, baseImageId, height); } } static void paintRoadAdditionPPStandard(PaintSession& session, const World::RoadElement& elRoad, const uint8_t rotation, const ImageId baseImageId, const RoadPaintAdditionPiece& tppa) { const auto height = elRoad.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotList4FD150( baseImageId.withIndexOffset(tppa.imageIds[rotation]), heightOffset, tppa.boundingBoxOffsets[rotation] + heightOffset, tppa.boundingBoxSizes[rotation]); if (tppa.supports.has_value()) { paintSupport(session, tppa.supports.value(), rotation, baseImageId, height); } } static void paintRoadAdditionPP(PaintSession& session, const World::RoadElement& elRoad, const uint8_t rotation, const ImageId baseImageId, const RoadPaintAdditionPiece& tppa) { // TODO: Better way to detect kNullTrackPaintAdditionPiece if (tppa.imageIds[3] != 0) { if (tppa.isIsMergeable) { paintRoadAdditionPPMergeable(session, elRoad, rotation, baseImageId, tppa); } else { paintRoadAdditionPPStandard(session, elRoad, rotation, baseImageId, tppa); } } } } namespace Style02 { constexpr std::array<uint32_t, 3> kMergeBaseImageIndex = { RoadObj::ImageIds::Style0::kStraight0NE, RoadObj::ImageIds::Style2::kStraight0NE, RoadObj::ImageIds::Style2::kStraight0SW, }; static void paintRoadPPMultiTileMerge(PaintSession& session, const World::RoadElement& elRoad, const RoadPaintCommon& roadSession, const uint8_t rotation, const RoadPaintMergeablePiece& rpp, const RoadPaintCommonPiece& rpcp) { const auto height = elRoad.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; if (_byte_50BF68 == 1) { session.addToPlotListTrackRoad( ImageId(rpp.imageIndexOffsets[rotation]), 2, heightOffset, rpcp.boundingBoxOffsets[rotation] + heightOffset, rpcp.boundingBoxSizes[rotation]); } else { session.setRoadExits(session.getRoadExits() | rpcp.bridgeEdges[rotation]); session.setMergeRoadBaseImage(roadSession.roadBaseImageId.withIndexOffset(kMergeBaseImageIndex[enumValue(rpp.isMultiTileMerge[rotation]) - 1]).toUInt32()); session.setMergeRoadHeight(height); } if (session.getRenderTarget()->zoomLevel == 0 && !elRoad.hasLevelCrossing() && !elRoad.hasSignalElement() && !elRoad.hasStationElement() && elRoad.streetLightStyle() != 0) { session.setMergeRoadStreetlight(elRoad.streetLightStyle()); } } static void paintRoadPPStandard(PaintSession& session, const World::RoadElement& elRoad, const RoadPaintCommon& roadSession, const uint8_t rotation, const RoadPaintMergeablePiece& rpp, const RoadPaintCommonPiece& rpcp) { const auto height = elRoad.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; const auto baseImage = roadSession.roadBaseImageId; session.addToPlotListTrackRoad( baseImage.withIndexOffset(rpp.imageIndexOffsets[rotation]), 2, heightOffset, rpcp.boundingBoxOffsets[rotation] + heightOffset, rpcp.boundingBoxSizes[rotation]); if (session.getRenderTarget()->zoomLevel == 0 && !elRoad.hasLevelCrossing() && !elRoad.hasSignalElement() && !elRoad.hasStationElement() && elRoad.streetLightStyle() != 0) { paintRoadStreetlights(session, elRoad, rpp.streetlightHeights[rotation]); } } static void paintRoadPP(PaintSession& session, const World::RoadElement& elRoad, const RoadPaintCommon& roadSession, const uint8_t rotation, const RoadPaintMergeablePiece& rpp, const RoadPaintCommonPiece& rpcp) { // Only need to check [0] for this as none is set for all of them when not a merge if (rpp.isMultiTileMerge[0] != RoadPaintMergeType::none) { paintRoadPPMultiTileMerge(session, elRoad, roadSession, rotation, rpp, rpcp); } else { paintRoadPPStandard(session, elRoad, roadSession, rotation, rpp, rpcp); } } } namespace Style1 { static void paintRoadPP(PaintSession& session, const World::RoadElement& elRoad, const RoadPaintCommon& roadSession, const uint8_t rotation, const RoadPaintPiece& rpp, const RoadPaintCommonPiece& rpcp) { const auto height = elRoad.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; const auto baseImage = roadSession.roadBaseImageId; session.addToPlotListTrackRoad( baseImage.withIndexOffset(rpp.imageIndexOffsets[rotation][0]), 0, heightOffset, rpcp.boundingBoxOffsets[rotation] + heightOffset, rpcp.boundingBoxSizes[rotation]); session.addToPlotListTrackRoad( baseImage.withIndexOffset(rpp.imageIndexOffsets[rotation][1]), 1, heightOffset, rpcp.boundingBoxOffsets[rotation] + heightOffset, rpcp.boundingBoxSizes[rotation]); session.addToPlotListTrackRoad( baseImage.withIndexOffset(rpp.imageIndexOffsets[rotation][2]), 3, heightOffset, rpcp.boundingBoxOffsets[rotation] + heightOffset, rpcp.boundingBoxSizes[rotation]); } } static void paintRoadPCP(PaintSession& session, const World::RoadElement& elRoad, const RoadPaintCommon& roadSession, const uint8_t rotation, const RoadPaintCommonPiece& rpcp) { const auto height = elRoad.baseHeight(); if (elRoad.hasBridge()) { auto newBridgeEntry = BridgeEntry( height, rpcp.bridgeType[rotation], rpcp.bridgeEdges[rotation], rpcp.bridgeQuarters[rotation], elRoad.bridge(), roadSession.bridgeColoursBaseImageId); // There may be other bridge edge/quarters due to merging so OR them together newBridgeEntry.edgesQuarters |= session.getBridgeEntry().edgesQuarters; session.setBridgeEntry(newBridgeEntry); } session.insertTunnels(rpcp.tunnelHeights[rotation], height, roadSession.tunnelType); session.set525CF8(session.get525CF8() | rpcp.segments[rotation]); session.setOccupiedAdditionSupportSegments(session.getOccupiedAdditionSupportSegments() | rpcp.segments[rotation]); } // 0x004759A6 void paintRoad(PaintSession& session, const World::RoadElement& elRoad) { if (elRoad.isAiAllocated() && !showAiPlanningGhosts()) { return; } if (elRoad.isGhost() && CompanyManager::getSecondaryPlayerId() != CompanyId::null && CompanyManager::getSecondaryPlayerId() == elRoad.owner()) { return; } const auto height = elRoad.baseHeight(); const auto rotation = (session.getRotation() + elRoad.rotation()) & 0x3; if (((session.getViewFlags() & Ui::ViewportFlags::height_marks_on_tracks_roads) != Ui::ViewportFlags::none) && session.getRenderTarget()->zoomLevel == 0) { const bool isLast = elRoad.isFlag6(); const bool isFirstTile = elRoad.sequenceIndex() == 0; if (isFirstTile || isLast) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); const auto markerHeight = height + getRoadDecorationHeightOffset(isFirstTile, elRoad.roadId()) + 8; const auto imageId = ImageId{ getHeightMarkerImage(markerHeight), Colour::blue }; const World::Pos3 offset(16, 16, markerHeight); const World::Pos3 bbOffset(1000, 1000, 1087); const World::Pos3 bbSize(1, 1, 0); session.addToPlotListAsParent(imageId, offset, bbOffset, bbSize); } } auto* roadObj = ObjectManager::get<RoadObject>(elRoad.roadObjectId()); if (((session.getViewFlags() & Ui::ViewportFlags::one_way_direction_arrows) != Ui::ViewportFlags::none) && session.getRenderTarget()->zoomLevel == 0 && !elRoad.isGhost() && roadObj->hasFlags(RoadObjectFlags::isOneWay)) { const bool isLast = elRoad.isFlag6(); const bool isFirstTile = elRoad.sequenceIndex() == 0; if (isFirstTile || isLast) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); const auto markerHeight = height + getRoadDecorationHeightOffset(isFirstTile, elRoad.roadId()) + 8; const auto imageId = ImageId{ kOneWayArrowImageIndexs[elRoad.roadId()][isLast ? 1 : 0][rotation], Colour::mutedAvocadoGreen }; const World::Pos3 offset(0, 0, markerHeight); const auto bbOffset = World::Pos3{ 15, 15, 16 } + World::Pos3(0, 0, markerHeight); const World::Pos3 bbSize(1, 1, 0); session.addToPlotListAsParent(imageId, offset, bbOffset, bbSize); } } session.setItemType(Ui::ViewportInteraction::InteractionItem::road); // This is an ImageId but it has no image index set! auto baseRoadImageColour = ImageId(0, CompanyManager::getCompanyColour(elRoad.owner())); if (elRoad.isGhost() || elRoad.isAiAllocated()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); baseRoadImageColour = Gfx::applyGhostToImage(0); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } RoadPaintCommon roadSession{ baseRoadImageColour.withIndex(roadObj->image), baseRoadImageColour, roadObj->tunnel }; if (!(*_byte_522095 & (1 << 0))) { auto& rpcp = kRoadPaintCommonParts[elRoad.roadId()][elRoad.sequenceIndex()]; if (roadObj->paintStyle == 0) { assert(elRoad.roadId() < Style0::kRoadPaintParts.size()); auto& parts = Style0::kRoadPaintParts[elRoad.roadId()]; assert(elRoad.sequenceIndex() < parts.size()); auto& rpp = parts[elRoad.sequenceIndex()]; Style02::paintRoadPP(session, elRoad, roadSession, rotation, rpp, rpcp); paintRoadPCP(session, elRoad, roadSession, rotation, rpcp); } else if (roadObj->paintStyle == 1) { assert(elRoad.roadId() < Style1::kRoadPaintParts.size()); auto& parts = Style1::kRoadPaintParts[elRoad.roadId()]; assert(elRoad.sequenceIndex() < parts.size()); auto& rpp = parts[elRoad.sequenceIndex()]; Style1::paintRoadPP(session, elRoad, roadSession, rotation, rpp, rpcp); paintRoadPCP(session, elRoad, roadSession, rotation, rpcp); } else if (roadObj->paintStyle == 2) { assert(elRoad.roadId() < Style2::kRoadPaintParts.size()); auto& parts = Style2::kRoadPaintParts[elRoad.roadId()]; assert(elRoad.sequenceIndex() < parts.size()); auto& rpp = parts[elRoad.sequenceIndex()]; Style02::paintRoadPP(session, elRoad, roadSession, rotation, rpp, rpcp); paintRoadPCP(session, elRoad, roadSession, rotation, rpcp); } else { assert(false); Logging::error("Tried to draw invalid road paint style: paintStyle {}", roadObj->paintStyle); } } if (session.getRenderTarget()->zoomLevel > 1) { return; } if (elRoad.hasLevelCrossing()) { paintLevelCrossing(session, baseRoadImageColour, elRoad, rotation); } if (session.getRenderTarget()->zoomLevel > 0 || roadObj->hasFlags(RoadObjectFlags::unk_03)) { return; } session.setItemType(Ui::ViewportInteraction::InteractionItem::roadExtra); const auto ghostMods = Ui::Windows::Construction::getLastSelectedMods(); for (auto mod = 0; mod < 2; ++mod) { const auto* roadExtraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[mod]); ImageId roadExtraBaseImage{}; if (elRoad.hasMod(mod)) { roadExtraBaseImage = baseRoadImageColour.withIndex(roadExtraObj->image); } else if (elRoad.hasGhostMods() && (ghostMods & (1U << mod))) { roadExtraBaseImage = Gfx::applyGhostToImage(roadExtraObj->image); } else { continue; } session.setTrackModId(mod); const auto paintStyle = roadExtraObj->paintStyle; if (paintStyle == 1 && elRoad.roadId() < AdditionStyle1::kRoadPaintAdditionParts.size() && elRoad.sequenceIndex() < AdditionStyle1::kRoadPaintAdditionParts[elRoad.roadId()].size()) { auto& parts = AdditionStyle1::kRoadPaintAdditionParts[elRoad.roadId()]; auto& tppa = parts[elRoad.sequenceIndex()]; AdditionStyle1::paintRoadAdditionPP(session, elRoad, rotation, roadExtraBaseImage, tppa); } else { assert(false); Logging::error("Tried to draw invalid road id or sequence index: RoadId {} SequenceIndex {}", elRoad.roadId(), elRoad.sequenceIndex()); } } } constexpr std::array<World::Pos3, 11> kMergeBoundingBoxOffsets = { World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }; constexpr std::array<World::Pos3, 11> kMergeBoundingBoxSizes = { World::Pos3{ 28, 22, 0 }, World::Pos3{ 22, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, World::Pos3{ 28, 28, 0 }, }; // Currently unused but will be soon [[maybe_unused]] constexpr std::array<uint32_t, 11> kStyle0MergeImageIndexs = { RoadObj::ImageIds::Style0::kStraight0NE, RoadObj::ImageIds::Style0::kStraight0SE, RoadObj::ImageIds::Style0::kRightCurveVerySmall0NE, RoadObj::ImageIds::Style0::kRightCurveVerySmall0SE, RoadObj::ImageIds::Style0::kRightCurveVerySmall0SW, RoadObj::ImageIds::Style0::kRightCurveVerySmall0NW, RoadObj::ImageIds::Style0::kJunctionLeft0NE, RoadObj::ImageIds::Style0::kJunctionLeft0SE, RoadObj::ImageIds::Style0::kJunctionLeft0SW, RoadObj::ImageIds::Style0::kJunctionLeft0NW, RoadObj::ImageIds::Style0::kJunctionCrossroads0NE, }; [[maybe_unused]] constexpr std::array<uint32_t, 11> kStyle2LeftMergeImageIndexs = { RoadObj::ImageIds::Style2::kStraight0NE, RoadObj::ImageIds::Style2::kStraight0SE, RoadObj::ImageIds::Style2::kLeftCurveVerySmall0NW, RoadObj::ImageIds::Style2::kLeftCurveVerySmall0NE, RoadObj::ImageIds::Style2::kLeftCurveVerySmall0SE, RoadObj::ImageIds::Style2::kLeftCurveVerySmall0SW, RoadObj::ImageIds::Style2::kJunctionLeft0NE, RoadObj::ImageIds::Style2::kJunctionLeft0SE, RoadObj::ImageIds::Style2::kJunctionLeft0SW, RoadObj::ImageIds::Style2::kJunctionLeft0NW, RoadObj::ImageIds::Style2::kJunctionCrossroads0NE, }; [[maybe_unused]] constexpr std::array<uint32_t, 11> kStyle2RightMergeImageIndexs = { RoadObj::ImageIds::Style2::kStraight0SW, RoadObj::ImageIds::Style2::kStraight0NW, RoadObj::ImageIds::Style2::kRightCurveVerySmall0NE, RoadObj::ImageIds::Style2::kRightCurveVerySmall0SE, RoadObj::ImageIds::Style2::kRightCurveVerySmall0SW, RoadObj::ImageIds::Style2::kRightCurveVerySmall0NW, RoadObj::ImageIds::Style2::kJunctionRight0NE, RoadObj::ImageIds::Style2::kJunctionRight0SE, RoadObj::ImageIds::Style2::kJunctionRight0SW, RoadObj::ImageIds::Style2::kJunctionRight0NW, RoadObj::ImageIds::Style2::kJunctionCrossroads0NE2, }; constexpr std::array<uint8_t, 16> kExitsToMergeId = { 0, // 0b0000 (not possible) 0, // 0b0001 (not possible) 1, // 0b0010 (not possible) 5, // 0b0011 (turn) 0, // 0b0100 (not possible) 0, // 0b0101 (straight) 2, // 0b0110 (turn) 8, // 0b0111 (junction) 1, // 0b1000 (not possible) 4, // 0b1001 (turn) 1, // 0b1010 (straight) 7, // 0b1011 (junction) 3, // 0b1100 (turn) 6, // 0b1101 (junction) 9, // 0b1110 (junction) 10, // 0b1111 (crossroads) }; // 0x004792E7 void finalisePaintRoad(PaintSession& session) { const auto exits = session.getRoadExits(); assert(exits < kExitsToMergeId.size()); const auto mergeId = kExitsToMergeId[exits]; const auto height = session.getMergeRoadHeight(); const auto streetlightType = session.getMergeRoadStreetlight(); const auto baseImage = ImageId::fromUInt32(session.getMergeRoadBaseImage()); session.setRoadExits(0); session.setMergeRoadStreetlight(0); const auto heightOffset = World::Pos3{ 0, 0, height }; const auto image = baseImage.withIndexOffset(mergeId); const auto boundingBoxOffset = kMergeBoundingBoxOffsets[mergeId] + heightOffset; const auto boundingBoxSize = kMergeBoundingBoxSizes[mergeId]; session.addToPlotListTrackRoad(image, 2, heightOffset, boundingBoxOffset, boundingBoxSize); if (streetlightType != 0) { const auto style = streetlightType - 1; for (auto i = 0U; i < 4; ++i) { if (!(exits & (1U << i))) { // Note: Vanilla used a different bboffset and size for this unsure why paintRoadStreetlight(session, height, style, 0, i); } } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoad.h ```h #pragma once namespace OpenLoco::World { struct RoadElement; } namespace OpenLoco::Paint { struct PaintSession; void paintRoad(PaintSession& session, const World::RoadElement& elRoad); void finalisePaintRoad(PaintSession& session); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadAdditionsData.h ```h #pragma once #include "Objects/RoadExtraObject.h" #include "Paint.h" #include <OpenLoco/Core/Numerics.hpp> #include <array> #include <optional> #include <span> namespace OpenLoco::Paint::AdditionStyle1 { struct RoadAdditionSupport { std::array<std::array<uint32_t, 4>, 4> imageIds; int16_t height; std::array<uint8_t, 4> frequencies; // Make array std::array<SegmentFlags, 4> segments; // Make array constexpr RoadAdditionSupport( const std::array<std::array<uint32_t, 4>, 4>& _imageIds, const int16_t _height, const std::array<uint8_t, 4>& _frequencies, const std::array<SegmentFlags, 4>& _segments) : imageIds(_imageIds) , height(_height) , frequencies(_frequencies) , segments(_segments) { } constexpr RoadAdditionSupport( const std::array<std::array<uint32_t, 4>, 4>& _imageIds, const int16_t _height, const uint8_t _frequency, const SegmentFlags _segment) : imageIds(_imageIds) , height(_height) , frequencies() , segments() { frequencies[0] = _frequency; frequencies[1] = Numerics::rotl4bit(frequencies[0], 2); frequencies[2] = frequencies[0]; frequencies[3] = frequencies[1]; segments[0] = _segment; for (auto i = 1U; i < 4; ++i) { segments[i] = rotlSegmentFlags(segments[0], i); } } }; struct RoadPaintAdditionPiece { std::array<uint32_t, 4> imageIds; std::array<World::Pos3, 4> boundingBoxOffsets; std::array<World::Pos3, 4> boundingBoxSizes; bool isIsMergeable; std::optional<RoadAdditionSupport> supports; }; constexpr std::array<uint8_t, 4> kRotationTable1230 = { 1, 2, 3, 0 }; constexpr std::array<uint8_t, 4> kRotationTable2301 = { 2, 3, 0, 1 }; constexpr std::array<uint8_t, 4> kRotationTable3012 = { 3, 0, 1, 2 }; constexpr RoadPaintAdditionPiece kNullRoadPaintAdditionPiece = {}; constexpr auto kNoSupports = std::nullopt; consteval std::optional<RoadAdditionSupport> rotateRoadPPASupport(const std::optional<RoadAdditionSupport>& reference, const std::array<uint8_t, 4>& rotationTable) { if (!reference.has_value()) { return std::nullopt; } return RoadAdditionSupport{ std::array<std::array<uint32_t, 4>, 4>{ reference->imageIds[rotationTable[0]], reference->imageIds[rotationTable[1]], reference->imageIds[rotationTable[2]], reference->imageIds[rotationTable[3]], }, reference->height, std::array<uint8_t, 4>{ reference->frequencies[rotationTable[0]], reference->frequencies[rotationTable[1]], reference->frequencies[rotationTable[2]], reference->frequencies[rotationTable[3]], }, std::array<SegmentFlags, 4>{ reference->segments[rotationTable[0]], reference->segments[rotationTable[1]], reference->segments[rotationTable[2]], reference->segments[rotationTable[3]], } }; } consteval RoadPaintAdditionPiece rotateRoadPPA(const RoadPaintAdditionPiece& reference, const std::array<uint8_t, 4>& rotationTable) { return RoadPaintAdditionPiece{ std::array<uint32_t, 4>{ reference.imageIds[rotationTable[0]], reference.imageIds[rotationTable[1]], reference.imageIds[rotationTable[2]], reference.imageIds[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxOffsets[rotationTable[0]], reference.boundingBoxOffsets[rotationTable[1]], reference.boundingBoxOffsets[rotationTable[2]], reference.boundingBoxOffsets[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxSizes[rotationTable[0]], reference.boundingBoxSizes[rotationTable[1]], reference.boundingBoxSizes[rotationTable[2]], reference.boundingBoxSizes[rotationTable[3]], }, reference.isIsMergeable, rotateRoadPPASupport(reference.supports, rotationTable) }; } using namespace OpenLoco::RoadExtraObj::ImageIds::Style1; // 0x00410159, 0x0041020A, 0x00410159, 0x0041020A constexpr RoadPaintAdditionPiece kStraightAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergable */ true, /* Supports */ RoadAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 4>, 4>{ std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 0, /* Frequency */ 2, /* Segment */ SegmentFlags::x1y0 | SegmentFlags::x1y2, }, }; constexpr std::array<RoadPaintAdditionPiece, 1> kStraightTPPA = { kStraightAddition0, }; // 0x004102BB, 0x00410302, 0x00410349, 0x00410390 constexpr RoadPaintAdditionPiece kRightCurveVerySmallAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveVerySmall0NE, kRightCurveVerySmall0SE, kRightCurveVerySmall0SW, kRightCurveVerySmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergable */ true, /* Supports */ kNoSupports, }; constexpr std::array<RoadPaintAdditionPiece, 1> kRightCurveVerySmallTPPA = { kRightCurveVerySmallAddition0, }; constexpr RoadPaintAdditionPiece kLeftCurveVerySmallAddition0 = rotateRoadPPA(kRightCurveVerySmallAddition0, kRotationTable1230); constexpr std::array<RoadPaintAdditionPiece, 1> kLeftCurveVerySmallTPPA = { kLeftCurveVerySmallAddition0, }; // 0x0041052B, 0x0041068F, 0x004107F3, 0x00410957 constexpr RoadPaintAdditionPiece kRightCurveSmallAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall0NE, kRightCurveSmall0SE, kRightCurveSmall0SW, kRightCurveSmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergable */ true, /* Supports */ RoadAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 4>, 4>{ std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0 | SegmentFlags::x1y2, }, }; constexpr RoadPaintAdditionPiece kRightCurveSmallAddition1 = kNullRoadPaintAdditionPiece; constexpr RoadPaintAdditionPiece kRightCurveSmallAddition2 = kNullRoadPaintAdditionPiece; // 0x004105DE, 0x00410742, 0x004108A6, 0x00410A0A constexpr RoadPaintAdditionPiece kRightCurveSmallAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall3NE, kRightCurveSmall3SE, kRightCurveSmall3SW, kRightCurveSmall3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergable */ true, /* Supports */ RoadAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 4>, 4>{ std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y1 | SegmentFlags::x2y1, }, }; constexpr std::array<RoadPaintAdditionPiece, 4> kRightCurveSmallTPPA = { kRightCurveSmallAddition0, kRightCurveSmallAddition1, kRightCurveSmallAddition2, kRightCurveSmallAddition3, }; constexpr RoadPaintAdditionPiece kLeftCurveSmallAddition0 = rotateRoadPPA(kRightCurveSmallAddition3, kRotationTable1230); constexpr RoadPaintAdditionPiece kLeftCurveSmallAddition1 = kNullRoadPaintAdditionPiece; constexpr RoadPaintAdditionPiece kLeftCurveSmallAddition2 = kNullRoadPaintAdditionPiece; constexpr RoadPaintAdditionPiece kLeftCurveSmallAddition3 = rotateRoadPPA(kRightCurveSmallAddition0, kRotationTable1230); constexpr std::array<RoadPaintAdditionPiece, 4> kLeftCurveSmallTPPA = { kLeftCurveSmallAddition0, kLeftCurveSmallAddition1, kLeftCurveSmallAddition2, kLeftCurveSmallAddition3, }; // 0x00410AF3, 0x00410C83, 0x00410E13, 0x00410FA3 constexpr RoadPaintAdditionPiece kStraightSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSlopeUp0NE, kStraightSlopeUp0SE, kStraightSlopeUp0SW, kStraightSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergable */ false, /* Supports */ RoadAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 4>, 4>{ std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 4, /* Frequency */ 1, /* Segment */ SegmentFlags::x1y0 | SegmentFlags::x1y2, }, }; // 0x00410BBB, 0x00410D4B, 0x00410EDB, 0x0041106B constexpr RoadPaintAdditionPiece kStraightSlopeUpAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSlopeUp1NE, kStraightSlopeUp1SE, kStraightSlopeUp1SW, kStraightSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergable */ false, /* Supports */ RoadAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 4>, 4>{ std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 12, /* Frequency */ 1, /* Segment */ SegmentFlags::x1y0 | SegmentFlags::x1y2, }, }; constexpr std::array<RoadPaintAdditionPiece, 2> kStraightSlopeUpTPPA = { kStraightSlopeUpAddition0, kStraightSlopeUpAddition1, }; constexpr RoadPaintAdditionPiece kStraightSlopeDownAddition0 = rotateRoadPPA(kStraightSlopeUpAddition1, kRotationTable2301); constexpr RoadPaintAdditionPiece kStraightSlopeDownAddition1 = rotateRoadPPA(kStraightSlopeUpAddition0, kRotationTable2301); constexpr std::array<RoadPaintAdditionPiece, 2> kStraightSlopeDownTPPA = { kStraightSlopeDownAddition0, kStraightSlopeDownAddition1, }; // 0x00411133, 0x004111FB, 0x004112C3, 0x0041138B constexpr RoadPaintAdditionPiece kStraightSteepSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSteepSlopeUp0NE, kStraightSteepSlopeUp0SE, kStraightSteepSlopeUp0SW, kStraightSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergable */ false, /* Supports */ RoadAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 4>, 4>{ std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 4>{ kSupportStraight0NE, kSupportConnectorStraight0NE, kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 4>{ kSupportStraight0SE, kSupportConnectorStraight0SE, kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 8, /* Frequency */ 1, /* Segment */ SegmentFlags::x1y0 | SegmentFlags::x1y2, }, }; constexpr std::array<RoadPaintAdditionPiece, 1> kStraightSteepSlopeUpTPPA = { kStraightSteepSlopeUpAddition0, }; constexpr RoadPaintAdditionPiece kStraightSteepSlopeDownAddition0 = rotateRoadPPA(kStraightSteepSlopeUpAddition0, kRotationTable2301); constexpr std::array<RoadPaintAdditionPiece, 1> kStraightSteepSlopeDownTPPA = { kStraightSteepSlopeDownAddition0, }; // 0x004103D7, 0x0041041E, 0x00410465, 0x004104AC constexpr RoadPaintAdditionPiece kTurnaroundAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kTurnaround0NE, kTurnaround0SE, kTurnaround0SW, kTurnaround0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 16, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, }, /* Mergable */ true, /* Supports */ kNoSupports, }; constexpr std::array<RoadPaintAdditionPiece, 1> kTurnaroundTPPA = { kTurnaroundAddition0, }; constexpr std::array<std::span<const RoadPaintAdditionPiece>, 10> kRoadPaintAdditionParts = { kStraightTPPA, kLeftCurveVerySmallTPPA, kRightCurveVerySmallTPPA, kLeftCurveSmallTPPA, kRightCurveSmallTPPA, kStraightSlopeUpTPPA, kStraightSlopeDownTPPA, kStraightSteepSlopeUpTPPA, kStraightSteepSlopeDownTPPA, kTurnaroundTPPA, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadCommonData.h ```h #pragma once #include "Paint.h" #include <OpenLoco/Core/Numerics.hpp> #include <array> #include <span> namespace OpenLoco::Paint { struct RoadPaintCommonPiece { private: constexpr void rotateTunnelHeights() { tunnelHeights[1][0] = tunnelHeights[0][3]; tunnelHeights[1][1] = tunnelHeights[0][0]; tunnelHeights[1][2] = tunnelHeights[0][1]; tunnelHeights[1][3] = tunnelHeights[0][2]; tunnelHeights[2][0] = tunnelHeights[0][2]; tunnelHeights[2][1] = tunnelHeights[0][3]; tunnelHeights[2][2] = tunnelHeights[0][0]; tunnelHeights[2][3] = tunnelHeights[0][1]; tunnelHeights[3][0] = tunnelHeights[0][1]; tunnelHeights[3][1] = tunnelHeights[0][2]; tunnelHeights[3][2] = tunnelHeights[0][3]; tunnelHeights[3][3] = tunnelHeights[0][0]; } constexpr void rotateBridgeEdgesQuarters() { for (auto i = 1; i < 4; ++i) { bridgeEdges[i] = Numerics::rotl4bit(bridgeEdges[0], i); } for (auto i = 1; i < 4; ++i) { bridgeQuarters[i] = Numerics::rotl4bit(bridgeQuarters[0], i); } } constexpr void rotateSegements() { for (auto i = 1; i < 4; ++i) { segments[i] = rotlSegmentFlags(segments[0], i); } } public: constexpr RoadPaintCommonPiece( const std::array<World::Pos3, 4>& _boundingBoxOffsets, const std::array<World::Pos3, 4>& _boundingBoxSizes, const std::array<uint8_t, 4>& _bridgeEdges, const std::array<uint8_t, 4>& _bridgeQuarters, const std::array<uint8_t, 4>& _bridgeType, const std::array<std::array<int16_t, 4>, 4>& _tunnelHeights, const std::array<SegmentFlags, 4>& _segments) : boundingBoxOffsets(_boundingBoxOffsets) , boundingBoxSizes(_boundingBoxSizes) , bridgeEdges(_bridgeEdges) , bridgeQuarters(_bridgeQuarters) , bridgeType(_bridgeType) , tunnelHeights(_tunnelHeights) , segments(_segments) { } constexpr RoadPaintCommonPiece( const std::array<World::Pos3, 4>& _boundingBoxOffsets, const std::array<World::Pos3, 4>& _boundingBoxSizes, uint8_t _bridgeEdges, uint8_t _bridgeQuarters, const std::array<uint8_t, 4>& _bridgeType, const std::array<int16_t, 4>& _tunnelHeights, SegmentFlags _segments) : boundingBoxOffsets(_boundingBoxOffsets) , boundingBoxSizes(_boundingBoxSizes) , bridgeEdges() , bridgeQuarters() , bridgeType(_bridgeType) , tunnelHeights() , segments() { tunnelHeights[0] = _tunnelHeights; bridgeEdges[0] = _bridgeEdges; bridgeQuarters[0] = _bridgeQuarters; segments[0] = _segments; rotateTunnelHeights(); rotateBridgeEdgesQuarters(); rotateSegements(); } std::array<World::Pos3, 4> boundingBoxOffsets; std::array<World::Pos3, 4> boundingBoxSizes; std::array<uint8_t, 4> bridgeEdges; std::array<uint8_t, 4> bridgeQuarters; std::array<uint8_t, 4> bridgeType; std::array<std::array<int16_t, 4>, 4> tunnelHeights; std::array<SegmentFlags, 4> segments; }; constexpr int16_t kNoTunnel = -1; constexpr std::array<int16_t, 4> kNoTunnels = { kNoTunnel, kNoTunnel, kNoTunnel, kNoTunnel }; constexpr std::array<uint8_t, 4> kFlatBridge = { 0, 0, 0, 0 }; constexpr std::array<uint8_t, 4> kRotationTable1230 = { 1, 2, 3, 0 }; constexpr std::array<uint8_t, 4> kRotationTable2301 = { 2, 3, 0, 1 }; consteval RoadPaintCommonPiece rotateRoadPCP(const RoadPaintCommonPiece& reference, const std::array<uint8_t, 4>& rotationTable) { return RoadPaintCommonPiece{ std::array<World::Pos3, 4>{ reference.boundingBoxOffsets[rotationTable[0]], reference.boundingBoxOffsets[rotationTable[1]], reference.boundingBoxOffsets[rotationTable[2]], reference.boundingBoxOffsets[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxSizes[rotationTable[0]], reference.boundingBoxSizes[rotationTable[1]], reference.boundingBoxSizes[rotationTable[2]], reference.boundingBoxSizes[rotationTable[3]], }, std::array<uint8_t, 4>{ reference.bridgeEdges[rotationTable[0]], reference.bridgeEdges[rotationTable[1]], reference.bridgeEdges[rotationTable[2]], reference.bridgeEdges[rotationTable[3]], }, std::array<uint8_t, 4>{ reference.bridgeQuarters[rotationTable[0]], reference.bridgeQuarters[rotationTable[1]], reference.bridgeQuarters[rotationTable[2]], reference.bridgeQuarters[rotationTable[3]], }, std::array<uint8_t, 4>{ reference.bridgeType[rotationTable[0]], reference.bridgeType[rotationTable[1]], reference.bridgeType[rotationTable[2]], reference.bridgeType[rotationTable[3]], }, std::array<std::array<int16_t, 4>, 4>{ reference.tunnelHeights[rotationTable[0]], reference.tunnelHeights[rotationTable[1]], reference.tunnelHeights[rotationTable[2]], reference.tunnelHeights[rotationTable[3]], }, std::array<SegmentFlags, 4>{ reference.segments[rotationTable[0]], reference.segments[rotationTable[1]], reference.segments[rotationTable[2]], reference.segments[rotationTable[3]], } }; } constexpr RoadPaintCommonPiece kStraight0 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ 0, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr std::array<RoadPaintCommonPiece, 1> kStraightRPCP = { kStraight0, }; constexpr RoadPaintCommonPiece kRightCurveVerySmall0 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<RoadPaintCommonPiece, 1> kRightCurveVerySmallRPCP = { kRightCurveVerySmall0, }; constexpr RoadPaintCommonPiece kLeftCurveVerySmall0 = rotateRoadPCP(kRightCurveVerySmall0, kRotationTable1230); constexpr std::array<RoadPaintCommonPiece, 1> kLeftCurveVerySmallRPCP = { kLeftCurveVerySmall0, }; constexpr RoadPaintCommonPiece kRightCurveSmall0 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 0, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 30, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr RoadPaintCommonPiece kRightCurveSmall1 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x1y0 | SegmentFlags::x0y1, }; constexpr RoadPaintCommonPiece kRightCurveSmall2 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr RoadPaintCommonPiece kRightCurveSmall3 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 0, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 6, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 30, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1110, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<RoadPaintCommonPiece, 4> kRightCurveSmallRPCP = { kRightCurveSmall0, kRightCurveSmall1, kRightCurveSmall2, kRightCurveSmall3, }; constexpr RoadPaintCommonPiece kLeftCurveSmall0 = rotateRoadPCP(kRightCurveSmall3, kRotationTable1230); constexpr RoadPaintCommonPiece kLeftCurveSmall1 = rotateRoadPCP(kRightCurveSmall1, kRotationTable1230); constexpr RoadPaintCommonPiece kLeftCurveSmall2 = rotateRoadPCP(kRightCurveSmall2, kRotationTable1230); constexpr RoadPaintCommonPiece kLeftCurveSmall3 = rotateRoadPCP(kRightCurveSmall0, kRotationTable1230); constexpr std::array<RoadPaintCommonPiece, 4> kLeftCurveSmallRPCP = { kLeftCurveSmall0, kLeftCurveSmall1, kLeftCurveSmall2, kLeftCurveSmall3, }; constexpr RoadPaintCommonPiece kStraightSlopeUp0 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 1, 3, 5, 7, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr RoadPaintCommonPiece kStraightSlopeUp1 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 2, 4, 6, 8, }, /* TunnelHeights */ std::array<int16_t, 4>{ 16, kNoTunnel, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr std::array<RoadPaintCommonPiece, 2> kStraightSlopeUpRPCP = { kStraightSlopeUp0, kStraightSlopeUp1, }; constexpr RoadPaintCommonPiece kStraightSlopeDown0 = rotateRoadPCP(kStraightSlopeUp1, kRotationTable2301); constexpr RoadPaintCommonPiece kStraightSlopeDown1 = rotateRoadPCP(kStraightSlopeUp0, kRotationTable2301); constexpr std::array<RoadPaintCommonPiece, 2> kStraightSlopeDownRPCP = { kStraightSlopeDown0, kStraightSlopeDown1, }; constexpr RoadPaintCommonPiece kStraightSteepSlopeUp0 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 9, 10, 11, 12, }, /* TunnelHeights */ std::array<int16_t, 4>{ 16, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr std::array<RoadPaintCommonPiece, 1> kStraightSteepSlopeUpRPCP = { kStraightSteepSlopeUp0, }; constexpr RoadPaintCommonPiece kStraightSteepSlopeDown0 = rotateRoadPCP(kStraightSteepSlopeUp0, kRotationTable2301); constexpr std::array<RoadPaintCommonPiece, 1> kStraightSteepSlopeDownRPCP = { kStraightSteepSlopeDown0, }; constexpr RoadPaintCommonPiece kTurnaround0 = { /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, }, /* BridgeEdges */ 0b0100, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1, }; constexpr std::array<RoadPaintCommonPiece, 1> kTurnaroundRPCP = { kTurnaround0, }; constexpr std::array<std::span<const RoadPaintCommonPiece>, 10> kRoadPaintCommonParts = { kStraightRPCP, kLeftCurveVerySmallRPCP, kRightCurveVerySmallRPCP, kLeftCurveSmallRPCP, kRightCurveSmallRPCP, kStraightSlopeUpRPCP, kStraightSlopeDownRPCP, kStraightSteepSlopeUpRPCP, kStraightSteepSlopeDownRPCP, kTurnaroundRPCP, }; enum class RoadPaintMergeType { none, // Not a Merging paint piece standard, // For non symmetrical pieces indicates the bank of images left, right, }; struct RoadPaintMergeablePiece { private: constexpr void rotateStreetlightHeights() { streetlightHeights[1][0] = streetlightHeights[0][3]; streetlightHeights[1][1] = streetlightHeights[0][0]; streetlightHeights[1][2] = streetlightHeights[0][1]; streetlightHeights[1][3] = streetlightHeights[0][2]; streetlightHeights[2][0] = streetlightHeights[0][2]; streetlightHeights[2][1] = streetlightHeights[0][3]; streetlightHeights[2][2] = streetlightHeights[0][0]; streetlightHeights[2][3] = streetlightHeights[0][1]; streetlightHeights[3][0] = streetlightHeights[0][1]; streetlightHeights[3][1] = streetlightHeights[0][2]; streetlightHeights[3][2] = streetlightHeights[0][3]; streetlightHeights[3][3] = streetlightHeights[0][0]; } public: constexpr RoadPaintMergeablePiece( const std::array<uint32_t, 4>& _imageIndexOffsets, const std::array<int16_t, 4>& _streetlightHeights, const std::array<RoadPaintMergeType, 4> _isMultiTileMerge) : imageIndexOffsets(_imageIndexOffsets) , streetlightHeights() , isMultiTileMerge(_isMultiTileMerge) { streetlightHeights = {}; streetlightHeights[0] = _streetlightHeights; rotateStreetlightHeights(); } constexpr RoadPaintMergeablePiece( const std::array<uint32_t, 4>& _imageIndexOffsets, const std::array<std::array<int16_t, 4>, 4>& _streetlightHeights, const std::array<RoadPaintMergeType, 4> _isMultiTileMerge) : imageIndexOffsets(_imageIndexOffsets) , streetlightHeights(_streetlightHeights) , isMultiTileMerge(_isMultiTileMerge) { } std::array<uint32_t, 4> imageIndexOffsets; std::array<std::array<int16_t, 4>, 4> streetlightHeights; std::array<RoadPaintMergeType, 4> isMultiTileMerge; }; constexpr int16_t kNoStreetlight = -1; constexpr std::array<RoadPaintMergeType, 4> kNoRoadPaintMerge = { RoadPaintMergeType::none, RoadPaintMergeType::none, RoadPaintMergeType::none, RoadPaintMergeType::none, }; constexpr std::array<int16_t, 4> kNoStreetlights = { kNoStreetlight, kNoStreetlight, kNoStreetlight, kNoStreetlight }; consteval RoadPaintMergeablePiece rotateRoadPP(const RoadPaintMergeablePiece& reference, const std::array<uint8_t, 4>& rotationTable) { return RoadPaintMergeablePiece{ std::array<uint32_t, 4>{ reference.imageIndexOffsets[rotationTable[0]], reference.imageIndexOffsets[rotationTable[1]], reference.imageIndexOffsets[rotationTable[2]], reference.imageIndexOffsets[rotationTable[3]], }, std::array<std::array<int16_t, 4>, 4>{ reference.streetlightHeights[rotationTable[0]], reference.streetlightHeights[rotationTable[1]], reference.streetlightHeights[rotationTable[2]], reference.streetlightHeights[rotationTable[3]], }, std::array<RoadPaintMergeType, 4>{ reference.isMultiTileMerge[rotationTable[0]], reference.isMultiTileMerge[rotationTable[1]], reference.isMultiTileMerge[rotationTable[2]], reference.isMultiTileMerge[rotationTable[3]], } }; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadStation.cpp ```cpp #include "PaintRoadStation.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/TileElement.h" #include "Objects/ObjectManager.h" #include "Objects/RoadStationObject.h" #include "Paint.h" #include "PaintStation.h" #include "Ui/ViewportInteraction.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> namespace OpenLoco::Paint { // THIS IS MOSTLY A SIMPLIFIED COPY OF TRAIN STATION PAINT struct PaintDetail { uint32_t imageId; World::Pos3 bbOffset; World::Pos3 bbSize; }; struct PlatformImage { PaintDetail back; PaintDetail front; PaintDetail canopy; PaintDetail canopyTranslucent; }; constexpr PlatformImage kNeStationPlatformImage = { { RoadStation::ImageIds::Style0::straightBackNE, { 2, 2, 8 }, { 28, 4, 3 }, }, { RoadStation::ImageIds::Style0::straightFrontNE, { 2, 24, 8 }, { 28, 4, 3 }, }, { RoadStation::ImageIds::Style0::straightCanopyNE, { 2, 2, 26 }, { 28, 28, 1 }, }, { RoadStation::ImageIds::Style0::straightCanopyTranslucentNE, {}, {}, }, }; constexpr PlatformImage kSeStationPlatformImage = { { RoadStation::ImageIds::Style0::straightBackSE, { 2, 2, 8 }, { 4, 28, 3 }, }, { RoadStation::ImageIds::Style0::straightFrontSE, { 24, 2, 8 }, { 4, 28, 3 }, }, { RoadStation::ImageIds::Style0::straightCanopySE, { 2, 2, 26 }, { 28, 28, 1 }, }, { RoadStation::ImageIds::Style0::straightCanopyTranslucentSE, {}, {}, }, }; constexpr std::array<PlatformImage, 4> kStationPlatformImages = { kNeStationPlatformImage, kSeStationPlatformImage, kNeStationPlatformImage, kSeStationPlatformImage, }; // 0x004D7CA4 (0x00411EDA, 0x00412099, 0x00412258, 0x00412417) static void paintRoadStationStyle0StraightTrack(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, const ImageId imageTranslucentBase) { const auto rotation = (session.getRotation() + elStation.rotation()) & 0x3; const auto* stationObj = ObjectManager::get<RoadStationObject>(elStation.objectId()); // This was part of paintStationCargo const auto unkPosHash = (session.getUnkPosition().x + session.getUnkPosition().y) / 32; const auto cargoOffsets = stationObj->getCargoOffsets(rotation, unkPosHash & 0x3); constexpr std::array<std::array<uint8_t, 4>, 4> cargoRotationFlags = { std::array<uint8_t, 4>{ 0x9, 0x5, 0x6, 0xA }, std::array<uint8_t, 4>{ 0x9, 0x5, 0x6, 0xA }, std::array<uint8_t, 4>{ 0xA, 0x6, 0x5, 0x9 }, std::array<uint8_t, 4>{ 0xA, 0x6, 0x5, 0x9 }, }; const auto& cargoFlags = cargoRotationFlags[rotation]; const auto& platformImages = kStationPlatformImages[rotation]; const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); uint32_t cargoTypeFlags = 0xFFFFFFFFU; if (stationObj->hasFlags(RoadStationFlags::freight | RoadStationFlags::passenger)) { cargoTypeFlags &= ~(1U << stationObj->cargoType); if (!stationObj->hasFlags(RoadStationFlags::freight)) { cargoTypeFlags = ~cargoTypeFlags; } } // Paint Back part of platform { World::Pos3 bbOffset = platformImages.back.bbOffset + heightOffset; session.addToPlotList4FD150(imageBase.withIndexOffset(platformImages.back.imageId), heightOffset, bbOffset, platformImages.back.bbSize); paintStationCargo(session, elStation, cargoFlags[0], cargoTypeFlags, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.back.bbSize); paintStationCargo(session, elStation, cargoFlags[1], cargoTypeFlags, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.back.bbSize); } // Paint Front part of platform { World::Pos3 bbOffset = platformImages.front.bbOffset + heightOffset; session.addToPlotList4FD150(imageBase.withIndexOffset(platformImages.front.imageId), heightOffset, bbOffset, platformImages.front.bbSize); paintStationCargo(session, elStation, cargoFlags[2], cargoTypeFlags, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.front.bbSize); paintStationCargo(session, elStation, cargoFlags[3], cargoTypeFlags, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.front.bbSize); } // Paint Canopy of platform { World::Pos3 bbOffset = platformImages.canopy.bbOffset + heightOffset; session.addToPlotListTrackRoadAddition(imageBase.withIndexOffset(platformImages.canopy.imageId), 1, heightOffset, bbOffset, platformImages.canopy.bbSize); session.attachToPrevious(imageTranslucentBase.withIndexOffset(platformImages.canopyTranslucent.imageId), { 0, 0 }); } session.set525CF8(session.get525CF8() | SegmentFlags::all); } // 0x004D7C6C static void paintRoadStationStyle0(PaintSession& session, const World::StationElement& elStation, const uint8_t roadId, [[maybe_unused]] const uint8_t sequenceIndex, const ImageId imageBase, const ImageId imageGlassBase) { switch (roadId) { case 0: paintRoadStationStyle0StraightTrack(session, elStation, imageBase, imageGlassBase); break; default: return; } } // 0x0048B403 void paintRoadStation(PaintSession& session, const World::StationElement& elStation) { session.setItemType(Ui::ViewportInteraction::InteractionItem::roadStation); const auto* stationObj = ObjectManager::get<RoadStationObject>(elStation.objectId()); session.setOccupiedAdditionSupportSegments(SegmentFlags::all); const auto* elRoad = elStation.prev()->as<World::RoadElement>(); if (elRoad == nullptr) { return; } auto* station = StationManager::get(elStation.stationId()); const auto companyColour = CompanyManager::getCompanyColour(station->owner); auto translucentColour = Colours::getTranslucent(companyColour); if (!stationObj->hasFlags(RoadStationFlags::recolourable)) { translucentColour = ExtColour::unk2E; } ImageId imageIdbase{}; // 0x0112C720 ImageId imageIdTranslucentBase{}; // 0x0112C724 if (elStation.isGhost() || elStation.isAiAllocated()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); imageIdbase = Gfx::applyGhostToImage(stationObj->imageOffsets[1]); imageIdTranslucentBase = ImageId{ stationObj->imageOffsets[1] }.withTranslucency(ExtColour::unk2F); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } else { imageIdbase = ImageId{ stationObj->imageOffsets[1], companyColour }; imageIdTranslucentBase = ImageId{ stationObj->imageOffsets[1] }.withTranslucency(translucentColour); } switch (stationObj->paintStyle) { case 0: paintRoadStationStyle0(session, elStation, elRoad->roadId(), elRoad->sequenceIndex(), imageIdbase, imageIdTranslucentBase); break; default: // Road only have 1 style of drawing break; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadStation.h ```h #pragma once namespace OpenLoco::World { struct StationElement; } namespace OpenLoco::Paint { struct PaintSession; void paintRoadStation(PaintSession& session, const World::StationElement& elStation); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadStyle0Data.h ```h #pragma once #include "Graphics/ImageIds.h" #include "Objects/RoadObject.h" #include "Paint.h" #include "PaintRoadCommonData.h" #include <OpenLoco/Core/Numerics.hpp> #include <array> #include <span> namespace OpenLoco::Paint::Style0 { // 0x004083B1, 0x004084BC, 0x004083B1, 0x004084BC constexpr RoadPaintMergeablePiece kStraight0 = { std::array<uint32_t, 4>{ ImageIds::road_hit_test_straight_NE, ImageIds::road_hit_test_straight_SW, ImageIds::road_hit_test_straight_NE, ImageIds::road_hit_test_straight_SW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ std::array<RoadPaintMergeType, 4>{ RoadPaintMergeType::standard, RoadPaintMergeType::standard, RoadPaintMergeType::standard, RoadPaintMergeType::standard }, }; constexpr std::array<RoadPaintMergeablePiece, 1> kStraightTPP = { kStraight0, }; // 0x004087DD, 0x004088E8, 0x004089F3, 0x00408AFC constexpr RoadPaintMergeablePiece kRightCurveVerySmall0 = { std::array<uint32_t, 4>{ ImageIds::road_hit_test_very_small_curve_right_NE, ImageIds::road_hit_test_very_small_curve_right_SE, ImageIds::road_hit_test_very_small_curve_right_SW, ImageIds::road_hit_test_very_small_curve_right_NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ std::array<RoadPaintMergeType, 4>{ RoadPaintMergeType::standard, RoadPaintMergeType::standard, RoadPaintMergeType::standard, RoadPaintMergeType::standard }, }; constexpr std::array<RoadPaintMergeablePiece, 1> kRightCurveVerySmallTPP = { kRightCurveVerySmall0, }; constexpr RoadPaintMergeablePiece kLeftCurveVerySmall0 = rotateRoadPP(kRightCurveVerySmall0, kRotationTable1230); constexpr std::array<RoadPaintMergeablePiece, 1> kLeftCurveVerySmallTPP = { kLeftCurveVerySmall0, }; // 0x0040935D, 0x004096C9, 0x00409A37, 0x00409DA3 constexpr RoadPaintMergeablePiece kRightCurveSmall0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kRightCurveSmall0NE, RoadObj::ImageIds::Style0::kRightCurveSmall0SE, RoadObj::ImageIds::Style0::kRightCurveSmall0SW, RoadObj::ImageIds::Style0::kRightCurveSmall0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, kNoStreetlight, kNoStreetlight, 0, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040948D, 0x004097F9, 0x00409B67, 0x00409ED3 constexpr RoadPaintMergeablePiece kRightCurveSmall1 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kRightCurveSmall1NE, RoadObj::ImageIds::Style0::kRightCurveSmall1SE, RoadObj::ImageIds::Style0::kRightCurveSmall1SW, RoadObj::ImageIds::Style0::kRightCurveSmall1NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x00409512, 0x00409880, 0x00409BEE, 0x00409F5A constexpr RoadPaintMergeablePiece kRightCurveSmall2 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kRightCurveSmall2NE, RoadObj::ImageIds::Style0::kRightCurveSmall2SE, RoadObj::ImageIds::Style0::kRightCurveSmall2SW, RoadObj::ImageIds::Style0::kRightCurveSmall2NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x00409599, 0x00409907, 0x00409C73, 0x00409FE1 constexpr RoadPaintMergeablePiece kRightCurveSmall3 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kRightCurveSmall3NE, RoadObj::ImageIds::Style0::kRightCurveSmall3SE, RoadObj::ImageIds::Style0::kRightCurveSmall3SW, RoadObj::ImageIds::Style0::kRightCurveSmall3NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ 0, kNoStreetlight, kNoStreetlight, kNoStreetlight, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 4> kRightCurveSmallTPP = { kRightCurveSmall0, kRightCurveSmall1, kRightCurveSmall2, kRightCurveSmall3, }; constexpr RoadPaintMergeablePiece kLeftCurveSmall0 = rotateRoadPP(kRightCurveSmall3, kRotationTable1230); constexpr RoadPaintMergeablePiece kLeftCurveSmall1 = rotateRoadPP(kRightCurveSmall1, kRotationTable1230); constexpr RoadPaintMergeablePiece kLeftCurveSmall2 = rotateRoadPP(kRightCurveSmall2, kRotationTable1230); constexpr RoadPaintMergeablePiece kLeftCurveSmall3 = rotateRoadPP(kRightCurveSmall0, kRotationTable1230); constexpr std::array<RoadPaintMergeablePiece, 4> kLeftCurveSmallTPP = { kLeftCurveSmall0, kLeftCurveSmall1, kLeftCurveSmall2, kLeftCurveSmall3, }; // 0x0040AF19, 0x0040B27F, 0x0040B5E5, 0x0040B94B constexpr RoadPaintMergeablePiece kStraightSlopeUp0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kStraightSlopeUp0NE, RoadObj::ImageIds::Style0::kStraightSlopeUp0SE, RoadObj::ImageIds::Style0::kStraightSlopeUp0SW, RoadObj::ImageIds::Style0::kStraightSlopeUp0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 4, kNoStreetlight, 4, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040B0CA, 0x0040B430, 0x0040B796, 0x0040BAFC constexpr RoadPaintMergeablePiece kStraightSlopeUp1 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kStraightSlopeUp1NE, RoadObj::ImageIds::Style0::kStraightSlopeUp1SE, RoadObj::ImageIds::Style0::kStraightSlopeUp1SW, RoadObj::ImageIds::Style0::kStraightSlopeUp1NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 12, kNoStreetlight, 12, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 2> kStraightSlopeUpTPP = { kStraightSlopeUp0, kStraightSlopeUp1, }; constexpr RoadPaintMergeablePiece kStraightSlopeDown0 = rotateRoadPP(kStraightSlopeUp1, kRotationTable2301); constexpr RoadPaintMergeablePiece kStraightSlopeDown1 = rotateRoadPP(kStraightSlopeUp0, kRotationTable2301); constexpr std::array<RoadPaintMergeablePiece, 2> kStraightSlopeDownTPP = { kStraightSlopeDown0, kStraightSlopeDown1, }; // 0x0040CA49, 0x0040CC2E, 0x0040CE13, 0x0040CFF8 constexpr RoadPaintMergeablePiece kStraightSteepSlopeUp0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kStraightSteepSlopeUp0NE, RoadObj::ImageIds::Style0::kStraightSteepSlopeUp0SE, RoadObj::ImageIds::Style0::kStraightSteepSlopeUp0SW, RoadObj::ImageIds::Style0::kStraightSteepSlopeUp0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 8, kNoStreetlight, 8, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 1> kStraightSteepSlopeUpTPP = { kStraightSteepSlopeUp0, }; constexpr RoadPaintMergeablePiece kStraightSteepSlopeDown0 = rotateRoadPP(kStraightSteepSlopeUp0, kRotationTable2301); constexpr std::array<RoadPaintMergeablePiece, 1> kStraightSteepSlopeDownTPP = { kStraightSteepSlopeDown0, }; // 0x00409031, 0x004090E8, 0x0040919D, 0x00409252 constexpr RoadPaintMergeablePiece kTurnaround0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style0::kTurnaround0NE, RoadObj::ImageIds::Style0::kTurnaround0SE, RoadObj::ImageIds::Style0::kTurnaround0SW, RoadObj::ImageIds::Style0::kTurnaround0NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 1> kTurnaroundTPP = { kTurnaround0, }; constexpr std::array<std::span<const RoadPaintMergeablePiece>, 10> kRoadPaintParts = { kStraightTPP, kLeftCurveVerySmallTPP, kRightCurveVerySmallTPP, kLeftCurveSmallTPP, kRightCurveSmallTPP, kStraightSlopeUpTPP, kStraightSlopeDownTPP, kStraightSteepSlopeUpTPP, kStraightSteepSlopeDownTPP, kTurnaroundTPP, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadStyle1Data.h ```h #pragma once #include "Objects/RoadObject.h" #include "Paint.h" #include <array> #include <span> namespace OpenLoco::Paint::Style1 { struct RoadPaintPiece { std::array<std::array<uint32_t, 3>, 4> imageIndexOffsets; }; constexpr std::array<uint8_t, 4> kRotationTable1230 = { 1, 2, 3, 0 }; constexpr std::array<uint8_t, 4> kRotationTable2301 = { 2, 3, 0, 1 }; consteval RoadPaintPiece rotateRoadPP(const RoadPaintPiece& reference, const std::array<uint8_t, 4>& rotationTable) { // MSVC 14.44.35207 will ICE if we don't create a temporary array here const auto intermediateArray = std::array<std::array<uint32_t, 3>, 4>{ reference.imageIndexOffsets[rotationTable[0]], reference.imageIndexOffsets[rotationTable[1]], reference.imageIndexOffsets[rotationTable[2]], reference.imageIndexOffsets[rotationTable[3]], }; return RoadPaintPiece{ intermediateArray }; } // 0x0040D9AD, 0x0040DADE, 0x0040D9AD, 0x0040DADE constexpr RoadPaintPiece kStraight0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraight0BallastNE, RoadObj::ImageIds::Style1::kStraight0SleeperNE, RoadObj::ImageIds::Style1::kStraight0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraight0BallastSE, RoadObj::ImageIds::Style1::kStraight0SleeperSE, RoadObj::ImageIds::Style1::kStraight0RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraight0BallastNE, RoadObj::ImageIds::Style1::kStraight0SleeperNE, RoadObj::ImageIds::Style1::kStraight0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraight0BallastSE, RoadObj::ImageIds::Style1::kStraight0SleeperSE, RoadObj::ImageIds::Style1::kStraight0RailSE }, }, }; constexpr std::array<RoadPaintPiece, 1> kStraightTPP = { kStraight0, }; // 0x0040DC0F, 0x0040DD46, 0x0040DE7D, 0x0040DFB2 constexpr RoadPaintPiece kRightCurveVerySmall0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveVerySmall0BallastNE, RoadObj::ImageIds::Style1::kRightCurveVerySmall0SleeperNE, RoadObj::ImageIds::Style1::kRightCurveVerySmall0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveVerySmall0BallastSE, RoadObj::ImageIds::Style1::kRightCurveVerySmall0SleeperSE, RoadObj::ImageIds::Style1::kRightCurveVerySmall0RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveVerySmall0BallastSW, RoadObj::ImageIds::Style1::kRightCurveVerySmall0SleeperSW, RoadObj::ImageIds::Style1::kRightCurveVerySmall0RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveVerySmall0BallastNW, RoadObj::ImageIds::Style1::kRightCurveVerySmall0SleeperNW, RoadObj::ImageIds::Style1::kRightCurveVerySmall0RailNW }, }, }; constexpr std::array<RoadPaintPiece, 1> kRightCurveVerySmallTPP = { kRightCurveVerySmall0, }; constexpr RoadPaintPiece kLeftCurveVerySmall0 = rotateRoadPP(kRightCurveVerySmall0, kRotationTable1230); constexpr std::array<RoadPaintPiece, 1> kLeftCurveVerySmallTPP = { kLeftCurveVerySmall0, }; // 0x0040E545, 0x0040E8E7, 0x0040EC8B, 0x0040F02D constexpr RoadPaintPiece kRightCurveSmall0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall0BallastNE, RoadObj::ImageIds::Style1::kRightCurveSmall0SleeperNE, RoadObj::ImageIds::Style1::kRightCurveSmall0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall0BallastSE, RoadObj::ImageIds::Style1::kRightCurveSmall0SleeperSE, RoadObj::ImageIds::Style1::kRightCurveSmall0RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall0BallastSW, RoadObj::ImageIds::Style1::kRightCurveSmall0SleeperSW, RoadObj::ImageIds::Style1::kRightCurveSmall0RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall0BallastNW, RoadObj::ImageIds::Style1::kRightCurveSmall0SleeperNW, RoadObj::ImageIds::Style1::kRightCurveSmall0RailNW }, }, }; // 0x0040E646, 0x0040E9E8, 0x0040ED8C, 0x0040F12E constexpr RoadPaintPiece kRightCurveSmall1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall1BallastNE, RoadObj::ImageIds::Style1::kRightCurveSmall1SleeperNE, RoadObj::ImageIds::Style1::kRightCurveSmall1RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall1BallastSE, RoadObj::ImageIds::Style1::kRightCurveSmall1SleeperSE, RoadObj::ImageIds::Style1::kRightCurveSmall1RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall1BallastSW, RoadObj::ImageIds::Style1::kRightCurveSmall1SleeperSW, RoadObj::ImageIds::Style1::kRightCurveSmall1RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall1BallastNW, RoadObj::ImageIds::Style1::kRightCurveSmall1SleeperNW, RoadObj::ImageIds::Style1::kRightCurveSmall1RailNW }, }, }; // 0x0040E715, 0x0040EAB9, 0x0040EE5D, 0x0040F1FF constexpr RoadPaintPiece kRightCurveSmall2 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall2BallastNE, RoadObj::ImageIds::Style1::kRightCurveSmall2SleeperNE, RoadObj::ImageIds::Style1::kRightCurveSmall2RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall2BallastSE, RoadObj::ImageIds::Style1::kRightCurveSmall2SleeperSE, RoadObj::ImageIds::Style1::kRightCurveSmall2RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall2BallastSW, RoadObj::ImageIds::Style1::kRightCurveSmall2SleeperSW, RoadObj::ImageIds::Style1::kRightCurveSmall2RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall2BallastNW, RoadObj::ImageIds::Style1::kRightCurveSmall2SleeperNW, RoadObj::ImageIds::Style1::kRightCurveSmall2RailNW }, }, }; // 0x0040E7E6, 0x0040EB8A, 0x0040EF2C, 0x0040F2D0 constexpr RoadPaintPiece kRightCurveSmall3 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall3BallastNE, RoadObj::ImageIds::Style1::kRightCurveSmall3SleeperNE, RoadObj::ImageIds::Style1::kRightCurveSmall3RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall3BallastSE, RoadObj::ImageIds::Style1::kRightCurveSmall3SleeperSE, RoadObj::ImageIds::Style1::kRightCurveSmall3RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall3BallastSW, RoadObj::ImageIds::Style1::kRightCurveSmall3SleeperSW, RoadObj::ImageIds::Style1::kRightCurveSmall3RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kRightCurveSmall3BallastNW, RoadObj::ImageIds::Style1::kRightCurveSmall3SleeperNW, RoadObj::ImageIds::Style1::kRightCurveSmall3RailNW }, }, }; constexpr std::array<RoadPaintPiece, 4> kRightCurveSmallTPP = { kRightCurveSmall0, kRightCurveSmall1, kRightCurveSmall2, kRightCurveSmall3, }; constexpr RoadPaintPiece kLeftCurveSmall0 = rotateRoadPP(kRightCurveSmall3, kRotationTable1230); constexpr RoadPaintPiece kLeftCurveSmall1 = rotateRoadPP(kRightCurveSmall1, kRotationTable1230); constexpr RoadPaintPiece kLeftCurveSmall2 = rotateRoadPP(kRightCurveSmall2, kRotationTable1230); constexpr RoadPaintPiece kLeftCurveSmall3 = rotateRoadPP(kRightCurveSmall0, kRotationTable1230); constexpr std::array<RoadPaintPiece, 4> kLeftCurveSmallTPP = { kLeftCurveSmall0, kLeftCurveSmall1, kLeftCurveSmall2, kLeftCurveSmall3, }; // 0x0040F409, 0x0040F61F, 0x0040F835, 0x0040FA4B constexpr RoadPaintPiece kStraightSlopeUp0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp0BallastNE, RoadObj::ImageIds::Style1::kStraightSlopeUp0SleeperNE, RoadObj::ImageIds::Style1::kStraightSlopeUp0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp0BallastSE, RoadObj::ImageIds::Style1::kStraightSlopeUp0SleeperSE, RoadObj::ImageIds::Style1::kStraightSlopeUp0RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp0BallastSW, RoadObj::ImageIds::Style1::kStraightSlopeUp0SleeperSW, RoadObj::ImageIds::Style1::kStraightSlopeUp0RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp0BallastNW, RoadObj::ImageIds::Style1::kStraightSlopeUp0SleeperNW, RoadObj::ImageIds::Style1::kStraightSlopeUp0RailNW }, }, }; // 0x0040F512, 0x0040F728, 0x0040F93E, 0x0040FB54 constexpr RoadPaintPiece kStraightSlopeUp1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp1BallastNE, RoadObj::ImageIds::Style1::kStraightSlopeUp1SleeperNE, RoadObj::ImageIds::Style1::kStraightSlopeUp1RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp1BallastSE, RoadObj::ImageIds::Style1::kStraightSlopeUp1SleeperSE, RoadObj::ImageIds::Style1::kStraightSlopeUp1RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp1BallastSW, RoadObj::ImageIds::Style1::kStraightSlopeUp1SleeperSW, RoadObj::ImageIds::Style1::kStraightSlopeUp1RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSlopeUp1BallastNW, RoadObj::ImageIds::Style1::kStraightSlopeUp1SleeperNW, RoadObj::ImageIds::Style1::kStraightSlopeUp1RailNW }, }, }; constexpr std::array<RoadPaintPiece, 2> kStraightSlopeUpTPP = { kStraightSlopeUp0, kStraightSlopeUp1, }; constexpr RoadPaintPiece kStraightSlopeDown0 = rotateRoadPP(kStraightSlopeUp1, kRotationTable2301); constexpr RoadPaintPiece kStraightSlopeDown1 = rotateRoadPP(kStraightSlopeUp0, kRotationTable2301); constexpr std::array<RoadPaintPiece, 2> kStraightSlopeDownTPP = { kStraightSlopeDown0, kStraightSlopeDown1, }; // 0x0040FC61, 0x0040FD9E, 0x0040FEDB, 0x00410018 constexpr RoadPaintPiece kStraightSteepSlopeUp0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0BallastNE, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0SleeperNE, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0BallastSE, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0SleeperSE, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0BallastSW, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0SleeperSW, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0BallastNW, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0SleeperNW, RoadObj::ImageIds::Style1::kStraightSteepSlopeUp0RailNW }, }, }; constexpr std::array<RoadPaintPiece, 1> kStraightSteepSlopeUpTPP = { kStraightSteepSlopeUp0, }; constexpr RoadPaintPiece kStraightSteepSlopeDown0 = rotateRoadPP(kStraightSteepSlopeUp0, kRotationTable2301); constexpr std::array<RoadPaintPiece, 1> kStraightSteepSlopeDownTPP = { kStraightSteepSlopeDown0, }; // 0x0040E0E9, 0x0040E1F3, 0x0040E2FB, 0x0040E403 constexpr RoadPaintPiece kTurnaround0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kTurnaround0BallastNE, RoadObj::ImageIds::Style1::kTurnaround0SleeperNE, RoadObj::ImageIds::Style1::kTurnaround0RailNE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kTurnaround0BallastSE, RoadObj::ImageIds::Style1::kTurnaround0SleeperSE, RoadObj::ImageIds::Style1::kTurnaround0RailSE }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kTurnaround0BallastSW, RoadObj::ImageIds::Style1::kTurnaround0SleeperSW, RoadObj::ImageIds::Style1::kTurnaround0RailSW }, std::array<uint32_t, 3>{ RoadObj::ImageIds::Style1::kTurnaround0BallastNW, RoadObj::ImageIds::Style1::kTurnaround0SleeperNW, RoadObj::ImageIds::Style1::kTurnaround0RailNW }, }, }; constexpr std::array<RoadPaintPiece, 1> kTurnaroundTPP = { kTurnaround0, }; constexpr std::array<std::span<const RoadPaintPiece>, 10> kRoadPaintParts = { kStraightTPP, kLeftCurveVerySmallTPP, kRightCurveVerySmallTPP, kLeftCurveSmallTPP, kRightCurveSmallTPP, kStraightSlopeUpTPP, kStraightSlopeDownTPP, kStraightSteepSlopeUpTPP, kStraightSteepSlopeDownTPP, kTurnaroundTPP, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintRoadStyle2Data.h ```h #pragma once #include "Graphics/ImageIds.h" #include "Objects/RoadObject.h" #include "Paint.h" #include "PaintRoadCommonData.h" #include <OpenLoco/Core/Numerics.hpp> #include <array> #include <span> namespace OpenLoco::Paint::Style2 { // 0x004083B1, 0x004084BC, 0x004085C7, 0x004086D2 constexpr RoadPaintMergeablePiece kStraight0 = { std::array<uint32_t, 4>{ ImageIds::road_hit_test_straight_NE, ImageIds::road_hit_test_straight_SW, ImageIds::road_hit_test_straight_NE, ImageIds::road_hit_test_straight_SW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ std::array<RoadPaintMergeType, 4>{ RoadPaintMergeType::left, RoadPaintMergeType::left, RoadPaintMergeType::right, RoadPaintMergeType::right }, }; constexpr std::array<RoadPaintMergeablePiece, 1> kStraightTPP = { kStraight0, }; // 0x00408C07, 0x00408D12, 0x00408E1D, 0x00408F26 constexpr RoadPaintMergeablePiece kRightCurveVerySmall0 = { std::array<uint32_t, 4>{ ImageIds::road_hit_test_very_small_curve_right_NE, ImageIds::road_hit_test_very_small_curve_right_SE, ImageIds::road_hit_test_very_small_curve_right_SW, ImageIds::road_hit_test_very_small_curve_right_NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ std::array<RoadPaintMergeType, 4>{ RoadPaintMergeType::right, RoadPaintMergeType::right, RoadPaintMergeType::right, RoadPaintMergeType::right }, }; constexpr std::array<RoadPaintMergeablePiece, 1> kRightCurveVerySmallTPP = { kRightCurveVerySmall0, }; // 0x004088E8, 0x004089F3, 0x00408AFC, 0x004087DD constexpr RoadPaintMergeablePiece kLeftCurveVerySmall0 = { std::array<uint32_t, 4>{ ImageIds::road_hit_test_very_small_curve_right_SE, ImageIds::road_hit_test_very_small_curve_right_SW, ImageIds::road_hit_test_very_small_curve_right_NW, ImageIds::road_hit_test_very_small_curve_right_NE, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ std::array<RoadPaintMergeType, 4>{ RoadPaintMergeType::left, RoadPaintMergeType::left, RoadPaintMergeType::left, RoadPaintMergeType::left }, }; constexpr std::array<RoadPaintMergeablePiece, 1> kLeftCurveVerySmallTPP = { kLeftCurveVerySmall0, }; // 0x0040A111, 0x0040A47D, 0x0040A7EB, 0x0040AB57 constexpr RoadPaintMergeablePiece kRightCurveSmall0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kRightCurveSmall0NE, RoadObj::ImageIds::Style2::kRightCurveSmall0SE, RoadObj::ImageIds::Style2::kRightCurveSmall0SW, RoadObj::ImageIds::Style2::kRightCurveSmall0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, kNoStreetlight, kNoStreetlight, 0, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040A241, 0x0040A5AD, 0x0040A91B, 0x0040AC87 constexpr RoadPaintMergeablePiece kRightCurveSmall1 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kRightCurveSmall1NE, RoadObj::ImageIds::Style2::kRightCurveSmall1SE, RoadObj::ImageIds::Style2::kRightCurveSmall1SW, RoadObj::ImageIds::Style2::kRightCurveSmall1NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040A2C6, 0x0040A634, 0x0040A9A2, 0x0040AD0E constexpr RoadPaintMergeablePiece kRightCurveSmall2 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kRightCurveSmall2NE, RoadObj::ImageIds::Style2::kRightCurveSmall2SE, RoadObj::ImageIds::Style2::kRightCurveSmall2SW, RoadObj::ImageIds::Style2::kRightCurveSmall2NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040A34D, 0x0040A6BB, 0x0040AA27, 0x0040AD95 constexpr RoadPaintMergeablePiece kRightCurveSmall3 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kRightCurveSmall3NE, RoadObj::ImageIds::Style2::kRightCurveSmall3SE, RoadObj::ImageIds::Style2::kRightCurveSmall3SW, RoadObj::ImageIds::Style2::kRightCurveSmall3NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ 0, kNoStreetlight, kNoStreetlight, kNoStreetlight, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 4> kRightCurveSmallTPP = { kRightCurveSmall0, kRightCurveSmall1, kRightCurveSmall2, kRightCurveSmall3, }; // 0x00409907, 0x00409C73, 0x00409FE1, 0x00409599 constexpr RoadPaintMergeablePiece kLeftCurveSmall0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kLeftCurveSmall0NE, RoadObj::ImageIds::Style2::kLeftCurveSmall0SE, RoadObj::ImageIds::Style2::kLeftCurveSmall0SW, RoadObj::ImageIds::Style2::kLeftCurveSmall0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 0, kNoStreetlight, kNoStreetlight, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x004097F9, 0x00409B67, 0x00409ED3, 0x0040948D constexpr RoadPaintMergeablePiece kLeftCurveSmall1 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kLeftCurveSmall1NE, RoadObj::ImageIds::Style2::kLeftCurveSmall1SE, RoadObj::ImageIds::Style2::kLeftCurveSmall1SW, RoadObj::ImageIds::Style2::kLeftCurveSmall1NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x00409880, 0x00409BEE, 0x00409F5A, 0x00409512 constexpr RoadPaintMergeablePiece kLeftCurveSmall2 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kLeftCurveSmall2NE, RoadObj::ImageIds::Style2::kLeftCurveSmall2SE, RoadObj::ImageIds::Style2::kLeftCurveSmall2SW, RoadObj::ImageIds::Style2::kLeftCurveSmall2NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x004096C9, 0x00409A37, 0x00409DA3, 0x0040935D constexpr RoadPaintMergeablePiece kLeftCurveSmall3 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kLeftCurveSmall3NE, RoadObj::ImageIds::Style2::kLeftCurveSmall3SE, RoadObj::ImageIds::Style2::kLeftCurveSmall3SW, RoadObj::ImageIds::Style2::kLeftCurveSmall3NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ 0, kNoStreetlight, kNoStreetlight, kNoStreetlight, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 4> kLeftCurveSmallTPP = { kLeftCurveSmall0, kLeftCurveSmall1, kLeftCurveSmall2, kLeftCurveSmall3, }; // 0x0040AF19, 0x0040B27F, 0x0040B5E5, 0x0040B94B constexpr RoadPaintMergeablePiece kStraightSlopeUp0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kStraightSlopeUp0NE, RoadObj::ImageIds::Style2::kStraightSlopeUp0SE, RoadObj::ImageIds::Style2::kStraightSlopeUp0SW, RoadObj::ImageIds::Style2::kStraightSlopeUp0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 4, kNoStreetlight, 4, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040B0CA, 0x0040B430, 0x0040B796, 0x0040BAFC constexpr RoadPaintMergeablePiece kStraightSlopeUp1 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kStraightSlopeUp1NE, RoadObj::ImageIds::Style2::kStraightSlopeUp1SE, RoadObj::ImageIds::Style2::kStraightSlopeUp1SW, RoadObj::ImageIds::Style2::kStraightSlopeUp1NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 12, kNoStreetlight, 12, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 2> kStraightSlopeUpTPP = { kStraightSlopeUp0, kStraightSlopeUp1, }; // 0x0040C52E, 0x0040C894, 0x0040BE62, 0x0040C1C8 constexpr RoadPaintMergeablePiece kStraightSlopeDown0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kStraightSlopeDown0NE, RoadObj::ImageIds::Style2::kStraightSlopeDown0SE, RoadObj::ImageIds::Style2::kStraightSlopeDown0SW, RoadObj::ImageIds::Style2::kStraightSlopeDown0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 12, kNoStreetlight, 12, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; // 0x0040C37D, 0x0040C6E3, 0x0040BCB1, 0x0040C017 constexpr RoadPaintMergeablePiece kStraightSlopeDown1 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kStraightSlopeDown1NE, RoadObj::ImageIds::Style2::kStraightSlopeDown1SE, RoadObj::ImageIds::Style2::kStraightSlopeDown1SW, RoadObj::ImageIds::Style2::kStraightSlopeDown1NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 4, kNoStreetlight, 4, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 2> kStraightSlopeDownTPP = { kStraightSlopeDown0, kStraightSlopeDown1, }; // 0x0040CA49, 0x0040CC2E, 0x0040CE13, 0x0040CFF8 constexpr RoadPaintMergeablePiece kStraightSteepSlopeUp0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kStraightSteepSlopeUp0NE, RoadObj::ImageIds::Style2::kStraightSteepSlopeUp0SE, RoadObj::ImageIds::Style2::kStraightSteepSlopeUp0SW, RoadObj::ImageIds::Style2::kStraightSteepSlopeUp0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 8, kNoStreetlight, 8, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 1> kStraightSteepSlopeUpTPP = { kStraightSteepSlopeUp0, }; // 0x0040D5A7, 0x0040D78C, 0x0040D1DD, 0x0040D3C2 constexpr RoadPaintMergeablePiece kStraightSteepSlopeDown0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kStraightSteepSlopeDown0NE, RoadObj::ImageIds::Style2::kStraightSteepSlopeDown0SE, RoadObj::ImageIds::Style2::kStraightSteepSlopeDown0SW, RoadObj::ImageIds::Style2::kStraightSteepSlopeDown0NW, }, /* StreetlightHeights */ std::array<int16_t, 4>{ kNoStreetlight, 8, kNoStreetlight, 8, }, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 1> kStraightSteepSlopeDownTPP = { kStraightSteepSlopeDown0, }; // 0x00409031, 0x004090E8, 0x0040919D, 0x00409252 constexpr RoadPaintMergeablePiece kTurnaround0 = { std::array<uint32_t, 4>{ RoadObj::ImageIds::Style2::kTurnaround0NE, RoadObj::ImageIds::Style2::kTurnaround0SE, RoadObj::ImageIds::Style2::kTurnaround0SW, RoadObj::ImageIds::Style2::kTurnaround0NW, }, /* StreetlightHeights */ kNoStreetlights, /* IsMultiTileMerge */ kNoRoadPaintMerge, }; constexpr std::array<RoadPaintMergeablePiece, 1> kTurnaroundTPP = { kTurnaround0, }; constexpr std::array<std::span<const RoadPaintMergeablePiece>, 10> kRoadPaintParts = { kStraightTPP, kLeftCurveVerySmallTPP, kRightCurveVerySmallTPP, kLeftCurveSmallTPP, kRightCurveSmallTPP, kStraightSlopeUpTPP, kStraightSlopeDownTPP, kStraightSteepSlopeUpTPP, kStraightSteepSlopeDownTPP, kTurnaroundTPP, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintSignal.cpp ```cpp #include "PaintSignal.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Map/SignalElement.h" #include "Map/TileElement.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrainSignalObject.h" #include "Paint.h" #include "PaintTileDecorations.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" #include "Viewport.hpp" #include "World/CompanyManager.h" #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Ui::ViewportInteraction; namespace OpenLoco::Paint { struct OffsetAndBBOffset { World::Pos2 offset; World::Pos2 boundingOffset; }; // clang-format off static constexpr std::array<OffsetAndBBOffset, 16> _4FE830 = { OffsetAndBBOffset{ { 24, 4, }, { 24, 4, } }, OffsetAndBBOffset{ { 4, 8, }, { 4, 8, } }, OffsetAndBBOffset{ { 8, 28, }, { 8, 28, } }, OffsetAndBBOffset{ { 28, 24, }, { 28, 24, } }, OffsetAndBBOffset{ { 24, 1, }, { 24, 1, } }, OffsetAndBBOffset{ { 1, 8, }, { 1, 8, } }, OffsetAndBBOffset{ { 8, 31, }, { 8, 31, } }, OffsetAndBBOffset{ { 31, 24, }, { 31, 24, } }, OffsetAndBBOffset{ { 24, 16, }, { 24, 16, } }, OffsetAndBBOffset{ { 16, 8, }, { 16, 8, } }, OffsetAndBBOffset{ { 8, 16, }, { 8, 16, } }, OffsetAndBBOffset{ { 16, 24, }, { 16, 24, } }, OffsetAndBBOffset{ { 6, 10, }, { 0, 0, } }, OffsetAndBBOffset{ { 10, 26, }, { 10, 26, } }, OffsetAndBBOffset{ { 26, 22, }, { 26, 22, } }, OffsetAndBBOffset{ { 22, 6, }, { 22, 6, } }, }; static constexpr std::array<OffsetAndBBOffset, 16> _4FE870 = { OffsetAndBBOffset{ { 24, 28, }, { 24, 28, } }, OffsetAndBBOffset{ { 28, 8, }, { 28, 8, } }, OffsetAndBBOffset{ { 8, 4, }, { 8, 4, } }, OffsetAndBBOffset{ { 4, 24, }, { 4, 24, } }, OffsetAndBBOffset{ { 24, 16, }, { 24, 16, } }, OffsetAndBBOffset{ { 16, 8, }, { 16, 8, } }, OffsetAndBBOffset{ { 8, 16, }, { 8, 16, } }, OffsetAndBBOffset{ { 16, 24, }, { 16, 24, } }, OffsetAndBBOffset{ { 24, 31, }, { 24, 31, } }, OffsetAndBBOffset{ { 31, 8, }, { 31, 8, } }, OffsetAndBBOffset{ { 8, 1, }, { 8, 1, } }, OffsetAndBBOffset{ { 31, 24, }, { 31, 24, } }, OffsetAndBBOffset{ { 22, 26, }, { 22, 26, } }, OffsetAndBBOffset{ { 26, 10, }, { 26, 10, } }, OffsetAndBBOffset{ { 10, 6, }, { 0, 0, } }, OffsetAndBBOffset{ { 6, 22, }, { 6, 22, } }, }; // clang-format on // 0x004FE8B0 static constexpr std::array<uint32_t, 16> kOneWayArrowLeft = { ImageIds::one_way_direction_arrow_north, ImageIds::one_way_direction_arrow_east, ImageIds::one_way_direction_arrow_south, ImageIds::one_way_direction_arrow_west, ImageIds::one_way_direction_arrow_north, ImageIds::one_way_direction_arrow_east, ImageIds::one_way_direction_arrow_south, ImageIds::one_way_direction_arrow_west, ImageIds::one_way_direction_arrow_north, ImageIds::one_way_direction_arrow_east, ImageIds::one_way_direction_arrow_south, ImageIds::one_way_direction_arrow_west, ImageIds::one_way_direction_arrow_north_east, ImageIds::one_way_direction_arrow_south_east, ImageIds::one_way_direction_arrow_south_west, ImageIds::one_way_direction_arrow_north_west, }; // 0x004FE8B0 static constexpr std::array<uint32_t, 16> kOneWayArrowRight = { ImageIds::one_way_direction_arrow_south, ImageIds::one_way_direction_arrow_west, ImageIds::one_way_direction_arrow_north, ImageIds::one_way_direction_arrow_east, ImageIds::one_way_direction_arrow_south, ImageIds::one_way_direction_arrow_west, ImageIds::one_way_direction_arrow_north, ImageIds::one_way_direction_arrow_east, ImageIds::one_way_direction_arrow_south, ImageIds::one_way_direction_arrow_west, ImageIds::one_way_direction_arrow_north, ImageIds::one_way_direction_arrow_east, ImageIds::one_way_direction_arrow_south_west, ImageIds::one_way_direction_arrow_north_west, ImageIds::one_way_direction_arrow_north_east, ImageIds::one_way_direction_arrow_south_east, }; static uint8_t getTrackRotation(const bool isRight, const uint8_t trackId, const uint8_t rotation) { if (isRight) { return World::TrackData::getUnkTrack((trackId << 3) | (rotation + 4)).rotationBegin; } else { return World::TrackData::getUnkTrack((trackId << 3) | rotation).rotationBegin; } } static uint8_t getSignalHeightOffset(const bool isRight, const uint8_t trackId) { if (isRight) { return World::TrackData::getTrackMiscData(trackId).signalHeightOffsetRight; } else { return World::TrackData::getTrackMiscData(trackId).signalHeightOffsetLeft; } } static uint32_t getOneWayArrowImage(const bool isRight, const uint8_t trackId, const uint8_t rotation) { const auto& trackCoordinates = World::TrackData::getUnkTrack((trackId << 3) | rotation); if (isRight) { return kOneWayArrowRight[trackCoordinates.rotationBegin]; } else { return kOneWayArrowLeft[trackCoordinates.rotationEnd]; } } static void paintSignalSide(PaintSession& session, const World::SignalElement::Side& side, const bool isRight, const bool isGhost, const uint8_t trackId, const uint8_t rotation, const coord_t height) { if (side.hasSignal()) { session.setItemType(InteractionItem::signal); session.setTrackModId(isRight ? 1 : 0); auto* signalObj = ObjectManager::get<TrainSignalObject>(side.signalObjectId()); const auto trackRotation = getTrackRotation(isRight, trackId, rotation); const auto& offsetAndBBoffsetArr = signalObj->hasFlags(TrainSignalObjectFlags::isLeft) ? _4FE870 : _4FE830; const auto& offsetAndBBoffset = offsetAndBBoffsetArr[trackRotation]; const auto imageRotationOffset = ((trackRotation & 0x3) << 1) | (trackRotation >= 12 ? 1 : 0); const auto imageOffset = imageRotationOffset + signalObj->image + (side.frame() << 3); ImageId imageId{ imageOffset }; if (isGhost) { session.setItemType(InteractionItem::noInteraction); imageId = Gfx::applyGhostToImage(imageOffset); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } World::Pos3 offset(offsetAndBBoffset.offset.x, offsetAndBBoffset.offset.y, getSignalHeightOffset(isRight, trackId) + height); World::Pos3 bbOffset(offsetAndBBoffset.boundingOffset.x, offsetAndBBoffset.boundingOffset.y, offset.z + 4); World::Pos3 bbSize(1, 1, 14); session.addToPlotListAsParent(imageId, offset, bbOffset, bbSize); if (signalObj->hasFlags(TrainSignalObjectFlags::hasLights)) { if (side.hasRedLight()) { const auto lightOffset = side.hasRedLight2() ? TrainSignal::ImageIds::redLights2 : TrainSignal::ImageIds::redLights; const auto lightImageOffset = imageRotationOffset + signalObj->image + lightOffset; imageId = ImageId{ lightImageOffset }; if (isGhost) { session.setItemType(InteractionItem::noInteraction); imageId = Gfx::applyGhostToImage(imageOffset); } session.addToPlotListAsChild(imageId, offset, bbOffset, bbSize); } if (side.hasGreenLight()) { const auto lightOffset = side.hasGreenLight2() ? TrainSignal::ImageIds::greenLights2 : TrainSignal::ImageIds::greenLights; const auto lightImageOffset = imageRotationOffset + signalObj->image + lightOffset; imageId = ImageId{ lightImageOffset }; if (isGhost) { session.setItemType(InteractionItem::noInteraction); imageId = Gfx::applyGhostToImage(imageOffset); } session.addToPlotListAsChild(imageId, offset, bbOffset, bbSize); } } } else { if (((session.getViewFlags() & Ui::ViewportFlags::one_way_direction_arrows) != Ui::ViewportFlags::none) && (session.getRenderTarget()->zoomLevel == 0)) { session.setItemType(InteractionItem::noInteraction); const auto imageId = ImageId{ getOneWayArrowImage(!isRight, trackId, rotation), Colour::mutedAvocadoGreen }; const World::Pos3 offset(0, 0, height + getTrackDecorationHeightOffset(!isRight, trackId) + 2); const World::Pos3 bbOffset(15, 15, offset.z + 16); const World::Pos3 bbSize(1, 1, 0); session.addToPlotListAsParent(imageId, offset, bbOffset, bbSize); } } } // 0x0048864C void paintSignal(PaintSession& session, const World::SignalElement& elSignal) { if (elSignal.isAiAllocated()) { return; } auto* elTrack = elSignal.prev()->as<World::TrackElement>(); if (elTrack == nullptr) { return; } if (elSignal.isGhost() && CompanyManager::getSecondaryPlayerId() != CompanyId::null && elTrack->owner() == CompanyManager::getSecondaryPlayerId()) { return; } if (session.getRenderTarget()->zoomLevel > 1) { return; } const coord_t height = elSignal.baseHeight(); const auto trackId = elTrack->trackId(); const uint8_t rotation = (session.getRotation() + elSignal.rotation()) & 0x3; if (elTrack->sequenceIndex() == 0) { auto& leftSignal = elSignal.getLeft(); const bool leftIsGhost = elSignal.isGhost() || elSignal.isLeftGhost(); paintSignalSide(session, leftSignal, false, leftIsGhost, trackId, rotation, height); } if (!elTrack->isFlag6()) { return; } auto& rightSignal = elSignal.getRight(); const bool rightIsGhost = elSignal.isGhost() || elSignal.isRightGhost(); paintSignalSide(session, rightSignal, true, rightIsGhost, trackId, rotation, height); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintSignal.h ```h #pragma once namespace OpenLoco::World { struct SignalElement; } namespace OpenLoco::Paint { struct PaintSession; void paintSignal(PaintSession& session, const World::SignalElement& elSignal); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintStation.cpp ```cpp #include "PaintStation.h" #include "Graphics/Colour.h" #include "Graphics/RenderTarget.h" #include "Map/StationElement.h" #include "Map/TrackElement.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Objects/TrainStationObject.h" #include "Paint.h" #include "PaintAirport.h" #include "PaintDocks.h" #include "PaintRoadStation.h" #include "PaintTrainStation.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" #include "World/CompanyManager.h" #include "World/Station.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> namespace OpenLoco::Paint { // 0x0042F550 void paintStationCargo(PaintSession& session, const World::StationElement& elStation, const uint8_t flags, const uint32_t cargoTypes, std::span<const std::array<World::Pos3, 2>> cargoOffsets, const int16_t offsetZ, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize) { if (elStation.isGhost()) { return; } if (session.getRenderTarget()->zoomLevel > 0) { return; } const auto* station = StationManager::get(elStation.stationId()); const auto unkPosHash = (session.getUnkPosition().x + session.getUnkPosition().y) / 32; bool hasDrawn = false; uint8_t cargoId = 0; for (auto& cargoStat : station->cargoStats) { const auto* cargoObj = ObjectManager::get<CargoObject>(cargoId); if (!(cargoTypes & (1 << cargoId))) { cargoId++; continue; } cargoId++; if (cargoStat.densityPerTile == 0) { continue; } if (cargoObj->numPlatformVariations == 0) { continue; } uint32_t variation = cargoObj->numPlatformVariations - 1; variation &= unkPosHash; for (uint32_t i = 0; i < cargoStat.densityPerTile; ++i) { if (variation >= cargoObj->numPlatformVariations) { variation = 0; } const auto curVariation = variation; variation++; // TODO: Investigate if updateCargoDistribution should cap to prevent this ever being hit if (i >= cargoOffsets.size()) { break; } if (hasDrawn) { hasDrawn = true; if (!(flags & (1 << 1))) { continue; } } else { hasDrawn = true; if (!(flags & (1 << 0))) { continue; } } World::Pos3 offset; if (cargoObj->hasFlags(CargoObjectFlags::unk0)) { if (flags & (1 << 2)) { offset = cargoOffsets[i][1]; } else { continue; } } else { if (flags & (1 << 3)) { offset = cargoOffsets[i][0]; } else { continue; } } const auto imageId = ImageId{ cargoObj->unitInlineSprite + Cargo::ImageIds::kStationPlatformBegin + curVariation }; session.addToPlotListAsChild(imageId, offset + World::Pos3{ 0, 0, offsetZ }, boundBoxOffset, boundBoxSize); } } } // 0x0048B313 void paintStation(PaintSession& session, const World::StationElement& elStation) { if (elStation.isAiAllocated() && !showAiPlanningGhosts()) { return; } if (elStation.isGhost() && CompanyManager::getSecondaryPlayerId() != CompanyId::null && CompanyManager::getSecondaryPlayerId() == elStation.owner()) { return; } switch (elStation.stationType()) { case StationType::trainStation: paintTrainStation(session, elStation); break; case StationType::roadStation: paintRoadStation(session, elStation); break; case StationType::airport: paintAirport(session, elStation); break; case StationType::docks: paintDocks(session, elStation); break; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintStation.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> #include <array> #include <span> namespace OpenLoco::World { struct StationElement; } namespace OpenLoco::Paint { struct PaintSession; void paintStation(PaintSession& session, const World::StationElement& elStation); void paintStationCargo(PaintSession& session, const World::StationElement& elStation, const uint8_t flags, const uint32_t cargoTypes, std::span<const std::array<World::Pos3, 2>> cargoOffsets, const int16_t offsetZ, const World::Pos3& boundBoxOffset, const World::Pos3& boundBoxSize); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintSurface.cpp ```cpp #include "PaintSurface.h" #include "Config.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Map/MapSelection.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/Wave.h" #include "Map/WaveManager.h" #include "Objects/IndustryObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/SnowObject.h" #include "Objects/TunnelObject.h" #include "Objects/WaterObject.h" #include "Paint.h" #include "PaintTileDecorations.h" #include "Ui/ViewportInteraction.h" #include "World/IndustryManager.h" #include "World/Station.h" #include <OpenLoco/Core/Numerics.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Paint { static loco_global<LandObjectFlags[32], 0x00F003D3> _F003D3; // T // --- // L---R // --- // B struct CornerHeight { MicroZ top; // al MicroZ right; // ah MicroZ bottom; // cl MicroZ left; // ch }; // The height of corners either side of // an edge struct EdgeHeight { MicroZ self0; // al self corner 0 MicroZ neighbour0; // ah neighbour corner 0 MicroZ self1; // cl self corner 1 MicroZ neighbour1; // ch neighbour corner 1 }; struct TileDescriptor { World::Pos2 pos; const World::SurfaceElement* elSurface; uint8_t landObjectId; uint8_t slope; EdgeHeight edgeHeight; uint8_t snowCoverage; uint8_t growthStage; }; static constexpr std::array<CornerHeight, 32> kCornerHeights = { // T R B L CornerHeight{ 0, 0, 0, 0 }, CornerHeight{ 0, 0, 1, 0 }, CornerHeight{ 0, 0, 0, 1 }, CornerHeight{ 0, 0, 1, 1 }, CornerHeight{ 1, 0, 0, 0 }, CornerHeight{ 1, 0, 1, 0 }, CornerHeight{ 1, 0, 0, 1 }, CornerHeight{ 1, 0, 1, 1 }, CornerHeight{ 0, 1, 0, 0 }, CornerHeight{ 0, 1, 1, 0 }, CornerHeight{ 0, 1, 0, 1 }, CornerHeight{ 0, 1, 1, 1 }, CornerHeight{ 1, 1, 0, 0 }, CornerHeight{ 1, 1, 1, 0 }, CornerHeight{ 1, 1, 0, 1 }, CornerHeight{ 1, 1, 1, 1 }, CornerHeight{ 0, 0, 0, 0 }, CornerHeight{ 0, 0, 1, 0 }, CornerHeight{ 0, 0, 0, 1 }, CornerHeight{ 0, 0, 1, 1 }, CornerHeight{ 1, 0, 0, 0 }, CornerHeight{ 1, 0, 1, 0 }, CornerHeight{ 1, 0, 0, 1 }, CornerHeight{ 1, 0, 1, 2 }, CornerHeight{ 0, 1, 0, 0 }, CornerHeight{ 0, 1, 1, 0 }, CornerHeight{ 0, 1, 0, 1 }, CornerHeight{ 0, 1, 2, 1 }, CornerHeight{ 1, 1, 0, 0 }, CornerHeight{ 1, 2, 1, 0 }, CornerHeight{ 2, 1, 0, 1 }, CornerHeight{ 1, 1, 1, 1 }, }; // 0x004FD97E // Truncates a SurfaceSlope slope into only the representable values // input is SurfaceSlope 0 <-> 31 with some unrepresentable // output is 0 <-> 18 // unrepresentable will be displayed at 0 (flat) static constexpr std::array<uint8_t, 32> kSlopeToDisplaySlope = { 0, 2, 1, 3, 8, 10, 9, 11, 4, 6, 5, 7, 12, 14, 13, 15, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 18, 15, 0, }; static constexpr std::array<uint8_t, 19> k4FD30C = { 0, 0, 0, 8, 0, 0, 8, 16, 0, 8, 0, 16, 8, 16, 16, 16, 16, 16, 16, }; // bottom left tint static constexpr std::array<uint8_t, 19> k4FDA5E = { 2, 5, 1, 4, 2, 5, 1, 2, 2, 4, 1, 2, 1, 3, 0, 3, 1, 5, 0, }; // top left tint static constexpr std::array<uint8_t, 19> k4FDA71 = { 2, 5, 2, 4, 2, 5, 1, 1, 3, 4, 3, 2, 1, 2, 0, 3, 1, 5, 0, }; // top right tint static constexpr std::array<uint8_t, 19> k4FDA84 = { 2, 2, 2, 4, 0, 0, 1, 1, 3, 4, 3, 5, 1, 2, 2, 3, 1, 5, 0, }; // bottom right tint static constexpr std::array<uint8_t, 19> k4FDA97 = { 2, 2, 1, 4, 0, 0, 1, 2, 2, 4, 1, 5, 1, 3, 2, 3, 1, 5, 0, }; // 0x004FD99E constexpr std::array<std::array<World::Pos2, 4>, 4> kNeighbourOffsets = { // For some reason we use spritePosition with this so we need to take into // account the spritePosition offset which varies by rotation: // { 0, 0 }, // { 32, 0 }, // { 32, 32 }, // { 0, 32 }, std::array<World::Pos2, 4>{ World::Pos2{ 32, 0 }, World::Pos2{ 0, 32 }, World::Pos2{ 0, -32 }, World::Pos2{ -32, 0 }, }, std::array<World::Pos2, 4>{ World::Pos2{ -32, 32 }, // 0, 32 World::Pos2{ -64, 0 }, // -32, 0 World::Pos2{ 0, 0 }, // 32, 0 World::Pos2{ -32, -32 }, // 0, 32 }, std::array<World::Pos2, 4>{ World::Pos2{ -64, -32 }, // -32, 0 World::Pos2{ -32, -64 }, // 0, -32 World::Pos2{ -32, 0 }, // 0, 32 World::Pos2{ 0, -32 }, // 32, 0 }, std::array<World::Pos2, 4>{ World::Pos2{ 0, -64 }, // 0, -32 World::Pos2{ 32, -32 }, // 32, 0 World::Pos2{ -32, -32 }, // -32, 0 World::Pos2{ 0, 0 }, // 0, 32 }, }; static constexpr std::array<std::array<uint32_t, 19>, 4> kSnowCoverageSlopeToMask = { std::array<uint32_t, 19>{ ImageIds::snowMaskCoverage1Slope0, ImageIds::snowMaskCoverage1Slope1, ImageIds::snowMaskCoverage1Slope2, ImageIds::snowMaskCoverage1Slope3, ImageIds::snowMaskCoverage1Slope4, ImageIds::snowMaskCoverage1Slope5, ImageIds::snowMaskCoverage1Slope6, ImageIds::snowMaskCoverage1Slope7, ImageIds::snowMaskCoverage1Slope8, ImageIds::snowMaskCoverage1Slope9, ImageIds::snowMaskCoverage1Slope10, ImageIds::snowMaskCoverage1Slope11, ImageIds::snowMaskCoverage1Slope12, ImageIds::snowMaskCoverage1Slope13, ImageIds::snowMaskCoverage1Slope14, ImageIds::snowMaskCoverage1Slope15, ImageIds::snowMaskCoverage1Slope16, ImageIds::snowMaskCoverage1Slope17, ImageIds::snowMaskCoverage1Slope18, }, std::array<uint32_t, 19>{ ImageIds::snowMaskCoverage2Slope0, ImageIds::snowMaskCoverage2Slope1, ImageIds::snowMaskCoverage2Slope2, ImageIds::snowMaskCoverage2Slope3, ImageIds::snowMaskCoverage2Slope4, ImageIds::snowMaskCoverage2Slope5, ImageIds::snowMaskCoverage2Slope6, ImageIds::snowMaskCoverage2Slope7, ImageIds::snowMaskCoverage2Slope8, ImageIds::snowMaskCoverage2Slope9, ImageIds::snowMaskCoverage2Slope10, ImageIds::snowMaskCoverage2Slope11, ImageIds::snowMaskCoverage2Slope12, ImageIds::snowMaskCoverage2Slope13, ImageIds::snowMaskCoverage2Slope14, ImageIds::snowMaskCoverage2Slope15, ImageIds::snowMaskCoverage2Slope16, ImageIds::snowMaskCoverage2Slope17, ImageIds::snowMaskCoverage2Slope18, }, std::array<uint32_t, 19>{ ImageIds::snowMaskCoverage3Slope0, ImageIds::snowMaskCoverage3Slope1, ImageIds::snowMaskCoverage3Slope2, ImageIds::snowMaskCoverage3Slope3, ImageIds::snowMaskCoverage3Slope4, ImageIds::snowMaskCoverage3Slope5, ImageIds::snowMaskCoverage3Slope6, ImageIds::snowMaskCoverage3Slope7, ImageIds::snowMaskCoverage3Slope8, ImageIds::snowMaskCoverage3Slope9, ImageIds::snowMaskCoverage3Slope10, ImageIds::snowMaskCoverage3Slope11, ImageIds::snowMaskCoverage3Slope12, ImageIds::snowMaskCoverage3Slope13, ImageIds::snowMaskCoverage3Slope14, ImageIds::snowMaskCoverage3Slope15, ImageIds::snowMaskCoverage3Slope16, ImageIds::snowMaskCoverage3Slope17, ImageIds::snowMaskCoverage3Slope18, }, std::array<uint32_t, 19>{ ImageIds::snowMaskCoverage4Slope0, ImageIds::snowMaskCoverage4Slope1, ImageIds::snowMaskCoverage4Slope2, ImageIds::snowMaskCoverage4Slope3, ImageIds::snowMaskCoverage4Slope4, ImageIds::snowMaskCoverage4Slope5, ImageIds::snowMaskCoverage4Slope6, ImageIds::snowMaskCoverage4Slope7, ImageIds::snowMaskCoverage4Slope8, ImageIds::snowMaskCoverage4Slope9, ImageIds::snowMaskCoverage4Slope10, ImageIds::snowMaskCoverage4Slope11, ImageIds::snowMaskCoverage4Slope12, ImageIds::snowMaskCoverage4Slope13, ImageIds::snowMaskCoverage4Slope14, ImageIds::snowMaskCoverage4Slope15, ImageIds::snowMaskCoverage4Slope16, ImageIds::snowMaskCoverage4Slope17, ImageIds::snowMaskCoverage4Slope18, } }; static constexpr std::array<uint32_t, 19> kCornerSelectionBoxFromSlope = { ImageIds::constructionSelectionCornersSlope0, ImageIds::constructionSelectionCornersSlope1, ImageIds::constructionSelectionCornersSlope2, ImageIds::constructionSelectionCornersSlope3, ImageIds::constructionSelectionCornersSlope4, ImageIds::constructionSelectionCornersSlope5, ImageIds::constructionSelectionCornersSlope6, ImageIds::constructionSelectionCornersSlope7, ImageIds::constructionSelectionCornersSlope8, ImageIds::constructionSelectionCornersSlope9, ImageIds::constructionSelectionCornersSlope10, ImageIds::constructionSelectionCornersSlope11, ImageIds::constructionSelectionCornersSlope12, ImageIds::constructionSelectionCornersSlope13, ImageIds::constructionSelectionCornersSlope14, ImageIds::constructionSelectionCornersSlope15, ImageIds::constructionSelectionCornersSlope16, ImageIds::constructionSelectionCornersSlope17, ImageIds::constructionSelectionCornersSlope18, }; static constexpr std::array<ExtColour, 4> kCornerColours = { ExtColour::unk21, ExtColour::unk22, ExtColour::unk23, ExtColour::unk24, }; static constexpr std::array<uint32_t, 19> kQuadSelectionBoxFromSlope = { ImageIds::constructionSelectionQuadsSlope0, ImageIds::constructionSelectionQuadsSlope1, ImageIds::constructionSelectionQuadsSlope2, ImageIds::constructionSelectionQuadsSlope3, ImageIds::constructionSelectionQuadsSlope4, ImageIds::constructionSelectionQuadsSlope5, ImageIds::constructionSelectionQuadsSlope6, ImageIds::constructionSelectionQuadsSlope7, ImageIds::constructionSelectionQuadsSlope8, ImageIds::constructionSelectionQuadsSlope9, ImageIds::constructionSelectionQuadsSlope10, ImageIds::constructionSelectionQuadsSlope11, ImageIds::constructionSelectionQuadsSlope12, ImageIds::constructionSelectionQuadsSlope13, ImageIds::constructionSelectionQuadsSlope14, ImageIds::constructionSelectionQuadsSlope15, ImageIds::constructionSelectionQuadsSlope16, ImageIds::constructionSelectionQuadsSlope17, ImageIds::constructionSelectionQuadsSlope18, }; static constexpr std::array<ExtColour, 4> kQuarterColours = { ExtColour::unk27, ExtColour::unk28, ExtColour::unk29, ExtColour::unk2A, }; static constexpr std::array<uint32_t, 19> kEdgeSelectionBoxFromSlope = { ImageIds::constructionSelectionEdgesSlope0, ImageIds::constructionSelectionEdgesSlope1, ImageIds::constructionSelectionEdgesSlope2, ImageIds::constructionSelectionEdgesSlope3, ImageIds::constructionSelectionEdgesSlope4, ImageIds::constructionSelectionEdgesSlope5, ImageIds::constructionSelectionEdgesSlope6, ImageIds::constructionSelectionEdgesSlope7, ImageIds::constructionSelectionEdgesSlope8, ImageIds::constructionSelectionEdgesSlope9, ImageIds::constructionSelectionEdgesSlope10, ImageIds::constructionSelectionEdgesSlope11, ImageIds::constructionSelectionEdgesSlope12, ImageIds::constructionSelectionEdgesSlope13, ImageIds::constructionSelectionEdgesSlope14, ImageIds::constructionSelectionEdgesSlope15, ImageIds::constructionSelectionEdgesSlope16, ImageIds::constructionSelectionEdgesSlope17, ImageIds::constructionSelectionEdgesSlope18, }; static constexpr std::array<ExtColour, 4> kEdgeColours = { ExtColour::unk22, ExtColour::unk23, ExtColour::unk24, ExtColour::unk25, }; static constexpr std::array<uint32_t, 19> kCatchmentFromSlope = { ImageIds::constructionCatchmentSlope0, ImageIds::constructionCatchmentSlope1, ImageIds::constructionCatchmentSlope2, ImageIds::constructionCatchmentSlope3, ImageIds::constructionCatchmentSlope4, ImageIds::constructionCatchmentSlope5, ImageIds::constructionCatchmentSlope6, ImageIds::constructionCatchmentSlope7, ImageIds::constructionCatchmentSlope8, ImageIds::constructionCatchmentSlope9, ImageIds::constructionCatchmentSlope10, ImageIds::constructionCatchmentSlope11, ImageIds::constructionCatchmentSlope12, ImageIds::constructionCatchmentSlope13, ImageIds::constructionCatchmentSlope14, ImageIds::constructionCatchmentSlope15, ImageIds::constructionCatchmentSlope16, ImageIds::constructionCatchmentSlope17, ImageIds::constructionCatchmentSlope18, }; static constexpr std::array<uint32_t, 19> kGridlinesBoxFromSlope = { ImageIds::gridlinesSlope0, ImageIds::gridlinesSlope1, ImageIds::gridlinesSlope2, ImageIds::gridlinesSlope3, ImageIds::gridlinesSlope4, ImageIds::gridlinesSlope5, ImageIds::gridlinesSlope6, ImageIds::gridlinesSlope7, ImageIds::gridlinesSlope8, ImageIds::gridlinesSlope9, ImageIds::gridlinesSlope10, ImageIds::gridlinesSlope11, ImageIds::gridlinesSlope12, ImageIds::gridlinesSlope13, ImageIds::gridlinesSlope14, ImageIds::gridlinesSlope15, ImageIds::gridlinesSlope16, ImageIds::gridlinesSlope17, ImageIds::gridlinesSlope18, }; static constexpr std::array<std::array<uint32_t, 19>, 4> kSurfaceSmoothFromSlope = { std::array<uint32_t, 19>{ ImageIds::surfaceSmooth0Slope0, ImageIds::surfaceSmooth0Slope1, ImageIds::surfaceSmooth0Slope2, ImageIds::surfaceSmooth0Slope3, ImageIds::surfaceSmooth0Slope4, ImageIds::surfaceSmooth0Slope5, ImageIds::surfaceSmooth0Slope6, ImageIds::surfaceSmooth0Slope7, ImageIds::surfaceSmooth0Slope8, ImageIds::surfaceSmooth0Slope9, ImageIds::surfaceSmooth0Slope10, ImageIds::surfaceSmooth0Slope11, ImageIds::surfaceSmooth0Slope12, ImageIds::surfaceSmooth0Slope13, ImageIds::surfaceSmooth0Slope14, ImageIds::surfaceSmooth0Slope15, ImageIds::surfaceSmooth0Slope16, ImageIds::surfaceSmooth0Slope17, ImageIds::surfaceSmooth0Slope18, }, std::array<uint32_t, 19>{ ImageIds::surfaceSmooth1Slope0, ImageIds::surfaceSmooth1Slope1, ImageIds::surfaceSmooth1Slope2, ImageIds::surfaceSmooth1Slope3, ImageIds::surfaceSmooth1Slope4, ImageIds::surfaceSmooth1Slope5, ImageIds::surfaceSmooth1Slope6, ImageIds::surfaceSmooth1Slope7, ImageIds::surfaceSmooth1Slope8, ImageIds::surfaceSmooth1Slope9, ImageIds::surfaceSmooth1Slope10, ImageIds::surfaceSmooth1Slope11, ImageIds::surfaceSmooth1Slope12, ImageIds::surfaceSmooth1Slope13, ImageIds::surfaceSmooth1Slope14, ImageIds::surfaceSmooth1Slope15, ImageIds::surfaceSmooth1Slope16, ImageIds::surfaceSmooth1Slope17, ImageIds::surfaceSmooth1Slope18, }, std::array<uint32_t, 19>{ ImageIds::surfaceSmooth2Slope0, ImageIds::surfaceSmooth2Slope1, ImageIds::surfaceSmooth2Slope2, ImageIds::surfaceSmooth2Slope3, ImageIds::surfaceSmooth2Slope4, ImageIds::surfaceSmooth2Slope5, ImageIds::surfaceSmooth2Slope6, ImageIds::surfaceSmooth2Slope7, ImageIds::surfaceSmooth2Slope8, ImageIds::surfaceSmooth2Slope9, ImageIds::surfaceSmooth2Slope10, ImageIds::surfaceSmooth2Slope11, ImageIds::surfaceSmooth2Slope12, ImageIds::surfaceSmooth2Slope13, ImageIds::surfaceSmooth2Slope14, ImageIds::surfaceSmooth2Slope15, ImageIds::surfaceSmooth2Slope16, ImageIds::surfaceSmooth2Slope17, ImageIds::surfaceSmooth2Slope18, }, std::array<uint32_t, 19>{ ImageIds::surfaceSmooth3Slope0, ImageIds::surfaceSmooth3Slope1, ImageIds::surfaceSmooth3Slope2, ImageIds::surfaceSmooth3Slope3, ImageIds::surfaceSmooth3Slope4, ImageIds::surfaceSmooth3Slope5, ImageIds::surfaceSmooth3Slope6, ImageIds::surfaceSmooth3Slope7, ImageIds::surfaceSmooth3Slope8, ImageIds::surfaceSmooth3Slope9, ImageIds::surfaceSmooth3Slope10, ImageIds::surfaceSmooth3Slope11, ImageIds::surfaceSmooth3Slope12, ImageIds::surfaceSmooth3Slope13, ImageIds::surfaceSmooth3Slope14, ImageIds::surfaceSmooth3Slope15, ImageIds::surfaceSmooth3Slope16, ImageIds::surfaceSmooth3Slope17, ImageIds::surfaceSmooth3Slope18, }, }; constexpr std::array<uint8_t, 8> kUndergroundViewSnowNoise = { 0, // Don't display (No snow handled differently) 0, // Don't display 0, // Don't display 3, 6, 0, // Don't display (full snow handled differently) 0, 0, }; constexpr std::array<uint8_t, 16> kSlopeToWaterShape = { 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 4, 0 }; static constexpr uint8_t getRotatedSlope(uint8_t slope, uint8_t rotation) { return Numerics::rotl4bit(slope & 0xF, rotation) | (slope & 0x10); } static void paintMainSurface(PaintSession& session, uint32_t imageIndex, int16_t baseHeight) { const auto imageId = [imageIndex, &session]() { if ((session.getViewFlags() & (Ui::ViewportFlags::underground_view | Ui::ViewportFlags::flag_7)) != Ui::ViewportFlags::none) { return ImageId(imageIndex).withTranslucency(ExtColour::unk30); } return ImageId(imageIndex); }(); const World::Pos3 offsetUnk(0, 0, baseHeight); const World::Pos3 bbSizeUnk(32, 32, -1); session.addToPlotListAsParent(imageId, offsetUnk, bbSizeUnk); } struct SnowImage { uint32_t baseImage; uint32_t imageMask; }; // 0x00465F01 static void paintSurfaceCornerSelection(PaintSession& session, const uint8_t displaySlope, const uint8_t corner) { const auto colour = kCornerColours[corner]; const auto imageId = ImageId(kCornerSelectionBoxFromSlope[displaySlope], colour); session.attachToPrevious(imageId, { 0, 0 }); } // 0x00465F08 static void paintSurfaceFullTileSelection(PaintSession& session, const uint8_t displaySlope) { const auto imageId = ImageId(kCornerSelectionBoxFromSlope[displaySlope], ExtColour::unk25); session.attachToPrevious(imageId, { 0, 0 }); } // 0x00465F36 static void paintSurfaceQuadSelection(PaintSession& session, const uint8_t displaySlope, const uint8_t quad) { const auto colour = kQuarterColours[quad]; const auto imageId = ImageId(kQuadSelectionBoxFromSlope[displaySlope], colour); session.attachToPrevious(imageId, { 0, 0 }); } // 0x00465F69 static void paintSurfaceEdgeSelection(PaintSession& session, const uint8_t displaySlope, const uint8_t edge) { const auto colour = kEdgeColours[edge]; const auto imageId = ImageId(kEdgeSelectionBoxFromSlope[displaySlope], colour); session.attachToPrevious(imageId, { 0, 0 }); } struct WaterSurface { int16_t height; uint8_t slope; }; static WaterSurface getWaterSurface(const World::SurfaceElement& elSurface, uint8_t slope) { int16_t height = elSurface.baseHeight(); if (elSurface.waterHeight() > height) { height += World::kMicroZStep; if (elSurface.waterHeight() != height || !elSurface.isSlopeDoubleHeight()) { // This is the simple case where the water is flat as no // bits of surface breach the water slope = 0; height = elSurface.waterHeight(); } else { // Adjust the slope to handle surface breaches slope = Numerics::rotl4bit((slope & 0xF) ^ 0xF, 2); } } return WaterSurface{ .height = height, .slope = slope }; } // 0x00465F99 static void paintSurfaceFullWaterTileSelection(PaintSession& session, const World::SurfaceElement& elSurface, uint8_t slope) { const auto waterSurface = getWaterSurface(elSurface, slope); const auto displaySlope = kSlopeToDisplaySlope[waterSurface.slope]; const auto imageId = ImageId(kCornerSelectionBoxFromSlope[displaySlope], ExtColour::unk26); // TODO: Push/pop last ps? auto* lastPs = session.getLastPS(); session.addToPlotListAsParent(imageId, { 0, 0, waterSurface.height }, { 32, 32, 1 }); session.setLastPS(lastPs); } // 0x00465EE9 static void paintSurfaceSelection(PaintSession& session, const World::SurfaceElement& elSurface, const uint8_t slope) { const auto rotation = session.getRotation(); const auto unkF252AC = kSlopeToDisplaySlope[slope]; switch (World::getMapSelectionCorner()) { case World::MapSelectionType::corner0: case World::MapSelectionType::corner1: case World::MapSelectionType::corner2: case World::MapSelectionType::corner3: { uint32_t corner = enumValue(World::getMapSelectionCorner()) - enumValue(World::MapSelectionType::corner0); corner = (corner + rotation) & 3; paintSurfaceCornerSelection(session, unkF252AC, corner); break; } case World::MapSelectionType::full: paintSurfaceFullTileSelection(session, unkF252AC); break; case World::MapSelectionType::fullWater: paintSurfaceFullWaterTileSelection(session, elSurface, slope); break; case World::MapSelectionType::quarter0: case World::MapSelectionType::quarter1: case World::MapSelectionType::quarter2: case World::MapSelectionType::quarter3: { uint32_t quad = enumValue(World::getMapSelectionCorner()) - enumValue(World::MapSelectionType::quarter0); quad = (quad + rotation) & 3; paintSurfaceQuadSelection(session, unkF252AC, quad); break; } case World::MapSelectionType::edge0: case World::MapSelectionType::edge1: case World::MapSelectionType::edge2: case World::MapSelectionType::edge3: { uint32_t edge = enumValue(World::getMapSelectionCorner()) - enumValue(World::MapSelectionType::edge0); edge = (edge + rotation) & 3; paintSurfaceEdgeSelection(session, unkF252AC, edge); break; } } } static void paintSurfaceSmoothenEdge( PaintSession& session, uint8_t edge, const TileDescriptor& self, const TileDescriptor& neighbour) { if (neighbour.elSurface == nullptr) { return; } if (neighbour.edgeHeight.neighbour1 != neighbour.edgeHeight.self1 || neighbour.edgeHeight.neighbour0 != neighbour.edgeHeight.self0) { return; } // If either is industrial if (neighbour.landObjectId == 0xFFU || self.landObjectId == 0xFFU) { return; } if (self.snowCoverage == 3) { return; } // 0x00F25304 const auto displaySlope = kSlopeToDisplaySlope[self.slope]; const auto neighbourDislaySlope = kSlopeToDisplaySlope[neighbour.slope]; uint8_t dh = 0, cl = 0; switch (edge) { case 0: dh = k4FDA5E[displaySlope]; cl = k4FDA84[neighbourDislaySlope]; break; case 1: dh = k4FDA97[displaySlope]; cl = k4FDA71[neighbourDislaySlope]; break; case 2: dh = k4FDA71[displaySlope]; cl = k4FDA97[neighbourDislaySlope]; break; case 3: dh = k4FDA84[displaySlope]; cl = k4FDA5E[neighbourDislaySlope]; break; } auto selfObj = self.snowCoverage >= 4 ? 0xFFU : self.landObjectId; auto neighbourObj = neighbour.snowCoverage >= 4 ? 0xFFU : neighbour.landObjectId; if (self.growthStage == neighbour.growthStage && selfObj == neighbourObj) { // same tint if (cl == dh) { return; } if ((_F003D3[self.landObjectId] & LandObjectFlags::unk4) != LandObjectFlags::none) { return; } } else { if ((_F003D3[self.landObjectId] & LandObjectFlags::unk5) != LandObjectFlags::none) { return; } if ((_F003D3[neighbour.landObjectId] & LandObjectFlags::unk5) != LandObjectFlags::none) { return; } } const auto baseImageId = ImageId(kSurfaceSmoothFromSlope[edge][displaySlope]); if (neighbourObj == 0xFFU) { auto* snowObj = ObjectManager::get<SnowObject>(); const auto variation = 38 + cl; const auto maskImageId = ImageId(snowObj->image).withIndexOffset(variation); auto* attachedPs = session.attachToPrevious(baseImageId, { 0, 0 }); if (attachedPs != nullptr) { attachedPs->maskedImageId = maskImageId; attachedPs->flags |= PaintStructFlags::hasMaskedImage; } } else { auto* landObj = ObjectManager::get<LandObject>(neighbour.landObjectId); const auto variation = landObj->numImagesPerGrowthStage * neighbour.growthStage + 19 + cl; const auto maskImageId = ImageId(landObj->image).withIndexOffset(variation); auto* attachedPs = session.attachToPrevious(baseImageId, { 0, 0 }); if (attachedPs != nullptr) { attachedPs->maskedImageId = maskImageId; attachedPs->flags |= PaintStructFlags::hasMaskedImage; } } } static void paintMainUndergroundSurface(PaintSession& session, uint32_t imageIndex, uint8_t displaySlope) { auto* attachedPs = session.attachToPrevious(ImageId(imageIndex), { 0, 0 }); if (attachedPs != nullptr) { attachedPs->maskedImageId = ImageId(kGridlinesBoxFromSlope[displaySlope]); attachedPs->flags |= PaintStructFlags::hasMaskedImage; } } constexpr std::array<uint8_t, 4> kEdgeFactorOffset = { 0, 16, 16, 0 }; constexpr std::array<uint8_t, 4> kEdgeUndergroundOffset = { 0, 0, 67, 64 }; constexpr std::array<World::Pos3, 4> kEdgeImageOffset = { World::Pos3{ 30, 0, 0 }, World::Pos3{ 0, 30, 0 }, World::Pos3{ 0, -2, 1 }, World::Pos3{ -2, 0, 1 }, }; constexpr std::array<World::Pos3, 4> kEdgeBoundingBoxSize = { World::Pos3{ 0, 30, 15 }, World::Pos3{ 30, 0, 15 }, World::Pos3{ 30, 0, 15 }, World::Pos3{ 0, 30, 15 }, }; constexpr std::array<std::array<std::array<uint32_t, 5>, 4>, 2> kEdgeMaskImageFromSlope = { std::array<std::array<uint32_t, 5>, 4>{ std::array<uint32_t, 5>{ ImageIds::cliffEdge0MaskSlope0, ImageIds::cliffEdge0MaskSlope1, ImageIds::cliffEdge0MaskSlope2, ImageIds::cliffEdge0MaskSlope3, ImageIds::cliffEdge0MaskSlope4, }, std::array<uint32_t, 5>{ ImageIds::cliffEdge1MaskSlope0, ImageIds::cliffEdge1MaskSlope1, ImageIds::cliffEdge1MaskSlope2, ImageIds::cliffEdge1MaskSlope3, ImageIds::cliffEdge1MaskSlope4, }, std::array<uint32_t, 5>{ ImageIds::cliffEdge1MaskSlope0, ImageIds::cliffEdge1MaskSlope1, ImageIds::cliffEdge1MaskSlope2, ImageIds::cliffEdge1MaskSlope3, ImageIds::cliffEdge1MaskSlope4, }, std::array<uint32_t, 5>{ ImageIds::cliffEdge0MaskSlope0, ImageIds::cliffEdge0MaskSlope1, ImageIds::cliffEdge0MaskSlope2, ImageIds::cliffEdge0MaskSlope3, ImageIds::cliffEdge0MaskSlope4, }, }, std::array<std::array<uint32_t, 5>, 4>{ std::array<uint32_t, 5>{ ImageIds::cliffEdge0UndergroundMaskSlope0, ImageIds::cliffEdge0UndergroundMaskSlope1, ImageIds::cliffEdge0UndergroundMaskSlope2, ImageIds::cliffEdge0UndergroundMaskSlope3, ImageIds::cliffEdge0UndergroundMaskSlope4, }, std::array<uint32_t, 5>{ ImageIds::cliffEdge1UndergroundMaskSlope0, ImageIds::cliffEdge1UndergroundMaskSlope1, ImageIds::cliffEdge1UndergroundMaskSlope2, ImageIds::cliffEdge1UndergroundMaskSlope3, ImageIds::cliffEdge1UndergroundMaskSlope4, }, std::array<uint32_t, 5>{ ImageIds::cliffEdge1UndergroundMaskSlope0, ImageIds::cliffEdge1UndergroundMaskSlope1, ImageIds::cliffEdge1UndergroundMaskSlope2, ImageIds::cliffEdge1UndergroundMaskSlope3, ImageIds::cliffEdge1UndergroundMaskSlope4, }, std::array<uint32_t, 5>{ ImageIds::cliffEdge0UndergroundMaskSlope0, ImageIds::cliffEdge0UndergroundMaskSlope1, ImageIds::cliffEdge0UndergroundMaskSlope2, ImageIds::cliffEdge0UndergroundMaskSlope3, ImageIds::cliffEdge0UndergroundMaskSlope4, }, }, }; struct SegmentHeight { int16_t height; uint8_t slope; }; // Unrepresentable slopes are assumed to be flat std::array<SegmentHeight, 9> kFlatSegmentSupportHeight = { SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, }; std::array<std::array<SegmentHeight, 9>, 32> kSlopeToSegmentsSupportHeights = { kFlatSegmentSupportHeight, std::array<SegmentHeight, 9>{ SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 1 }, SegmentHeight{ 0, 1 }, SegmentHeight{ 12, 27 }, SegmentHeight{ 0, 1 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 6, 27 }, SegmentHeight{ 6, 27 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 0, 2 }, SegmentHeight{ 12, 23 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 2 }, SegmentHeight{ 0, 2 }, SegmentHeight{ 6, 23 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 6, 23 }, SegmentHeight{ 0, 0 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 2, 3 }, SegmentHeight{ 14, 3 }, SegmentHeight{ 2, 3 }, SegmentHeight{ 14, 3 }, SegmentHeight{ 8, 3 }, SegmentHeight{ 8, 3 }, SegmentHeight{ 2, 3 }, SegmentHeight{ 14, 3 }, SegmentHeight{ 8, 3 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 12, 30 }, SegmentHeight{ 0, 4 }, SegmentHeight{ 0, 4 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 4 }, SegmentHeight{ 6, 30 }, SegmentHeight{ 6, 30 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 0, 0 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 12, 30 }, SegmentHeight{ 0, 5 }, SegmentHeight{ 0, 5 }, SegmentHeight{ 12, 27 }, SegmentHeight{ 0, 5 }, SegmentHeight{ 6, 30 }, SegmentHeight{ 6, 30 }, SegmentHeight{ 6, 27 }, SegmentHeight{ 6, 27 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 14, 6 }, SegmentHeight{ 14, 6 }, SegmentHeight{ 2, 6 }, SegmentHeight{ 2, 6 }, SegmentHeight{ 8, 6 }, SegmentHeight{ 14, 6 }, SegmentHeight{ 8, 6 }, SegmentHeight{ 8, 6 }, SegmentHeight{ 2, 6 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 16, 7 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 4, 23 }, SegmentHeight{ 16, 7 }, SegmentHeight{ 16, 7 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 10, 23 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 10, 23 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 0, 8 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 12, 29 }, SegmentHeight{ 0, 8 }, SegmentHeight{ 0, 8 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 6, 29 }, SegmentHeight{ 0, 0 }, SegmentHeight{ 6, 29 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 2, 9 }, SegmentHeight{ 2, 9 }, SegmentHeight{ 14, 9 }, SegmentHeight{ 14, 9 }, SegmentHeight{ 8, 9 }, SegmentHeight{ 2, 9 }, SegmentHeight{ 8, 9 }, SegmentHeight{ 8, 9 }, SegmentHeight{ 14, 9 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 0, 10 }, SegmentHeight{ 12, 23 }, SegmentHeight{ 12, 29 }, SegmentHeight{ 0, 10 }, SegmentHeight{ 0, 10 }, SegmentHeight{ 6, 23 }, SegmentHeight{ 6, 29 }, SegmentHeight{ 6, 23 }, SegmentHeight{ 6, 29 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 4, 27 }, SegmentHeight{ 16, 11 }, SegmentHeight{ 16, 11 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 16, 11 }, SegmentHeight{ 10, 27 }, SegmentHeight{ 10, 27 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 16, 0 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 14, 12 }, SegmentHeight{ 2, 12 }, SegmentHeight{ 14, 12 }, SegmentHeight{ 2, 12 }, SegmentHeight{ 8, 12 }, SegmentHeight{ 8, 12 }, SegmentHeight{ 14, 12 }, SegmentHeight{ 2, 12 }, SegmentHeight{ 8, 12 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 16, 13 }, SegmentHeight{ 4, 29 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 16, 13 }, SegmentHeight{ 16, 13 }, SegmentHeight{ 10, 29 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 10, 29 }, SegmentHeight{ 16, 0 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 16, 0 }, SegmentHeight{ 16, 14 }, SegmentHeight{ 16, 14 }, SegmentHeight{ 4, 30 }, SegmentHeight{ 16, 14 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 16, 0 }, SegmentHeight{ 10, 30 }, SegmentHeight{ 10, 30 }, }, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, std::array<SegmentHeight, 9>{ SegmentHeight{ 16, 23 }, SegmentHeight{ 28, 23 }, SegmentHeight{ 4, 23 }, SegmentHeight{ 16, 23 }, SegmentHeight{ 16, 23 }, SegmentHeight{ 22, 23 }, SegmentHeight{ 10, 23 }, SegmentHeight{ 22, 23 }, SegmentHeight{ 10, 23 }, }, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, kFlatSegmentSupportHeight, std::array<SegmentHeight, 9>{ SegmentHeight{ 4, 27 }, SegmentHeight{ 16, 27 }, SegmentHeight{ 16, 27 }, SegmentHeight{ 28, 27 }, SegmentHeight{ 16, 27 }, SegmentHeight{ 10, 27 }, SegmentHeight{ 10, 27 }, SegmentHeight{ 22, 27 }, SegmentHeight{ 22, 27 }, }, kFlatSegmentSupportHeight, std::array<SegmentHeight, 9>{ SegmentHeight{ 16, 29 }, SegmentHeight{ 4, 29 }, SegmentHeight{ 28, 29 }, SegmentHeight{ 16, 29 }, SegmentHeight{ 16, 29 }, SegmentHeight{ 10, 29 }, SegmentHeight{ 22, 29 }, SegmentHeight{ 10, 29 }, SegmentHeight{ 22, 29 }, }, std::array<SegmentHeight, 9>{ SegmentHeight{ 28, 30 }, SegmentHeight{ 16, 30 }, SegmentHeight{ 16, 30 }, SegmentHeight{ 4, 30 }, SegmentHeight{ 16, 30 }, SegmentHeight{ 22, 30 }, SegmentHeight{ 22, 30 }, SegmentHeight{ 10, 30 }, SegmentHeight{ 10, 30 }, }, kFlatSegmentSupportHeight, }; // TODO: Unscramble this so they are the same constexpr std::array<uint8_t, 4> kCliffEdgeToTunnelEdge = { 2, 1, 3, 0 }; static void paintEdgeSection(PaintSession& session, uint32_t cliffEdgeImageBase, uint32_t factor, MicroZ height, uint8_t edge, uint32_t edgeSlopeMaskImageIndex) { const auto image = ImageId(cliffEdgeImageBase).withIndexOffset(factor + (height & 0xF)); const World::Pos3 offset = kEdgeImageOffset[edge] + World::Pos3(0, 0, height * kMicroZStep); const World::Pos3 boundBoxSize = kEdgeBoundingBoxSize[edge]; auto* ps = session.addToPlotListAsParent(image, offset, boundBoxSize); if (ps != nullptr) { ps->flags |= PaintStructFlags::hasMaskedImage; ps->maskedImageId = ImageId(edgeSlopeMaskImageIndex); } } static void paintSurfaceCliffEdgeImpl(PaintSession& session, uint8_t edge, int16_t baseHeight, const EdgeHeight& edgeHeight, uint32_t cliffEdgeImageBase) { if (edgeHeight.self0 <= edgeHeight.neighbour0 && edgeHeight.self1 <= edgeHeight.neighbour1) { return; } const bool isUnderground = (session.getViewFlags() & Ui::ViewportFlags::underground_view) != Ui::ViewportFlags::none; const auto spritePos = session.getSpritePosition(); const uint32_t factor = ((spritePos.x ^ spritePos.y) & 0b10'0000) + kEdgeFactorOffset[edge]; const auto undergroundOffset = kEdgeUndergroundOffset[edge]; if (undergroundOffset != 0 && isUnderground) { const auto offset = edgeHeight.self1 - edgeHeight.self0 + 1; const auto yOffset = ((edgeHeight.self0 - baseHeight / kMicroToSmallZStep) * kMicroZStep) + 1; const auto image = ImageId(cliffEdgeImageBase).withIndexOffset(offset + undergroundOffset); session.attachToPrevious(image, Ui::Point(0, -yOffset)); } auto& maskArr = kEdgeMaskImageFromSlope[isUnderground][edge]; // The current height we are drawing the edge at **MicroZ** MicroZ uHeight = edgeHeight.neighbour1; if (uHeight != edgeHeight.neighbour0) { uint8_t unk = 3; if (uHeight >= edgeHeight.neighbour0) { unk = 4; uHeight = edgeHeight.neighbour0; } if (uHeight != edgeHeight.self0 && uHeight != edgeHeight.self1) { paintEdgeSection(session, cliffEdgeImageBase, factor, uHeight, edge, maskArr[unk]); uHeight++; } } uint8_t tunnelNum = 0; while (uHeight < edgeHeight.self0 && uHeight < edgeHeight.self1) { const auto tunnelEdge = kCliffEdgeToTunnelEdge[edge]; while (uHeight > session.getTunnels(tunnelEdge)[tunnelNum].height) { tunnelNum++; } auto& tunnel = session.getTunnels(tunnelEdge)[tunnelNum]; if (uHeight == tunnel.height) { if (edge == 0) { auto* tunnelObj = ObjectManager::get<TunnelObject>(tunnel.type); { const auto image = ImageId(tunnelObj->image); const World::Pos3 offset = World::Pos3(30, 0, 0) + World::Pos3(0, 0, uHeight * kMicroZStep); const World::Pos3 boundBoxSize = World::Pos3(2, 2, 25); const World::Pos3 boundBoxOffset = World::Pos3(29, 0, 6) + World::Pos3(0, 0, uHeight * kMicroZStep); session.addToPlotListAsParent(image, offset, boundBoxOffset, boundBoxSize); } { const auto image = ImageId(tunnelObj->image).withIndexOffset(1); const World::Pos3 offset = World::Pos3(30, 0, 0) + World::Pos3(0, 0, uHeight * kMicroZStep); const World::Pos3 boundBoxSize = World::Pos3(1, 1, 31); const World::Pos3 boundBoxOffset = World::Pos3(30, 30, 0) + World::Pos3(0, 0, uHeight * kMicroZStep); session.addToPlotListAsParent(image, offset, boundBoxOffset, boundBoxSize); } } else if (edge == 1) { auto* tunnelObj = ObjectManager::get<TunnelObject>(tunnel.type); { const auto image = ImageId(tunnelObj->image).withIndexOffset(2); const World::Pos3 offset = World::Pos3(0, 30, 0) + World::Pos3(0, 0, uHeight * kMicroZStep); const World::Pos3 boundBoxSize = World::Pos3(2, 2, 25); const World::Pos3 boundBoxOffset = World::Pos3(0, 29, 6) + World::Pos3(0, 0, uHeight * kMicroZStep); session.addToPlotListAsParent(image, offset, boundBoxOffset, boundBoxSize); } { const auto image = ImageId(tunnelObj->image).withIndexOffset(3); const World::Pos3 offset = World::Pos3(0, 30, 0) + World::Pos3(0, 0, uHeight * kMicroZStep); const World::Pos3 boundBoxSize = World::Pos3(1, 1, 31); const World::Pos3 boundBoxOffset = World::Pos3(30, 30, 0) + World::Pos3(0, 0, uHeight * kMicroZStep); session.addToPlotListAsParent(image, offset, boundBoxOffset, boundBoxSize); } } uHeight += 2; tunnelNum++; continue; } paintEdgeSection(session, cliffEdgeImageBase, factor, uHeight, edge, maskArr[0]); uHeight++; } uint8_t unk = 1; if (uHeight >= edgeHeight.self0) { unk = 2; if (uHeight >= edgeHeight.self1) { return; } } paintEdgeSection(session, cliffEdgeImageBase, factor, uHeight, edge, maskArr[unk]); } static void paintSurfaceCliffEdge(PaintSession& session, uint8_t edge, const int16_t baseHeight, const TileDescriptor& neighbour, uint32_t cliffEdgeImageBase) { if (neighbour.elSurface == nullptr) { return; } paintSurfaceCliffEdgeImpl(session, edge, baseHeight, neighbour.edgeHeight, cliffEdgeImageBase); } static void paintSurfaceWaterCliffEdge(PaintSession& session, uint8_t edge, const int16_t waterHeight, const TileDescriptor& neighbour, uint32_t cliffEdgeImageBase) { if (neighbour.elSurface == nullptr) { return; } if (neighbour.elSurface->waterHeight() == waterHeight) { return; } const auto edgeHeight = EdgeHeight{ static_cast<uint8_t>(waterHeight / kMicroZStep), neighbour.edgeHeight.neighbour0, static_cast<uint8_t>(waterHeight / kMicroZStep), neighbour.edgeHeight.neighbour1 }; paintSurfaceCliffEdgeImpl(session, edge, waterHeight, edgeHeight, cliffEdgeImageBase); } // 0x004656BF void paintSurface(PaintSession& session, World::SurfaceElement& elSurface) { session.setItemType(Ui::ViewportInteraction::InteractionItem::surface); const auto zoomLevel = session.getRenderTarget()->zoomLevel; session.setDidPassSurface(true); // 0x00F252B0 / 0x00F252B4 but if 0x00F252B0 == -2 that means industrial [[maybe_unused]] uint8_t landObjId = elSurface.terrain(); const auto* landObj = ObjectManager::get<LandObject>(landObjId); const auto rotation = session.getRotation(); const auto baseHeight = elSurface.baseHeight(); const auto rotatedSlope = getRotatedSlope(elSurface.slope(), rotation); const auto selfDescriptor = TileDescriptor{ session.getSpritePosition(), &elSurface, elSurface.isIndustrial() ? static_cast<uint8_t>(0xFFU) : elSurface.terrain(), rotatedSlope, {}, // Edge height unused elSurface.snowCoverage(), elSurface.getGrowthStage(), }; // Used by bridge shadows to know where to draw session.setSurfaceHeight(elSurface.baseHeight()); session.setSurfaceSlope(rotatedSlope); const uint8_t selfMicroZ = elSurface.baseZ() / kMicroToSmallZStep; const CornerHeight selfCornerHeight = { static_cast<uint8_t>(selfMicroZ + kCornerHeights[rotatedSlope].top), static_cast<uint8_t>(selfMicroZ + kCornerHeights[rotatedSlope].right), static_cast<uint8_t>(selfMicroZ + kCornerHeights[rotatedSlope].bottom), static_cast<uint8_t>(selfMicroZ + kCornerHeights[rotatedSlope].left), }; std::array<TileDescriptor, 4> tileDescriptors{}; for (std::size_t i = 0; i < std::size(tileDescriptors); i++) { const auto& offset = kNeighbourOffsets[rotation][i]; const auto position = session.getSpritePosition() + offset; TileDescriptor& descriptor = tileDescriptors[i]; descriptor.elSurface = nullptr; if (!World::validCoords(position)) { continue; } descriptor.elSurface = World::TileManager::get(position).surface(); if (descriptor.elSurface == nullptr) { continue; } const uint32_t surfaceSlope = getRotatedSlope(descriptor.elSurface->slope(), rotation); const uint8_t microZ = descriptor.elSurface->baseZ() / kMicroToSmallZStep; const CornerHeight& ch = kCornerHeights[surfaceSlope]; descriptor.pos = position; descriptor.landObjectId = descriptor.elSurface->isIndustrial() ? static_cast<uint8_t>(0xFFU) : descriptor.elSurface->terrain(); descriptor.slope = surfaceSlope; if (i == 0) // SW edge { descriptor.edgeHeight.self0 = selfCornerHeight.left; descriptor.edgeHeight.neighbour0 = microZ + ch.top; descriptor.edgeHeight.self1 = selfCornerHeight.bottom; descriptor.edgeHeight.neighbour1 = microZ + ch.right; } else if (i == 1) // SE edge { descriptor.edgeHeight.self0 = selfCornerHeight.right; descriptor.edgeHeight.neighbour0 = microZ + ch.top; descriptor.edgeHeight.self1 = selfCornerHeight.bottom; descriptor.edgeHeight.neighbour1 = microZ + ch.left; } else if (i == 2) // NW edge { descriptor.edgeHeight.self0 = selfCornerHeight.top; descriptor.edgeHeight.neighbour0 = microZ + ch.right; descriptor.edgeHeight.self1 = selfCornerHeight.left; descriptor.edgeHeight.neighbour1 = microZ + ch.bottom; } else if (i == 3) // NE edge { descriptor.edgeHeight.self0 = selfCornerHeight.top; descriptor.edgeHeight.neighbour0 = microZ + ch.left; descriptor.edgeHeight.self1 = selfCornerHeight.right; descriptor.edgeHeight.neighbour1 = microZ + ch.bottom; } descriptor.snowCoverage = descriptor.elSurface->snowCoverage(); descriptor.growthStage = descriptor.elSurface->getGrowthStage(); } if (((session.getViewFlags() & Ui::ViewportFlags::height_marks_on_land) != Ui::ViewportFlags::none) && zoomLevel == 0) { const auto markerPos = session.getUnkPosition() + World::Pos2(16, 16); const auto markerHeight = World::TileManager::getHeight(markerPos).landHeight + 3; const auto markerImageIndex = getHeightMarkerImage(markerHeight); const auto imageId = ImageId{ markerImageIndex, Colour::mutedAvocadoGreen }; const World::Pos3 offset(16, 16, markerHeight); const World::Pos3 bbSize(1, 1, 0); session.addToPlotListAsParent(imageId, offset, bbSize); } // 0x00F25314 const auto cliffEdgeImageBase = landObj->cliffEdgeImage; // 0x00F252AC const auto displaySlope = kSlopeToDisplaySlope[selfDescriptor.slope]; // 0x00F25344 std::optional<SnowImage> snowImage = std::nullopt; if (elSurface.isIndustrial()) { // 0x00465C96 auto* industry = IndustryManager::get(elSurface.industryId()); auto* industryObj = ObjectManager::get<IndustryObject>(industry->objectId); session.setItemType(Ui::ViewportInteraction::InteractionItem::industryTree); const auto variation = industryObj->numImagesPerFieldGrowthStage * elSurface.getGrowthStage() + ((industryObj->farmTileNumImageAngles - 1) & rotation) * 21; // Draw trees if they exist { const auto height = baseHeight + k4FD30C[displaySlope]; const auto imageIndex = industryObj->fieldImageIds + variation + (elSurface.snowCoverage() ? 20 : 19); const World::Pos3 offset(0, 0, height); const World::Pos3 bbOffset(14, 14, height + 4); const World::Pos3 bbSize(4, 4, 14); session.addToPlotList4FD150(ImageId(imageIndex), offset, bbOffset, bbSize); } session.setItemType(Ui::ViewportInteraction::InteractionItem::surface); if ((zoomLevel == 0 && industryObj->hasFlags(IndustryObjectFlags::farmTilesDrawAboveSnow)) || elSurface.snowCoverage() == 0) { // Draw main surface image const auto imageIndex = industryObj->fieldImageIds + variation + displaySlope; paintMainSurface(session, imageIndex, baseHeight); } else { // Draw snow surface image auto* snowObj = ObjectManager::get<SnowObject>(); if (elSurface.snowCoverage() == 5) { paintMainSurface(session, displaySlope + snowObj->image, baseHeight); } else { const auto imageIndex = industryObj->fieldImageIds + variation + displaySlope; paintMainSurface(session, imageIndex, baseHeight); if ((session.getViewFlags() & (Ui::ViewportFlags::underground_view | Ui::ViewportFlags::flag_7)) == Ui::ViewportFlags::none) { snowImage = SnowImage{ .baseImage = displaySlope + snowObj->image, .imageMask = kSnowCoverageSlopeToMask[elSurface.snowCoverage() - 1][displaySlope] }; } } } } else { const auto variation = landObj->numImagesPerGrowthStage * elSurface.getGrowthStage() + ((landObj->numImageAngles - 1) & rotation) * 25; if (elSurface.snowCoverage()) { // Draw snow surface image auto* snowObj = ObjectManager::get<SnowObject>(); if (elSurface.snowCoverage() == 5) { paintMainSurface(session, displaySlope + snowObj->image, baseHeight); } else { const auto imageIndex = landObj->image + variation + displaySlope; paintMainSurface(session, imageIndex, baseHeight); if ((session.getViewFlags() & (Ui::ViewportFlags::underground_view | Ui::ViewportFlags::flag_7)) == Ui::ViewportFlags::none) { snowImage = SnowImage{ .baseImage = displaySlope + snowObj->image, .imageMask = kSnowCoverageSlopeToMask[elSurface.snowCoverage() - 1][displaySlope] }; } } } else { const auto imageIndex = [&elSurface, zoomLevel, displaySlope, &landObj, variation]() { if (!elSurface.water() && elSurface.variation() != 0 && zoomLevel == 0 && displaySlope == 0 && (landObj->numGrowthStages - 1) == elSurface.getGrowthStage()) { return landObj->mapPixelImage + 3 + elSurface.variation(); } return landObj->image + variation + displaySlope; }(); paintMainSurface(session, imageIndex, baseHeight); } } // 0x00465E92 if (World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { const auto pos = session.getUnkPosition(); auto [pointA, pointB] = getMapSelectionArea(); if (pos.x >= pointA.x && pos.x <= pointB.x && pos.y >= pointA.y && pos.y <= pointB.y) { paintSurfaceSelection(session, elSurface, selfDescriptor.slope); } } if (World::hasMapSelectionFlag(World::MapSelectionFlags::enableConstruct)) { if (isWithinMapSelectionFreeFormTiles(session.getUnkPosition())) { const auto colour = World::hasMapSelectionFlag(World::MapSelectionFlags::unk_03) ? ExtColour::unk2B : ExtColour::unk25; if (elSurface.water() && elSurface.waterHeight() > elSurface.baseHeight()) { const auto waterSurface = getWaterSurface(elSurface, selfDescriptor.slope); const auto waterDisplaySlope = kSlopeToDisplaySlope[waterSurface.slope]; const auto imageId = ImageId(kCornerSelectionBoxFromSlope[waterDisplaySlope], colour); // TODO: Push/pop last ps? auto* lastPs = session.getLastPS(); session.addToPlotListAsParent(imageId, { 0, 0, waterSurface.height }, { 32, 32, 1 }); session.setLastPS(lastPs); } else { const auto imageId = ImageId(kCornerSelectionBoxFromSlope[displaySlope], colour); session.attachToPrevious(imageId, { 0, 0 }); } } } if (World::hasMapSelectionFlag(World::MapSelectionFlags::catchmentArea)) { if (isWithinCatchmentDisplay(session.getUnkPosition())) { const auto waterSurface = getWaterSurface(elSurface, selfDescriptor.slope); const auto waterDisplaySlope = kSlopeToDisplaySlope[waterSurface.slope]; const auto imageId = ImageId(kCatchmentFromSlope[waterDisplaySlope], Colour::darkBlue); // TODO: Push/pop last ps? auto* lastPs = session.getLastPS(); session.addToPlotListAsParent(imageId, { 0, 0, waterSurface.height }, { 32, 32, 1 }); session.setLastPS(lastPs); } } if ((session.getViewFlags() & Ui::ViewportFlags::gridlines_on_landscape) != Ui::ViewportFlags::none && zoomLevel <= 2 && (session.getViewFlags() & Ui::ViewportFlags::underground_view) == Ui::ViewportFlags::none) { const auto imageId = ImageId(kGridlinesBoxFromSlope[displaySlope]).withTranslucency(ExtColour::unk30); session.attachToPrevious(imageId, { 0, 0 }); } if (snowImage.has_value() && zoomLevel <= 2) { const auto imageId = ImageId(snowImage->baseImage); auto* attachedPs = session.attachToPrevious(imageId, { 0, 0 }); if (attachedPs != nullptr) { attachedPs->flags |= PaintStructFlags::hasMaskedImage; attachedPs->maskedImageId = ImageId(snowImage->imageMask); } } if (zoomLevel == 0 && (session.getViewFlags() & (Ui::ViewportFlags::underground_view | Ui::ViewportFlags::flag_7)) == Ui::ViewportFlags::none && Config::get().landscapeSmoothing) { paintSurfaceSmoothenEdge(session, 2, selfDescriptor, tileDescriptors[2]); paintSurfaceSmoothenEdge(session, 3, selfDescriptor, tileDescriptors[3]); paintSurfaceSmoothenEdge(session, 0, selfDescriptor, tileDescriptors[0]); paintSurfaceSmoothenEdge(session, 1, selfDescriptor, tileDescriptors[1]); } if (((session.getViewFlags() & Ui::ViewportFlags::underground_view) != Ui::ViewportFlags::none) && ((session.getViewFlags() & Ui::ViewportFlags::flag_7) == Ui::ViewportFlags::none)) { if (elSurface.isIndustrial()) { auto* industry = IndustryManager::get(elSurface.industryId()); auto* industryObj = ObjectManager::get<IndustryObject>(industry->objectId); const auto variation = industryObj->numImagesPerFieldGrowthStage * elSurface.getGrowthStage() + ((industryObj->farmTileNumImageAngles - 1) & rotation) * 21; const auto imageIndex = industryObj->fieldImageIds + variation + displaySlope; if ((zoomLevel == 0 && industryObj->hasFlags(IndustryObjectFlags::farmTilesDrawAboveSnow)) || selfDescriptor.snowCoverage == 0) { paintMainUndergroundSurface(session, imageIndex, displaySlope); } else if (selfDescriptor.snowCoverage == 5) { auto* snowObj = ObjectManager::get<SnowObject>(); const auto imageId = ImageId(snowObj->image).withIndexOffset(19 + displaySlope); session.attachToPrevious(imageId, { 0, 0 }); } else { auto* snowObj = ObjectManager::get<SnowObject>(); const auto snowNoise = kUndergroundViewSnowNoise[selfDescriptor.snowCoverage]; if (snowNoise != 0) { const auto imageId = ImageId(snowObj->image).withIndexOffset(19 + displaySlope).withNoiseMask(snowNoise); session.attachToPrevious(imageId, { 0, 0 }); } paintMainUndergroundSurface(session, imageIndex, displaySlope); } } else { const auto variation = landObj->numImagesPerGrowthStage * elSurface.getGrowthStage() + ((landObj->numImageAngles - 1) & rotation) * 25; const auto imageIndex = landObj->image + variation + displaySlope; if (selfDescriptor.snowCoverage == 0) { paintMainUndergroundSurface(session, imageIndex, displaySlope); } else if (selfDescriptor.snowCoverage == 5) { // 0x00466389 auto* snowObj = ObjectManager::get<SnowObject>(); const auto imageId = ImageId(snowObj->image).withIndexOffset(19 + displaySlope); session.attachToPrevious(imageId, { 0, 0 }); } else { auto* snowObj = ObjectManager::get<SnowObject>(); const auto snowNoise = kUndergroundViewSnowNoise[selfDescriptor.snowCoverage]; if (snowNoise != 0) { const auto imageId = ImageId(snowObj->image).withIndexOffset(19 + displaySlope).withNoiseMask(snowNoise); session.attachToPrevious(imageId, { 0, 0 }); } paintMainUndergroundSurface(session, imageIndex, displaySlope); } } } if (((session.getViewFlags() & Ui::ViewportFlags::flag_8) == Ui::ViewportFlags::none)) { paintSurfaceCliffEdge(session, 2, baseHeight, tileDescriptors[2], cliffEdgeImageBase); paintSurfaceCliffEdge(session, 3, baseHeight, tileDescriptors[3], cliffEdgeImageBase); paintSurfaceCliffEdge(session, 0, baseHeight, tileDescriptors[0], cliffEdgeImageBase); paintSurfaceCliffEdge(session, 1, baseHeight, tileDescriptors[1], cliffEdgeImageBase); } session.setWaterHeight2(0); if (elSurface.water() != 0) { session.setItemType(Ui::ViewportInteraction::InteractionItem::water); const auto waterHeight = elSurface.waterHeight(); // Why are there 2 ??? session.setWaterHeight2(waterHeight); session.setWaterHeight(waterHeight); uint8_t shape = 0; if (waterHeight <= baseHeight + World::kMicroZStep) { shape = kSlopeToWaterShape[rotatedSlope & 0xF]; } auto* waterObj = ObjectManager::get<WaterObject>(); const auto imageId = ImageId(waterObj->image).withIndexOffset(shape + 35).withBlend(ExtColour::water); session.addToPlotListAsParent(imageId, { 0, 0, waterHeight }, { 32, 32, -1 }); const auto attachedImage = ImageId(waterObj->image).withIndexOffset(shape + 30); session.attachToPrevious(attachedImage, { 0, 0 }); // Draw waves if (elSurface.isFlag6() && zoomLevel == 0) { const auto waveIndex = WaveManager::getWaveIndex(toTileSpace(session.getUnkPosition())); const auto& wave = WaveManager::getWave(waveIndex); const auto waveImage = ImageId(waterObj->image).withIndexOffset(wave.frame + 60); session.attachToPrevious(waveImage, { 0, 0 }); } // Do water edges paintSurfaceWaterCliffEdge(session, 2, waterHeight, tileDescriptors[2], cliffEdgeImageBase); paintSurfaceWaterCliffEdge(session, 3, waterHeight, tileDescriptors[3], cliffEdgeImageBase); paintSurfaceWaterCliffEdge(session, 0, waterHeight, tileDescriptors[0], cliffEdgeImageBase); paintSurfaceWaterCliffEdge(session, 1, waterHeight, tileDescriptors[1], cliffEdgeImageBase); } // Only used by dead code... // session.getGeneralSupportHeight().var_03 |= (1U << 0); session.setGeneralSupportHeight(baseHeight, selfDescriptor.slope); const auto& segmentsSupportHeight = kSlopeToSegmentsSupportHeights[selfDescriptor.slope]; for (auto segment = 0U; segment < 9U; ++segment) { const auto& segmentSupportHeight = segmentsSupportHeight[segment]; session.setSegmentSupportHeight(segment, segmentSupportHeight.height, segmentSupportHeight.slope); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintSurface.h ```h #pragma once namespace OpenLoco::World { struct SurfaceElement; } namespace OpenLoco::Paint { struct PaintSession; void paintSurface(PaintSession& session, World::SurfaceElement& elSurface); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTile.cpp ```cpp #include "PaintTile.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Input.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Map/WallElement.h" #include "Objects/BridgeObject.h" #include "Objects/ObjectManager.h" #include "Paint.h" #include "PaintBridge.h" #include "PaintBuilding.h" #include "PaintIndustry.h" #include "PaintRoad.h" #include "PaintSignal.h" #include "PaintStation.h" #include "PaintSurface.h" #include "PaintTrack.h" #include "PaintTree.h" #include "PaintWall.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" #include "World/Station.h" using namespace OpenLoco::Interop; using namespace OpenLoco::Ui::ViewportInteraction; using namespace OpenLoco::World; namespace OpenLoco::Paint { // 0x004621FF static void paintVoid(PaintSession& session, const World::Pos2& loc) { constexpr World::Pos2 kUnkOffsets[4] = { { 0, 0 }, { 32, 0 }, { 32, 32 }, { 0, 32 }, }; const auto loc2 = loc + kUnkOffsets[session.getRotation()]; const auto vpPos = World::gameToScreen(World::Pos3(loc2.x, loc2.y, 16), session.getRotation()); if (vpPos.y + 32 <= session.getRenderTarget()->y) { return; } if (vpPos.y - 20 >= session.getRenderTarget()->height + session.getRenderTarget()->y) { return; } session.setEntityPosition(loc2); session.setItemType(InteractionItem::noInteraction); session.addToPlotListAsParent(ImageId{ ImageIds::blank_tile }, { 0, 0, 16 }, { 32, 32, -1 }); } // 0x00461EA7 static void paintConstructionArrow(PaintSession& session, const World::Pos2& loc) { static loco_global<World::Pos3, 0x00F24942> _constructionArrowLocation; static loco_global<uint8_t, 0x00F24948> _constructionArrowDirection; if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enableConstructionArrow)) { return; } if (session.getUnkPosition() != _constructionArrowLocation) { return; } session.setEntityPosition(loc); const auto dirIndex = (_constructionArrowDirection & 0xFC) | (((_constructionArrowDirection & 0x3) + session.getRotation()) & 0x3); constexpr std::array<uint32_t, 16> kConstructionArrowImages = { ImageIds::construction_arrow_north, ImageIds::construction_arrow_east, ImageIds::construction_arrow_south, ImageIds::construction_arrow_west, ImageIds::construction_arrow_north2, ImageIds::construction_arrow_east2, ImageIds::construction_arrow_south2, ImageIds::construction_arrow_west2, ImageIds::construction_arrow_north3, ImageIds::construction_arrow_east3, ImageIds::construction_arrow_south3, ImageIds::construction_arrow_west3, ImageIds::construction_arrow_north_east, ImageIds::construction_arrow_south_east, ImageIds::construction_arrow_south_west, ImageIds::construction_arrow_north_west, }; const auto imageId = ImageId{ kConstructionArrowImages[dirIndex], Colour::yellow }; session.setItemType(InteractionItem::noInteraction); session.addToPlotListAsParent(imageId, { 0, 0, _constructionArrowLocation->z }, World::Pos3(0, 0, _constructionArrowLocation->z + 10), { 32, 32, -1 }); } constexpr std::array<std::array<World::Pos3, 9>, 2> kSupportBoundingBoxOffsets = { std::array<World::Pos3, 9>{ World::Pos3{ 2, 2, 6 }, World::Pos3{ 28, 2, 6 }, World::Pos3{ 2, 28, 6 }, World::Pos3{ 28, 28, 6 }, World::Pos3{ 15, 15, 6 }, World::Pos3{ 15, 2, 6 }, World::Pos3{ 2, 15, 6 }, World::Pos3{ 28, 15, 6 }, World::Pos3{ 15, 28, 6 }, }, std::array<World::Pos3, 9>{ World::Pos3{ 2, 2, 28 }, World::Pos3{ 28, 2, 28 }, World::Pos3{ 2, 28, 28 }, World::Pos3{ 28, 28, 28 }, World::Pos3{ 15, 15, 28 }, World::Pos3{ 15, 2, 28 }, World::Pos3{ 2, 15, 28 }, World::Pos3{ 28, 15, 28 }, World::Pos3{ 15, 28, 28 }, }, }; constexpr std::array<World::Pos3, 2> kSupportBoundingBoxLengths = { World::Pos3{ 1, 1, 17 }, World::Pos3{ 1, 1, 1 }, }; constexpr std::array<std::array<uint8_t, 4>, 4> kFrequencyRotationMap = { std::array<uint8_t, 4>{ 1U << 0, 1U << 2, 1U << 1, 1U << 3 }, std::array<uint8_t, 4>{ 1U << 3, 1U << 0, 1U << 2, 1U << 1 }, std::array<uint8_t, 4>{ 1U << 1, 1U << 3, 1U << 0, 1U << 2 }, std::array<uint8_t, 4>{ 1U << 2, 1U << 1, 1U << 3, 1U << 0 }, }; // 0x0046748F static void paintSupports(PaintSession& session) { // Copy the supports const TrackRoadAdditionSupports supports = session.getAdditionSupport(); // Clear the supports as this function will have taken care of their render session.setAdditionSupport(TrackRoadAdditionSupports{}); auto& bridge = session.getBridgeEntry(); if (!bridge.isEmpty()) { auto* bridgeObj = ObjectManager::get<BridgeObject>(bridge.objectId); // Bridge blocks the supports due to the roof if ((bridgeObj->flags & BridgeObjectFlags::hasRoof) != BridgeObjectFlags::none) { return; } } const auto pos = session.getSpritePosition(); for (auto i = 0U; i < std::size(kSegmentOffsets); ++i) { const auto seg = kSegmentOffsets[i]; // No support at this location if (supports.segmentImages[i] == 0) { continue; } // Support blocked by something at this location if ((supports.occupiedSegments & seg) != SegmentFlags::none) { continue; } const auto frequency = supports.segmentFrequency[i]; bool frequenceSkip = [&]() { auto& line = kFrequencyRotationMap[session.getRotation()]; if ((frequency & line[0]) && !(pos.x & 0b0010'0000)) { return true; } if ((frequency & line[1]) && !(pos.y & 0b0010'0000)) { return true; } if ((frequency & line[2]) && (pos.x & 0b0010'0000)) { return true; } if ((frequency & line[3]) && (pos.y & 0b0010'0000)) { return true; } return false; }(); if (frequenceSkip) { continue; } session.setCurrentItem(supports.segmentInteractionItem[i]); session.setItemType(supports.segmentInteractionType[i]); const auto heightOffset = World::Pos3{ 0, 0, supports.height }; for (auto j = 0; j < 2; ++j) { const auto bbOffset = kSupportBoundingBoxOffsets[j][i] + heightOffset; const auto& bbLength = kSupportBoundingBoxLengths[j]; const auto imageId = ImageId::fromUInt32(supports.segmentImages[i]).withIndexOffset(j); session.addToPlotList4FD150(imageId, heightOffset, bbOffset, bbLength); } } } // Returns std::nullopt on no need to paint static std::optional<Ui::viewport_pos> paintTileElementsSetup(PaintSession& session, const World::Pos2& loc) { session.setSegmentsSupportHeight(SegmentFlags::all, std::numeric_limits<uint16_t>::max(), 0); session.setGeneralSupportHeight(std::numeric_limits<uint16_t>::max(), 0); session.resetTunnels(); session.setUnkPosition(loc); session.setMapPosition(loc); session.setMaxHeight(loc); constexpr World::Pos2 kUnkOffsets[4] = { { 0, 0 }, { 32, 0 }, { 32, 32 }, { 0, 32 }, }; const auto loc2 = loc + kUnkOffsets[session.getRotation()]; const auto vpPos = World::gameToScreen(World::Pos3(loc2.x, loc2.y, 0), session.getRotation()); paintConstructionArrow(session, loc2); if (vpPos.y + 52 <= session.getRenderTarget()->y) { return std::nullopt; } if (vpPos.y - session.getMaxHeight() > session.getRenderTarget()->y + session.getRenderTarget()->height) { return std::nullopt; } session.setEntityPosition(loc2); session.resetTileColumn({ vpPos.x, vpPos.y }); return { vpPos }; } static void paintTileElementsEndLoop(PaintSession& session, const World::TileElement& el) { if (el.isLast() || el.baseZ() != ((&el) + 1)->baseZ()) { if (session.getRoadExits() != 0) { finalisePaintRoad(session); } if (session.getAdditionSupportHeight() != 0) { paintSupports(session); } session.finaliseTrackRoadOrdering(); session.finaliseTrackRoadAdditionsOrdering(); session.setOccupiedAdditionSupportSegments(SegmentFlags::none); auto& bridgeEntry = session.getBridgeEntry(); if (!bridgeEntry.isEmpty()) { if (paintBridge(session)) { session.setSegmentsSupportHeight(SegmentFlags::all, 0xFFFF, 0); } if (session.getGeneralSupportHeight().height >= bridgeEntry.height) { session.setGeneralSupportHeight(bridgeEntry.height, 0x20); } session.setBridgeEntry(kNullBridgeEntry); } if (session.get525CF8() != SegmentFlags::none) { session.setSegmentsSupportHeight(session.get525CF8(), 0xFFFF, 0); session.set525CF8(SegmentFlags::none); } } } // 0x00461CF8 void paintTileElements(PaintSession& session, const World::Pos2& loc) { if (!World::drawableCoords(loc)) { paintVoid(session, loc); return; } const auto vpPos = paintTileElementsSetup(session, loc); if (!vpPos) { return; } auto tile = TileManager::get(loc); for (auto& el : tile) { session.setUnkVpY(vpPos->y - el.baseHeight()); session.setCurrentItem(&el); switch (el.type()) { case World::ElementType::surface: { auto& elSurface = el.get<World::SurfaceElement>(); paintSurface(session, elSurface); break; } case World::ElementType::track: { auto& elTrack = el.get<World::TrackElement>(); paintTrack(session, elTrack); break; } case World::ElementType::station: { auto& elStation = el.get<World::StationElement>(); paintStation(session, elStation); break; } case World::ElementType::signal: { auto& elSignal = el.get<World::SignalElement>(); paintSignal(session, elSignal); break; } case World::ElementType::building: { auto& elBuilding = el.get<World::BuildingElement>(); paintBuilding(session, elBuilding); break; } case World::ElementType::tree: { auto& elTree = el.get<World::TreeElement>(); paintTree(session, elTree); break; } case World::ElementType::wall: { auto& elWall = el.get<World::WallElement>(); paintWall(session, elWall); break; } case World::ElementType::road: { auto& elRoad = el.get<World::RoadElement>(); paintRoad(session, elRoad); break; } case World::ElementType::industry: { auto& elIndustry = el.get<World::IndustryElement>(); paintIndustry(session, elIndustry); break; } } paintTileElementsEndLoop(session, el); } } // 0x004617C6 void paintTileElements2(PaintSession& session, const World::Pos2& loc) { if (!World::drawableCoords(loc)) { return; } const auto vpPos = paintTileElementsSetup(session, loc); if (!vpPos) { return; } auto tile = TileManager::get(loc); for (auto& el : tile) { session.setUnkVpY(vpPos->y - el.baseHeight()); session.setCurrentItem(&el); switch (el.type()) { case World::ElementType::surface: case World::ElementType::track: case World::ElementType::signal: case World::ElementType::wall: case World::ElementType::road: continue; case World::ElementType::station: { auto& elStation = el.get<StationElement>(); switch (elStation.stationType()) { case StationType::airport: case StationType::docks: paintStation(session, elStation); break; default: case StationType::roadStation: case StationType::trainStation: continue; } break; } case World::ElementType::building: { auto& elBuilding = el.get<BuildingElement>(); paintBuilding(session, elBuilding); break; } case World::ElementType::tree: { auto& elTree = el.get<TreeElement>(); paintTree(session, elTree); break; } case World::ElementType::industry: { auto& elIndustry = el.get<IndustryElement>(); paintIndustry(session, elIndustry); break; } } paintTileElementsEndLoop(session, el); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTile.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> namespace OpenLoco::Paint { struct PaintSession; void paintTileElements(PaintSession& session, const World::Pos2& loc); void paintTileElements2(PaintSession& session, const World::Pos2& loc); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTileDecorations.cpp ```cpp #include "PaintTileDecorations.h" #include "Config.h" #include "GameState.h" #include "Graphics/ImageIds.h" #include <OpenLoco/Interop/Interop.hpp> namespace OpenLoco::Paint { static Interop::loco_global<int8_t[2 * 44], 0x004F86B4> _4F86B4; static Interop::loco_global<int8_t[2 * 10], 0x004F720C> _4F720C; static constexpr std::array<std::array<uint32_t, 256>, 3> kHeightMarkerImages = { // MicroZ Units std::array<uint32_t, 256>{ ImageIds::height_marker_neg_128_u, ImageIds::height_marker_neg_127_u, ImageIds::height_marker_neg_126_u, ImageIds::height_marker_neg_125_u, ImageIds::height_marker_neg_124_u, ImageIds::height_marker_neg_123_u, ImageIds::height_marker_neg_122_u, ImageIds::height_marker_neg_121_u, ImageIds::height_marker_neg_120_u, ImageIds::height_marker_neg_119_u, ImageIds::height_marker_neg_118_u, ImageIds::height_marker_neg_117_u, ImageIds::height_marker_neg_116_u, ImageIds::height_marker_neg_115_u, ImageIds::height_marker_neg_114_u, ImageIds::height_marker_neg_113_u, ImageIds::height_marker_neg_112_u, ImageIds::height_marker_neg_111_u, ImageIds::height_marker_neg_110_u, ImageIds::height_marker_neg_109_u, ImageIds::height_marker_neg_108_u, ImageIds::height_marker_neg_107_u, ImageIds::height_marker_neg_106_u, ImageIds::height_marker_neg_105_u, ImageIds::height_marker_neg_104_u, ImageIds::height_marker_neg_103_u, ImageIds::height_marker_neg_102_u, ImageIds::height_marker_neg_101_u, ImageIds::height_marker_neg_100_u, ImageIds::height_marker_neg_99_u, ImageIds::height_marker_neg_98_u, ImageIds::height_marker_neg_97_u, ImageIds::height_marker_neg_96_u, ImageIds::height_marker_neg_95_u, ImageIds::height_marker_neg_94_u, ImageIds::height_marker_neg_93_u, ImageIds::height_marker_neg_92_u, ImageIds::height_marker_neg_91_u, ImageIds::height_marker_neg_90_u, ImageIds::height_marker_neg_89_u, ImageIds::height_marker_neg_88_u, ImageIds::height_marker_neg_87_u, ImageIds::height_marker_neg_86_u, ImageIds::height_marker_neg_85_u, ImageIds::height_marker_neg_84_u, ImageIds::height_marker_neg_83_u, ImageIds::height_marker_neg_82_u, ImageIds::height_marker_neg_81_u, ImageIds::height_marker_neg_80_u, ImageIds::height_marker_neg_79_u, ImageIds::height_marker_neg_78_u, ImageIds::height_marker_neg_77_u, ImageIds::height_marker_neg_76_u, ImageIds::height_marker_neg_75_u, ImageIds::height_marker_neg_74_u, ImageIds::height_marker_neg_73_u, ImageIds::height_marker_neg_72_u, ImageIds::height_marker_neg_71_u, ImageIds::height_marker_neg_70_u, ImageIds::height_marker_neg_69_u, ImageIds::height_marker_neg_68_u, ImageIds::height_marker_neg_67_u, ImageIds::height_marker_neg_66_u, ImageIds::height_marker_neg_65_u, ImageIds::height_marker_neg_64_u, ImageIds::height_marker_neg_63_u, ImageIds::height_marker_neg_62_u, ImageIds::height_marker_neg_61_u, ImageIds::height_marker_neg_60_u, ImageIds::height_marker_neg_59_u, ImageIds::height_marker_neg_58_u, ImageIds::height_marker_neg_57_u, ImageIds::height_marker_neg_56_u, ImageIds::height_marker_neg_55_u, ImageIds::height_marker_neg_54_u, ImageIds::height_marker_neg_53_u, ImageIds::height_marker_neg_52_u, ImageIds::height_marker_neg_51_u, ImageIds::height_marker_neg_50_u, ImageIds::height_marker_neg_49_u, ImageIds::height_marker_neg_48_u, ImageIds::height_marker_neg_47_u, ImageIds::height_marker_neg_46_u, ImageIds::height_marker_neg_45_u, ImageIds::height_marker_neg_44_u, ImageIds::height_marker_neg_43_u, ImageIds::height_marker_neg_42_u, ImageIds::height_marker_neg_41_u, ImageIds::height_marker_neg_40_u, ImageIds::height_marker_neg_39_u, ImageIds::height_marker_neg_38_u, ImageIds::height_marker_neg_37_u, ImageIds::height_marker_neg_36_u, ImageIds::height_marker_neg_35_u, ImageIds::height_marker_neg_34_u, ImageIds::height_marker_neg_33_u, ImageIds::height_marker_neg_32_u, ImageIds::height_marker_neg_31_u, ImageIds::height_marker_neg_30_u, ImageIds::height_marker_neg_29_u, ImageIds::height_marker_neg_28_u, ImageIds::height_marker_neg_27_u, ImageIds::height_marker_neg_26_u, ImageIds::height_marker_neg_25_u, ImageIds::height_marker_neg_24_u, ImageIds::height_marker_neg_23_u, ImageIds::height_marker_neg_22_u, ImageIds::height_marker_neg_21_u, ImageIds::height_marker_neg_20_u, ImageIds::height_marker_neg_19_u, ImageIds::height_marker_neg_18_u, ImageIds::height_marker_neg_17_u, ImageIds::height_marker_neg_16_u, ImageIds::height_marker_neg_15_u, ImageIds::height_marker_neg_14_u, ImageIds::height_marker_neg_13_u, ImageIds::height_marker_neg_12_u, ImageIds::height_marker_neg_11_u, ImageIds::height_marker_neg_10_u, ImageIds::height_marker_neg_9_u, ImageIds::height_marker_neg_8_u, ImageIds::height_marker_neg_7_u, ImageIds::height_marker_neg_6_u, ImageIds::height_marker_neg_5_u, ImageIds::height_marker_neg_4_u, ImageIds::height_marker_neg_3_u, ImageIds::height_marker_neg_2_u, ImageIds::height_marker_neg_1_u, ImageIds::height_marker_0_u, ImageIds::height_marker_1_u, ImageIds::height_marker_2_u, ImageIds::height_marker_3_u, ImageIds::height_marker_4_u, ImageIds::height_marker_5_u, ImageIds::height_marker_6_u, ImageIds::height_marker_7_u, ImageIds::height_marker_8_u, ImageIds::height_marker_9_u, ImageIds::height_marker_10_u, ImageIds::height_marker_11_u, ImageIds::height_marker_12_u, ImageIds::height_marker_13_u, ImageIds::height_marker_14_u, ImageIds::height_marker_15_u, ImageIds::height_marker_16_u, ImageIds::height_marker_17_u, ImageIds::height_marker_18_u, ImageIds::height_marker_19_u, ImageIds::height_marker_20_u, ImageIds::height_marker_21_u, ImageIds::height_marker_22_u, ImageIds::height_marker_23_u, ImageIds::height_marker_24_u, ImageIds::height_marker_25_u, ImageIds::height_marker_26_u, ImageIds::height_marker_27_u, ImageIds::height_marker_28_u, ImageIds::height_marker_29_u, ImageIds::height_marker_30_u, ImageIds::height_marker_31_u, ImageIds::height_marker_32_u, ImageIds::height_marker_33_u, ImageIds::height_marker_34_u, ImageIds::height_marker_35_u, ImageIds::height_marker_36_u, ImageIds::height_marker_37_u, ImageIds::height_marker_38_u, ImageIds::height_marker_39_u, ImageIds::height_marker_40_u, ImageIds::height_marker_41_u, ImageIds::height_marker_42_u, ImageIds::height_marker_43_u, ImageIds::height_marker_44_u, ImageIds::height_marker_45_u, ImageIds::height_marker_46_u, ImageIds::height_marker_47_u, ImageIds::height_marker_48_u, ImageIds::height_marker_49_u, ImageIds::height_marker_50_u, ImageIds::height_marker_51_u, ImageIds::height_marker_52_u, ImageIds::height_marker_53_u, ImageIds::height_marker_54_u, ImageIds::height_marker_55_u, ImageIds::height_marker_56_u, ImageIds::height_marker_57_u, ImageIds::height_marker_58_u, ImageIds::height_marker_59_u, ImageIds::height_marker_60_u, ImageIds::height_marker_61_u, ImageIds::height_marker_62_u, ImageIds::height_marker_63_u, ImageIds::height_marker_64_u, ImageIds::height_marker_65_u, ImageIds::height_marker_66_u, ImageIds::height_marker_67_u, ImageIds::height_marker_68_u, ImageIds::height_marker_69_u, ImageIds::height_marker_70_u, ImageIds::height_marker_71_u, ImageIds::height_marker_72_u, ImageIds::height_marker_73_u, ImageIds::height_marker_74_u, ImageIds::height_marker_75_u, ImageIds::height_marker_76_u, ImageIds::height_marker_77_u, ImageIds::height_marker_78_u, ImageIds::height_marker_79_u, ImageIds::height_marker_80_u, ImageIds::height_marker_81_u, ImageIds::height_marker_82_u, ImageIds::height_marker_83_u, ImageIds::height_marker_84_u, ImageIds::height_marker_85_u, ImageIds::height_marker_86_u, ImageIds::height_marker_87_u, ImageIds::height_marker_88_u, ImageIds::height_marker_89_u, ImageIds::height_marker_90_u, ImageIds::height_marker_91_u, ImageIds::height_marker_92_u, ImageIds::height_marker_93_u, ImageIds::height_marker_94_u, ImageIds::height_marker_95_u, ImageIds::height_marker_96_u, ImageIds::height_marker_97_u, ImageIds::height_marker_98_u, ImageIds::height_marker_99_u, ImageIds::height_marker_100_u, ImageIds::height_marker_101_u, ImageIds::height_marker_102_u, ImageIds::height_marker_103_u, ImageIds::height_marker_104_u, ImageIds::height_marker_105_u, ImageIds::height_marker_106_u, ImageIds::height_marker_107_u, ImageIds::height_marker_108_u, ImageIds::height_marker_109_u, ImageIds::height_marker_110_u, ImageIds::height_marker_111_u, ImageIds::height_marker_112_u, ImageIds::height_marker_113_u, ImageIds::height_marker_114_u, ImageIds::height_marker_115_u, ImageIds::height_marker_116_u, ImageIds::height_marker_117_u, ImageIds::height_marker_118_u, ImageIds::height_marker_119_u, ImageIds::height_marker_120_u, ImageIds::height_marker_121_u, ImageIds::height_marker_122_u, ImageIds::height_marker_123_u, ImageIds::height_marker_124_u, ImageIds::height_marker_125_u, ImageIds::height_marker_126_u, ImageIds::height_marker_127_u, }, // Imperial std::array<uint32_t, 256>{ ImageIds::height_marker_neg_128_i, ImageIds::height_marker_neg_127_i, ImageIds::height_marker_neg_126_i, ImageIds::height_marker_neg_125_i, ImageIds::height_marker_neg_124_i, ImageIds::height_marker_neg_123_i, ImageIds::height_marker_neg_122_i, ImageIds::height_marker_neg_121_i, ImageIds::height_marker_neg_120_i, ImageIds::height_marker_neg_119_i, ImageIds::height_marker_neg_118_i, ImageIds::height_marker_neg_117_i, ImageIds::height_marker_neg_116_i, ImageIds::height_marker_neg_115_i, ImageIds::height_marker_neg_114_i, ImageIds::height_marker_neg_113_i, ImageIds::height_marker_neg_112_i, ImageIds::height_marker_neg_111_i, ImageIds::height_marker_neg_110_i, ImageIds::height_marker_neg_109_i, ImageIds::height_marker_neg_108_i, ImageIds::height_marker_neg_107_i, ImageIds::height_marker_neg_106_i, ImageIds::height_marker_neg_105_i, ImageIds::height_marker_neg_104_i, ImageIds::height_marker_neg_103_i, ImageIds::height_marker_neg_102_i, ImageIds::height_marker_neg_101_i, ImageIds::height_marker_neg_100_i, ImageIds::height_marker_neg_99_i, ImageIds::height_marker_neg_98_i, ImageIds::height_marker_neg_97_i, ImageIds::height_marker_neg_96_i, ImageIds::height_marker_neg_95_i, ImageIds::height_marker_neg_94_i, ImageIds::height_marker_neg_93_i, ImageIds::height_marker_neg_92_i, ImageIds::height_marker_neg_91_i, ImageIds::height_marker_neg_90_i, ImageIds::height_marker_neg_89_i, ImageIds::height_marker_neg_88_i, ImageIds::height_marker_neg_87_i, ImageIds::height_marker_neg_86_i, ImageIds::height_marker_neg_85_i, ImageIds::height_marker_neg_84_i, ImageIds::height_marker_neg_83_i, ImageIds::height_marker_neg_82_i, ImageIds::height_marker_neg_81_i, ImageIds::height_marker_neg_80_i, ImageIds::height_marker_neg_79_i, ImageIds::height_marker_neg_78_i, ImageIds::height_marker_neg_77_i, ImageIds::height_marker_neg_76_i, ImageIds::height_marker_neg_75_i, ImageIds::height_marker_neg_74_i, ImageIds::height_marker_neg_73_i, ImageIds::height_marker_neg_72_i, ImageIds::height_marker_neg_71_i, ImageIds::height_marker_neg_70_i, ImageIds::height_marker_neg_69_i, ImageIds::height_marker_neg_68_i, ImageIds::height_marker_neg_67_i, ImageIds::height_marker_neg_66_i, ImageIds::height_marker_neg_65_i, ImageIds::height_marker_neg_64_i, ImageIds::height_marker_neg_63_i, ImageIds::height_marker_neg_62_i, ImageIds::height_marker_neg_61_i, ImageIds::height_marker_neg_60_i, ImageIds::height_marker_neg_59_i, ImageIds::height_marker_neg_58_i, ImageIds::height_marker_neg_57_i, ImageIds::height_marker_neg_56_i, ImageIds::height_marker_neg_55_i, ImageIds::height_marker_neg_54_i, ImageIds::height_marker_neg_53_i, ImageIds::height_marker_neg_52_i, ImageIds::height_marker_neg_51_i, ImageIds::height_marker_neg_50_i, ImageIds::height_marker_neg_49_i, ImageIds::height_marker_neg_48_i, ImageIds::height_marker_neg_47_i, ImageIds::height_marker_neg_46_i, ImageIds::height_marker_neg_45_i, ImageIds::height_marker_neg_44_i, ImageIds::height_marker_neg_43_i, ImageIds::height_marker_neg_42_i, ImageIds::height_marker_neg_41_i, ImageIds::height_marker_neg_40_i, ImageIds::height_marker_neg_39_i, ImageIds::height_marker_neg_38_i, ImageIds::height_marker_neg_37_i, ImageIds::height_marker_neg_36_i, ImageIds::height_marker_neg_35_i, ImageIds::height_marker_neg_34_i, ImageIds::height_marker_neg_33_i, ImageIds::height_marker_neg_32_i, ImageIds::height_marker_neg_31_i, ImageIds::height_marker_neg_30_i, ImageIds::height_marker_neg_29_i, ImageIds::height_marker_neg_28_i, ImageIds::height_marker_neg_27_i, ImageIds::height_marker_neg_26_i, ImageIds::height_marker_neg_25_i, ImageIds::height_marker_neg_24_i, ImageIds::height_marker_neg_23_i, ImageIds::height_marker_neg_22_i, ImageIds::height_marker_neg_21_i, ImageIds::height_marker_neg_20_i, ImageIds::height_marker_neg_19_i, ImageIds::height_marker_neg_18_i, ImageIds::height_marker_neg_17_i, ImageIds::height_marker_neg_16_i, ImageIds::height_marker_neg_15_i, ImageIds::height_marker_neg_14_i, ImageIds::height_marker_neg_13_i, ImageIds::height_marker_neg_12_i, ImageIds::height_marker_neg_11_i, ImageIds::height_marker_neg_10_i, ImageIds::height_marker_neg_9_i, ImageIds::height_marker_neg_8_i, ImageIds::height_marker_neg_7_i, ImageIds::height_marker_neg_6_i, ImageIds::height_marker_neg_5_i, ImageIds::height_marker_neg_4_i, ImageIds::height_marker_neg_3_i, ImageIds::height_marker_neg_2_i, ImageIds::height_marker_neg_1_i, ImageIds::height_marker_0_i, ImageIds::height_marker_1_i, ImageIds::height_marker_2_i, ImageIds::height_marker_3_i, ImageIds::height_marker_4_i, ImageIds::height_marker_5_i, ImageIds::height_marker_6_i, ImageIds::height_marker_7_i, ImageIds::height_marker_8_i, ImageIds::height_marker_9_i, ImageIds::height_marker_10_i, ImageIds::height_marker_11_i, ImageIds::height_marker_12_i, ImageIds::height_marker_13_i, ImageIds::height_marker_14_i, ImageIds::height_marker_15_i, ImageIds::height_marker_16_i, ImageIds::height_marker_17_i, ImageIds::height_marker_18_i, ImageIds::height_marker_19_i, ImageIds::height_marker_20_i, ImageIds::height_marker_21_i, ImageIds::height_marker_22_i, ImageIds::height_marker_23_i, ImageIds::height_marker_24_i, ImageIds::height_marker_25_i, ImageIds::height_marker_26_i, ImageIds::height_marker_27_i, ImageIds::height_marker_28_i, ImageIds::height_marker_29_i, ImageIds::height_marker_30_i, ImageIds::height_marker_31_i, ImageIds::height_marker_32_i, ImageIds::height_marker_33_i, ImageIds::height_marker_34_i, ImageIds::height_marker_35_i, ImageIds::height_marker_36_i, ImageIds::height_marker_37_i, ImageIds::height_marker_38_i, ImageIds::height_marker_39_i, ImageIds::height_marker_40_i, ImageIds::height_marker_41_i, ImageIds::height_marker_42_i, ImageIds::height_marker_43_i, ImageIds::height_marker_44_i, ImageIds::height_marker_45_i, ImageIds::height_marker_46_i, ImageIds::height_marker_47_i, ImageIds::height_marker_48_i, ImageIds::height_marker_49_i, ImageIds::height_marker_50_i, ImageIds::height_marker_51_i, ImageIds::height_marker_52_i, ImageIds::height_marker_53_i, ImageIds::height_marker_54_i, ImageIds::height_marker_55_i, ImageIds::height_marker_56_i, ImageIds::height_marker_57_i, ImageIds::height_marker_58_i, ImageIds::height_marker_59_i, ImageIds::height_marker_60_i, ImageIds::height_marker_61_i, ImageIds::height_marker_62_i, ImageIds::height_marker_63_i, ImageIds::height_marker_64_i, ImageIds::height_marker_65_i, ImageIds::height_marker_66_i, ImageIds::height_marker_67_i, ImageIds::height_marker_68_i, ImageIds::height_marker_69_i, ImageIds::height_marker_70_i, ImageIds::height_marker_71_i, ImageIds::height_marker_72_i, ImageIds::height_marker_73_i, ImageIds::height_marker_74_i, ImageIds::height_marker_75_i, ImageIds::height_marker_76_i, ImageIds::height_marker_77_i, ImageIds::height_marker_78_i, ImageIds::height_marker_79_i, ImageIds::height_marker_80_i, ImageIds::height_marker_81_i, ImageIds::height_marker_82_i, ImageIds::height_marker_83_i, ImageIds::height_marker_84_i, ImageIds::height_marker_85_i, ImageIds::height_marker_86_i, ImageIds::height_marker_87_i, ImageIds::height_marker_88_i, ImageIds::height_marker_89_i, ImageIds::height_marker_90_i, ImageIds::height_marker_91_i, ImageIds::height_marker_92_i, ImageIds::height_marker_93_i, ImageIds::height_marker_94_i, ImageIds::height_marker_95_i, ImageIds::height_marker_96_i, ImageIds::height_marker_97_i, ImageIds::height_marker_98_i, ImageIds::height_marker_99_i, ImageIds::height_marker_100_i, ImageIds::height_marker_101_i, ImageIds::height_marker_102_i, ImageIds::height_marker_103_i, ImageIds::height_marker_104_i, ImageIds::height_marker_105_i, ImageIds::height_marker_106_i, ImageIds::height_marker_107_i, ImageIds::height_marker_108_i, ImageIds::height_marker_109_i, ImageIds::height_marker_110_i, ImageIds::height_marker_111_i, ImageIds::height_marker_112_i, ImageIds::height_marker_113_i, ImageIds::height_marker_114_i, ImageIds::height_marker_115_i, ImageIds::height_marker_116_i, ImageIds::height_marker_117_i, ImageIds::height_marker_118_i, ImageIds::height_marker_119_i, ImageIds::height_marker_120_i, ImageIds::height_marker_121_i, ImageIds::height_marker_122_i, ImageIds::height_marker_123_i, ImageIds::height_marker_124_i, ImageIds::height_marker_125_i, ImageIds::height_marker_126_i, ImageIds::height_marker_127_i, }, // Metric std::array<uint32_t, 256>{ ImageIds::height_marker_neg_128_m, ImageIds::height_marker_neg_127_m, ImageIds::height_marker_neg_126_m, ImageIds::height_marker_neg_125_m, ImageIds::height_marker_neg_124_m, ImageIds::height_marker_neg_123_m, ImageIds::height_marker_neg_122_m, ImageIds::height_marker_neg_121_m, ImageIds::height_marker_neg_120_m, ImageIds::height_marker_neg_119_m, ImageIds::height_marker_neg_118_m, ImageIds::height_marker_neg_117_m, ImageIds::height_marker_neg_116_m, ImageIds::height_marker_neg_115_m, ImageIds::height_marker_neg_114_m, ImageIds::height_marker_neg_113_m, ImageIds::height_marker_neg_112_m, ImageIds::height_marker_neg_111_m, ImageIds::height_marker_neg_110_m, ImageIds::height_marker_neg_109_m, ImageIds::height_marker_neg_108_m, ImageIds::height_marker_neg_107_m, ImageIds::height_marker_neg_106_m, ImageIds::height_marker_neg_105_m, ImageIds::height_marker_neg_104_m, ImageIds::height_marker_neg_103_m, ImageIds::height_marker_neg_102_m, ImageIds::height_marker_neg_101_m, ImageIds::height_marker_neg_100_m, ImageIds::height_marker_neg_99_m, ImageIds::height_marker_neg_98_m, ImageIds::height_marker_neg_97_m, ImageIds::height_marker_neg_96_m, ImageIds::height_marker_neg_95_m, ImageIds::height_marker_neg_94_m, ImageIds::height_marker_neg_93_m, ImageIds::height_marker_neg_92_m, ImageIds::height_marker_neg_91_m, ImageIds::height_marker_neg_90_m, ImageIds::height_marker_neg_89_m, ImageIds::height_marker_neg_88_m, ImageIds::height_marker_neg_87_m, ImageIds::height_marker_neg_86_m, ImageIds::height_marker_neg_85_m, ImageIds::height_marker_neg_84_m, ImageIds::height_marker_neg_83_m, ImageIds::height_marker_neg_82_m, ImageIds::height_marker_neg_81_m, ImageIds::height_marker_neg_80_m, ImageIds::height_marker_neg_79_m, ImageIds::height_marker_neg_78_m, ImageIds::height_marker_neg_77_m, ImageIds::height_marker_neg_76_m, ImageIds::height_marker_neg_75_m, ImageIds::height_marker_neg_74_m, ImageIds::height_marker_neg_73_m, ImageIds::height_marker_neg_72_m, ImageIds::height_marker_neg_71_m, ImageIds::height_marker_neg_70_m, ImageIds::height_marker_neg_69_m, ImageIds::height_marker_neg_68_m, ImageIds::height_marker_neg_67_m, ImageIds::height_marker_neg_66_m, ImageIds::height_marker_neg_65_m, ImageIds::height_marker_neg_64_m, ImageIds::height_marker_neg_63_m, ImageIds::height_marker_neg_62_m, ImageIds::height_marker_neg_61_m, ImageIds::height_marker_neg_60_m, ImageIds::height_marker_neg_59_m, ImageIds::height_marker_neg_58_m, ImageIds::height_marker_neg_57_m, ImageIds::height_marker_neg_56_m, ImageIds::height_marker_neg_55_m, ImageIds::height_marker_neg_54_m, ImageIds::height_marker_neg_53_m, ImageIds::height_marker_neg_52_m, ImageIds::height_marker_neg_51_m, ImageIds::height_marker_neg_50_m, ImageIds::height_marker_neg_49_m, ImageIds::height_marker_neg_48_m, ImageIds::height_marker_neg_47_m, ImageIds::height_marker_neg_46_m, ImageIds::height_marker_neg_45_m, ImageIds::height_marker_neg_44_m, ImageIds::height_marker_neg_43_m, ImageIds::height_marker_neg_42_m, ImageIds::height_marker_neg_41_m, ImageIds::height_marker_neg_40_m, ImageIds::height_marker_neg_39_m, ImageIds::height_marker_neg_38_m, ImageIds::height_marker_neg_37_m, ImageIds::height_marker_neg_36_m, ImageIds::height_marker_neg_35_m, ImageIds::height_marker_neg_34_m, ImageIds::height_marker_neg_33_m, ImageIds::height_marker_neg_32_m, ImageIds::height_marker_neg_31_m, ImageIds::height_marker_neg_30_m, ImageIds::height_marker_neg_29_m, ImageIds::height_marker_neg_28_m, ImageIds::height_marker_neg_27_m, ImageIds::height_marker_neg_26_m, ImageIds::height_marker_neg_25_m, ImageIds::height_marker_neg_24_m, ImageIds::height_marker_neg_23_m, ImageIds::height_marker_neg_22_m, ImageIds::height_marker_neg_21_m, ImageIds::height_marker_neg_20_m, ImageIds::height_marker_neg_19_m, ImageIds::height_marker_neg_18_m, ImageIds::height_marker_neg_17_m, ImageIds::height_marker_neg_16_m, ImageIds::height_marker_neg_15_m, ImageIds::height_marker_neg_14_m, ImageIds::height_marker_neg_13_m, ImageIds::height_marker_neg_12_m, ImageIds::height_marker_neg_11_m, ImageIds::height_marker_neg_10_m, ImageIds::height_marker_neg_9_m, ImageIds::height_marker_neg_8_m, ImageIds::height_marker_neg_7_m, ImageIds::height_marker_neg_6_m, ImageIds::height_marker_neg_5_m, ImageIds::height_marker_neg_4_m, ImageIds::height_marker_neg_3_m, ImageIds::height_marker_neg_2_m, ImageIds::height_marker_neg_1_m, ImageIds::height_marker_0_m, ImageIds::height_marker_1_m, ImageIds::height_marker_2_m, ImageIds::height_marker_3_m, ImageIds::height_marker_4_m, ImageIds::height_marker_5_m, ImageIds::height_marker_6_m, ImageIds::height_marker_7_m, ImageIds::height_marker_8_m, ImageIds::height_marker_9_m, ImageIds::height_marker_10_m, ImageIds::height_marker_11_m, ImageIds::height_marker_12_m, ImageIds::height_marker_13_m, ImageIds::height_marker_14_m, ImageIds::height_marker_15_m, ImageIds::height_marker_16_m, ImageIds::height_marker_17_m, ImageIds::height_marker_18_m, ImageIds::height_marker_19_m, ImageIds::height_marker_20_m, ImageIds::height_marker_21_m, ImageIds::height_marker_22_m, ImageIds::height_marker_23_m, ImageIds::height_marker_24_m, ImageIds::height_marker_25_m, ImageIds::height_marker_26_m, ImageIds::height_marker_27_m, ImageIds::height_marker_28_m, ImageIds::height_marker_29_m, ImageIds::height_marker_30_m, ImageIds::height_marker_31_m, ImageIds::height_marker_32_m, ImageIds::height_marker_33_m, ImageIds::height_marker_34_m, ImageIds::height_marker_35_m, ImageIds::height_marker_36_m, ImageIds::height_marker_37_m, ImageIds::height_marker_38_m, ImageIds::height_marker_39_m, ImageIds::height_marker_40_m, ImageIds::height_marker_41_m, ImageIds::height_marker_42_m, ImageIds::height_marker_43_m, ImageIds::height_marker_44_m, ImageIds::height_marker_45_m, ImageIds::height_marker_46_m, ImageIds::height_marker_47_m, ImageIds::height_marker_48_m, ImageIds::height_marker_49_m, ImageIds::height_marker_50_m, ImageIds::height_marker_51_m, ImageIds::height_marker_52_m, ImageIds::height_marker_53_m, ImageIds::height_marker_54_m, ImageIds::height_marker_55_m, ImageIds::height_marker_56_m, ImageIds::height_marker_57_m, ImageIds::height_marker_58_m, ImageIds::height_marker_59_m, ImageIds::height_marker_60_m, ImageIds::height_marker_61_m, ImageIds::height_marker_62_m, ImageIds::height_marker_63_m, ImageIds::height_marker_64_m, ImageIds::height_marker_65_m, ImageIds::height_marker_66_m, ImageIds::height_marker_67_m, ImageIds::height_marker_68_m, ImageIds::height_marker_69_m, ImageIds::height_marker_70_m, ImageIds::height_marker_71_m, ImageIds::height_marker_72_m, ImageIds::height_marker_73_m, ImageIds::height_marker_74_m, ImageIds::height_marker_75_m, ImageIds::height_marker_76_m, ImageIds::height_marker_77_m, ImageIds::height_marker_78_m, ImageIds::height_marker_79_m, ImageIds::height_marker_80_m, ImageIds::height_marker_81_m, ImageIds::height_marker_82_m, ImageIds::height_marker_83_m, ImageIds::height_marker_84_m, ImageIds::height_marker_85_m, ImageIds::height_marker_86_m, ImageIds::height_marker_87_m, ImageIds::height_marker_88_m, ImageIds::height_marker_89_m, ImageIds::height_marker_90_m, ImageIds::height_marker_91_m, ImageIds::height_marker_92_m, ImageIds::height_marker_93_m, ImageIds::height_marker_94_m, ImageIds::height_marker_95_m, ImageIds::height_marker_96_m, ImageIds::height_marker_97_m, ImageIds::height_marker_98_m, ImageIds::height_marker_99_m, ImageIds::height_marker_100_m, ImageIds::height_marker_101_m, ImageIds::height_marker_102_m, ImageIds::height_marker_103_m, ImageIds::height_marker_104_m, ImageIds::height_marker_105_m, ImageIds::height_marker_106_m, ImageIds::height_marker_107_m, ImageIds::height_marker_108_m, ImageIds::height_marker_109_m, ImageIds::height_marker_110_m, ImageIds::height_marker_111_m, ImageIds::height_marker_112_m, ImageIds::height_marker_113_m, ImageIds::height_marker_114_m, ImageIds::height_marker_115_m, ImageIds::height_marker_116_m, ImageIds::height_marker_117_m, ImageIds::height_marker_118_m, ImageIds::height_marker_119_m, ImageIds::height_marker_120_m, ImageIds::height_marker_121_m, ImageIds::height_marker_122_m, ImageIds::height_marker_123_m, ImageIds::height_marker_124_m, ImageIds::height_marker_125_m, ImageIds::height_marker_126_m, ImageIds::height_marker_127_m, }, }; int8_t getTrackDecorationHeightOffset(const bool isFirstTile, const uint8_t trackId) { if (isFirstTile) { return _4F86B4[trackId * 2]; } else { return _4F86B4[trackId * 2 + 1]; } } int8_t getRoadDecorationHeightOffset(const bool isFirstTile, const uint8_t roadId) { if (isFirstTile) { return _4F720C[roadId * 2]; } else { return _4F720C[roadId * 2 + 1]; } } uint32_t getHeightMarkerImage(const coord_t height) { const auto offset = height / World::kMicroZStep - getGameState().seaLevel + 128; return kHeightMarkerImages[Config::get().heightMarkerOffset][offset]; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTileDecorations.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> #include <cstdint> namespace OpenLoco::Paint { // Base height offset for decorations such as direction arrows and height markers int8_t getTrackDecorationHeightOffset(bool isFirstTile, uint8_t trackId); int8_t getRoadDecorationHeightOffset(const bool isFirstTile, const uint8_t roadId); uint32_t getHeightMarkerImage(const coord_t height); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTrack.cpp ```cpp #include "PaintTrack.h" #include "Graphics/Colour.h" #include "Graphics/RenderTarget.h" #include "Logging.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Paint.h" #include "PaintTileDecorations.h" #include "PaintTrackAdditionsData.h" #include "PaintTrackData.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" #include "Ui/WindowManager.h" #include "Viewport.hpp" #include "World/CompanyManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Paint { static loco_global<uint8_t, 0x00522095> _byte_522095; namespace Style0 { static void paintTrackAdditionPPMergeable(PaintSession& session, const World::TrackElement& elTrack, const uint8_t rotation, const ImageId baseImageId, const TrackPaintAdditionPiece& tppa) { const auto height = elTrack.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotListTrackRoad( baseImageId.withIndexOffset(tppa.imageIds[rotation]), 4, heightOffset, tppa.boundingBoxOffsets[rotation] + heightOffset, tppa.boundingBoxSizes[rotation]); } static void paintTrackAdditionPPStandard(PaintSession& session, const World::TrackElement& elTrack, const uint8_t rotation, const ImageId baseImageId, const TrackPaintAdditionPiece& tppa) { const auto height = elTrack.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotListAsChild( baseImageId.withIndexOffset(tppa.imageIds[rotation]), heightOffset, tppa.boundingBoxOffsets[rotation] + heightOffset, tppa.boundingBoxSizes[rotation]); } static void paintTrackAdditionPP(PaintSession& session, const World::TrackElement& elTrack, const uint8_t rotation, const ImageId baseImageId, const TrackPaintAdditionPiece& tppa) { if (tppa.isIsMergeable) { paintTrackAdditionPPMergeable(session, elTrack, rotation, baseImageId, tppa); } else { paintTrackAdditionPPStandard(session, elTrack, rotation, baseImageId, tppa); } } } namespace Style1 { static void paintSupport(PaintSession& session, const TrackAdditionSupport& tppaSupport, const uint8_t rotation, const ImageId baseImageId, int16_t height) { const auto seg = Numerics::bitScanForward(enumValue(tppaSupport.segments[rotation])); assert(seg != -1); TrackRoadAdditionSupports support{}; support.height = height + tppaSupport.height; support.occupiedSegments = session.getOccupiedAdditionSupportSegments(); support.segmentFrequency[seg] = tppaSupport.frequencies[rotation]; support.segmentImages[seg] = baseImageId.withIndexOffset(tppaSupport.imageIds[rotation][0]).toUInt32(); support.segmentInteractionItem[seg] = session.getCurrentItem(); support.segmentInteractionType[seg] = session.getItemType(); session.setAdditionSupport(support); } static void paintTrackAdditionPPMergeable(PaintSession& session, const World::TrackElement& elTrack, const uint8_t rotation, const ImageId baseImageId, const TrackPaintAdditionPiece& tppa) { const auto height = elTrack.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotListTrackRoadAddition( baseImageId.withIndexOffset(tppa.imageIds[rotation]), 0, heightOffset, tppa.boundingBoxOffsets[rotation] + heightOffset, tppa.boundingBoxSizes[rotation]); if (tppa.supports.has_value()) { paintSupport(session, tppa.supports.value(), rotation, baseImageId, height); } } static void paintTrackAdditionPPStandard(PaintSession& session, const World::TrackElement& elTrack, const uint8_t rotation, const ImageId baseImageId, const TrackPaintAdditionPiece& tppa) { const auto height = elTrack.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; session.addToPlotList4FD150( baseImageId.withIndexOffset(tppa.imageIds[rotation]), heightOffset, tppa.boundingBoxOffsets[rotation] + heightOffset, tppa.boundingBoxSizes[rotation]); if (tppa.supports.has_value()) { paintSupport(session, tppa.supports.value(), rotation, baseImageId, height); } } static void paintTrackAdditionPP(PaintSession& session, const World::TrackElement& elTrack, const uint8_t rotation, const ImageId baseImageId, const TrackPaintAdditionPiece& tppa) { // TODO: Better way to detect kNullTrackPaintAdditionPiece if (tppa.imageIds[3] != 0) { if (tppa.isIsMergeable) { paintTrackAdditionPPMergeable(session, elTrack, rotation, baseImageId, tppa); } else { paintTrackAdditionPPStandard(session, elTrack, rotation, baseImageId, tppa); } } } } struct TrackPaintCommon { ImageId trackBaseImageId; // 0x01135F26 with colours and image index set to base of trackObject image table ImageId bridgeColoursBaseImageId; // 0x01135F36 with only the colours set (image index not set!) uint8_t tunnelType; // 0x0113605E }; static void paintTrackPPMergeable(PaintSession& session, const World::TrackElement& elTrack, const TrackPaintCommon& trackSession, const uint8_t rotation, const TrackPaintPiece& tpp) { const auto height = elTrack.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; if (elTrack.hasBridge()) { auto newBridgeEntry = BridgeEntry( height, tpp.bridgeType[rotation], tpp.bridgeEdges[rotation], tpp.bridgeQuarters[rotation], elTrack.bridge(), trackSession.bridgeColoursBaseImageId); // There may be other bridge edge/quarters due to merging so OR them together newBridgeEntry.edgesQuarters |= session.getBridgeEntry().edgesQuarters; session.setBridgeEntry(newBridgeEntry); } const auto baseImage = trackSession.trackBaseImageId; session.addToPlotListTrackRoad( baseImage.withIndexOffset(tpp.imageIndexOffsets[rotation][0]), 0, heightOffset, tpp.boundingBoxOffsets[rotation] + heightOffset, tpp.boundingBoxSizes[rotation]); session.addToPlotListTrackRoad( baseImage.withIndexOffset(tpp.imageIndexOffsets[rotation][1]), 1, heightOffset, tpp.boundingBoxOffsets[rotation] + heightOffset, tpp.boundingBoxSizes[rotation]); session.addToPlotListTrackRoad( baseImage.withIndexOffset(tpp.imageIndexOffsets[rotation][2]), 3, heightOffset, tpp.boundingBoxOffsets[rotation] + heightOffset, tpp.boundingBoxSizes[rotation]); session.insertTunnels(tpp.tunnelHeights[rotation], height, trackSession.tunnelType); session.set525CF8(session.get525CF8() | tpp.segments[rotation]); session.setOccupiedAdditionSupportSegments(session.getOccupiedAdditionSupportSegments() | tpp.segments[rotation]); } static void paintTrackPPStandard(PaintSession& session, const World::TrackElement& elTrack, const TrackPaintCommon& trackSession, const uint8_t rotation, const TrackPaintPiece& tpp) { const auto height = elTrack.baseHeight(); const auto heightOffset = World::Pos3{ 0, 0, height }; if (elTrack.hasBridge()) { auto newBridgeEntry = BridgeEntry( height, tpp.bridgeType[rotation], tpp.bridgeEdges[rotation], tpp.bridgeQuarters[rotation], elTrack.bridge(), trackSession.bridgeColoursBaseImageId); // There may be other bridge edge/quarters due to merging so OR them together newBridgeEntry.edgesQuarters |= session.getBridgeEntry().edgesQuarters; session.setBridgeEntry(newBridgeEntry); } const auto baseImage = trackSession.trackBaseImageId; session.addToPlotList4FD150( baseImage.withIndexOffset(tpp.imageIndexOffsets[rotation][0]), heightOffset, tpp.boundingBoxOffsets[rotation] + heightOffset, tpp.boundingBoxSizes[rotation]); session.insertTunnels(tpp.tunnelHeights[rotation], height, trackSession.tunnelType); session.set525CF8(session.get525CF8() | tpp.segments[rotation]); session.setOccupiedAdditionSupportSegments(session.getOccupiedAdditionSupportSegments() | tpp.segments[rotation]); } static void paintTrackPP(PaintSession& session, const World::TrackElement& elTrack, const TrackPaintCommon& trackSession, const uint8_t rotation, const TrackPaintPiece& tpp) { if (tpp.isMergeable) { paintTrackPPMergeable(session, elTrack, trackSession, rotation, tpp); } else { paintTrackPPStandard(session, elTrack, trackSession, rotation, tpp); } } // 0x0049B6BF void paintTrack(PaintSession& session, const World::TrackElement& elTrack) { if (elTrack.isAiAllocated() && !showAiPlanningGhosts()) { return; } if (elTrack.isGhost() && CompanyManager::getSecondaryPlayerId() != CompanyId::null && CompanyManager::getSecondaryPlayerId() == elTrack.owner()) { return; } const auto height = elTrack.baseZ() * 4; const auto rotation = (session.getRotation() + elTrack.rotation()) & 0x3; if (((session.getViewFlags() & Ui::ViewportFlags::height_marks_on_tracks_roads) != Ui::ViewportFlags::none) && session.getRenderTarget()->zoomLevel == 0) { const bool isLast = elTrack.isFlag6(); const bool isFirstTile = elTrack.sequenceIndex() == 0; if (elTrack.sequenceIndex() == 0 || isLast) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); const auto markerHeight = height + getTrackDecorationHeightOffset(isFirstTile, elTrack.trackId()) + 8; const auto imageId = ImageId{ getHeightMarkerImage(markerHeight), Colour::blue }; const World::Pos3 offset(16, 16, markerHeight); const World::Pos3 bbOffset(1000, 1000, 1087); const World::Pos3 bbSize(1, 1, 0); session.addToPlotListAsParent(imageId, offset, bbOffset, bbSize); } } session.setItemType(Ui::ViewportInteraction::InteractionItem::track); const auto* trackObj = ObjectManager::get<TrackObject>(elTrack.trackObjectId()); // This is an ImageId but it has no image index set! auto baseTrackImageColour = ImageId(0, CompanyManager::getCompanyColour(elTrack.owner())); if (elTrack.isGhost() || elTrack.isAiAllocated()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); baseTrackImageColour = Gfx::applyGhostToImage(0); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } TrackPaintCommon trackSession{ baseTrackImageColour.withIndex(trackObj->image), baseTrackImageColour, trackObj->tunnel }; if (!(*_byte_522095 & (1 << 0))) { if (elTrack.trackId() < kTrackPaintParts.size() && elTrack.sequenceIndex() < kTrackPaintParts[elTrack.trackId()].size()) { auto& parts = kTrackPaintParts[elTrack.trackId()]; auto& tpp = parts[elTrack.sequenceIndex()]; paintTrackPP(session, elTrack, trackSession, rotation, tpp); } else { assert(false); Logging::error("Tried to draw invalid track id or sequence index: TrackId {} SequenceIndex {}", elTrack.trackId(), elTrack.sequenceIndex()); } } if (session.getRenderTarget()->zoomLevel > 0) { return; } session.setItemType(Ui::ViewportInteraction::InteractionItem::trackExtra); const auto ghostMods = Ui::Windows::Construction::getLastSelectedMods(); for (auto mod = 0; mod < 4; ++mod) { const auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[mod]); ImageId trackExtraBaseImage{}; if (elTrack.hasMod(mod)) { trackExtraBaseImage = baseTrackImageColour.withIndex(trackExtraObj->image); } else if (elTrack.hasGhostMods() && ghostMods & (1 << mod)) { trackExtraBaseImage = Gfx::applyGhostToImage(trackExtraObj->image); } else { continue; } session.setTrackModId(mod); const auto paintStyle = trackExtraObj->paintStyle; if (paintStyle == 0 && elTrack.trackId() < Style0::kTrackPaintAdditionParts.size() && elTrack.sequenceIndex() < Style0::kTrackPaintAdditionParts[elTrack.trackId()].size()) { auto& parts = Style0::kTrackPaintAdditionParts[elTrack.trackId()]; auto& tppa = parts[elTrack.sequenceIndex()]; Style0::paintTrackAdditionPP(session, elTrack, rotation, trackExtraBaseImage, tppa); } else if (paintStyle == 1 && elTrack.trackId() < Style1::kTrackPaintAdditionParts.size() && elTrack.sequenceIndex() < Style1::kTrackPaintAdditionParts[elTrack.trackId()].size()) { auto& parts = Style1::kTrackPaintAdditionParts[elTrack.trackId()]; auto& tppa = parts[elTrack.sequenceIndex()]; Style1::paintTrackAdditionPP(session, elTrack, rotation, trackExtraBaseImage, tppa); } else { assert(false); Logging::error("Tried to draw invalid track id or sequence index: TrackId {} SequenceIndex {}", elTrack.trackId(), elTrack.sequenceIndex()); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTrack.h ```h #pragma once namespace OpenLoco::World { struct TrackElement; } namespace OpenLoco::Paint { struct PaintSession; void paintTrack(PaintSession& session, const World::TrackElement& elTrack); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTrackAdditionsData.h ```h #pragma once #include "Objects/TrackExtraObject.h" #include "Paint.h" #include <OpenLoco/Core/Numerics.hpp> #include <array> #include <optional> #include <span> namespace OpenLoco::Paint { namespace Style0 { struct TrackPaintAdditionPiece { std::array<uint32_t, 4> imageIds; std::array<World::Pos3, 4> boundingBoxOffsets; std::array<World::Pos3, 4> boundingBoxSizes; bool isIsMergeable; }; constexpr std::array<uint8_t, 4> kRotationTable1230 = { 1, 2, 3, 0 }; constexpr std::array<uint8_t, 4> kRotationTable2301 = { 2, 3, 0, 1 }; constexpr std::array<uint8_t, 4> kRotationTable3012 = { 3, 0, 1, 2 }; consteval TrackPaintAdditionPiece rotateTrackPPA(const TrackPaintAdditionPiece& reference, const std::array<uint8_t, 4>& rotationTable) { return TrackPaintAdditionPiece{ std::array<uint32_t, 4>{ reference.imageIds[rotationTable[0]], reference.imageIds[rotationTable[1]], reference.imageIds[rotationTable[2]], reference.imageIds[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxOffsets[rotationTable[0]], reference.boundingBoxOffsets[rotationTable[1]], reference.boundingBoxOffsets[rotationTable[2]], reference.boundingBoxOffsets[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxSizes[rotationTable[0]], reference.boundingBoxSizes[rotationTable[1]], reference.boundingBoxSizes[rotationTable[2]], reference.boundingBoxSizes[rotationTable[3]], }, reference.isIsMergeable }; } using namespace OpenLoco::TrackExtraObj::ImageIds::Style0; // 0x0041DDCD, 0x0041DE0C, 0x0041DE4B, 0x0041DE8A constexpr TrackPaintAdditionPiece kStraightAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0SW, kStraight0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 1> kStraightTPPA = { kStraightAddition0, }; // 0x00420ED5, 0x00420FDD, 0x004210E5, 0x004211ED constexpr TrackPaintAdditionPiece kDiagonalAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal0NE, kDiagonal0SE, kDiagonal0SW, kDiagonal0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, }; // 0x00420F17, 0x0042101F, 0x00421127, 0x0042122F constexpr TrackPaintAdditionPiece kDiagonalAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal1NE, kDiagonal1SE, kDiagonal1SW, kDiagonal1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x00420F59, 0x00421061, 0x00421169, 0x00421271 constexpr TrackPaintAdditionPiece kDiagonalAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal2NE, kDiagonal2SE, kDiagonal2SW, kDiagonal2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x00420F9B, 0x004210A3, 0x004211AB, 0x004212B3 constexpr TrackPaintAdditionPiece kDiagonalAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal3NE, kDiagonal3SE, kDiagonal3SW, kDiagonal3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 4> kDiagonalTPPA = { kDiagonalAddition0, kDiagonalAddition1, kDiagonalAddition2, kDiagonalAddition3, }; // 0x0041E3F1, 0x0041E433, 0x0041E475, 0x0041E4B7 constexpr TrackPaintAdditionPiece kRightCurveVerySmallAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveVerySmall0NE, kRightCurveVerySmall0SE, kRightCurveVerySmall0SW, kRightCurveVerySmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 1> kRightCurveVerySmallTPPA = { kRightCurveVerySmallAddition0, }; constexpr TrackPaintAdditionPiece kLeftCurveVerySmallAddition0 = rotateTrackPPA(kRightCurveVerySmallAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 1> kLeftCurveVerySmallTPPA = { kLeftCurveVerySmallAddition0, }; // 0x0041E849, 0x0041E945, 0x0041EA41, 0x0041EB3D constexpr TrackPaintAdditionPiece kRightCurveSmallAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall0NE, kRightCurveSmall0SE, kRightCurveSmall0SW, kRightCurveSmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ true, }; // 0x0041E888, 0x0041E984, 0x0041EA80, 0x0041EB7C constexpr TrackPaintAdditionPiece kRightCurveSmallAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall1NE, kRightCurveSmall1SE, kRightCurveSmall1SW, kRightCurveSmall1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x0041E8C7, 0x0041E9C3, 0x0041EABF, 0x0041EBBB constexpr TrackPaintAdditionPiece kRightCurveSmallAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall2NE, kRightCurveSmall2SE, kRightCurveSmall2SW, kRightCurveSmall2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x0041E906, 0x0041EA02, 0x0041EAFE, 0x0041EBFA constexpr TrackPaintAdditionPiece kRightCurveSmallAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall3NE, kRightCurveSmall3SE, kRightCurveSmall3SW, kRightCurveSmall3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallTPPA = { kRightCurveSmallAddition0, kRightCurveSmallAddition1, kRightCurveSmallAddition2, kRightCurveSmallAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition0 = rotateTrackPPA(kRightCurveSmallAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition1 = rotateTrackPPA(kRightCurveSmallAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition2 = rotateTrackPPA(kRightCurveSmallAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition3 = rotateTrackPPA(kRightCurveSmallAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallTPPA = { kLeftCurveSmallAddition0, kLeftCurveSmallAddition1, kLeftCurveSmallAddition2, kLeftCurveSmallAddition3, }; // 0x0041FF0D, 0x00420048, 0x00420183, 0x004202BE constexpr TrackPaintAdditionPiece kRightCurveAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve0NE, kRightCurve0SE, kRightCurve0SW, kRightCurve0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ true, }; // 0x0041FF4C, 0x00420087, 0x004201C2, 0x004202FD constexpr TrackPaintAdditionPiece kRightCurveAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1NE, kRightCurve1SE, kRightCurve1SW, kRightCurve1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* Mergeable */ true, }; // 0x0041FF8B, 0x004200C6, 0x00420201, 0x0042033C constexpr TrackPaintAdditionPiece kRightCurveAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve2NE, kRightCurve2SE, kRightCurve2SW, kRightCurve2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x0041FFCA, 0x00420105, 0x00420240, 0x0042037B constexpr TrackPaintAdditionPiece kRightCurveAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve3NE, kRightCurve3SE, kRightCurve3SW, kRightCurve3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, }, /* Mergeable */ true, }; // 0x00420009, 0x00420144, 0x0042027F, 0x004203BA constexpr TrackPaintAdditionPiece kRightCurveAddition4 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve4NE, kRightCurve4SE, kRightCurve4SW, kRightCurve4NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 5> kRightCurveTPPA = { kRightCurveAddition0, kRightCurveAddition1, kRightCurveAddition2, kRightCurveAddition3, kRightCurveAddition4, }; constexpr TrackPaintAdditionPiece kLeftCurveAddition0 = rotateTrackPPA(kRightCurveAddition4, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition1 = rotateTrackPPA(kRightCurveAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition2 = rotateTrackPPA(kRightCurveAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition3 = rotateTrackPPA(kRightCurveAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition4 = rotateTrackPPA(kRightCurveAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 5> kLeftCurveTPPA = { kLeftCurveAddition0, kLeftCurveAddition1, kLeftCurveAddition2, kLeftCurveAddition3, kLeftCurveAddition4, }; // 0x00420991, 0x00420ADB, 0x00420C25, 0x00420D6F constexpr TrackPaintAdditionPiece kRightCurveLargeAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveLarge0NE, kRightCurveLarge0SE, kRightCurveLarge0SW, kRightCurveLarge0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, }; // 0x004209D3, 0x00420B1D, 0x00420C67, 0x00420DB1 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveLarge1NE, kRightCurveLarge1SE, kRightCurveLarge1SW, kRightCurveLarge1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* Mergeable */ true, }; // 0x00420A15, 0x00420B5F, 0x00420CA9, 0x00420DF3 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveLarge2NE, kRightCurveLarge2SE, kRightCurveLarge2SW, kRightCurveLarge2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x00420A57, 0x00420BA1, 0x00420CEB, 0x00420E35 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveLarge3NE, kRightCurveLarge3SE, kRightCurveLarge3SW, kRightCurveLarge3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x00420A99, 0x00420BE3, 0x00420D2D, 0x00420E77 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition4 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveLarge4NE, kRightCurveLarge4SE, kRightCurveLarge4SW, kRightCurveLarge4NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 5> kRightCurveLargeTPPA = { kRightCurveLargeAddition0, kRightCurveLargeAddition1, kRightCurveLargeAddition2, kRightCurveLargeAddition3, kRightCurveLargeAddition4, }; // 0x00420469, 0x004205B3, 0x004206FD, 0x00420847 constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kLeftCurveLarge0NE, kLeftCurveLarge0SE, kLeftCurveLarge0SW, kLeftCurveLarge0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, }; // 0x004204AB, 0x004205F5, 0x0042073F, 0x00420889 constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kLeftCurveLarge1NE, kLeftCurveLarge1SE, kLeftCurveLarge1SW, kLeftCurveLarge1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* Mergeable */ true, }; // 0x004204ED, 0x00420637, 0x00420781, 0x004208CB constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kLeftCurveLarge2NE, kLeftCurveLarge2SE, kLeftCurveLarge2SW, kLeftCurveLarge2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x0042052F, 0x00420679, 0x004207C3, 0x0042090D constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kLeftCurveLarge3NE, kLeftCurveLarge3SE, kLeftCurveLarge3SW, kLeftCurveLarge3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, }; // 0x00420571, 0x004206BB, 0x00420805, 0x0042094F constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition4 = { /* ImageIds */ std::array<uint32_t, 4>{ kLeftCurveLarge4NE, kLeftCurveLarge4SE, kLeftCurveLarge4SW, kLeftCurveLarge4NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 5> kLeftCurveLargeTPPA = { kLeftCurveLargeAddition0, kLeftCurveLargeAddition1, kLeftCurveLargeAddition2, kLeftCurveLargeAddition3, kLeftCurveLargeAddition4, }; constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition0 = rotateTrackPPA(kLeftCurveLargeAddition4, kRotationTable3012); constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition1 = rotateTrackPPA(kLeftCurveLargeAddition2, kRotationTable3012); constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition2 = rotateTrackPPA(kLeftCurveLargeAddition3, kRotationTable3012); constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition3 = rotateTrackPPA(kLeftCurveLargeAddition1, kRotationTable3012); constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition4 = rotateTrackPPA(kLeftCurveLargeAddition0, kRotationTable3012); constexpr std::array<TrackPaintAdditionPiece, 5> kDiagonalRightCurveLargeTPPA = { kDiagonalRightCurveLargeAddition0, kDiagonalRightCurveLargeAddition1, kDiagonalRightCurveLargeAddition2, kDiagonalRightCurveLargeAddition3, kDiagonalRightCurveLargeAddition4, }; constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition0 = rotateTrackPPA(kRightCurveLargeAddition4, kRotationTable2301); constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition1 = rotateTrackPPA(kRightCurveLargeAddition2, kRotationTable2301); constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition2 = rotateTrackPPA(kRightCurveLargeAddition3, kRotationTable2301); constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition3 = rotateTrackPPA(kRightCurveLargeAddition1, kRotationTable2301); constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition4 = rotateTrackPPA(kRightCurveLargeAddition0, kRotationTable2301); constexpr std::array<TrackPaintAdditionPiece, 5> kDiagonalLeftCurveLargeTPPA = { kDiagonalLeftCurveLargeAddition0, kDiagonalLeftCurveLargeAddition1, kDiagonalLeftCurveLargeAddition2, kDiagonalLeftCurveLargeAddition3, kDiagonalLeftCurveLargeAddition4, }; // 0x004216AD, 0x004217A9, 0x00421962, 0x00421A5E constexpr TrackPaintAdditionPiece kSBendLeftAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendLeft0NE, kSBendLeft0SE, kSBendLeft0SW, kSBendLeft0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, }; // 0x004216EC, 0x004217E8, 0x00421923, 0x00421A1F constexpr TrackPaintAdditionPiece kSBendLeftAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendLeft1NE, kSBendLeft1SE, kSBendLeft1SW, kSBendLeft1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 24, 1 }, World::Pos3{ 24, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, }; // 0x0042172B, 0x00421827, 0x004218E4, 0x004219E0 constexpr TrackPaintAdditionPiece kSBendLeftAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendLeft2NE, kSBendLeft2SE, kSBendLeft2SW, kSBendLeft2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 24, 1 }, World::Pos3{ 24, 28, 1 }, }, /* Mergeable */ true, }; // 0x0042176A, 0x00421866, 0x004218A5, 0x004219A1 constexpr TrackPaintAdditionPiece kSBendLeftAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendLeft3NE, kSBendLeft3SE, kSBendLeft3SW, kSBendLeft3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 4> kSBendLeftTPPA = { kSBendLeftAddition0, kSBendLeftAddition1, kSBendLeftAddition2, kSBendLeftAddition3, }; // 0x00421A9D, 0x00421B99, 0x00421D52, 0x00421E4E constexpr TrackPaintAdditionPiece kSBendRightAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendRight0NE, kSBendRight0SE, kSBendRight0SW, kSBendRight0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, }; // 0x00421ADC, 0x00421BD8, 0x00421D13, 0x00421E0F constexpr TrackPaintAdditionPiece kSBendRightAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendRight1NE, kSBendRight1SE, kSBendRight1SW, kSBendRight1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 0, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 24, 28, 1 }, }, /* Mergeable */ true, }; // 0x00421B1B, 0x00421C17, 0x00421CD4, 0x00421DD0 constexpr TrackPaintAdditionPiece kSBendRightAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendRight2NE, kSBendRight2SE, kSBendRight2SW, kSBendRight2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 0, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 24, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, }; // 0x00421B5A, 0x00421C56, 0x00421C95, 0x00421D91 constexpr TrackPaintAdditionPiece kSBendRightAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kSBendRight3NE, kSBendRight3SE, kSBendRight3SW, kSBendRight3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, }; constexpr std::array<TrackPaintAdditionPiece, 4> kSBendRightTPPA = { kSBendRightAddition0, kSBendRightAddition1, kSBendRightAddition2, kSBendRightAddition3, }; // 0x0042132D, 0x004213B9, 0x00421445, 0x004214D1 constexpr TrackPaintAdditionPiece kStraightSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSlopeUp0NE, kStraightSlopeUp0SE, kStraightSlopeUp0SW, kStraightSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; // 0x00421373, 0x004213FF, 0x0042148B, 0x00421517 constexpr TrackPaintAdditionPiece kStraightSlopeUpAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSlopeUp1NE, kStraightSlopeUp1SE, kStraightSlopeUp1SW, kStraightSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; constexpr std::array<TrackPaintAdditionPiece, 2> kStraightSlopeUpTPPA = { kStraightSlopeUpAddition0, kStraightSlopeUpAddition1, }; constexpr TrackPaintAdditionPiece kStraightSlopeDownAddition0 = rotateTrackPPA(kStraightSlopeUpAddition1, kRotationTable2301); constexpr TrackPaintAdditionPiece kStraightSlopeDownAddition1 = rotateTrackPPA(kStraightSlopeUpAddition0, kRotationTable2301); constexpr std::array<TrackPaintAdditionPiece, 2> kStraightSlopeDownTPPA = { kStraightSlopeDownAddition0, kStraightSlopeDownAddition1, }; // 0x0042155D, 0x004215A3, 0x004215E9, 0x0042162F constexpr TrackPaintAdditionPiece kStraightSteepSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSteepSlopeUp0NE, kStraightSteepSlopeUp0SE, kStraightSteepSlopeUp0SW, kStraightSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; constexpr std::array<TrackPaintAdditionPiece, 1> kStraightSteepSlopeUpTPPA = { kStraightSteepSlopeUpAddition0, }; constexpr TrackPaintAdditionPiece kStraightSteepSlopeDownAddition0 = rotateTrackPPA(kStraightSteepSlopeUpAddition0, kRotationTable2301); constexpr std::array<TrackPaintAdditionPiece, 1> kStraightSteepSlopeDownTPPA = { kStraightSteepSlopeDownAddition0, }; // 0x0041ECA9, 0x0041EDC1, 0x0041EED9, 0x0041EFF1 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeUp0NE, kRightCurveSmallSlopeUp0SE, kRightCurveSmallSlopeUp0SW, kRightCurveSmallSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; // 0x0041ECEF, 0x0041EE07, 0x0041EF1F, 0x0041F037 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeUp1NE, kRightCurveSmallSlopeUp1SE, kRightCurveSmallSlopeUp1SW, kRightCurveSmallSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041ED35, 0x0041EE4D, 0x0041EF65, 0x0041F07D constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeUp2NE, kRightCurveSmallSlopeUp2SE, kRightCurveSmallSlopeUp2SW, kRightCurveSmallSlopeUp2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041ED7B, 0x0041EE93, 0x0041EFAB, 0x0041F0C3 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeUp3NE, kRightCurveSmallSlopeUp3SE, kRightCurveSmallSlopeUp3SW, kRightCurveSmallSlopeUp3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSlopeUpTPPA = { kRightCurveSmallSlopeUpAddition0, kRightCurveSmallSlopeUpAddition1, kRightCurveSmallSlopeUpAddition2, kRightCurveSmallSlopeUpAddition3, }; // 0x0041F109, 0x0041F221, 0x0041F339, 0x0041F451 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeDown0NE, kRightCurveSmallSlopeDown0SE, kRightCurveSmallSlopeDown0SW, kRightCurveSmallSlopeDown0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; // 0x0041F14F, 0x0041F267, 0x0041F37F, 0x0041F497 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeDown1NE, kRightCurveSmallSlopeDown1SE, kRightCurveSmallSlopeDown1SW, kRightCurveSmallSlopeDown1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041F195, 0x0041F2AD, 0x0041F3C5, 0x0041F4DD constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeDown2NE, kRightCurveSmallSlopeDown2SE, kRightCurveSmallSlopeDown2SW, kRightCurveSmallSlopeDown2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041F1DB, 0x0041F2F3, 0x0041F40B, 0x0041F523 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeDown3NE, kRightCurveSmallSlopeDown3SE, kRightCurveSmallSlopeDown3SW, kRightCurveSmallSlopeDown3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSlopeDownTPPA = { kRightCurveSmallSlopeDownAddition0, kRightCurveSmallSlopeDownAddition1, kRightCurveSmallSlopeDownAddition2, kRightCurveSmallSlopeDownAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition0 = rotateTrackPPA(kRightCurveSmallSlopeDownAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition1 = rotateTrackPPA(kRightCurveSmallSlopeDownAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition2 = rotateTrackPPA(kRightCurveSmallSlopeDownAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition3 = rotateTrackPPA(kRightCurveSmallSlopeDownAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSlopeUpTPPA = { kLeftCurveSmallSlopeUpAddition0, kLeftCurveSmallSlopeUpAddition1, kLeftCurveSmallSlopeUpAddition2, kLeftCurveSmallSlopeUpAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition0 = rotateTrackPPA(kRightCurveSmallSlopeUpAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition1 = rotateTrackPPA(kRightCurveSmallSlopeUpAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition2 = rotateTrackPPA(kRightCurveSmallSlopeUpAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition3 = rotateTrackPPA(kRightCurveSmallSlopeUpAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSlopeDownTPPA = { kLeftCurveSmallSlopeDownAddition0, kLeftCurveSmallSlopeDownAddition1, kLeftCurveSmallSlopeDownAddition2, kLeftCurveSmallSlopeDownAddition3, }; // 0x0041F5D9, 0x0041F6F1, 0x0041F809, 0x0041F921 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeUp0NE, kRightCurveSmallSteepSlopeUp0SE, kRightCurveSmallSteepSlopeUp0SW, kRightCurveSmallSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; // 0x0041F61F, 0x0041F737, 0x0041F84F, 0x0041F96A constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeUp1NE, kRightCurveSmallSteepSlopeUp1SE, kRightCurveSmallSteepSlopeUp1SW, kRightCurveSmallSteepSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041F665, 0x0041F77D, 0x0041F895, 0x0041F9B3 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeUp2NE, kRightCurveSmallSteepSlopeUp2SE, kRightCurveSmallSteepSlopeUp2SW, kRightCurveSmallSteepSlopeUp2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041F6AB, 0x0041F7C3, 0x0041F8DB, 0x0041F9FC constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeUp3NE, kRightCurveSmallSteepSlopeUp3SE, kRightCurveSmallSteepSlopeUp3SW, kRightCurveSmallSteepSlopeUp3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSteepSlopeUpTPPA = { kRightCurveSmallSteepSlopeUpAddition0, kRightCurveSmallSteepSlopeUpAddition1, kRightCurveSmallSteepSlopeUpAddition2, kRightCurveSmallSteepSlopeUpAddition3, }; // 0x0041FA45, 0x0041FB69, 0x0041FC8D, 0x0041FDB1 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeDown0NE, kRightCurveSmallSteepSlopeDown0SE, kRightCurveSmallSteepSlopeDown0SW, kRightCurveSmallSteepSlopeDown0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, }; // 0x0041FA8E, 0x0041FBB2, 0x0041FCD6, 0x0041FDFA constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeDown1NE, kRightCurveSmallSteepSlopeDown1SE, kRightCurveSmallSteepSlopeDown1SW, kRightCurveSmallSteepSlopeDown1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041FAD7, 0x0041FBFB, 0x0041FD1F, 0x0041FE43 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeDown2NE, kRightCurveSmallSteepSlopeDown2SE, kRightCurveSmallSteepSlopeDown2SW, kRightCurveSmallSteepSlopeDown2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ false, }; // 0x0041FB20, 0x0041FC44, 0x0041FD68, 0x0041FE8C constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeDown3NE, kRightCurveSmallSteepSlopeDown3SE, kRightCurveSmallSteepSlopeDown3SW, kRightCurveSmallSteepSlopeDown3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSteepSlopeDownTPPA = { kRightCurveSmallSteepSlopeDownAddition0, kRightCurveSmallSteepSlopeDownAddition1, kRightCurveSmallSteepSlopeDownAddition2, kRightCurveSmallSteepSlopeDownAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition0 = rotateTrackPPA(kRightCurveSmallSteepSlopeDownAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition1 = rotateTrackPPA(kRightCurveSmallSteepSlopeDownAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition2 = rotateTrackPPA(kRightCurveSmallSteepSlopeDownAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition3 = rotateTrackPPA(kRightCurveSmallSteepSlopeDownAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSteepSlopeUpTPPA = { kLeftCurveSmallSteepSlopeUpAddition0, kLeftCurveSmallSteepSlopeUpAddition1, kLeftCurveSmallSteepSlopeUpAddition2, kLeftCurveSmallSteepSlopeUpAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition0 = rotateTrackPPA(kRightCurveSmallSteepSlopeUpAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition1 = rotateTrackPPA(kRightCurveSmallSteepSlopeUpAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition2 = rotateTrackPPA(kRightCurveSmallSteepSlopeUpAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition3 = rotateTrackPPA(kRightCurveSmallSteepSlopeUpAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSteepSlopeDownTPPA = { kLeftCurveSmallSteepSlopeDownAddition0, kLeftCurveSmallSteepSlopeDownAddition1, kLeftCurveSmallSteepSlopeDownAddition2, kLeftCurveSmallSteepSlopeDownAddition3, }; constexpr std::array<std::span<const TrackPaintAdditionPiece>, 26> kTrackPaintAdditionParts = { kStraightTPPA, kDiagonalTPPA, kLeftCurveVerySmallTPPA, kRightCurveVerySmallTPPA, kLeftCurveSmallTPPA, kRightCurveSmallTPPA, kLeftCurveTPPA, kRightCurveTPPA, kLeftCurveLargeTPPA, kRightCurveLargeTPPA, kDiagonalLeftCurveLargeTPPA, kDiagonalRightCurveLargeTPPA, kSBendLeftTPPA, kSBendRightTPPA, kStraightSlopeUpTPPA, kStraightSlopeDownTPPA, kStraightSteepSlopeUpTPPA, kStraightSteepSlopeDownTPPA, kLeftCurveSmallSlopeUpTPPA, kRightCurveSmallSlopeUpTPPA, kLeftCurveSmallSlopeDownTPPA, kRightCurveSmallSlopeDownTPPA, kLeftCurveSmallSteepSlopeUpTPPA, kRightCurveSmallSteepSlopeUpTPPA, kLeftCurveSmallSteepSlopeDownTPPA, kRightCurveSmallSteepSlopeDownTPPA, }; } namespace Style1 { struct TrackAdditionSupport { std::array<std::array<uint32_t, 2>, 4> imageIds; int16_t height; std::array<uint8_t, 4> frequencies; // Make array std::array<SegmentFlags, 4> segments; // Make array constexpr TrackAdditionSupport( const std::array<std::array<uint32_t, 2>, 4>& _imageIds, const int16_t _height, const std::array<uint8_t, 4>& _frequencies, const std::array<SegmentFlags, 4>& _segments) : imageIds(_imageIds) , height(_height) , frequencies(_frequencies) , segments(_segments) { } constexpr TrackAdditionSupport( const std::array<std::array<uint32_t, 2>, 4>& _imageIds, const int16_t _height, const uint8_t _frequency, const SegmentFlags _segment) : imageIds(_imageIds) , height(_height) , frequencies() , segments() { frequencies[0] = _frequency; frequencies[1] = Numerics::rotl4bit(frequencies[0], 2); frequencies[2] = frequencies[0]; frequencies[3] = frequencies[1]; segments[0] = _segment; for (auto i = 1U; i < 4; ++i) { segments[i] = rotlSegmentFlags(segments[0], i); } } }; struct TrackPaintAdditionPiece { std::array<uint32_t, 4> imageIds; std::array<World::Pos3, 4> boundingBoxOffsets; std::array<World::Pos3, 4> boundingBoxSizes; bool isIsMergeable; std::optional<TrackAdditionSupport> supports; }; constexpr std::array<uint8_t, 4> kRotationTable1230 = { 1, 2, 3, 0 }; constexpr std::array<uint8_t, 4> kRotationTable2301 = { 2, 3, 0, 1 }; constexpr std::array<uint8_t, 4> kRotationTable3012 = { 3, 0, 1, 2 }; constexpr TrackPaintAdditionPiece kNullTrackPaintAdditionPiece = {}; constexpr auto kNoSupports = std::nullopt; consteval std::optional<TrackAdditionSupport> rotateTrackPPASupport(const std::optional<TrackAdditionSupport>& reference, const std::array<uint8_t, 4>& rotationTable) { if (!reference.has_value()) { return std::nullopt; } return TrackAdditionSupport{ std::array<std::array<uint32_t, 2>, 4>{ reference->imageIds[rotationTable[0]], reference->imageIds[rotationTable[1]], reference->imageIds[rotationTable[2]], reference->imageIds[rotationTable[3]], }, reference->height, std::array<uint8_t, 4>{ reference->frequencies[rotationTable[0]], reference->frequencies[rotationTable[1]], reference->frequencies[rotationTable[2]], reference->frequencies[rotationTable[3]], }, std::array<SegmentFlags, 4>{ reference->segments[rotationTable[0]], reference->segments[rotationTable[1]], reference->segments[rotationTable[2]], reference->segments[rotationTable[3]], } }; } consteval TrackPaintAdditionPiece rotateTrackPPA(const TrackPaintAdditionPiece& reference, const std::array<uint8_t, 4>& rotationTable) { return TrackPaintAdditionPiece{ std::array<uint32_t, 4>{ reference.imageIds[rotationTable[0]], reference.imageIds[rotationTable[1]], reference.imageIds[rotationTable[2]], reference.imageIds[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxOffsets[rotationTable[0]], reference.boundingBoxOffsets[rotationTable[1]], reference.boundingBoxOffsets[rotationTable[2]], reference.boundingBoxOffsets[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxSizes[rotationTable[0]], reference.boundingBoxSizes[rotationTable[1]], reference.boundingBoxSizes[rotationTable[2]], reference.boundingBoxSizes[rotationTable[3]], }, reference.isIsMergeable, rotateTrackPPASupport(reference.supports, rotationTable) }; } using namespace OpenLoco::TrackExtraObj::ImageIds::Style1; // 0x00421E91, 0x00421F0D, 0x00421F89, 0x00422005 constexpr TrackPaintAdditionPiece kStraightAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 5, 26 }, World::Pos3{ 5, 2, 26 }, World::Pos3{ 2, 5, 26 }, World::Pos3{ 5, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 0, /* Frequency */ 2, /* Segment */ SegmentFlags::x1y0, }, }; constexpr std::array<TrackPaintAdditionPiece, 1> kStraightTPPA = { kStraightAddition0, }; // 0x00425229, 0x004252B9, 0x00425349, 0x004253D9 constexpr TrackPaintAdditionPiece kDiagonalAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal0NE, kDiagonal0SE, kDiagonal0SW, kDiagonal0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr TrackPaintAdditionPiece kDiagonalAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kDiagonalAddition2 = kNullTrackPaintAdditionPiece; // 0x00425272, 0x00425302, 0x00425392, 0x00425422 constexpr TrackPaintAdditionPiece kDiagonalAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal0SW, kDiagonal0NW, kDiagonal0NE, kDiagonal0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 4> kDiagonalTPPA = { kDiagonalAddition0, kDiagonalAddition1, kDiagonalAddition2, kDiagonalAddition3, }; // 0x004226E1, 0x00422728, 0x0042276F, 0x004227B6 constexpr TrackPaintAdditionPiece kRightCurveVerySmallAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveVerySmall0NE, kRightCurveVerySmall0SE, kRightCurveVerySmall0SW, kRightCurveVerySmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 1> kRightCurveVerySmallTPPA = { kRightCurveVerySmallAddition0, }; constexpr TrackPaintAdditionPiece kLeftCurveVerySmallAddition0 = rotateTrackPPA(kRightCurveVerySmallAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 1> kLeftCurveVerySmallTPPA = { kLeftCurveVerySmallAddition0, }; // 0x00422B89, 0x00422C83, 0x00422D7D, 0x00422E77 constexpr TrackPaintAdditionPiece kRightCurveSmallAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall0NE, kRightCurveSmall0SE, kRightCurveSmall0SW, kRightCurveSmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0, }, }; constexpr TrackPaintAdditionPiece kRightCurveSmallAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kRightCurveSmallAddition2 = kNullTrackPaintAdditionPiece; // 0x00422C07, 0x00422D01, 0x00422DFB, 0x00422EF5 constexpr TrackPaintAdditionPiece kRightCurveSmallAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall3NE, kRightCurveSmall3SE, kRightCurveSmall3SW, kRightCurveSmall3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y1, }, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallTPPA = { kRightCurveSmallAddition0, kRightCurveSmallAddition1, kRightCurveSmallAddition2, kRightCurveSmallAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition0 = rotateTrackPPA(kRightCurveSmallAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallAddition3 = rotateTrackPPA(kRightCurveSmallAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallTPPA = { kLeftCurveSmallAddition0, kLeftCurveSmallAddition1, kLeftCurveSmallAddition2, kLeftCurveSmallAddition3, }; // 0x00424209, 0x004243D6, 0x004245A3, 0x00424770 constexpr TrackPaintAdditionPiece kRightCurveAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; // 0x00424250, 0x0042441D, 0x004245EA, 0x004247B7 constexpr TrackPaintAdditionPiece kRightCurveAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1NE, kRightCurve1SE, kRightCurve1SW, kRightCurve1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 26 }, World::Pos3{ 16, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportRightCurve1NE, kSupportConnectorRightCurve1NE }, std::array<uint32_t, 2>{ kSupportRightCurve1SE, kSupportConnectorRightCurve1SE }, std::array<uint32_t, 2>{ kSupportRightCurve1SW, kSupportConnectorRightCurve1SW }, std::array<uint32_t, 2>{ kSupportRightCurve1NW, kSupportConnectorRightCurve1NW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x2y0, }, }; // 0x004242CC, 0x00424499, 0x00424666, 0x00424833 constexpr TrackPaintAdditionPiece kRightCurveAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1SW, kRightCurve1NW, kRightCurve1NE, kRightCurve1SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 16, 26 }, World::Pos3{ 16, 16, 26 }, World::Pos3{ 16, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; // 0x00424313, 0x004244E0, 0x004246AD, 0x0042487A constexpr TrackPaintAdditionPiece kRightCurveAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1NE, kRightCurve1SE, kRightCurve1SW, kRightCurve1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 16, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportRightCurve3NE, kSupportConnectorRightCurve3NE }, std::array<uint32_t, 2>{ kSupportRightCurve3SE, kSupportConnectorRightCurve3SE }, std::array<uint32_t, 2>{ kSupportRightCurve3SW, kSupportConnectorRightCurve3SW }, std::array<uint32_t, 2>{ kSupportRightCurve3NW, kSupportConnectorRightCurve3NW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y2, }, }; // 0x0042438F, 0x0042455C, 0x00424729, 0x004248F6 constexpr TrackPaintAdditionPiece kRightCurveAddition4 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0SE, kStraight0NE, kStraight0SE, kStraight0NE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 6, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 5> kRightCurveTPPA = { kRightCurveAddition0, kRightCurveAddition1, kRightCurveAddition2, kRightCurveAddition3, kRightCurveAddition4, }; constexpr TrackPaintAdditionPiece kLeftCurveAddition0 = rotateTrackPPA(kRightCurveAddition4, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition1 = rotateTrackPPA(kRightCurveAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition2 = rotateTrackPPA(kRightCurveAddition2, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition3 = rotateTrackPPA(kRightCurveAddition1, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveAddition4 = rotateTrackPPA(kRightCurveAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 5> kLeftCurveTPPA = { kLeftCurveAddition0, kLeftCurveAddition1, kLeftCurveAddition2, kLeftCurveAddition3, kLeftCurveAddition4, }; // 0x00424DDD, 0x00424EE9, 0x00424FF5, 0x00425101 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 3, 26 }, World::Pos3{ 3, 2, 26 }, World::Pos3{ 2, 3, 26 }, World::Pos3{ 3, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; // 0x00424E24, 0x00424F30, 0x0042503C, 0x00425148 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall0NE, kRightCurveSmall0SE, kRightCurveSmall0SW, kRightCurveSmall0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 26 }, World::Pos3{ 16, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0, }, }; constexpr TrackPaintAdditionPiece kRightCurveLargeAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kRightCurveLargeAddition3 = kNullTrackPaintAdditionPiece; // 0x00424EA2, 0x00424FAE, 0x004250BA, 0x004251C6 constexpr TrackPaintAdditionPiece kRightCurveLargeAddition4 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal0SW, kDiagonal0NW, kDiagonal0NE, kDiagonal0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 5> kRightCurveLargeTPPA = { kRightCurveLargeAddition0, kRightCurveLargeAddition1, kRightCurveLargeAddition2, kRightCurveLargeAddition3, kRightCurveLargeAddition4, }; // 0x004249AD, 0x00424AB9, 0x00424BC5, 0x00424CD1 constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 3, 26 }, World::Pos3{ 3, 2, 26 }, World::Pos3{ 2, 3, 26 }, World::Pos3{ 3, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; // 0x004249F4, 0x00424B00, 0x00424C0C, 0x00424D18 constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmall3SE, kRightCurveSmall3SW, kRightCurveSmall3NW, kRightCurveSmall3NE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 16, 26 }, World::Pos3{ 16, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y2, }, }; constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition3 = kNullTrackPaintAdditionPiece; // 0x00424A72, 0x00424B7E, 0x00424C8A, 0x00424D96 constexpr TrackPaintAdditionPiece kLeftCurveLargeAddition4 = { /* ImageIds */ std::array<uint32_t, 4>{ kDiagonal0SE, kDiagonal0SW, kDiagonal0NW, kDiagonal0NE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 5> kLeftCurveLargeTPPA = { kLeftCurveLargeAddition0, kLeftCurveLargeAddition1, kLeftCurveLargeAddition2, kLeftCurveLargeAddition3, kLeftCurveLargeAddition4, }; constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition0 = rotateTrackPPA(kLeftCurveLargeAddition4, kRotationTable3012); constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition3 = rotateTrackPPA(kLeftCurveLargeAddition1, kRotationTable3012); constexpr TrackPaintAdditionPiece kDiagonalRightCurveLargeAddition4 = rotateTrackPPA(kLeftCurveLargeAddition0, kRotationTable3012); constexpr std::array<TrackPaintAdditionPiece, 5> kDiagonalRightCurveLargeTPPA = { kDiagonalRightCurveLargeAddition0, kDiagonalRightCurveLargeAddition1, kDiagonalRightCurveLargeAddition2, kDiagonalRightCurveLargeAddition3, kDiagonalRightCurveLargeAddition4, }; constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition0 = rotateTrackPPA(kRightCurveLargeAddition4, kRotationTable2301); constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition3 = rotateTrackPPA(kRightCurveLargeAddition1, kRotationTable2301); constexpr TrackPaintAdditionPiece kDiagonalLeftCurveLargeAddition4 = rotateTrackPPA(kRightCurveLargeAddition0, kRotationTable2301); constexpr std::array<TrackPaintAdditionPiece, 5> kDiagonalLeftCurveLargeTPPA = { kDiagonalLeftCurveLargeAddition0, kDiagonalLeftCurveLargeAddition1, kDiagonalLeftCurveLargeAddition2, kDiagonalLeftCurveLargeAddition3, kDiagonalLeftCurveLargeAddition4, }; // 0x00425B5D, 0x00425CE3, 0x00425FA8, 0x0042612E constexpr TrackPaintAdditionPiece kSBendLeftAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; // 0x00425BA4, 0x00425D2A, 0x00425F2C, 0x004260B2 constexpr TrackPaintAdditionPiece kSBendLeftAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1SE, kRightCurve1SW, kRightCurve1NW, kRightCurve1NE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 24, 1 }, World::Pos3{ 24, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportRightCurve3SE, kSupportConnectorRightCurve3SE }, std::array<uint32_t, 2>{ kSupportRightCurve3SW, kSupportConnectorRightCurve3SW }, std::array<uint32_t, 2>{ kSupportRightCurve3NW, kSupportConnectorRightCurve3NW }, std::array<uint32_t, 2>{ kSupportRightCurve3NE, kSupportConnectorRightCurve3NE }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x2y2, }, }; // 0x00425C20, 0x00425DA6, 0x00425EB0, 0x00426036 constexpr TrackPaintAdditionPiece kSBendLeftAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1NW, kRightCurve1NE, kRightCurve1SE, kRightCurve1SW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 24, 1 }, World::Pos3{ 24, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportRightCurve3NW, kSupportConnectorRightCurve3NW }, std::array<uint32_t, 2>{ kSupportRightCurve3NE, kSupportConnectorRightCurve3NE }, std::array<uint32_t, 2>{ kSupportRightCurve3SE, kSupportConnectorRightCurve3SE }, std::array<uint32_t, 2>{ kSupportRightCurve3SW, kSupportConnectorRightCurve3SW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y0, }, }; // 0x00425C9C, 0x00425E22, 0x00425E69, 0x00425FEF constexpr TrackPaintAdditionPiece kSBendLeftAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 4> kSBendLeftTPPA = { kSBendLeftAddition0, kSBendLeftAddition1, kSBendLeftAddition2, kSBendLeftAddition3, }; // 0x00426175, 0x004262FB, 0x004265C0, 0x00426746 constexpr TrackPaintAdditionPiece kSBendRightAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; // 0x004261BC, 0x00426342, 0x00426544, 0x004266CA constexpr TrackPaintAdditionPiece kSBendRightAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1NE, kRightCurve1SE, kRightCurve1SW, kRightCurve1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, World::Pos3{ 2, 0, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 24, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportRightCurve1NE, kSupportConnectorRightCurve1NE }, std::array<uint32_t, 2>{ kSupportRightCurve1SE, kSupportConnectorRightCurve1SE }, std::array<uint32_t, 2>{ kSupportRightCurve1SW, kSupportConnectorRightCurve1SW }, std::array<uint32_t, 2>{ kSupportRightCurve1NW, kSupportConnectorRightCurve1NW }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x2y0, }, }; // 0x00426238, 0x004263BE, 0x004264C8, 0x0042664E constexpr TrackPaintAdditionPiece kSBendRightAddition2 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurve1SW, kRightCurve1NW, kRightCurve1NE, kRightCurve1SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 0, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 6, 26 }, World::Pos3{ 6, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 24, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* Mergeable */ true, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportRightCurve1SW, kSupportConnectorRightCurve1SW }, std::array<uint32_t, 2>{ kSupportRightCurve1NW, kSupportConnectorRightCurve1NW }, std::array<uint32_t, 2>{ kSupportRightCurve1NE, kSupportConnectorRightCurve1NE }, std::array<uint32_t, 2>{ kSupportRightCurve1SE, kSupportConnectorRightCurve1SE }, }, /* SupportHeight */ 0, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y2, }, }; // 0x004262B4, 0x0042643A, 0x00426481, 0x00426607 constexpr TrackPaintAdditionPiece kSBendRightAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraight0NE, kStraight0SE, kStraight0NE, kStraight0SE, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, World::Pos3{ 2, 2, 26 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* Mergeable */ true, /* Supports */ kNoSupports, }; constexpr std::array<TrackPaintAdditionPiece, 4> kSBendRightTPPA = { kSBendRightAddition0, kSBendRightAddition1, kSBendRightAddition2, kSBendRightAddition3, }; // 0x004254A1, 0x004255B7, 0x004256CD, 0x004257E3 constexpr TrackPaintAdditionPiece kStraightSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSlopeUp0NE, kStraightSlopeUp0SE, kStraightSlopeUp0SW, kStraightSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 4, /* Frequency */ 1, /* Segment */ SegmentFlags::x1y0, }, }; // 0x0042552C, 0x00425642, 0x00425758, 0x0042586E constexpr TrackPaintAdditionPiece kStraightSlopeUpAddition1 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSlopeUp1NE, kStraightSlopeUp1SE, kStraightSlopeUp1SW, kStraightSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 12, /* Frequency */ 1, /* Segment */ SegmentFlags::x1y0, }, }; constexpr std::array<TrackPaintAdditionPiece, 2> kStraightSlopeUpTPPA = { kStraightSlopeUpAddition0, kStraightSlopeUpAddition1, }; constexpr TrackPaintAdditionPiece kStraightSlopeDownAddition0 = rotateTrackPPA(kStraightSlopeUpAddition1, kRotationTable2301); constexpr TrackPaintAdditionPiece kStraightSlopeDownAddition1 = rotateTrackPPA(kStraightSlopeUpAddition0, kRotationTable2301); constexpr std::array<TrackPaintAdditionPiece, 2> kStraightSlopeDownTPPA = { kStraightSlopeDownAddition0, kStraightSlopeDownAddition1, }; // 0x004258F9, 0x00425984, 0x00425A0F, 0x00425A9A constexpr TrackPaintAdditionPiece kStraightSteepSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kStraightSteepSlopeUp0NE, kStraightSteepSlopeUp0SE, kStraightSteepSlopeUp0SW, kStraightSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 8, /* Frequency */ 2, /* Segment */ SegmentFlags::x1y0, }, }; constexpr std::array<TrackPaintAdditionPiece, 1> kStraightSteepSlopeUpTPPA = { kStraightSteepSlopeUpAddition0, }; constexpr TrackPaintAdditionPiece kStraightSteepSlopeDownAddition0 = rotateTrackPPA(kStraightSteepSlopeUpAddition0, kRotationTable2301); constexpr std::array<TrackPaintAdditionPiece, 1> kStraightSteepSlopeDownTPPA = { kStraightSteepSlopeDownAddition0, }; // 0x00422FE1, 0x004230F9, 0x00423211, 0x00423329 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeUp0NE, kRightCurveSmallSlopeUp0SE, kRightCurveSmallSlopeUp0SW, kRightCurveSmallSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 4, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0, }, }; constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition2 = kNullTrackPaintAdditionPiece; // 0x0042306E, 0x00423186, 0x0042329E, 0x004233B6 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeUpAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeUp3NE, kRightCurveSmallSlopeUp3SE, kRightCurveSmallSlopeUp3SW, kRightCurveSmallSlopeUp3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, }, /* SupportHeight */ 12, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y1, }, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSlopeUpTPPA = { kRightCurveSmallSlopeUpAddition0, kRightCurveSmallSlopeUpAddition1, kRightCurveSmallSlopeUpAddition2, kRightCurveSmallSlopeUpAddition3, }; // 0x00423441, 0x00423559, 0x00423671, 0x00423789 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeDown0NE, kRightCurveSmallSlopeDown0SE, kRightCurveSmallSlopeDown0SW, kRightCurveSmallSlopeDown0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 12, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0, }, }; constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition2 = kNullTrackPaintAdditionPiece; // 0x004234CE, 0x004235E6, 0x004236FE, 0x00423816 constexpr TrackPaintAdditionPiece kRightCurveSmallSlopeDownAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSlopeDown3NE, kRightCurveSmallSlopeDown3SE, kRightCurveSmallSlopeDown3SW, kRightCurveSmallSlopeDown3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, }, /* SupportHeight */ 4, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y1, }, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSlopeDownTPPA = { kRightCurveSmallSlopeDownAddition0, kRightCurveSmallSlopeDownAddition1, kRightCurveSmallSlopeDownAddition2, kRightCurveSmallSlopeDownAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition0 = rotateTrackPPA(kRightCurveSmallSlopeDownAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeUpAddition3 = rotateTrackPPA(kRightCurveSmallSlopeDownAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSlopeUpTPPA = { kLeftCurveSmallSlopeUpAddition0, kLeftCurveSmallSlopeUpAddition1, kLeftCurveSmallSlopeUpAddition2, kLeftCurveSmallSlopeUpAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition0 = rotateTrackPPA(kRightCurveSmallSlopeUpAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSlopeDownAddition3 = rotateTrackPPA(kRightCurveSmallSlopeUpAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSlopeDownTPPA = { kLeftCurveSmallSlopeDownAddition0, kLeftCurveSmallSlopeDownAddition1, kLeftCurveSmallSlopeDownAddition2, kLeftCurveSmallSlopeDownAddition3, }; // 0x00423911, 0x00423A29, 0x00423B41, 0x00423C59 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeUp0NE, kRightCurveSmallSteepSlopeUp0SE, kRightCurveSmallSteepSlopeUp0SW, kRightCurveSmallSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 8, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0, }, }; constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition2 = kNullTrackPaintAdditionPiece; // 0x0042399E, 0x00423AB6, 0x00423BCE, 0x00423CE6 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeUpAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeUp3NE, kRightCurveSmallSteepSlopeUp3SE, kRightCurveSmallSteepSlopeUp3SW, kRightCurveSmallSteepSlopeUp3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, }, /* SupportHeight */ 8, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y1, }, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSteepSlopeUpTPPA = { kRightCurveSmallSteepSlopeUpAddition0, kRightCurveSmallSteepSlopeUpAddition1, kRightCurveSmallSteepSlopeUpAddition2, kRightCurveSmallSteepSlopeUpAddition3, }; // 0x00423D71, 0x00423E89, 0x00423FA1, 0x004240B9 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition0 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeDown0NE, kRightCurveSmallSteepSlopeDown0SE, kRightCurveSmallSteepSlopeDown0SW, kRightCurveSmallSteepSlopeDown0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, }, /* SupportHeight */ 8, /* Frequency */ 0, /* Segment */ SegmentFlags::x1y0, }, }; constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition2 = kNullTrackPaintAdditionPiece; // 0x00423DFE, 0x00423F16, 0x0042402E, 0x00424146 constexpr TrackPaintAdditionPiece kRightCurveSmallSteepSlopeDownAddition3 = { /* ImageIds */ std::array<uint32_t, 4>{ kRightCurveSmallSteepSlopeDown3NE, kRightCurveSmallSteepSlopeDown3SE, kRightCurveSmallSteepSlopeDown3SW, kRightCurveSmallSteepSlopeDown3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, World::Pos3{ 6, 2, 34 }, World::Pos3{ 2, 6, 34 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* Mergeable */ false, /* Supports */ TrackAdditionSupport{ /* ImageIds */ std::array<std::array<uint32_t, 2>, 4>{ std::array<uint32_t, 2>{ kSupportStraight0SE, kSupportConnectorStraight0SE }, std::array<uint32_t, 2>{ kSupportStraight0SW, kSupportConnectorStraight0SW }, std::array<uint32_t, 2>{ kSupportStraight0NW, kSupportConnectorStraight0NW }, std::array<uint32_t, 2>{ kSupportStraight0NE, kSupportConnectorStraight0NE }, }, /* SupportHeight */ 8, /* Frequency */ 0, /* Segment */ SegmentFlags::x0y1, }, }; constexpr std::array<TrackPaintAdditionPiece, 4> kRightCurveSmallSteepSlopeDownTPPA = { kRightCurveSmallSteepSlopeDownAddition0, kRightCurveSmallSteepSlopeDownAddition1, kRightCurveSmallSteepSlopeDownAddition2, kRightCurveSmallSteepSlopeDownAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition0 = rotateTrackPPA(kRightCurveSmallSteepSlopeDownAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeUpAddition3 = rotateTrackPPA(kRightCurveSmallSteepSlopeDownAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSteepSlopeUpTPPA = { kLeftCurveSmallSteepSlopeUpAddition0, kLeftCurveSmallSteepSlopeUpAddition1, kLeftCurveSmallSteepSlopeUpAddition2, kLeftCurveSmallSteepSlopeUpAddition3, }; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition0 = rotateTrackPPA(kRightCurveSmallSteepSlopeUpAddition3, kRotationTable1230); constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition1 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition2 = kNullTrackPaintAdditionPiece; constexpr TrackPaintAdditionPiece kLeftCurveSmallSteepSlopeDownAddition3 = rotateTrackPPA(kRightCurveSmallSteepSlopeUpAddition0, kRotationTable1230); constexpr std::array<TrackPaintAdditionPiece, 4> kLeftCurveSmallSteepSlopeDownTPPA = { kLeftCurveSmallSteepSlopeDownAddition0, kLeftCurveSmallSteepSlopeDownAddition1, kLeftCurveSmallSteepSlopeDownAddition2, kLeftCurveSmallSteepSlopeDownAddition3, }; constexpr std::array<std::span<const TrackPaintAdditionPiece>, 26> kTrackPaintAdditionParts = { kStraightTPPA, kDiagonalTPPA, kLeftCurveVerySmallTPPA, kRightCurveVerySmallTPPA, kLeftCurveSmallTPPA, kRightCurveSmallTPPA, kLeftCurveTPPA, kRightCurveTPPA, kLeftCurveLargeTPPA, kRightCurveLargeTPPA, kDiagonalLeftCurveLargeTPPA, kDiagonalRightCurveLargeTPPA, kSBendLeftTPPA, kSBendRightTPPA, kStraightSlopeUpTPPA, kStraightSlopeDownTPPA, kStraightSteepSlopeUpTPPA, kStraightSteepSlopeDownTPPA, kLeftCurveSmallSlopeUpTPPA, kRightCurveSmallSlopeUpTPPA, kLeftCurveSmallSlopeDownTPPA, kRightCurveSmallSlopeDownTPPA, kLeftCurveSmallSteepSlopeUpTPPA, kRightCurveSmallSteepSlopeUpTPPA, kLeftCurveSmallSteepSlopeDownTPPA, kRightCurveSmallSteepSlopeDownTPPA, }; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTrackData.h ```h #pragma once #include "Objects/TrackObject.h" #include "Paint.h" #include <OpenLoco/Core/Numerics.hpp> #include <array> #include <span> namespace OpenLoco::Paint { struct TrackPaintPiece { private: constexpr void rotateTunnelHeights() { tunnelHeights[1][0] = tunnelHeights[0][3]; tunnelHeights[1][1] = tunnelHeights[0][0]; tunnelHeights[1][2] = tunnelHeights[0][1]; tunnelHeights[1][3] = tunnelHeights[0][2]; tunnelHeights[2][0] = tunnelHeights[0][2]; tunnelHeights[2][1] = tunnelHeights[0][3]; tunnelHeights[2][2] = tunnelHeights[0][0]; tunnelHeights[2][3] = tunnelHeights[0][1]; tunnelHeights[3][0] = tunnelHeights[0][1]; tunnelHeights[3][1] = tunnelHeights[0][2]; tunnelHeights[3][2] = tunnelHeights[0][3]; tunnelHeights[3][3] = tunnelHeights[0][0]; } constexpr void rotateBridgeEdgesQuarters() { for (auto i = 1; i < 4; ++i) { bridgeEdges[i] = Numerics::rotl4bit(bridgeEdges[0], i); } for (auto i = 1; i < 4; ++i) { bridgeQuarters[i] = Numerics::rotl4bit(bridgeQuarters[0], i); } } constexpr void rotateSegements() { for (auto i = 1; i < 4; ++i) { segments[i] = rotlSegmentFlags(segments[0], i); } } public: constexpr TrackPaintPiece( const std::array<std::array<uint32_t, 3>, 4>& _imageIndexOffsets, const std::array<World::Pos3, 4>& _boundingBoxOffsets, const std::array<World::Pos3, 4>& _boundingBoxSizes, const std::array<uint8_t, 4>& _bridgeEdges, const std::array<uint8_t, 4>& _bridgeQuarters, const std::array<uint8_t, 4>& _bridgeType, const std::array<std::array<int16_t, 4>, 4>& _tunnelHeights, const std::array<SegmentFlags, 4>& _segments, bool _isMergeable) : imageIndexOffsets(_imageIndexOffsets) , boundingBoxOffsets(_boundingBoxOffsets) , boundingBoxSizes(_boundingBoxSizes) , bridgeEdges(_bridgeEdges) , bridgeQuarters(_bridgeQuarters) , bridgeType(_bridgeType) , tunnelHeights(_tunnelHeights) , segments(_segments) , isMergeable(_isMergeable) { } constexpr TrackPaintPiece( const std::array<std::array<uint32_t, 3>, 4>& _imageIndexOffsets, const std::array<World::Pos3, 4>& _boundingBoxOffsets, const std::array<World::Pos3, 4>& _boundingBoxSizes, uint8_t _bridgeEdges, uint8_t _bridgeQuarters, const std::array<uint8_t, 4>& _bridgeType, const std::array<int16_t, 4>& _tunnelHeights, SegmentFlags _segments) : imageIndexOffsets(_imageIndexOffsets) , boundingBoxOffsets(_boundingBoxOffsets) , boundingBoxSizes(_boundingBoxSizes) , bridgeEdges() , bridgeQuarters() , bridgeType(_bridgeType) , tunnelHeights() , segments() , isMergeable(true) { tunnelHeights[0] = _tunnelHeights; bridgeEdges[0] = _bridgeEdges; bridgeQuarters[0] = _bridgeQuarters; segments[0] = _segments; rotateTunnelHeights(); rotateBridgeEdgesQuarters(); rotateSegements(); } constexpr TrackPaintPiece( const std::array<uint32_t, 4>& _imageIndexOffsets, const std::array<World::Pos3, 4>& _boundingBoxOffsets, const std::array<World::Pos3, 4>& _boundingBoxSizes, uint8_t _bridgeEdges, uint8_t _bridgeQuarters, const std::array<uint8_t, 4>& _bridgeType, const std::array<int16_t, 4>& _tunnelHeights, SegmentFlags _segments) : imageIndexOffsets() , boundingBoxOffsets(_boundingBoxOffsets) , boundingBoxSizes(_boundingBoxSizes) , bridgeEdges() , bridgeQuarters() , bridgeType(_bridgeType) , tunnelHeights() , segments() , isMergeable(false) { imageIndexOffsets[0][0] = _imageIndexOffsets[0]; imageIndexOffsets[1][0] = _imageIndexOffsets[1]; imageIndexOffsets[2][0] = _imageIndexOffsets[2]; imageIndexOffsets[3][0] = _imageIndexOffsets[3]; tunnelHeights[0] = _tunnelHeights; bridgeEdges[0] = _bridgeEdges; bridgeQuarters[0] = _bridgeQuarters; segments[0] = _segments; rotateTunnelHeights(); rotateBridgeEdgesQuarters(); rotateSegements(); } std::array<std::array<uint32_t, 3>, 4> imageIndexOffsets; std::array<World::Pos3, 4> boundingBoxOffsets; std::array<World::Pos3, 4> boundingBoxSizes; std::array<uint8_t, 4> bridgeEdges; std::array<uint8_t, 4> bridgeQuarters; std::array<uint8_t, 4> bridgeType; std::array<std::array<int16_t, 4>, 4> tunnelHeights; std::array<SegmentFlags, 4> segments; bool isMergeable; }; constexpr int16_t kNoTunnel = -1; constexpr std::array<int16_t, 4> kNoTunnels = { kNoTunnel, kNoTunnel, kNoTunnel, kNoTunnel }; constexpr std::array<uint8_t, 4> kFlatBridge = { 0, 0, 0, 0 }; constexpr std::array<uint8_t, 4> kRotationTable1230 = { 1, 2, 3, 0 }; constexpr std::array<uint8_t, 4> kRotationTable2301 = { 2, 3, 0, 1 }; constexpr std::array<uint8_t, 4> kRotationTable3012 = { 3, 0, 1, 2 }; consteval TrackPaintPiece rotateTrackPP(const TrackPaintPiece& reference, const std::array<uint8_t, 4>& rotationTable) { return TrackPaintPiece{ std::array<std::array<uint32_t, 3>, 4>{ reference.imageIndexOffsets[rotationTable[0]], reference.imageIndexOffsets[rotationTable[1]], reference.imageIndexOffsets[rotationTable[2]], reference.imageIndexOffsets[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxOffsets[rotationTable[0]], reference.boundingBoxOffsets[rotationTable[1]], reference.boundingBoxOffsets[rotationTable[2]], reference.boundingBoxOffsets[rotationTable[3]], }, std::array<World::Pos3, 4>{ reference.boundingBoxSizes[rotationTable[0]], reference.boundingBoxSizes[rotationTable[1]], reference.boundingBoxSizes[rotationTable[2]], reference.boundingBoxSizes[rotationTable[3]], }, std::array<uint8_t, 4>{ reference.bridgeEdges[rotationTable[0]], reference.bridgeEdges[rotationTable[1]], reference.bridgeEdges[rotationTable[2]], reference.bridgeEdges[rotationTable[3]], }, std::array<uint8_t, 4>{ reference.bridgeQuarters[rotationTable[0]], reference.bridgeQuarters[rotationTable[1]], reference.bridgeQuarters[rotationTable[2]], reference.bridgeQuarters[rotationTable[3]], }, std::array<uint8_t, 4>{ reference.bridgeType[rotationTable[0]], reference.bridgeType[rotationTable[1]], reference.bridgeType[rotationTable[2]], reference.bridgeType[rotationTable[3]], }, std::array<std::array<int16_t, 4>, 4>{ reference.tunnelHeights[rotationTable[0]], reference.tunnelHeights[rotationTable[1]], reference.tunnelHeights[rotationTable[2]], reference.tunnelHeights[rotationTable[3]], }, std::array<SegmentFlags, 4>{ reference.segments[rotationTable[0]], reference.segments[rotationTable[1]], reference.segments[rotationTable[2]], reference.segments[rotationTable[3]], }, reference.isMergeable }; } // 0x004125DD, 0x0041270E constexpr TrackPaintPiece kStraight0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kStraight0BallastNE, TrackObj::ImageIds::Style0::kStraight0SleeperNE, TrackObj::ImageIds::Style0::kStraight0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kStraight0BallastSE, TrackObj::ImageIds::Style0::kStraight0SleeperSE, TrackObj::ImageIds::Style0::kStraight0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kStraight0BallastNE, TrackObj::ImageIds::Style0::kStraight0SleeperNE, TrackObj::ImageIds::Style0::kStraight0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kStraight0BallastSE, TrackObj::ImageIds::Style0::kStraight0SleeperSE, TrackObj::ImageIds::Style0::kStraight0RailSE }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, World::Pos3{ 2, 5, 0 }, World::Pos3{ 5, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, World::Pos3{ 28, 22, 1 }, World::Pos3{ 22, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ 0, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr std::array<TrackPaintPiece, 1> kStraightTPP = { kStraight0, }; // 0x0041BDBD, 0x0041C121, 0x0041C047, 0x0041C3AB constexpr TrackPaintPiece kDiagonal0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal0BallastE, TrackObj::ImageIds::Style0::kDiagonal0SleeperE, TrackObj::ImageIds::Style0::kDiagonal0RailE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal0BallastS, TrackObj::ImageIds::Style0::kDiagonal0SleeperS, TrackObj::ImageIds::Style0::kDiagonal0RailS }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal3BallastE, TrackObj::ImageIds::Style0::kDiagonal3SleeperE, TrackObj::ImageIds::Style0::kDiagonal3RailE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal3BallastS, TrackObj::ImageIds::Style0::kDiagonal3SleeperS, TrackObj::ImageIds::Style0::kDiagonal3RailS }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* BridgeEdges */ 0b1111, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x1y2, }; // 0x0041BE97, 0x0041C1FB, 0x0041BF6F, 0x0041C2D3 constexpr TrackPaintPiece kDiagonal1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal1BallastE, TrackObj::ImageIds::Style0::kDiagonal1SleeperE, TrackObj::ImageIds::Style0::kDiagonal1RailE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal1BallastS, TrackObj::ImageIds::Style0::kDiagonal1SleeperS, TrackObj::ImageIds::Style0::kDiagonal1RailS }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal2BallastE, TrackObj::ImageIds::Style0::kDiagonal2SleeperE, TrackObj::ImageIds::Style0::kDiagonal2RailE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kDiagonal2BallastS, TrackObj::ImageIds::Style0::kDiagonal2SleeperS, TrackObj::ImageIds::Style0::kDiagonal2RailS }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0, }; constexpr TrackPaintPiece kDiagonal2 = rotateTrackPP(kDiagonal1, kRotationTable2301); constexpr TrackPaintPiece kDiagonal3 = rotateTrackPP(kDiagonal0, kRotationTable2301); constexpr std::array<TrackPaintPiece, 4> kDiagonalTPP = { kDiagonal0, kDiagonal1, kDiagonal2, kDiagonal3, }; // 0x00413BDF, 0x00413D19, 0x00413E53, 0x00413F8B constexpr TrackPaintPiece kRightCurveVerySmall0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveVerySmall0BallastNE, TrackObj::ImageIds::Style0::kRightCurveVerySmall0SleeperNE, TrackObj::ImageIds::Style0::kRightCurveVerySmall0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveVerySmall0BallastSE, TrackObj::ImageIds::Style0::kRightCurveVerySmall0SleeperSE, TrackObj::ImageIds::Style0::kRightCurveVerySmall0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveVerySmall0BallastSW, TrackObj::ImageIds::Style0::kRightCurveVerySmall0SleeperSW, TrackObj::ImageIds::Style0::kRightCurveVerySmall0RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveVerySmall0BallastNW, TrackObj::ImageIds::Style0::kRightCurveVerySmall0SleeperNW, TrackObj::ImageIds::Style0::kRightCurveVerySmall0RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 1> kRightCurveVerySmallTPP = { kRightCurveVerySmall0, }; constexpr TrackPaintPiece kLeftCurveVerySmall0 = rotateTrackPP(kRightCurveVerySmall0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 1> kLeftCurveVerySmallTPP = { kLeftCurveVerySmall0, }; // 0x00414EED, 0x0041528F, 0x00415631, 0x004159D1 constexpr TrackPaintPiece kRightCurveSmall0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall0BallastNE, TrackObj::ImageIds::Style0::kRightCurveSmall0SleeperNE, TrackObj::ImageIds::Style0::kRightCurveSmall0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall0BallastSE, TrackObj::ImageIds::Style0::kRightCurveSmall0SleeperSE, TrackObj::ImageIds::Style0::kRightCurveSmall0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall0BallastSW, TrackObj::ImageIds::Style0::kRightCurveSmall0SleeperSW, TrackObj::ImageIds::Style0::kRightCurveSmall0RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall0BallastNW, TrackObj::ImageIds::Style0::kRightCurveSmall0SleeperNW, TrackObj::ImageIds::Style0::kRightCurveSmall0RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00414FEE, 0x00415390, 0x00415732, 0x00415AD2 constexpr TrackPaintPiece kRightCurveSmall1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall1BallastNE, TrackObj::ImageIds::Style0::kRightCurveSmall1SleeperNE, TrackObj::ImageIds::Style0::kRightCurveSmall1RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall1BallastSE, TrackObj::ImageIds::Style0::kRightCurveSmall1SleeperSE, TrackObj::ImageIds::Style0::kRightCurveSmall1RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall1BallastSW, TrackObj::ImageIds::Style0::kRightCurveSmall1SleeperSW, TrackObj::ImageIds::Style0::kRightCurveSmall1RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall1BallastNW, TrackObj::ImageIds::Style0::kRightCurveSmall1SleeperNW, TrackObj::ImageIds::Style0::kRightCurveSmall1RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0, }; // 0x004150BD, 0x0041545F, 0x00415801, 0x00415BA1 constexpr TrackPaintPiece kRightCurveSmall2 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall2BallastNE, TrackObj::ImageIds::Style0::kRightCurveSmall2SleeperNE, TrackObj::ImageIds::Style0::kRightCurveSmall2RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall2BallastSE, TrackObj::ImageIds::Style0::kRightCurveSmall2SleeperSE, TrackObj::ImageIds::Style0::kRightCurveSmall2RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall2BallastSW, TrackObj::ImageIds::Style0::kRightCurveSmall2SleeperSW, TrackObj::ImageIds::Style0::kRightCurveSmall2RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall2BallastNW, TrackObj::ImageIds::Style0::kRightCurveSmall2SleeperNW, TrackObj::ImageIds::Style0::kRightCurveSmall2RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x0041518E, 0x00415530, 0x004158D0, 0x00415C72 constexpr TrackPaintPiece kRightCurveSmall3 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall3BallastNE, TrackObj::ImageIds::Style0::kRightCurveSmall3SleeperNE, TrackObj::ImageIds::Style0::kRightCurveSmall3RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall3BallastSE, TrackObj::ImageIds::Style0::kRightCurveSmall3SleeperSE, TrackObj::ImageIds::Style0::kRightCurveSmall3RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall3BallastSW, TrackObj::ImageIds::Style0::kRightCurveSmall3SleeperSW, TrackObj::ImageIds::Style0::kRightCurveSmall3RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveSmall3BallastNW, TrackObj::ImageIds::Style0::kRightCurveSmall3SleeperNW, TrackObj::ImageIds::Style0::kRightCurveSmall3RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1110, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 4> kRightCurveSmallTPP = { kRightCurveSmall0, kRightCurveSmall1, kRightCurveSmall2, kRightCurveSmall3, }; constexpr TrackPaintPiece kLeftCurveSmall0 = rotateTrackPP(kRightCurveSmall3, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmall1 = rotateTrackPP(kRightCurveSmall1, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmall2 = rotateTrackPP(kRightCurveSmall2, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmall3 = rotateTrackPP(kRightCurveSmall0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 4> kLeftCurveSmallTPP = { kLeftCurveSmall0, kLeftCurveSmall1, kLeftCurveSmall2, kLeftCurveSmall3, }; // 0x0041873B, 0x00418BDB, 0x0041907D, 0x0041951B constexpr TrackPaintPiece kRightCurve0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve0BallastNE, TrackObj::ImageIds::Style0::kRightCurve0SleeperNE, TrackObj::ImageIds::Style0::kRightCurve0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve0BallastSE, TrackObj::ImageIds::Style0::kRightCurve0SleeperSE, TrackObj::ImageIds::Style0::kRightCurve0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve0BallastSW, TrackObj::ImageIds::Style0::kRightCurve0SleeperSW, TrackObj::ImageIds::Style0::kRightCurve0RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve0BallastNW, TrackObj::ImageIds::Style0::kRightCurve0SleeperNW, TrackObj::ImageIds::Style0::kRightCurve0RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00418845, 0x00418CE5, 0x00419187, 0x00419625 constexpr TrackPaintPiece kRightCurve1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve1BallastNE, TrackObj::ImageIds::Style0::kRightCurve1SleeperNE, TrackObj::ImageIds::Style0::kRightCurve1RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve1BallastSE, TrackObj::ImageIds::Style0::kRightCurve1SleeperSE, TrackObj::ImageIds::Style0::kRightCurve1RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve1BallastSW, TrackObj::ImageIds::Style0::kRightCurve1SleeperSW, TrackObj::ImageIds::Style0::kRightCurve1RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve1BallastNW, TrackObj::ImageIds::Style0::kRightCurve1SleeperNW, TrackObj::ImageIds::Style0::kRightCurve1RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x0041891F, 0x00418DBF, 0x0041925F, 0x004196FF constexpr TrackPaintPiece kRightCurve2 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve2BallastNE, TrackObj::ImageIds::Style0::kRightCurve2SleeperNE, TrackObj::ImageIds::Style0::kRightCurve2RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve2BallastSE, TrackObj::ImageIds::Style0::kRightCurve2SleeperSE, TrackObj::ImageIds::Style0::kRightCurve2RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve2BallastSW, TrackObj::ImageIds::Style0::kRightCurve2SleeperSW, TrackObj::ImageIds::Style0::kRightCurve2RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve2BallastNW, TrackObj::ImageIds::Style0::kRightCurve2SleeperNW, TrackObj::ImageIds::Style0::kRightCurve2RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x0y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x0y1, }; // 0x004189F7, 0x00418E99, 0x00419339, 0x004197D9 constexpr TrackPaintPiece kRightCurve3 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve3BallastNE, TrackObj::ImageIds::Style0::kRightCurve3SleeperNE, TrackObj::ImageIds::Style0::kRightCurve3RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve3BallastSE, TrackObj::ImageIds::Style0::kRightCurve3SleeperSE, TrackObj::ImageIds::Style0::kRightCurve3RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve3BallastSW, TrackObj::ImageIds::Style0::kRightCurve3SleeperSW, TrackObj::ImageIds::Style0::kRightCurve3RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve3BallastNW, TrackObj::ImageIds::Style0::kRightCurve3SleeperNW, TrackObj::ImageIds::Style0::kRightCurve3RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00418AD1, 0x00418F73, 0x00419411, 0x004198B3 constexpr TrackPaintPiece kRightCurve4 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve4BallastNE, TrackObj::ImageIds::Style0::kRightCurve4SleeperNE, TrackObj::ImageIds::Style0::kRightCurve4RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve4BallastSE, TrackObj::ImageIds::Style0::kRightCurve4SleeperSE, TrackObj::ImageIds::Style0::kRightCurve4RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve4BallastSW, TrackObj::ImageIds::Style0::kRightCurve4SleeperSW, TrackObj::ImageIds::Style0::kRightCurve4RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurve4BallastNW, TrackObj::ImageIds::Style0::kRightCurve4SleeperNW, TrackObj::ImageIds::Style0::kRightCurve4RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 6, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1010, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 5> kRightCurveTPP = { kRightCurve0, kRightCurve1, kRightCurve2, kRightCurve3, kRightCurve4, }; constexpr TrackPaintPiece kLeftCurve0 = rotateTrackPP(kRightCurve4, kRotationTable1230); constexpr TrackPaintPiece kLeftCurve1 = rotateTrackPP(kRightCurve3, kRotationTable1230); constexpr TrackPaintPiece kLeftCurve2 = rotateTrackPP(kRightCurve2, kRotationTable1230); constexpr TrackPaintPiece kLeftCurve3 = rotateTrackPP(kRightCurve1, kRotationTable1230); constexpr TrackPaintPiece kLeftCurve4 = rotateTrackPP(kRightCurve0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 5> kLeftCurveTPP = { kLeftCurve0, kLeftCurve1, kLeftCurve2, kLeftCurve3, kLeftCurve4, }; // 0x0041ABE7, 0x0041B055, 0x0041B4C3, 0x0041B931 constexpr TrackPaintPiece kRightCurveLarge0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge0BallastNE, TrackObj::ImageIds::Style0::kRightCurveLarge0SleeperNE, TrackObj::ImageIds::Style0::kRightCurveLarge0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge0BallastSE, TrackObj::ImageIds::Style0::kRightCurveLarge0SleeperSE, TrackObj::ImageIds::Style0::kRightCurveLarge0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge0BallastSW, TrackObj::ImageIds::Style0::kRightCurveLarge0SleeperSW, TrackObj::ImageIds::Style0::kRightCurveLarge0RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge0BallastNW, TrackObj::ImageIds::Style0::kRightCurveLarge0SleeperNW, TrackObj::ImageIds::Style0::kRightCurveLarge0RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x0041ACF1, 0x0041B15F, 0x0041B5CD, 0x0041BA3B constexpr TrackPaintPiece kRightCurveLarge1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge1BallastNE, TrackObj::ImageIds::Style0::kRightCurveLarge1SleeperNE, TrackObj::ImageIds::Style0::kRightCurveLarge1RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge1BallastSE, TrackObj::ImageIds::Style0::kRightCurveLarge1SleeperSE, TrackObj::ImageIds::Style0::kRightCurveLarge1RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge1BallastSW, TrackObj::ImageIds::Style0::kRightCurveLarge1SleeperSW, TrackObj::ImageIds::Style0::kRightCurveLarge1RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge1BallastNW, TrackObj::ImageIds::Style0::kRightCurveLarge1SleeperNW, TrackObj::ImageIds::Style0::kRightCurveLarge1RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x0041ADCB, 0x0041B239, 0x0041B6A5, 0x0041BB15 constexpr TrackPaintPiece kRightCurveLarge2 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge2BallastNE, TrackObj::ImageIds::Style0::kRightCurveLarge2SleeperNE, TrackObj::ImageIds::Style0::kRightCurveLarge2RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge2BallastSE, TrackObj::ImageIds::Style0::kRightCurveLarge2SleeperSE, TrackObj::ImageIds::Style0::kRightCurveLarge2RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge2BallastSW, TrackObj::ImageIds::Style0::kRightCurveLarge2SleeperSW, TrackObj::ImageIds::Style0::kRightCurveLarge2RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge2BallastNW, TrackObj::ImageIds::Style0::kRightCurveLarge2SleeperNW, TrackObj::ImageIds::Style0::kRightCurveLarge2RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x1y0 | SegmentFlags::x0y1, }; // 0x0041AEA3, 0x0041B313, 0x0041B77F, 0x0041BBEF constexpr TrackPaintPiece kRightCurveLarge3 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge3BallastNE, TrackObj::ImageIds::Style0::kRightCurveLarge3SleeperNE, TrackObj::ImageIds::Style0::kRightCurveLarge3RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge3BallastSE, TrackObj::ImageIds::Style0::kRightCurveLarge3SleeperSE, TrackObj::ImageIds::Style0::kRightCurveLarge3RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge3BallastSW, TrackObj::ImageIds::Style0::kRightCurveLarge3SleeperSW, TrackObj::ImageIds::Style0::kRightCurveLarge3RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge3BallastNW, TrackObj::ImageIds::Style0::kRightCurveLarge3SleeperNW, TrackObj::ImageIds::Style0::kRightCurveLarge3RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2, }; // 0x0041AF7B, 0x0041B3EB, 0x0041B857, 0x0041BCC7 constexpr TrackPaintPiece kRightCurveLarge4 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge4BallastNE, TrackObj::ImageIds::Style0::kRightCurveLarge4SleeperNE, TrackObj::ImageIds::Style0::kRightCurveLarge4RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge4BallastSE, TrackObj::ImageIds::Style0::kRightCurveLarge4SleeperSE, TrackObj::ImageIds::Style0::kRightCurveLarge4RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge4BallastSW, TrackObj::ImageIds::Style0::kRightCurveLarge4SleeperSW, TrackObj::ImageIds::Style0::kRightCurveLarge4RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kRightCurveLarge4BallastNW, TrackObj::ImageIds::Style0::kRightCurveLarge4SleeperNW, TrackObj::ImageIds::Style0::kRightCurveLarge4RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* BridgeEdges */ 0b1111, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1, }; constexpr std::array<TrackPaintPiece, 5> kRightCurveLargeTPP = { kRightCurveLarge0, kRightCurveLarge1, kRightCurveLarge2, kRightCurveLarge3, kRightCurveLarge4, }; // 0x00419A2D, 0x00419E9D, 0x0041A30B, 0x0041A779 constexpr TrackPaintPiece kLeftCurveLarge0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge0BallastNE, TrackObj::ImageIds::Style0::kLeftCurveLarge0SleeperNE, TrackObj::ImageIds::Style0::kLeftCurveLarge0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge0BallastSE, TrackObj::ImageIds::Style0::kLeftCurveLarge0SleeperSE, TrackObj::ImageIds::Style0::kLeftCurveLarge0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge0BallastSW, TrackObj::ImageIds::Style0::kLeftCurveLarge0SleeperSW, TrackObj::ImageIds::Style0::kLeftCurveLarge0RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge0BallastNW, TrackObj::ImageIds::Style0::kLeftCurveLarge0SleeperNW, TrackObj::ImageIds::Style0::kLeftCurveLarge0RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, World::Pos3{ 2, 3, 0 }, World::Pos3{ 3, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; // 0x00419B37, 0x00419FA7, 0x0041A415, 0x0041A883 constexpr TrackPaintPiece kLeftCurveLarge1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge1BallastNE, TrackObj::ImageIds::Style0::kLeftCurveLarge1SleeperNE, TrackObj::ImageIds::Style0::kLeftCurveLarge1RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge1BallastSE, TrackObj::ImageIds::Style0::kLeftCurveLarge1SleeperSE, TrackObj::ImageIds::Style0::kLeftCurveLarge1RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge1BallastSW, TrackObj::ImageIds::Style0::kLeftCurveLarge1SleeperSW, TrackObj::ImageIds::Style0::kLeftCurveLarge1RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge1BallastNW, TrackObj::ImageIds::Style0::kLeftCurveLarge1SleeperNW, TrackObj::ImageIds::Style0::kLeftCurveLarge1RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, World::Pos3{ 28, 14, 1 }, World::Pos3{ 14, 28, 1 }, }, /* BridgeEdges */ 0b1101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1, }; // 0x00419C11, 0x0041A07F, 0x0041A4EF, 0x0041A95D constexpr TrackPaintPiece kLeftCurveLarge2 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge2BallastNE, TrackObj::ImageIds::Style0::kLeftCurveLarge2SleeperNE, TrackObj::ImageIds::Style0::kLeftCurveLarge2RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge2BallastSE, TrackObj::ImageIds::Style0::kLeftCurveLarge2SleeperSE, TrackObj::ImageIds::Style0::kLeftCurveLarge2RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge2BallastSW, TrackObj::ImageIds::Style0::kLeftCurveLarge2SleeperSW, TrackObj::ImageIds::Style0::kLeftCurveLarge2RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge2BallastNW, TrackObj::ImageIds::Style0::kLeftCurveLarge2SleeperNW, TrackObj::ImageIds::Style0::kLeftCurveLarge2RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0011, /* BridgeQuarters */ 0b0001, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x0y1 | SegmentFlags::x1y2, }; // 0x00419CEB, 0x0041A159, 0x0041A5C9, 0x0041AA35 constexpr TrackPaintPiece kLeftCurveLarge3 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge3BallastNE, TrackObj::ImageIds::Style0::kLeftCurveLarge3SleeperNE, TrackObj::ImageIds::Style0::kLeftCurveLarge3RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge3BallastSE, TrackObj::ImageIds::Style0::kLeftCurveLarge3SleeperSE, TrackObj::ImageIds::Style0::kLeftCurveLarge3RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge3BallastSW, TrackObj::ImageIds::Style0::kLeftCurveLarge3SleeperSW, TrackObj::ImageIds::Style0::kLeftCurveLarge3RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge3BallastNW, TrackObj::ImageIds::Style0::kLeftCurveLarge3SleeperNW, TrackObj::ImageIds::Style0::kLeftCurveLarge3RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 16, 0 }, World::Pos3{ 16, 16, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1100, /* BridgeQuarters */ 0b0100, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y0, }; // 0x00419DC3, 0x0041A231, 0x0041A6A1, 0x0041AB0D constexpr TrackPaintPiece kLeftCurveLarge4 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge4BallastNE, TrackObj::ImageIds::Style0::kLeftCurveLarge4SleeperNE, TrackObj::ImageIds::Style0::kLeftCurveLarge4RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge4BallastSE, TrackObj::ImageIds::Style0::kLeftCurveLarge4SleeperSE, TrackObj::ImageIds::Style0::kLeftCurveLarge4RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge4BallastSW, TrackObj::ImageIds::Style0::kLeftCurveLarge4SleeperSW, TrackObj::ImageIds::Style0::kLeftCurveLarge4RailSW }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kLeftCurveLarge4BallastNW, TrackObj::ImageIds::Style0::kLeftCurveLarge4SleeperNW, TrackObj::ImageIds::Style0::kLeftCurveLarge4RailNW }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, World::Pos3{ 28, 28, 1 }, }, /* BridgeEdges */ 0b1111, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 5> kLeftCurveLargeTPP = { kLeftCurveLarge0, kLeftCurveLarge1, kLeftCurveLarge2, kLeftCurveLarge3, kLeftCurveLarge4, }; constexpr TrackPaintPiece kDiagonalRightCurveLarge0 = rotateTrackPP(kLeftCurveLarge4, kRotationTable3012); constexpr TrackPaintPiece kDiagonalRightCurveLarge1 = rotateTrackPP(kLeftCurveLarge2, kRotationTable3012); constexpr TrackPaintPiece kDiagonalRightCurveLarge2 = rotateTrackPP(kLeftCurveLarge3, kRotationTable3012); constexpr TrackPaintPiece kDiagonalRightCurveLarge3 = rotateTrackPP(kLeftCurveLarge1, kRotationTable3012); constexpr TrackPaintPiece kDiagonalRightCurveLarge4 = rotateTrackPP(kLeftCurveLarge0, kRotationTable3012); constexpr std::array<TrackPaintPiece, 5> kDiagonalRightCurveLargeTPP = { kDiagonalRightCurveLarge0, kDiagonalRightCurveLarge1, kDiagonalRightCurveLarge2, kDiagonalRightCurveLarge3, kDiagonalRightCurveLarge4, }; constexpr TrackPaintPiece kDiagonalLeftCurveLarge0 = rotateTrackPP(kRightCurveLarge4, kRotationTable2301); constexpr TrackPaintPiece kDiagonalLeftCurveLarge1 = rotateTrackPP(kRightCurveLarge2, kRotationTable2301); constexpr TrackPaintPiece kDiagonalLeftCurveLarge2 = rotateTrackPP(kRightCurveLarge3, kRotationTable2301); constexpr TrackPaintPiece kDiagonalLeftCurveLarge3 = rotateTrackPP(kRightCurveLarge1, kRotationTable2301); constexpr TrackPaintPiece kDiagonalLeftCurveLarge4 = rotateTrackPP(kRightCurveLarge0, kRotationTable2301); constexpr std::array<TrackPaintPiece, 5> kDiagonalLeftCurveLargeTPP = { kDiagonalLeftCurveLarge0, kDiagonalLeftCurveLarge1, kDiagonalLeftCurveLarge2, kDiagonalLeftCurveLarge3, kDiagonalLeftCurveLarge4, }; // 0x0041CEAF, 0x0041D277, 0x0041D16D, 0x0041D533 constexpr TrackPaintPiece kSBendLeft0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft0BallastNE, TrackObj::ImageIds::Style0::kSBendLeft0SleeperNE, TrackObj::ImageIds::Style0::kSBendLeft0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft0BallastSE, TrackObj::ImageIds::Style0::kSBendLeft0SleeperSE, TrackObj::ImageIds::Style0::kSBendLeft0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft3BallastNE, TrackObj::ImageIds::Style0::kSBendLeft3SleeperNE, TrackObj::ImageIds::Style0::kSBendLeft3RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft3BallastSE, TrackObj::ImageIds::Style0::kSBendLeft3SleeperSE, TrackObj::ImageIds::Style0::kSBendLeft3RailSE }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; // 0x0041CFB9, 0x0041D381, 0x0041D093, 0x0041D459 constexpr TrackPaintPiece kSBendLeft1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft1BallastNE, TrackObj::ImageIds::Style0::kSBendLeft1SleeperNE, TrackObj::ImageIds::Style0::kSBendLeft1RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft1BallastSE, TrackObj::ImageIds::Style0::kSBendLeft1SleeperSE, TrackObj::ImageIds::Style0::kSBendLeft1RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft2BallastNE, TrackObj::ImageIds::Style0::kSBendLeft2SleeperNE, TrackObj::ImageIds::Style0::kSBendLeft2RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendLeft2BallastSE, TrackObj::ImageIds::Style0::kSBendLeft2SleeperSE, TrackObj::ImageIds::Style0::kSBendLeft2RailSE }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 24, 1 }, World::Pos3{ 24, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, }, /* BridgeEdges */ 0b1100, /* BridgeQuarters */ 0b0100, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0 | SegmentFlags::x2y0 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1, }; constexpr TrackPaintPiece kSBendLeft2 = rotateTrackPP(kSBendLeft1, kRotationTable2301); constexpr TrackPaintPiece kSBendLeft3 = rotateTrackPP(kSBendLeft0, kRotationTable2301); constexpr std::array<TrackPaintPiece, 4> kSBendLeftTPP = { kSBendLeft0, kSBendLeft1, kSBendLeft2, kSBendLeft3, }; // 0x0041D63D, 0x0041DA03, 0x0041D8F9, 0x0041DCC1 constexpr TrackPaintPiece kSBendRight0 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight0BallastNE, TrackObj::ImageIds::Style0::kSBendRight0SleeperNE, TrackObj::ImageIds::Style0::kSBendRight0RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight0BallastSE, TrackObj::ImageIds::Style0::kSBendRight0SleeperSE, TrackObj::ImageIds::Style0::kSBendRight0RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight3BallastNE, TrackObj::ImageIds::Style0::kSBendRight3SleeperNE, TrackObj::ImageIds::Style0::kSBendRight3RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight3BallastSE, TrackObj::ImageIds::Style0::kSBendRight3SleeperSE, TrackObj::ImageIds::Style0::kSBendRight3RailSE }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, World::Pos3{ 28, 27, 1 }, World::Pos3{ 27, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ kFlatBridge, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x0041D747, 0x0041DB0D, 0x0041D821, 0x0041DBE7 constexpr TrackPaintPiece kSBendRight1 = { std::array<std::array<uint32_t, 3>, 4>{ std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight1BallastNE, TrackObj::ImageIds::Style0::kSBendRight1SleeperNE, TrackObj::ImageIds::Style0::kSBendRight1RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight1BallastSE, TrackObj::ImageIds::Style0::kSBendRight1SleeperSE, TrackObj::ImageIds::Style0::kSBendRight1RailSE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight2BallastNE, TrackObj::ImageIds::Style0::kSBendRight2SleeperNE, TrackObj::ImageIds::Style0::kSBendRight2RailNE }, std::array<uint32_t, 3>{ TrackObj::ImageIds::Style0::kSBendRight2BallastSE, TrackObj::ImageIds::Style0::kSBendRight2SleeperSE, TrackObj::ImageIds::Style0::kSBendRight2RailSE }, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 0 }, World::Pos3{ 6, 2, 0 }, World::Pos3{ 2, 0, 0 }, World::Pos3{ 2, 2, 0 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 26, 1 }, World::Pos3{ 26, 28, 1 }, World::Pos3{ 28, 26, 1 }, World::Pos3{ 24, 28, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr TrackPaintPiece kSBendRight2 = rotateTrackPP(kSBendRight1, kRotationTable2301); constexpr TrackPaintPiece kSBendRight3 = rotateTrackPP(kSBendRight0, kRotationTable2301); constexpr std::array<TrackPaintPiece, 4> kSBendRightTPP = { kSBendRight0, kSBendRight1, kSBendRight2, kSBendRight3, }; // 0x0041C4BB, 0x0041C639, 0x0041C7B7, 0x0041C935 constexpr TrackPaintPiece kStraightSlopeUp0 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kStraightSlopeUp0NE, TrackObj::ImageIds::Style0::kStraightSlopeUp0SE, TrackObj::ImageIds::Style0::kStraightSlopeUp0SW, TrackObj::ImageIds::Style0::kStraightSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 1, 3, 5, 7, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; // 0x0041C578, 0x0041C6F6, 0x0041C874, 0x0041C9F2 constexpr TrackPaintPiece kStraightSlopeUp1 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kStraightSlopeUp1NE, TrackObj::ImageIds::Style0::kStraightSlopeUp1SE, TrackObj::ImageIds::Style0::kStraightSlopeUp1SW, TrackObj::ImageIds::Style0::kStraightSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 2, 4, 6, 8, }, /* TunnelHeights */ std::array<int16_t, 4>{ 16, kNoTunnel, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr std::array<TrackPaintPiece, 2> kStraightSlopeUpTPP = { kStraightSlopeUp0, kStraightSlopeUp1, }; constexpr TrackPaintPiece kStraightSlopeDown0 = rotateTrackPP(kStraightSlopeUp1, kRotationTable2301); constexpr TrackPaintPiece kStraightSlopeDown1 = rotateTrackPP(kStraightSlopeUp0, kRotationTable2301); constexpr std::array<TrackPaintPiece, 2> kStraightSlopeDownTPP = { kStraightSlopeDown0, kStraightSlopeDown1, }; // 0x0041CAB3, 0x0041CBA4, 0x0041CC95, 0x0041CD86 constexpr TrackPaintPiece kStraightSteepSlopeUp0 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kStraightSteepSlopeUp0NE, TrackObj::ImageIds::Style0::kStraightSteepSlopeUp0SE, TrackObj::ImageIds::Style0::kStraightSteepSlopeUp0SW, TrackObj::ImageIds::Style0::kStraightSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0101, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 9, 10, 11, 12, }, /* TunnelHeights */ std::array<int16_t, 4>{ 16, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1, }; constexpr std::array<TrackPaintPiece, 1> kStraightSteepSlopeUpTPP = { kStraightSteepSlopeUp0, }; constexpr TrackPaintPiece kStraightSteepSlopeDown0 = rotateTrackPP(kStraightSteepSlopeUp0, kRotationTable2301); constexpr std::array<TrackPaintPiece, 1> kStraightSteepSlopeDownTPP = { kStraightSteepSlopeDown0, }; // 0x00415DE3, 0x0041606D, 0x004162F7, 0x0041657F constexpr TrackPaintPiece kRightCurveSmallSlopeUp0 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp0NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp0SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp0SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 1, 3, 5, 7, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00415E9D, 0x00416127, 0x004163B1, 0x00416639 constexpr TrackPaintPiece kRightCurveSmallSlopeUp1 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp1NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp1SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp1SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ std::array<uint8_t, 4>{ 16, 13, 14, 15, }, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0, }; // 0x00415F25, 0x004161AF, 0x00416439, 0x004166C1 constexpr TrackPaintPiece kRightCurveSmallSlopeUp2 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp2NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp2SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp2SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ std::array<uint8_t, 4>{ 14, 15, 16, 13, }, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00415FAF, 0x00416239, 0x004164C1, 0x0041674B constexpr TrackPaintPiece kRightCurveSmallSlopeUp3 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp3NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp3SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp3SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeUp3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1110, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 4, 6, 8, 2, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 16, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 4> kRightCurveSmallSlopeUpTPP = { kRightCurveSmallSlopeUp0, kRightCurveSmallSlopeUp1, kRightCurveSmallSlopeUp2, kRightCurveSmallSlopeUp3, }; // 0x00416809, 0x00416A93, 0x00416D1D, 0x00416FA5 constexpr TrackPaintPiece kRightCurveSmallSlopeDown0 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown0NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown0SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown0SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 6, 8, 2, 4, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 16, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x004168C7, 0x00416B51, 0x00416DDB, 0x00417063 constexpr TrackPaintPiece kRightCurveSmallSlopeDown1 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown1NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown1SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown1SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ std::array<uint8_t, 4>{ 16, 13, 14, 15, }, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0, }; // 0x0041694F, 0x00416BD9, 0x00416E63, 0x004170EB constexpr TrackPaintPiece kRightCurveSmallSlopeDown2 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown2NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown2SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown2SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ std::array<uint8_t, 4>{ 14, 15, 16, 13, }, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x004169D9, 0x00416C63, 0x00416EEB, 0x00417175 constexpr TrackPaintPiece kRightCurveSmallSlopeDown3 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown3NE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown3SE, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown3SW, TrackObj::ImageIds::Style0::kRightCurveSmallSlopeDown3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1110, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 7, 1, 3, 5, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 4> kRightCurveSmallSlopeDownTPP = { kRightCurveSmallSlopeDown0, kRightCurveSmallSlopeDown1, kRightCurveSmallSlopeDown2, kRightCurveSmallSlopeDown3, }; constexpr TrackPaintPiece kLeftCurveSmallSlopeUp0 = rotateTrackPP(kRightCurveSmallSlopeDown3, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSlopeUp1 = rotateTrackPP(kRightCurveSmallSlopeDown1, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSlopeUp2 = rotateTrackPP(kRightCurveSmallSlopeDown2, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSlopeUp3 = rotateTrackPP(kRightCurveSmallSlopeDown0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 4> kLeftCurveSmallSlopeUpTPP = { kLeftCurveSmallSlopeUp0, kLeftCurveSmallSlopeUp1, kLeftCurveSmallSlopeUp2, kLeftCurveSmallSlopeUp3, }; constexpr TrackPaintPiece kLeftCurveSmallSlopeDown0 = rotateTrackPP(kRightCurveSmallSlopeUp3, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSlopeDown1 = rotateTrackPP(kRightCurveSmallSlopeUp1, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSlopeDown2 = rotateTrackPP(kRightCurveSmallSlopeUp2, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSlopeDown3 = rotateTrackPP(kRightCurveSmallSlopeUp0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 4> kLeftCurveSmallSlopeDownTPP = { kLeftCurveSmallSlopeDown0, kLeftCurveSmallSlopeDown1, kLeftCurveSmallSlopeDown2, kLeftCurveSmallSlopeDown3, }; // 0x0041729F, 0x00417529, 0x004177B3, 0x00417A3B constexpr TrackPaintPiece kRightCurveSmallSteepSlopeUp0 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp0NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp0SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp0SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 9, 10, 11, 12, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 0, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00417359, 0x004175E3, 0x0041786D, 0x00417AF5 constexpr TrackPaintPiece kRightCurveSmallSteepSlopeUp1 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp1NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp1SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp1SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0, }; // 0x004173E1, 0x0041766B, 0x004178F5, 0x00417B7D constexpr TrackPaintPiece kRightCurveSmallSteepSlopeUp2 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp2NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp2SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp2SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x0041746B, 0x004176F5, 0x0041797D, 0x00417C07 constexpr TrackPaintPiece kRightCurveSmallSteepSlopeUp3 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp3NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp3SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp3SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeUp3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1110, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 10, 11, 12, 9, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 16, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 4> kRightCurveSmallSteepSlopeUpTPP = { kRightCurveSmallSteepSlopeUp0, kRightCurveSmallSteepSlopeUp1, kRightCurveSmallSteepSlopeUp2, kRightCurveSmallSteepSlopeUp3, }; // 0x00417CC5, 0x00417F4F, 0x004181D9, 0x0041846D constexpr TrackPaintPiece kRightCurveSmallSteepSlopeDown0 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown0NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown0SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown0SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown0NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, }, /* BridgeEdges */ 0b0111, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 11, 12, 9, 10, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, kNoTunnel, 16, kNoTunnel, }, /* Segments */ SegmentFlags::x0y2 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x0y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00417D83, 0x0041800D, 0x0041829A, 0x0041852E constexpr TrackPaintPiece kRightCurveSmallSteepSlopeDown1 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown1NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown1SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown1SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown1NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b1001, /* BridgeQuarters */ 0b1000, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x0y0, }; // 0x00417E0B, 0x00418095, 0x00418325, 0x004185B9 constexpr TrackPaintPiece kRightCurveSmallSteepSlopeDown2 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown2NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown2SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown2SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown2NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 16, 16, 2 }, World::Pos3{ 16, 2, 2 }, World::Pos3{ 2, 2, 2 }, World::Pos3{ 2, 16, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, World::Pos3{ 14, 14, 1 }, }, /* BridgeEdges */ 0b0110, /* BridgeQuarters */ 0b0010, /* BridgeType */ kFlatBridge, /* TunnelHeights */ kNoTunnels, /* Segments */ SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; // 0x00417E95, 0x0041811F, 0x004183B0, 0x00418646 constexpr TrackPaintPiece kRightCurveSmallSteepSlopeDown3 = { std::array<uint32_t, 4>{ TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown3NE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown3SE, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown3SW, TrackObj::ImageIds::Style0::kRightCurveSmallSteepSlopeDown3NW, }, /* BoundingBoxOffsets */ std::array<World::Pos3, 4>{ World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, World::Pos3{ 6, 2, 2 }, World::Pos3{ 2, 6, 2 }, }, /* BoundingBoxSizes */ std::array<World::Pos3, 4>{ World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, World::Pos3{ 20, 28, 1 }, World::Pos3{ 28, 20, 1 }, }, /* BridgeEdges */ 0b1110, /* BridgeQuarters */ 0b1111, /* BridgeType */ std::array<uint8_t, 4>{ 12, 9, 10, 11, }, /* TunnelHeights */ std::array<int16_t, 4>{ kNoTunnel, 0, kNoTunnel, kNoTunnel, }, /* Segments */ SegmentFlags::x2y0 | SegmentFlags::x2y2 | SegmentFlags::x1y1 | SegmentFlags::x1y0 | SegmentFlags::x2y1 | SegmentFlags::x1y2, }; constexpr std::array<TrackPaintPiece, 4> kRightCurveSmallSteepSlopeDownTPP = { kRightCurveSmallSteepSlopeDown0, kRightCurveSmallSteepSlopeDown1, kRightCurveSmallSteepSlopeDown2, kRightCurveSmallSteepSlopeDown3, }; constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeUp0 = rotateTrackPP(kRightCurveSmallSteepSlopeDown3, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeUp1 = rotateTrackPP(kRightCurveSmallSteepSlopeDown1, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeUp2 = rotateTrackPP(kRightCurveSmallSteepSlopeDown2, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeUp3 = rotateTrackPP(kRightCurveSmallSteepSlopeDown0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 4> kLeftCurveSmallSteepSlopeUpTPP = { kLeftCurveSmallSteepSlopeUp0, kLeftCurveSmallSteepSlopeUp1, kLeftCurveSmallSteepSlopeUp2, kLeftCurveSmallSteepSlopeUp3, }; constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeDown0 = rotateTrackPP(kRightCurveSmallSteepSlopeUp3, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeDown1 = rotateTrackPP(kRightCurveSmallSteepSlopeUp1, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeDown2 = rotateTrackPP(kRightCurveSmallSteepSlopeUp2, kRotationTable1230); constexpr TrackPaintPiece kLeftCurveSmallSteepSlopeDown3 = rotateTrackPP(kRightCurveSmallSteepSlopeUp0, kRotationTable1230); constexpr std::array<TrackPaintPiece, 4> kLeftCurveSmallSteepSlopeDownTPP = { kLeftCurveSmallSteepSlopeDown0, kLeftCurveSmallSteepSlopeDown1, kLeftCurveSmallSteepSlopeDown2, kLeftCurveSmallSteepSlopeDown3, }; constexpr std::array<std::span<const TrackPaintPiece>, 26> kTrackPaintParts = { kStraightTPP, kDiagonalTPP, kLeftCurveVerySmallTPP, kRightCurveVerySmallTPP, kLeftCurveSmallTPP, kRightCurveSmallTPP, kLeftCurveTPP, kRightCurveTPP, kLeftCurveLargeTPP, kRightCurveLargeTPP, kDiagonalLeftCurveLargeTPP, kDiagonalRightCurveLargeTPP, kSBendLeftTPP, kSBendRightTPP, kStraightSlopeUpTPP, kStraightSlopeDownTPP, kStraightSteepSlopeUpTPP, kStraightSteepSlopeDownTPP, kLeftCurveSmallSlopeUpTPP, kRightCurveSmallSlopeUpTPP, kLeftCurveSmallSlopeDownTPP, kRightCurveSmallSlopeDownTPP, kLeftCurveSmallSteepSlopeUpTPP, kRightCurveSmallSteepSlopeUpTPP, kLeftCurveSmallSteepSlopeDownTPP, kRightCurveSmallSteepSlopeDownTPP, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTrainStation.cpp ```cpp #include "PaintTrainStation.h" #include "Map/StationElement.h" #include "Map/TileElement.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrainStationObject.h" #include "Paint.h" #include "PaintStation.h" #include "Ui/ViewportInteraction.h" #include "World/CompanyManager.h" namespace OpenLoco::Paint { // 0x004D79AC (0x00411456, 0x004115EB, 0x00411780, 0x00419915) static void paintTrainStationStyle0StraightTrack(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, const ImageId imageTranslucentBase) { const auto rotation = (session.getRotation() + elStation.rotation()) & 0x3; const auto* stationObj = ObjectManager::get<TrainStationObject>(elStation.objectId()); // This was part of paintStationCargo const auto unkPosHash = (session.getUnkPosition().x + session.getUnkPosition().y) / 32; const auto cargoOffsets = stationObj->getCargoOffsets(rotation, unkPosHash & 0x3); constexpr std::array<std::array<uint8_t, 4>, 4> cargoRotationFlags = { std::array<uint8_t, 4>{ 0x9, 0x5, 0x6, 0xA }, std::array<uint8_t, 4>{ 0x9, 0x5, 0x6, 0xA }, std::array<uint8_t, 4>{ 0xA, 0x6, 0x5, 0x9 }, std::array<uint8_t, 4>{ 0xA, 0x6, 0x5, 0x9 }, }; struct PaintDetail { uint32_t imageId; World::Pos3 bbOffset; World::Pos3 bbSize; }; struct PlatformImage { PaintDetail back; PaintDetail front; PaintDetail canopy; PaintDetail canopyTranslucent; }; constexpr PlatformImage neStationPlatformImage = { { TrainStation::ImageIds::Style0::straightBackNE, { 2, 2, 8 }, { 28, 4, 3 }, }, { TrainStation::ImageIds::Style0::straightFrontNE, { 2, 24, 8 }, { 28, 4, 3 }, }, { TrainStation::ImageIds::Style0::straightCanopyNE, { 2, 2, 26 }, { 28, 28, 1 }, }, { TrainStation::ImageIds::Style0::straightCanopyTranslucentNE, {}, {}, }, }; constexpr PlatformImage seStationPlatformImage = { { TrainStation::ImageIds::Style0::straightBackSE, { 2, 2, 8 }, { 4, 28, 3 }, }, { TrainStation::ImageIds::Style0::straightFrontSE, { 24, 2, 8 }, { 4, 28, 3 }, }, { TrainStation::ImageIds::Style0::straightCanopySE, { 2, 2, 26 }, { 28, 28, 1 }, }, { TrainStation::ImageIds::Style0::straightCanopyTranslucentSE, {}, {}, }, }; constexpr std::array<PlatformImage, 4> stationPlatformImages = { neStationPlatformImage, seStationPlatformImage, neStationPlatformImage, seStationPlatformImage, }; const auto& cargoFlags = cargoRotationFlags[rotation]; const auto& platformImages = stationPlatformImages[rotation]; const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); // Paint Back part of platform { World::Pos3 bbOffset = platformImages.back.bbOffset + heightOffset; session.addToPlotList4FD150(imageBase.withIndexOffset(platformImages.back.imageId), heightOffset, bbOffset, platformImages.back.bbSize); paintStationCargo(session, elStation, cargoFlags[0], 0xFFFFFFFF, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.back.bbSize); paintStationCargo(session, elStation, cargoFlags[1], 0xFFFFFFFF, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.back.bbSize); } // Paint Front part of platform { World::Pos3 bbOffset = platformImages.front.bbOffset + heightOffset; session.addToPlotList4FD150(imageBase.withIndexOffset(platformImages.front.imageId), heightOffset, bbOffset, platformImages.front.bbSize); paintStationCargo(session, elStation, cargoFlags[2], 0xFFFFFFFF, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.front.bbSize); paintStationCargo(session, elStation, cargoFlags[3], 0xFFFFFFFF, cargoOffsets, elStation.baseHeight(), bbOffset, platformImages.front.bbSize); } // Paint Canopy of platform { World::Pos3 bbOffset = platformImages.canopy.bbOffset + heightOffset; session.addToPlotListTrackRoadAddition(imageBase.withIndexOffset(platformImages.canopy.imageId), 1, heightOffset, bbOffset, platformImages.canopy.bbSize); session.attachToPrevious(imageTranslucentBase.withIndexOffset(platformImages.canopyTranslucent.imageId), { 0, 0 }); } session.set525CF8(session.get525CF8() | SegmentFlags::all); } // 0x00411AC6 static void paintTrainStationStyle0DiagonalTrack0NE(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, [[maybe_unused]] const ImageId imageTranslucentBase) { const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); World::Pos3 bbOffset = World::Pos3{ 2, 2, 8 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 2, 2, 3 }; session.addToPlotList4FD150(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalNE0), heightOffset, bbOffset, bbSize); } // 0x00411B09 static void paintTrainStationStyle0DiagonalTrack1NE(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, const ImageId imageTranslucentBase) { const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); // Platform { World::Pos3 bbOffset = World::Pos3{ 6, 6, 8 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 2, 2, 11 }; session.addToPlotList4FD150(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalNE1), heightOffset, bbOffset, bbSize); } // Canopy { World::Pos3 bbOffset = World::Pos3{ 6, 6, 26 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 2, 2, 1 }; session.addToPlotList4FD150(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalCanopyNE1), heightOffset, bbOffset, bbSize); session.attachToPrevious(imageTranslucentBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalCanopyTranslucentNE1), { 0, 0 }); } } // 0x00411BA6 static void paintTrainStationStyle0DiagonalTrack2NE([[maybe_unused]] PaintSession& session, [[maybe_unused]] const World::StationElement& elStation, [[maybe_unused]] const ImageId imageBase, [[maybe_unused]] const ImageId imageTranslucentBase) { return; } // 0x00411BA8 static void paintTrainStationStyle0DiagonalTrack3NE(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, [[maybe_unused]] const ImageId imageTranslucentBase) { const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); World::Pos3 bbOffset = World::Pos3{ 2, 2, 8 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 2, 2, 3 }; session.addToPlotList4FD150(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalNE3), heightOffset, bbOffset, bbSize); } // 0x00411BEB static void paintTrainStationStyle0DiagonalTrack0SE([[maybe_unused]] PaintSession& session, [[maybe_unused]] const World::StationElement& elStation, [[maybe_unused]] const ImageId imageBase, [[maybe_unused]] const ImageId imageTranslucentBase) { return; } // 0x00411BED static void paintTrainStationStyle0DiagonalTrack1SE(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, [[maybe_unused]] const ImageId imageTranslucentBase) { const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); World::Pos3 bbOffset = World::Pos3{ 28, 34, 8 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 2, 2, 3 }; session.addToPlotList4FD150(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalSE1), heightOffset, bbOffset, bbSize); } // 0x00411C30 static void paintTrainStationStyle0DiagonalTrack2SE(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, [[maybe_unused]] const ImageId imageTranslucentBase) { const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); World::Pos3 bbOffset = World::Pos3{ 34, 28, 8 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 2, 2, 3 }; session.addToPlotList4FD150(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalSE2), heightOffset, bbOffset, bbSize); } // 0x00411C73 static void paintTrainStationStyle0DiagonalTrack3SE(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, const ImageId imageTranslucentBase) { const World::Pos3 heightOffset(0, 0, elStation.baseHeight()); World::Pos3 bbOffset = World::Pos3{ 0, 0, 26 } + heightOffset; World::Pos3 bbSize = World::Pos3{ 30, 30, 1 }; session.addToPlotListTrackRoadAddition(imageBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalSE3), 1, heightOffset, bbOffset, bbSize); session.attachToPrevious(imageTranslucentBase.withIndexOffset(TrainStation::ImageIds::Style0::diagonalCanopyTranslucentSE3), { 0, 0 }); } // 0x004D7A5C static void paintTrainStationStyle0DiagonalTrack(PaintSession& session, const World::StationElement& elStation, const ImageId imageBase, const ImageId imageTranslucentBase) { const auto* elTrack = elStation.prev()->as<World::TrackElement>(); if (elTrack == nullptr) { return; } const auto rotation = (session.getRotation() + elStation.rotation()) & 0x3; const auto seqIndex = rotation & (1 << 1) ? 3 - elTrack->sequenceIndex() : elTrack->sequenceIndex(); if (rotation & (1 << 0)) { switch (seqIndex) { case 0: paintTrainStationStyle0DiagonalTrack0SE(session, elStation, imageBase, imageTranslucentBase); break; case 1: paintTrainStationStyle0DiagonalTrack1SE(session, elStation, imageBase, imageTranslucentBase); break; case 2: paintTrainStationStyle0DiagonalTrack2SE(session, elStation, imageBase, imageTranslucentBase); break; case 3: paintTrainStationStyle0DiagonalTrack3SE(session, elStation, imageBase, imageTranslucentBase); break; } } else { switch (seqIndex) { case 0: paintTrainStationStyle0DiagonalTrack0NE(session, elStation, imageBase, imageTranslucentBase); break; case 1: paintTrainStationStyle0DiagonalTrack1NE(session, elStation, imageBase, imageTranslucentBase); break; case 2: paintTrainStationStyle0DiagonalTrack2NE(session, elStation, imageBase, imageTranslucentBase); break; case 3: paintTrainStationStyle0DiagonalTrack3NE(session, elStation, imageBase, imageTranslucentBase); break; } } } // 0x004D78EC static void paintTrainStationStyle0(PaintSession& session, const World::StationElement& elStation, const uint8_t trackId, [[maybe_unused]] const uint8_t sequenceIndex, const ImageId imageBase, const ImageId imageGlassBase) { switch (trackId) { case 0: paintTrainStationStyle0StraightTrack(session, elStation, imageBase, imageGlassBase); break; case 1: // Vanilla had hard to reach code for diagonal train stations paintTrainStationStyle0DiagonalTrack(session, elStation, imageBase, imageGlassBase); break; default: return; } } // 0x0048B34D void paintTrainStation(PaintSession& session, const World::StationElement& elStation) { session.setItemType(Ui::ViewportInteraction::InteractionItem::trainStation); const auto* stationObj = ObjectManager::get<TrainStationObject>(elStation.objectId()); session.setOccupiedAdditionSupportSegments(SegmentFlags::all); const auto* elTrack = elStation.prev()->as<World::TrackElement>(); if (elTrack == nullptr) { return; } const auto companyColour = CompanyManager::getCompanyColour(elTrack->owner()); auto translucentColour = Colours::getTranslucent(companyColour); if (!stationObj->hasFlags(TrainStationFlags::recolourable)) { translucentColour = ExtColour::unk2E; } ImageId imageIdbase{}; // 0x0112C720 ImageId imageIdTranslucentBase{}; // 0x0112C724 if (elStation.isGhost() || elStation.isAiAllocated()) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); imageIdbase = Gfx::applyGhostToImage(stationObj->imageOffsets[elStation.sequenceIndex()]); imageIdTranslucentBase = ImageId{ stationObj->imageOffsets[elStation.sequenceIndex()] }.withTranslucency(ExtColour::unk2F); // TODO: apply company colour if playerCompanyID != elTrack.owner()? } else { imageIdbase = ImageId{ stationObj->imageOffsets[elStation.sequenceIndex()], companyColour }; imageIdTranslucentBase = ImageId{ stationObj->imageOffsets[elStation.sequenceIndex()] }.withTranslucency(translucentColour); } switch (stationObj->paintStyle) { case 0: paintTrainStationStyle0(session, elStation, elTrack->trackId(), elTrack->sequenceIndex(), imageIdbase, imageIdTranslucentBase); break; default: // Track only have 1 style of drawing break; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTrainStation.h ```h #pragma once namespace OpenLoco::World { struct StationElement; } namespace OpenLoco::Paint { struct PaintSession; void paintTrainStation(PaintSession& session, const World::StationElement& elStation); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTree.cpp ```cpp #include "PaintTree.h" #include "Config.h" #include "Graphics/Colour.h" #include "Graphics/RenderTarget.h" #include "Map/TreeElement.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "Paint.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" using namespace OpenLoco::Interop; using namespace OpenLoco::Ui::ViewportInteraction; namespace OpenLoco::Paint { constexpr std::array<uint8_t, 6> _50076A = { 3, 0, 1, 2, 1, 4 }; constexpr std::array<bool, 6> _500770 = { true, true, false, false, true, true }; constexpr std::array<World::Pos2, 4> kTreeQuadrantOffset = { World::Pos2{ 7, 7 }, World::Pos2{ 7, 23 }, World::Pos2{ 23, 23 }, World::Pos2{ 23, 7 }, }; // 0x004BAEDA void paintTree(PaintSession& session, const World::TreeElement& elTree) { session.setItemType(InteractionItem::tree); const auto* treeObj = ObjectManager::get<TreeObject>(elTree.treeObjectId()); const uint8_t viewableRotation = (session.getRotation() + elTree.rotation()) & 0x3; const uint32_t treeFrameNum = (viewableRotation % treeObj->numRotations) + elTree.growth() * treeObj->numRotations; uint8_t season = elTree.season(); bool hasImage2 = false; uint32_t imageIndex2 = 0; uint8_t noiseMask = 0; if (elTree.unk7l() != 7) { hasImage2 = true; season = _50076A[season]; noiseMask = elTree.unk7l() + 1; auto image2Season = elTree.season(); if (_500770[image2Season]) { image2Season = season; season = elTree.season(); noiseMask = 8 - noiseMask; } auto imageId = elTree.hasSnow() ? treeObj->snowSprites[image2Season] : treeObj->sprites[image2Season]; imageIndex2 = treeFrameNum + imageId; } const auto seasonBaseImageIndex = elTree.hasSnow() ? treeObj->snowSprites[season] : treeObj->sprites[season]; std::optional<ImageId> shadowImageId = std::nullopt; if (treeObj->hasFlags(TreeObjectFlags::hasShadow)) { shadowImageId = ImageId{ treeObj->shadowImageOffset + treeFrameNum + seasonBaseImageIndex }.withTranslucency(ExtColour::unk32); } const uint8_t quadrant = (elTree.quadrant() + session.getRotation()) % 4; const auto imageOffset = World::Pos3(kTreeQuadrantOffset[quadrant].x, kTreeQuadrantOffset[quadrant].y, elTree.baseHeight()); const int16_t boundBoxSizeZ = std::min(elTree.clearZ() - elTree.baseZ(), 32) * World::kSmallZStep - 3; const uint32_t imageIndex1 = treeFrameNum + seasonBaseImageIndex; ImageId imageId1{}; ImageId imageId2{}; if (elTree.isGhost()) { session.setItemType(InteractionItem::noInteraction); imageId2 = Gfx::applyGhostToImage(imageIndex2); imageId1 = Gfx::applyGhostToImage(imageIndex1); } else if (treeObj->colours != 0) { // No vanilla object has this property set const auto colour = static_cast<Colour>(elTree.colour()); imageId2 = ImageId{ imageIndex2, colour }.withNoiseMask(noiseMask); imageId1 = ImageId{ imageIndex1, colour }; } else { imageId1 = ImageId{ imageIndex1 }; imageId2 = ImageId{ imageIndex2 }.withNoiseMask(noiseMask); } if (shadowImageId) { if (session.getRenderTarget()->zoomLevel <= 1) { session.addToPlotListAsParent(*shadowImageId, imageOffset, imageOffset, { 18, 18, 1 }); } } session.addToPlotListAsParent(imageId1, imageOffset, imageOffset + World::Pos3(0, 0, 2), { 2, 2, boundBoxSizeZ }); if (hasImage2) { session.addToPlotListAsChild(imageId2, imageOffset, imageOffset + World::Pos3(0, 0, 2), { 2, 2, boundBoxSizeZ }); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintTree.h ```h #pragma once namespace OpenLoco::World { struct TreeElement; } namespace OpenLoco::Paint { struct PaintSession; void paintTree(PaintSession& session, const World::TreeElement& elTree); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintVehicle.cpp ```cpp #include "PaintVehicle.h" #include "Config.h" #include "Graphics/Colour.h" #include "Objects/ObjectManager.h" #include "Objects/VehicleObject.h" #include "Paint.h" #include "Ui/ViewportInteraction.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include "World/CompanyManager.h" #include <OpenLoco/Math/Trigonometry.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Vehicles; namespace OpenLoco::Paint { // 0x00500160 constexpr Pitch kReversePitch[13]{ Pitch::flat, Pitch::down6deg, Pitch::down12deg, Pitch::down18deg, Pitch::down25deg, Pitch::up6deg, Pitch::up12deg, Pitch::up18deg, Pitch::up25deg, Pitch::down10deg, Pitch::up10deg, Pitch::down20deg, Pitch::up20deg, }; // Bounding box offset and size scaling factors indexed by yaw angle (0-31) // These factors are multiplied by bodyLength and divided by 256 // Used in paintBody to calculate vehicle bounding boxes based on orientation struct BoundingBoxFactors { int8_t xOffsetFactor; int8_t yOffsetFactor; int8_t xSizeFactor; int8_t ySizeFactor; }; // 0x005001B4 static constexpr std::array<BoundingBoxFactors, 32> kBoundingBoxFactorsByYaw = { { { -30, -3, 60, 6 }, { -29, -4, 58, 8 }, { -28, -6, 56, 12 }, { -26, -6, 56, 12 }, { -24, -6, 56, 12 }, { -22, -11, 48, 24 }, { -20, -20, 40, 40 }, { -20, -20, 45, 45 }, { -16, -16, 46, 46 }, { -20, -20, 45, 45 }, { -20, -20, 40, 40 }, { -11, -22, 24, 48 }, { -6, -24, 12, 56 }, { -6, -26, 12, 56 }, { -6, -28, 12, 56 }, { -4, -29, 8, 58 }, { -3, -30, 6, 60 }, { -4, -29, 8, 58 }, { -5, -28, 10, 57 }, { -2, -28, 6, 54 }, { -2, -20, 8, 50 }, { -2, -20, 8, 45 }, { -4, -15, 12, 40 }, { -5, -12, 17, 32 }, { -5, -5, 25, 25 }, { -12, -5, 32, 17 }, { -15, -4, 40, 12 }, { -20, -2, 45, 8 }, { -20, -2, 50, 8 }, { -28, -2, 54, 6 }, { -28, -5, 57, 10 }, { -29, -4, 58, 8 }, } }; // 0x004B0CFC static void paintBogie(PaintSession& session, VehicleBogie* bogie) { auto* vehObject = ObjectManager::get<VehicleObject>(bogie->objectId); if (bogie->objectSpriteType == SpriteIndex::null) { return; } auto& sprite = vehObject->bogieSprites[bogie->objectSpriteType]; uint8_t yaw = (bogie->spriteYaw + (session.getRotation() << 4)) & 0x3F; auto pitch = bogie->spritePitch; if (bogie->has38Flags(Flags38::isReversed)) { // Flip the highest bit to reverse the yaw yaw ^= (1 << 5); pitch = kReversePitch[static_cast<uint8_t>(bogie->spritePitch)]; } auto yawIndex = (yaw >> 1) & 0x1F; switch (pitch) { case Pitch::flat: case Pitch::up12deg: case Pitch::up10deg: case Pitch::up25deg: case Pitch::up20deg: break; default: if (sprite.hasFlags(BogieSpriteFlags::rotationalSymmetry)) { // Rotational symmetry will have 1 fewer bits of yaw yawIndex ^= (1 << 4); } else { yawIndex ^= (1 << 5); } break; } switch (pitch) { case Pitch::flat: { if (sprite.hasFlags(BogieSpriteFlags::rotationalSymmetry)) { yawIndex &= 0xF; } const auto imageIndex = sprite.numFramesPerRotation * yawIndex + bogie->animationIndex + sprite.flatImageIds; ImageId imageId{}; if (bogie->has38Flags(Flags38::isGhost)) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); imageId = Gfx::applyGhostToImage(imageIndex); } else if (bogie->hasVehicleFlags(VehicleFlags::unk_5)) { imageId = ImageId(imageIndex, ExtColour::unk74); } else if (bogie->getTransportMode() == TransportMode::air) { // Airplane bogies are the shadows of the plane if (bogie->has38Flags(Flags38::isGhost)) { // Ghosts don't cast shadows return; } session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); imageId = ImageId(imageIndex).withTranslucency(ExtColour::unk32); session.addToPlotList4FD200(imageId, { 0, 0, bogie->position.z }, { 8, 8, static_cast<coord_t>(bogie->position.z + 6) }, { 48, 48, 2 }); return; } else { imageId = ImageId(imageIndex, bogie->colourScheme); } if (sprite.hasFlags(BogieSpriteFlags::largerBoundingBox)) { // larger sprite session.addToPlotListAsParent(imageId, { 0, 0, bogie->position.z }, { -9, -9, static_cast<coord_t>(bogie->position.z + 3) }, { 18, 18, 5 }); } else { // smaller sprite session.addToPlotListAsParent(imageId, { 0, 0, bogie->position.z }, { -6, -6, static_cast<coord_t>(bogie->position.z + 3) }, { 12, 12, 1 }); } break; } case Pitch::up12deg: case Pitch::up10deg: case Pitch::down12deg: case Pitch::down10deg: { const auto imageIndex = sprite.numFramesPerRotation * yawIndex + bogie->animationIndex + sprite.gentleImageIds; ImageId imageId{}; if (bogie->has38Flags(Flags38::isGhost)) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); imageId = Gfx::applyGhostToImage(imageIndex); } else { imageId = ImageId(imageIndex, bogie->colourScheme); } if (sprite.hasFlags(BogieSpriteFlags::largerBoundingBox)) { // larger sprite session.addToPlotListAsParent(imageId, { 0, 0, bogie->position.z }, { -8, -8, static_cast<coord_t>(bogie->position.z + 3) }, { 16, 16, 1 }); } else { // smaller sprite session.addToPlotListAsParent(imageId, { 0, 0, bogie->position.z }, { -6, -6, static_cast<coord_t>(bogie->position.z + 3) }, { 12, 12, 1 }); } break; } default: { const auto imageIndex = sprite.numFramesPerRotation * yawIndex + bogie->animationIndex + sprite.steepImageIds; ImageId imageId{}; if (bogie->has38Flags(Flags38::isGhost)) { session.setItemType(Ui::ViewportInteraction::InteractionItem::noInteraction); imageId = Gfx::applyGhostToImage(imageIndex); } else { imageId = ImageId(imageIndex, bogie->colourScheme); } session.addToPlotListAsParent(imageId, { 0, 0, bogie->position.z }, { -6, -6, static_cast<coord_t>(bogie->position.z + 3) }, { 12, 12, 1 }); break; } } } // 0x004B103C static void paintBody(PaintSession& session, VehicleBody* body) { auto* vehObject = ObjectManager::get<VehicleObject>(body->objectId); if (body->objectSpriteType == SpriteIndex::null) { return; } auto& sprite = vehObject->bodySprites[body->objectSpriteType]; uint8_t yaw = (body->spriteYaw + (session.getRotation() << 4)) & 0x3F; auto originalYaw = yaw; // edi auto pitch = body->spritePitch; if (body->has38Flags(Flags38::isReversed)) { yaw ^= (1 << 5); pitch = kReversePitch[static_cast<uint8_t>(body->spritePitch)]; } uint32_t bodyImageIndex = getBodyImageIndex(sprite, pitch, yaw, body->animationFrame, body->cargoFrame); std::optional<uint32_t> brakingImageIndex = {}; if (sprite.hasFlags(BodySpriteFlags::hasBrakingLights)) { brakingImageIndex = getBrakingImageIndex(sprite, pitch, yaw); } World::Pos3 offsets = { 0, 0, body->position.z }; World::Pos3 boundBoxOffsets; World::Pos3 boundBoxSize; if ((body->getTransportMode() == TransportMode::air) || (body->getTransportMode() == TransportMode::water)) { boundBoxOffsets = { -8, -8, static_cast<int16_t>(body->position.z + 11) }; boundBoxSize = { 48, 48, 15 }; } else { auto& componentObject = vehObject->carComponents[body->bodyIndex]; auto overhangLength = componentObject.frontBogiePosition - componentObject.backBogiePosition; if (body->has38Flags(Flags38::isReversed)) { overhangLength = -overhangLength; } if (componentObject.bodySpriteInd & SpriteIndex::isReversed) { overhangLength = -overhangLength; } const auto overhangOffset = Math::Trigonometry::computeXYVector(overhangLength, originalYaw) / 8; boundBoxOffsets.x = overhangOffset.x; boundBoxOffsets.y = overhangOffset.y; const auto bodyLength = sprite.halfLength * 2 - 4; originalYaw &= 0x1F; const auto& bboxFactors = kBoundingBoxFactorsByYaw[originalYaw]; boundBoxOffsets.x += (bboxFactors.xOffsetFactor * bodyLength) >> 8; boundBoxOffsets.y += (bboxFactors.yOffsetFactor * bodyLength) >> 8; boundBoxOffsets.z = body->position.z + 11; boundBoxSize = { static_cast<coord_t>((bboxFactors.xSizeFactor * bodyLength) >> 8), static_cast<coord_t>((bboxFactors.ySizeFactor * bodyLength) >> 8), 15 }; } ImageId imageId{}; if (body->has38Flags(Flags38::isGhost)) { imageId = Gfx::applyGhostToImage(bodyImageIndex); } else if (body->hasVehicleFlags(VehicleFlags::unk_5)) { imageId = ImageId(bodyImageIndex, ExtColour::unk74); } else { imageId = ImageId(bodyImageIndex, body->colourScheme); } session.addToPlotList4FD200(imageId, offsets, boundBoxOffsets, boundBoxSize); if (brakingImageIndex) { Vehicle train(body->head); if (train.veh2->brakeLightTimeout != 0 && !body->has38Flags(Flags38::isGhost) && !body->hasVehicleFlags(VehicleFlags::unk_5)) { session.attachToPrevious(ImageId{ *brakingImageIndex }, { 0, 0 }); } } } // 0x004B0CCE void paintVehicleEntity(PaintSession& session, Vehicles::VehicleBase* base) { if (base->has38Flags(Flags38::isGhost)) { if (base->owner != CompanyManager::getControllingId()) { return; } } switch (base->getSubType()) { case VehicleEntityType::head: case VehicleEntityType::vehicle_1: case VehicleEntityType::vehicle_2: case VehicleEntityType::tail: break; case VehicleEntityType::bogie: paintBogie(session, base->asVehicleBogie()); break; case VehicleEntityType::body_start: case VehicleEntityType::body_continued: paintBody(session, base->asVehicleBody()); break; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintVehicle.h ```h #pragma once #include "Types.hpp" namespace OpenLoco::Vehicles { struct VehicleBase; } namespace OpenLoco::Paint { struct PaintSession; void paintVehicleEntity(PaintSession& session, Vehicles::VehicleBase* base); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintWall.cpp ```cpp #include "PaintWall.h" #include "Graphics/Colour.h" #include "Map/WallElement.h" #include "Objects/ObjectManager.h" #include "Objects/WallObject.h" #include "Paint.h" #include "ScenarioManager.h" #include "Ui/ViewportInteraction.h" #include <cassert> using namespace OpenLoco::Interop; using namespace OpenLoco::Ui::ViewportInteraction; namespace OpenLoco::Paint { static constexpr World::Pos3 kOffsets[4] = { { 0, 0, 0 }, { 1, 31, 0 }, { 31, 0, 0 }, { 2, 1, 0 }, }; static constexpr World::Pos3 kBBoxOffsets[4] = { { 1, 1, 1 }, { 2, 30, 1 }, { 30, 2, 1 }, { 1, 1, 1 }, }; static constexpr World::Pos3 kBBoxLengths[4] = { { 1, 28, 0 }, { 29, 1, 0 }, { 1, 29, 0 }, { 28, 1, 0 }, }; using namespace WallObj::ImageIds; static constexpr std::array<std::array<std::array<uint8_t, 3>, 4>, 2> kImageOffsets = { std::array<std::array<uint8_t, 3>, 4>{ std::array<uint8_t, 3>{ kSlopedNE, kSlopedSW, kFlatNE }, std::array<uint8_t, 3>{ kSlopedSE, kSlopedNW, kFlatSE }, std::array<uint8_t, 3>{ kSlopedSW, kSlopedNE, kFlatNE }, std::array<uint8_t, 3>{ kSlopedNW, kSlopedSE, kFlatSE }, }, std::array<std::array<uint8_t, 3>, 4>{ std::array<uint8_t, 3>{ kSlopedNE, kSlopedSW, kFlatNE }, std::array<uint8_t, 3>{ kGlassSlopedSE, kGlassSlopedNW, kGlassFlatSE }, std::array<uint8_t, 3>{ kGlassSlopedSW, kGlassSlopedNE, kGlassFlatNE }, std::array<uint8_t, 3>{ kSlopedNW, kSlopedSE, kFlatSE }, } }; static constexpr std::array<std::array<uint8_t, 3>, 4> kImageOffsetsGlass = { std::array<uint8_t, 3>{ kGlassSlopedNE, kGlassSlopedSW, kGlassFlatNE }, std::array<uint8_t, 3>{ kGlassSlopedSE, kGlassSlopedNW, kGlassFlatSE }, std::array<uint8_t, 3>{ kGlassSlopedSW, kGlassSlopedNE, kGlassFlatNE }, std::array<uint8_t, 3>{ kGlassSlopedNW, kGlassSlopedSE, kGlassFlatSE }, }; static constexpr uint8_t slopeFlagsToIndex(EdgeSlope flags) { // Slope flags to index are 0 = downwards, 1 == upwards, 2 == no slope if ((flags & EdgeSlope::downwards) != EdgeSlope::none) { return 0; } if ((flags & EdgeSlope::upwards) != EdgeSlope::none) { return 1; } return 2; } static uint32_t getWallImageIndexOffset(const World::WallElement& elWall, int32_t rotation, bool isTwoSided) { const auto index = slopeFlagsToIndex(elWall.getSlopeFlags()); return kImageOffsets[isTwoSided][rotation][index]; } static uint32_t getWallImageIndexOffsetGlass(const World::WallElement& elWall, int32_t rotation) { const auto index = slopeFlagsToIndex(elWall.getSlopeFlags()); return kImageOffsetsGlass[rotation][index]; } static ImageId getWallImageId(ImageIndex imageIndex, bool isGhost, const World::WallElement& elWall, const WallObject* wallObject) { if (isGhost) { return Gfx::applyGhostToImage(imageIndex); } ImageId imageId{ imageIndex }; if ((wallObject->flags & WallObjectFlags::hasPrimaryColour) != WallObjectFlags::none) { imageId = imageId.withPrimary(elWall.getPrimaryColour()); } if ((wallObject->flags & WallObjectFlags::hasSecondaryColour) != WallObjectFlags::none) { imageId = imageId.withSecondary(elWall.getSecondaryColour()); } return imageId; } // 0x004C3D7C void paintWall(PaintSession& session, const World::WallElement& elWall) { const auto* wallObject = ObjectManager::get<WallObject>(elWall.wallObjectId()); assert(wallObject != nullptr); const auto isGhost = elWall.isGhost(); session.setItemType(isGhost ? InteractionItem::noInteraction : InteractionItem::wall); const coord_t objectHeight = kSmallZStep * wallObject->height - 2; const int32_t rotation = (session.getRotation() + elWall.rotation()) & 0x3; const auto heightOffset = World::Pos3{ 0, 0, elWall.baseHeight() }; const auto offset = kOffsets[rotation] + heightOffset; const auto bboxOffset = kBBoxOffsets[rotation] + heightOffset; const auto bboxLength = kBBoxLengths[rotation] + World::Pos3{ 0, 0, objectHeight }; const auto isTwoSided = (wallObject->flags & WallObjectFlags::twoSided) != WallObjectFlags::none; const auto imageOffset = getWallImageIndexOffset(elWall, rotation, isTwoSided); const auto imageIndex = wallObject->sprite + imageOffset; if ((wallObject->flags & WallObjectFlags::hasGlass) != WallObjectFlags::none) { const auto imageId = getWallImageId(imageIndex, isGhost, elWall, wallObject); session.addToPlotListAsParent( imageId, offset, bboxOffset, bboxLength); if (!isGhost) { const auto blendColour = Colours::getGlass(imageId.getPrimary()); const auto glassImageIndex = wallObject->sprite + getWallImageIndexOffsetGlass(elWall, rotation); session.addToPlotListAsChild( ImageId(glassImageIndex).withTranslucency(blendColour), offset, bboxOffset, bboxLength); } } else { const auto imageId = getWallImageId(imageIndex, isGhost, elWall, wallObject); session.addToPlotListAsParent( imageId, offset, bboxOffset, bboxLength); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Paint/PaintWall.h ```h #pragma once namespace OpenLoco::World { struct WallElement; } namespace OpenLoco::Paint { struct PaintSession; void paintWall(PaintSession& session, const World::WallElement& elWall); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/S5/Limits.h ```h #pragma once #include <cstddef> namespace OpenLoco::S5::Limits { constexpr size_t kMaxMessages = 199; constexpr size_t kMaxCompanies = 15; constexpr size_t kMinTowns = 1; constexpr size_t kMaxTowns = 80; constexpr size_t kMaxIndustries = 128; constexpr size_t kMaxStations = 1024; constexpr size_t kMaxEntities = 20000; constexpr size_t kMaxAnimations = 8192; constexpr size_t kMaxWaves = 64; constexpr size_t kMaxUserStrings = 2048; constexpr size_t kMaxVehicles = 1000; constexpr size_t kMaxRoutingsPerVehicle = 64; // The number of orders appears to be the number of routings minus a null byte (OrderEnd) constexpr size_t kMaxOrdersPerVehicle = kMaxRoutingsPerVehicle - 1; constexpr size_t kMaxOrders = 256000; constexpr size_t kNumEntityLists = 7; // There is a separate pool of 200 entities dedicated for money constexpr size_t kMaxMoneyEntities = 200; // This is the main pool for everything that isn't money constexpr size_t maxNormalEntities = kMaxEntities - kMaxMoneyEntities; // Money is not counted in this limit constexpr size_t kMaxMiscEntities = 4000; constexpr size_t kMaxStationCargoDensity = 15; constexpr size_t kMaxInterfaceObjects = 1; constexpr size_t kMaxSoundObjects = 128; constexpr size_t kMaxCurrencyObjects = 1; constexpr size_t kMaxSteamObjects = 32; constexpr size_t kMaxRockObjects = 8; constexpr size_t kMaxWaterObjects = 1; constexpr size_t kMaxSurfaceObjects = 32; constexpr size_t kMaxTownNamesObjects = 1; constexpr size_t kMaxCargoObjects = 32; constexpr size_t kMaxWallObjects = 32; constexpr size_t kMaxTrainSignalObjects = 16; constexpr size_t kMaxLevelCrossingObjects = 4; constexpr size_t kMaxStreetLightObjects = 1; constexpr size_t kMaxTunnelObjects = 16; constexpr size_t kMaxBridgeObjects = 8; constexpr size_t kMaxTrainStationObjects = 16; constexpr size_t kMaxTrackExtraObjects = 8; constexpr size_t kMaxTrackObjects = 8; constexpr size_t kMaxRoadStationObjects = 16; constexpr size_t kMaxRoadExtraObjects = 4; constexpr size_t kMaxRoadObjects = 8; constexpr size_t kMaxAirportObjects = 8; constexpr size_t kMaxDockObjects = 8; constexpr size_t kMaxVehicleObjects = 224; constexpr size_t kMaxTreeObjects = 64; constexpr size_t kMaxSnowObjects = 1; constexpr size_t kMaxClimateObjects = 1; constexpr size_t kMaxHillShapesObjects = 1; constexpr size_t kMaxBuildingObjects = 128; constexpr size_t kMaxScaffoldingObjects = 1; constexpr size_t kMaxIndustryObjects = 16; constexpr size_t kMaxRegionObjects = 1; constexpr size_t kMaxCompetitorObjects = 32; constexpr size_t kMaxScenarioTextObjects = 1; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/S5/S5.cpp ```cpp #define DO_TITLE_SEQUENCE_CHECKS #include "S5.h" #include "Audio/Audio.h" #include "EditorController.h" #include "Entities/EntityManager.h" #include "Game.h" #include "GameException.hpp" #include "GameState.h" #include "GameStateFlags.h" #include "Graphics/DrawingContext.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Gui.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Objects/LandObject.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "Objects/ScenarioTextObject.h" #include "Objects/WaterObject.h" #include "OpenLoco.h" #include "SawyerStream.h" #include "ScenarioManager.h" #include "ScenarioOptions.h" #include "SceneManager.h" #include "Ui/ProgressBar.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Core/Stream.hpp> #include <OpenLoco/Diagnostics/Logging.h> #include <OpenLoco/Interop/Interop.hpp> #include <fstream> #include <iomanip> using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::Ui; using namespace OpenLoco::Diagnostics; namespace OpenLoco::S5 { constexpr uint32_t kCurrentVersion = 0x62262; constexpr uint32_t kMagicNumber = 0x62300; static loco_global<GameState, 0x00525E18> _gameState; static loco_global<Options, 0x009C8714> _activeOptions; static loco_global<Header, 0x009CCA34> _header; static loco_global<uint8_t, 0x0050C197> _loadErrorCode; static loco_global<StringId, 0x0050C198> _loadErrorMessage; // TODO: move this? static std::vector<ObjectHeader> _loadErrorObjectsList; static bool exportGameState(Stream& stream, const S5File& file, const std::vector<ObjectHeader>& packedObjects); constexpr bool hasSaveFlags(SaveFlags flags, SaveFlags flagsToTest) { return (flags & flagsToTest) != SaveFlags::none; } constexpr bool hasLoadFlags(LoadFlags flags, LoadFlags flagsToTest) { return (flags & flagsToTest) != LoadFlags::none; } static Header prepareHeader(SaveFlags flags, size_t numPackedObjects) { Header result; std::memset(&result, 0, sizeof(result)); result.type = S5Type::savedGame; if (hasSaveFlags(flags, SaveFlags::landscape)) { result.type = S5Type::landscape; } if (hasSaveFlags(flags, SaveFlags::scenario)) { result.type = S5Type::scenario; } result.numPackedObjects = static_cast<uint16_t>(numPackedObjects); result.version = kCurrentVersion; result.magic = kMagicNumber; if (hasSaveFlags(flags, SaveFlags::raw)) { result.flags |= HeaderFlags::isRaw; } if (hasSaveFlags(flags, SaveFlags::dump)) { result.flags |= HeaderFlags::isDump; } if (!hasSaveFlags(flags, SaveFlags::scenario) && !hasSaveFlags(flags, SaveFlags::raw) && !hasSaveFlags(flags, SaveFlags::dump)) { result.flags |= HeaderFlags::hasSaveDetails; } return result; } static PaletteIndex_t getPreviewColourByTilePos(const TilePos2& pos) { PaletteIndex_t colour = PaletteIndex::transparent; auto tile = TileManager::get(pos); for (auto& el : tile) { switch (el.type()) { case ElementType::surface: { auto* surfaceEl = el.as<SurfaceElement>(); if (surfaceEl == nullptr) { continue; } if (surfaceEl->water() == 0) { const auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); const auto* landImage = Gfx::getG1Element(landObj->mapPixelImage); auto offset = surfaceEl->baseZ() / kMicroToSmallZStep * 2; colour = landImage->offset[offset]; } else { const auto* waterObj = ObjectManager::get<WaterObject>(); const auto* waterImage = Gfx::getG1Element(waterObj->mapPixelImage); auto offset = (surfaceEl->water() * kMicroToSmallZStep - surfaceEl->baseZ()) / 2; colour = waterImage->offset[offset - 2]; } break; } case ElementType::building: case ElementType::road: colour = PaletteIndex::mutedDarkRed7; break; case ElementType::industry: colour = PaletteIndex::mutedPurple7; break; case ElementType::tree: colour = PaletteIndex::green6; break; default: break; } } return colour; } // 0x0046DB4C void drawScenarioPreviewImage() { auto& options = *_activeOptions; const auto kPreviewSize = sizeof(options.preview[0]); const auto kMapSkipFactor = kMapRows / kPreviewSize; for (auto y = 0U; y < kPreviewSize; y++) { for (auto x = 0U; x < kPreviewSize; x++) { auto pos = TilePos2(kMapColumns - (x + 1) * kMapSkipFactor + 1, y * kMapSkipFactor + 1); options.preview[y][x] = getPreviewColourByTilePos(pos); } } } static void drawSavePreviewImage(void* pixels, Ui::Size size) { auto mainViewport = WindowManager::getMainViewport(); if (mainViewport == nullptr) { return; } const auto mapPosXY = mainViewport->getCentreMapPosition(); const auto mapPosXYZ = Pos3(mapPosXY.x, mapPosXY.y, coord_t{ TileManager::getHeight(mapPosXY) }); Viewport saveVp{}; saveVp.x = 0; saveVp.y = 0; saveVp.width = size.width; saveVp.height = size.height; saveVp.flags = ViewportFlags::town_names_displayed | ViewportFlags::station_names_displayed; saveVp.zoom = ZoomLevel::half; saveVp.viewWidth = size.width << saveVp.zoom; saveVp.viewHeight = size.height << saveVp.zoom; const auto viewPos = saveVp.centre2dCoordinates(mapPosXYZ); saveVp.viewX = viewPos.x; saveVp.viewY = viewPos.y; Gfx::RenderTarget rt{}; rt.bits = static_cast<uint8_t*>(pixels); rt.x = 0; rt.y = 0; rt.width = size.width; rt.height = size.height; rt.pitch = 0; rt.zoomLevel = saveVp.zoom; auto& drawingEngine = Gfx::getDrawingEngine(); auto& drawingCtx = drawingEngine.getDrawingContext(); drawingCtx.pushRenderTarget(rt); saveVp.render(drawingCtx); drawingCtx.popRenderTarget(); } // 0x004471A4 static std::unique_ptr<SaveDetails> prepareSaveDetails(GameState& gameState) { auto saveDetails = std::make_unique<SaveDetails>(); const auto& playerCompany = gameState.companies[gameState.playerCompanies[0]]; StringManager::formatString(saveDetails->company, sizeof(saveDetails->company), playerCompany.name); StringManager::formatString(saveDetails->owner, sizeof(saveDetails->owner), playerCompany.ownerName); saveDetails->date = gameState.currentDay; saveDetails->performanceIndex = playerCompany.performanceIndex; saveDetails->challengeProgress = playerCompany.challengeProgress; saveDetails->challengeFlags = playerCompany.challengeFlags; std::strncpy(saveDetails->scenario, gameState.scenarioName, sizeof(saveDetails->scenario)); drawSavePreviewImage(saveDetails->image, { 250, 200 }); return saveDetails; } /** * Removes all tile elements that have the ghost flag set. * Assumes all elements are organised in tile order. */ static void removeGhostElements(std::vector<TileElement>& elements) { for (size_t i = 0; i < elements.size(); i++) { if (elements[i].isGhost()) { if (elements[i].isLast()) { if (i == 0 || elements[i - 1].isLast()) { // First element of tile, can not remove... } else { elements[i - 1].setLast(true); elements.erase(elements.begin() + i); i--; } } else { elements.erase(elements.begin() + i); i--; } } } } static std::unique_ptr<S5File> prepareGameState(SaveFlags flags, const std::vector<ObjectHeader>& requiredObjects, const std::vector<ObjectHeader>& packedObjects) { auto mainWindow = WindowManager::getMainWindow(); auto savedView = mainWindow != nullptr && mainWindow->viewports[0] != nullptr ? mainWindow->viewports[0]->toSavedView() : SavedViewSimple{ 0, 0, 0, 0 }; auto file = std::make_unique<S5File>(); file->header = prepareHeader(flags, packedObjects.size()); if (file->header.type == S5Type::scenario || file->header.type == S5Type::landscape) { file->scenarioOptions = std::make_unique<Options>(_activeOptions); } if (file->header.hasFlags(HeaderFlags::hasSaveDetails)) { file->saveDetails = prepareSaveDetails(_gameState); } std::memcpy(file->requiredObjects, requiredObjects.data(), sizeof(file->requiredObjects)); file->gameState = _gameState; file->gameState.savedViewX = savedView.viewX; file->gameState.savedViewY = savedView.viewY; file->gameState.savedViewZoom = static_cast<uint8_t>(savedView.zoomLevel); file->gameState.savedViewRotation = savedView.rotation; file->gameState.magicNumber = kMagicNumber; // Match implementation at 0x004437FC auto tileElements = TileManager::getElements(); file->tileElements.resize(tileElements.size()); std::memcpy(file->tileElements.data(), tileElements.data(), tileElements.size_bytes()); removeGhostElements(file->tileElements); return file; } static constexpr bool shouldPackObjects(SaveFlags flags) { return (flags & SaveFlags::raw) == SaveFlags::none && (flags & SaveFlags::dump) == SaveFlags::none && (flags & SaveFlags::packCustomObjects) != SaveFlags::none && !SceneManager::isNetworked(); } // 0x00441C26 bool exportGameStateToFile(const fs::path& path, SaveFlags flags) { FileStream fs(path, StreamMode::write); return exportGameStateToFile(fs, flags); } bool exportGameStateToFile(Stream& stream, SaveFlags flags) { if ((flags & SaveFlags::isAutosave) == SaveFlags::none) { Ui::ProgressBar::begin(StringIds::please_wait); Ui::ProgressBar::setProgress(20); } if ((flags & SaveFlags::noWindowClose) == SaveFlags::none && (flags & SaveFlags::raw) == SaveFlags::none && (flags & SaveFlags::dump) == SaveFlags::none) { WindowManager::closeConstructionWindows(); } if ((flags & SaveFlags::raw) == SaveFlags::none) { TileManager::reorganise(); EntityManager::resetSpatialIndex(); EntityManager::zeroUnused(); StationManager::zeroUnused(); Vehicles::OrderManager::zeroUnusedOrderTable(); } if ((flags & SaveFlags::isAutosave) == SaveFlags::none) { Ui::ProgressBar::setProgress(40); } bool saveResult; { auto requiredObjects = ObjectManager::getHeaders(); std::vector<ObjectHeader> packedObjects; if (shouldPackObjects(flags)) { std::copy_if(requiredObjects.begin(), requiredObjects.end(), std::back_inserter(packedObjects), [](ObjectHeader& header) { return !header.isEmpty() && !header.isVanilla(); }); } auto file = prepareGameState(flags, requiredObjects, packedObjects); saveResult = exportGameState(stream, *file, packedObjects); } if ((flags & SaveFlags::isAutosave) == SaveFlags::none) { Ui::ProgressBar::setProgress(230); } if ((flags & SaveFlags::raw) == SaveFlags::none && (flags & SaveFlags::dump) == SaveFlags::none) { ObjectManager::reloadAll(); } if ((flags & SaveFlags::isAutosave) == SaveFlags::none) { Ui::ProgressBar::end(); } if (saveResult) { Gfx::invalidateScreen(); if ((flags & SaveFlags::raw) == SaveFlags::none) { SceneManager::resetSceneAge(); } return true; } return false; } static bool exportGameState(Stream& stream, const S5File& file, const std::vector<ObjectHeader>& packedObjects) { try { SawyerStreamWriter fs(stream); fs.writeChunk(SawyerEncoding::rotate, file.header); if (file.header.type == S5Type::scenario || file.header.type == S5Type::landscape) { fs.writeChunk(SawyerEncoding::rotate, *file.scenarioOptions); } if (file.header.hasFlags(HeaderFlags::hasSaveDetails)) { fs.writeChunk(SawyerEncoding::rotate, *file.saveDetails); } if (file.header.numPackedObjects != 0) { ObjectManager::writePackedObjects(fs, packedObjects); } fs.writeChunk(SawyerEncoding::rotate, file.requiredObjects, sizeof(file.requiredObjects)); if (file.header.type == S5Type::scenario) { fs.writeChunk(SawyerEncoding::runLengthSingle, file.gameState.rng, 0xB96C); fs.writeChunk(SawyerEncoding::runLengthSingle, file.gameState.towns, 0x123480); fs.writeChunk(SawyerEncoding::runLengthSingle, file.gameState.animations, 0x79D80); } else { fs.writeChunk(SawyerEncoding::runLengthSingle, file.gameState); } if (file.header.hasFlags(HeaderFlags::isRaw)) { throw Exception::NotImplemented(); } else { fs.writeChunk(SawyerEncoding::runLengthMulti, file.tileElements.data(), file.tileElements.size() * sizeof(TileElement)); } fs.writeChecksum(); return true; } catch (const std::exception& e) { Logging::error("Unable to save S5: {}", e.what()); return false; } } // 0x00445A4A static void fixState(GameState& state) { if (state.hasFixFlags(S5FixFlags::fixFlag0)) { state.fixFlags |= S5FixFlags::fixFlag1; } if (!state.hasFixFlags(S5FixFlags::fixFlag1)) { // Shift data after companies to correct location auto src = reinterpret_cast<uint8_t*>(&state) + 0x49EA24; auto dst = src + 0x1C20; // std::size(Company::cargoUnitsDistanceHistory) * std::size(state.companies) for (size_t i = 0; i < 0x40E200; i++) { *--dst = *--src; } // Convert each company format from old to new for (size_t i = 0; i < std::size(state.companies); i++) { for (size_t j = 0; j < 372; j++) { *--dst = *--src; } // Make space for cargoUnitsDistanceHistory for (size_t j = 0; j < 480; j++) { *--dst = 0; } for (size_t j = 0; j < 35924; j++) { *--dst = *--src; } } } } // 0x00441FC9 std::unique_ptr<S5File> importSave(Stream& stream) { SawyerStreamReader fs(stream); if (!fs.validateChecksum()) { throw Exception::RuntimeError("Invalid checksum"); } auto file = std::make_unique<S5File>(); // Read header fs.readChunk(&file->header, sizeof(file->header)); // Read saved details 0x00442087 if (file->header.hasFlags(HeaderFlags::hasSaveDetails)) { file->saveDetails = std::make_unique<SaveDetails>(); fs.readChunk(file->saveDetails.get(), sizeof(file->saveDetails)); } if (file->header.type == S5Type::scenario) { file->scenarioOptions = std::make_unique<S5::Options>(); fs.readChunk(&*file->scenarioOptions, sizeof(S5::Options)); } // Read packed objects if (file->header.numPackedObjects > 0) { for (auto i = 0; i < file->header.numPackedObjects; ++i) { ObjectHeader object; fs.read(&object, sizeof(ObjectHeader)); auto unownedObjectData = fs.readChunk(); std::vector<std::byte> objectData; objectData.resize(unownedObjectData.size()); std::copy(std::begin(unownedObjectData), std::end(unownedObjectData), std::begin(objectData)); file->packedObjects.push_back(std::make_pair(object, std::move(objectData))); } // 0x004420B2 } if (file->header.type == S5Type::scenario) { // Load required objects fs.readChunk(file->requiredObjects, sizeof(file->requiredObjects)); // Load game state up to just before companies fs.readChunk(&file->gameState, sizeof(file->gameState)); // Load game state towns industry and stations fs.readChunk(&file->gameState.towns, sizeof(file->gameState)); // Load the rest of gamestate after animations fs.readChunk(&file->gameState.animations, sizeof(file->gameState)); file->gameState.fixFlags |= S5FixFlags::fixFlag1; fixState(file->gameState); if ((file->gameState.flags & GameStateFlags::tileManagerLoaded) != GameStateFlags::none) { // Load tile elements auto tileElements = fs.readChunk(); auto numTileElements = tileElements.size() / sizeof(TileElement); file->tileElements.resize(numTileElements); std::memcpy(file->tileElements.data(), tileElements.data(), numTileElements * sizeof(TileElement)); } } else { // Load required objects fs.readChunk(file->requiredObjects, sizeof(file->requiredObjects)); // Load game state fs.readChunk(&file->gameState, sizeof(file->gameState)); fixState(file->gameState); // Load tile elements auto tileElements = fs.readChunk(); auto numTileElements = tileElements.size() / sizeof(TileElement); file->tileElements.resize(numTileElements); std::memcpy(file->tileElements.data(), tileElements.data(), numTileElements * sizeof(TileElement)); } return file; } // 0x00444D76 static void setObjectErrorMessage(const ObjectHeader& header) { auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2040)); StringManager::formatString(buffer, 512, StringIds::missing_object_data_id_x); objectCreateIdentifierName(strchr(buffer, 0), header); _loadErrorCode = 255; _loadErrorMessage = StringIds::buffer_2040; } static void setObjectErrorList(const std::vector<ObjectHeader>& list) { _loadErrorObjectsList = list; } const std::vector<ObjectHeader>& getObjectErrorList() { return _loadErrorObjectsList; } class LoadException : public std::runtime_error { private: StringId _localisedMessage; public: LoadException(const char* message, StringId localisedMessage) : std::runtime_error(message) , _localisedMessage(localisedMessage) { } StringId getLocalisedMessage() const { return _localisedMessage; } }; void sub_4BAEC4() // TerraformConfig { addr<0x001136496, uint8_t>() = 2; // last tree rotation getGameState().lastTreeOption = 0xFF; getGameState().lastWallOption = 0xFF; } // 0x00441FA7 bool importSaveToGameState(const fs::path& path, LoadFlags flags) { FileStream fs(path, StreamMode::read); return importSaveToGameState(fs, flags); } bool importSaveToGameState(Stream& stream, LoadFlags flags) { SceneManager::setGameSpeed(GameSpeed::Normal); if ((flags & LoadFlags::titleSequence) == LoadFlags::none && (flags & LoadFlags::twoPlayer) == LoadFlags::none) { WindowManager::closeConstructionWindows(); WindowManager::closeAllFloatingWindows(); } try { Ui::ProgressBar::begin(StringIds::loading); Ui::ProgressBar::setProgress(10); auto file = importSave(stream); Ui::ProgressBar::setProgress(90); if (file->header.version != kCurrentVersion) { throw LoadException("Unsupported S5 version", StringIds::error_file_contains_invalid_data); } #ifdef DO_TITLE_SEQUENCE_CHECKS if ((flags & LoadFlags::titleSequence) != LoadFlags::none) { if (!file->header.hasFlags(HeaderFlags::isTitleSequence)) { throw LoadException("File was not a title sequence", StringIds::error_file_contains_invalid_data); } } else { if (file->header.hasFlags(HeaderFlags::isTitleSequence)) { throw LoadException("File is a title sequence", StringIds::error_file_contains_invalid_data); } } #endif if (hasLoadFlags(flags, LoadFlags::landscape)) { if (file->header.type != S5Type::scenario) { _loadErrorCode = 255; _loadErrorMessage = StringIds::error_file_contains_invalid_data; Ui::ProgressBar::end(); return false; } if (static_cast<EditorController::Step>(file->scenarioOptions->editorStep) == EditorController::Step::null) { file->scenarioOptions->editorStep = enumValue(EditorController::Step::landscapeEditor); } } Ui::ProgressBar::setProgress(100); // Any packed objects to install? if (!file->packedObjects.empty()) { // For now installing objects can't be done with a progress bar // revert this when objects do not change the current game state Ui::ProgressBar::end(); bool objectInstalled = false; for (auto [object, data] : file->packedObjects) { if (ObjectManager::tryInstallObject(object, data)) { objectInstalled = true; } } if (objectInstalled) { ObjectManager::loadIndex(); } // See above. restart progress bar Ui::ProgressBar::begin(StringIds::loading); } Ui::ProgressBar::setProgress(150); if (file->header.type == S5Type::objects) { _gameState->var_014A = 0; _loadErrorCode = 254; _loadErrorMessage = StringIds::new_objects_installed_successfully; Ui::ProgressBar::end(); // Throws! Game::returnToTitle(); } if (!hasLoadFlags(flags, LoadFlags::scenario | LoadFlags::landscape)) { if (file->header.type == S5Type::scenario) { throw LoadException("File is a scenario, not a saved game", StringIds::error_file_contains_invalid_data); } } if (file->header.hasFlags(HeaderFlags::isRaw) || file->header.hasFlags(HeaderFlags::isDump)) { throw LoadException("Unsupported S5 format", StringIds::error_file_contains_invalid_data); } if (hasLoadFlags(flags, LoadFlags::twoPlayer)) { if (file->header.type != S5Type::landscape) { throw LoadException("Not a two player saved game", StringIds::error_file_is_not_two_player_save); } } else if (!hasLoadFlags(flags, LoadFlags::scenario) && !hasLoadFlags(flags, LoadFlags::landscape)) { if (file->header.type != S5Type::savedGame) { throw LoadException("Not a single player saved game", StringIds::error_file_is_not_single_player_save); } } // Load required objects auto loadObjectResult = ObjectManager::loadAll(file->requiredObjects); if (!loadObjectResult.success) { setObjectErrorMessage(loadObjectResult.problemObjects[0]); setObjectErrorList(loadObjectResult.problemObjects); if (hasLoadFlags(flags, LoadFlags::twoPlayer)) { CompanyManager::reset(); _gameState->var_014A = 0; Ui::ProgressBar::end(); return false; } else { Ui::ProgressBar::end(); Game::returnToTitle(); return false; } } ObjectManager::reloadAll(); Ui::ProgressBar::setProgress(200); _gameState = file->gameState; if (hasLoadFlags(flags, LoadFlags::scenario | LoadFlags::landscape)) { _activeOptions = *file->scenarioOptions; } if ((file->gameState.flags & GameStateFlags::tileManagerLoaded) != GameStateFlags::none) { TileManager::setElements(std::span<World::TileElement>(reinterpret_cast<World::TileElement*>(file->tileElements.data()), file->tileElements.size())); } else { World::TileManager::initialise(); Scenario::sub_46115C(); } if (hasLoadFlags(flags, LoadFlags::landscape)) { EntityManager::freeUserStrings(); } if (hasLoadFlags(flags, LoadFlags::scenario | LoadFlags::landscape)) { CompanyManager::reset(); EntityManager::reset(); } Audio::stopVehicleNoise(); EntityManager::resetSpatialIndex(); CompanyManager::updateColours(); ObjectManager::updateTerraformObjects(); TileManager::resetSurfaceClearance(); IndustryManager::createAllMapAnimations(); Ui::ProgressBar::setProgress(225); if (hasLoadFlags(flags, LoadFlags::landscape)) { Scenario::initialiseSnowLine(); auto* stexObj = ObjectManager::get<ScenarioTextObject>(); if (stexObj != nullptr) { auto header = ObjectManager::getHeader(LoadedObjectHandle{ ObjectType::scenarioText, 0 }); ObjectManager::unload(header); ObjectManager::reloadAll(); ObjectManager::updateTerraformObjects(); _activeOptions->editorStep = enumValue(EditorController::Step::landscapeEditor); _activeOptions->difficulty = 3; StringManager::formatString(_activeOptions->scenarioDetails, StringIds::no_details_yet); _activeOptions->scenarioName[0] = '\0'; } } Audio::resetSoundObjects(); if (hasLoadFlags(flags, LoadFlags::scenario)) { _gameState->var_014A = 0; Ui::ProgressBar::end(); return true; } if (!hasLoadFlags(flags, LoadFlags::titleSequence)) { SceneManager::removeSceneFlags(SceneManager::Flags::title); initialiseViewports(); Audio::resetMusic(); if (hasLoadFlags(flags, LoadFlags::landscape)) { SceneManager::addSceneFlags(SceneManager::Flags::editor); EditorController::showEditor(); } else { Gui::init(); } } Ui::ProgressBar::setProgress(245); auto mainWindow = WindowManager::getMainWindow(); if (mainWindow != nullptr) { SavedViewSimple savedView; savedView.viewX = file->gameState.savedViewX; savedView.viewY = file->gameState.savedViewY; savedView.zoomLevel = static_cast<ZoomLevel>(file->gameState.savedViewZoom); savedView.rotation = file->gameState.savedViewRotation; mainWindow->viewportFromSavedView(savedView); mainWindow->invalidate(); } EntityManager::updateSpatialIndex(); TownManager::updateLabels(); StationManager::updateLabels(); sub_4BAEC4(); WindowManager::resetThousandthTickCounter(); Gfx::invalidateScreen(); if (!hasLoadFlags(flags, LoadFlags::landscape)) { Scenario::loadPreferredCurrencyAlways(); } Gfx::loadCurrency(); _gameState->var_014A = 0; if (hasLoadFlags(flags, LoadFlags::titleSequence)) { ScenarioManager::setScenarioTicks(ScenarioManager::getScenarioTicks() - 1); ScenarioManager::setScenarioTicks2(ScenarioManager::getScenarioTicks2() - 1); World::TileManager::disablePeriodicDefrag(); } Ui::ProgressBar::end(); if (!hasLoadFlags(flags, LoadFlags::titleSequence) && !hasLoadFlags(flags, LoadFlags::twoPlayer) && !hasLoadFlags(flags, LoadFlags::landscape)) { SceneManager::resetSceneAge(); throw GameException::Interrupt; } return true; } catch (const LoadException& e) { Logging::error("Unable to load S5: {}", e.what()); _loadErrorCode = 255; _loadErrorMessage = e.getLocalisedMessage(); Ui::ProgressBar::end(); return false; } catch (const std::exception& e) { Logging::error("Unable to load S5: {}", e.what()); _loadErrorCode = 255; _loadErrorMessage = StringIds::null; Ui::ProgressBar::end(); return false; } } // 0x00442403 std::unique_ptr<SaveDetails> readSaveDetails(const fs::path& path) { FileStream stream(path, StreamMode::read); SawyerStreamReader fs(stream); if (!fs.validateChecksum()) { return nullptr; } Header s5Header{}; // Read header fs.readChunk(&s5Header, sizeof(s5Header)); if (s5Header.version != kCurrentVersion) { return nullptr; } if (s5Header.hasFlags(HeaderFlags::isTitleSequence | HeaderFlags::isDump | HeaderFlags::isRaw)) { return nullptr; } if (s5Header.hasFlags(HeaderFlags::hasSaveDetails)) { // 0x0050AEA8 auto ret = std::make_unique<SaveDetails>(); fs.readChunk(ret.get(), sizeof(*ret)); return ret; } return nullptr; } // 0x00442AFC std::unique_ptr<Scenario::Options> readScenarioOptions(const fs::path& path) { FileStream stream(path, StreamMode::read); SawyerStreamReader fs(stream); if (!fs.validateChecksum()) { return nullptr; } Header s5Header{}; // Read header fs.readChunk(&s5Header, sizeof(s5Header)); if (s5Header.version != kCurrentVersion) { return nullptr; } if (s5Header.type == S5Type::scenario) { // 0x009DA285 = 1 // 0x009CCA54 _previewOptions // TODO: For now OpenLoco::Options and S5::Options are identical in the future // there should be an import and validation step that converts from one to the // other auto ret = std::make_unique<Scenario::Options>(); fs.readChunk(ret.get(), sizeof(*ret)); return ret; } return nullptr; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/S5/S5.h ```h #pragma once #include "Engine/Limits.h" #include "Objects/Object.h" #include "ScenarioConstruction.h" #include "ScenarioObjective.h" #include "World/CompanyManager.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/FileSystem.hpp> #include <cstdint> #include <memory> #include <vector> namespace OpenLoco { enum class GameStateFlags : uint32_t; class Stream; } namespace OpenLoco::Scenario { struct Options; } namespace OpenLoco::S5 { enum class S5Type : uint8_t { savedGame = 0, scenario = 1, objects = 2, landscape = 3, }; enum class HeaderFlags : uint8_t { none = 0U, isRaw = 1U << 0, isDump = 1U << 1, isTitleSequence = 1U << 2, hasSaveDetails = 1U << 3, }; OPENLOCO_ENABLE_ENUM_OPERATORS(HeaderFlags); #pragma pack(push, 1) struct Header { S5Type type; HeaderFlags flags; uint16_t numPackedObjects; uint32_t version; uint32_t magic; std::byte padding[20]; constexpr bool hasFlags(HeaderFlags flagsToTest) const { return (flags & flagsToTest) != HeaderFlags::none; } }; #pragma pack(pop) static_assert(sizeof(Header) == 0x20); #pragma pack(push, 1) struct Options { uint8_t editorStep; // 0x00 uint8_t difficulty; // 0x01 uint16_t scenarioStartYear; // 0x02 uint8_t pad_4[2]; // 0x04 uint16_t scenarioFlags; // 0x06 uint8_t madeAnyChanges; // 0x08 uint8_t pad_9[1]; // 0x09 uint8_t landDistributionPatterns[32]; // 0x0A char scenarioName[64]; // 0x2A char scenarioDetails[256]; // 0x6A ObjectHeader scenarioText; // 0x16A uint16_t numberOfForests; // 0x17A uint8_t minForestRadius; // 0x17C uint8_t maxForestRadius; // 0x17D uint8_t minForestDensity; // 0x17E uint8_t maxForestDensity; // 0x17F uint16_t numberRandomTrees; // 0x180 uint8_t minAltitudeForTrees; // 0x182 uint8_t maxAltitudeForTrees; // 0x183 uint8_t minLandHeight; // 0x184 uint8_t topographyStyle; // 0x185 uint8_t hillDensity; // 0x186 uint8_t numberOfTowns; // 0x187 uint8_t maxTownSize; // 0x188 uint8_t numberOfIndustries; // 0x189 uint8_t preview[128][128]; // 0x18A uint8_t maxCompetingCompanies; // 0x418A uint8_t competitorStartDelay; // 0x418B Scenario::Objective objective; // 0x418C ObjectHeader objectiveDeliveredCargo; // 0x419D ObjectHeader currency; // 0x41AD // new fields: uint8_t generator; uint8_t numTerrainSmoothingPasses; uint8_t numRiverbeds; uint8_t minRiverWidth; uint8_t maxRiverWidth; uint8_t riverbankWidth; uint8_t riverMeanderRate; std::byte pad_41BD[342]; }; #pragma pack(pop) static_assert(sizeof(Options) == 0x431A); #pragma pack(push, 1) struct SaveDetails { char company[256]; // 0x000 char owner[256]; // 0x100 uint32_t date; // 0x200 uint16_t performanceIndex; // 0x204 (from [company.performance_index) char scenario[0x40]; // 0x206 uint8_t challengeProgress; // 0x246 std::byte pad_247; // 0x247 uint8_t image[250 * 200]; // 0x248 CompanyFlags challengeFlags; // 0xC598 (from [company.challenge_flags]) std::byte pad_C59C[0xC618 - 0xC59C]; // 0xC59C }; #pragma pack(pop) static_assert(sizeof(SaveDetails) == 0xC618); #pragma pack(push, 1) struct Company { uint16_t name; // 0x0000 uint16_t ownerName; // 0x0002 CompanyFlags challengeFlags; // 0x0004 uint8_t cash[6]; // 0x0008 uint32_t currentLoan; // 0x000E uint32_t updateCounter; // 0x0012 int16_t performanceIndex; // 0x0016 uint8_t pad_18[0x8C4E - 0x18]; // 0x0018 uint8_t challengeProgress; // 0x8C4E uint8_t pad_8C4F[0x8FA8 - 0x8C4F]; }; static_assert(sizeof(Company) == 0x8FA8); struct Town { uint8_t pad_000[0x270]; }; struct Industry { uint8_t pad_000[0x453]; }; struct Station { uint8_t pad_000[0x3D2]; }; struct Entity { uint8_t pad_00[0x80]; }; struct Animation { uint8_t pad_0[0x6]; }; struct Wave { uint8_t pad_0[0x6]; }; struct Message { uint8_t pad_0[0xD4]; }; struct TileElement { private: static constexpr uint8_t FLAG_GHOST = 1 << 4; static constexpr uint8_t FLAG_LAST = 1 << 7; public: uint8_t type; uint8_t flags; uint8_t baseZ; uint8_t clearZ; uint8_t pad_4[4]; void setLast(bool value) { if (value) { flags |= FLAG_LAST; } else { flags &= ~FLAG_LAST; } } constexpr bool isGhost() const { return flags & FLAG_GHOST; } constexpr bool isLast() const { return flags & FLAG_LAST; } }; static_assert(sizeof(TileElement) == 8); enum class S5FixFlags : uint16_t { none = 0U, fixFlag0 = 1U << 0, fixFlag1 = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(S5FixFlags); struct GameState { uint32_t rng[2]; // 0x000000 (0x00525E18) uint32_t unkRng[2]; // 0x000008 (0x00525E20) GameStateFlags flags; // 0x000010 (0x00525E28) uint32_t currentDay; // 0x000014 (0x00525E2C) uint16_t dayCounter; // 0x000018 uint16_t currentYear; // 0x00001A uint8_t currentMonth; // 0x00001C uint8_t currentDayOfMonth; // 0x00001D int16_t savedViewX; // 0x00001E int16_t savedViewY; // 0x000020 uint8_t savedViewZoom; // 0x000022 uint8_t savedViewRotation; // 0x000023 uint8_t playerCompanies[2]; // 0x000024 (0x00525E3C) uint16_t entityListHeads[Limits::kNumEntityLists]; // 0x000026 (0x00525E3E) uint16_t entityListCounts[Limits::kNumEntityLists]; // 0x000034 (0x00525E4C) uint8_t pad_0042[0x046 - 0x042]; // 0x000042 uint32_t currencyMultiplicationFactor[32]; // 0x000046 (0x00525E5E) uint32_t unusedCurrencyMultiplicationFactor[32]; // 0x0000C6 (0x00525EDE) uint32_t scenarioTicks; // 0x000146 (0x00525F5E) uint16_t var_014A; // 0x00014A (0x00525F62) uint32_t scenarioTicks2; // 0x00014C (0x00525F64) uint32_t magicNumber; // 0x000150 (0x00525F68) uint16_t numMapAnimations; // 0x000154 (0x00525F6C) int16_t tileUpdateStartLocation[2]; // 0x000156 (0x00525F6E) Scenario::Construction scenarioConstruction; // 0x00015A (0x00525F72) uint8_t lastRailroadOption; // 0x000192 (0x00525FAA) uint8_t lastRoadOption; // 0x000193 (0x00525FAB) uint8_t lastAirport; // 0x000194 (0x00525FAC) uint8_t lastShipPort; // 0x000195 (0x00525FAD) bool trafficHandedness; // 0x000196 (0x00525FAE) uint8_t lastVehicleType; // 0x000197 (0x00525FAF) uint8_t pickupDirection; // 0x000198 (0x00525FB0) uint8_t lastTreeOption; // 0x000199 (0x00525FB1) uint16_t seaLevel; // 0x00019A (0x00525FB2) uint8_t currentSnowLine; // 0x00019C (0x00525FB4) uint8_t currentSeason; // 0x00019D (0x00525FB5) uint8_t lastLandOption; // 0x00019E (0x00525FB6) uint8_t maxCompetingCompanies; // 0x00019F (0x00525FB7) uint32_t orderTableLength; // 0x0001A0 (0x00525FB8) uint32_t roadObjectIdIsNotTram; // 0x0001A4 (0x00525FBC) uint32_t roadObjectIdIsFlag7; // 0x0001A8 (0x00525FC0) uint8_t currentDefaultLevelCrossingType; // 0x0001AC (0x00525FC4) uint8_t lastTrackTypeOption; // 0x0001AD (0x00525FC5) uint8_t loanInterestRate; // 0x0001AE (0x00525FC6) uint8_t lastIndustryOption; // 0x0001AF (0x00525FC7) uint8_t lastBuildingOption; // 0x0001B0 (0x00525FC8) uint8_t lastMiscBuildingOption; // 0x0001B1 (0x00525FC9) uint8_t lastWallOption; // 0x0001B2 (0x00525FCA) uint8_t produceAICompanyTimeout; // 0x0001B3 (0x00525FCB) uint32_t tickStartPrngState[2]; // 0x0001B4 (0x00525FCC) char scenarioFileName[256]; // 0x0001BC (0x00525FD4) char scenarioName[64]; // 0x0002BC (0x005260D4) char scenarioDetails[256]; // 0x0002FC (0x00526114) uint8_t competitorStartDelay; // 0x0003FC (0x00526214) uint8_t preferredAIIntelligence; // 0x0003FD (0x00526215) uint8_t preferredAIAggressiveness; // 0x0003FE (0x00526216) uint8_t preferredAICompetitiveness; // 0x0003FF (0x00526217) uint16_t startingLoanSize; // 0x000400 (0x00526218) uint16_t maxLoanSize; // 0x000402 (0x0052621A) uint32_t var_404; // 0x000404 (0x0052621C) uint32_t var_408; // 0x000408 (0x00526220) uint32_t var_40C; // 0x00040C (0x00526224) uint32_t var_410; // 0x000410 (0x00526228) uint8_t lastBuildVehiclesOption; // 0x000414 (0x0052622C) uint8_t numberOfIndustries; // 0x000415 (0x0052622D) uint16_t vehiclePreviewRotationFrame; // 0x000416 (0x0052622E) uint8_t objectiveType; // 0x000418 (0x00526230) uint8_t objectiveFlags; // 0x000419 (0x00526231) uint32_t objectiveCompanyValue; // 0x00041A (0x00526232) uint32_t objectiveMonthlyVehicleProfit; // 0x00041E (0x00526236) uint8_t objectivePerformanceIndex; // 0x000422 (0x0052623A) uint8_t objectiveDeliveredCargoType; // 0x000423 (0x0052623B) uint32_t objectiveDeliveredCargoAmount; // 0x000424 (0x0052623C) uint8_t objectiveTimeLimitYears; // 0x000428 (0x00526240) uint16_t objectiveTimeLimitUntilYear; // 0x000429 (0x00526241) uint16_t objectiveMonthsInChallenge; // 0x00042B (0x00526243) uint16_t objectiveCompletedChallengeInMonths; // 0x00042D (0x00526245) uint8_t industryFlags; // 0x00042F (0x00526247) uint16_t forbiddenVehiclesPlayers; // 0x000430 (0x00526248) uint16_t forbiddenVehiclesCompetitors; // 0x000432 (0x0052624A) S5FixFlags fixFlags; // 0x000434 (0x0052624C) uint16_t recordSpeed[3]; // 0x000436 (0x0052624E) uint8_t recordCompany[4]; // 0x00043C (0x00526254) uint32_t recordDate[3]; // 0x000440 (0x00526258) uint32_t var_44C; // 0x00044C (0x00526264) uint32_t var_450; // 0x000450 (0x00526268) uint32_t var_454; // 0x000454 (0x0052626C) uint32_t var_458; // 0x000458 (0x00526270) uint32_t var_45C; // 0x00045C (0x00526274) uint32_t var_460; // 0x000460 (0x00526278) uint32_t var_464; // 0x000464 (0x0052627C) uint32_t var_468; // 0x000468 (0x00526280) uint32_t lastMapWindowFlags; // 0x00046C (0x00526284) uint16_t lastMapWindowSize[2]; // 0x000470 (0x00526288) uint16_t lastMapWindowVar88A; // 0x000474 (0x0052628C) uint16_t lastMapWindowVar88C; // 0x000476 (0x0052628E) uint32_t var_478; // 0x000478 (0x00526290) uint8_t pad_047C[0x13B6 - 0x47C]; // 0x00047C uint16_t numMessages; // 0x0013B6 (0x005271CE) uint16_t activeMessageIndex; // 0x0013B8 (0x005271D0) Message messages[S5::Limits::kMaxMessages]; // 0x0013BA (0x005271D2) uint8_t pad_B886[0xB94C - 0xB886]; // 0x00B886 uint8_t var_B94C; // 0x00B94C (0x00531774) uint8_t pad_B94D[0xB950 - 0xB94D]; // 0x00B94D uint8_t var_B950; // 0x00B950 (0x00531778) uint8_t pad_B951; // 0x00B951 uint8_t var_B952; // 0x00B952 (0x0053177A) uint8_t pad_B953; // 0x00B953 uint8_t var_B954; // 0x00B954 (0x0053177C) uint8_t pad_B955; // 0x00B955 uint8_t var_B956; // 0x00B956 (0x0053177E) uint8_t pad_B957[0xB968 - 0xB957]; // 0x00B957 uint8_t currentRainLevel; // 0x00B968 (0x00531780) uint8_t pad_B969[0xB96C - 0xB969]; // 0x00B969 Company companies[S5::Limits::kMaxCompanies]; // 0x00B96C (0x00531784) Town towns[S5::Limits::kMaxTowns]; // 0x092444 (0x005B825C) Industry industries[S5::Limits::kMaxIndustries]; // 0x09E744 (0x005C455C) Station stations[S5::Limits::kMaxStations]; // 0x0C10C4 (0x005E6EDC) Entity entities[S5::Limits::kMaxEntities]; // 0x1B58C4 (0x006DB6DC) Animation animations[S5::Limits::kMaxAnimations]; // 0x4268C4 (0x0094C6DC) Wave waves[S5::Limits::kMaxWaves]; // 0x4328C4 (0x009586DC) char userStrings[S5::Limits::kMaxUserStrings][32]; // 0x432A44 (0x0095885C) uint16_t routings[S5::Limits::kMaxVehicles][S5::Limits::kMaxRoutingsPerVehicle]; // 0x442A44 (0x0096885C) uint8_t orders[S5::Limits::kMaxOrders]; // 0x461E44 (0x00987C5C) constexpr bool hasFixFlags(S5FixFlags flagsToTest) const { return (fixFlags & flagsToTest) != S5FixFlags::none; } }; #pragma pack(pop) static_assert(sizeof(GameState) == 0x4A0644); struct S5File { Header header; std::unique_ptr<Options> scenarioOptions; std::unique_ptr<SaveDetails> saveDetails; ObjectHeader requiredObjects[859]; GameState gameState; std::vector<TileElement> tileElements; std::vector<std::pair<ObjectHeader, std::vector<std::byte>>> packedObjects; }; enum class LoadFlags : uint32_t { none = 0U, titleSequence = 1U << 0, twoPlayer = 1U << 1, scenario = 1U << 2, landscape = 1U << 3, }; OPENLOCO_ENABLE_ENUM_OPERATORS(LoadFlags); enum class SaveFlags : uint32_t { none = 0, packCustomObjects = 1U << 0, scenario = 1U << 1, landscape = 1U << 2, isAutosave = 1U << 28, noWindowClose = 1U << 29, raw = 1U << 30, // Save raw data including pointers with no clean up dump = 1U << 31, // Used for dumping the game state when there is a fatal error }; OPENLOCO_ENABLE_ENUM_OPERATORS(SaveFlags); constexpr const char* extensionSC5 = ".SC5"; constexpr const char* extensionSV5 = ".SV5"; constexpr const char* filterSC5 = "*.SC5"; constexpr const char* filterSV5 = "*.SV5"; void drawScenarioPreviewImage(); bool exportGameStateToFile(const fs::path& path, SaveFlags flags); bool exportGameStateToFile(Stream& stream, SaveFlags flags); const std::vector<ObjectHeader>& getObjectErrorList(); std::unique_ptr<S5File> importSave(Stream& stream); bool importSaveToGameState(const fs::path& path, LoadFlags flags); bool importSaveToGameState(Stream& stream, LoadFlags flags); std::unique_ptr<SaveDetails> readSaveDetails(const fs::path& path); std::unique_ptr<Scenario::Options> readScenarioOptions(const fs::path& path); void sub_4BAEC4(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/S5/SawyerStream.cpp ```cpp #include "SawyerStream.h" #include <OpenLoco/Core/Exception.hpp> #include <algorithm> #include <bit> #include <cassert> #include <cstring> #include <memory> #include <stdexcept> using namespace OpenLoco; constexpr const char* exceptionReadError = "Failed to read data from stream"; constexpr const char* exceptionWriteError = "Failed to write data to stream"; constexpr const char* exceptionInvalidRLE = "Invalid RLE run"; constexpr const char* exceptionUnknownEncoding = "Unknown encoding"; SawyerStreamReader::SawyerStreamReader(Stream& stream) : _stream(stream) { } std::span<const std::byte> SawyerStreamReader::readChunk() { SawyerEncoding encoding; read(&encoding, sizeof(encoding)); uint32_t length; read(&length, sizeof(length)); _decodeBuffer.resize(length); read(_decodeBuffer.data(), length); return decode(encoding, _decodeBuffer.getSpan()); } size_t SawyerStreamReader::readChunk(void* data, size_t maxDataLen) { auto chunkData = readChunk(); std::memcpy(data, chunkData.data(), std::min(chunkData.size(), maxDataLen)); return chunkData.size(); } void SawyerStreamReader::read(void* data, size_t dataLen) { try { _stream.read(data, dataLen); } catch (...) { throw Exception::RuntimeError(exceptionReadError); } } bool SawyerStreamReader::validateChecksum() { auto valid = false; auto backupPos = _stream.getPosition(); auto fileLength = static_cast<uint32_t>(_stream.getLength()); if (fileLength >= 4) { // Read checksum uint32_t checksum; _stream.setPosition(fileLength - 4); _stream.read(&checksum, sizeof(checksum)); // Calculate checksum uint32_t actualChecksum = 0; _stream.setPosition(0); uint8_t buffer[2048]; for (uint32_t i = 0; i < fileLength - 4; i += sizeof(buffer)) { auto readLength = std::min<size_t>(sizeof(buffer), fileLength - 4 - i); _stream.read(buffer, readLength); for (size_t j = 0; j < readLength; j++) { actualChecksum += buffer[j]; } } valid = checksum == actualChecksum; } // Restore position _stream.setPosition(backupPos); return valid; } std::span<const std::byte> SawyerStreamReader::decode(SawyerEncoding encoding, std::span<const std::byte> data) { switch (encoding) { case SawyerEncoding::uncompressed: return data; case SawyerEncoding::runLengthSingle: _decodeBuffer2.clear(); _decodeBuffer2.reserve(data.size()); decodeRunLengthSingle(_decodeBuffer2, data); return _decodeBuffer2.getSpan(); case SawyerEncoding::runLengthMulti: _decodeBuffer2.clear(); _decodeBuffer2.reserve(data.size()); decodeRunLengthSingle(_decodeBuffer2, data); _decodeBuffer.clear(); _decodeBuffer.reserve(_decodeBuffer2.getLength()); decodeRunLengthMulti(_decodeBuffer, _decodeBuffer2.getSpan()); return _decodeBuffer.getSpan(); case SawyerEncoding::rotate: _decodeBuffer2.clear(); _decodeBuffer2.reserve(data.size()); decodeRotate(_decodeBuffer2, data); return _decodeBuffer2.getSpan(); default: throw Exception::RuntimeError(exceptionUnknownEncoding); } } static void fillStream(MemoryStream& buffer, std::byte value, size_t count) { for (size_t i = 0; i < count; i++) { buffer.writeValue(value); } } void SawyerStreamReader::decodeRunLengthSingle(MemoryStream& buffer, std::span<const std::byte> data) { for (size_t i = 0; i < data.size(); i++) { uint8_t rleCodeByte = static_cast<uint8_t>(data[i]); if (rleCodeByte & 128) { i++; if (i >= data.size()) { throw Exception::RuntimeError(exceptionInvalidRLE); } auto copyLen = static_cast<size_t>(257 - rleCodeByte); auto copyByte = data[i]; fillStream(buffer, copyByte, copyLen); } else { if (i + 1 >= data.size() || i + 1 + rleCodeByte + 1 > data.size()) { throw Exception::RuntimeError(exceptionInvalidRLE); } auto copyLen = static_cast<size_t>(rleCodeByte + 1); buffer.write(&data[i + 1], copyLen); i += rleCodeByte + 1; } } } void SawyerStreamReader::decodeRunLengthMulti(MemoryStream& buffer, std::span<const std::byte> data) { for (size_t i = 0; i < data.size(); i++) { if (data[i] == std::byte{ 0xFF }) { i++; if (i >= data.size()) { throw Exception::RuntimeError(exceptionInvalidRLE); } buffer.writeValue(data[i]); } else { auto offset = static_cast<int32_t>(data[i] >> 3) - 32; assert(offset < 0); if (static_cast<size_t>(-offset) > buffer.getLength()) { throw Exception::RuntimeError(exceptionInvalidRLE); } auto copySrc = buffer.data() + buffer.getLength() + offset; auto copyLen = (static_cast<size_t>(data[i]) & 7) + 1; // Copy it to temp buffer first as we can't copy buffer to itself due to potential // realloc in between reserve and push std::byte copyBuffer[32]; assert(copyLen <= sizeof(copyBuffer)); std::memcpy(copyBuffer, copySrc, copyLen); buffer.write(copyBuffer, copyLen); } } } void SawyerStreamReader::decodeRotate(MemoryStream& buffer, std::span<const std::byte> data) { uint8_t code = 1; for (size_t i = 0; i < data.size(); i++) { buffer.writeValue(std::rotr(static_cast<uint8_t>(data[i]), code)); code = (code + 2) & 7; } } SawyerStreamWriter::SawyerStreamWriter(Stream& stream) : _stream(stream) { } void SawyerStreamWriter::writeChunk(SawyerEncoding chunkType, const void* data, size_t dataLen) { auto encodedData = encode(chunkType, std::span(static_cast<const std::byte*>(data), dataLen)); write(&chunkType, sizeof(chunkType)); write(static_cast<uint32_t>(encodedData.size())); write(encodedData.data(), encodedData.size()); } void SawyerStreamWriter::write(const void* data, size_t dataLen) { writeStream(data, dataLen); auto data8 = reinterpret_cast<const uint8_t*>(data); for (size_t i = 0; i < dataLen; i++) { _checksum += data8[i]; } } void SawyerStreamWriter::writeChecksum() { writeStream(&_checksum, sizeof(_checksum)); } void SawyerStreamWriter::writeStream(const void* data, size_t dataLen) { try { _stream.write(data, dataLen); } catch (...) { throw Exception::RuntimeError(exceptionWriteError); } } std::span<const std::byte> SawyerStreamWriter::encode(SawyerEncoding encoding, std::span<const std::byte> data) { switch (encoding) { case SawyerEncoding::uncompressed: return data; case SawyerEncoding::runLengthSingle: _encodeBuffer.clear(); _encodeBuffer.reserve(data.size()); encodeRunLengthSingle(_encodeBuffer, data); return _encodeBuffer.getSpan(); case SawyerEncoding::runLengthMulti: _encodeBuffer.clear(); _encodeBuffer.reserve(data.size()); encodeRunLengthMulti(_encodeBuffer, data); _encodeBuffer2.clear(); _encodeBuffer2.reserve(_encodeBuffer.getLength()); encodeRunLengthSingle(_encodeBuffer2, _encodeBuffer.getSpan()); return _encodeBuffer2.getSpan(); case SawyerEncoding::rotate: _encodeBuffer.clear(); _encodeBuffer.reserve(data.size()); encodeRotate(_encodeBuffer, data); return _encodeBuffer.getSpan(); default: throw Exception::RuntimeError(exceptionUnknownEncoding); } } void SawyerStreamWriter::encodeRunLengthSingle(MemoryStream& buffer, std::span<const std::byte> data) { auto src = data.data(); auto srcEnd = src + data.size(); auto srcNormStart = src; uint8_t count = 0; while (src < srcEnd - 1) { if ((count != 0 && src[0] == src[1]) || count > 125) { buffer.writeValue(static_cast<std::byte>(count - 1)); buffer.write(srcNormStart, count); srcNormStart += count; count = 0; } if (src[0] == src[1]) { for (; count < 125 && src + count < srcEnd; count++) { if (src[0] != src[count]) { break; } } buffer.writeValue(static_cast<std::byte>(257 - count)); buffer.writeValue(src[0]); src += count; srcNormStart = src; count = 0; } else { count++; src++; } } if (src == srcEnd - 1) { count++; } if (count != 0) { buffer.writeValue(static_cast<std::byte>(count - 1)); buffer.write(srcNormStart, count); } } void SawyerStreamWriter::encodeRunLengthMulti(MemoryStream& buffer, std::span<const std::byte> data) { auto src = data.data(); auto srcLen = data.size(); if (srcLen == 0) { return; } // Need to emit at least one byte, otherwise there is nothing to repeat buffer.writeValue(std::byte{ 0xFF }); buffer.writeValue(src[0]); // Iterate through remainder of the source buffer for (size_t i = 1; i < srcLen;) { size_t searchIndex = (i < 32) ? 0 : (i - 32); size_t searchEnd = i - 1; size_t bestRepeatIndex = 0; size_t bestRepeatCount = 0; for (size_t repeatIndex = searchIndex; repeatIndex <= searchEnd; repeatIndex++) { size_t repeatCount = 0; size_t maxRepeatCount = std::min(std::min(static_cast<size_t>(7), searchEnd - repeatIndex), srcLen - i - 1); // maxRepeatCount should not exceed srcLen assert(repeatIndex + maxRepeatCount < srcLen); assert(i + maxRepeatCount < srcLen); for (size_t j = 0; j <= maxRepeatCount; j++) { if (src[repeatIndex + j] == src[i + j]) { repeatCount++; } else { break; } } if (repeatCount > bestRepeatCount) { bestRepeatIndex = repeatIndex; bestRepeatCount = repeatCount; // Maximum repeat count is 8 if (repeatCount == 8) { break; } } } if (bestRepeatCount == 0) { buffer.writeValue(std::byte{ 0xFF }); buffer.writeValue(src[i]); i++; } else { buffer.writeValue(static_cast<std::byte>((bestRepeatCount - 1) | ((32 - (i - bestRepeatIndex)) << 3))); i += bestRepeatCount; } } } void SawyerStreamWriter::encodeRotate(MemoryStream& buffer, std::span<const std::byte> data) { uint8_t code = 1; for (size_t i = 0; i < data.size(); i++) { buffer.writeValue(std::rotl(static_cast<uint8_t>(data[i]), code)); code = (code + 2) & 7; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/S5/SawyerStream.h ```h #pragma once #include <OpenLoco/Core/FileStream.h> #include <OpenLoco/Core/FileSystem.hpp> #include <OpenLoco/Core/MemoryStream.h> #include <cstdint> #include <memory> #include <span> namespace OpenLoco { enum class SawyerEncoding : uint8_t { uncompressed, runLengthSingle, runLengthMulti, rotate, }; class SawyerStreamReader { private: Stream& _stream; MemoryStream _decodeBuffer; MemoryStream _decodeBuffer2; std::span<const std::byte> decode(SawyerEncoding encoding, std::span<const std::byte> data); static void decodeRunLengthSingle(MemoryStream& buffer, std::span<const std::byte> data); static void decodeRunLengthMulti(MemoryStream& buffer, std::span<const std::byte> data); static void decodeRotate(MemoryStream& buffer, std::span<const std::byte> data); public: SawyerStreamReader(Stream& stream); std::span<const std::byte> readChunk(); size_t readChunk(void* data, size_t maxDataLen); void read(void* data, size_t dataLen); bool validateChecksum(); }; class SawyerStreamWriter { private: Stream& _stream; uint32_t _checksum{}; MemoryStream _encodeBuffer; MemoryStream _encodeBuffer2; void writeStream(const void* data, size_t dataLen); std::span<const std::byte> encode(SawyerEncoding encoding, std::span<const std::byte> data); static void encodeRunLengthSingle(MemoryStream& buffer, std::span<const std::byte> data); static void encodeRunLengthMulti(MemoryStream& buffer, std::span<const std::byte> data); static void encodeRotate(MemoryStream& buffer, std::span<const std::byte> data); public: SawyerStreamWriter(Stream& stream); void writeChunk(SawyerEncoding chunkType, const void* data, size_t dataLen); void write(const void* data, size_t dataLen); void writeChecksum(); template<typename T> void writeChunk(SawyerEncoding chunkType, const T& data) { writeChunk(chunkType, &data, sizeof(T)); } template<typename T> void write(const T& data) { write(&data, sizeof(T)); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Entities/Entity.cpp ```cpp #include "Entity.h" #include "EntityManager.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" namespace OpenLoco { bool EntityBase::empty() const { return baseType == EntityBaseType::null; } // 0x0046FC83 void EntityBase::moveTo(const World::Pos3& loc) { EntityManager::moveSpatialEntry(*this, loc); // Update sprite boundaries if (position.x == Location::null) { spriteLeft = Location::null; return; } const auto vpPos = World::gameToScreen(loc, Ui::WindowManager::getCurrentRotation()); spriteLeft = vpPos.x - spriteWidth; spriteRight = vpPos.x + spriteWidth; spriteTop = vpPos.y - spriteHeightNegative; spriteBottom = vpPos.y + spriteHeightPositive; } // 0x004CBB01 void EntityBase::invalidateSprite() { Ui::ViewportManager::invalidate(this, ZoomLevel::eighth); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Entities/Entity.h ```h #pragma once #include "Location.hpp" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/World.hpp> #include <cstdint> #include <limits> namespace OpenLoco { enum class EntityBaseType : uint8_t { vehicle = 0, effect, null = 0xFF }; enum class Pitch : uint8_t { // actual angle (for trig) flat = 0, up6deg = 1, // Transition, 5.75 deg up12deg = 2, // Gentle, 11.75 deg up18deg = 3, // Transition, 17 deg up25deg = 4, // Steep, 22.5 deg down6deg = 5, down12deg = 6, down18deg = 7, down25deg = 8, up10deg = 9, // Gentle Curve Up, 10 deg down10deg = 10, up20deg = 11, // Steep Curve Up, 19.25 deg down20deg = 12, }; enum class VehicleFlags : uint16_t // commands? { none = 0U, unk_0 = 1U << 0, commandStop = 1U << 1, // commanded to stop?? unk_2 = 1U << 2, sorted = 1U << 3, // vehicle list unk_5 = 1U << 5, manualControl = 1U << 6, shuntCheat = 1U << 7, }; OPENLOCO_ENABLE_ENUM_OPERATORS(VehicleFlags); #pragma pack(push, 1) struct EntityBase { EntityBaseType baseType; private: uint8_t type; // Use type specific getters/setters as this depends on baseType public: EntityId nextQuadrantId; // 0x02 EntityId nextEntityId; // 0x04 EntityId llPreviousId; // 0x06 uint8_t linkedListOffset; // 0x08 uint8_t spriteHeightNegative; // 0x09 EntityId id; // 0x0A VehicleFlags vehicleFlags; // 0x0C, Move these to VehicleBase after full reimplementation World::Pos3 position; // 0x0E uint8_t spriteWidth; // 0x14 uint8_t spriteHeightPositive; // 0x15 int16_t spriteLeft; // 0x16 int16_t spriteTop; // 0x18 int16_t spriteRight; // 0x1A int16_t spriteBottom; // 0x1C uint8_t spriteYaw; // 0x1E Pitch spritePitch; // 0x1F uint8_t pad_20; // 0x20 CompanyId owner; // 0x21 StringId name; // 0x22, combined with ordinalNumber on vehicles void moveTo(const World::Pos3& loc); void invalidateSprite(); template<typename T> bool isBase() const { return baseType == T::kBaseType; } template<typename BaseType> BaseType* asBase() { return isBase<BaseType>() ? reinterpret_cast<BaseType*>(this) : nullptr; } template<typename BaseType> const BaseType* asBase() const { return isBase<BaseType>() ? reinterpret_cast<const BaseType*>(this) : nullptr; } bool empty() const; protected: constexpr uint8_t getSubType() const { return type; } void setSubType(const uint8_t newType) { type = newType; } }; // Max size of a Entity. Use when needing to know Entity size struct Entity : EntityBase { private: uint8_t pad_24[0x80 - 0x24]; }; static_assert(sizeof(Entity) == 0x80); #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Entities/EntityManager.cpp ```cpp #include "EntityManager.h" #include "EntityTweener.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "GameStateFlags.h" #include "Localisation/StringIds.h" #include "Logging.h" #include <OpenLoco/Core/LocoFixedVector.hpp> using namespace OpenLoco::Diagnostics; namespace OpenLoco::EntityManager { constexpr size_t kSpatialEntityMapSize = (World::kMapPitch * World::kMapPitch) + 1; constexpr size_t kEntitySpatialIndexNull = kSpatialEntityMapSize - 1; static_assert(kSpatialEntityMapSize == 0x40001); static_assert(kEntitySpatialIndexNull == 0x40000); static EntityId _entitySpatialIndex[kSpatialEntityMapSize]; // 0x01025A8C static uint32_t _entitySpatialCount; // 0x01025A88 static auto& rawEntities() { return getGameState().entities; } static auto entities() { return FixedVector(rawEntities()); } static auto& rawListHeads() { return getGameState().entityListHeads; } static auto& rawListCounts() { return getGameState().entityListCounts; } constexpr uint8_t getLinkedListOffset(EntityListType list) { return enumValue(list) * sizeof(uint16_t); } constexpr size_t getLinkedListIndex(uint8_t offset) { return offset / sizeof(uint16_t); } // 0x0046FDFD void reset() { // Reset all entities to 0 std::fill(std::begin(rawEntities()), std::end(rawEntities()), Entity{}); // Reset all entity lists std::fill(std::begin(rawListCounts()), std::end(rawListCounts()), 0); std::fill(std::begin(rawListHeads()), std::end(rawListHeads()), EntityId::null); // Remake null entities (size maxNormalEntities) EntityBase* previous = nullptr; uint16_t id = 0; for (; id < Limits::maxNormalEntities; ++id) { auto& ent = rawEntities()[id]; ent.baseType = EntityBaseType::null; ent.id = EntityId(id); ent.nextEntityId = EntityId::null; ent.linkedListOffset = getLinkedListOffset(EntityListType::null); if (previous == nullptr) { ent.llPreviousId = EntityId::null; rawListHeads()[enumValue(EntityListType::null)] = EntityId(id); } else { ent.llPreviousId = previous->id; previous->nextEntityId = EntityId(id); } previous = &ent; } rawListCounts()[enumValue(EntityListType::null)] = Limits::maxNormalEntities; // Remake null money entities (size kMaxMoneyEntities) previous = nullptr; for (; id < Limits::kMaxEntities; ++id) { auto& ent = rawEntities()[id]; ent.baseType = EntityBaseType::null; ent.id = EntityId(id); ent.nextEntityId = EntityId::null; ent.linkedListOffset = getLinkedListOffset(EntityListType::nullMoney); if (previous == nullptr) { ent.llPreviousId = EntityId::null; rawListHeads()[enumValue(EntityListType::nullMoney)] = EntityId(id); } else { ent.llPreviousId = previous->id; previous->nextEntityId = EntityId(id); } previous = &ent; } rawListCounts()[enumValue(EntityListType::nullMoney)] = Limits::kMaxMoneyEntities; resetSpatialIndex(); EntityTweener::get().reset(); } void freeUserStrings() { for (auto& entity : rawEntities()) { if (entity.baseType == EntityBaseType::null) { continue; } StringManager::emptyUserString(entity.name); } } EntityId firstId(EntityListType list) { return rawListHeads()[enumValue(list)]; } uint16_t getListCount(const EntityListType list) { return rawListCounts()[enumValue(list)]; } template<> EntityBase* get(EntityId id) { EntityBase* result = nullptr; if (enumValue(id) < Limits::kMaxEntities) { return &rawEntities()[enumValue(id)]; } return result; } constexpr size_t getSpatialIndexOffset(const World::Pos2& loc) { if (loc.x == Location::null) { return kEntitySpatialIndexNull; } const auto tileX = std::abs(loc.x) / World::kTileSize; const auto tileY = std::abs(loc.y) / World::kTileSize; if (tileX >= World::kMapPitch || tileY >= World::kMapPitch) { return kEntitySpatialIndexNull; } return (World::kMapPitch * tileX) + tileY; } EntityId firstQuadrantId(const World::Pos2& loc) { auto index = getSpatialIndexOffset(loc); return _entitySpatialIndex[index]; } static void insertToSpatialIndex(EntityBase& entity, const size_t newIndex) { entity.nextQuadrantId = _entitySpatialIndex[newIndex]; _entitySpatialIndex[newIndex] = entity.id; } static void insertToSpatialIndex(EntityBase& entity) { const auto index = getSpatialIndexOffset(entity.position); insertToSpatialIndex(entity, index); } // 0x0046FF54 void resetSpatialIndex() { // Clear existing array std::fill(std::begin(_entitySpatialIndex), std::end(_entitySpatialIndex), EntityId::null); // Original filled an unreferenced array at 0x010A5A8E as well then overwrote part of it??? // Refill the index for (auto& ent : entities()) { insertToSpatialIndex(ent); } } // 0x0046FC57 void updateSpatialIndex() { for (auto& ent : entities()) { ent.moveTo(ent.position); } } static bool removeFromSpatialIndex(EntityBase& entity, const size_t index) { auto* quadId = &_entitySpatialIndex[index]; _entitySpatialCount = 0; while (enumValue(*quadId) < Limits::kMaxEntities) { auto* quadEnt = get<EntityBase>(*quadId); if (quadEnt == &entity) { *quadId = entity.nextQuadrantId; return true; } _entitySpatialCount++; if (_entitySpatialCount > Limits::kMaxEntities) { break; } quadId = &quadEnt->nextQuadrantId; } return false; } static bool removeFromSpatialIndex(EntityBase& entity) { const auto index = getSpatialIndexOffset(entity.position); return removeFromSpatialIndex(entity, index); } void moveSpatialEntry(EntityBase& entity, const World::Pos3& loc) { const auto newIndex = getSpatialIndexOffset(loc); const auto oldIndex = getSpatialIndexOffset(entity.position); if (newIndex != oldIndex) { if (!removeFromSpatialIndex(entity, oldIndex)) { Logging::info("Invalid quadrant ids... Resetting spatial index."); resetSpatialIndex(); moveSpatialEntry(entity, loc); return; } insertToSpatialIndex(entity, newIndex); } entity.position = loc; } static EntityBase* createEntity(EntityId id, EntityListType list) { auto* newEntity = get<EntityBase>(id); if (newEntity == nullptr) { Logging::error("Tried to create invalid entity! id: {}, list: {}", enumValue(id), enumValue(list)); return nullptr; } moveEntityToList(newEntity, list); newEntity->position = { Location::null, Location::null, 0 }; insertToSpatialIndex(*newEntity); newEntity->name = StringIds::empty_pop; newEntity->spriteWidth = 16; newEntity->spriteHeightNegative = 20; newEntity->spriteHeightPositive = 8; newEntity->vehicleFlags = VehicleFlags::none; newEntity->spriteLeft = Location::null; return newEntity; } // 0x004700A5 EntityBase* createEntityMisc() { if (getListCount(EntityListType::misc) >= Limits::kMaxMiscEntities) { return nullptr; } if (getListCount(EntityListType::null) <= 0) { return nullptr; } auto newId = rawListHeads()[enumValue(EntityListType::null)]; return createEntity(newId, EntityListType::misc); } // 0x0047011C EntityBase* createEntityMoney() { if (getListCount(EntityListType::nullMoney) <= 0) { return nullptr; } const auto newId = rawListHeads()[enumValue(EntityListType::nullMoney)]; return createEntity(newId, EntityListType::misc); } // 0x00470039 EntityBase* createEntityVehicle() { if (getListCount(EntityListType::null) <= 0) { return nullptr; } const auto newId = rawListHeads()[enumValue(EntityListType::null)]; return createEntity(newId, EntityListType::vehicle); } // 0x0047024A void freeEntity(EntityBase* const entity) { EntityTweener::get().removeEntity(entity); auto list = enumValue(entity->id) < 19800 ? EntityListType::null : EntityListType::nullMoney; moveEntityToList(entity, list); StringManager::emptyUserString(entity->name); entity->baseType = EntityBaseType::null; if (!removeFromSpatialIndex(*entity)) { Logging::info("Invalid quadrant ids... Resetting spatial index."); resetSpatialIndex(); } } // 0x0047019F void moveEntityToList(EntityBase* const entity, const EntityListType list) { const auto newListOffset = getLinkedListOffset(list); if (entity->linkedListOffset == newListOffset) { return; } const auto newListIndex = enumValue(list); const auto oldListIndex = getLinkedListIndex(entity->linkedListOffset); const auto nextId = entity->nextEntityId; const auto previousId = entity->llPreviousId; // Unlink previous entity from this entity if (previousId == EntityId::null) { rawListHeads()[oldListIndex] = nextId; } else { auto* previousEntity = get<EntityBase>(previousId); if (previousEntity == nullptr) { Logging::error("Invalid previous entity id. Entity linked list corrupted? Id: {}", enumValue(previousId)); } else { previousEntity->nextEntityId = nextId; } } // Unlink next entity from this entity if (nextId != EntityId::null) { auto* nextEntity = get<EntityBase>(nextId); if (nextEntity == nullptr) { Logging::error("Invalid next entity id. Entity linked list corrupted? Id: {}", enumValue(nextId)); } else { nextEntity->llPreviousId = previousId; } } entity->llPreviousId = EntityId::null; entity->linkedListOffset = newListOffset; entity->nextEntityId = rawListHeads()[newListIndex]; rawListHeads()[newListIndex] = entity->id; // Link next entity to this entity if (entity->nextEntityId != EntityId::null) { auto* nextEntity = get<EntityBase>(entity->nextEntityId); if (nextEntity == nullptr) { Logging::error("Invalid next entity id. Entity linked list corrupted? Id: {}", enumValue(entity->nextEntityId)); } else { nextEntity->llPreviousId = entity->id; } } rawListCounts()[oldListIndex]--; rawListCounts()[newListIndex]++; } // 0x00470188 bool checkNumFreeEntities(const size_t numNewEntities) { if (getListCount(EntityListType::null) <= numNewEntities) { GameCommands::setErrorText(StringIds::too_many_objects_in_game); return false; } return true; } static void zeroEntity(EntityBase* ent) { auto next = ent->nextEntityId; auto previous = ent->llPreviousId; auto id = ent->id; auto llOffset = ent->linkedListOffset; std::fill_n(reinterpret_cast<uint8_t*>(ent), sizeof(Entity), 0); ent->baseType = EntityBaseType::null; ent->nextEntityId = next; ent->llPreviousId = previous; ent->id = id; ent->linkedListOffset = llOffset; } // 0x0046FED5 void zeroUnused() { for (auto* ent : EntityList<EntityListIterator<EntityBase>, EntityListType::null>()) { zeroEntity(ent); } for (auto* ent : EntityList<EntityListIterator<EntityBase>, EntityListType::nullMoney>()) { zeroEntity(ent); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Entities/EntityManager.h ```h #pragma once #include "Entity.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Engine/World.hpp> #include <cstdio> #include <iterator> namespace OpenLoco::Vehicles { struct VehicleHead; } namespace OpenLoco::EntityManager { enum class EntityListType { null, // Used for vehicles and other misc entities (not money) nullMoney, // For some reason money effects have their own pool of entities to use vehicleHead, misc = 4, vehicle = 6, }; void reset(); void freeUserStrings(); template<typename T> T* get(EntityId id); template<> EntityBase* get(EntityId id); template<typename T> T* get(EntityId id) { auto* base = get<EntityBase>(id); return base != nullptr ? base->asBase<T>() : nullptr; } EntityId firstId(EntityListType list); EntityId firstQuadrantId(const World::Pos2& loc); void resetSpatialIndex(); void updateSpatialIndex(); void moveSpatialEntry(EntityBase& entity, const World::Pos3& loc); EntityBase* createEntityMisc(); EntityBase* createEntityMoney(); EntityBase* createEntityVehicle(); void freeEntity(EntityBase* const entity); uint16_t getListCount(const EntityListType list); void moveEntityToList(EntityBase* const entity, const EntityListType list); bool checkNumFreeEntities(const size_t numNewEntities); void zeroUnused(); template<typename TEntityType, EntityId EntityBase::*nextList> class ListIterator { private: TEntityType* entity = nullptr; EntityId nextEntityId = EntityId::null; public: ListIterator(const EntityId _headId) : nextEntityId(_headId) { ++(*this); } ListIterator& operator++() { entity = get<TEntityType>(nextEntityId); if (entity) { nextEntityId = entity->*nextList; } return *this; } ListIterator operator++(int) { ListIterator retval = *this; ++(*this); return retval; } bool operator==(const ListIterator& other) const { return entity == other.entity; } TEntityType* operator*() { if (entity == nullptr) { throw Exception::RuntimeError("Bad Entity List!"); } return entity; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = TEntityType; using pointer = TEntityType*; using reference = TEntityType&; using iterator_category = std::forward_iterator_tag; }; template<typename T> using EntityListIterator = ListIterator<T, &EntityBase::nextEntityId>; template<typename T, EntityListType list> class EntityList { private: EntityId firstId = EntityId::null; public: EntityList() { firstId = EntityManager::firstId(list); } T begin() { return T(firstId); } T end() { return T(EntityId::null); } }; class EntityTileList { private: EntityId firstId = EntityId::null; using Iterator = ListIterator<EntityBase, &EntityBase::nextQuadrantId>; public: EntityTileList(const World::Pos2& loc) { firstId = EntityManager::firstQuadrantId(loc); } Iterator begin() { return Iterator(firstId); } Iterator end() { return Iterator(EntityId::null); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Entities/EntityTweener.cpp ```cpp #include "EntityTweener.h" #include "Entity.h" #include "OpenLoco.h" #include "Vehicles/Vehicle.h" #include <cmath> #include <iostream> namespace OpenLoco { using EntityListType = EntityManager::EntityListType; using EntityListIterator = EntityManager::ListIterator<EntityBase, &EntityBase::nextEntityId>; template<EntityListType id, typename Pred> void PopulateEntities(std::vector<EntityBase*>& list, std::vector<World::Pos3>& posList, const Pred& pred) { auto entsView = EntityManager::EntityList<EntityListIterator, id>(); for (auto* ent : entsView) { if (!pred(ent)) { continue; } list.push_back(ent); posList.emplace_back(ent->position); } } static EntityTweener _tweener; EntityTweener& EntityTweener::get() { return _tweener; } void EntityTweener::preTick() { restore(); reset(); PopulateEntities<EntityListType::misc>(_entities, _prePos, [](auto*) { return true; }); PopulateEntities<EntityListType::vehicle>(_entities, _prePos, [](auto* ent) { const auto* vehicle = ent->template asBase<Vehicles::VehicleBase>(); if (vehicle == nullptr) { // This can be never null but makes the compiler happy. return false; } return vehicle->isVehicleBody() || vehicle->isVehicleBogie(); }); } void EntityTweener::postTick() { for (auto* ent : _entities) { if (ent == nullptr || ent->id == EntityId::null) { // Sprite was removed, add a dummy position to keep the index aligned. _postPos.emplace_back(0, 0, 0); } else { _postPos.emplace_back(ent->position); } } } void EntityTweener::removeEntity(const EntityBase* entity) { auto it = std::find(_entities.begin(), _entities.end(), entity); if (it != _entities.end()) { *it = nullptr; } } void EntityTweener::tween(float alpha) { const float inv = (1.0f - alpha); for (size_t i = 0; i < _entities.size(); ++i) { auto* ent = _entities[i]; if (ent == nullptr) { continue; } auto& posA = _prePos[i]; auto& posB = _postPos[i]; if (posA == posB) { continue; } auto newPos = World::Pos3{ static_cast<int16_t>(std::round(posB.x * alpha + posA.x * inv)), static_cast<int16_t>(std::round(posB.y * alpha + posA.y * inv)), static_cast<int16_t>(std::round(posB.z * alpha + posA.z * inv)) }; if (ent->position == newPos) { continue; } ent->moveTo(newPos); ent->invalidateSprite(); } } void EntityTweener::restore() { for (size_t i = 0; i < _entities.size(); ++i) { auto* ent = _entities[i]; if (ent == nullptr) { continue; } auto& newPos = _postPos[i]; if (ent->position == newPos) { continue; } ent->moveTo(newPos); ent->invalidateSprite(); } } void EntityTweener::reset() { _entities.clear(); _prePos.clear(); _postPos.clear(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Entities/EntityTweener.h ```h #pragma once #include "EntityManager.h" #include <OpenLoco/Engine/World.hpp> #include <vector> namespace OpenLoco { class EntityTweener { std::vector<EntityBase*> _entities; std::vector<World::Pos3> _prePos; std::vector<World::Pos3> _postPos; public: static EntityTweener& get(); void preTick(); void postTick(); void removeEntity(const EntityBase* entity); void tween(float alpha); void restore(); void reset(); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Animation.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> namespace OpenLoco::World { #pragma pack(push, 1) struct Animation { uint8_t baseZ; uint8_t type; World::Pos2 pos; }; static_assert(sizeof(Animation) == 6); #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/AnimationManager.cpp ```cpp #include "AnimationManager.h" #include "Animation.h" #include "BuildingElement.h" #include "Game.h" #include "GameState.h" #include "GameStateFlags.h" #include "IndustryElement.h" #include "RoadElement.h" #include "SignalElement.h" #include "StationElement.h" #include <OpenLoco/Interop/Interop.hpp> #include <array> using namespace OpenLoco::Interop; namespace OpenLoco::World::AnimationManager { static auto& rawAnimations() { return getGameState().animations; } static auto& numAnimations() { return getGameState().numMapAnimations; } // 0x004612A6 void createAnimation(uint8_t type, const Pos2& pos, tile_coord_t baseZ) { if (numAnimations() >= Limits::kMaxAnimations) { return; } for (size_t i = 0; i < numAnimations(); i++) { auto& animation = rawAnimations()[i]; if (animation.type == type && animation.pos == pos && animation.baseZ == baseZ) { return; } } auto& newAnimation = rawAnimations()[numAnimations()++]; newAnimation.baseZ = baseZ; newAnimation.type = type; newAnimation.pos = pos; } // 0x00461166 void reset() { numAnimations() = 0; } static bool callUpdateFunction(Animation& anim) { switch (anim.type) { case 0: return updateSignalAnimation(anim); case 1: return updateLevelCrossingAnimation(anim); case 2: return false; case 3: return updateIndustryAnimation1(anim); case 4: return updateIndustryAnimation2(anim); case 5: return updateBuildingAnimation1(anim); case 6: return updateBuildingAnimation2(anim); case 7: return updateAirportStationAnimation(anim); case 8: return updateDockStationAnimation(anim); } assert(false); return false; } // 0x004612EC void update() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded)) { std::array<bool, Limits::kMaxAnimations> animsToRemove{}; for (uint16_t i = 0; i < numAnimations(); ++i) { auto& animation = rawAnimations()[i]; animsToRemove[i] = callUpdateFunction(animation); } // Remove animations that are no longer required uint16_t last = 0; for (uint16_t i = 0; i < numAnimations(); ++i, ++last) { while (animsToRemove[i] && i < numAnimations()) { ++i; } if (i >= numAnimations()) { break; } rawAnimations()[last] = rawAnimations()[i]; } // For vanilla binary compatibility copy the old last entry across all garbage entries auto repCount = numAnimations() - last; std::fill_n(std::next(std::begin(rawAnimations()), last), repCount, rawAnimations()[numAnimations() - 1]); // Above to be deleted when confirmed matching numAnimations() = last; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/AnimationManager.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> namespace OpenLoco::World::AnimationManager { void createAnimation(uint8_t type, const Pos2& pos, tile_coord_t baseZ); void reset(); void update(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/BuildingElement.cpp ```cpp #include "BuildingElement.h" #include "Animation.h" #include "AnimationManager.h" #include "Game.h" #include "GameCommands/Buildings/RemoveBuilding.h" #include "GameCommands/GameCommands.h" #include "GameStateFlags.h" #include "Objects/BuildingObject.h" #include "Objects/ObjectManager.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "Tile.h" #include "TileManager.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/StationManager.h" #include "World/TownManager.h" namespace OpenLoco::World { const BuildingObject* BuildingElement::getObject() const { return ObjectManager::get<BuildingObject>(objectId()); } template<typename TFunction> static void applyToMultiTile(BuildingElement& el0, const World::Pos2& loc, bool isMultiTile, TFunction&& func) { for (auto& offset : getBuildingTileOffsets(isMultiTile)) { auto* elBuilding = &el0; const auto pos = loc + offset.pos; if (offset.index != 0) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { elBuilding = el.as<BuildingElement>(); if (elBuilding == nullptr) { continue; } if (elBuilding->baseZ() != el0.baseZ()) { elBuilding = nullptr; continue; } break; } } if (elBuilding != nullptr) { func(*elBuilding, pos); } } } // 0x0042DF8B bool BuildingElement::update(const World::Pos2& loc) { // Only update from tile index 0 of multi tile buildings if (sequenceIndex()) { return true; } if (isGhost()) { return true; } const auto* buildingObj = getObject(); const auto isMultiTile = buildingObj->hasFlags(BuildingObjectFlags::largeTile); if (!isConstructed()) { auto newUnk5u = unk5u(); auto newAge = age(); auto isConstructed = false; if (unk5u() != 7) { newUnk5u++; } else { auto parts = buildingObj->getBuildingParts(variation()); if (static_cast<uint32_t>(age() + 1) != parts.size()) { newUnk5u = 0; newAge++; } else { auto totalHeight = 3; const auto partHeights = buildingObj->getBuildingPartHeights(); for (auto part : parts) { totalHeight += partHeights[part]; } const auto newClearHeight = baseZ() + totalHeight / 4; applyToMultiTile(*this, loc, isMultiTile, [newClearHeight](World::BuildingElement& elBuilding2, const World::Pos2& pos) { Ui::ViewportManager::invalidate(pos, elBuilding2.baseHeight(), elBuilding2.clearHeight(), ZoomLevel::quarter); elBuilding2.setClearZ(newClearHeight); }); if (buildingObj->numElevatorSequences != 0) { AnimationManager::createAnimation(5, loc, baseZ()); } TownManager::updateTownInfo(loc, buildingObj->producedQuantity[0], 0, 0, 0); newUnk5u = 0; newAge = 0; isConstructed = true; } } applyToMultiTile(*this, loc, isMultiTile, [isConstructed, newUnk5u, newAge](World::BuildingElement& elBuilding2, const World::Pos2& pos) { elBuilding2.setConstructed(isConstructed); elBuilding2.setUnk5u(newUnk5u); elBuilding2.setAge(newAge); Ui::ViewportManager::invalidate(pos, elBuilding2.baseHeight(), elBuilding2.clearHeight(), ZoomLevel::quarter); }); } if (isMiscBuilding() || SceneManager::isEditorMode()) { return true; } auto res = TownManager::getClosestTownAndDensity(loc); if (!res) { return true; } auto* town = TownManager::get(res->first); if (isConstructed()) { setUnk5u(unk5u() + 1); if (!unk5u() && age() != 63) { const auto newAge = age() + 1; // Why are we not invalidating?? applyToMultiTile(*this, loc, isMultiTile, [newAge](World::BuildingElement& elBuilding2, const World::Pos2&) { elBuilding2.setAge(newAge); }); } } if (isConstructed() && age() >= 40) { if (town->prng.randNext(0xFFFF) <= 16) { GameCommands::BuildingRemovalArgs args; args.pos = World::Pos3(loc.x, loc.y, baseHeight()); GameCommands::doCommand(args, GameCommands::Flags::apply); return false; } } if (isConstructed()) { // This is purely to keep things in sync when confirmed no desync move // rand call into loop and force a desync. const uint16_t randVal = town->prng.randNext(0xFFFF); const uint8_t randArr[2] = { static_cast<uint8_t>(randVal), static_cast<uint8_t>(randVal >> 8) }; for (auto i = 0; i < 2; ++i) { if (randArr[i] >= buildingObj->producedQuantity[i]) { continue; } auto producedAmount = randArr[i] / 4 + 1; if (Game::hasFlags(GameStateFlags::unk2)) { producedAmount = (producedAmount + 1) / 2; } town->var_19C[i][0] += producedAmount; const auto size = buildingObj->hasFlags(BuildingObjectFlags::largeTile) ? World::TilePos2(2, 2) : World::TilePos2(1, 1); town->var_19C[i][1] += StationManager::deliverCargoToNearbyStations(buildingObj->producedCargoType[i], producedAmount, loc, size) & 0xFF; } } return true; } // 0x0042E4D4 bool updateBuildingAnimation1(const Animation& anim) { auto tile = TileManager::get(anim.pos); BuildingElement* elBuilding = nullptr; for (auto& el : tile) { elBuilding = el.as<BuildingElement>(); if (elBuilding == nullptr) { continue; } if (elBuilding->baseZ() != anim.baseZ) { continue; } break; } if (elBuilding == nullptr) { return true; } // Animations are controlled from index 0 if (elBuilding->sequenceIndex() != 0) { return true; } auto* buildingObj = elBuilding->getObject(); if (buildingObj->numElevatorSequences == 0) { return true; } if (ScenarioManager::getScenarioTicks() & 0b1) { return false; } bool isMultiTile = buildingObj->hasFlags(BuildingObjectFlags::largeTile); applyToMultiTile(*elBuilding, anim.pos, isMultiTile, [](World::BuildingElement& elBuilding, const World::Pos2& pos) { Ui::ViewportManager::invalidate(pos, elBuilding.baseHeight(), elBuilding.clearHeight(), ZoomLevel::half); }); return false; } // 0x0042E646 bool updateBuildingAnimation2(const Animation& anim) { auto tile = TileManager::get(anim.pos); BuildingElement* elBuilding = nullptr; for (auto& el : tile) { elBuilding = el.as<BuildingElement>(); if (elBuilding == nullptr) { continue; } if (elBuilding->baseZ() != anim.baseZ) { continue; } break; } if (elBuilding == nullptr) { return true; } auto* buildingObj = elBuilding->getObject(); const auto parts = buildingObj->getBuildingParts(elBuilding->variation()); const auto partAnimations = buildingObj->getBuildingPartAnimations(); uint8_t slowestSpeed = 0xFF; uint8_t numFrames = 0; for (auto part : parts) { auto& partAnim = partAnimations[part]; const uint8_t animSpeed = partAnim.animationSpeed & ~(1U << 7); if (partAnim.numFrames == 0) { continue; } numFrames |= partAnim.numFrames; if (partAnim.numFrames == 1) { continue; } slowestSpeed = std::min(slowestSpeed, animSpeed); } if (numFrames <= 1) { return true; } const auto speedMask = ((1 << slowestSpeed) - 1); if (!(ScenarioManager::getScenarioTicks() & speedMask)) { Ui::ViewportManager::invalidate(anim.pos, elBuilding->baseHeight(), elBuilding->clearHeight(), ZoomLevel::quarter); } return false; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/BuildingElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco { struct BuildingObject; } namespace OpenLoco::World { #pragma pack(push, 1) struct BuildingElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::building; private: uint8_t _4; uint8_t _5; uint16_t _6; public: uint8_t rotation() const { return _type & 0x03; } void setRotation(uint8_t rotation) { _type &= ~0x03; _type |= rotation & 0x3; } // Saves having to access the building object flags bool isMiscBuilding() const { return (_type & 0x40) != 0; } void setIsMiscBuilding(bool state) { _type &= ~0x40; _type |= state ? 0x40 : 0; } bool isConstructed() const { return (_type & 0x80) != 0; } void setConstructed(bool state) { _type &= ~0x80; _type |= state ? 0x80 : 0; } Colour colour() const { return static_cast<Colour>(_6 >> 11); } void setColour(Colour colour) { _6 = (_6 & 0x7FF) | (enumValue(colour) << 11); } uint8_t objectId() const { return _4; } void setObjectId(uint8_t id) { _4 = id; } const BuildingObject* getObject() const; uint8_t sequenceIndex() const { return _5 & 3; } void setSequenceIndex(uint8_t index) { _5 &= ~0x03; _5 |= index & 0x3; } uint8_t unk5u() const { return _5 >> 5; } // likely age related as well (higher precision) void setUnk5u(uint8_t value) { _5 &= ~0xE0; _5 |= value << 5; } uint8_t variation() const { return (_6 >> 6) & 0x1F; } void setVariation(uint8_t variation) { _6 &= ~0x07C0; _6 |= (variation & 0x1F) << 6; } uint8_t age() const { return _6 & 0x3F; } // 6l void setAge(uint8_t value) // 6l { _6 &= ~0x3F; _6 |= value & 0x3F; } bool update(const World::Pos2& loc); }; #pragma pack(pop) static_assert(sizeof(BuildingElement) == kTileElementSize); struct Animation; bool updateBuildingAnimation1(const Animation& anim); bool updateBuildingAnimation2(const Animation& anim); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/IndustryElement.cpp ```cpp #include "IndustryElement.h" #include "Animation.h" #include "AnimationManager.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "ScenarioManager.h" #include "StationElement.h" #include "TileLoop.hpp" #include "TileManager.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/Industry.h" #include "World/IndustryManager.h" #include <numeric> namespace OpenLoco::World { Industry* IndustryElement::industry() const { return IndustryManager::get(_industryId); } uint8_t IndustryElement::buildingType() const { return (_6 >> 6) & 0x1F; } Colour IndustryElement::var_6_F800() const { return static_cast<Colour>((_6 >> 11) & 0x1F); } uint8_t IndustryElement::var_6_003F() const { return _6 & 0x3F; } void IndustryElement::setVar_6_003F(uint8_t val) { _6 &= ~(0x3F); _6 |= val & 0x3F; } uint8_t IndustryElement::sectionProgress() const { return (_5 >> 5) & 0x7; } void IndustryElement::setSectionProgress(uint8_t val) { _5 &= ~(0xE0); _5 |= (val & 0x7) << 5; } uint8_t IndustryElement::sequenceIndex() const { return _5 & 0x3; } void IndustryElement::setIsConstructed(bool val) { _type &= ~(1 << 7); _type |= val ? (1 << 7) : 0; } // 0x0045769A // A more generic version of the vanilla function template<typename TFunction> static void applyToMultiTile(IndustryElement& el0, const World::Pos2& loc, bool isMultiTile, TFunction&& func) { for (auto& offset : getBuildingTileOffsets(isMultiTile)) { auto* elIndustry = &el0; const auto pos = loc + offset.pos; if (offset.index != 0) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { elIndustry = el.as<IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->baseZ() != el0.baseZ()) { elIndustry = nullptr; continue; } break; } } if (elIndustry != nullptr) { func(*elIndustry, pos); } } } // 0x00456FF7 bool IndustryElement::update(const World::Pos2& loc) { // Sequence 0 updates all the other ones if (sequenceIndex() != 0) { return true; } if (isGhost()) { return true; } auto* ind = industry(); const auto* indObj = ind->getObject(); const auto type = buildingType(); const auto isMultiTile = indObj->buildingSizeFlags & (1 << type); if (!isConstructed()) { bool newConstructed = isConstructed(); uint8_t newSectionProgress = sectionProgress(); uint8_t newNumSections = var_6_003F(); const auto progress = sectionProgress(); if (progress == 0x7) { const size_t numSections = var_6_003F(); const auto parts = indObj->getBuildingParts(type); const auto heights = indObj->getBuildingPartHeights(); if (parts.size() <= numSections + 1) { ind->under_construction++; if (ind->under_construction >= ind->numTiles) { ind->under_construction = 0xFF; Ui::WindowManager::invalidate(Ui::WindowType::industry, enumValue(ind->id())); Ui::WindowManager::invalidate(Ui::WindowType::industryList); } const auto height = std::accumulate(parts.begin(), parts.end(), 0, [partHeights = heights](int32_t total, uint8_t part) { return total + partHeights[part]; }); const auto newClearZ = ((height + 3) / World::kSmallZStep) + baseZ(); applyToMultiTile(*this, loc, isMultiTile, [newClearZ](World::IndustryElement& elIndustry, const World::Pos2& pos) { Ui::ViewportManager::invalidate(pos, elIndustry.baseHeight(), elIndustry.clearHeight(), ZoomLevel::quarter); elIndustry.setClearZ(newClearZ); }); newConstructed = true; newSectionProgress = 0; newNumSections = 0; } else { newSectionProgress = 0; newNumSections++; } } else { newSectionProgress++; } applyToMultiTile(*this, loc, isMultiTile, [newConstructed, newSectionProgress, newNumSections](World::IndustryElement& elIndustry, const World::Pos2& pos) { elIndustry.setIsConstructed(newConstructed); elIndustry.setSectionProgress(newSectionProgress); elIndustry.setVar_6_003F(newNumSections); Ui::ViewportManager::invalidate(pos, elIndustry.baseHeight(), elIndustry.clearHeight(), ZoomLevel::quarter); }); } // Might have changed so can't be combined with above if if (isConstructed()) { bool hasAZeroFrame = false; const auto buildingPartAnims = indObj->getBuildingPartAnimations(); for (auto& part : indObj->getBuildingParts(type)) { const auto animFrames = buildingPartAnims[part].numFrames; if (animFrames == 0) { hasAZeroFrame = true; break; } } if (hasAZeroFrame && !(var_6_003F() & (1 << 5))) { std::array<uint8_t, 8> _E0C3D4{}; auto ptr = _E0C3D4.begin(); for (const auto& unk38 : indObj->getUnk38()) { if (unk38.var_00 == type) { *ptr++ = unk38.var_01; } } const auto numAnimations = std::distance(_E0C3D4.begin(), ptr); if (numAnimations != 0) { const auto rand = ind->prng.randNext(); if ((rand & 0x700) == 0) { const auto randAnim = _E0C3D4[(numAnimations * (rand & 0xFF)) / 256]; const auto newVar6_3F = randAnim | (1 << 5) | (var_6_003F() & 0xC); applyToMultiTile(*this, loc, isMultiTile, [newVar6_3F](IndustryElement& elIndustry, [[maybe_unused]] const World::Pos2& pos) { elIndustry.setVar_6_003F(newVar6_3F); }); AnimationManager::createAnimation(4, loc, baseZ()); } } } } if (ind->under_construction == 0xFF) { const coord_t upperRange = isMultiTile ? 5 : 4; constexpr coord_t kLowerRange = 4; // Find all stations in range of industry building const auto tileStart = toTileSpace(loc); for (auto& tilePos : getClampedRange(tileStart - TilePos2{ kLowerRange, kLowerRange }, tileStart + TilePos2{ upperRange, upperRange })) { auto tile = TileManager::get(tilePos); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->isGhost() || elStation->isAiAllocated()) { continue; } const auto station = elStation->stationId(); ind->stationsInRange.set(enumValue(station), true); } } } return true; } // 0x00456E32 bool updateIndustryAnimation1(const Animation& anim) { auto tile = TileManager::get(anim.pos); for (auto& el : tile) { auto* elIndustry = el.as<IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->baseZ() != anim.baseZ) { continue; } auto* industry = elIndustry->industry(); const auto* indObj = industry->getObject(); const auto buildingParts = indObj->getBuildingParts(elIndustry->buildingType()); const auto buildingPartAnims = indObj->getBuildingPartAnimations(); bool hasAnimation = false; uint8_t animSpeed = std::numeric_limits<uint8_t>::max(); for (auto& part : buildingParts) { auto& partAnim = buildingPartAnims[part]; if (partAnim.numFrames > 1) { hasAnimation = true; animSpeed = std::min<uint8_t>(animSpeed, partAnim.animationSpeed & ~(1 << 7)); } } if (!hasAnimation) { return true; } const auto speedMask = ((1 << animSpeed) - 1); if (!(ScenarioManager::getScenarioTicks() & speedMask)) { Ui::ViewportManager::invalidate(anim.pos, el.baseHeight(), el.clearHeight(), ZoomLevel::quarter); } return false; } return true; } // 0x00456EEB bool updateIndustryAnimation2(const Animation& anim) { auto tile = TileManager::get(anim.pos); for (auto& el : tile) { auto* elIndustry = el.as<IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->baseZ() != anim.baseZ) { continue; } if (!(elIndustry->var_6_003F() & (1 << 5))) { continue; } auto* industry = elIndustry->industry(); const auto* indObj = industry->getObject(); const auto type = elIndustry->buildingType(); const auto buildingParts = indObj->getBuildingParts(type); const auto buildingPartAnims = indObj->getBuildingPartAnimations(); // Guaranteed power of 2 auto animLength = indObj->getAnimationSequence(elIndustry->var_6_003F() & 0x3).size(); const auto isMultiTile = indObj->buildingSizeFlags & (1 << type); for (auto& part : buildingParts) { auto& partAnim = buildingPartAnims[part]; if (partAnim.numFrames == 0) { const auto animSpeed = partAnim.animationSpeed & ~(1 << 7); const auto speedMask = animLength - 1; if (elIndustry->var_6_003F() & (1 << 4)) { if ((speedMask & (ScenarioManager::getScenarioTicks() >> animSpeed)) == 0) { applyToMultiTile(*elIndustry, anim.pos, isMultiTile, [](World::IndustryElement& elIndustry, const World::Pos2& pos) { Ui::ViewportManager::invalidate(pos, elIndustry.baseHeight(), elIndustry.clearHeight(), ZoomLevel::quarter); elIndustry.setVar_6_003F(elIndustry.var_6_003F() & ~(1 << 5)); }); return true; } else { const auto speedMask2 = (1 << animSpeed) - 1; if (!(speedMask2 & ScenarioManager::getScenarioTicks())) { applyToMultiTile(*elIndustry, anim.pos, isMultiTile, [](World::IndustryElement& elIndustry, const World::Pos2& pos) { Ui::ViewportManager::invalidate(pos, elIndustry.baseHeight(), elIndustry.clearHeight(), ZoomLevel::quarter); }); } return false; } } else { if ((speedMask & (ScenarioManager::getScenarioTicks() >> animSpeed)) == 1) { applyToMultiTile(*elIndustry, anim.pos, isMultiTile, [](World::IndustryElement& elIndustry, const World::Pos2& pos) { Ui::ViewportManager::invalidate(pos, elIndustry.baseHeight(), elIndustry.clearHeight(), ZoomLevel::quarter); elIndustry.setVar_6_003F(elIndustry.var_6_003F() | (1 << 4)); }); } return false; } } } } return true; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/IndustryElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco { struct Industry; } namespace OpenLoco::World { #pragma pack(push, 1) struct IndustryElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::industry; private: IndustryId _industryId; uint8_t _5; uint16_t _6; public: // _4 IndustryId industryId() const { return _industryId; } void setIndustryId(const IndustryId id) { _industryId = id; } Industry* industry() const; // var_6_07C0 uint8_t buildingType() const; void setBuildingType(uint8_t type) { _6 &= ~0x7C0; _6 |= type << 6; } uint8_t rotation() const { return _type & 0x3; } void setRotation(const uint8_t rotation) { _type &= ~0x3; _type |= rotation & 0x3; } // var_5_03 uint8_t sequenceIndex() const; void setSequenceIndex(const uint8_t index) { _5 &= ~0x3; _5 |= index & 0x3; } // var_5_E0 uint8_t sectionProgress() const; void setSectionProgress(uint8_t val); Colour var_6_F800() const; void setColour(Colour c) { _6 &= ~0xF800; _6 |= enumValue(c) << 11; } // This has two uses. When under construction it is the number of completed sections. Otherwise its animation sequence related uint8_t var_6_003F() const; void setVar_6_003F(uint8_t val); bool isConstructed() const { return _type & 0x80; } void setIsConstructed(bool val); bool update(const World::Pos2& loc); }; #pragma pack(pop) static_assert(sizeof(IndustryElement) == kTileElementSize); struct Animation; bool updateIndustryAnimation1(const Animation& anim); bool updateIndustryAnimation2(const Animation& anim); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapSelection.cpp ```cpp #include "MapSelection.h" #include "Input.h" #include "Map/TileManager.h" #include "Ui/ViewportInteraction.h" #include <utility> namespace OpenLoco::World { static MapSelectionFlags _mapSelectionFlags = MapSelectionFlags::none; // 0x00F24484 static coord_t _mapSelectionAX = 0; // 0x00F24486 static coord_t _mapSelectionBX = 0; // 0x00F24488 static coord_t _mapSelectionAY = 0; // 0x00F2448A static coord_t _mapSelectionBY = 0; // 0x00F2448C static MapSelectionType _mapSelectionType = MapSelectionType::corner0; // 0x00F2448E constexpr uint16_t kMapSelectedFreeFormTilesSize = 300; sfl::static_vector<Pos2, kMapSelectedFreeFormTilesSize> _mapSelectedFreeFormTiles; // TODO: Return std::optional uint16_t setMapSelectionTiles(const Pos2& loc, const MapSelectionType selectionType, uint16_t toolSizeA) { uint16_t xPos = loc.x; uint16_t yPos = loc.y; uint8_t count = 0; if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { World::setMapSelectionFlags(World::MapSelectionFlags::enable); count++; } if (_mapSelectionType != selectionType) { _mapSelectionType = selectionType; count++; } if (!toolSizeA) { toolSizeA = 1; } toolSizeA = toolSizeA << 5; uint16_t toolSizeB = toolSizeA; toolSizeB -= 32; toolSizeA = toolSizeA >> 1; toolSizeA -= 16; xPos -= toolSizeA; yPos -= toolSizeA; xPos &= 0xFFE0; yPos &= 0xFFE0; if (xPos != _mapSelectionAX) { _mapSelectionAX = xPos; count++; } if (yPos != _mapSelectionAY) { _mapSelectionAY = yPos; count++; } xPos += toolSizeB; yPos += toolSizeB; if (xPos != _mapSelectionBX) { _mapSelectionBX = xPos; count++; } if (yPos != _mapSelectionBY) { _mapSelectionBY = yPos; count++; } mapInvalidateSelectionRect(); return count; } uint16_t setMapSelectionSingleTile(const Pos2& loc, bool setQuadrant) { uint16_t xPos = loc.x & 0xFFE0; uint16_t yPos = loc.y & 0xFFE0; MapSelectionType cursorQuadrant = getQuadrantOrCentreFromPos(loc); auto count = 0; if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { World::setMapSelectionFlags(World::MapSelectionFlags::enable); count++; } if (setQuadrant && _mapSelectionType != cursorQuadrant) { _mapSelectionType = cursorQuadrant; count++; } else if (!setQuadrant && _mapSelectionType != MapSelectionType::full) { _mapSelectionType = MapSelectionType::full; count++; } if (xPos != _mapSelectionAX) { _mapSelectionAX = xPos; count++; } if (yPos != _mapSelectionAY) { _mapSelectionAY = yPos; count++; } if (xPos != _mapSelectionBX) { _mapSelectionBX = xPos; count++; } if (yPos != _mapSelectionBY) { _mapSelectionBY = yPos; count++; } mapInvalidateSelectionRect(); return count; } // 0x004610F2 void mapInvalidateSelectionRect() { if (World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { for (coord_t x = _mapSelectionAX; x <= _mapSelectionBX; x += 32) { for (coord_t y = _mapSelectionAY; y <= _mapSelectionBY; y += 32) { TileManager::mapInvalidateTileFull({ x, y }); } } } } void resetMapSelectionFreeFormTiles() { _mapSelectedFreeFormTiles.clear(); } void addMapSelectionFreeFormTile(const Pos2& pos) { _mapSelectedFreeFormTiles.push_back(pos); } std::span<const Pos2> getMapSelectionFreeFormTiles() { return _mapSelectedFreeFormTiles; } // 0x0046112C void mapInvalidateMapSelectionFreeFormTiles() { if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enableConstruct)) { return; } for (const auto& position : _mapSelectedFreeFormTiles) { TileManager::mapInvalidateTileFull(position); } } bool isWithinMapSelectionFreeFormTiles(const Pos2 pos) { if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enableConstruct)) { return false; } return std::ranges::find(_mapSelectedFreeFormTiles, pos) != _mapSelectedFreeFormTiles.end(); } void setMapSelectionArea(const Pos2& locA, const Pos2& locB) { _mapSelectionAX = std::min(locA.x, locB.x); _mapSelectionAY = std::min(locA.y, locB.y); _mapSelectionBX = std::max(locA.x, locB.x); _mapSelectionBY = std::max(locA.y, locB.y); } std::pair<Pos2, Pos2> getMapSelectionArea() { return std::make_pair(Pos2{ _mapSelectionAX, _mapSelectionAY }, Pos2{ _mapSelectionBX, _mapSelectionBY }); } void setMapSelectionCorner(const MapSelectionType corner) { _mapSelectionType = corner; } MapSelectionType getMapSelectionCorner() { return _mapSelectionType; } // 0x0045FD8E // NOTE: Original call getSurfaceLocFromUi within this function // instead OpenLoco has split it in two. Also note that result of original // was a Pos2 start i.e. (& 0xFFE0) both components MapSelectionType getQuadrantOrCentreFromPos(const Pos2& loc) { // Determine to which quadrants the cursor is closest 4 == all quadrants const auto xNibbleCentre = std::abs((loc.x & 0xFFE0) + 16 - loc.x); const auto yNibbleCentre = std::abs((loc.y & 0xFFE0) + 16 - loc.y); if (std::max(xNibbleCentre, yNibbleCentre) <= 7) { // Is centre so all quadrants return MapSelectionType::full; } return getQuadrantFromPos(loc); } // 0x0045FE05 // NOTE: Original call getSurfaceLocFromUi within this function // instead OpenLoco has split it in two. Also note that result of original // was a Pos2 start i.e. (& 0xFFE0) both components MapSelectionType getQuadrantFromPos(const Pos2& loc) { const auto xNibble = loc.x & 0x1F; const auto yNibble = loc.y & 0x1F; if (xNibble > 16) { return (yNibble >= 16) ? MapSelectionType::corner0 : MapSelectionType::corner1; } else { return (yNibble >= 16) ? MapSelectionType::corner3 : MapSelectionType::corner2; } } // 0x0045FE4C // NOTE: Original call getSurfaceLocFromUi within this function // instead OpenLoco has split it in two. Also note that result of original // was a Pos2 start i.e. (& 0xFFE0) both components MapSelectionType getSideFromPos(const Pos2& loc) { const auto xNibble = loc.x & 0x1F; const auto yNibble = loc.y & 0x1F; if (xNibble < yNibble) { return (xNibble + yNibble < 32) ? MapSelectionType::corner0 : MapSelectionType::corner1; } else { return (xNibble + yNibble < 32) ? MapSelectionType::corner3 : MapSelectionType::corner2; } } MapSelectionFlags getMapSelectionFlags() { return _mapSelectionFlags; } bool hasMapSelectionFlag(MapSelectionFlags flags) { return (_mapSelectionFlags & flags) != MapSelectionFlags::none; } void setMapSelectionFlags(MapSelectionFlags flags) { _mapSelectionFlags = _mapSelectionFlags | flags; } void resetMapSelectionFlag(MapSelectionFlags flags) { _mapSelectionFlags = _mapSelectionFlags & ~flags; } void resetMapSelectionFlags() { _mapSelectionFlags = MapSelectionFlags::none; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapSelection.h ```h #pragma once #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/Types.hpp> #include <OpenLoco/Engine/World.hpp> #include <span> namespace OpenLoco::World { enum class MapSelectionFlags : uint8_t { none = 0U, enable = 1U << 0, enableConstruct = 1U << 1, enableConstructionArrow = 1U << 2, unk_03 = 1U << 3, unk_04 = 1U << 4, // Vehicle orders? catchmentArea = 1U << 5, hoveringOverStation = 1U << 6, }; OPENLOCO_ENABLE_ENUM_OPERATORS(MapSelectionFlags); enum MapSelectionType : uint8_t { corner0, corner1, corner2, corner3, full, fullWater, quarter0, quarter1, quarter2, quarter3, edge0, edge1, edge2, edge3, }; uint16_t setMapSelectionTiles(const Pos2& loc, const MapSelectionType selectionType, uint16_t toolSize); uint16_t setMapSelectionSingleTile(const Pos2& loc, bool setQuadrant = false); void mapInvalidateSelectionRect(); void resetMapSelectionFreeFormTiles(); void addMapSelectionFreeFormTile(const Pos2& pos); std::span<const Pos2> getMapSelectionFreeFormTiles(); void mapInvalidateMapSelectionFreeFormTiles(); bool isWithinMapSelectionFreeFormTiles(const Pos2 pos); void setMapSelectionArea(const Pos2& locA, const Pos2& locB); std::pair<Pos2, Pos2> getMapSelectionArea(); void setMapSelectionCorner(const MapSelectionType corner); MapSelectionType getMapSelectionCorner(); MapSelectionType getQuadrantOrCentreFromPos(const Pos2& loc); MapSelectionType getQuadrantFromPos(const Pos2& loc); MapSelectionType getSideFromPos(const Pos2& loc); MapSelectionFlags getMapSelectionFlags(); bool hasMapSelectionFlag(MapSelectionFlags flags); void setMapSelectionFlags(MapSelectionFlags flags); void resetMapSelectionFlag(MapSelectionFlags flags); void resetMapSelectionFlags(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/QuarterTile.h ```h #pragma once #include <cstdint> namespace OpenLoco::World { class QuarterTile { private: uint8_t _val{ 0 }; public: explicit constexpr QuarterTile(uint8_t tileQuarter, uint8_t zQuarter) : _val(tileQuarter | (zQuarter << 4)) { } explicit constexpr QuarterTile(uint8_t tileAndZQuarter) : _val(tileAndZQuarter) { } // Rotate both of the values amount. Returns new RValue QuarterTile constexpr const QuarterTile rotate(uint8_t amount) const { switch (amount) { default: return QuarterTile{ *this }; case 1: { auto rotVal1 = _val << 1; auto rotVal2 = rotVal1 >> 4; // Clear the bit from the tileQuarter rotVal1 &= 0b11101110; // Clear the bit from the zQuarter rotVal2 &= 0b00010001; return QuarterTile{ static_cast<uint8_t>(rotVal1 | rotVal2) }; } case 2: { auto rotVal1 = _val << 2; auto rotVal2 = rotVal1 >> 4; // Clear the bit from the tileQuarter rotVal1 &= 0b11001100; // Clear the bit from the zQuarter rotVal2 &= 0b00110011; return QuarterTile{ static_cast<uint8_t>(rotVal1 | rotVal2) }; } case 3: { auto rotVal1 = _val << 3; auto rotVal2 = rotVal1 >> 4; // Clear the bit from the tileQuarter rotVal1 &= 0b10001000; // Clear the bit from the zQuarter rotVal2 &= 0b01110111; return QuarterTile{ static_cast<uint8_t>(rotVal1 | rotVal2) }; } } } constexpr uint8_t getBaseQuarterOccupied() const { return _val & 0xF; } constexpr uint8_t getZQuarterOccupied() const { return (_val >> 4) & 0xF; } }; static_assert(sizeof(QuarterTile) == 1); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/RoadElement.cpp ```cpp #include "RoadElement.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/RemoveRoad.h" #include "GameState.h" #include "Objects/LevelCrossingObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "ScenarioManager.h" #include "Tile.h" #include "TileManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::World { RoadElement::RoadElement(World::SmallZ baseZ, World::SmallZ clearZ) : _4(0) , _5(0) , _6(0) , _7(0) { _type = 0; _flags = 0; setType(World::ElementType::road); setBaseZ(baseZ); setClearZ(clearZ); } // 0x00477FC2 bool RoadElement::update(const World::Pos2& loc) { if (owner() == CompanyId::neutral || CompanyManager::isPlayerCompany(owner())) { return true; } if (!(getGameState().roadObjectIdIsNotTram & (1 << roadObjectId()))) { return true; } if (sequenceIndex()) { return true; } if (hasUnk7_10() || hasLevelCrossing() || hasUnk7_40() || hasUnk7_80()) { return true; } if (isGhost() || isAiAllocated()) { return true; } if (hasStationElement()) { return true; } // Verify there are no other conflicting tile elements on the current tile either. // This probably duplicates the above series of checks as well? auto tile = TileManager::get(loc); for (auto& el : tile) { auto* roadEl = el.as<RoadElement>(); if (roadEl == nullptr) { continue; } if (roadEl->baseZ() != baseZ()) { continue; } if (roadEl->owner() == CompanyId::neutral || CompanyManager::isPlayerCompany(roadEl->owner())) { continue; } if (!(getGameState().roadObjectIdIsNotTram & (1 << roadEl->roadObjectId()))) { continue; } if (roadEl->sequenceIndex()) { return true; } if (hasUnk7_10() || hasLevelCrossing() || hasUnk7_40() || hasUnk7_80()) { return true; } if (roadEl->isGhost() || roadEl->isAiAllocated()) { return true; } if (roadEl->hasStationElement()) { return true; } } CompanyId backup = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(owner()); GameCommands::RoadRemovalArgs args; args.pos = World::Pos3(loc.x, loc.y, baseHeight()); args.rotation = rotation(); args.roadId = roadId(); args.sequenceIndex = sequenceIndex(); args.objectId = roadObjectId(); GameCommands::doCommand(args, GameCommands::Flags::apply); GameCommands::setUpdatingCompanyId(backup); return false; } // 0x00479413 bool updateLevelCrossingAnimation(const Animation& anim) { auto tile = TileManager::get(anim.pos); bool shouldInvalidate = false; bool hasAnimation = false; // It's possible to have multiple level crossing elements on the same tile/baseZ // this happens if you have tram tracks on road on track. for (auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseZ() != anim.baseZ) { continue; } if (!elRoad->hasLevelCrossing()) { continue; } const auto* levelCrossingObj = ObjectManager::get<LevelCrossingObject>(elRoad->levelCrossingObjectId()); if (ScenarioManager::getScenarioTicks() & levelCrossingObj->var_0A) { hasAnimation = true; } else { shouldInvalidate = true; auto newFrame = elRoad->unk6l(); if (elRoad->hasUnk7_10()) { if (newFrame != 15) { newFrame++; if (newFrame > levelCrossingObj->closedFrames) { newFrame = 15; } } hasAnimation = true; } else { if (newFrame != 0) { newFrame--; if (newFrame == 14) { newFrame = levelCrossingObj->closedFrames; } hasAnimation = true; } // Doesn't set hasAnimation = true on else branch! } elRoad->setUnk6l(newFrame); } } if (shouldInvalidate) { Ui::ViewportManager::invalidate(anim.pos, anim.baseZ * kSmallZStep, anim.baseZ * kSmallZStep + 32, ZoomLevel::half); } return !hasAnimation; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/RoadElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco::World { struct Animation; #pragma pack(push, 1) struct RoadElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::road; private: uint8_t _4; uint8_t _5; uint8_t _6; uint8_t _7; public: RoadElement() = default; RoadElement(World::SmallZ baseZ, World::SmallZ clearZ); uint8_t rotation() const { return _type & 0x03; } void setRotation(uint8_t rotation) { _type &= ~0x3; _type |= rotation & 0x03; } uint8_t roadId() const { return _4 & 0xF; } // _4l void setRoadId(uint8_t roadId) { _4 &= ~0xF; _4 |= roadId & 0xF; } void setHasGhostMods(bool hasGhostMods) { _4 &= ~0x40; _4 |= hasGhostMods ? 0x40 : 0; } bool hasGhostMods() const { return (_4 & 0x40) != 0; } bool hasBridge() const { return (_4 & 0x80) != 0; } void setHasBridge(bool hasBridge) { _4 &= ~0x80; _4 |= hasBridge ? 0x80 : 0; } uint8_t unk4u() const { return (_4 & 0x30) >> 4; } void setUnk4u(uint8_t newUnk4u) { _4 &= ~(0x30); _4 |= (newUnk4u & 0x3) << 4; } uint8_t roadObjectId() const { return _5 >> 4; } // _5u void setRoadObjectId(uint8_t objectId) { _5 &= ~0xF0; _5 |= (objectId & 0xF) << 4; } uint8_t sequenceIndex() const { return _5 & 0x3; } // _5l void setSequenceIndex(uint8_t index) { _5 &= ~0x3; _5 |= index & 0x3; } uint8_t levelCrossingObjectId() const { return (_5 >> 2) & 0x3; } // _5l 0b0000_1100 NOTE: Shared with streetlight style void setLevelCrossingObjectId(uint8_t levelCrossingObjectId) // Shared with streetlight style { _5 &= ~0b1100; _5 |= (levelCrossingObjectId & 0x3) << 2; } uint8_t streetLightStyle() const { return (_5 >> 2) & 0x3; } // _5l 0b0000_1100 NOTE: Shared with level crossing object id 0 = no street light void setStreetLightStyle(uint8_t style) // Shared with streetlight style { _5 &= ~0b1100; _5 |= (style & 0x3) << 2; } uint8_t unk6l() const { return _6 & 0xF; } void setUnk6l(uint8_t value) { _6 &= ~0xF; _6 |= value & 0xF; } // _6u uint8_t bridge() const { return _6 >> 5; } // _6u void setBridgeObjectId(const uint8_t bridge) { _6 &= ~0xE0; _6 |= bridge << 5; } bool hasStationElement() const { return (_type & 0x80) != 0; } void setHasStationElement(bool state) { _type &= ~0x80; _type |= state ? 0x80 : 0; } bool hasSignalElement() const { return (_type & 0x40) != 0; } // Always false bool hasUnk7_10() const { return _7 & (1 << 4); } // _7u (bit 4) level crossing related void setUnk7_10(bool newState) // _7u (bit 4) level crossing related { _7 &= ~(1 << 4); _7 |= newState ? (1 << 4) : 0; } bool hasLevelCrossing() const { return _7 & (1 << 5); } // _7 0b0010_0000 NOTE: if false may have street light void setHasLevelCrossing(bool state) { _7 &= ~(1 << 5); _7 |= state ? (1U << 5) : 0; } // NOTE: This is the same field as mods! NON-TRAM SPECIFIC bool hasUnk7_40() const { return _7 & (1U << 6); } // NOTE: This is the same field as mods! NON-TRAM SPECIFIC void setUnk7_40(bool newState) { _7 &= ~(1 << 6); _7 |= newState ? (1 << 6) : 0; } // NOTE: This is the same field as mods! NON-TRAM SPECIFIC bool hasUnk7_80() const { return _7 & (1U << 7); } // NOTE: This is the same field as mods! NON-TRAM SPECIFIC void setUnk7_80(bool newState) { _7 &= ~(1U << 7); _7 |= newState ? (1U << 7) : 0; } bool hasMod(uint8_t mod) const { return _7 & (1 << (mod + 6)); } // _7u (bits 6 and 7) uint8_t mods() const { return _7 >> 6; } // _7u void setMods(uint8_t mods) { _7 &= ~0xC0; _7 |= (mods & 0x3) << 6; } void setMod(uint8_t mod, bool value) { _7 &= ~(1U << (mod + 6)); _7 |= value ? (1U << (mod + 6)) : 0; } CompanyId owner() const { return CompanyId(_7 & 0xF); } // _7l void setOwner(CompanyId newOwner) { _7 = (_7 & 0xF0) | (enumValue(newOwner) & 0xF); } bool update(const World::Pos2& loc); }; #pragma pack(pop) static_assert(sizeof(RoadElement) == kTileElementSize); bool updateLevelCrossingAnimation(const Animation& anim); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/SignalElement.cpp ```cpp #include "SignalElement.h" #include "Animation.h" #include "Objects/ObjectManager.h" #include "Objects/TrainSignalObject.h" #include "ScenarioManager.h" #include "TileManager.h" #include "ViewportManager.h" namespace OpenLoco::World { struct AnimResult { bool hasAnimation = false; bool shouldInvalidate = false; constexpr AnimResult& operator|=(const AnimResult& rhs) { hasAnimation |= rhs.hasAnimation; shouldInvalidate |= rhs.shouldInvalidate; return *this; } }; static AnimResult updateSignalAnimationSide(SignalElement::Side& side) { AnimResult res{}; if (side.hasSignal()) { const auto* signalObj = ObjectManager::get<TrainSignalObject>(side.signalObjectId()); const auto targetFrame = std::min(side.getUnk4() * 3, signalObj->numFrames - 1); if (side.frame() != targetFrame) { res.hasAnimation = true; if (!(ScenarioManager::getScenarioTicks() & signalObj->animationSpeed)) { uint8_t newFrame = side.frame() + 1; if (side.frame() >= targetFrame) { newFrame = side.frame() - 1; if (signalObj->hasFlags(TrainSignalObjectFlags::unk2)) { newFrame = std::min<uint8_t>(newFrame, 1U); } } side.setFrame(newFrame); res.shouldInvalidate = true; } } } return res; } // 0x0048950F bool updateSignalAnimation(const Animation& anim) { AnimResult result{}; auto tile = TileManager::get(anim.pos); // It's possible to have multiple signal elements on the same tile/baseZ ??? // Unsure why for (auto& el : tile) { auto* elSignal = el.as<SignalElement>(); if (elSignal == nullptr) { continue; } if (elSignal->baseZ() != anim.baseZ) { continue; } result |= updateSignalAnimationSide(elSignal->getLeft()); result |= updateSignalAnimationSide(elSignal->getRight()); } if (result.shouldInvalidate) { Ui::ViewportManager::invalidate(anim.pos, anim.baseZ * kSmallZStep, anim.baseZ * kSmallZStep + 32, ZoomLevel::half); } return !result.hasAnimation; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/SignalElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco::World { struct Animation; #pragma pack(push, 1) struct SignalElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::signal; struct Side { private: uint8_t _4; uint8_t _5; public: bool hasSignal() const { return _4 & 0x80; } void setHasSignal(bool state) { _4 &= ~0x80; _4 |= state ? 0x80 : 0; } bool isOccupied() const { return _4 & (1 << 6); } void setIsOccupied(bool newState) { _4 &= ~(1 << 6); _4 |= newState ? (1 << 6) : 0; } // _4: 0b0011_0000 ?maybe targetState/state? void setUnk4(uint8_t newUnk4) { _4 &= ~0x30; _4 |= (newUnk4 & 0x3) << 4; } // _4: 0b0011_0000 ?maybe targetState/state? uint8_t getUnk4() const { return (_4 >> 4) & 0x3; } uint8_t signalObjectId() const { return _4 & 0xF; } // _4l void setSignalObjectId(uint8_t signalObjectId) { _4 &= ~0xF; _4 |= signalObjectId & 0xF; } uint8_t frame() const { return _5 & 0xF; } // _5l void setFrame(uint8_t frame) { _5 &= ~0xF; _5 |= frame & 0xF; } uint8_t allLights() const { return _5 >> 4; } // _5u void setAllLights(uint8_t newLights) { _5 &= ~(0xF0); _5 |= newLights << 4; } bool hasRedLight() const { return _5 & 0x40; } // TBC colours bool hasRedLight2() const { return _5 & 0x10; } // TBC colours bool hasGreenLight() const { return _5 & 0x80; } // TBC colours bool hasGreenLight2() const { return _5 & 0x20; } // TBC colours }; private: Side sides[2]; public: uint8_t rotation() const { return _type & 0x3; } void setRotation(uint8_t rotation) { _type &= ~0x3; _type |= rotation & 0x3; } bool isLeftGhost() const { return _type & 0x80; } void setLeftGhost(bool state) { _type &= ~0x80; _type |= state ? 0x80 : 0; } bool isRightGhost() const { return _type & 0x40; } void setRightGhost(bool state) { _type &= ~0x40; _type |= state ? 0x40 : 0; } Side& getLeft() { return sides[0]; } Side& getRight() { return sides[1]; } const Side& getLeft() const { return sides[0]; } const Side& getRight() const { return sides[1]; } }; #pragma pack(pop) static_assert(sizeof(SignalElement) == kTileElementSize); bool updateSignalAnimation(const Animation& anim); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/StationElement.cpp ```cpp #include "StationElement.h" #include "Animation.h" #include "Objects/AirportObject.h" #include "Objects/DockObject.h" #include "Objects/ObjectManager.h" #include "ScenarioManager.h" #include "TileManager.h" #include "ViewportManager.h" #include "World/Station.h" namespace OpenLoco::World { template<typename Object> bool updateStationAnimation(const Animation& anim, StationType stationType) { auto tile = TileManager::get(anim.pos); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != anim.baseZ) { continue; } if (elStation->stationType() != stationType) { continue; } const auto* obj = ObjectManager::get<Object>(elStation->objectId()); auto buildingParts = obj->getBuildingParts(elStation->buildingType()); const auto animations = obj->getBuildingPartAnimations(); bool hasAnimation = false; uint8_t animSpeed = std::numeric_limits<uint8_t>::max(); for (auto& part : buildingParts) { auto& partAnim = animations[part]; if (partAnim.numFrames > 1) { hasAnimation = true; animSpeed = std::min<uint8_t>(animSpeed, partAnim.animationSpeed & ~(1 << 7)); } } if (!hasAnimation) { return true; } const auto speedMask = ((1 << animSpeed) - 1); if (!(ScenarioManager::getScenarioTicks() & speedMask)) { Ui::ViewportManager::invalidate(anim.pos, el.baseHeight(), el.clearHeight(), ZoomLevel::quarter); } return false; } return true; } // 0x004944B6 bool updateDockStationAnimation(const Animation& anim) { return updateStationAnimation<DockObject>(anim, StationType::docks); } // 0x004939ED bool updateAirportStationAnimation(const Animation& anim) { return updateStationAnimation<AirportObject>(anim, StationType::airport); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/StationElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco { enum class StationType : uint8_t; } namespace OpenLoco::World { struct Animation; #pragma pack(push, 1) struct StationElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::station; private: uint8_t _4; uint8_t _5; uint16_t _stationId; public: CompanyId owner() const { return CompanyId(_4 & 0xF); } // _4l void setOwner(CompanyId owner) { _4 &= ~0xF; _4 |= enumValue(owner) & 0xF; } void setUnk4SLR4(uint8_t val) { _4 &= ~0xF0; _4 |= (val & 0xF) << 4; } uint8_t objectId() const { return _5 & 0x1F; } void setObjectId(uint8_t objectId) { _5 &= ~0x1F; _5 |= objectId & 0x1F; } StationType stationType() const; void setStationType(StationType type); uint8_t rotation() const { return _type & 0x3; } void setRotation(uint8_t rotation) { _type &= ~0x3; _type |= rotation & 0x3; } uint8_t sequenceIndex() const { return (_type >> 6) & 3; } void setSequenceIndex(uint8_t index) { _type &= ~0xC0; _type |= (index & 3) << 6; } StationId stationId() const { return StationId(_stationId & 0x3FF); } void setStationId(StationId id) { _stationId &= ~0x3FF; _stationId |= enumValue(id) & 0x3FF; } // ((_6 & 0xFC00) >> 10) Note: Only non-zero for airports uint8_t buildingType() const { return (_stationId & 0xFC00) >> 10; } // ((_6 & 0xFC00) >> 10) Note: Only non-zero for airports void setBuildingType(uint8_t type) { _stationId &= ~0xFC00; _stationId |= (type & 0x3F) << 10; } }; #pragma pack(pop) static_assert(sizeof(StationElement) == kTileElementSize); bool updateDockStationAnimation(const Animation& anim); bool updateAirportStationAnimation(const Animation& anim); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/SurfaceData.cpp ```cpp #include "SurfaceData.h" #include "SurfaceElement.h" #include <array> namespace OpenLoco::World { // For lowering surface height // NB: only used by raise/lower land and mountain tools // 0x004FD3DC constexpr std::array<std::array<uint8_t, 32>, 9> lowerSurfaceCornerMapping = { { { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::north, 0, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::east, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::east, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::requiresHeightAdjustment, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SurfaceSlope::CornerDown::west, 0, 0, 0, SurfaceSlope::CornerDown::south, 0, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, 0 }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, 0, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, 0, 0, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, 0, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, 0, 0, SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, 0, 0, 0, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, 0, 0, 0, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south }, { SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerUp::north, 0, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north }, } }; // For raising surface height // NB: only used by raise/lower land and mountain tools // 0x004FD33C constexpr std::array<std::array<uint8_t, 32>, 9> raiseSurfaceCornerMapping = { { { SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::CornerUp::west, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::doubleHeight | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::doubleHeight | SurfaceSlope::CornerDown::north | SurfaceSlope::CornerUp::north }, { SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment }, { SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::south }, { SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::east, SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west | SurfaceSlope::CornerUp::north }, { SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::CornerDown::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::east | SurfaceSlope::CornerUp::north }, { SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::north, SurfaceSlope::CornerDown::north, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::west, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east, SurfaceSlope::requiresHeightAdjustment | SurfaceSlope::CornerUp::south | SurfaceSlope::CornerUp::east }, } }; uint8_t lowerSurfaceCornerFlags(uint8_t selectedCorner, uint8_t currentSlope) { return lowerSurfaceCornerMapping[selectedCorner][currentSlope]; } uint8_t raiseSurfaceCornerFlags(uint8_t selectedCorner, uint8_t currentSlope) { return raiseSurfaceCornerMapping[selectedCorner][currentSlope]; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/SurfaceData.h ```h #pragma once #include <cstdint> namespace OpenLoco::World { uint8_t lowerSurfaceCornerFlags(uint8_t selectedCorner, uint8_t currentSlope); uint8_t raiseSurfaceCornerFlags(uint8_t selectedCorner, uint8_t currentSlope); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/SurfaceElement.cpp ```cpp #include "SurfaceElement.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Terraform/CreateWall.h" #include "GameCommands/Terraform/RemoveWall.h" #include "IndustryElement.h" #include "Objects/IndustryObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Scenario.h" #include "TileManager.h" #include "ViewportManager.h" #include "WallElement.h" #include "WaveManager.h" #include "World/IndustryManager.h" #include "World/TownManager.h" namespace OpenLoco::World { void SurfaceElement::removeIndustry(const World::Pos2& pos) { if (isIndustrial()) { setIsIndustrialFlag(false); setGrowthStage(0); setVariation(0); auto z = baseHeight(); Ui::ViewportManager::invalidate(pos, z, z + 32, ZoomLevel::eighth); TownManager::updateTownInfo(pos, 0, 0, -30, 0); } } static void updateNonIndustrialSurface(SurfaceElement& elSurface, const World::Pos2 loc) { auto* landObj = ObjectManager::get<LandObject>(elSurface.terrain()); if (!landObj->hasFlags(LandObjectFlags::unk0)) { return; } elSurface.setUpdateTimer(elSurface.getUpdateTimer() + 1); if (elSurface.getUpdateTimer() != 0) { return; } if (elSurface.water()) { SmallZ waterZ = elSurface.water() * kMicroToSmallZStep; if (elSurface.slope()) { waterZ -= 4; } if (waterZ > elSurface.baseZ()) { if (elSurface.getGrowthStage()) { elSurface.setGrowthStage(0); Ui::ViewportManager::invalidate(loc, elSurface.baseHeight(), elSurface.baseHeight()); } return; } } if (elSurface.getGrowthStage() + 1 < landObj->numGrowthStages) { elSurface.setGrowthStage(elSurface.getGrowthStage() + 1); Ui::ViewportManager::invalidate(loc, elSurface.baseHeight(), elSurface.baseHeight()); } } // 0x004C49E9 static WallElement* getWallElement(const World::Pos2 loc, SmallZ baseZ, SmallZ clearZ, uint8_t direction) { auto tile = TileManager::get(loc); for (auto& el : tile) { auto* elWall = el.as<WallElement>(); if (elWall == nullptr) { continue; } if (elWall->isGhost()) { continue; } if (elWall->clearZ() < baseZ) { continue; } if (elWall->baseZ() > clearZ) { continue; } if (elWall->rotation() != direction) { continue; } return elWall; } return nullptr; } static bool updateIndustrialSurface(SurfaceElement& elSurface, const World::Pos2 loc) { auto* industry = IndustryManager::get(elSurface.industryId()); auto* industryObj = industry->getObject(); if (industryObj->hasFlags(IndustryObjectFlags::builtOnSnow) && elSurface.snowCoverage() < 4) { TileManager::removeSurfaceIndustry(loc); return false; } if (elSurface.getGrowthStage() != industryObj->farmTileGrowthStageNoProduction || elSurface.getGrowthStage() == 0) { elSurface.setUpdateTimer(elSurface.getUpdateTimer() + 1); if (elSurface.getUpdateTimer() == 0) { uint8_t newGrowthStage = elSurface.getGrowthStage() + 1; if (newGrowthStage >= industryObj->farmTileNumGrowthStages) { newGrowthStage = 0; } elSurface.setGrowthStage(newGrowthStage); Ui::ViewportManager::invalidate(loc, elSurface.baseHeight(), elSurface.baseHeight()); } } SurfaceElement* surf = &elSurface; bool tileAddedRemoved = false; for (auto i = 0; i < 4; ++i) { // This loop looks for walls on either sides of the surface tile being updated // // | N | // | 2 | // --- | ----- | --- // | 1 | // N 2 | 1 X 1 | 2 N // | 1 | // --- | ----- | --- // | 2 | // | N | // // N == Neighbour tile (this loop) // X == Surface being updated // 1 == Potential wall on surface being updated // 2 == Potential wall on Neighbour tile (this loop) auto* elWall = getWallElement(loc, surf->baseZ(), surf->baseZ() + 16, i); if (elWall) { // Wall has been found on this surface tile. // Validate if it should be here and if not // remove it if (surf->getGrowthStage() != industryObj->farmTileGrowthStageNoProduction) { continue; } const auto nextLoc = loc + kRotationOffset[i]; if (!validCoords(nextLoc)) { continue; } auto* nextSurface = TileManager::get(nextLoc).surface(); if (!nextSurface->isIndustrial() || nextSurface->industryId() != surf->industryId()) { continue; } if (nextSurface->getGrowthStage() != industryObj->farmTileGrowthStageNoProduction) { continue; } GameCommands::WallRemovalArgs args{}; args.pos = Pos3(loc, elWall->baseHeight()); args.rotation = i; GameCommands::doCommand(args, GameCommands::Flags::apply); // tileAddedRemoved = true; // To be safe we should really re-get the tile and stop processing the tile (tileAddedRemoved = true) // but that subtly diverges from vanilla. // TODO: Change this when we want to diverge! // surf might be invalid! Re-get it just to be safe. surf = TileManager::get(loc).surface(); continue; } else { const auto nextLoc = loc + kRotationOffset[i]; if (!validCoords(nextLoc)) { continue; } // ^ (1U << 1) as we need to look at reverse direction for the neighbours wall auto* elWall2 = getWallElement(nextLoc, surf->baseZ(), surf->baseZ() + 16, i ^ (1U << 1)); if (elWall2) { continue; } // Wall has *NOT* been found on neighbour surface tile. // Validate if it should exist and if it should create // it. auto* nextSurface = TileManager::get(nextLoc).surface(); if (nextSurface->isIndustrial()) { if (nextSurface->industryId() == surf->industryId()) { continue; } } else { bool hasIndustryBuilding = [&nextLoc]() { auto tile2 = TileManager::get(nextLoc); bool passedSurface = false; for (auto& el : tile2) { if (el.as<SurfaceElement>() != nullptr) { passedSurface = true; continue; } if (passedSurface) { auto* elIndustry = el.as<IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->isGhost()) { continue; } return true; } } return false; }(); if (hasIndustryBuilding) { continue; } } uint8_t wallType = industryObj->wallTypes[0]; if (wallType == 0xFFU) { continue; } if (surf->getGrowthStage() != industryObj->farmTileGrowthStageNoProduction || industryObj->buildingWall != 0xFFU) { if (surf->getGrowthStage() == industryObj->farmTileGrowthStageNoProduction) { wallType = industryObj->buildingWall; } GameCommands::WallPlacementArgs args{}; args.pos = Pos3(loc, 0); args.primaryColour = Colour::black; args.secondaryColour = Colour::black; args.tertiaryColour = Colour::black; args.type = wallType; args.rotation = i; GameCommands::doCommand(args, GameCommands::Flags::apply); tileAddedRemoved = true; // surf is invalid! Need to re-get it. surf = TileManager::get(loc).surface(); } } } return tileAddedRemoved; } // 0x004691FA bool updateSurface(SurfaceElement& elSurface, const World::Pos2 loc) { bool elSurfaceValid = true; if (elSurface.isIndustrial()) { elSurfaceValid = !updateIndustrialSurface(elSurface, loc); } else { updateNonIndustrialSurface(elSurface, loc); } auto* surf = elSurfaceValid ? &elSurface : TileManager::get(loc).surface(); const MicroZ snow = Scenario::getCurrentSnowLine() / kMicroToSmallZStep; uint8_t targetCoverage = std::clamp(((surf->baseZ() / kMicroToSmallZStep) + 1) - snow, 0, 5); if (surf->snowCoverage() != targetCoverage) { if (surf->snowCoverage() > targetCoverage) { surf->setSnowCoverage(surf->snowCoverage() - 1); } else { surf->setSnowCoverage(surf->snowCoverage() + 1); } Ui::ViewportManager::invalidate(loc, surf->baseHeight(), surf->baseHeight()); } if (!surf->water()) { return elSurfaceValid; } if (surf->hasType6Flag()) { surf->setVariation(surf->variation() + 1); if (surf->variation() >= 64) { surf->setVariation(0); surf->setType6Flag(false); } } if (surf->isFlag6()) { return elSurfaceValid; } WaveManager::createWave(*surf, loc); return elSurfaceValid; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/SurfaceElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco::World { namespace SurfaceSlope { constexpr uint8_t flat = 0x00; namespace CornerUp { constexpr uint8_t all = 0x0F; constexpr uint8_t north = (1 << 0); constexpr uint8_t east = (1 << 1); constexpr uint8_t south = (1 << 2); constexpr uint8_t west = (1 << 3); } constexpr uint8_t doubleHeight = (1 << 4); constexpr uint8_t requiresHeightAdjustment = (1 << 5); namespace CornerDown { constexpr uint8_t west = CornerUp::all & ~CornerUp::west; constexpr uint8_t south = CornerUp::all & ~CornerUp::south; constexpr uint8_t east = CornerUp::all & ~CornerUp::east; constexpr uint8_t north = CornerUp::all & ~CornerUp::north; } namespace SideUp { constexpr uint8_t northeast = CornerUp::north | CornerUp::east; constexpr uint8_t southeast = CornerUp::south | CornerUp::east; constexpr uint8_t northwest = CornerUp::north | CornerUp::west; constexpr uint8_t southwest = CornerUp::south | CornerUp::west; } namespace Valley { constexpr uint8_t westeast = CornerUp::east | CornerUp::west; constexpr uint8_t northsouth = CornerUp::north | CornerUp::south; } } #pragma pack(push, 1) struct SurfaceElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::surface; private: uint8_t _slope; // 0x4 uint8_t _water; // 0x5 uint8_t _terrain; // 0x6 uint8_t _7; // 0x7 either variation or industry depending on high type flag public: SurfaceElement() = default; SurfaceElement(World::SmallZ baseZ, World::SmallZ clearZ, uint8_t quarterTile, bool highTypeFlag) { setType(kElementType); setBaseZ(baseZ); setClearZ(clearZ); _flags = quarterTile; setIsIndustrialFlag(highTypeFlag); } bool isSlopeDoubleHeight() const { return _slope & SurfaceSlope::doubleHeight; } uint8_t slopeCorners() const { return _slope & 0x0F; } uint8_t slope() const { return _slope & 0x1F; } void setSlope(uint8_t slope) { _slope &= ~0x1F; _slope = slope & 0x1F; } uint8_t snowCoverage() const { return (_slope & 0xE0) >> 5; } void setSnowCoverage(uint8_t coverage) { _slope &= ~0xE0; _slope |= coverage << 5; } MicroZ water() const { return _water & 0x1F; } int16_t waterHeight() const { return (_water & 0x1F) * kMicroZStep; } void setWater(MicroZ level) { _water = (_water & 0xE0) | (level & 0x1F); }; uint8_t getUpdateTimer() const { return (_water & 0xE0) >> 5; } void setUpdateTimer(uint8_t var5) { _water = (_water & 0x1F) | ((var5 << 5) & 0xE0); } uint8_t terrain() const { return _terrain & 0x1F; } void setTerrain(uint8_t terrain) { _terrain &= ~0x1F; _terrain |= terrain & 0x1F; } uint8_t getGrowthStage() const { return _terrain >> 5; } void setGrowthStage(uint8_t var6) { _terrain &= 0x1F; _terrain |= var6 << 5; } IndustryId industryId() const { return IndustryId(_7); } uint8_t variation() const { return _7; } void setIndustry(const IndustryId industry) { _7 = enumValue(industry); } void setVariation(const uint8_t variation) { _7 = variation; } void setType6Flag(bool state) { _type &= ~0x40; _type |= state ? 0x40 : 0; } bool hasType6Flag() const { return _type & 0x40; } // Note: Also used for other means for boats bool isIndustrial() const { return _type & 0x80; } // Note: Also used for other means for boats void setIsIndustrialFlag(bool state) { _type &= ~0x80; _type |= state ? 0x80 : 0; } void removeIndustry(const World::Pos2& pos); }; #pragma pack(pop) static_assert(sizeof(SurfaceElement) == kTileElementSize); bool updateSurface(SurfaceElement& elSurface, const World::Pos2 loc); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Tile.cpp ```cpp #include "Tile.h" #include "IndustryElement.h" #include "Objects/ObjectManager.h" #include "RoadElement.h" #include "StationElement.h" #include "SurfaceElement.h" #include "TrackElement.h" #include "Ui/WindowManager.h" #include "Viewport.hpp" #include "World/IndustryManager.h" #include "World/Station.h" #include <cassert> namespace OpenLoco::World { const uint8_t* TileElementBase::data() const { return (uint8_t*)this; } ElementType TileElementBase::type() const { return (ElementType)((_type & 0x3C) >> 2); } bool TileElementBase::isLast() const { return (_flags & ElementFlags::last) != 0; } Tile::Tile(const TilePos2& tPos, TileElement* data) : _data(data) , pos(tPos) { } bool Tile::isNull() const { return _data == nullptr; } Tile::Iterator Tile::begin() { return Iterator{ _data }; } Tile::Iterator Tile::begin() const { return Iterator{ _data }; } Tile::Iterator Tile::end() { return Iterator{}; } Tile::Iterator Tile::end() const { return Iterator{}; } size_t Tile::size() { const auto dist = std::distance(begin(), end()); return static_cast<size_t>(dist); } TileElement* Tile::operator[](size_t i) { #if DEBUG assert(i < size()); #endif return &_data[i]; } size_t Tile::indexOf(const TileElementBase* element) const { size_t i = 0; for (const auto& tile : *this) { if (&tile == element) { return i; } i++; } return npos; } SurfaceElement* Tile::surface() const { for (auto& tile : *this) { auto* result = tile.as<SurfaceElement>(); if (result != nullptr) { return result; } } return nullptr; } StationElement* Tile::trainStation(uint8_t trackId, uint8_t direction, uint8_t baseZ) const { StationElement* result = nullptr; bool trackFound = false; for (auto& tile : *this) { if (trackFound) { result = tile.as<StationElement>(); if (result != nullptr) { break; } } auto* elTrack = tile.as<TrackElement>(); if (elTrack == nullptr) { continue; } trackFound = false; if (elTrack->baseZ() != baseZ) { continue; } if (elTrack->rotation() != direction) { continue; } if (elTrack->trackId() != trackId) { continue; } if (!elTrack->hasStationElement()) { continue; } trackFound = true; } return result; } StationElement* Tile::roadStation(uint8_t roadId, uint8_t direction, uint8_t baseZ) const { StationElement* result = nullptr; bool trackFound = false; for (auto& tile : *this) { if (trackFound) { result = tile.as<StationElement>(); if (result != nullptr) { return result; } } auto* elRoad = tile.as<RoadElement>(); if (elRoad == nullptr) { // We can have any amount of road elements between the station // this is different to a track where the station is always the next // element. trackFound = false; continue; } if (elRoad->baseZ() != baseZ) { // We can have any amount of road elements between the station // but if the base height is different then the station doesn't // exist here! (Should never happen) trackFound = false; continue; } if (elRoad->rotation() != direction) { continue; } if (elRoad->roadId() != roadId) { continue; } if (!elRoad->hasStationElement()) { continue; } trackFound = true; } return result; } StationType StationElement::stationType() const { return StationType(_5 >> 5); } void StationElement::setStationType(StationType type) { _5 &= ~0xE0; _5 |= (enumValue(type) & 0x7) << 5; } /** * * @param x @<ax> * @param y * @param z * @param rotation * @return */ Ui::viewport_pos gameToScreen(const Pos3& loc, int rotation) { auto rotLoc = Math::Vector::rotate(loc, rotation); return Ui::viewport_pos(rotLoc.y - rotLoc.x, ((rotLoc.y + rotLoc.x) >> 1) - loc.z); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Tile.h ```h #pragma once #include "TileElement.h" #include "Types.hpp" #include <OpenLoco/Engine/World.hpp> #include <array> #include <cassert> #include <cstddef> #include <cstdint> #include <limits> #include <tuple> namespace OpenLoco::Ui { struct viewport_pos; } namespace OpenLoco::World { struct TileHeight { coord_t landHeight; coord_t waterHeight; explicit operator coord_t() const { return waterHeight == 0 ? landHeight : waterHeight; } }; // 0x004F9296, 0x004F9298 constexpr std::array<Pos2, 4> kOffsets = { Pos2{ 0, 0 }, Pos2{ 0, 32 }, Pos2{ 32, 32 }, Pos2{ 32, 0 }, }; // 0x00503C6C, 0x00503C6E constexpr std::array<Pos2, 16> kRotationOffset = { Pos2{ -32, 0 }, Pos2{ 0, 32 }, Pos2{ 32, 0 }, Pos2{ 0, -32 }, Pos2{ -32, 0 }, Pos2{ 0, 32 }, Pos2{ 32, 0 }, Pos2{ 0, -32 }, Pos2{ -32, 0 }, Pos2{ 0, 32 }, Pos2{ 32, 0 }, Pos2{ 0, -32 }, Pos2{ -32, 32 }, Pos2{ 32, 32 }, Pos2{ 32, -32 }, Pos2{ -32, -32 }, }; // 0x00503CAC constexpr std::array<uint8_t, 16> kReverseRotation = { 2, 3, 0, 1, 10, 11, 8, 9, 6, 7, 4, 5, 14, 15, 12, 13, }; struct LessThanPos3 { bool operator()(World::Pos3 const& lhs, World::Pos3 const& rhs) const { return std::tie(lhs.x, lhs.y, lhs.z) < std::tie(rhs.x, rhs.y, rhs.z); } }; Ui::viewport_pos gameToScreen(const Pos3& loc, int rotation); struct SurfaceElement; struct StationElement; struct Tile { public: struct Iterator { using iterator_concept = std::forward_iterator_tag; using value_type = TileElement; using difference_type = std::ptrdiff_t; using pointer = TileElement*; using reference = TileElement&; private: TileElement* _current{}; public: constexpr Iterator() = default; constexpr Iterator(TileElement* current) : _current(current) { } constexpr TileElement& operator*() const { return *_current; } constexpr TileElement* operator->() const { return _current; } constexpr Iterator& operator++() { if (_current == nullptr) { return *this; } if (_current->isLast()) { _current = nullptr; } else { _current = _current->next(); } return *this; } constexpr Iterator operator++(int) { Iterator result = *this; ++(*this); return result; } constexpr auto operator<=>(const Iterator& other) const = default; }; private: TileElement* const _data; public: static constexpr size_t npos = std::numeric_limits<size_t>().max(); const TilePos2 pos; Tile(const TilePos2& tPos, TileElement* data); bool isNull() const; Iterator begin(); Iterator begin() const; Iterator end(); Iterator end() const; size_t size(); TileElement* operator[](size_t i); size_t indexOf(const TileElementBase* element) const; SurfaceElement* surface() const; StationElement* trainStation(uint8_t trackId, uint8_t direction, uint8_t baseZ) const; StationElement* roadStation(uint8_t roadId, uint8_t direction, uint8_t baseZ) const; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileClearance.cpp ```cpp #include "TileClearance.h" #include "BuildingElement.h" #include "Economy/Economy.h" #include "GameCommands/Buildings/RemoveBuilding.h" #include "GameCommands/GameCommands.h" #include "IndustryElement.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/BuildingObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/TreeObject.h" #include "RoadElement.h" #include "ScenarioOptions.h" #include "SignalElement.h" #include "StationElement.h" #include "SurfaceElement.h" #include "TileManager.h" #include "TrackElement.h" #include "TreeElement.h" #include "WallElement.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include "World/Station.h" using OpenLoco::World::TileManager::ElementPositionFlags; namespace OpenLoco::World::TileClearance { static loco_global<uint32_t, 0x00F00138> _F00138; static loco_global<TileElement*, 0x00F0015C> _F0015C; static loco_global<ElementPositionFlags, 0x00F00166> _constructAtElementPositionFlags; // 0x00462C8E void setCollisionErrorMessage(const World::TileElement& el) { switch (el.type()) { case ElementType::surface: { GameCommands::setErrorText(StringIds::raise_or_lower_land_first); break; } case ElementType::track: { auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { return; } auto* trackObj = ObjectManager::get<TrackObject>(elTrack->trackObjectId()); FormatArguments::common(trackObj->name); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } case ElementType::station: { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { return; } constexpr std::array<StringId, 4> kStationTypeNames = { StringIds::capt_station, StringIds::capt_station, StringIds::capt_airport, StringIds::capt_ship_port, }; FormatArguments::common(kStationTypeNames[enumValue(elStation->stationType())]); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } case ElementType::signal: { FormatArguments::common(StringIds::capt_signal); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } case ElementType::building: { auto* elBuidling = el.as<BuildingElement>(); if (elBuidling == nullptr) { return; } auto* buildingObj = elBuidling->getObject(); FormatArguments::common(buildingObj->name); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } case ElementType::tree: { auto* elTree = el.as<TreeElement>(); if (elTree == nullptr) { return; } auto* treeObj = ObjectManager::get<TreeObject>(elTree->treeObjectId()); FormatArguments::common(treeObj->name); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } case ElementType::wall: { GameCommands::setErrorText(StringIds::object_in_the_way); break; } case ElementType::road: { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { return; } auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); FormatArguments::common(roadObj->name); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } case ElementType::industry: { auto* elIndustry = el.as<IndustryElement>(); if (elIndustry == nullptr) { return; } auto* industry = elIndustry->industry(); FormatArguments::common(industry->name, industry->town); GameCommands::setErrorText(StringIds::string_id_in_the_way); break; } } } constexpr bool isCollisionResult(ClearFuncResult res) { return res == ClearFuncResult::collision || res == ClearFuncResult::collisionErrorSet; } // 0x00462BB3 // Vanilla function would return true with input esi not modified // Vanilla function would return false with esi set to 0xFFFFFFFF if error text set or problem element if not set static ClearFuncResult aiCompanyAboutToBuildCheck(const World::TileElement& el) { auto* elSurface = el.as<SurfaceElement>(); // 0x00462C02 auto returnFunc = [](const CompanyId owner) -> ClearFuncResult { const auto updatingId = GameCommands::getUpdatingCompanyId(); if (updatingId == CompanyId::neutral || !CompanyManager::isPlayerCompany(updatingId)) { GameCommands::setErrorText(StringIds::another_company_is_about_to_build_here); return ClearFuncResult::collisionErrorSet; } if (owner == updatingId || CompanyManager::isPlayerCompany(owner)) { return ClearFuncResult::collision; } auto* company = CompanyManager::get(owner); if ((company->challengeFlags & CompanyFlags::unk2) != CompanyFlags::none) { GameCommands::setErrorText(StringIds::another_company_is_about_to_build_here); return ClearFuncResult::collisionErrorSet; } // Modification from vanilla company->challengeFlags |= CompanyFlags::unk1; return ClearFuncResult::noCollision; }; if (elSurface == nullptr) { CompanyId owner = TileManager::getTileOwner(el); if (owner == CompanyId::null) { return ClearFuncResult::noCollision; } return returnFunc(owner); } else { auto* elp = &el; while (!elp->isLast()) { elp = elp->next(); if (!elp->isAiAllocated()) { continue; } const auto owner = TileManager::getTileOwner(*elp); if (owner == CompanyId::null) { continue; } return returnFunc(owner); } GameCommands::setErrorText(StringIds::another_company_is_about_to_build_here); return ClearFuncResult::collisionErrorSet; } } // 0x00462B4F static ClearFuncResult callClearFunction(TileElement& el, const std::function<ClearFuncResult(TileElement& el)>& clearFunc) { if (!clearFunc) { return ClearFuncResult::collision; } _F0015C = nullptr; return clearFunc(el); }; enum class BuildingCollisionType : bool { standard, anyHeight, // If the building/industry/tree/dock/airport is at any height on the tile this is a collision }; // 0x0046297D static ClearFuncResult canConstructAtCheckSurfaceElement(uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt, const std::function<ClearFuncResult(TileElement& el)>& clearFunc, TileElement& el, const SurfaceElement& elSurface) { if (elSurface.isAiAllocated()) { if (auto res = aiCompanyAboutToBuildCheck(el); res != ClearFuncResult::noCollision) { return res; } } const auto waterZ = elSurface.water() * kMicroToSmallZStep; if (waterZ != 0) { if (clearZ > elSurface.clearZ() && baseZ < waterZ + 4) { _constructAtElementPositionFlags = _constructAtElementPositionFlags | ElementPositionFlags::partiallyUnderwater; if (baseZ < waterZ) { _constructAtElementPositionFlags = _constructAtElementPositionFlags | ElementPositionFlags::underwater; if (clearZ > waterZ) { if (clearFunc) { _F0015C = nullptr; if (auto res = clearFunc(el); isCollisionResult(res)) { if (res == ClearFuncResult::collision) { GameCommands::setErrorText(StringIds::cannot_build_partly_above_below_water); } return ClearFuncResult::collisionErrorSet; } } else { GameCommands::setErrorText(StringIds::cannot_build_partly_above_below_water); return ClearFuncResult::collisionErrorSet; } } } } } if (qt.getZQuarterOccupied() == 0xF) { return ClearFuncResult::noCollision; } if (clearZ <= elSurface.baseZ()) { _constructAtElementPositionFlags = _constructAtElementPositionFlags | ElementPositionFlags::underground; _constructAtElementPositionFlags = _constructAtElementPositionFlags & ~(ElementPositionFlags::aboveGround); return ClearFuncResult::noCollision; } else { auto northZ = elSurface.baseZ(); auto eastZ = northZ; auto southZ = northZ; auto westZ = northZ; const auto slope = elSurface.slope(); if (slope & SurfaceSlope::CornerUp::north) { northZ += kSmallZStep; if (slope == (SurfaceSlope::CornerDown::south | SurfaceSlope::doubleHeight)) { northZ += kSmallZStep; } } if (slope & SurfaceSlope::CornerUp::east) { eastZ += kSmallZStep; if (slope == (SurfaceSlope::CornerDown::west | SurfaceSlope::doubleHeight)) { eastZ += kSmallZStep; } } if (slope & SurfaceSlope::CornerUp::south) { southZ += kSmallZStep; if (slope == (SurfaceSlope::CornerDown::north | SurfaceSlope::doubleHeight)) { southZ += kSmallZStep; } } if (slope & SurfaceSlope::CornerUp::west) { westZ += kSmallZStep; if (slope == (SurfaceSlope::CornerDown::east | SurfaceSlope::doubleHeight)) { westZ += kSmallZStep; } } const auto doubleHeight = baseZ + 8; const auto baseQuarter = qt.getBaseQuarterOccupied(); const auto zQuarter = qt.getZQuarterOccupied(); if ((!(baseQuarter & 0b0001) || ((zQuarter & 0b0001 || baseZ >= northZ) && doubleHeight >= northZ)) && (!(baseQuarter & 0b0010) || ((zQuarter & 0b0010 || baseZ >= eastZ) && doubleHeight >= eastZ)) && (!(baseQuarter & 0b0100) || ((zQuarter & 0b0100 || baseZ >= southZ) && doubleHeight >= southZ)) && (!(baseQuarter & 0b1000) || ((zQuarter & 0b1000 || baseZ >= westZ) && doubleHeight >= westZ))) { return ClearFuncResult::noCollision; } return callClearFunction(el, clearFunc); } } // 0x00462AA4 static ClearFuncResult canConstructAtCheckNonSurfaceElement(const uint8_t baseZ, const uint8_t clearZ, const QuarterTile& qt, const BuildingCollisionType flags, const std::function<ClearFuncResult(TileElement& el)>& clearFunc, TileElement& el) { if (flags == BuildingCollisionType::anyHeight) { if (el.type() == ElementType::tree || el.type() == ElementType::building || el.type() == ElementType::industry) { return callClearFunction(el, clearFunc); } const auto* elStation = el.as<StationElement>(); if (elStation != nullptr) { if (elStation->stationType() == StationType::airport || elStation->stationType() == StationType::docks) { return callClearFunction(el, clearFunc); } } } if (baseZ >= el.clearZ()) { return ClearFuncResult::noCollision; } if (clearZ <= el.baseZ()) { return ClearFuncResult::noCollision; } if (el.isGhost()) { return ClearFuncResult::noCollision; } if ((el.occupiedQuarter() & qt.getBaseQuarterOccupied()) == 0) { return ClearFuncResult::noCollision; } if (!el.isAiAllocated()) { return callClearFunction(el, clearFunc); } if (clearFunc) { _F0015C = nullptr; if (auto res = clearFunc(el); !isCollisionResult(res)) { return res; } } return aiCompanyAboutToBuildCheck(el); } // 0x00462937 static bool canConstructAtWithClear(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt, BuildingCollisionType flags, std::function<ClearFuncResult(TileElement& el)> clearFunc) { _constructAtElementPositionFlags = ElementPositionFlags::aboveGround; if (!drawableCoords(pos)) { GameCommands::setErrorText(StringIds::off_edge_of_map); return false; } bool collisionRemoved = false; do { collisionRemoved = false; const auto tile = TileManager::get(pos); for (auto& el : tile) { const auto* elSurface = el.as<SurfaceElement>(); const auto res = elSurface == nullptr ? canConstructAtCheckNonSurfaceElement(baseZ, clearZ, qt, flags, clearFunc, el) : canConstructAtCheckSurfaceElement(baseZ, clearZ, qt, clearFunc, el, *elSurface); switch (res) { case ClearFuncResult::noCollision: break; case ClearFuncResult::allCollisionsRemoved: return true; case ClearFuncResult::collision: setCollisionErrorMessage(el); return false; case ClearFuncResult::collisionRemoved: collisionRemoved = true; break; case ClearFuncResult::collisionErrorSet: return false; } if (collisionRemoved) { break; } } } while (collisionRemoved); return true; } // 0x00462908 bool applyClearAtAllHeights(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt, std::function<ClearFuncResult(TileElement& el)> clearFunc) { return canConstructAtWithClear(pos, baseZ, clearZ, qt, BuildingCollisionType::anyHeight, clearFunc); } // 0x00462917 bool applyClearAtStandardHeight(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt, std::function<ClearFuncResult(TileElement& el)> clearFunc) { return canConstructAtWithClear(pos, baseZ, clearZ, qt, BuildingCollisionType::standard, clearFunc); } // 0x00462926 bool canConstructAt(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt) { return canConstructAtWithClear(pos, baseZ, clearZ, qt, BuildingCollisionType::standard, {}); } // 0x00469E07, 0x00468949, 0x004C4DAD, 0x0042D5E5, 0x0049434F static ClearFuncResult tileClearFunction(World::TileElement& el, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost, bool defaultCollision) { switch (el.type()) { case ElementType::surface: return ClearFuncResult::noCollision; case ElementType::tree: { auto* elTree = el.as<TreeElement>(); if (elTree == nullptr) { return ClearFuncResult::noCollision; } return clearTreeCollision(*elTree, pos, flags, cost); } case ElementType::building: { auto* elBuilding = el.as<BuildingElement>(); if (elBuilding == nullptr) { return ClearFuncResult::noCollision; } return clearBuildingCollision(*elBuilding, pos, removedBuildings, flags, cost); } default: return defaultCollision ? ClearFuncResult::collision : ClearFuncResult::noCollision; } }; ClearFuncResult clearWithDefaultCollision(World::TileElement& el, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost) { return tileClearFunction(el, pos, removedBuildings, flags, cost, true); } ClearFuncResult clearWithoutDefaultCollision(World::TileElement& el, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost) { return tileClearFunction(el, pos, removedBuildings, flags, cost, false); } ClearFuncResult clearBuildingCollision(World::BuildingElement& elBuilding, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost) { auto* buildingObj = elBuilding.getObject(); if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters)) { return ClearFuncResult::collision; } const auto buildingStart = World::Pos3{ pos - World::kOffsets[elBuilding.sequenceIndex()], elBuilding.baseHeight() }; if (removedBuildings.count(buildingStart) != 0) { return ClearFuncResult::noCollision; } removedBuildings.insert(buildingStart); World::TileManager::setRemoveElementPointerChecker(reinterpret_cast<TileElement&>(elBuilding)); uint8_t removeBuildingFlags = flags; if ((flags & GameCommands::Flags::apply) || removedBuildings.size() != 1) { removeBuildingFlags |= GameCommands::Flags::flag_7; } if (flags & (GameCommands::Flags::ghost | GameCommands::Flags::aiAllocated)) { removeBuildingFlags &= ~(GameCommands::Flags::ghost | GameCommands::Flags::aiAllocated | GameCommands::Flags::apply); } GameCommands::BuildingRemovalArgs args{}; args.pos = buildingStart; Interop::registers regs = static_cast<Interop::registers>(args); regs.bl = removeBuildingFlags; // We should probably call doCommand here but then it gets messy with the costs // look into changing this in the future. GameCommands::removeBuilding(regs); const auto buildingCost = static_cast<currency32_t>(regs.ebx); if (static_cast<uint32_t>(buildingCost) == GameCommands::FAILURE) { return ClearFuncResult::collisionErrorSet; } if (flags & GameCommands::Flags::apply) { Scenario::getOptions().madeAnyChanges = 1; } cost += buildingCost; if (!(flags & GameCommands::Flags::apply) || (flags & (GameCommands::Flags::ghost | GameCommands::Flags::aiAllocated))) { return ClearFuncResult::noCollision; } if (World::TileManager::wasRemoveOnLastElement()) { return ClearFuncResult::allCollisionsRemoved; } return ClearFuncResult::collisionRemoved; } ClearFuncResult clearTreeCollision(World::TreeElement& elTree, const World::Pos2 pos, const uint8_t flags, currency32_t& cost) { auto* treeObj = ObjectManager::get<TreeObject>(elTree.treeObjectId()); cost += Economy::getInflationAdjustedCost(treeObj->clearCostFactor, treeObj->costIndex, 12); if ((flags & (GameCommands::Flags::ghost | GameCommands::Flags::aiAllocated)) || !(flags & GameCommands::Flags::apply)) { return ClearFuncResult::noCollision; } World::TileManager::setRemoveElementPointerChecker(reinterpret_cast<TileElement&>(elTree)); World::TileManager::removeTree(elTree, GameCommands::Flags::apply, pos); Scenario::getOptions().madeAnyChanges = 1; if (World::TileManager::wasRemoveOnLastElement()) { return ClearFuncResult::allCollisionsRemoved; } return ClearFuncResult::collisionRemoved; } ElementPositionFlags getPositionFlags() { return *_constructAtElementPositionFlags; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileClearance.h ```h #pragma once #include "Economy/Currency.h" #include "QuarterTile.h" #include "Tile.h" #include <functional> #include <sfl/small_set.hpp> namespace OpenLoco::World { struct BuildingElement; struct TreeElement; } namespace OpenLoco::World::TileManager { enum class ElementPositionFlags : uint8_t; } namespace OpenLoco::World::TileClearance { enum class ClearFuncResult { allCollisionsRemoved, collision, collisionErrorSet, noCollision, collisionRemoved, }; void setCollisionErrorMessage(const World::TileElement& el); bool applyClearAtAllHeights(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt, std::function<ClearFuncResult(TileElement& el)> clearFunc); bool applyClearAtStandardHeight(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt, std::function<ClearFuncResult(TileElement& el)> clearFunc); bool canConstructAt(const World::Pos2& pos, uint8_t baseZ, uint8_t clearZ, const QuarterTile& qt); using RemovedBuildings = sfl::small_set<World::Pos3, 128, LessThanPos3>; // Removes Buildings and Trees but everything else is a collision ClearFuncResult clearWithDefaultCollision(World::TileElement& el, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost); // Removes Buildings and Trees but everything else is **NOT** a collision ClearFuncResult clearWithoutDefaultCollision(World::TileElement& el, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost); // Removes a building as per normal clear function setup ClearFuncResult clearBuildingCollision(World::BuildingElement& elBuilding, const World::Pos2 pos, RemovedBuildings& removedBuildings, const uint8_t flags, currency32_t& cost); // Removes a tree as per normal clear function setup ClearFuncResult clearTreeCollision(World::TreeElement& elTree, const World::Pos2 pos, const uint8_t flags, currency32_t& cost); // These are an additional return variable from the applyClear functions TileManager::ElementPositionFlags getPositionFlags(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco::World { #pragma pack(push, 1) struct TileElement : public TileElementBase { private: uint8_t pad[4]; }; #pragma pack(pop) static_assert(sizeof(TileElement) == kTileElementSize); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileElementBase.h ```h #pragma once #include "Types.hpp" #include <OpenLoco/Engine/World.hpp> #include <cassert> #include <span> namespace OpenLoco::World { struct TileElement; enum class ElementType : uint8_t { surface, // 0x00 track, // 0x04 station, // 0x08 signal, // 0x0C building, // 0x10 tree, // 0x14 wall, // 0x18 road, // 0x1C industry, // 0x20 }; static constexpr size_t kTileElementSize = 8; namespace ElementFlags { constexpr uint8_t ghost = 1 << 4; constexpr uint8_t aiAllocated = 1 << 5; // Kind of like an ai ghost which players can't place on constexpr uint8_t flag_6 = 1 << 6; constexpr uint8_t last = 1 << 7; } #pragma pack(push, 1) struct TileElementBase { protected: uint8_t _type; uint8_t _flags; uint8_t _baseZ; uint8_t _clearZ; public: // Temporary, use this to get fields easily before they are defined const uint8_t* data() const; ElementType type() const; void setType(ElementType t) { // Purposely clobbers any other data in _type _type = enumValue(t) << 2; } uint8_t flags() const { return _flags; } SmallZ baseZ() const { return _baseZ; } int16_t baseHeight() const { return _baseZ * kSmallZStep; } SmallZ clearZ() const { return _clearZ; } int16_t clearHeight() const { return _clearZ * kSmallZStep; } uint8_t occupiedQuarter() const { return _flags & 0xF; } void setOccupiedQuarter(uint8_t val) { _flags &= ~0xF; _flags |= val & 0xF; } bool isGhost() const { return _flags & ElementFlags::ghost; } void setGhost(bool state) { _flags &= ~ElementFlags::ghost; _flags |= state == true ? ElementFlags::ghost : 0; } bool isAiAllocated() const { return _flags & ElementFlags::aiAllocated; } void setAiAllocated(bool state) { _flags &= ~ElementFlags::aiAllocated; _flags |= state == true ? ElementFlags::aiAllocated : 0; } bool isFlag6() const { return _flags & ElementFlags::flag_6; } // in tracks/roads indicates is last tile of multi tile void setFlag6(bool state) { _flags &= ~ElementFlags::flag_6; _flags |= state == true ? ElementFlags::flag_6 : 0; } void setBaseZ(uint8_t baseZ) { _baseZ = baseZ; } void setClearZ(uint8_t value) { _clearZ = value; } bool isLast() const; void setLastFlag(bool state) { _flags &= ~ElementFlags::last; _flags |= state == true ? ElementFlags::last : 0; } std::span<uint8_t> rawData() { return std::span{ reinterpret_cast<uint8_t*>(this), kTileElementSize }; } std::span<const uint8_t> rawData() const { return std::span{ reinterpret_cast<const uint8_t*>(this), kTileElementSize }; } template<typename TType> const TType* as() const { return type() == TType::kElementType ? reinterpret_cast<const TType*>(this) : nullptr; } template<typename TType> TType* as() { return type() == TType::kElementType ? reinterpret_cast<TType*>(this) : nullptr; } template<typename TType> const TType& get() const { assert(type() == TType::kElementType); return *reinterpret_cast<const TType*>(this); } template<typename TType> TType& get() { assert(type() == TType::kElementType); return *reinterpret_cast<TType*>(this); } const TileElement* prev() const { return reinterpret_cast<const TileElement*>(reinterpret_cast<const uint8_t*>(this) - kTileElementSize); } TileElement* prev() { return reinterpret_cast<TileElement*>(reinterpret_cast<uint8_t*>(this) - kTileElementSize); } const TileElement* next() const { return reinterpret_cast<const TileElement*>(reinterpret_cast<const uint8_t*>(this) + kTileElementSize); } TileElement* next() { return reinterpret_cast<TileElement*>(reinterpret_cast<uint8_t*>(this) + kTileElementSize); } }; #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileLoop.cpp ```cpp #include "TileLoop.hpp" namespace OpenLoco::World { TilePosRangeView getClampedRange(const TilePos2& posA, const TilePos2& posB) { auto clampedA = TilePos2(clampTileCoord(posA.x), clampTileCoord(posA.y)); auto clampedB = TilePos2(clampTileCoord(posB.x), clampTileCoord(posB.y)); return TilePosRangeView(clampedA, clampedB); } TilePosRangeView getClampedRange(const Pos2& posA, const Pos2& posB) { auto clampedA = Pos2(clampCoord(posA.x), clampCoord(posA.y)); auto clampedB = Pos2(clampCoord(posB.x), clampCoord(posB.y)); return TilePosRangeView(toTileSpace(clampedA), toTileSpace(clampedB)); } TilePosRangeView getDrawableTileRange() { return TilePosRangeView({ 1, 1 }, { kMapColumns - 2, kMapRows - 2 }); } TilePosRangeView getWorldRange() { return TilePosRangeView({ 0, 0 }, { kMapColumns - 1, kMapRows - 1 }); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileLoop.hpp ```hpp #pragma once #include "Tile.h" namespace OpenLoco::World { #pragma pack(push, 1) struct TileLoop { private: Pos2 _pos; public: Pos2 current() const { return _pos; } Pos2 next() { _pos.x += kTileSize; if (_pos.x >= kMapWidth - 1) { _pos.x = 0; _pos.y += kTileSize; if (_pos.y >= kMapHeight - 1) { _pos.y = 0; } } return _pos; } }; #pragma pack(pop) // Loops over a range from bottomLeft to topRight inclusive struct TilePosRangeView { private: TilePos2 _bottomLeft; TilePos2 _topRight; class Iterator { private: const TilePos2 _bottomLeft; const TilePos2 _topRight; TilePos2 _pos; public: Iterator(const TilePos2& bottomLeft, const TilePos2& topRight) : _bottomLeft(bottomLeft) , _topRight(topRight) , _pos(bottomLeft) { } Iterator& operator++() { if (_pos.x >= _topRight.x) { _pos.x = _bottomLeft.x; _pos.y++; } else { _pos.x++; } return *this; } Iterator operator++(int) { Iterator retval = *this; ++(*this); return retval; } bool operator==(const Iterator& other) const { return _pos == other._pos; } const TilePos2& operator*() { return _pos; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = const TilePos2; using pointer = TilePos2*; using reference = const TilePos2&; using iterator_category = std::forward_iterator_tag; }; public: TilePosRangeView(const TilePos2& bottomLeft, const TilePos2& topRight) : _bottomLeft(bottomLeft) , _topRight(topRight) { assert(bottomLeft.x <= topRight.x); assert(bottomLeft.y <= topRight.y); } Iterator begin() const { return Iterator(_bottomLeft, _topRight); } Iterator end() const { // End iterator must be 1 step past the end so that loop is inclusive return Iterator(TilePos2(_bottomLeft.x, _topRight.y + 1), _topRight); } }; TilePosRangeView getClampedRange(const TilePos2& posA, const TilePos2& posB); TilePosRangeView getClampedRange(const Pos2& posA, const Pos2& posB); TilePosRangeView getDrawableTileRange(); TilePosRangeView getWorldRange(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileManager.cpp ```cpp #include "TileManager.h" #include "Audio/Audio.h" #include "BuildingElement.h" #include "Economy/Economy.h" #include "Effects/Effect.h" #include "Effects/ExplosionSmokeEffect.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "GameStateFlags.h" #include "IndustryElement.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/BridgeObject.h" #include "Objects/BuildingObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/TreeObject.h" #include "Objects/WaterObject.h" #include "OpenLoco.h" #include "Random.h" #include "RoadElement.h" #include "SceneManager.h" #include "SignalElement.h" #include "StationElement.h" #include "SurfaceElement.h" #include "TileClearance.h" #include "TrackElement.h" #include "TreeElement.h" #include "Ui.h" #include "Ui/ViewportInteraction.h" #include "ViewportManager.h" #include "WallElement.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include "World/TownManager.h" #include <OpenLoco/Diagnostics/Logging.h> #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <set> using namespace OpenLoco::Interop; using namespace OpenLoco::Diagnostics; namespace OpenLoco::World::TileManager { constexpr auto kNumTiles = kMapPitch * kMapColumns; static std::vector<TileElement> _elements; // 0x005230C8 static std::array<TileElement*, kNumTiles> _tiles{}; // 0x00E40134 static ptrdiff_t _elementsEnd = 0; // 0x00F00134 static const TileElement* _F00158 = nullptr; // 0x00F00158 static uint32_t _periodicDefragStartTile; // 0x00F00168 static bool _disablePeriodicDefrag; // 0x0050BF6C void disablePeriodicDefrag() { _disablePeriodicDefrag = true; } // 0x0046902E void removeSurfaceIndustry(const Pos2& pos) { auto tile = get(pos); auto* surface = tile.surface(); if (surface != nullptr) { surface->removeIndustry(pos); } } // 0x0046908D void removeSurfaceIndustryAtHeight(const Pos3& pos) { auto* elSurface = World::TileManager::get(pos).surface(); if (elSurface != nullptr) { // If underground if (elSurface->baseHeight() > pos.z) { return; } // If quite high in the air if (pos.z - elSurface->baseHeight() >= 12 * World::kSmallZStep) { return; } elSurface->removeIndustry(pos); } } // 0x004BF476 void allocateMapElements() { try { _elements.resize(kMaxElements); } catch (std::bad_alloc&) { exitWithError(StringIds::game_init_failure, StringIds::unable_to_allocate_enough_memory); return; } } // 0x00461179 void initialise() { _periodicDefragStartTile = 0; getGameState().tileUpdateStartLocation = World::Pos2(0, 0); const auto landType = getGameState().lastLandOption == 0xFF ? 0 : getGameState().lastLandOption; SurfaceElement defaultElement{}; defaultElement.setTerrain(landType); defaultElement.setBaseZ(4); defaultElement.setLastFlag(true); for (auto& element : _elements) { element = *reinterpret_cast<TileElement*>(&defaultElement); } updateTilePointers(); getGameState().flags |= GameStateFlags::tileManagerLoaded; } std::span<TileElement> getElements() { return std::span<TileElement>(static_cast<TileElement*>(&*_elements.begin()), _elementsEnd); } uint32_t numFreeElements() { return kMaxElements - _elementsEnd; } void setElements(std::span<TileElement> elements) { std::ranges::copy(elements, _elements.begin()); TileManager::updateTilePointers(); } // Note: Must be past the last tile flag static void markElementAsFree(TileElement& element) { element.setBaseZ(255); if (std::distance(&*_elements.begin(), element.next()) == _elementsEnd) { _elementsEnd--; } } // 0x00461760 void removeElement(TileElement& element) { // This is used to indicate if the caller can still use this pointer if (&element == _F00158) { if (element.isLast()) { _F00158 = nullptr; } } if (element.isLast()) { auto* prev = element.prev(); prev->setLastFlag(true); markElementAsFree(element); } else { // Move all of the elements up one until last for the tile auto* next = element.next(); auto* cur = &element; do { *cur++ = *next; } while (!next++->isLast()); markElementAsFree(*cur); } } void setRemoveElementPointerChecker(TileElement& element) { _F00158 = &element; } bool wasRemoveOnLastElement() { return _F00158 == nullptr; } static constexpr size_t getTileIndex(const TilePos2& pos) { // This is the same as (y * kMapPitch) + x return (pos.y << 9) | pos.x; } Tile get(TilePos2 pos) { const auto index = getTileIndex(pos); if (index >= _tiles.size()) { Logging::error("Attempted to get tile out of bounds! ({0}, {1})", pos.x, pos.y); return Tile(pos, nullptr); } auto data = _tiles[index]; return Tile(pos, data); } Tile get(Pos2 pos) { return get(pos.x, pos.y); } Tile get(coord_t x, coord_t y) { return get(TilePos2(x / World::kTileSize, y / World::kTileSize)); } static void set(TilePos2 pos, TileElement* elements) { const auto index = getTileIndex(pos); _tiles[index] = elements; } static std::pair<TileElement*, TileElement*> insertElementPrepareDest(const TilePos2 pos) { const auto index = getTileIndex(pos); if (index >= _tiles.size()) { Logging::error("Attempted to get tile out of bounds! ({0}, {1})", pos.x, pos.y); return std::make_pair(nullptr, nullptr); } auto* source = _tiles[index]; // _elementsEnd points to the free space at the end of the // tile elements. You must always check there is space (checkFreeElementsAndReorganise) // prior to calling this function! auto* dest = &_elements[_elementsEnd]; set(pos, dest); return std::make_pair(source, dest); } static TileElement* insertElementEnd(ElementType type, uint8_t baseZ, uint8_t occupiedQuads, TileElement* source, TileElement* dest, bool lastFound) { auto* newElement = dest++; // Clear the element *newElement = TileElement{}; newElement->setType(type); newElement->setBaseZ(baseZ); newElement->setClearZ(baseZ); newElement->setOccupiedQuarter(occupiedQuads); if (lastFound) { newElement->setLastFlag(true); } else { // Copy all of the elements that are above the new tile do { *dest = *source; source->setBaseZ(0xFFU); source++; } while (!dest++->isLast()); } _elementsEnd = std::distance(&*_elements.begin(), dest); return newElement; } // 0x004616D6 TileElement* insertElement(ElementType type, const Pos2& pos, uint8_t baseZ, uint8_t occupiedQuads) { checkFreeElementsAndReorganise(); auto [source, dest] = insertElementPrepareDest(toTileSpace(pos)); if (source == nullptr) { return nullptr; } bool lastFound = false; // Copy all of the elements that are underneath the new tile (or till end) while (baseZ >= source->baseZ()) { *dest = *source; source->setBaseZ(0xFFU); source++; if (dest->isLast()) { // The new element will become the last // so we are clearing the flag dest->setLastFlag(false); dest++; lastFound = true; break; } dest++; } return insertElementEnd(type, baseZ, occupiedQuads, source, dest, lastFound); } // 0x0046166C RoadElement* insertElementRoad(const Pos2& pos, uint8_t baseZ, uint8_t occupiedQuads) { checkFreeElementsAndReorganise(); auto [source, dest] = insertElementPrepareDest(toTileSpace(pos)); if (source == nullptr) { return nullptr; } bool lastFound = false; auto isRoadStation = [](const TileElement* source, SmallZ baseZ) { if (baseZ != source->baseZ()) { return false; } auto* srcStation = source->as<StationElement>(); if (srcStation == nullptr) { return false; } return srcStation->stationType() == StationType::roadStation; }; // Copy all of the elements that are underneath the new tile (or till end) while (baseZ >= source->baseZ() && !isRoadStation(source, baseZ)) { *dest = *source; source->setBaseZ(0xFFU); source++; if (dest->isLast()) { // The new element will become the last // so we are clearing the flag dest->setLastFlag(false); dest++; lastFound = true; break; } dest++; } return insertElementEnd(ElementType::road, baseZ, occupiedQuads, source, dest, lastFound)->as<RoadElement>(); } // 0x00461578 TileElement* insertElementAfterNoReorg(TileElement* after, ElementType type, const Pos2& pos, uint8_t baseZ, uint8_t occupiedQuads) { auto [source, dest] = insertElementPrepareDest(toTileSpace(pos)); if (source == nullptr) { return nullptr; } bool lastFound = false; // Copy all of the elements that are underneath the new tile (or till end) while (source <= after) { *dest = *source; source->setBaseZ(0xFFU); source++; if (dest->isLast()) { // The new element will become the last // so we are clearing the flag dest->setLastFlag(false); dest++; lastFound = true; break; } dest++; } return insertElementEnd(type, baseZ, occupiedQuads, source, dest, lastFound); } constexpr uint8_t kTileSize = 31; static int16_t getOneCornerUpLandHeight(int8_t xl, int8_t yl, uint8_t slope) { int16_t quad = 0; switch (slope) { case SurfaceSlope::CornerUp::north: quad = xl + yl - kTileSize; break; case SurfaceSlope::CornerUp::east: quad = xl - yl; break; case SurfaceSlope::CornerUp::south: quad = kTileSize - yl - xl; break; case SurfaceSlope::CornerUp::west: quad = yl - xl; break; } // If the element is in the quadrant with the slope, raise its height if (quad > 0) { return quad / 2; } return 0; } static int16_t getOneSideUpLandHeight(int8_t xl, int8_t yl, uint8_t slope) { int16_t edge = 0; switch (slope) { case SurfaceSlope::SideUp::northeast: edge = xl / 2 + 1; break; case SurfaceSlope::SideUp::southeast: edge = (kTileSize - yl) / 2; break; case SurfaceSlope::SideUp::northwest: edge = yl / 2 + 1; break; case SurfaceSlope::SideUp::southwest: edge = (kTileSize - xl) / 2; break; } return edge; } // This also takes care of the one corner down and one opposite corner up static int16_t getOneCornerDownLandHeight(int8_t xl, int8_t yl, uint8_t slope, bool isDoubleHeight) { int16_t quadExtra = 0; int16_t quad = 0; switch (slope) { case SurfaceSlope::CornerDown::west: quadExtra = xl + kTileSize - yl; quad = xl - yl; break; case SurfaceSlope::CornerDown::south: quadExtra = xl + yl; quad = xl + yl - kTileSize - 1; break; case SurfaceSlope::CornerDown::east: quadExtra = kTileSize - xl + yl; quad = yl - xl; break; case SurfaceSlope::CornerDown::north: quadExtra = (kTileSize - xl) + (kTileSize - yl); quad = kTileSize - yl - xl - 1; break; } if (isDoubleHeight) { return quadExtra / 2 + 1; } else { // This tile is essentially at the next height level // so we move *down* the slope return quad / 2 + 16; } } static int16_t getValleyLandHeight(int8_t xl, int8_t yl, uint8_t slope) { int16_t quad = 0; switch (slope) { case SurfaceSlope::Valley::westeast: if (xl + yl > kTileSize + 1) { quad = kTileSize - xl - yl; } break; case SurfaceSlope::Valley::northsouth: quad = xl - yl; break; } if (quad > 0) { return quad / 2; } return 0; } /** * Return the absolute height of an element, given its (x, y) coordinates * remember to & with 0xFFFF if you don't want water affecting results * * @param x @<ax> * @param y @<cx> * @return height @<edx> * * 0x00467297 rct2: 0x00662783 (numbers different) */ TileHeight getHeight(const Pos2& pos) { TileHeight height{ 16, 0 }; // Off the map if ((unsigned)pos.x >= (World::kMapWidth - 1) || (unsigned)pos.y >= (World::kMapHeight - 1)) { return height; } auto tile = TileManager::get(pos); // Get the surface element for the tile auto surfaceEl = tile.surface(); if (surfaceEl == nullptr) { return height; } height.waterHeight = surfaceEl->waterHeight(); height.landHeight = surfaceEl->baseHeight(); const auto slope = surfaceEl->slopeCorners(); // Sub-tile coords const auto xl = pos.x & 0x1f; const auto yl = pos.y & 0x1f; // Slope logic: // Each of the four bits in slope represents that corner being raised // slope == 15 (all four bits) is not used and slope == 0 is flat // If the extra_height bit is set, then the slope goes up two z-levels (this happens with one corner down with opposite corner up) // We arbitrarily take the SW corner to be closest to the viewer switch (slope) { case SurfaceSlope::flat: // Flat surface requires no further calculations. break; case SurfaceSlope::CornerUp::north: case SurfaceSlope::CornerUp::east: case SurfaceSlope::CornerUp::south: case SurfaceSlope::CornerUp::west: height.landHeight += getOneCornerUpLandHeight(xl, yl, slope); break; case SurfaceSlope::SideUp::northeast: case SurfaceSlope::SideUp::southeast: case SurfaceSlope::SideUp::northwest: case SurfaceSlope::SideUp::southwest: height.landHeight += getOneSideUpLandHeight(xl, yl, slope); break; case SurfaceSlope::CornerDown::north: case SurfaceSlope::CornerDown::east: case SurfaceSlope::CornerDown::south: case SurfaceSlope::CornerDown::west: height.landHeight += getOneCornerDownLandHeight(xl, yl, slope, surfaceEl->isSlopeDoubleHeight()); break; case SurfaceSlope::Valley::northsouth: case SurfaceSlope::Valley::westeast: height.landHeight += getValleyLandHeight(xl, yl, slope); break; } return height; } static uint8_t getCornerDownMask(const uint8_t cornerUp) { switch (cornerUp) { case SurfaceSlope::CornerUp::north: return SurfaceSlope::CornerDown::south; case SurfaceSlope::CornerUp::south: return SurfaceSlope::CornerDown::north; case SurfaceSlope::CornerUp::west: return SurfaceSlope::CornerDown::east; case SurfaceSlope::CornerUp::east: return SurfaceSlope::CornerDown::west; } return SurfaceSlope::flat; } SmallZ getSurfaceCornerDownHeight(const SurfaceElement& surface, const uint8_t cornerMask) { auto baseZ = surface.baseZ(); if (surface.slope() & cornerMask) { baseZ += kSmallZStep; uint8_t cornerDownMask = getCornerDownMask(cornerMask); if (surface.isSlopeDoubleHeight() && surface.slopeCorners() == cornerDownMask) { baseZ += kSmallZStep; } } return baseZ; } SmallZ getSurfaceCornerHeight(const SurfaceElement& surface) { auto baseZ = surface.baseZ(); if (surface.slope()) { baseZ += kSmallZStep; if (surface.isSlopeDoubleHeight()) { baseZ += kSmallZStep; } } return baseZ; } static void clearTilePointers() { std::ranges::fill(_tiles, nullptr); } // 0x00461348 void updateTilePointers() { clearTilePointers(); auto el = _elements.begin(); for (tile_coord_t y = 0; y < kMapRows; y++) { for (tile_coord_t x = 0; x < kMapColumns; x++) { set(TilePos2(x, y), &*el); // Skip remaining elements on this tile do { el++; } while (!(el - 1)->isLast()); } } _elementsEnd = std::distance(_elements.begin(), el); } // 0x0046148F void reorganise() { const auto curCursor = Ui::getCursor(); Ui::setCursor(Ui::CursorId::busy); try { // Allocate a temporary buffer and tightly pack all the tile elements in the map std::vector<TileElement> tempBuffer; tempBuffer.resize(kMaxElements); size_t numElements = 0; for (tile_coord_t y = 0; y < kMapRows; y++) { for (tile_coord_t x = 0; x < kMapColumns; x++) { auto tile = get(TilePos2(x, y)); for (const auto& element : tile) { tempBuffer[numElements] = element; numElements++; } } } // Copy organised elements back to original element buffer _elements = tempBuffer; updateTilePointers(); } catch (const std::bad_alloc&) { exitWithError(StringIds::unable_to_allocate_enough_memory, StringIds::game_init_failure); } // Note: original implementation did not revert the cursor Ui::setCursor(curCursor); } // 0x004613F0 void defragmentTilePeriodic() { if (!Game::hasFlags(GameStateFlags::tileManagerLoaded)) { return; } if (_disablePeriodicDefrag) { _disablePeriodicDefrag = false; return; } _disablePeriodicDefrag = false; const uint32_t searchStart = _periodicDefragStartTile + 1; for (auto i = 0U; i < kNumTiles; ++i) { const auto j = (i + searchStart) % kNumTiles; if (_tiles[j] != nullptr) { _periodicDefragStartTile = j; break; } } auto* firstTile = _tiles[_periodicDefragStartTile]; auto* emptyTile = firstTile - 1; while (emptyTile != &_elements[0] && emptyTile->baseZ() == 0xFFU) { emptyTile--; } emptyTile++; if (emptyTile == firstTile) { return; } _tiles[_periodicDefragStartTile] = emptyTile; { auto* dest = emptyTile; auto* source = firstTile; do { *dest = *source; source->setBaseZ(0xFFU); source++; } while (!dest++->isLast()); } // Its possible we have freed up elements at the end so this // looks to see if we should move the element end auto newEnd = _elementsEnd - 1; while (_elements[newEnd].baseZ() == 0xFFU) { newEnd--; } _elementsEnd = newEnd + 1; } // 0x00461393 bool checkFreeElementsAndReorganise() { if (numFreeElements() > kMaxElementsOnOneTile) { return true; } // First try a basic defrag multiple times for (auto i = 0U; i < 1000; ++i) { defragmentTilePeriodic(); } if (numFreeElements() > kMaxElementsOnOneTile) { return true; } // Now try a full defrag reorganise(); if (numFreeElements() > kMaxElementsOnOneTile) { return true; } GameCommands::setErrorText(StringIds::landscape_data_area_full); return false; } CompanyId getTileOwner(const World::TileElement& el) { CompanyId owner = CompanyId::null; if (auto* elTrack = el.as<TrackElement>(); elTrack != nullptr) { owner = elTrack->owner(); } else if (auto* elRoad = el.as<RoadElement>(); elRoad != nullptr) { owner = elRoad->owner(); } else if (auto* elStation = el.as<StationElement>(); elStation != nullptr) { if (elStation->stationType() == StationType::trainStation) { if (auto* prevElTrack = el.prev()->as<TrackElement>(); prevElTrack != nullptr) { owner = prevElTrack->owner(); } } else if (elStation->stationType() == StationType::roadStation) { if (auto* prevElRoad = el.prev()->as<RoadElement>(); prevElRoad != nullptr) { owner = prevElRoad->owner(); } } else { owner = elStation->owner(); } } else if (auto* elSignal = el.as<SignalElement>(); elSignal != nullptr) { if (auto* prevElTrack = el.prev()->as<TrackElement>(); prevElTrack != nullptr) { owner = prevElTrack->owner(); } } return owner; } // 0x004CBE5F // regs.ax: pos.x // regs.cx: pos.y void mapInvalidateTileFull(World::Pos2 pos) { Ui::ViewportManager::invalidate(pos, 0, 1120, ZoomLevel::eighth); } // 0x0046A747 void resetSurfaceClearance() { for (coord_t y = 0; y < kMapHeight; y += kTileSize) { for (coord_t x = 0; x < kMapWidth; x += kTileSize) { auto tile = get(x, y); auto surface = tile.surface(); if (surface != nullptr && surface->slope() == 0) { surface->setClearZ(surface->baseZ()); } } } } // 0x00469A81 int16_t mountainHeight(const World::Pos2& loc) { // Works out roughly the height of a mountain of area 11 * 11 // (Its just the highest point - the lowest point) int16_t lowest = std::numeric_limits<int16_t>::max(); int16_t highest = 0; const auto initialTilePos = toTileSpace(loc); auto range = getClampedRange(initialTilePos - TilePos2{ 5, 5 }, initialTilePos + TilePos2{ 5, 5 }); for (auto& tilePos : range) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); auto height = surface->baseHeight(); lowest = std::min(lowest, height); if (surface->slope()) { height += 16; if (surface->isSlopeDoubleHeight()) { height += 16; } } highest = std::max(highest, height); } return highest - lowest; } // 0x004C5596 uint16_t countSurroundingWaterTiles(const Pos2& pos) { // Search a 10x10 area centred at pos. // Initial tile position is the top left of the area. auto initialTilePos = World::toTileSpace(pos) - World::TilePos2(5, 5); uint16_t surroundingWaterTiles = 0; for (const auto& tilePos : getClampedRange(initialTilePos, initialTilePos + TilePos2{ 10, 10 })) { auto tile = get(tilePos); auto* surface = tile.surface(); if (surface != nullptr && surface->water() > 0) { surroundingWaterTiles++; } } return surroundingWaterTiles; } // 0x00469B1D uint16_t countSurroundingDesertTiles(const Pos2& pos) { // Search a 10x10 area centred at pos. // Initial tile position is the top left of the area. auto initialTilePos = toTileSpace(pos) - TilePos2(5, 5); uint16_t surroundingDesertTiles = 0; for (const auto& tilePos : getClampedRange(initialTilePos, initialTilePos + TilePos2{ 10, 10 })) { auto tile = get(tilePos); auto* surface = tile.surface(); // Desert tiles can't have water! Oasis aren't deserts. if (surface == nullptr || surface->water() != 0) { continue; } auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); if (landObj == nullptr) { continue; } if (landObj->hasFlags(LandObjectFlags::isDesert)) { surroundingDesertTiles++; } } return surroundingDesertTiles; } // 0x004BE048 uint16_t countSurroundingTrees(const Pos2& pos) { // Search a 10x10 area centred at pos. // Initial tile position is the top left of the area. auto initialTilePos = World::toTileSpace(pos) - World::TilePos2(5, 5); uint16_t surroundingTrees = 0; for (const auto& tilePos : getClampedRange(initialTilePos, initialTilePos + TilePos2{ 10, 10 })) { auto tile = get(tilePos); for (auto& element : tile) { // NB: vanilla was checking for trees above the surface element. // This has been omitted from our implementation. auto* tree = element.as<TreeElement>(); if (tree == nullptr) { continue; } if (tree->isGhost()) { continue; } surroundingTrees++; } } return surroundingTrees; } // 0x004C5604 uint16_t countNearbyWaterTiles(Pos2 pos) { // Search a 20x20 area in a checkerboard pattern, centred at pos. // Initial tile position is the top left of the area. auto initialTilePos = World::toTileSpace(pos) - World::TilePos2(10, 10); uint16_t nearbyWaterTiles = 0; for (const auto& tilePos : getClampedRange(initialTilePos, initialTilePos + TilePos2{ 20, 20 })) { // Skip every other tile, depending on initial position if ((tilePos.x & 1) != (initialTilePos.x & 1) || (tilePos.y & 1) != (initialTilePos.y & 1)) { continue; } auto tile = get(tilePos); auto* surface = tile.surface(); if (surface != nullptr && surface->water() > 0) { nearbyWaterTiles++; } } return nearbyWaterTiles; } static bool update(TileElement& el, const World::Pos2& loc) { switch (el.type()) { case ElementType::surface: { auto& elSurface = el.get<SurfaceElement>(); return updateSurface(elSurface, loc); } case ElementType::building: { auto& elBuilding = el.get<BuildingElement>(); return elBuilding.update(loc); } case ElementType::tree: { auto& elTree = el.get<TreeElement>(); return updateTreeElement(elTree, loc); } case ElementType::road: { auto& elRoad = el.get<RoadElement>(); return elRoad.update(loc); } case ElementType::industry: { auto& elIndustry = el.get<IndustryElement>(); return elIndustry.update(loc); } case ElementType::track: break; case ElementType::station: break; case ElementType::signal: break; case ElementType::wall: break; } return true; } // 0x00463ABA void update() { if (!Game::hasFlags(GameStateFlags::tileManagerLoaded)) { return; } GameCommands::setUpdatingCompanyId(CompanyId::neutral); auto pos = getGameState().tileUpdateStartLocation; for (; pos.y < World::kMapHeight; pos.y += 16 * World::kTileSize) { for (; pos.x < World::kMapWidth; pos.x += 16 * World::kTileSize) { auto tile = TileManager::get(pos); for (auto& el : tile) { if (el.isGhost()) { continue; } // If update removed/added tiles we must stop loop as pointer is invalid if (!update(el, pos)) { break; } } } pos.x -= World::kMapWidth; } pos.y -= World::kMapHeight; const auto tilePos = World::toTileSpace(pos); const uint8_t shift = (tilePos.y << 4) + tilePos.x + 9; getGameState().tileUpdateStartLocation = World::toWorldSpace(TilePos2(shift & 0xF, shift >> 4)); if (shift == 0) { IndustryManager::updateProducedCargoStats(); } } // 0x0048B089 static void playDemolishTreeSound(const World::Pos3& loc) { const auto frequency = gPrng2().randNext(20003, 24098); Audio::playSound(Audio::SoundId::demolishTree, loc, -1100, frequency); } // 0x004BB432 // bl = flags; // esi = X86Pointer(&element); // ax = pos.x; // cx = pos.y; void removeTree(World::TreeElement& element, const uint8_t flags, const World::Pos2& pos) { if ((!element.isGhost() && !element.isAiAllocated()) && GameCommands::getUpdatingCompanyId() != CompanyId::neutral) { auto loc = World::Pos3(pos.x, pos.y, element.baseHeight()); playDemolishTreeSound(loc); } if ((flags & GameCommands::Flags::ghost) == 0) { auto treeObj = ObjectManager::get<TreeObject>(element.treeObjectId()); auto ratingReduction = treeObj->demolishRatingReduction; TownManager::updateTownInfo(pos, 0, 0, ratingReduction, 0); } auto zMin = element.baseHeight(); auto zMax = element.clearHeight(); Ui::ViewportManager::invalidate(pos, zMin, zMax, ZoomLevel::eighth, 56); World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(&element)); } // 0x0048B0C7 void createDestructExplosion(const World::Pos3& pos) { ExplosionSmoke::create(pos + World::Pos3{ 0, 0, 13 }); const auto randFreq = gPrng2().randNext(20'003, 24'098); Audio::playSound(Audio::SoundId::demolishBuilding, pos, -1400, randFreq); } // 0x0042D8FF void removeBuildingElement(BuildingElement& elBuilding, const World::Pos2& pos) { if (!elBuilding.isGhost() && !elBuilding.isAiAllocated()) { if (GameCommands::getUpdatingCompanyId() != CompanyId::neutral) { createDestructExplosion(World::Pos3(pos.x + 16, pos.y + 16, elBuilding.baseHeight())); } } if (elBuilding.sequenceIndex() == 0) { if (!elBuilding.isGhost()) { auto* buildingObj = elBuilding.getObject(); if (buildingObj != nullptr) { if (!buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { auto buildingCapacity = -buildingObj->producedQuantity[0]; auto removedPopulation = buildingCapacity; if (!elBuilding.isConstructed()) { removedPopulation = 0; } auto ratingReduction = buildingObj->demolishRatingReduction; auto* town = TownManager::updateTownInfo(pos, removedPopulation, buildingCapacity, ratingReduction, -1); if (town != nullptr) { if (buildingObj->var_AC != 0xFF) { town->var_150[buildingObj->var_AC] -= 1; } } } } } } Ui::ViewportManager::invalidate(pos, elBuilding.baseHeight(), elBuilding.clearHeight(), ZoomLevel::eighth); TileManager::removeElement(*reinterpret_cast<TileElement*>(&elBuilding)); } // 0x004C482B void removeAllWallsOnTileAbove(const World::TilePos2& pos, SmallZ baseZ) { std::vector<World::TileElement*> toDelete; auto tile = get(pos); for (auto& el : tile) { auto* elWall = el.as<WallElement>(); if (elWall == nullptr) { continue; } if (baseZ >= elWall->clearZ()) { continue; } if (baseZ + 12 < elWall->baseZ()) { continue; } toDelete.push_back(&el); } // Remove in reverse order to prevent pointer invalidation std::for_each(std::rbegin(toDelete), std::rend(toDelete), [&pos](World::TileElement* el) { Ui::ViewportManager::invalidate(World::toWorldSpace(pos), el->baseHeight(), el->baseHeight() + 72, ZoomLevel::half); removeElement(*el); }); } // 0x004C4979 void removeAllWallsOnTileBelow(const World::TilePos2& pos, SmallZ baseZ) { std::vector<World::TileElement*> toDelete; auto tile = get(pos); for (auto& el : tile) { auto* elWall = el.as<WallElement>(); if (elWall == nullptr) { continue; } if (baseZ < elWall->clearZ() && baseZ + 12 <= elWall->baseZ()) { continue; } toDelete.push_back(&el); } // Remove in reverse order to prevent pointer invalidation std::for_each(std::rbegin(toDelete), std::rend(toDelete), [&pos](World::TileElement* el) { Ui::ViewportManager::invalidate(World::toWorldSpace(pos), el->baseHeight(), el->baseHeight() + 72, ZoomLevel::half); removeElement(*el); }); } static void setTerrainStyleAsCleared(const Pos2 pos, SurfaceElement& surface) { if (surface.isIndustrial()) { return; } if (surface.getGrowthStage() > 0) { surface.setGrowthStage(0); surface.setSnowCoverage(0); Ui::ViewportManager::invalidate(pos, surface.baseHeight(), surface.baseHeight() + 32, ZoomLevel::eighth); } if (surface.snowCoverage() > 0) { surface.setSnowCoverage(0); Ui::ViewportManager::invalidate(pos, surface.baseHeight(), surface.baseHeight() + 32, ZoomLevel::eighth); } } // 0x004795D1 void setLevelCrossingFlags(const World::Pos3 pos) { auto findLevelTrackAndRoad = [pos](auto&& trackFunction, auto&& roadFunction) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } if (el.isAiAllocated()) { continue; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { if (elTrack->trackId() == 0) { trackFunction(*elTrack); } } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { if (elRoad->roadId() == 0) { roadFunction(*elRoad); } } } }; bool hasRoad = false; bool hasTrack = false; findLevelTrackAndRoad( [&hasTrack](World::TrackElement& elTrack) { hasTrack |= elTrack.hasLevelCrossing(); }, [&hasRoad](World::RoadElement& elRoad) { hasRoad |= elRoad.hasLevelCrossing(); }); if (hasRoad ^ hasTrack) { findLevelTrackAndRoad( [hasTrack](World::TrackElement& elTrack) { if (hasTrack) { elTrack.setHasLevelCrossing(false); } }, [hasRoad](World::RoadElement& elRoad) { if (hasRoad) { elRoad.setHasLevelCrossing(false); elRoad.setUnk7_10(false); elRoad.setLevelCrossingObjectId(0); } }); } } // 0x004690FC void setTerrainStyleAsCleared(const Pos2& pos) { auto* surface = World::TileManager::get(pos).surface(); if (surface == nullptr) { return; } setTerrainStyleAsCleared(pos, *surface); } // 0x00469174 void setTerrainStyleAsClearedAtHeight(const Pos3& pos) { auto* elSurface = World::TileManager::get(pos).surface(); if (elSurface == nullptr) { return; } // If underground if (elSurface->baseHeight() > pos.z) { return; } // If quite high in the air if (pos.z - elSurface->baseHeight() >= 12 * World::kSmallZStep) { return; } setTerrainStyleAsCleared(pos, *elSurface); } // 0x00468651 uint32_t adjustSurfaceHeight(World::Pos2 pos, SmallZ targetBaseZ, uint8_t slopeFlags, World::TileClearance::RemovedBuildings& removedBuildings, uint8_t flags) { if (!validCoords(pos)) { GameCommands::setErrorText(StringIds::off_edge_of_map); return GameCommands::FAILURE; } if (targetBaseZ < 4) { GameCommands::setErrorText(StringIds::error_too_low); return GameCommands::FAILURE; } if (targetBaseZ > 160 || (targetBaseZ == 160 && (slopeFlags & 0x1F) != 0) || (targetBaseZ == 156 && (slopeFlags & 0x10) != 0)) { GameCommands::setErrorText(StringIds::error_too_high); return GameCommands::FAILURE; } currency32_t totalCost = 0; if (flags & GameCommands::Flags::apply) { removeSurfaceIndustry(pos); if (!SceneManager::isEditorMode()) { setTerrainStyleAsCleared(pos); } auto clearHeight = getHeight(pos).landHeight; removeAllWallsOnTileAbove(toTileSpace(pos), clearHeight / 4); } // Compute cost of landscape operation auto tile = get(pos); auto* surface = tile.surface(); auto landObj = ObjectManager::get<LandObject>(surface->terrain()); totalCost += Economy::getInflationAdjustedCost(landObj->costFactor, landObj->costIndex, 10); auto targetClearZ = targetBaseZ; if (slopeFlags & 0x1F) { targetClearZ += kSmallZStep; } if (slopeFlags & SurfaceSlope::doubleHeight) { targetClearZ += kSmallZStep; } // If surface is in use as a water(route), and has water, ensure we don't remove it if (surface->hasType6Flag() && surface->water() > 0) { auto waterHeight = (surface->water() - 1) * kMicroToSmallZStep; if (waterHeight < targetClearZ) { GameCommands::setErrorText(StringIds::water_channel_currently_needed_by_ships); return GameCommands::FAILURE; } } // Bind our local vars to the tile clear function auto clearFunc = [pos, &removedBuildings, flags, &totalCost](TileElement& el) { return TileClearance::clearWithDefaultCollision(el, pos, removedBuildings, flags, totalCost); }; QuarterTile qt(0xF, 0); if (!TileClearance::applyClearAtAllHeights(pos, targetBaseZ, targetClearZ, qt, clearFunc)) { return GameCommands::FAILURE; } // Check bridge requirements for track and road elements const auto tileIt = get(pos); for (auto& el : tileIt) { if (!(el.type() == ElementType::track || el.type() == ElementType::road)) { continue; } if (el.isGhost()) { continue; } auto height = el.baseZ() - targetBaseZ; if (height < 0) { continue; } if (el.type() == ElementType::track) { auto* trackEl = el.as<TrackElement>(); if (trackEl != nullptr) { if (trackEl->hasBridge()) { auto* bridgeObj = ObjectManager::get<BridgeObject>(trackEl->bridge()); if (height > bridgeObj->maxHeight * kMicroToSmallZStep) { GameCommands::setErrorText(StringIds::bridge_already_at_maximum_height); return GameCommands::FAILURE; } } else { auto* trackObj = ObjectManager::get<TrackObject>(trackEl->trackObjectId()); auto args = FormatArguments::common(); args.push(trackObj->name); GameCommands::setErrorText(StringIds::stringid_requires_a_bridge); return GameCommands::FAILURE; } } } else if (el.type() == ElementType::road) { auto* roadEl = el.as<RoadElement>(); if (roadEl != nullptr) { if (roadEl->hasBridge()) { auto* bridgeObj = ObjectManager::get<BridgeObject>(roadEl->bridge()); if (height > bridgeObj->maxHeight * kMicroToSmallZStep) { GameCommands::setErrorText(StringIds::bridge_already_at_maximum_height); return GameCommands::FAILURE; } } else { auto* roadObj = ObjectManager::get<RoadObject>(roadEl->roadObjectId()); auto args = FormatArguments::common(); args.push(roadObj->name); GameCommands::setErrorText(StringIds::stringid_requires_a_bridge); return GameCommands::FAILURE; } } } } if (!(flags & GameCommands::Flags::apply)) { return totalCost; } surface = tileIt.surface(); if (!SceneManager::isEditorMode()) { // Reset terrain growth when not in editor surface->setGrowthStage(0); } surface->setBaseZ(targetBaseZ); surface->setClearZ(targetBaseZ); surface->setSlope(slopeFlags); landObj = ObjectManager::get<LandObject>(surface->terrain()); if (landObj->hasFlags(LandObjectFlags::hasReplacementLandHeader) && !SceneManager::isEditorMode()) { surface->setTerrain(landObj->replacementLandHeader); } if (surface->water() * kMicroToSmallZStep <= targetBaseZ) { surface->setWater(0); } mapInvalidateTileFull(pos); return totalCost; } // 0x004C4C28 uint32_t adjustWaterHeight(World::Pos2 pos, SmallZ targetHeight, World::TileClearance::RemovedBuildings& removedBuildings, uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); GameCommands::setPosition(World::Pos3(pos.x + World::kTileSize / 2, pos.y + World::kTileSize / 2, targetHeight * kMicroToSmallZStep)); if (targetHeight < 4) { GameCommands::setErrorText(StringIds::error_too_low); return GameCommands::FAILURE; } if (targetHeight >= 116) { GameCommands::setErrorText(StringIds::error_too_high); return GameCommands::FAILURE; } currency32_t totalCost = 0; if (flags & GameCommands::Flags::apply) { removeSurfaceIndustry(pos); if (!SceneManager::isEditorMode()) { setTerrainStyleAsCleared(pos); } auto clearHeight = getHeight(pos).landHeight; removeAllWallsOnTileAbove(toTileSpace(pos), clearHeight / kSmallZStep); } auto tile = get(pos); auto* surface = tile.surface(); auto referenceZ = surface->baseZ(); auto water = surface->water(); if (water > 0) { referenceZ = water * kMicroToSmallZStep; } const auto baseTargetZ = std::min(targetHeight, referenceZ); const auto clearTargetZ = std::max(targetHeight, referenceZ); // Bind our local vars to the tile clear function auto clearFunc = [pos, &removedBuildings, flags, &totalCost](TileElement& el) { return TileClearance::clearWithDefaultCollision(el, pos, removedBuildings, flags, totalCost); }; QuarterTile qt(0xF, 0); if (!TileClearance::applyClearAtAllHeights(pos, baseTargetZ, clearTargetZ, qt, clearFunc)) { return GameCommands::FAILURE; } if (surface->hasType6Flag()) { GameCommands::setErrorText(StringIds::water_channel_currently_needed_by_ships); return GameCommands::FAILURE; } auto* waterObj = ObjectManager::get<WaterObject>(); totalCost += Economy::getInflationAdjustedCost(waterObj->costFactor, waterObj->costIndex, 10); if (flags & GameCommands::Flags::apply) { if (targetHeight <= surface->baseZ()) { surface->setWater(0); } else { surface->setWater(targetHeight / kMicroToSmallZStep); } surface->setType6Flag(false); surface->setVariation(0); mapInvalidateTileFull(pos); } return totalCost; } // 0x0047AB9B void updateYearly() { const auto isObjectNotTram = getGameState().roadObjectIdIsNotTram; for (const auto& tilePos : getWorldRange()) { auto tile = get(tilePos); for (auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } // This is a much cheaper tram checker // compared to getting the object if (isObjectNotTram & (1U << elRoad->roadObjectId())) { elRoad->setUnk7_80(elRoad->hasUnk7_40()); elRoad->setUnk7_40(false); } } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TileManager.h ```h #pragma once #include "Tile.h" #include "TileClearance.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <cstdint> #include <set> #include <span> namespace OpenLoco::World { class QuarterTile; struct BuildingElement; struct TreeElement; struct SurfaceElement; struct RoadElement; enum class ElementType : uint8_t; } namespace OpenLoco::World::TileManager { constexpr size_t kMaxElements = 3 * kMapColumns * kMapRows; constexpr size_t kMaxElementsOnOneTile = 1024; // If you exceed this then the game may buffer overflow in certain situations constexpr size_t kMaxUsableElements = kMaxElements - kMaxElementsOnOneTile; const TileElement* const kInvalidTile = reinterpret_cast<const TileElement*>(static_cast<intptr_t>(-1)); enum class ElementPositionFlags : uint8_t { none = 0U, aboveGround = 1U << 0, underground = 1U << 1, partiallyUnderwater = 1U << 2, underwater = 1U << 3, anyHeightBuildingCollisions = 1U << 7, // Do not use only for interop }; OPENLOCO_ENABLE_ENUM_OPERATORS(ElementPositionFlags); void allocateMapElements(); void initialise(); std::span<TileElement> getElements(); uint32_t numFreeElements(); Tile get(TilePos2 pos); Tile get(Pos2 pos); Tile get(coord_t x, coord_t y); void setElements(std::span<TileElement> elements); void removeElement(TileElement& element); // This is used with wasRemoveOnLastElement to indicate that pointer passed to removeElement is now bad void setRemoveElementPointerChecker(TileElement& element); // See above. Used to indicate if pointer to removeElement is now bad bool wasRemoveOnLastElement(); // Note: Any TileElement pointers invalid after this call TileElement* insertElement(ElementType type, const Pos2& pos, uint8_t baseZ, uint8_t occupiedQuads); // Note: Any TileElement pointers invalid after this call template<typename TileT> TileT* insertElement(const Pos2& pos, const uint8_t baseZ, const uint8_t occupiedQuads) { return insertElement(TileT::kElementType, pos, baseZ, occupiedQuads)->template as<TileT>(); } // Note: `after` pointer will be invalid after this call TileElement* insertElementAfterNoReorg(TileElement* after, ElementType type, const Pos2& pos, uint8_t baseZ, uint8_t occupiedQuads); // Note: `after` pointer will be invalid after this call template<typename TileT> TileT* insertElementAfterNoReorg(TileElement* after, const Pos2& pos, const uint8_t baseZ, const uint8_t occupiedQuads) { return insertElementAfterNoReorg(after, TileT::kElementType, pos, baseZ, occupiedQuads)->template as<TileT>(); } // Special road element insert World::RoadElement* insertElementRoad(const Pos2& pos, uint8_t baseZ, uint8_t occupiedQuads); TileHeight getHeight(const Pos2& pos); SmallZ getSurfaceCornerHeight(const SurfaceElement& surface); SmallZ getSurfaceCornerDownHeight(const SurfaceElement& surface, const uint8_t cornerMask); void updateTilePointers(); // Only disables first call to defrag void disablePeriodicDefrag(); // Fully defragment the tile element array void reorganise(); // Defragments singular tile (chosen tile updates each call) void defragmentTilePeriodic(); bool checkFreeElementsAndReorganise(); CompanyId getTileOwner(const World::TileElement& el); void mapInvalidateTileFull(World::Pos2 pos); void resetSurfaceClearance(); int16_t mountainHeight(const World::Pos2& loc); uint16_t countSurroundingWaterTiles(const Pos2& pos); uint16_t countSurroundingDesertTiles(const Pos2& pos); uint16_t countSurroundingTrees(const Pos2& pos); uint16_t countNearbyWaterTiles(Pos2 pos); void update(); void updateYearly(); void removeSurfaceIndustry(const Pos2& pos); void removeSurfaceIndustryAtHeight(const Pos3& pos); void createDestructExplosion(const World::Pos3& pos); void removeBuildingElement(BuildingElement& element, const World::Pos2& pos); void removeTree(TreeElement& element, const uint8_t flags, const World::Pos2& pos); void removeAllWallsOnTileAbove(const World::TilePos2& pos, SmallZ baseZ); void removeAllWallsOnTileBelow(const World::TilePos2& pos, SmallZ baseZ); void setLevelCrossingFlags(const World::Pos3 pos); void setTerrainStyleAsCleared(const Pos2& pos); void setTerrainStyleAsClearedAtHeight(const Pos3& pos); uint32_t adjustSurfaceHeight(World::Pos2 pos, SmallZ targetBaseZ, uint8_t slopeFlags, World::TileClearance::RemovedBuildings& removedBuildings, uint8_t flags); uint32_t adjustWaterHeight(World::Pos2 pos, SmallZ targetHeight, World::TileClearance::RemovedBuildings& removedBuildings, uint8_t flags); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TrackElement.h ```h #pragma once #include "TileElementBase.h" #include <optional> namespace OpenLoco::World { #pragma pack(push, 1) struct TrackElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::track; private: uint8_t _4; uint8_t _5; uint8_t _6; uint8_t _7; public: TrackElement() = default; TrackElement(World::SmallZ baseZ, World::SmallZ clearZ, uint8_t direction, uint8_t quarterTile, uint8_t sequenceIndex, uint8_t trackObjId, uint8_t trackId, std::optional<uint8_t> bridge, CompanyId owner, uint8_t mods); bool hasStationElement() const { return (_type & 0x80) != 0; } void setHasStationElement(bool state) { _type &= ~0x80; _type |= state ? 0x80 : 0; } bool hasSignal() const { return (_type & 0x40) != 0; } void setHasSignal(bool state) { _type &= ~0x40; _type |= state ? 0x40 : 0; } uint8_t rotation() const { return _type & 0x03; } void setRotation(uint8_t rotation) { _type &= ~0x3; _type |= rotation & 0x3; } uint8_t trackId() const { return _4 & 0x3F; } // _4 void setTrackId(uint8_t trackId) { _4 &= ~0x3F; _4 |= trackId & 0x3F; } bool hasBridge() const { return (_4 & 0x80) != 0; } void setHasBridge(bool state) { _4 &= ~(1U << 7); _4 |= state ? (1U << 7) : 0; } bool hasGhostMods() const { return (_4 & 0x40) != 0; } void setHasGhostMods(bool state) { _4 &= ~(1U << 6); _4 |= state ? (1U << 6) : 0; } uint8_t trackObjectId() const { return _5 >> 4; } // _5u void setTrackObjectId(uint8_t trackObjectId) { _5 &= ~0xF0; _5 |= (trackObjectId & 0xF) << 4; } uint8_t sequenceIndex() const { return _5 & 0xF; } // _5l void setSequenceIndex(uint8_t index) { _5 &= ~0x0F; _5 |= index & 0xF; } bool hasLevelCrossing() const { return (_6 & 0x10) != 0; } // _6_10 void setHasLevelCrossing(bool state) { _6 &= ~(1U << 4); _6 |= state ? (1U << 4) : 0; } uint8_t bridge() const { return _6 >> 5; } // _6u void setBridgeObjectId(uint8_t bridgeObjectId) { _6 &= ~0xE0; _6 |= (bridgeObjectId & 0x7) << 5; } CompanyId owner() const { return CompanyId(_7 & 0xF); } // _7l void setOwner(CompanyId newOwner) { _7 = (_7 & 0xF0) | (enumValue(newOwner) & 0xF); } bool hasMod(uint8_t mod) const { return _7 & (1 << (4 + mod)); } // _7u uint8_t mods() const { return _7 >> 4; } // _7u void setMod(uint8_t mod, bool state) { _7 &= ~(1U << (4 + mod)); _7 |= state ? (1U << (4 + mod)) : 0; } }; #pragma pack(pop) static_assert(sizeof(TrackElement) == kTileElementSize); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Tree.cpp ```cpp #include "Tree.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Terraform/CreateTree.h" #include "Graphics/Colour.h" #include "Map/MapSelection.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "Random.h" #include "Scenario.h" #include "SurfaceElement.h" #include "TileManager.h" #include "Ui/ViewportInteraction.h" #include <OpenLoco/Math/Trigonometry.hpp> namespace OpenLoco::World { // 0x004BDF19 std::optional<uint8_t> getRandomTreeTypeFromSurface(const World::TilePos2& loc, bool unk) { if (!World::validCoords(loc)) { return {}; } auto* surface = World::TileManager::get(loc).surface(); if (surface == nullptr) { return {}; } TreeObjectFlags mustNotTreeFlags = TreeObjectFlags::none; if (!unk) { mustNotTreeFlags |= TreeObjectFlags::unk1; } TreeObjectFlags mustTreeFlags = TreeObjectFlags::none; if (surface->baseZ() - 4 > Scenario::getCurrentSnowLine()) { mustTreeFlags |= TreeObjectFlags::hasSnowVariation; } if (surface->baseZ() >= 68) { mustTreeFlags |= TreeObjectFlags::highAltitude; } if (surface->baseZ() <= 48) { mustTreeFlags |= TreeObjectFlags::lowAltitude; } auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); mustNotTreeFlags |= TreeObjectFlags::droughtResistant; if (landObj->hasFlags(LandObjectFlags::isDesert)) { mustTreeFlags |= TreeObjectFlags::droughtResistant; mustNotTreeFlags &= ~TreeObjectFlags::droughtResistant; } if (landObj->hasFlags(LandObjectFlags::noTrees)) { return {}; } mustNotTreeFlags |= TreeObjectFlags::requiresWater; const uint16_t numSameTypeSurfaces = TileManager::countSurroundingWaterTiles(World::toWorldSpace(loc)); if (numSameTypeSurfaces >= 8) { mustNotTreeFlags &= ~TreeObjectFlags::requiresWater; } std::vector<uint8_t> selectableTrees; for (uint8_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::tree); ++i) { auto* treeObj = ObjectManager::get<TreeObject>(i); if (treeObj == nullptr) { continue; } if (treeObj->hasFlags(mustNotTreeFlags)) { continue; } if ((treeObj->flags & mustTreeFlags) != mustTreeFlags) { continue; } selectableTrees.push_back(i); } if (selectableTrees.empty()) { return {}; } auto& rng = gPrng1(); const auto randVal = rng.randNext(); const auto selected = ((randVal & 0xFFFF) * selectableTrees.size()) / 65536; return { selectableTrees[selected] }; } bool placeRandomTree(const World::Pos2& pos, std::optional<uint8_t> treeType) { GameCommands::TreePlacementArgs args; args.quadrant = World::getQuadrantFromPos(pos); args.pos = World::Pos2(pos.x & 0xFFE0, pos.y & 0xFFE0); // Note: this is not the same as the randomDirection above as it is the trees rotation args.rotation = gPrng1().randNext(3); args.colour = Colour::black; // If not set by the caller then a random tree type is selected based on the surface type std::optional<uint8_t> randTreeType = treeType; if (!randTreeType.has_value()) { randTreeType = getRandomTreeTypeFromSurface(World::toTileSpace(args.pos), false); // It is possible that there are no valid tree types for the surface if (!randTreeType.has_value()) { return false; } } args.type = *randTreeType; args.buildImmediately = true; args.requiresFullClearance = true; // First query if we can place a tree at this location; skip if we can't. auto queryRes = doCommand(args, 0); if (queryRes == GameCommands::FAILURE) { return false; } // Actually place the tree doCommand(args, GameCommands::Flags::apply); return true; } // 0x004BDC67 (when treeType is nullopt) & 0x004BDDC6 (when treeType is set) bool placeTreeCluster(const World::TilePos2& centreLoc, const uint16_t range, const uint16_t density, const std::optional<uint8_t> treeType) { const auto numPlacements = (range * range * density) / 8192; uint16_t numErrors = 0; for (auto i = 0; i < numPlacements; ++i) { // Choose a random offset in a circle auto& rng = gPrng1(); auto randomMagnitude = rng.randNext(std::numeric_limits<uint16_t>::max()) * range / 65536; auto randomDirection = rng.randNext(Math::Trigonometry::kDirectionPrecisionHigh - 1); World::Pos2 randomOffset( Math::Trigonometry::integerSinePrecisionHigh(randomDirection, randomMagnitude), Math::Trigonometry::integerCosinePrecisionHigh(randomDirection, randomMagnitude)); if (!placeRandomTree(randomOffset + World::toWorldSpace(centreLoc), treeType)) { numErrors++; } } // Have we placed any trees? return (numErrors < numPlacements); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Tree.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> #include <optional> namespace OpenLoco::World { std::optional<uint8_t> getRandomTreeTypeFromSurface(const World::TilePos2& loc, bool unk); bool placeRandomTree(const World::Pos2& pos, std::optional<uint8_t> treeType); bool placeTreeCluster(const World::TilePos2& centreLoc, const uint16_t range, const uint16_t density, const std::optional<uint8_t> treeType); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TreeElement.cpp ```cpp #include "TreeElement.h" #include "GameCommands/Terraform/CreateTree.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "Random.h" #include "RoadElement.h" #include "Scenario.h" #include "SceneManager.h" #include "SurfaceElement.h" #include "TileClearance.h" #include "TileManager.h" #include "TrackElement.h" #include "Tree.h" #include "ViewportManager.h" #include "World/IndustryManager.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::World { static constexpr std::array<uint8_t, 6> kSeasonDeathSequence = { 1, 4, 3, 0, 5, 0xFFU }; // TODO: Deduplicate copied from PaintTree constexpr std::array<World::Pos2, 4> kTreeQuadrantOffset = { World::Pos2{ 7, 7 }, World::Pos2{ 7, 23 }, World::Pos2{ 23, 23 }, World::Pos2{ 23, 7 }, }; // 0x004BDA17 static TileClearance::ClearFuncResult clearFunction(World::TileElement& el, bool& noTrees) { if (el.isAiAllocated() || el.isGhost()) { return TileClearance::ClearFuncResult::noCollision; } switch (el.type()) { case ElementType::tree: case ElementType::building: case ElementType::industry: break; case ElementType::road: { auto* elRoad = el.as<RoadElement>(); if (elRoad != nullptr) { if (elRoad->hasBridge()) { noTrees = true; } } break; } case ElementType::track: { auto* elTrack = el.as<TrackElement>(); if (elTrack != nullptr) { if (elTrack->hasBridge()) { noTrees = true; } } break; } case ElementType::signal: case ElementType::station: case ElementType::surface: case ElementType::wall: noTrees = true; break; } return TileClearance::ClearFuncResult::noCollision; } // 0x004BD64A static bool hasObstructionsTooNear(World::Pos2 loc, uint8_t quadrant, uint8_t baseZ, uint8_t clearZ) { const auto topLeft = loc + World::kOffsets[quadrant] / 2 - World::Pos2{ 16, 16 }; auto pos = topLeft; bool noTrees = false; for (auto i = 0; i < 3; ++i) { for (auto j = 0; j < 3; ++j) { auto checkPos = pos; QuarterTile qt(0, 0); if (pos.x & 0x1F) { checkPos.x &= ~0x1F; qt = World::QuarterTile(1U << 1, 0b1111); if (pos.y & 0x1F) { checkPos.y &= ~0x1F; qt = World::QuarterTile(1U << 0, 0b1111); } } else { qt = World::QuarterTile(1U << 2, 0b1111); if (pos.y & 0x1F) { checkPos.y &= ~0x1F; qt = World::QuarterTile(1U << 3, 0b1111); } } auto clearFunc = [&noTrees](World::TileElement& el) -> TileClearance::ClearFuncResult { return clearFunction(el, noTrees); }; TileClearance::applyClearAtStandardHeight(checkPos, baseZ, clearZ, qt, clearFunc); pos.x += 16; } pos.x = topLeft.x; pos.y += 16; } return noTrees; } static void killTree(TreeElement& elTree) { if (!SceneManager::isEditorMode()) { elTree.setIsDying(true); } } static void invalidateTree(TreeElement& elTree, const World::Pos2 loc) { Ui::ViewportManager::invalidate(loc, elTree.baseHeight(), elTree.clearHeight(), ZoomLevel::eighth, 56); } // 0x004BD52B bool updateTreeElement(TreeElement& elTree, const World::Pos2 loc) { if (elTree.unk7l() != 7) { elTree.setUnk7l(elTree.unk7l() + 1); invalidateTree(elTree, loc); return true; } auto* treeObj = ObjectManager::get<TreeObject>(elTree.treeObjectId()); if (elTree.isDying()) { const auto unk = kSeasonDeathSequence[elTree.season()]; if (unk == 0xFFU) { invalidateTree(elTree, loc); TileManager::removeElement(reinterpret_cast<TileElement&>(elTree)); return false; } else { elTree.setSeason(unk); elTree.setUnk7l(0); invalidateTree(elTree, loc); return true; } } if (!SceneManager::isEditorMode()) { elTree.setUnk5h(elTree.unk5h() + 1); if (elTree.unk5h() != 0) { return true; } } const auto isBelowSnowLine = elTree.baseZ() - 4 <= Scenario::getCurrentSnowLine(); if (isBelowSnowLine) { if (elTree.hasSnow()) { elTree.setSnow(false); invalidateTree(elTree, loc); } } else { if (treeObj->hasFlags(TreeObjectFlags::hasSnowVariation)) { if (!elTree.hasSnow()) { elTree.setSnow(true); invalidateTree(elTree, loc); } } else { killTree(elTree); return true; } } const auto& elSurface = *TileManager::get(loc).surface(); if (elSurface.isIndustrial()) { auto* industry = IndustryManager::get(elSurface.industryId()); auto* industryObj = ObjectManager::get<IndustryObject>(industry->objectId); if (industryObj->hasFlags(IndustryObjectFlags::killsTrees)) { killTree(elTree); return true; } } if (elTree.season() != enumValue(Scenario::getCurrentSeason())) { elTree.setSeason((elTree.season() + 1) & 0x3); elTree.setUnk7l(0); invalidateTree(elTree, loc); return true; } const auto newGrowth = elTree.growth() + 1; if (newGrowth < treeObj->growth) { if (SceneManager::isEditorMode()) { return true; } const auto oldClearZ = elTree.clearZ(); elTree.setClearZ(elTree.baseZ()); auto length = (treeObj->height - treeObj->initialHeight) * (newGrowth + 1); const auto divisor = treeObj->growth - 1; if (divisor != 0) { length /= divisor; } const World::SmallZ newHeight = (treeObj->initialHeight + length) / kSmallZStep; const auto newClearZ = elTree.baseZ() + newHeight; const auto occupiedQuad = 1U << ((elTree.quadrant() + 2) & 0x3); const auto qt = World::QuarterTile(occupiedQuad, 0b1111); const auto canConstruct = TileClearance::canConstructAt(loc, elTree.baseZ(), newClearZ, qt); if (!canConstruct) { elTree.setClearZ(oldClearZ); killTree(elTree); return true; } elTree.setClearZ(newClearZ); elTree.setGrowth(newGrowth); elTree.setUnk5h(0); invalidateTree(elTree, loc); return true; } if (treeObj->var_05 > 34) { bool hasObstruction = hasObstructionsTooNear(loc, elTree.quadrant(), elTree.baseZ(), elTree.clearZ()); if (hasObstruction) { killTree(elTree); return true; } } if (SceneManager::isEditorMode()) { return true; } auto& prng = gPrng1(); const auto rand = prng.randNext(); const auto randDecisions = rand & 0x3F; if (randDecisions < 52) { return true; } else if (randDecisions < 58) { World::Pos2 randOffset{}; const auto rand2 = prng.randNext(); const auto offsetDistance = randDecisions == 57 ? 31 : 7; randOffset.x = ((rand2 >> 16) & (offsetDistance * kTileSize)) - (offsetDistance / 2 * kTileSize); randOffset.y = ((rand2 & 0xFFFFU) & (offsetDistance * kTileSize)) - (offsetDistance / 2 * kTileSize); if (Scenario::getCurrentSeason() == Scenario::Season::winter) { return true; } const auto newTreePos = loc + randOffset; if (!validCoords(newTreePos)) { return true; } auto newTreeObjId = elTree.treeObjectId(); if (!(rand & 0x0F00'0000)) { const auto randTreeObjId = getRandomTreeTypeFromSurface(toTileSpace(newTreePos), true); if (!randTreeObjId.has_value()) { return true; } newTreeObjId = randTreeObjId.value(); } auto* newTreeObj = ObjectManager::get<TreeObject>(newTreeObjId); const auto newQuadrant = (rand >> 5) & 0x3; if (newTreeObj->var_05 > 34) { const auto newTreeQuadPos = newTreePos + kTreeQuadrantOffset[newQuadrant] - World::Pos2{ 1, 1 }; const auto heights = TileManager::getHeight(newTreeQuadPos); const auto baseZ = heights.landHeight / World::kSmallZStep; const auto clearZ = newTreeObj->height / World::kSmallZStep + baseZ; bool hasObstruction = hasObstructionsTooNear(newTreePos, newQuadrant, baseZ, clearZ); if (hasObstruction) { return true; } } GameCommands::TreePlacementArgs args; args.pos = newTreePos; args.quadrant = newQuadrant; args.rotation = (rand >> 16) & 0x3; const auto randNumRotations = (rand >> 19) & 0x1F; auto randColoursRot = std::rotr(newTreeObj->colours, randNumRotations); const auto randColour = Numerics::bitScanForward(randColoursRot); args.colour = randColour == -1 ? Colour::black : static_cast<Colour>((randColour + randNumRotations) & 0x1F); args.buildImmediately = false; args.requiresFullClearance = true; args.type = newTreeObjId; GameCommands::doCommand(args, GameCommands::Flags::apply); return false; } else { if (Scenario::getCurrentSeason() == Scenario::Season::autumn || Scenario::getCurrentSeason() == Scenario::Season::winter) { killTree(elTree); return true; } return true; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/TreeElement.h ```h #pragma once #include "TileElementBase.h" namespace OpenLoco::World { #pragma pack(push, 1) struct TreeElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::tree; private: uint8_t _4; uint8_t _5; uint8_t _6; uint8_t _7; public: uint8_t treeObjectId() const { return _4; } // _4 void setTreeObjectId(uint8_t type) { _4 = type; } uint8_t rotation() const { return _type & 0x03; } void setRotation(uint8_t rotation) { _type &= ~0x3; _type |= rotation & 0x3; } uint8_t quadrant() const { return (_type >> 6) & 0x03; } // _0_C0 void setQuadrant(uint8_t quad) { _type &= ~0xC0; _type |= (quad & 0x3) << 6; } uint8_t growth() const { return _5 & 0xF; } void setGrowth(uint8_t unk) { _5 &= ~0xF; _5 |= unk & 0xF; } uint8_t unk5h() const { return (_5 >> 4) & 0xF; } void setUnk5h(uint8_t unk) { _5 &= ~0xF0; _5 |= (unk & 0xF) << 4; } Colour colour() const { return static_cast<Colour>(_6 & 0x1F); } //_6l void setColour(Colour colour) { _6 &= ~0x1F; _6 |= enumValue(colour) & 0x1F; } bool hasSnow() const { return _6 & 0x40; } //_6_40 void setSnow(bool hasSnow) { _6 &= ~0x40; _6 |= hasSnow ? 0x40 : 0; } bool isDying() const { return _6 & 0x80; }; void setIsDying(bool unk) { _6 &= ~0x80; _6 |= unk ? 0x80 : 0; } uint8_t unk7l() const { return _7 & 0x7; } void setUnk7l(uint8_t unk) { _7 &= ~0x7; _7 |= unk & 0x7; } uint8_t season() const { return (_7 >> 3) & 0x7; } // Not strictly a season its a super set of season void setSeason(uint8_t season) { _7 &= ~0xF8; _7 |= (season & 0x1F) << 3; // unsure of & 0x1F } }; #pragma pack(pop) static_assert(sizeof(TreeElement) == kTileElementSize); bool updateTreeElement(TreeElement& elTree, const World::Pos2 loc); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/WallElement.h ```h #pragma once #include "Graphics/Colour.h" #include "TileElementBase.h" #include <OpenLoco/Core/EnumFlags.hpp> namespace OpenLoco::World { enum class EdgeSlope : uint8_t { none = 0U, upwards = 1U << 0, downwards = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(EdgeSlope); #pragma pack(push, 1) struct WallElement : public TileElementBase { static constexpr ElementType kElementType = ElementType::wall; private: uint8_t _4; uint8_t _5; uint8_t _6; uint8_t _7; public: uint8_t wallObjectId() const { return _4; } // _4 void setWallObjectId(uint8_t id) { _4 = id; } uint8_t rotation() const { return _type & 0x3; } // _0 void setRotation(uint8_t rotation) { _type &= ~0x3; _type |= (rotation & 0x3); } EdgeSlope getSlopeFlags() const { return static_cast<EdgeSlope>((_type & 0xC0) >> 6); } void setSlopeFlags(EdgeSlope slopeFlags) { _type &= ~0xC0; _type |= (enumValue(slopeFlags) << 6) & 0xC0; } void setPrimaryColour(Colour colour) { _6 = (_6 & 0xE0) | (enumValue(colour) & 0x1F); } Colour getPrimaryColour() const { return Colour(_6 & 0x1F); } void setSecondaryColour(Colour colour) { _6 &= 0x1F; _6 |= (enumValue(colour) & 0x7) << 5; _flags &= ~0x60; // Reuse flags 5 and 6 for storing bits of the secondary colour _flags |= (enumValue(colour) & 0x18) << 2; } Colour getSecondaryColour() const { return Colour(((_6 >> 5) & 0x7) | ((_flags >> 2) & 0x18)); } void setTertiaryColour(Colour colour) { _5 = enumValue(colour); } Colour getTertiaryColour() const { return Colour(_5); } }; #pragma pack(pop) static_assert(sizeof(WallElement) == kTileElementSize); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Wave.h ```h #pragma once #include "Location.hpp" #include <OpenLoco/Engine/World.hpp> namespace OpenLoco::World { #pragma pack(push, 1) struct Wave { World::Pos2 loc; // 0x00 uint16_t frame; // 0x04 bool empty() const { return loc.x == Location::null; } }; #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/WaveManager.cpp ```cpp #include "WaveManager.h" #include "Engine/Limits.h" #include "Game.h" #include "GameState.h" #include "GameStateFlags.h" #include "Random.h" #include "ScenarioManager.h" #include "SurfaceElement.h" #include "TileManager.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "Wave.h" #include <OpenLoco/Core/LocoFixedVector.hpp> #include <OpenLoco/Core/Prng.h> #include <OpenLoco/Interop/Interop.hpp> namespace OpenLoco::World::WaveManager { using namespace OpenLoco::Interop; using namespace OpenLoco::Ui; const static Pos2 _offsets[4] = { Pos2(+32, 0), Pos2(-32, 0), Pos2(0, +32), Pos2(0, -32), }; static auto& rawWaves() { return getGameState().waves; } static FixedVector<Wave, Limits::kMaxWaves> waves() { return FixedVector(rawWaves()); } // 0x0046956E void createWave(SurfaceElement& surface, const World::Pos2& pos) { const auto waveIndex = getWaveIndex(World::toTileSpace(pos)); auto& wave = rawWaves()[waveIndex]; if (!wave.empty()) { return; } auto vpPoint = gameToScreen(Pos3(pos.x + 16, pos.y + 16, surface.waterHeight()), WindowManager::getCurrentRotation()); auto w = WindowManager::findWindowShowing(vpPoint); if (w == nullptr) { return; } uint16_t dx2 = gPrng2().randNext() & 0xFFFF; if (dx2 > 0x1745) { return; } // Check whether surrounding tiles are water for (const auto& offset : _offsets) { auto searchLoc = pos + offset; if (!World::validCoords(searchLoc)) { return; } const auto tile = TileManager::get(searchLoc); if (tile.isNull()) { return; } const auto* nearbySurface = tile.surface(); if (nearbySurface == nullptr) { return; } if (nearbySurface->water() == 0) { return; } } wave.loc = pos; wave.frame = 0; surface.setFlag6(true); ViewportManager::invalidate(pos, surface.waterHeight(), surface.waterHeight(), ZoomLevel::full); } const Wave& getWave(const uint8_t waveIndex) { return rawWaves()[waveIndex]; } // 0x004C56F6 void update() { if (!Game::hasFlags(GameStateFlags::tileManagerLoaded) || (ScenarioManager::getScenarioTicks() & 0x3)) { return; } for (auto& wave : waves()) { auto tile = TileManager::get(wave.loc); auto* surface = tile.surface(); if (surface == nullptr) { wave.loc.x = Location::null; continue; } ViewportManager::invalidate(wave.loc, surface->waterHeight(), surface->waterHeight(), ZoomLevel::full); if (surface->water()) { wave.frame++; if (wave.frame < 16) { continue; } } // Wave removed if 16 frames or no water wave.loc.x = Location::null; surface->setFlag6(false); } } // 0x004C4BC0 void reset() { for (auto& wave : rawWaves()) { wave.loc.x = Location::null; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/WaveManager.h ```h #pragma once #include "Tile.h" namespace OpenLoco::World { struct Wave; } namespace OpenLoco::World::WaveManager { void update(); void reset(); void createWave(SurfaceElement& surface, const World::Pos2& pos); constexpr uint8_t getWaveIndex(const World::TilePos2& pos) { return (pos.x & 0x7) | ((pos.y & 0x7) << 3); } const Wave& getWave(const uint8_t waveIndex); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/HeightMap.cpp ```cpp #include "HeightMap.h" #include <algorithm> namespace OpenLoco::World::MapGenerator { constexpr uint8_t kHeightmapMarkedFlag = (1 << 7); void HeightMap::resetMarkerFlags() { std::for_each_n(data(), size(), [](uint8_t& value) { value &= ~kHeightmapMarkedFlag; }); } uint8_t HeightMap::getHeight(TilePos2 pos) const { return (*this)[pos] & ~kHeightmapMarkedFlag; } bool HeightMap::isMarkerSet(TilePos2 pos) const { return (*this)[pos] & kHeightmapMarkedFlag; } void HeightMap::setMarker(TilePos2 pos) { (*this)[pos] |= kHeightmapMarkedFlag; } void HeightMap::unsetMarker(TilePos2 pos) { (*this)[pos] &= ~kHeightmapMarkedFlag; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/HeightMap.h ```h #pragma once #include <OpenLoco/Engine/World.hpp> #include <cassert> #include <cstddef> #include <cstdint> #include <vector> namespace OpenLoco::World::MapGenerator { class HeightMap { private: std::vector<uint8_t> _height; public: const uint16_t width; const uint16_t height; HeightMap(int32_t width, int32_t height) : _height(width * height) , width(width) , height(height) { } uint8_t& operator[](TilePos2 pos) { assert(pos.x >= 0 || pos.y >= 0 || pos.x < width || pos.y < height); return _height[pos.y * width + pos.x]; } const uint8_t& operator[](TilePos2 pos) const { assert(pos.x >= 0 || pos.y >= 0 || pos.x < width || pos.y < height); return _height[pos.y * width + pos.x]; } uint8_t* data() { return _height.data(); } const uint8_t* data() const { return _height.data(); } size_t size() const { return _height.size(); } uint8_t getHeight(TilePos2 pos) const; void resetMarkerFlags(); bool isMarkerSet(TilePos2 pos) const; void setMarker(TilePos2 pos); void unsetMarker(TilePos2 pos); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/HeightMapRange.h ```h #pragma once #include "HeightMap.h" #include <cstdint> #include <vector> namespace OpenLoco::World::MapGenerator { class HeightMapRange { private: HeightMap& _heightMap; int32_t const _minX; int32_t const _minY; public: int32_t const width; int32_t const height; HeightMapRange(HeightMap& heightMap) : _heightMap(heightMap) , _minX(0) , _minY(0) , width(heightMap.width) , height(heightMap.height) { } HeightMapRange(HeightMap& heightMap, int32_t minX, int32_t minY, int32_t width, int32_t height) : _heightMap(heightMap) , _minX(minX) , _minY(minY) , width(width) , height(height) { } uint8_t& operator[](TilePos2 pos) { pos.x += _minX; pos.y += _minY; return _heightMap[pos]; } const uint8_t& operator[](TilePos2 pos) const { pos.x += _minX; pos.y += _minY; return _heightMap[pos]; } HeightMapRange slice(int32_t l, int32_t t, int32_t w, int32_t h) { return HeightMapRange(_heightMap, _minX + l, _minY + t, w, h); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/MapGenerator.cpp ```cpp #include "MapGenerator.h" #include "../SurfaceElement.h" #include "../Tile.h" #include "../TileLoop.hpp" #include "../TileManager.h" #include "../Tree.h" #include "../TreeElement.h" #include "Date.h" #include "GameCommands/Buildings/CreateBuilding.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Town/CreateTown.h" #include "GameState.h" #include "Input.h" #include "Localisation/StringIds.h" #include "Objects/BuildingObject.h" #include "Objects/HillShapesObject.h" #include "Objects/IndustryObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "OriginalTerrainGenerator.h" #include "PngTerrainGenerator.h" #include "Random.h" #include "Scenario.h" #include "ScenarioOptions.h" #include "SimplexTerrainGenerator.h" #include "Ui/ProgressBar.h" #include "Ui/WindowManager.h" #include "World/TownManager.h" #include <cassert> #include <cstdint> #include <random> #include <vector> using namespace OpenLoco::World; using namespace OpenLoco::Ui; using namespace OpenLoco::S5; using namespace OpenLoco::World::MapGenerator; namespace OpenLoco::World::MapGenerator { static constexpr auto kCliffTerrainHeightDiff = 4; static constexpr auto kMountainTerrainHeight = 26; static fs::path _pngHeightmapPath{}; static void updateProgress(uint8_t value) { Input::processMessagesMini(); Ui::ProgressBar::setProgress(value); } // 0x004624F0 static void generateHeightMap(const Scenario::Options& options, HeightMap& heightMap) { if (options.generator == Scenario::LandGeneratorType::Original) { OriginalTerrainGenerator generator; generator.generate(options, heightMap); } else if (options.generator == Scenario::LandGeneratorType::Simplex) { SimplexTerrainGenerator generator; generator.generate(options, heightMap, std::random_device{}()); } else { PngTerrainGenerator generator; generator.generate(options, _pngHeightmapPath, heightMap); } } static void generateRivers(const Scenario::Options& options, HeightMap& heightMap) { for (auto i = 0; i < options.numRiverbeds; i++) { auto& gs = getGameState(); const auto riverEastWest = gs.rng.randBool(); const auto riverWidth = gs.rng.randNext(options.minRiverWidth, options.maxRiverWidth); const auto riverbedHeight = std::max<uint8_t>(gs.seaLevel > 0 ? gs.seaLevel - 1 : 1, options.minLandHeight); // We'll be varying the bank width as we meander auto riverbankWidth = options.riverbankWidth; auto totalRiverWidth = riverWidth + 2 * riverbankWidth; auto easternBankOffset = riverWidth + riverbankWidth; // Pivot: generate a random X position auto xStartPos = getGameState().rng.randNext(0.15 * heightMap.width, 0.85 * heightMap.width); for (auto yPos = 0; yPos < heightMap.height; yPos++) { for (auto xOffset = 0; xOffset < totalRiverWidth; xOffset++) { auto pos = TilePos2(xStartPos + xOffset, yPos); if (!riverEastWest) { pos = TilePos2(pos.y, pos.x); } if (!validCoords(pos)) { // We might meander back to a valid position later, // so we're only breaking out of the inner loop. break; } if (riverbankWidth > 0 && xOffset < riverbankWidth) { // Western riverbank (high to low) auto bankPos = riverbankWidth - xOffset; auto bankHeight = heightMap[pos] * bankPos / riverbankWidth; heightMap[pos] = std::max<uint8_t>(riverbedHeight, bankHeight); } else if (riverbankWidth > 0 && xOffset > easternBankOffset) { // Eastern riverbank (low to high) auto bankPos = xOffset - easternBankOffset; auto bankHeight = heightMap[pos] * bankPos / riverbankWidth; heightMap[pos] = std::max<uint8_t>(riverbedHeight, bankHeight); } else { // Simply carve out the river heightMap[pos] = riverbedHeight; } } // Let the river meander slightly const auto meanderRate = options.riverMeanderRate; if (meanderRate > 0 && yPos % 4 == 0) { const auto halfMeanderRate = meanderRate / 2; int8_t meanderOffset = getGameState().rng.randNext(0, meanderRate) - halfMeanderRate; xStartPos += meanderOffset; // Adjust bank width slightly as well if (options.riverbankWidth > 0 && halfMeanderRate != 0) { riverbankWidth += meanderOffset / halfMeanderRate; easternBankOffset += meanderOffset / halfMeanderRate; totalRiverWidth += meanderOffset / halfMeanderRate * 2; } } } } } // 0x004625D0 static void generateLand(HeightMap& heightMap) { for (auto& pos : World::getDrawableTileRange()) { const MicroZ q00 = heightMap[pos + TilePos2{ -1, -1 }]; const MicroZ q01 = heightMap[pos + TilePos2{ 0, -1 }]; const MicroZ q10 = heightMap[pos + TilePos2{ -1, 0 }]; const MicroZ q11 = heightMap[pos + TilePos2{ 0, 0 }]; const auto tile = TileManager::get(pos); auto* surfaceElement = tile.surface(); if (surfaceElement == nullptr) { continue; } const MicroZ baseHeight = std::min({ q00, q01, q10, q11 }); surfaceElement->setBaseZ(baseHeight * kMicroToSmallZStep); uint8_t currentSlope = SurfaceSlope::flat; // First, figure out basic corner style if (q00 > baseHeight) { currentSlope |= SurfaceSlope::CornerUp::south; } if (q01 > baseHeight) { currentSlope |= SurfaceSlope::CornerUp::east; } if (q10 > baseHeight) { currentSlope |= SurfaceSlope::CornerUp::west; } if (q11 > baseHeight) { currentSlope |= SurfaceSlope::CornerUp::north; } // Now, deduce if we should go for double height // clang-format off if ((currentSlope == SurfaceSlope::CornerDown::north && q00 - baseHeight >= 2) || (currentSlope == SurfaceSlope::CornerDown::west && q01 - baseHeight >= 2) || (currentSlope == SurfaceSlope::CornerDown::east && q10 - baseHeight >= 2) || (currentSlope == SurfaceSlope::CornerDown::south && q11 - baseHeight >= 2)) { currentSlope |= SurfaceSlope::doubleHeight; } // clang-format on surfaceElement->setSlope(currentSlope); auto clearZ = surfaceElement->baseZ(); if (surfaceElement->slopeCorners()) { clearZ += kSmallZStep; } if (surfaceElement->isSlopeDoubleHeight()) { clearZ += kSmallZStep; } surfaceElement->setClearZ(clearZ); } } // 0x004C4BD7 static void generateWater([[maybe_unused]] HeightMap& heightMap) { auto seaLevel = getGameState().seaLevel; for (auto& pos : World::getDrawableTileRange()) { auto tile = TileManager::get(pos); auto* surface = tile.surface(); if (surface != nullptr && surface->baseZ() < (seaLevel << 2)) { surface->setWater(seaLevel); } } } static std::optional<uint8_t> getEverywhereSurfaceStyle() { for (uint8_t landObjectIdx = 0; landObjectIdx < ObjectManager::getMaxObjects(ObjectType::land); ++landObjectIdx) { auto* landObj = ObjectManager::get<LandObject>(landObjectIdx); if (landObj == nullptr) { continue; } if (Scenario::getOptions().landDistributionPatterns[landObjectIdx] == Scenario::LandDistributionPattern::everywhere) { return landObjectIdx; } } if (getGameState().lastLandOption != 0xFF) { return getGameState().lastLandOption; } return std::nullopt; } // 0x00469FC8 std::optional<uint8_t> getRandomTerrainVariation(const SurfaceElement& surface) { if (surface.water()) { return std::nullopt; } if (surface.isIndustrial()) { return std::nullopt; } auto* landObj = ObjectManager::get<LandObject>(surface.terrain()); if (landObj == nullptr) { return std::nullopt; } if (landObj->numVariations == 0 || surface.slope()) { return 0; } // TODO: split into two randNext calls uint16_t randVal = gPrng1().randNext(); if (landObj->variationLikelihood <= (randVal >> 8)) { return 0; } return ((randVal & 0xFF) * landObj->numVariations) >> 8; } static void applySurfaceStyleToMarkedTiles(HeightMap& heightMap, uint8_t surfaceStyle, bool requireMark) { for (auto& pos : World::getDrawableTileRange()) { const bool tileIsMarked = heightMap.isMarkerSet({ pos.x, pos.y }); if (requireMark != tileIsMarked) { continue; } auto tile = TileManager::get(pos); auto* surface = tile.surface(); if (surface == nullptr) { continue; } surface->setTerrain(surfaceStyle); auto res = getRandomTerrainVariation(*surface); if (res) { surface->setVariation(*res); } } } // 0x0046A379 static void generateTerrainFarFromWater(HeightMap& heightMap, uint8_t surfaceStyle) { heightMap.resetMarkerFlags(); // Mark tiles near water auto seaLevel = getGameState().seaLevel; for (auto pos : getWorldRange()) { auto height = heightMap.getHeight({ pos.x, pos.y }); if (height > seaLevel) { continue; } for (auto lookaheadPos : getClampedRange(pos - TilePos2(25, 25), pos + TilePos2(25, 25))) { heightMap.setMarker({ lookaheadPos.x, lookaheadPos.y }); } } // Apply surface style to tiles that have *not* been marked applySurfaceStyleToMarkedTiles(heightMap, surfaceStyle, false); } // 0x0046A439 static void generateTerrainNearWater(HeightMap& heightMap, uint8_t surfaceStyle) { heightMap.resetMarkerFlags(); // Mark tiles near water auto seaLevel = getGameState().seaLevel; for (auto pos : getWorldRange()) { auto height = heightMap.getHeight({ pos.x, pos.y }); if (height < seaLevel) { continue; } for (auto lookaheadPos : getClampedRange(pos - TilePos2(25, 25), pos + TilePos2(25, 25))) { heightMap.setMarker({ lookaheadPos.x, lookaheadPos.y }); } } // Apply surface style to tiles that have been marked applySurfaceStyleToMarkedTiles(heightMap, surfaceStyle, true); } // 0x0046A5B3 static void generateTerrainOnMountains(HeightMap& heightMap, uint8_t surfaceStyle) { heightMap.resetMarkerFlags(); // Mark tiles above mountain level for (auto pos : getWorldRange()) { // NB: this is an inclusive check to match vanilla auto height = heightMap.getHeight({ pos.x, pos.y }); if (height <= kMountainTerrainHeight) { continue; } for (auto lookaheadPos : getClampedRange(pos - TilePos2(12, 12), pos + TilePos2(12, 12))) { heightMap.setMarker({ lookaheadPos.x, lookaheadPos.y }); } } // Apply surface style to tiles that have been marked applySurfaceStyleToMarkedTiles(heightMap, surfaceStyle, true); } // 0x0046A4F9 static void generateTerrainFarFromMountains(HeightMap& heightMap, uint8_t surfaceStyle) { heightMap.resetMarkerFlags(); // Mark tiles above mountain level for (auto pos : getWorldRange()) { // NB: this is an exclusive check to match vanilla auto height = heightMap.getHeight({ pos.x, pos.y }); if (height < kMountainTerrainHeight) { continue; } for (auto lookaheadPos : getClampedRange(pos - TilePos2(25, 25), pos + TilePos2(25, 25))) { heightMap.setMarker({ lookaheadPos.x, lookaheadPos.y }); } } // Apply surface style to tiles that have *not* been marked applySurfaceStyleToMarkedTiles(heightMap, surfaceStyle, false); } // 0x0046A0D8, 0x0046A227 static void generateTerrainInRandomAreas(uint8_t surfaceStyle, uint16_t minTiles, uint16_t maxTiles) { auto numberOfAreas = getGameState().rng.randNext(80, 143); for (auto i = 0; i < numberOfAreas; i++) { // TODO: could probably simplify / replace with two randNext(lo, hi) calls auto randPos = getGameState().rng.randNext(); auto xPos = ((randPos & 0xFFFF) * kMapColumns) >> 16; auto yPos = ((randPos >> 16) * kMapRows) >> 16; auto pos = World::toWorldSpace(TilePos2(xPos, yPos)); auto numberOfTiles = getGameState().rng.randNext(minTiles, maxTiles - 1); for (auto j = 0; j < numberOfTiles; j++) { if (validCoords(pos)) { auto tile = TileManager::get(pos); auto surface = tile.surface(); if (surface != nullptr) { auto height = TileManager::getSurfaceCornerHeight(*surface) / kMicroToSmallZStep; if (height > getGameState().seaLevel) { surface->setTerrain(surfaceStyle); auto variation = getRandomTerrainVariation(*surface); if (variation.has_value()) { surface->setVariation(variation.value()); } } } } auto randRotation = getGameState().rng.randNext(3); auto offset = kRotationOffset[randRotation]; pos += offset; } } } // 0x0046A0D8 static void generateTerrainInSmallRandomAreas([[maybe_unused]] HeightMap& heightMap, uint8_t surfaceStyle) { generateTerrainInRandomAreas(surfaceStyle, 24, 56); } // 0x0046A227 static void generateTerrainInLargeRandomAreas([[maybe_unused]] HeightMap& heightMap, uint8_t surfaceStyle) { generateTerrainInRandomAreas(surfaceStyle, 128, 388); } // 0x0046A66D static void generateTerrainAroundCliffs(HeightMap& heightMap, uint8_t surfaceStyle) { heightMap.resetMarkerFlags(); // Mark tiles with sudden height changes in the next row for (auto pos : getDrawableTileRange()) { auto heightA = heightMap.getHeight({ pos + TilePos2{ 0, 1 } }); auto heightB = heightMap.getHeight({ pos + TilePos2{ 0, 1 } }); // Find no cliff between A and B? if (std::abs(heightB - heightA) < kCliffTerrainHeightDiff) { auto heightC = heightMap.getHeight({ pos + TilePos2{ 0, 1 } }); auto heightD = heightMap.getHeight({ pos + TilePos2{ 0, 1 } }); // Find no cliff between C and D? if (std::abs(heightD - heightC) < kCliffTerrainHeightDiff) { continue; } } // Found a cliff around this point, so mark the points around it for (auto lookaheadPos : getClampedRange(pos - TilePos2(6, 6), pos + TilePos2(6, 6))) { heightMap.setMarker({ lookaheadPos.x, lookaheadPos.y }); } } // Apply surface style to tiles that have been marked applySurfaceStyleToMarkedTiles(heightMap, surfaceStyle, true); } static void generateTerrainNull([[maybe_unused]] HeightMap& heightMap, [[maybe_unused]] uint8_t surfaceStyle) {} using GenerateTerrainFunc = void (*)(HeightMap&, uint8_t); static const GenerateTerrainFunc _generateFuncs[] = { generateTerrainNull, // LandDistributionPattern::everywhere This is null as it is a special function performed separately generateTerrainNull, // LandDistributionPattern::nowhere generateTerrainFarFromWater, // LandDistributionPattern::farFromWater generateTerrainNearWater, // LandDistributionPattern::nearWater generateTerrainOnMountains, // LandDistributionPattern::onMountains generateTerrainFarFromMountains, // LandDistributionPattern::farFromMountains generateTerrainInSmallRandomAreas, // LandDistributionPattern::inSmallRandomAreas generateTerrainInLargeRandomAreas, // LandDistributionPattern::inLargeRandomAreas generateTerrainAroundCliffs // LandDistributionPattern::aroundCliffs }; // 0x0046A021 static void generateTerrain(HeightMap& heightMap) { const auto style = getEverywhereSurfaceStyle(); if (!style.has_value()) { return; } const TilePosRangeView tileLoop = getDrawableTileRange(); for (const auto& tilePos : tileLoop) { auto* surface = World::TileManager::get(tilePos).surface(); if (surface == nullptr) { continue; } surface->setTerrain(*style); surface->setGrowthStage(0); const auto variation = getRandomTerrainVariation(*surface); if (variation.has_value()) { surface->setVariation(*variation); } } constexpr std::array landDistributionPatterns = { Scenario::LandDistributionPattern::farFromWater, Scenario::LandDistributionPattern::nearWater, Scenario::LandDistributionPattern::onMountains, Scenario::LandDistributionPattern::farFromMountains, Scenario::LandDistributionPattern::inSmallRandomAreas, Scenario::LandDistributionPattern::inLargeRandomAreas, Scenario::LandDistributionPattern::aroundCliffs, }; for (auto i = 0U; i < landDistributionPatterns.size(); i++) { updateProgress(55 + 12 * i); for (uint8_t landObjectIdx = 0; landObjectIdx < ObjectManager::getMaxObjects(ObjectType::land); ++landObjectIdx) { const auto* landObj = ObjectManager::get<LandObject>(landObjectIdx); if (landObj == nullptr) { continue; } const auto typePattern = Scenario::getOptions().landDistributionPatterns[landObjectIdx]; const auto distPattern = landDistributionPatterns[i]; if (typePattern != distPattern) { continue; } _generateFuncs[enumValue(distPattern)](heightMap, landObjectIdx); } } } // 0x004611DF static void generateSurfaceVariation() { for (auto& pos : World::getDrawableTileRange()) { auto tile = TileManager::get(pos); auto* surface = tile.surface(); if (surface == nullptr) { continue; } if (!surface->isIndustrial()) { auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); if (landObj->hasFlags(LandObjectFlags::unk0)) { bool setVariation = false; if (surface->water()) { auto waterBaseZ = surface->water() * kMicroToSmallZStep; if (surface->slope()) { waterBaseZ -= 4; } if (waterBaseZ > surface->baseZ()) { if (surface->terrain() != 0) { surface->setGrowthStage(0); setVariation = true; } } } if (!setVariation) { surface->setGrowthStage(landObj->numGrowthStages - 1); } } } auto snowLine = Scenario::getCurrentSnowLine() / kMicroToSmallZStep; MicroZ baseMicroZ = (surface->baseZ() / kMicroToSmallZStep) + 1; auto unk = std::clamp(baseMicroZ - snowLine, 0, 5); surface->setSnowCoverage(unk); } } // 0x004BE0C7 static void updateTreeSeasons() { auto currentSeason = getGameState().currentSeason; for (auto& pos : World::getDrawableTileRange()) { auto tile = TileManager::get(pos); for (auto& el : tile) { auto* treeEl = el.as<TreeElement>(); if (treeEl == nullptr) { continue; } if (treeEl->season() < 4 && !treeEl->isDying()) { treeEl->setSeason(enumValue(currentSeason)); treeEl->setUnk7l(0x7); } break; } } } // 0x004BDA49 static void generateTrees() { const auto& options = Scenario::getOptions(); // Place forests for (auto i = 0; i < options.numberOfForests; ++i) { const auto randRadius = ((gPrng1().randNext(255) * std::max(options.maxForestRadius - options.minForestRadius, 0)) / 255 + options.minForestRadius) * kTileSize; const auto randLoc = World::TilePos2(gPrng1().randNext(kMapRows), gPrng1().randNext(kMapColumns)); const auto randDensity = (gPrng1().randNext(15) * std::max(options.maxForestDensity - options.minForestDensity, 0)) / 15 + options.minForestDensity; placeTreeCluster(randLoc, randRadius, randDensity, std::nullopt); if (TileManager::numFreeElements() < 0x1B000) { break; } } // Place a number of random trees for (auto i = 0; i < options.numberRandomTrees; ++i) { const auto randLoc = World::Pos2(gPrng1().randNext(kMapWidth), gPrng1().randNext(kMapHeight)); placeRandomTree(randLoc, std::nullopt); } // Cull trees that are too high / low uint32_t randMask = gPrng1().randNext(); uint32_t i = 0; std::vector<TileElement*> toBeRemoved; for (auto& loc : getWorldRange()) { auto tile = TileManager::get(loc); for (auto& el : tile) { auto* elTree = el.as<TreeElement>(); if (elTree == nullptr) { continue; } if (elTree->baseHeight() / kMicroToSmallZStep <= options.minAltitudeForTrees) { if (elTree->baseHeight() / kMicroToSmallZStep != options.minAltitudeForTrees || (randMask & (1 << i))) { toBeRemoved.push_back(&el); i++; i %= 32; break; } } if (elTree->baseHeight() / kMicroToSmallZStep >= options.maxAltitudeForTrees) { if (elTree->baseHeight() / kMicroToSmallZStep != options.maxAltitudeForTrees || (randMask & (1 << i))) { toBeRemoved.push_back(&el); i++; i %= 32; break; } } } // Remove in reverse order to prevent pointer invalidation for (auto elIter = std::rbegin(toBeRemoved); elIter != std::rend(toBeRemoved); ++elIter) { TileManager::removeElement(**elIter); } toBeRemoved.clear(); } updateTreeSeasons(); } // 0x00496BBC static void generateTowns() { for (auto i = 0; i < Scenario::getOptions().numberOfTowns; i++) { // NB: vanilla was calling the game command directly; we're using the runner. GameCommands::TownPlacementArgs args{}; args.pos = { -1, -1 }; const auto maxTownSize = Scenario::getOptions().maxTownSize; args.size = maxTownSize > 1 ? getGameState().rng.randNext(1, maxTownSize) : 1; GameCommands::doCommand(args, GameCommands::Flags::apply); } } // 0x004595B7 static bool isCargoProducedAnywhere(uint8_t requiredCargoType) { auto commonBuildingCargoType = IndustryManager::getMostCommonBuildingCargoType(); if (commonBuildingCargoType == requiredCargoType) { return true; } for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::industry); i++) { auto* industryObj = ObjectManager::get<IndustryObject>(i); if (industryObj == nullptr) { continue; } if (getCurrentYear() < industryObj->designedYear || getCurrentYear() >= industryObj->obsoleteYear) { continue; } for (auto producedCargoType : industryObj->producedCargoType) { if (producedCargoType == requiredCargoType) { return true; } } } return false; } // 0x004597FD static void generateIndustries(uint32_t minProgress, uint32_t maxProgress) { auto numIndustriesAvailable = 0; for (auto indObjId = 0U; indObjId < ObjectManager::getMaxObjects(ObjectType::industry); indObjId++) { if (ObjectManager::get<IndustryObject>(indObjId) != nullptr) { numIndustriesAvailable++; } } if (numIndustriesAvailable == 0) { return; } GameCommands::setUpdatingCompanyId(CompanyId::neutral); auto progressTicksPerIndustry = (maxProgress - minProgress) / numIndustriesAvailable; auto currentProgress = minProgress; for (auto indObjId = 0U; indObjId < ObjectManager::getMaxObjects(ObjectType::industry); indObjId++) { auto* industryObj = ObjectManager::get<IndustryObject>(indObjId); if (industryObj == nullptr) { continue; } currentProgress += progressTicksPerIndustry; updateProgress(currentProgress); // Check if industry is available at present if (getCurrentYear() < industryObj->designedYear || getCurrentYear() >= industryObj->obsoleteYear) { continue; } // Check if required cargo is available if (industryObj->requiredCargoType[0] != 0xFF) { auto numCargoSpecified = 0; auto numCargoAvailable = 0; for (auto cargoType : industryObj->requiredCargoType) { if (cargoType == 0xFF) { continue; } numCargoSpecified++; if (isCargoProducedAnywhere(cargoType)) { numCargoAvailable++; } } if (industryObj->hasFlags(IndustryObjectFlags::requiresAllCargo)) { if (numCargoSpecified != numCargoAvailable) { continue; } } else if (numCargoAvailable == 0) { continue; } } const uint8_t numIndustriesFactor = Scenario::getOptions().numberOfIndustries; const auto numIndustriesToCreate = IndustryManager::capOfTypeOfIndustry(indObjId, numIndustriesFactor); for (auto i = 0; i < numIndustriesToCreate; i++) { IndustryManager::createNewIndustry(indObjId, true, 50); } } } template<typename Func> static void generateMiscBuilding(const BuildingObject* buildingObj, const size_t id, Func&& predicate) { uint8_t randomComponent = getGameState().rng.randNext(0, buildingObj->averageNumberOnMap / 2); uint8_t staticComponent = buildingObj->averageNumberOnMap - (buildingObj->averageNumberOnMap / 4); uint8_t amountToBuild = randomComponent + staticComponent; if (amountToBuild == 0) { return; } for (auto i = 0U; i < amountToBuild; i++) { for (auto attemptsLeft = 200; attemptsLeft > 0; attemptsLeft--) { // NB: coordinate selection has been simplified compared to vanilla auto randomX = getGameState().rng.randNext(2, kMapRows - 2); auto randomY = getGameState().rng.randNext(2, kMapColumns - 2); auto tile = TileManager::get(TilePos2(randomX, randomY)); if (!predicate(tile)) { continue; } auto* surface = tile.surface(); if (surface == nullptr) { continue; } auto baseHeight = TileManager::getSurfaceCornerHeight(*surface) * kSmallZStep; auto randomRotation = getGameState().rng.randNext(0, 3); auto randomVariation = getGameState().rng.randNext(0, buildingObj->numVariations - 1); GameCommands::BuildingPlacementArgs args{}; args.pos = Pos3(randomX * kTileSize, randomY * kTileSize, baseHeight); args.rotation = randomRotation; args.type = static_cast<uint8_t>(id); args.variation = randomVariation; args.colour = Colour::black; args.buildImmediately = true; if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { break; } } } } // 0x0042E731 // Example: 'Transmitter' building object static void generateMiscBuildingType0(const BuildingObject* buildingObj, const size_t id) { generateMiscBuilding(buildingObj, id, [](const Tile& tile) { // This kind of object (e.g. a transmitter) only occurs in mountains auto* surface = tile.surface(); return surface->baseZ() >= 100; }); } static World::Pos2 placeBuildingsAlongLine(World::Pos2 origin, uint8_t numTilesBetween, const size_t buildingId, int16_t remainingTilesDistance, uint8_t rotation) { // We'll be placing buildings along the line and return the final location. World::Pos2 targetPos = origin; // 0x0042E945 for (remainingTilesDistance -= numTilesBetween; remainingTilesDistance > 0; remainingTilesDistance -= numTilesBetween) { // 0x0042E956 auto offset = kRotationOffset[rotation] * numTilesBetween; targetPos += offset; if (!drawableCoords(targetPos)) { break; } // 0x0042E98A auto tile = TileManager::get(targetPos); auto* surface = tile.surface(); if (surface == nullptr) { break; } auto height = TileManager::getSurfaceCornerHeight(*surface); GameCommands::BuildingPlacementArgs buildArgs{}; buildArgs.pos = World::Pos3(targetPos, height * World::kSmallZStep); buildArgs.rotation = rotation; buildArgs.type = static_cast<uint8_t>(buildingId); buildArgs.variation = 0; buildArgs.colour = Colour::black; buildArgs.buildImmediately = true; // NB: return is ignored (it doesn't matter if some pylons missing) GameCommands::doCommand(buildArgs, GameCommands::Flags::apply); } return targetPos; } // 0x0042E893 // Example: 'Electricity Pylon' building object // Only used by 'Coal-Fired Power Station' in vanilla static void generateMiscBuildingType1(const BuildingObject* buildingObj, const size_t id) { for (auto& industry : IndustryManager::industries()) { auto* industryObj = ObjectManager::get<IndustryObject>(industry.objectId); if (!industryObj->hasFlags(IndustryObjectFlags::requiresElectricityPylons)) { continue; } auto numTownsLeft = 3; for (auto& town : TownManager::towns()) { // Figure out distance and rotation (angle) between town and industry auto rotationBL = 2; auto xDist = town.x - industry.x; // ax if (xDist < 0) { xDist = -xDist; rotationBL = 0; } auto rotationBH = 1; auto yDist = town.y - industry.y; // dx if (yDist < 0) { yDist = -yDist; rotationBH = 3; } auto manhattanDistance = xDist + yDist; // bp if (manhattanDistance < 800 || manhattanDistance > 2240) { continue; } // Order distances such that the longest edge is in xDist if (yDist > xDist) { std::swap(xDist, yDist); std::swap(rotationBL, rotationBH); } auto origin = World::Pos2(industry.x, industry.y); const auto lineEnd = placeBuildingsAlongLine(origin, buildingObj->averageNumberOnMap, id, xDist / kTileSize, rotationBL); placeBuildingsAlongLine(lineEnd, buildingObj->averageNumberOnMap, id, yDist / kTileSize, rotationBH); // 0x0042E9FF numTownsLeft--; if (!numTownsLeft) { break; } } } } // 0x0042EA29 // Example: 'Lighthouse' building object static void generateMiscBuildingType2(const BuildingObject* buildingObj, const size_t id) { generateMiscBuilding(buildingObj, id, [](const Tile& tile) { // This kind of object (e.g. a lighthouse) needs to be around water return TileManager::countSurroundingWaterTiles(toWorldSpace(tile.pos)) >= 50; }); } // 0x0042EB94 // Example: 'Castle Ruins' building object static void generateMiscBuildingType3(const BuildingObject* buildingObj, const size_t id) { generateMiscBuilding(buildingObj, id, [](const Tile& tile) { auto* surface = tile.surface(); return surface->baseZ() >= 40 && surface->baseZ() <= 92; }); } // 0x0042E6F2 static void generateMiscBuildings() { GameCommands::setUpdatingCompanyId(CompanyId::neutral); for (auto id = 0U; id < ObjectManager::getMaxObjects(ObjectType::building); id++) { auto* buildingObj = ObjectManager::get<BuildingObject>(id); if (buildingObj == nullptr) { continue; } if (!buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { continue; } if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters)) { continue; } static std::array<std::function<void(const BuildingObject*, const size_t)>, 4> generatorFunctions = { generateMiscBuildingType0, generateMiscBuildingType1, generateMiscBuildingType2, generateMiscBuildingType3, }; generatorFunctions[buildingObj->generatorFunction](buildingObj, id); } } // 0x0043C90C void generate(const Scenario::Options& options) { Input::processMessagesMini(); WindowManager::close(WindowType::town); WindowManager::close(WindowType::industry); Ui::ProgressBar::begin(StringIds::generating_landscape); auto rotation = WindowManager::getCurrentRotation(); Scenario::reset(); WindowManager::setCurrentRotation(rotation); updateProgress(5); Scenario::initialiseDate(options.scenarioStartYear); Scenario::initialiseSnowLine(); TileManager::initialise(); updateProgress(10); { HeightMap heightMap(kMapColumns, kMapRows); generateHeightMap(options, heightMap); updateProgress(25); generateRivers(options, heightMap); updateProgress(30); generateLand(heightMap); updateProgress(35); generateWater(heightMap); updateProgress(45); generateTerrain(heightMap); updateProgress(55); } generateSurfaceVariation(); updateProgress(175); generateTrees(); updateProgress(200); generateTowns(); updateProgress(225); generateIndustries(225, 245); updateProgress(245); generateMiscBuildings(); updateProgress(250); generateSurfaceVariation(); updateProgress(255); Scenario::sub_4969E0(0); Scenario::sub_4748D4(); Ui::ProgressBar::end(); } void setPngHeightmapPath(const fs::path& path) { _pngHeightmapPath = path; } fs::path getPngHeightmapPath() { return _pngHeightmapPath; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/MapGenerator.h ```h #pragma once #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/FileSystem.hpp> #include <array> #include <cstdint> #include <optional> namespace OpenLoco::Scenario { struct Options; } namespace OpenLoco::World { struct SurfaceElement; } namespace OpenLoco::World::MapGenerator { enum class TopographyFlags : uint8_t { none = 0U, hasHills = 1U << 0, hasMountains = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(TopographyFlags); // 0x004FD332 static constexpr std::array<TopographyFlags, 10> kTopographyStyleFlags = { TopographyFlags::none, TopographyFlags::none, TopographyFlags::hasHills, TopographyFlags::hasHills, TopographyFlags::hasMountains | TopographyFlags::hasHills, TopographyFlags::hasMountains | TopographyFlags::hasHills, TopographyFlags::hasHills, TopographyFlags::hasMountains | TopographyFlags::hasHills, TopographyFlags::none, TopographyFlags::hasMountains | TopographyFlags::hasHills, }; void generate(const Scenario::Options& options); std::optional<uint8_t> getRandomTerrainVariation(const SurfaceElement& surface); void setPngHeightmapPath(const fs::path& path); fs::path getPngHeightmapPath(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/OriginalTerrainGenerator.cpp ```cpp #include "OriginalTerrainGenerator.h" #include "GameState.h" #include "Graphics/Gfx.h" #include "MapGenerator.h" #include "Objects/HillShapesObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" namespace OpenLoco::World::MapGenerator { void OriginalTerrainGenerator::blitHill(const Scenario::Options& options, HeightMap& heightMap) { const uint32_t randomVal = getGameState().rng.randNext(); const bool flipHillImageLateral = randomVal & 0x100; const bool flipHillImageVertical = randomVal & 0x200; const auto hillShapesObj = ObjectManager::get<HillShapesObject>(); const uint8_t hillShapeCount = hillShapesObj->hillHeightMapCount + hillShapesObj->mountainHeightMapCount; // The hill index calculation is a minor simplification compared to vanilla const uint8_t randomHillIndex = (randomVal & 0xFF) % hillShapeCount; const auto hillImage = hillShapesObj->image + randomHillIndex; const auto g1Element = Gfx::getG1Element(hillImage); auto featureWidth = g1Element->width & 0xFF; auto featureHeight = g1Element->height & 0xFF; if (flipHillImageLateral) { std::swap(featureWidth, featureHeight); } // 0x00462718 const uint32_t randX = getGameState().rng.randNext(heightMap.width - 1); const uint32_t randY = getGameState().rng.randNext(heightMap.height - 1); if (randX < 2 || randY < 2) { return; } // Vanilla would use an `rcl` for the lower bit, getting the carry flag in. // We're substituting it with an extra bit of the random state. const bool topographyBit = randX > randY; const auto topographyId = (enumValue(options.topographyStyle) << 1) | (topographyBit ? 1U : 0); const auto topographyFlags = kTopographyStyleFlags[topographyId]; const bool generateHills = (topographyFlags & TopographyFlags::hasHills) != TopographyFlags::none; const bool generateMountains = (topographyFlags & TopographyFlags::hasMountains) != TopographyFlags::none; const bool isValidHillIndex = generateHills && randomHillIndex < hillShapesObj->hillHeightMapCount; const bool isValidMountainIndex = generateMountains && randomHillIndex >= hillShapesObj->hillHeightMapCount; if (!(isValidHillIndex || isValidMountainIndex)) { return; } // 0x0046276D if ((options.scenarioFlags & Scenario::ScenarioFlags::hillsEdgeOfMap) == Scenario::ScenarioFlags::none) { if ((randX + featureWidth >= heightMap.width - 2U) || (randY + featureHeight >= heightMap.height - 2U)) { return; } } using BlitFunction = std::function<void(Gfx::G1Element*, uint8_t, uint8_t, HeightMap&, tile_coord_t, tile_coord_t)>; static const std::array<std::array<BlitFunction, 2>, 2> blitMethods = { { { blitImageNormalXNormalY, blitImageNormalXFlippedY, }, { blitImageFlippedXNormalY, blitImageFlippedXFlippedY, }, } }; auto blitFeature = blitMethods[flipHillImageLateral][flipHillImageVertical]; blitFeature(g1Element, featureWidth, featureHeight, heightMap, randX, randY); } void OriginalTerrainGenerator::blitImageFlippedXFlippedY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY) { auto* src = g1Element->offset; int32_t x = randX; for (auto j = 0; j < featureWidth; ++j) { int32_t y = (featureHeight + randY - 1) % (heightMap.height - 1); for (auto i = 0; i < featureHeight; ++i) { const auto data = *src++; heightMap[TilePos2(x, y)] = std::max(data, heightMap[TilePos2(x, y)]); auto mod = heightMap.height - 1; y = (y - 1 + mod) % mod; } x++; x %= heightMap.width - 1; } } void OriginalTerrainGenerator::blitImageFlippedXNormalY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY) { auto* src = g1Element->offset; int32_t x = randX; for (auto j = 0; j < featureWidth; ++j) { int32_t y = randY; for (auto i = 0; i < featureHeight; ++i) { const auto data = *src++; heightMap[TilePos2(x, y)] = std::max(data, heightMap[TilePos2(x, y)]); y++; y %= heightMap.height - 1; } x++; x %= heightMap.width - 1; } } void OriginalTerrainGenerator::blitImageNormalXFlippedY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY) { auto* src = g1Element->offset; int32_t y = randY; for (auto j = 0; j < featureHeight; ++j) { int32_t x = (randX + featureWidth - 1) % (heightMap.width - 1); for (auto i = 0; i < featureWidth; ++i) { const auto data = *src++; heightMap[TilePos2(x, y)] = std::max(data, heightMap[TilePos2(x, y)]); auto mod = heightMap.width - 1; x = (x - 1 + mod) % mod; } y++; y %= heightMap.height - 1; } } void OriginalTerrainGenerator::blitImageNormalXNormalY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY) { auto* src = g1Element->offset; int32_t y = randY; for (auto j = 0; j < featureHeight; ++j) { int32_t x = randX; for (auto i = 0; i < featureWidth; ++i) { const auto data = *src++; heightMap[TilePos2(x, y)] = std::max(data, heightMap[TilePos2(x, y)]); x++; x %= heightMap.width - 1; } y++; y %= heightMap.height - 1; } } // 0x00462518 void OriginalTerrainGenerator::generateHills(const Scenario::Options& options, HeightMap& heightMap) { uint8_t baseCount = getGameState().rng.randNext() & 7; uint16_t numHills = baseCount + (options.hillDensity * 5) + 1; for (uint16_t i = 0; i < numHills; i++) { blitHill(options, heightMap); } } // 0x00462556 void OriginalTerrainGenerator::copyHeightMapFromG1(Gfx::G1Element* g1Element, HeightMap& heightMap) { auto* src = g1Element->offset; for (auto y = heightMap.height - 1; y > 0; y--) { for (auto x = heightMap.width - 1; x > 0; x--) { auto height = std::max<uint8_t>(*src, heightMap[TilePos2(x, y)]); heightMap[TilePos2(x, y)] = height; src++; } src += kMapPitch; } } // 0x00462590 void OriginalTerrainGenerator::capSeaLevels(HeightMap& heightMap) { const auto seaLevel = getGameState().seaLevel; for (auto y = 0; y < heightMap.height - 2; y++) { for (auto x = 0; x < heightMap.width - 2; x++) { if (seaLevel != heightMap[TilePos2(x + 0, y + 0)]) { continue; } if (seaLevel != heightMap[TilePos2(x + 1, y + 0)]) { continue; } if (seaLevel != heightMap[TilePos2(x + 0, y + 1)]) { continue; } if (seaLevel != heightMap[TilePos2(x + 1, y + 1)]) { continue; } heightMap[TilePos2(x + 0, y + 0)] += 1; heightMap[TilePos2(x + 1, y + 0)] += 1; heightMap[TilePos2(x + 0, y + 1)] += 1; heightMap[TilePos2(x + 1, y + 1)] += 1; } } } void OriginalTerrainGenerator::generate(const Scenario::Options& options, HeightMap& heightMap) { std::fill_n(heightMap.data(), heightMap.size(), options.minLandHeight); auto hillShapesObj = ObjectManager::get<HillShapesObject>(); if ((hillShapesObj->flags & HillShapeFlags::isHeightMap) != HillShapeFlags::none) { auto g1Element = Gfx::getG1Element(hillShapesObj->image); copyHeightMapFromG1(g1Element, heightMap); } else { generateHills(options, heightMap); } capSeaLevels(heightMap); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/OriginalTerrainGenerator.h ```h #pragma once #include "HeightMap.h" #include "Types.hpp" #include <array> #include <cstdint> #include <functional> namespace OpenLoco::Scenario { struct Options; } namespace OpenLoco::Gfx { struct G1Element; } namespace OpenLoco::World::MapGenerator { class OriginalTerrainGenerator { private: // 0x004626B7 void blitHill(const Scenario::Options& options, HeightMap& heightMap); static void blitImageFlippedXFlippedY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY); static void blitImageFlippedXNormalY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY); static void blitImageNormalXFlippedY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY); static void blitImageNormalXNormalY(Gfx::G1Element* g1Element, uint8_t featureWidth, uint8_t featureHeight, HeightMap& heightMap, tile_coord_t randX, tile_coord_t randY); // 0x00462518 void generateHills(const Scenario::Options& options, HeightMap& heightMap); // 0x00462556 void copyHeightMapFromG1(Gfx::G1Element* g1Element, HeightMap& heightMap); // 0x00462590 void capSeaLevels(HeightMap& heightMap); public: // 0x004624F0 void generate(const Scenario::Options& options, HeightMap& heightMap); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/PngTerrainGenerator.cpp ```cpp #include "PngTerrainGenerator.h" #include "Logging.h" #include "MapGenerator.h" #include "ScenarioOptions.h" #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Gfx/PngImage.h> #include <OpenLoco/Platform/Platform.h> #include <png.h> using namespace OpenLoco::World; using namespace OpenLoco::Diagnostics; namespace OpenLoco::World::MapGenerator { void PngTerrainGenerator::generate(const Scenario::Options& options, const fs::path& path, HeightMap& heightMap) { if (!fs::is_regular_file(path)) { Logging::error("Can't find heightmap file ({})", path); return; } auto pngImage = Gfx::PngImage::loadFromFile(path); if (pngImage == nullptr) { Logging::error("Can't load heightmap file ({})", path); return; } const int maxHeightmapLevels = 40 - options.minLandHeight; const float scalingFactor = maxHeightmapLevels / 255.f; std::fill_n(heightMap.data(), heightMap.size(), options.minLandHeight); auto width = std::min<int>(World::kMapColumns, pngImage->width); auto height = std::min<int>(World::kMapRows, pngImage->height); for (int32_t y = 0; y < height; y++) { for (int32_t x = 0; x < width; x++) { const auto pixelColour = pngImage->getPixel(x, y); auto imgHeight = std::max({ pixelColour.r, pixelColour.g, pixelColour.b }); heightMap[{ TilePos2(y, x) }] += imgHeight * scalingFactor; // this must be { y, x } otherwise the heightmap is mirrored } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/PngTerrainGenerator.h ```h #pragma once #include "HeightMap.h" #include <OpenLoco/Core/FileSystem.hpp> namespace OpenLoco::Scenario { struct Options; } namespace OpenLoco::World::MapGenerator { class PngTerrainGenerator { public: void generate(const Scenario::Options& options, const fs::path& path, HeightMap& heightMap); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/SimplexTerrainGenerator.cpp ```cpp #include "SimplexTerrainGenerator.h" #include "ScenarioOptions.h" #include "Ui/ProgressBar.h" #include <algorithm> namespace OpenLoco::World::MapGenerator { void SimplexTerrainGenerator::generate(const Scenario::Options& options, HeightMapRange heightMap, uint32_t seed) { initialiseRng(seed); auto hillDensity = std::clamp<uint8_t>(options.hillDensity, 0, 100) / 100.0f; auto smoothingPasses = std::clamp<uint8_t>(options.numTerrainSmoothingPasses, 1, 5); SimplexSettings settings; settings.low = options.minLandHeight; settings.smooth = smoothingPasses; switch (options.topographyStyle) { case Scenario::TopographyStyle::flatLand: settings.high = options.minLandHeight + 8; settings.baseFreq = 4.0f * hillDensity; settings.octaves = 5; generate(settings, heightMap); break; case Scenario::TopographyStyle::smallHills: settings.high = options.minLandHeight + 14; settings.baseFreq = 6.0f * hillDensity; settings.octaves = 6; generate(settings, heightMap); break; case Scenario::TopographyStyle::mountains: settings.high = 32; settings.baseFreq = 4.0f * hillDensity; settings.octaves = 6; generate(settings, heightMap); break; case Scenario::TopographyStyle::halfMountainsHills: settings.high = 32; settings.baseFreq = 8.0f * hillDensity; settings.octaves = 6; generate(settings, heightMap); break; case Scenario::TopographyStyle::halfMountainsFlat: settings.high = 32; settings.baseFreq = 6.0f * hillDensity; settings.octaves = 5; generate(settings, heightMap); break; } } void SimplexTerrainGenerator::initialiseRng(uint32_t seed) { _pprng.seed(seed); } void SimplexTerrainGenerator::generate(const SimplexSettings& settings, HeightMapRange heightMap) { generateSimplex(settings, heightMap); Ui::ProgressBar::setProgress(15); smooth(settings.smooth, heightMap); } void SimplexTerrainGenerator::generateSimplex(const SimplexSettings& settings, HeightMapRange heightMap) { auto freq = settings.baseFreq * (1.0f / std::max(heightMap.width, heightMap.height)); uint8_t perm[512]; noise(perm, std::size(perm)); for (int32_t y = 0; y < heightMap.height; y++) { for (int32_t x = 0; x < heightMap.width; x++) { auto noiseValue = std::clamp(noiseFractal(perm, x, y, freq, settings.octaves, 2.0f, 0.65f), -1.0f, 1.0f); auto normalisedNoiseValue = (noiseValue + 1.0f) / 2.0f; auto height = settings.low + static_cast<int32_t>(normalisedNoiseValue * settings.high); heightMap[TilePos2(x, y)] = height; } } } void SimplexTerrainGenerator::smooth(int32_t iterations, HeightMapRange heightMap) { if (iterations == 0) { return; } const auto progressSteps = (25 - 15) / iterations; auto currentProgress = 15; for (int32_t i = 0; i < iterations; i++) { auto copyHeight = heightMap; for (int32_t y = 1; y < heightMap.width - 1; y++) { for (int32_t x = 1; x < heightMap.height - 1; x++) { int32_t total = 0; for (int32_t yy = -1; yy <= 1; yy++) { for (int32_t xx = -1; xx <= 1; xx++) { total += copyHeight[TilePos2(x + xx, y + yy)]; } } heightMap[TilePos2(x, y)] = total / 9; } } currentProgress += progressSteps; Ui::ProgressBar::setProgress(currentProgress); } } float SimplexTerrainGenerator::noiseFractal(uint8_t* perm, int32_t x, int32_t y, float frequency, int32_t octaves, float lacunarity, float persistence) { float total = 0.0f; float amplitude = persistence; for (int32_t i = 0; i < octaves; i++) { total += generateNoise(perm, x * frequency, y * frequency) * amplitude; frequency *= lacunarity; amplitude *= persistence; } return total; } float SimplexTerrainGenerator::generateNoise(uint8_t* perm, float x, float y) { const float F2 = 0.366025403f; // F2 = 0.5*(sqrt(3.0)-1.0) const float G2 = 0.211324865f; // G2 = (3.0-sqrt(3.0))/6.0 float n0, n1, n2; // Noise contributions from the three corners // Skew the input space to determine which simplex cell we're in float s = (x + y) * F2; // Hairy factor for 2D float xs = x + s; float ys = y + s; int32_t i = fastFloor(xs); int32_t j = fastFloor(ys); float t = static_cast<float>(i + j) * G2; float X0 = i - t; // Unskew the cell origin back to (x,y) space float Y0 = j - t; float x0 = x - X0; // The x,y distances from the cell origin float y0 = y - Y0; // For the 2D case, the simplex shape is an equilateral triangle. // Determine which simplex we are in. int32_t i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords if (x0 > y0) { i1 = 1; j1 = 0; } // lower triangle, XY order: (0,0)->(1,0)->(1,1) else { i1 = 0; j1 = 1; } // upper triangle, YX order: (0,0)->(0,1)->(1,1) // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where // c = (3-sqrt(3))/6 float x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords float y1 = y0 - j1 + G2; float x2 = x0 - 1.0f + 2.0f * G2; // Offsets for last corner in (x,y) unskewed coords float y2 = y0 - 1.0f + 2.0f * G2; // Wrap the integer indices at 256, to avoid indexing perm[] out of bounds int32_t ii = i % 256; int32_t jj = j % 256; // Calculate the contribution from the three corners float t0 = 0.5f - x0 * x0 - y0 * y0; if (t0 < 0.0f) { n0 = 0.0f; } else { t0 *= t0; n0 = t0 * t0 * grad(perm[ii + perm[jj]], x0, y0); } float t1 = 0.5f - x1 * x1 - y1 * y1; if (t1 < 0.0f) { n1 = 0.0f; } else { t1 *= t1; n1 = t1 * t1 * grad(perm[ii + i1 + perm[jj + j1]], x1, y1); } float t2 = 0.5f - x2 * x2 - y2 * y2; if (t2 < 0.0f) { n2 = 0.0f; } else { t2 *= t2; n2 = t2 * t2 * grad(perm[ii + 1 + perm[jj + 1]], x2, y2); } // Add contributions from each corner to get the final noise value. // The result is scaled to return values in the interval [-1,1]. return 40.0f * (n0 + n1 + n2); // TODO: The scale factor is preliminary! } void SimplexTerrainGenerator::noise(uint8_t* perm, size_t len) { for (size_t i = 0; i < len; i++) { perm[i] = randomNext() & 0xFF; } } float SimplexTerrainGenerator::grad(int32_t hash, float x, float y) { int32_t h = hash & 7; // Convert low 3 bits of hash code float u = h < 4 ? x : y; // into 8 simple gradient directions, float v = h < 4 ? y : x; // and compute the dot product with (x,y). return ((h & 1) != 0 ? -u : u) + ((h & 2) != 0 ? -2.0f * v : 2.0f * v); } int32_t SimplexTerrainGenerator::fastFloor(float x) { return (x > 0) ? (static_cast<int32_t>(x)) : ((static_cast<int32_t>(x)) - 1); } uint32_t SimplexTerrainGenerator::randomNext() { return _pprng(); } int32_t SimplexTerrainGenerator::randomNext(int32_t min, int32_t max) { return min + (randomNext() % (max - min)); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/MapGenerator/SimplexTerrainGenerator.h ```h #pragma once #include "HeightMapRange.h" #include <cstdint> #include <random> namespace OpenLoco::Scenario { struct Options; } namespace OpenLoco::World::MapGenerator { class SimplexTerrainGenerator { public: void generate(const Scenario::Options& options, HeightMapRange heightMap, uint32_t seed); private: struct SimplexSettings { int32_t low = 2; int32_t high = 24; float baseFreq = 1.25f; int32_t octaves = 4; int32_t smooth = 2; }; std::mt19937 _pprng; void initialiseRng(uint32_t seed); void generate(const SimplexSettings& settings, HeightMapRange heightMap); void generateSimplex(const SimplexSettings& settings, HeightMapRange heightMap); static void smooth(int32_t iterations, HeightMapRange heightMap); static float noiseFractal(uint8_t* perm, int32_t x, int32_t y, float frequency, int32_t octaves, float lacunarity, float persistence); static float generateNoise(uint8_t* perm, float x, float y); void noise(uint8_t* perm, size_t len); static float grad(int32_t hash, float x, float y); static int32_t fastFloor(float x); uint32_t randomNext(); int32_t randomNext(int32_t min, int32_t max); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/SubpositionData.cpp ```cpp #include "SubpositionData.h" #include "Entities/Entity.h" #include "GameState.h" #include <OpenLoco/Interop/Interop.hpp> #include <array> #include <vector> using namespace OpenLoco::Interop; namespace OpenLoco::World::TrackData { #pragma region TrackData // 0x4da526 // Track 0. Reversed 0. Direction 0 static constexpr auto moveInfoT0R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 0, Pitch::flat }, { { 23, 16, 0 }, 0, Pitch::flat }, { { 22, 16, 0 }, 0, Pitch::flat }, { { 21, 16, 0 }, 0, Pitch::flat }, { { 20, 16, 0 }, 0, Pitch::flat }, { { 19, 16, 0 }, 0, Pitch::flat }, { { 18, 16, 0 }, 0, Pitch::flat }, { { 17, 16, 0 }, 0, Pitch::flat }, { { 16, 16, 0 }, 0, Pitch::flat }, { { 15, 16, 0 }, 0, Pitch::flat }, { { 14, 16, 0 }, 0, Pitch::flat }, { { 13, 16, 0 }, 0, Pitch::flat }, { { 12, 16, 0 }, 0, Pitch::flat }, { { 11, 16, 0 }, 0, Pitch::flat }, { { 10, 16, 0 }, 0, Pitch::flat }, { { 9, 16, 0 }, 0, Pitch::flat }, { { 8, 16, 0 }, 0, Pitch::flat }, { { 7, 16, 0 }, 0, Pitch::flat }, { { 6, 16, 0 }, 0, Pitch::flat }, { { 5, 16, 0 }, 0, Pitch::flat }, { { 4, 16, 0 }, 0, Pitch::flat }, { { 3, 16, 0 }, 0, Pitch::flat }, { { 2, 16, 0 }, 0, Pitch::flat }, { { 1, 16, 0 }, 0, Pitch::flat }, { { 0, 16, 0 }, 0, Pitch::flat }, }); // 0x4da628 // Track 0. Reversed 0. Direction 1 static constexpr auto moveInfoT0R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 16, Pitch::flat }, { { 16, 9, 0 }, 16, Pitch::flat }, { { 16, 10, 0 }, 16, Pitch::flat }, { { 16, 11, 0 }, 16, Pitch::flat }, { { 16, 12, 0 }, 16, Pitch::flat }, { { 16, 13, 0 }, 16, Pitch::flat }, { { 16, 14, 0 }, 16, Pitch::flat }, { { 16, 15, 0 }, 16, Pitch::flat }, { { 16, 16, 0 }, 16, Pitch::flat }, { { 16, 17, 0 }, 16, Pitch::flat }, { { 16, 18, 0 }, 16, Pitch::flat }, { { 16, 19, 0 }, 16, Pitch::flat }, { { 16, 20, 0 }, 16, Pitch::flat }, { { 16, 21, 0 }, 16, Pitch::flat }, { { 16, 22, 0 }, 16, Pitch::flat }, { { 16, 23, 0 }, 16, Pitch::flat }, { { 16, 24, 0 }, 16, Pitch::flat }, { { 16, 25, 0 }, 16, Pitch::flat }, { { 16, 26, 0 }, 16, Pitch::flat }, { { 16, 27, 0 }, 16, Pitch::flat }, { { 16, 28, 0 }, 16, Pitch::flat }, { { 16, 29, 0 }, 16, Pitch::flat }, { { 16, 30, 0 }, 16, Pitch::flat }, { { 16, 31, 0 }, 16, Pitch::flat }, }); // 0x4da72a // Track 0. Reversed 0. Direction 2 static constexpr auto moveInfoT0R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 32, Pitch::flat }, { { 9, 16, 0 }, 32, Pitch::flat }, { { 10, 16, 0 }, 32, Pitch::flat }, { { 11, 16, 0 }, 32, Pitch::flat }, { { 12, 16, 0 }, 32, Pitch::flat }, { { 13, 16, 0 }, 32, Pitch::flat }, { { 14, 16, 0 }, 32, Pitch::flat }, { { 15, 16, 0 }, 32, Pitch::flat }, { { 16, 16, 0 }, 32, Pitch::flat }, { { 17, 16, 0 }, 32, Pitch::flat }, { { 18, 16, 0 }, 32, Pitch::flat }, { { 19, 16, 0 }, 32, Pitch::flat }, { { 20, 16, 0 }, 32, Pitch::flat }, { { 21, 16, 0 }, 32, Pitch::flat }, { { 22, 16, 0 }, 32, Pitch::flat }, { { 23, 16, 0 }, 32, Pitch::flat }, { { 24, 16, 0 }, 32, Pitch::flat }, { { 25, 16, 0 }, 32, Pitch::flat }, { { 26, 16, 0 }, 32, Pitch::flat }, { { 27, 16, 0 }, 32, Pitch::flat }, { { 28, 16, 0 }, 32, Pitch::flat }, { { 29, 16, 0 }, 32, Pitch::flat }, { { 30, 16, 0 }, 32, Pitch::flat }, { { 31, 16, 0 }, 32, Pitch::flat }, }); // 0x4da82c // Track 0. Reversed 0. Direction 3 static constexpr auto moveInfoT0R0D3 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 48, Pitch::flat }, { { 16, 23, 0 }, 48, Pitch::flat }, { { 16, 22, 0 }, 48, Pitch::flat }, { { 16, 21, 0 }, 48, Pitch::flat }, { { 16, 20, 0 }, 48, Pitch::flat }, { { 16, 19, 0 }, 48, Pitch::flat }, { { 16, 18, 0 }, 48, Pitch::flat }, { { 16, 17, 0 }, 48, Pitch::flat }, { { 16, 16, 0 }, 48, Pitch::flat }, { { 16, 15, 0 }, 48, Pitch::flat }, { { 16, 14, 0 }, 48, Pitch::flat }, { { 16, 13, 0 }, 48, Pitch::flat }, { { 16, 12, 0 }, 48, Pitch::flat }, { { 16, 11, 0 }, 48, Pitch::flat }, { { 16, 10, 0 }, 48, Pitch::flat }, { { 16, 9, 0 }, 48, Pitch::flat }, { { 16, 8, 0 }, 48, Pitch::flat }, { { 16, 7, 0 }, 48, Pitch::flat }, { { 16, 6, 0 }, 48, Pitch::flat }, { { 16, 5, 0 }, 48, Pitch::flat }, { { 16, 4, 0 }, 48, Pitch::flat }, { { 16, 3, 0 }, 48, Pitch::flat }, { { 16, 2, 0 }, 48, Pitch::flat }, { { 16, 1, 0 }, 48, Pitch::flat }, { { 16, 0, 0 }, 48, Pitch::flat }, }); // 0x4dc14e // Track 1. Reversed 0. Direction 0 static constexpr auto moveInfoT1R0D0 = std::to_array<MoveInfo>( { { { 15, 16, 0 }, 8, Pitch::flat }, { { 14, 17, 0 }, 8, Pitch::flat }, { { 13, 18, 0 }, 8, Pitch::flat }, { { 12, 19, 0 }, 8, Pitch::flat }, { { 11, 20, 0 }, 8, Pitch::flat }, { { 10, 21, 0 }, 8, Pitch::flat }, { { 9, 22, 0 }, 8, Pitch::flat }, { { 8, 23, 0 }, 8, Pitch::flat }, { { 7, 24, 0 }, 8, Pitch::flat }, { { 6, 25, 0 }, 8, Pitch::flat }, { { 5, 26, 0 }, 8, Pitch::flat }, { { 4, 27, 0 }, 8, Pitch::flat }, { { 3, 28, 0 }, 8, Pitch::flat }, { { 2, 29, 0 }, 8, Pitch::flat }, { { 1, 30, 0 }, 8, Pitch::flat }, { { 0, 31, 0 }, 8, Pitch::flat }, { { -1, 32, 0 }, 8, Pitch::flat }, { { -2, 33, 0 }, 8, Pitch::flat }, { { -3, 34, 0 }, 8, Pitch::flat }, { { -4, 35, 0 }, 8, Pitch::flat }, { { -5, 36, 0 }, 8, Pitch::flat }, { { -6, 37, 0 }, 8, Pitch::flat }, { { -7, 38, 0 }, 8, Pitch::flat }, { { -8, 39, 0 }, 8, Pitch::flat }, { { -9, 40, 0 }, 8, Pitch::flat }, { { -10, 41, 0 }, 8, Pitch::flat }, { { -11, 42, 0 }, 8, Pitch::flat }, { { -12, 43, 0 }, 8, Pitch::flat }, { { -13, 44, 0 }, 8, Pitch::flat }, { { -14, 45, 0 }, 8, Pitch::flat }, { { -15, 46, 0 }, 8, Pitch::flat }, { { -16, 47, 0 }, 8, Pitch::flat }, }); // 0x4dc250 // Track 1. Reversed 0. Direction 1 static constexpr auto moveInfoT1R0D1 = std::to_array<MoveInfo>( { { { 16, 16, 0 }, 24, Pitch::flat }, { { 17, 17, 0 }, 24, Pitch::flat }, { { 18, 18, 0 }, 24, Pitch::flat }, { { 19, 19, 0 }, 24, Pitch::flat }, { { 20, 20, 0 }, 24, Pitch::flat }, { { 21, 21, 0 }, 24, Pitch::flat }, { { 22, 22, 0 }, 24, Pitch::flat }, { { 23, 23, 0 }, 24, Pitch::flat }, { { 24, 24, 0 }, 24, Pitch::flat }, { { 25, 25, 0 }, 24, Pitch::flat }, { { 26, 26, 0 }, 24, Pitch::flat }, { { 27, 27, 0 }, 24, Pitch::flat }, { { 28, 28, 0 }, 24, Pitch::flat }, { { 29, 29, 0 }, 24, Pitch::flat }, { { 30, 30, 0 }, 24, Pitch::flat }, { { 31, 31, 0 }, 24, Pitch::flat }, { { 32, 32, 0 }, 24, Pitch::flat }, { { 33, 33, 0 }, 24, Pitch::flat }, { { 34, 34, 0 }, 24, Pitch::flat }, { { 35, 35, 0 }, 24, Pitch::flat }, { { 36, 36, 0 }, 24, Pitch::flat }, { { 37, 37, 0 }, 24, Pitch::flat }, { { 38, 38, 0 }, 24, Pitch::flat }, { { 39, 39, 0 }, 24, Pitch::flat }, { { 40, 40, 0 }, 24, Pitch::flat }, { { 41, 41, 0 }, 24, Pitch::flat }, { { 42, 42, 0 }, 24, Pitch::flat }, { { 43, 43, 0 }, 24, Pitch::flat }, { { 44, 44, 0 }, 24, Pitch::flat }, { { 45, 45, 0 }, 24, Pitch::flat }, { { 46, 46, 0 }, 24, Pitch::flat }, { { 47, 47, 0 }, 24, Pitch::flat }, }); // 0x4dc352 // Track 1. Reversed 0. Direction 2 static constexpr auto moveInfoT1R0D2 = std::to_array<MoveInfo>( { { { 16, 15, 0 }, 40, Pitch::flat }, { { 17, 14, 0 }, 40, Pitch::flat }, { { 18, 13, 0 }, 40, Pitch::flat }, { { 19, 12, 0 }, 40, Pitch::flat }, { { 20, 11, 0 }, 40, Pitch::flat }, { { 21, 10, 0 }, 40, Pitch::flat }, { { 22, 9, 0 }, 40, Pitch::flat }, { { 23, 8, 0 }, 40, Pitch::flat }, { { 24, 7, 0 }, 40, Pitch::flat }, { { 25, 6, 0 }, 40, Pitch::flat }, { { 26, 5, 0 }, 40, Pitch::flat }, { { 27, 4, 0 }, 40, Pitch::flat }, { { 28, 3, 0 }, 40, Pitch::flat }, { { 29, 2, 0 }, 40, Pitch::flat }, { { 30, 1, 0 }, 40, Pitch::flat }, { { 31, 0, 0 }, 40, Pitch::flat }, { { 32, -1, 0 }, 40, Pitch::flat }, { { 33, -2, 0 }, 40, Pitch::flat }, { { 34, -3, 0 }, 40, Pitch::flat }, { { 35, -4, 0 }, 40, Pitch::flat }, { { 36, -5, 0 }, 40, Pitch::flat }, { { 37, -6, 0 }, 40, Pitch::flat }, { { 38, -7, 0 }, 40, Pitch::flat }, { { 39, -8, 0 }, 40, Pitch::flat }, { { 40, -9, 0 }, 40, Pitch::flat }, { { 41, -10, 0 }, 40, Pitch::flat }, { { 42, -11, 0 }, 40, Pitch::flat }, { { 43, -12, 0 }, 40, Pitch::flat }, { { 44, -13, 0 }, 40, Pitch::flat }, { { 45, -14, 0 }, 40, Pitch::flat }, { { 46, -15, 0 }, 40, Pitch::flat }, { { 47, -16, 0 }, 40, Pitch::flat }, }); // 0x4dc454 // Track 1. Reversed 0. Direction 3 static constexpr auto moveInfoT1R0D3 = std::to_array<MoveInfo>( { { { 15, 15, 0 }, 56, Pitch::flat }, { { 14, 14, 0 }, 56, Pitch::flat }, { { 13, 13, 0 }, 56, Pitch::flat }, { { 12, 12, 0 }, 56, Pitch::flat }, { { 11, 11, 0 }, 56, Pitch::flat }, { { 10, 10, 0 }, 56, Pitch::flat }, { { 9, 9, 0 }, 56, Pitch::flat }, { { 8, 8, 0 }, 56, Pitch::flat }, { { 7, 7, 0 }, 56, Pitch::flat }, { { 6, 6, 0 }, 56, Pitch::flat }, { { 5, 5, 0 }, 56, Pitch::flat }, { { 4, 4, 0 }, 56, Pitch::flat }, { { 3, 3, 0 }, 56, Pitch::flat }, { { 2, 2, 0 }, 56, Pitch::flat }, { { 1, 1, 0 }, 56, Pitch::flat }, { { 0, 0, 0 }, 56, Pitch::flat }, { { -1, -1, 0 }, 56, Pitch::flat }, { { -2, -2, 0 }, 56, Pitch::flat }, { { -3, -3, 0 }, 56, Pitch::flat }, { { -4, -4, 0 }, 56, Pitch::flat }, { { -5, -5, 0 }, 56, Pitch::flat }, { { -6, -6, 0 }, 56, Pitch::flat }, { { -7, -7, 0 }, 56, Pitch::flat }, { { -8, -8, 0 }, 56, Pitch::flat }, { { -9, -9, 0 }, 56, Pitch::flat }, { { -10, -10, 0 }, 56, Pitch::flat }, { { -11, -11, 0 }, 56, Pitch::flat }, { { -12, -12, 0 }, 56, Pitch::flat }, { { -13, -13, 0 }, 56, Pitch::flat }, { { -14, -14, 0 }, 56, Pitch::flat }, { { -15, -15, 0 }, 56, Pitch::flat }, { { -16, -16, 0 }, 56, Pitch::flat }, }); // 0x4df376 // Track 2. Reversed 0. Direction 0 static constexpr auto moveInfoT2R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 62, Pitch::flat }, { { 28, 15, 0 }, 62, Pitch::flat }, { { 27, 15, 0 }, 60, Pitch::flat }, { { 26, 15, 0 }, 60, Pitch::flat }, { { 25, 14, 0 }, 60, Pitch::flat }, { { 24, 14, 0 }, 58, Pitch::flat }, { { 23, 13, 0 }, 58, Pitch::flat }, { { 22, 12, 0 }, 56, Pitch::flat }, { { 21, 11, 0 }, 56, Pitch::flat }, { { 20, 10, 0 }, 56, Pitch::flat }, { { 19, 9, 0 }, 54, Pitch::flat }, { { 18, 8, 0 }, 54, Pitch::flat }, { { 18, 7, 0 }, 52, Pitch::flat }, { { 17, 6, 0 }, 52, Pitch::flat }, { { 17, 5, 0 }, 52, Pitch::flat }, { { 17, 4, 0 }, 50, Pitch::flat }, { { 16, 3, 0 }, 50, Pitch::flat }, { { 16, 2, 0 }, 48, Pitch::flat }, { { 16, 1, 0 }, 48, Pitch::flat }, { { 16, 0, 0 }, 48, Pitch::flat }, }); // 0x4df428 // Track 2. Reversed 0. Direction 1 static constexpr auto moveInfoT2R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 14, Pitch::flat }, { { 15, 4, 0 }, 14, Pitch::flat }, { { 15, 5, 0 }, 12, Pitch::flat }, { { 15, 6, 0 }, 12, Pitch::flat }, { { 14, 7, 0 }, 12, Pitch::flat }, { { 14, 8, 0 }, 10, Pitch::flat }, { { 13, 9, 0 }, 10, Pitch::flat }, { { 12, 10, 0 }, 8, Pitch::flat }, { { 11, 11, 0 }, 8, Pitch::flat }, { { 10, 12, 0 }, 8, Pitch::flat }, { { 9, 13, 0 }, 6, Pitch::flat }, { { 8, 14, 0 }, 6, Pitch::flat }, { { 7, 14, 0 }, 4, Pitch::flat }, { { 6, 15, 0 }, 4, Pitch::flat }, { { 5, 15, 0 }, 4, Pitch::flat }, { { 4, 15, 0 }, 2, Pitch::flat }, { { 3, 16, 0 }, 2, Pitch::flat }, { { 2, 16, 0 }, 0, Pitch::flat }, { { 1, 16, 0 }, 0, Pitch::flat }, { { 0, 16, 0 }, 0, Pitch::flat }, }); // 0x4df4e2 // Track 2. Reversed 0. Direction 2 static constexpr auto moveInfoT2R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 30, Pitch::flat }, { { 4, 17, 0 }, 30, Pitch::flat }, { { 5, 17, 0 }, 28, Pitch::flat }, { { 6, 17, 0 }, 28, Pitch::flat }, { { 7, 18, 0 }, 28, Pitch::flat }, { { 8, 18, 0 }, 26, Pitch::flat }, { { 9, 19, 0 }, 26, Pitch::flat }, { { 10, 20, 0 }, 24, Pitch::flat }, { { 11, 21, 0 }, 24, Pitch::flat }, { { 12, 22, 0 }, 24, Pitch::flat }, { { 13, 23, 0 }, 22, Pitch::flat }, { { 14, 24, 0 }, 22, Pitch::flat }, { { 14, 25, 0 }, 20, Pitch::flat }, { { 15, 26, 0 }, 20, Pitch::flat }, { { 15, 27, 0 }, 20, Pitch::flat }, { { 15, 28, 0 }, 18, Pitch::flat }, { { 16, 29, 0 }, 18, Pitch::flat }, { { 16, 30, 0 }, 16, Pitch::flat }, { { 16, 31, 0 }, 16, Pitch::flat }, }); // 0x4df594 // Track 2. Reversed 0. Direction 3 static constexpr auto moveInfoT2R0D3 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 46, Pitch::flat }, { { 17, 28, 0 }, 46, Pitch::flat }, { { 17, 27, 0 }, 44, Pitch::flat }, { { 17, 26, 0 }, 44, Pitch::flat }, { { 18, 25, 0 }, 44, Pitch::flat }, { { 18, 24, 0 }, 42, Pitch::flat }, { { 19, 23, 0 }, 42, Pitch::flat }, { { 20, 22, 0 }, 40, Pitch::flat }, { { 21, 21, 0 }, 40, Pitch::flat }, { { 22, 20, 0 }, 40, Pitch::flat }, { { 23, 19, 0 }, 38, Pitch::flat }, { { 24, 18, 0 }, 38, Pitch::flat }, { { 25, 18, 0 }, 36, Pitch::flat }, { { 26, 17, 0 }, 36, Pitch::flat }, { { 27, 17, 0 }, 36, Pitch::flat }, { { 28, 17, 0 }, 34, Pitch::flat }, { { 29, 16, 0 }, 34, Pitch::flat }, { { 30, 16, 0 }, 32, Pitch::flat }, { { 31, 16, 0 }, 32, Pitch::flat }, }); // 0x4df6e8 // Track 2. Reversed 1. Direction 0 static constexpr auto moveInfoT2R1D0 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 18, Pitch::flat }, { { 17, 4, 0 }, 18, Pitch::flat }, { { 17, 5, 0 }, 20, Pitch::flat }, { { 17, 6, 0 }, 20, Pitch::flat }, { { 18, 7, 0 }, 20, Pitch::flat }, { { 18, 8, 0 }, 22, Pitch::flat }, { { 19, 9, 0 }, 22, Pitch::flat }, { { 20, 10, 0 }, 24, Pitch::flat }, { { 21, 11, 0 }, 24, Pitch::flat }, { { 22, 12, 0 }, 24, Pitch::flat }, { { 23, 13, 0 }, 26, Pitch::flat }, { { 24, 14, 0 }, 26, Pitch::flat }, { { 25, 14, 0 }, 28, Pitch::flat }, { { 26, 15, 0 }, 28, Pitch::flat }, { { 27, 15, 0 }, 28, Pitch::flat }, { { 28, 15, 0 }, 30, Pitch::flat }, { { 29, 16, 0 }, 30, Pitch::flat }, { { 30, 16, 0 }, 32, Pitch::flat }, { { 31, 16, 0 }, 32, Pitch::flat }, }); // 0x4df79a // Track 2. Reversed 1. Direction 1 static constexpr auto moveInfoT2R1D1 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 34, Pitch::flat }, { { 4, 15, 0 }, 34, Pitch::flat }, { { 5, 15, 0 }, 36, Pitch::flat }, { { 6, 15, 0 }, 36, Pitch::flat }, { { 7, 14, 0 }, 36, Pitch::flat }, { { 8, 14, 0 }, 38, Pitch::flat }, { { 9, 13, 0 }, 38, Pitch::flat }, { { 10, 12, 0 }, 40, Pitch::flat }, { { 11, 11, 0 }, 40, Pitch::flat }, { { 12, 10, 0 }, 40, Pitch::flat }, { { 13, 9, 0 }, 42, Pitch::flat }, { { 14, 8, 0 }, 42, Pitch::flat }, { { 14, 7, 0 }, 44, Pitch::flat }, { { 15, 6, 0 }, 44, Pitch::flat }, { { 15, 5, 0 }, 44, Pitch::flat }, { { 15, 4, 0 }, 46, Pitch::flat }, { { 16, 3, 0 }, 46, Pitch::flat }, { { 16, 2, 0 }, 48, Pitch::flat }, { { 16, 1, 0 }, 48, Pitch::flat }, { { 16, 0, 0 }, 48, Pitch::flat }, }); // 0x4df854 // Track 2. Reversed 1. Direction 2 static constexpr auto moveInfoT2R1D2 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 50, Pitch::flat }, { { 15, 28, 0 }, 50, Pitch::flat }, { { 15, 27, 0 }, 52, Pitch::flat }, { { 15, 26, 0 }, 52, Pitch::flat }, { { 14, 25, 0 }, 52, Pitch::flat }, { { 14, 24, 0 }, 54, Pitch::flat }, { { 13, 23, 0 }, 54, Pitch::flat }, { { 12, 22, 0 }, 56, Pitch::flat }, { { 11, 21, 0 }, 56, Pitch::flat }, { { 10, 20, 0 }, 56, Pitch::flat }, { { 9, 19, 0 }, 58, Pitch::flat }, { { 8, 18, 0 }, 58, Pitch::flat }, { { 7, 18, 0 }, 60, Pitch::flat }, { { 6, 17, 0 }, 60, Pitch::flat }, { { 5, 17, 0 }, 60, Pitch::flat }, { { 4, 17, 0 }, 62, Pitch::flat }, { { 3, 16, 0 }, 62, Pitch::flat }, { { 2, 16, 0 }, 0, Pitch::flat }, { { 1, 16, 0 }, 0, Pitch::flat }, { { 0, 16, 0 }, 0, Pitch::flat }, }); // 0x4df63e // Track 2. Reversed 1. Direction 3 static constexpr auto moveInfoT2R1D3 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 2, Pitch::flat }, { { 28, 17, 0 }, 2, Pitch::flat }, { { 27, 17, 0 }, 4, Pitch::flat }, { { 26, 17, 0 }, 4, Pitch::flat }, { { 25, 18, 0 }, 4, Pitch::flat }, { { 24, 18, 0 }, 6, Pitch::flat }, { { 23, 19, 0 }, 6, Pitch::flat }, { { 22, 20, 0 }, 8, Pitch::flat }, { { 21, 21, 0 }, 8, Pitch::flat }, { { 20, 22, 0 }, 8, Pitch::flat }, { { 19, 23, 0 }, 10, Pitch::flat }, { { 18, 24, 0 }, 10, Pitch::flat }, { { 18, 25, 0 }, 12, Pitch::flat }, { { 17, 26, 0 }, 12, Pitch::flat }, { { 17, 27, 0 }, 12, Pitch::flat }, { { 17, 28, 0 }, 14, Pitch::flat }, { { 16, 29, 0 }, 14, Pitch::flat }, { { 16, 30, 0 }, 16, Pitch::flat }, { { 16, 31, 0 }, 16, Pitch::flat }, }); // 0x4df906 // Track 4. Reversed 0. Direction 0 static constexpr auto moveInfoT4R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 62, Pitch::flat }, { { 26, 16, 0 }, 62, Pitch::flat }, { { 25, 15, 0 }, 62, Pitch::flat }, { { 24, 15, 0 }, 62, Pitch::flat }, { { 23, 15, 0 }, 62, Pitch::flat }, { { 22, 15, 0 }, 62, Pitch::flat }, { { 21, 15, 0 }, 62, Pitch::flat }, { { 20, 15, 0 }, 62, Pitch::flat }, { { 19, 14, 0 }, 62, Pitch::flat }, { { 18, 14, 0 }, 60, Pitch::flat }, { { 17, 14, 0 }, 60, Pitch::flat }, { { 16, 13, 0 }, 60, Pitch::flat }, { { 15, 13, 0 }, 60, Pitch::flat }, { { 14, 13, 0 }, 60, Pitch::flat }, { { 13, 12, 0 }, 60, Pitch::flat }, { { 12, 12, 0 }, 60, Pitch::flat }, { { 11, 11, 0 }, 60, Pitch::flat }, { { 10, 11, 0 }, 60, Pitch::flat }, { { 9, 10, 0 }, 58, Pitch::flat }, { { 8, 10, 0 }, 58, Pitch::flat }, { { 7, 9, 0 }, 58, Pitch::flat }, { { 6, 9, 0 }, 58, Pitch::flat }, { { 5, 8, 0 }, 58, Pitch::flat }, { { 4, 7, 0 }, 58, Pitch::flat }, { { 3, 7, 0 }, 58, Pitch::flat }, { { 2, 6, 0 }, 58, Pitch::flat }, { { 1, 5, 0 }, 56, Pitch::flat }, { { 0, 4, 0 }, 56, Pitch::flat }, { { -1, 3, 0 }, 56, Pitch::flat }, { { -3, 3, 0 }, 56, Pitch::flat }, { { -4, 2, 0 }, 56, Pitch::flat }, { { -5, 1, 0 }, 56, Pitch::flat }, { { -6, 0, 0 }, 56, Pitch::flat }, { { -7, -1, 0 }, 54, Pitch::flat }, { { -7, -2, 0 }, 54, Pitch::flat }, { { -8, -3, 0 }, 54, Pitch::flat }, { { -9, -4, 0 }, 54, Pitch::flat }, { { -9, -5, 0 }, 54, Pitch::flat }, { { -10, -6, 0 }, 54, Pitch::flat }, { { -10, -7, 0 }, 54, Pitch::flat }, { { -11, -8, 0 }, 54, Pitch::flat }, { { -11, -9, 0 }, 52, Pitch::flat }, { { -12, -10, 0 }, 52, Pitch::flat }, { { -12, -11, 0 }, 52, Pitch::flat }, { { -13, -12, 0 }, 52, Pitch::flat }, { { -13, -13, 0 }, 52, Pitch::flat }, { { -13, -14, 0 }, 52, Pitch::flat }, { { -14, -15, 0 }, 52, Pitch::flat }, { { -14, -16, 0 }, 52, Pitch::flat }, { { -14, -17, 0 }, 52, Pitch::flat }, { { -15, -18, 0 }, 50, Pitch::flat }, { { -15, -19, 0 }, 50, Pitch::flat }, { { -15, -20, 0 }, 50, Pitch::flat }, { { -15, -21, 0 }, 50, Pitch::flat }, { { -15, -22, 0 }, 50, Pitch::flat }, { { -15, -23, 0 }, 50, Pitch::flat }, { { -16, -24, 0 }, 50, Pitch::flat }, { { -16, -25, 0 }, 50, Pitch::flat }, { { -16, -26, 0 }, 50, Pitch::flat }, { { -16, -27, 0 }, 48, Pitch::flat }, { { -16, -28, 0 }, 48, Pitch::flat }, { { -16, -29, 0 }, 48, Pitch::flat }, { { -16, -30, 0 }, 48, Pitch::flat }, { { -16, -31, 0 }, 48, Pitch::flat }, }); // 0x4dfb28 // Track 4. Reversed 0. Direction 1 static constexpr auto moveInfoT4R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 14, Pitch::flat }, { { 16, 6, 0 }, 14, Pitch::flat }, { { 15, 7, 0 }, 14, Pitch::flat }, { { 15, 8, 0 }, 14, Pitch::flat }, { { 15, 9, 0 }, 14, Pitch::flat }, { { 15, 10, 0 }, 14, Pitch::flat }, { { 15, 11, 0 }, 14, Pitch::flat }, { { 15, 12, 0 }, 14, Pitch::flat }, { { 14, 13, 0 }, 14, Pitch::flat }, { { 14, 14, 0 }, 12, Pitch::flat }, { { 14, 15, 0 }, 12, Pitch::flat }, { { 13, 16, 0 }, 12, Pitch::flat }, { { 13, 17, 0 }, 12, Pitch::flat }, { { 13, 18, 0 }, 12, Pitch::flat }, { { 12, 19, 0 }, 12, Pitch::flat }, { { 12, 20, 0 }, 12, Pitch::flat }, { { 11, 21, 0 }, 12, Pitch::flat }, { { 11, 22, 0 }, 12, Pitch::flat }, { { 10, 23, 0 }, 10, Pitch::flat }, { { 10, 24, 0 }, 10, Pitch::flat }, { { 9, 25, 0 }, 10, Pitch::flat }, { { 9, 26, 0 }, 10, Pitch::flat }, { { 8, 27, 0 }, 10, Pitch::flat }, { { 7, 28, 0 }, 10, Pitch::flat }, { { 7, 29, 0 }, 10, Pitch::flat }, { { 6, 30, 0 }, 10, Pitch::flat }, { { 5, 31, 0 }, 8, Pitch::flat }, { { 4, 32, 0 }, 8, Pitch::flat }, { { 3, 33, 0 }, 8, Pitch::flat }, { { 3, 35, 0 }, 8, Pitch::flat }, { { 2, 36, 0 }, 8, Pitch::flat }, { { 1, 37, 0 }, 8, Pitch::flat }, { { 0, 38, 0 }, 8, Pitch::flat }, { { -1, 39, 0 }, 6, Pitch::flat }, { { -2, 39, 0 }, 6, Pitch::flat }, { { -3, 40, 0 }, 6, Pitch::flat }, { { -4, 41, 0 }, 6, Pitch::flat }, { { -5, 41, 0 }, 6, Pitch::flat }, { { -6, 42, 0 }, 6, Pitch::flat }, { { -7, 42, 0 }, 6, Pitch::flat }, { { -8, 43, 0 }, 6, Pitch::flat }, { { -9, 43, 0 }, 4, Pitch::flat }, { { -10, 44, 0 }, 4, Pitch::flat }, { { -11, 44, 0 }, 4, Pitch::flat }, { { -12, 45, 0 }, 4, Pitch::flat }, { { -13, 45, 0 }, 4, Pitch::flat }, { { -14, 45, 0 }, 4, Pitch::flat }, { { -15, 46, 0 }, 4, Pitch::flat }, { { -16, 46, 0 }, 4, Pitch::flat }, { { -17, 46, 0 }, 4, Pitch::flat }, { { -18, 47, 0 }, 2, Pitch::flat }, { { -19, 47, 0 }, 2, Pitch::flat }, { { -20, 47, 0 }, 2, Pitch::flat }, { { -21, 47, 0 }, 2, Pitch::flat }, { { -22, 47, 0 }, 2, Pitch::flat }, { { -23, 47, 0 }, 2, Pitch::flat }, { { -24, 48, 0 }, 2, Pitch::flat }, { { -25, 48, 0 }, 2, Pitch::flat }, { { -26, 48, 0 }, 2, Pitch::flat }, { { -27, 48, 0 }, 0, Pitch::flat }, { { -28, 48, 0 }, 0, Pitch::flat }, { { -29, 48, 0 }, 0, Pitch::flat }, { { -30, 48, 0 }, 0, Pitch::flat }, { { -31, 48, 0 }, 0, Pitch::flat }, }); // 0x4dfd52 // Track 4. Reversed 0. Direction 2 static constexpr auto moveInfoT4R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 30, Pitch::flat }, { { 6, 16, 0 }, 30, Pitch::flat }, { { 7, 17, 0 }, 30, Pitch::flat }, { { 8, 17, 0 }, 30, Pitch::flat }, { { 9, 17, 0 }, 30, Pitch::flat }, { { 10, 17, 0 }, 30, Pitch::flat }, { { 11, 17, 0 }, 30, Pitch::flat }, { { 12, 17, 0 }, 30, Pitch::flat }, { { 13, 18, 0 }, 30, Pitch::flat }, { { 14, 18, 0 }, 28, Pitch::flat }, { { 15, 18, 0 }, 28, Pitch::flat }, { { 16, 19, 0 }, 28, Pitch::flat }, { { 17, 19, 0 }, 28, Pitch::flat }, { { 18, 19, 0 }, 28, Pitch::flat }, { { 19, 20, 0 }, 28, Pitch::flat }, { { 20, 20, 0 }, 28, Pitch::flat }, { { 21, 21, 0 }, 28, Pitch::flat }, { { 22, 21, 0 }, 28, Pitch::flat }, { { 23, 22, 0 }, 26, Pitch::flat }, { { 24, 22, 0 }, 26, Pitch::flat }, { { 25, 23, 0 }, 26, Pitch::flat }, { { 26, 23, 0 }, 26, Pitch::flat }, { { 27, 24, 0 }, 26, Pitch::flat }, { { 28, 25, 0 }, 26, Pitch::flat }, { { 29, 25, 0 }, 26, Pitch::flat }, { { 30, 26, 0 }, 26, Pitch::flat }, { { 31, 27, 0 }, 24, Pitch::flat }, { { 32, 28, 0 }, 24, Pitch::flat }, { { 33, 29, 0 }, 24, Pitch::flat }, { { 35, 29, 0 }, 24, Pitch::flat }, { { 36, 30, 0 }, 24, Pitch::flat }, { { 37, 31, 0 }, 24, Pitch::flat }, { { 38, 32, 0 }, 24, Pitch::flat }, { { 39, 33, 0 }, 22, Pitch::flat }, { { 39, 34, 0 }, 22, Pitch::flat }, { { 40, 35, 0 }, 22, Pitch::flat }, { { 41, 36, 0 }, 22, Pitch::flat }, { { 41, 37, 0 }, 22, Pitch::flat }, { { 42, 38, 0 }, 22, Pitch::flat }, { { 42, 39, 0 }, 22, Pitch::flat }, { { 43, 40, 0 }, 22, Pitch::flat }, { { 43, 41, 0 }, 20, Pitch::flat }, { { 44, 42, 0 }, 20, Pitch::flat }, { { 44, 43, 0 }, 20, Pitch::flat }, { { 45, 44, 0 }, 20, Pitch::flat }, { { 45, 45, 0 }, 20, Pitch::flat }, { { 45, 46, 0 }, 20, Pitch::flat }, { { 46, 47, 0 }, 20, Pitch::flat }, { { 46, 48, 0 }, 20, Pitch::flat }, { { 46, 49, 0 }, 20, Pitch::flat }, { { 47, 50, 0 }, 18, Pitch::flat }, { { 47, 51, 0 }, 18, Pitch::flat }, { { 47, 52, 0 }, 18, Pitch::flat }, { { 47, 53, 0 }, 18, Pitch::flat }, { { 47, 54, 0 }, 18, Pitch::flat }, { { 47, 55, 0 }, 18, Pitch::flat }, { { 48, 56, 0 }, 18, Pitch::flat }, { { 48, 57, 0 }, 18, Pitch::flat }, { { 48, 58, 0 }, 18, Pitch::flat }, { { 48, 59, 0 }, 16, Pitch::flat }, { { 48, 60, 0 }, 16, Pitch::flat }, { { 48, 61, 0 }, 16, Pitch::flat }, { { 48, 62, 0 }, 16, Pitch::flat }, }); // 0x4dff74 // Track 4. Reversed 0. Direction 3 static constexpr auto moveInfoT4R0D3 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 46, Pitch::flat }, { { 16, 26, 0 }, 46, Pitch::flat }, { { 17, 25, 0 }, 46, Pitch::flat }, { { 17, 24, 0 }, 46, Pitch::flat }, { { 17, 23, 0 }, 46, Pitch::flat }, { { 17, 22, 0 }, 46, Pitch::flat }, { { 17, 21, 0 }, 46, Pitch::flat }, { { 17, 20, 0 }, 46, Pitch::flat }, { { 18, 19, 0 }, 46, Pitch::flat }, { { 18, 18, 0 }, 44, Pitch::flat }, { { 18, 17, 0 }, 44, Pitch::flat }, { { 19, 16, 0 }, 44, Pitch::flat }, { { 19, 15, 0 }, 44, Pitch::flat }, { { 19, 14, 0 }, 44, Pitch::flat }, { { 20, 13, 0 }, 44, Pitch::flat }, { { 20, 12, 0 }, 44, Pitch::flat }, { { 21, 11, 0 }, 44, Pitch::flat }, { { 21, 10, 0 }, 44, Pitch::flat }, { { 22, 9, 0 }, 42, Pitch::flat }, { { 22, 8, 0 }, 42, Pitch::flat }, { { 23, 7, 0 }, 42, Pitch::flat }, { { 23, 6, 0 }, 42, Pitch::flat }, { { 24, 5, 0 }, 42, Pitch::flat }, { { 25, 4, 0 }, 42, Pitch::flat }, { { 25, 3, 0 }, 42, Pitch::flat }, { { 26, 2, 0 }, 42, Pitch::flat }, { { 27, 1, 0 }, 40, Pitch::flat }, { { 28, 0, 0 }, 40, Pitch::flat }, { { 29, -1, 0 }, 40, Pitch::flat }, { { 29, -3, 0 }, 40, Pitch::flat }, { { 30, -4, 0 }, 40, Pitch::flat }, { { 31, -5, 0 }, 40, Pitch::flat }, { { 32, -6, 0 }, 40, Pitch::flat }, { { 33, -7, 0 }, 38, Pitch::flat }, { { 34, -7, 0 }, 38, Pitch::flat }, { { 35, -8, 0 }, 38, Pitch::flat }, { { 36, -9, 0 }, 38, Pitch::flat }, { { 37, -9, 0 }, 38, Pitch::flat }, { { 38, -10, 0 }, 38, Pitch::flat }, { { 39, -10, 0 }, 38, Pitch::flat }, { { 40, -11, 0 }, 38, Pitch::flat }, { { 41, -11, 0 }, 36, Pitch::flat }, { { 42, -12, 0 }, 36, Pitch::flat }, { { 43, -12, 0 }, 36, Pitch::flat }, { { 44, -13, 0 }, 36, Pitch::flat }, { { 45, -13, 0 }, 36, Pitch::flat }, { { 46, -13, 0 }, 36, Pitch::flat }, { { 47, -14, 0 }, 36, Pitch::flat }, { { 48, -14, 0 }, 36, Pitch::flat }, { { 49, -14, 0 }, 36, Pitch::flat }, { { 50, -15, 0 }, 34, Pitch::flat }, { { 51, -15, 0 }, 34, Pitch::flat }, { { 52, -15, 0 }, 34, Pitch::flat }, { { 53, -15, 0 }, 34, Pitch::flat }, { { 54, -15, 0 }, 34, Pitch::flat }, { { 55, -15, 0 }, 34, Pitch::flat }, { { 56, -16, 0 }, 34, Pitch::flat }, { { 57, -16, 0 }, 34, Pitch::flat }, { { 58, -16, 0 }, 34, Pitch::flat }, { { 59, -16, 0 }, 32, Pitch::flat }, { { 60, -16, 0 }, 32, Pitch::flat }, { { 61, -16, 0 }, 32, Pitch::flat }, { { 62, -16, 0 }, 32, Pitch::flat }, }); // 0x4e03a8 // Track 4. Reversed 1. Direction 0 static constexpr auto moveInfoT4R1D0 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 18, Pitch::flat }, { { 16, 6, 0 }, 18, Pitch::flat }, { { 17, 7, 0 }, 18, Pitch::flat }, { { 17, 8, 0 }, 18, Pitch::flat }, { { 17, 9, 0 }, 18, Pitch::flat }, { { 17, 10, 0 }, 18, Pitch::flat }, { { 17, 11, 0 }, 18, Pitch::flat }, { { 17, 12, 0 }, 18, Pitch::flat }, { { 18, 13, 0 }, 18, Pitch::flat }, { { 18, 14, 0 }, 20, Pitch::flat }, { { 18, 15, 0 }, 20, Pitch::flat }, { { 19, 16, 0 }, 20, Pitch::flat }, { { 19, 17, 0 }, 20, Pitch::flat }, { { 19, 18, 0 }, 20, Pitch::flat }, { { 20, 19, 0 }, 20, Pitch::flat }, { { 20, 20, 0 }, 20, Pitch::flat }, { { 21, 21, 0 }, 20, Pitch::flat }, { { 21, 22, 0 }, 20, Pitch::flat }, { { 22, 23, 0 }, 22, Pitch::flat }, { { 22, 24, 0 }, 22, Pitch::flat }, { { 23, 25, 0 }, 22, Pitch::flat }, { { 23, 26, 0 }, 22, Pitch::flat }, { { 24, 27, 0 }, 22, Pitch::flat }, { { 25, 28, 0 }, 22, Pitch::flat }, { { 25, 29, 0 }, 22, Pitch::flat }, { { 26, 30, 0 }, 22, Pitch::flat }, { { 27, 31, 0 }, 24, Pitch::flat }, { { 28, 32, 0 }, 24, Pitch::flat }, { { 29, 33, 0 }, 24, Pitch::flat }, { { 29, 35, 0 }, 24, Pitch::flat }, { { 30, 36, 0 }, 24, Pitch::flat }, { { 31, 37, 0 }, 24, Pitch::flat }, { { 32, 38, 0 }, 24, Pitch::flat }, { { 33, 39, 0 }, 26, Pitch::flat }, { { 34, 39, 0 }, 26, Pitch::flat }, { { 35, 40, 0 }, 26, Pitch::flat }, { { 36, 41, 0 }, 26, Pitch::flat }, { { 37, 41, 0 }, 26, Pitch::flat }, { { 38, 42, 0 }, 26, Pitch::flat }, { { 39, 42, 0 }, 26, Pitch::flat }, { { 40, 43, 0 }, 26, Pitch::flat }, { { 41, 43, 0 }, 28, Pitch::flat }, { { 42, 44, 0 }, 28, Pitch::flat }, { { 43, 44, 0 }, 28, Pitch::flat }, { { 44, 45, 0 }, 28, Pitch::flat }, { { 45, 45, 0 }, 28, Pitch::flat }, { { 46, 45, 0 }, 28, Pitch::flat }, { { 47, 46, 0 }, 28, Pitch::flat }, { { 48, 46, 0 }, 28, Pitch::flat }, { { 49, 46, 0 }, 28, Pitch::flat }, { { 50, 47, 0 }, 30, Pitch::flat }, { { 51, 47, 0 }, 30, Pitch::flat }, { { 52, 47, 0 }, 30, Pitch::flat }, { { 53, 47, 0 }, 30, Pitch::flat }, { { 54, 47, 0 }, 30, Pitch::flat }, { { 55, 47, 0 }, 30, Pitch::flat }, { { 56, 48, 0 }, 30, Pitch::flat }, { { 57, 48, 0 }, 30, Pitch::flat }, { { 58, 48, 0 }, 30, Pitch::flat }, { { 59, 48, 0 }, 32, Pitch::flat }, { { 60, 48, 0 }, 32, Pitch::flat }, { { 61, 48, 0 }, 32, Pitch::flat }, { { 62, 48, 0 }, 32, Pitch::flat }, }); // 0x4e05ca // Track 4. Reversed 1. Direction 1 static constexpr auto moveInfoT4R1D1 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 34, Pitch::flat }, { { 6, 16, 0 }, 34, Pitch::flat }, { { 7, 15, 0 }, 34, Pitch::flat }, { { 8, 15, 0 }, 34, Pitch::flat }, { { 9, 15, 0 }, 34, Pitch::flat }, { { 10, 15, 0 }, 34, Pitch::flat }, { { 11, 15, 0 }, 34, Pitch::flat }, { { 12, 15, 0 }, 34, Pitch::flat }, { { 13, 14, 0 }, 34, Pitch::flat }, { { 14, 14, 0 }, 36, Pitch::flat }, { { 15, 14, 0 }, 36, Pitch::flat }, { { 16, 13, 0 }, 36, Pitch::flat }, { { 17, 13, 0 }, 36, Pitch::flat }, { { 18, 13, 0 }, 36, Pitch::flat }, { { 19, 12, 0 }, 36, Pitch::flat }, { { 20, 12, 0 }, 36, Pitch::flat }, { { 21, 11, 0 }, 36, Pitch::flat }, { { 22, 11, 0 }, 36, Pitch::flat }, { { 23, 10, 0 }, 38, Pitch::flat }, { { 24, 10, 0 }, 38, Pitch::flat }, { { 25, 9, 0 }, 38, Pitch::flat }, { { 26, 9, 0 }, 38, Pitch::flat }, { { 27, 8, 0 }, 38, Pitch::flat }, { { 28, 7, 0 }, 38, Pitch::flat }, { { 29, 7, 0 }, 38, Pitch::flat }, { { 30, 6, 0 }, 38, Pitch::flat }, { { 31, 5, 0 }, 40, Pitch::flat }, { { 32, 4, 0 }, 40, Pitch::flat }, { { 33, 3, 0 }, 40, Pitch::flat }, { { 35, 3, 0 }, 40, Pitch::flat }, { { 36, 2, 0 }, 40, Pitch::flat }, { { 37, 1, 0 }, 40, Pitch::flat }, { { 38, 0, 0 }, 40, Pitch::flat }, { { 39, -1, 0 }, 42, Pitch::flat }, { { 39, -2, 0 }, 42, Pitch::flat }, { { 40, -3, 0 }, 42, Pitch::flat }, { { 41, -4, 0 }, 42, Pitch::flat }, { { 41, -5, 0 }, 42, Pitch::flat }, { { 42, -6, 0 }, 42, Pitch::flat }, { { 42, -7, 0 }, 42, Pitch::flat }, { { 43, -8, 0 }, 42, Pitch::flat }, { { 43, -9, 0 }, 44, Pitch::flat }, { { 44, -10, 0 }, 44, Pitch::flat }, { { 44, -11, 0 }, 44, Pitch::flat }, { { 45, -12, 0 }, 44, Pitch::flat }, { { 45, -13, 0 }, 44, Pitch::flat }, { { 45, -14, 0 }, 44, Pitch::flat }, { { 46, -15, 0 }, 44, Pitch::flat }, { { 46, -16, 0 }, 44, Pitch::flat }, { { 46, -17, 0 }, 44, Pitch::flat }, { { 47, -18, 0 }, 46, Pitch::flat }, { { 47, -19, 0 }, 46, Pitch::flat }, { { 47, -20, 0 }, 46, Pitch::flat }, { { 47, -21, 0 }, 46, Pitch::flat }, { { 47, -22, 0 }, 46, Pitch::flat }, { { 47, -23, 0 }, 46, Pitch::flat }, { { 48, -24, 0 }, 46, Pitch::flat }, { { 48, -25, 0 }, 46, Pitch::flat }, { { 48, -26, 0 }, 46, Pitch::flat }, { { 48, -27, 0 }, 48, Pitch::flat }, { { 48, -28, 0 }, 48, Pitch::flat }, { { 48, -29, 0 }, 48, Pitch::flat }, { { 48, -30, 0 }, 48, Pitch::flat }, { { 48, -31, 0 }, 48, Pitch::flat }, }); // 0x4e07f4 // Track 4. Reversed 1. Direction 2 static constexpr auto moveInfoT4R1D2 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 50, Pitch::flat }, { { 16, 26, 0 }, 50, Pitch::flat }, { { 15, 25, 0 }, 50, Pitch::flat }, { { 15, 24, 0 }, 50, Pitch::flat }, { { 15, 23, 0 }, 50, Pitch::flat }, { { 15, 22, 0 }, 50, Pitch::flat }, { { 15, 21, 0 }, 50, Pitch::flat }, { { 15, 20, 0 }, 50, Pitch::flat }, { { 14, 19, 0 }, 50, Pitch::flat }, { { 14, 18, 0 }, 52, Pitch::flat }, { { 14, 17, 0 }, 52, Pitch::flat }, { { 13, 16, 0 }, 52, Pitch::flat }, { { 13, 15, 0 }, 52, Pitch::flat }, { { 13, 14, 0 }, 52, Pitch::flat }, { { 12, 13, 0 }, 52, Pitch::flat }, { { 12, 12, 0 }, 52, Pitch::flat }, { { 11, 11, 0 }, 52, Pitch::flat }, { { 11, 10, 0 }, 52, Pitch::flat }, { { 10, 9, 0 }, 54, Pitch::flat }, { { 10, 8, 0 }, 54, Pitch::flat }, { { 9, 7, 0 }, 54, Pitch::flat }, { { 9, 6, 0 }, 54, Pitch::flat }, { { 8, 5, 0 }, 54, Pitch::flat }, { { 7, 4, 0 }, 54, Pitch::flat }, { { 7, 3, 0 }, 54, Pitch::flat }, { { 6, 2, 0 }, 54, Pitch::flat }, { { 5, 1, 0 }, 56, Pitch::flat }, { { 4, 0, 0 }, 56, Pitch::flat }, { { 3, -1, 0 }, 56, Pitch::flat }, { { 3, -3, 0 }, 56, Pitch::flat }, { { 2, -4, 0 }, 56, Pitch::flat }, { { 1, -5, 0 }, 56, Pitch::flat }, { { 0, -6, 0 }, 56, Pitch::flat }, { { -1, -7, 0 }, 58, Pitch::flat }, { { -2, -7, 0 }, 58, Pitch::flat }, { { -3, -8, 0 }, 58, Pitch::flat }, { { -4, -9, 0 }, 58, Pitch::flat }, { { -5, -9, 0 }, 58, Pitch::flat }, { { -6, -10, 0 }, 58, Pitch::flat }, { { -7, -10, 0 }, 58, Pitch::flat }, { { -8, -11, 0 }, 58, Pitch::flat }, { { -9, -11, 0 }, 60, Pitch::flat }, { { -10, -12, 0 }, 60, Pitch::flat }, { { -11, -12, 0 }, 60, Pitch::flat }, { { -12, -13, 0 }, 60, Pitch::flat }, { { -13, -13, 0 }, 60, Pitch::flat }, { { -14, -13, 0 }, 60, Pitch::flat }, { { -15, -14, 0 }, 60, Pitch::flat }, { { -16, -14, 0 }, 60, Pitch::flat }, { { -17, -14, 0 }, 60, Pitch::flat }, { { -18, -15, 0 }, 62, Pitch::flat }, { { -19, -15, 0 }, 62, Pitch::flat }, { { -20, -15, 0 }, 62, Pitch::flat }, { { -21, -15, 0 }, 62, Pitch::flat }, { { -22, -15, 0 }, 62, Pitch::flat }, { { -23, -15, 0 }, 62, Pitch::flat }, { { -24, -16, 0 }, 62, Pitch::flat }, { { -25, -16, 0 }, 62, Pitch::flat }, { { -26, -16, 0 }, 62, Pitch::flat }, { { -27, -16, 0 }, 0, Pitch::flat }, { { -28, -16, 0 }, 0, Pitch::flat }, { { -29, -16, 0 }, 0, Pitch::flat }, { { -30, -16, 0 }, 0, Pitch::flat }, { { -31, -16, 0 }, 0, Pitch::flat }, }); // 0x4e018e // Track 4. Reversed 1. Direction 3 static constexpr auto moveInfoT4R1D3 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 2, Pitch::flat }, { { 26, 16, 0 }, 2, Pitch::flat }, { { 25, 17, 0 }, 2, Pitch::flat }, { { 24, 17, 0 }, 2, Pitch::flat }, { { 23, 17, 0 }, 2, Pitch::flat }, { { 22, 17, 0 }, 2, Pitch::flat }, { { 21, 17, 0 }, 2, Pitch::flat }, { { 20, 17, 0 }, 2, Pitch::flat }, { { 19, 18, 0 }, 2, Pitch::flat }, { { 18, 18, 0 }, 4, Pitch::flat }, { { 17, 18, 0 }, 4, Pitch::flat }, { { 16, 19, 0 }, 4, Pitch::flat }, { { 15, 19, 0 }, 4, Pitch::flat }, { { 14, 19, 0 }, 4, Pitch::flat }, { { 13, 20, 0 }, 4, Pitch::flat }, { { 12, 20, 0 }, 4, Pitch::flat }, { { 11, 21, 0 }, 4, Pitch::flat }, { { 10, 21, 0 }, 4, Pitch::flat }, { { 9, 22, 0 }, 6, Pitch::flat }, { { 8, 22, 0 }, 6, Pitch::flat }, { { 7, 23, 0 }, 6, Pitch::flat }, { { 6, 23, 0 }, 6, Pitch::flat }, { { 5, 24, 0 }, 6, Pitch::flat }, { { 4, 25, 0 }, 6, Pitch::flat }, { { 3, 25, 0 }, 6, Pitch::flat }, { { 2, 26, 0 }, 6, Pitch::flat }, { { 1, 27, 0 }, 8, Pitch::flat }, { { 0, 28, 0 }, 8, Pitch::flat }, { { -1, 29, 0 }, 8, Pitch::flat }, { { -3, 29, 0 }, 8, Pitch::flat }, { { -4, 30, 0 }, 8, Pitch::flat }, { { -5, 31, 0 }, 8, Pitch::flat }, { { -6, 32, 0 }, 8, Pitch::flat }, { { -7, 33, 0 }, 10, Pitch::flat }, { { -7, 34, 0 }, 10, Pitch::flat }, { { -8, 35, 0 }, 10, Pitch::flat }, { { -9, 36, 0 }, 10, Pitch::flat }, { { -9, 37, 0 }, 10, Pitch::flat }, { { -10, 38, 0 }, 10, Pitch::flat }, { { -10, 39, 0 }, 10, Pitch::flat }, { { -11, 40, 0 }, 10, Pitch::flat }, { { -11, 41, 0 }, 12, Pitch::flat }, { { -12, 42, 0 }, 12, Pitch::flat }, { { -12, 43, 0 }, 12, Pitch::flat }, { { -13, 44, 0 }, 12, Pitch::flat }, { { -13, 45, 0 }, 12, Pitch::flat }, { { -13, 46, 0 }, 12, Pitch::flat }, { { -14, 47, 0 }, 12, Pitch::flat }, { { -14, 48, 0 }, 12, Pitch::flat }, { { -14, 49, 0 }, 12, Pitch::flat }, { { -15, 50, 0 }, 14, Pitch::flat }, { { -15, 51, 0 }, 14, Pitch::flat }, { { -15, 52, 0 }, 14, Pitch::flat }, { { -15, 53, 0 }, 14, Pitch::flat }, { { -15, 54, 0 }, 14, Pitch::flat }, { { -15, 55, 0 }, 14, Pitch::flat }, { { -16, 56, 0 }, 14, Pitch::flat }, { { -16, 57, 0 }, 14, Pitch::flat }, { { -16, 58, 0 }, 14, Pitch::flat }, { { -16, 59, 0 }, 16, Pitch::flat }, { { -16, 60, 0 }, 16, Pitch::flat }, { { -16, 61, 0 }, 16, Pitch::flat }, { { -16, 62, 0 }, 16, Pitch::flat }, }); // 0x4e0a16 // Track 6. Reversed 0. Direction 0 static constexpr auto moveInfoT6R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 62, Pitch::flat }, { { 23, 15, 0 }, 62, Pitch::flat }, { { 22, 15, 0 }, 62, Pitch::flat }, { { 21, 15, 0 }, 62, Pitch::flat }, { { 20, 15, 0 }, 62, Pitch::flat }, { { 19, 15, 0 }, 62, Pitch::flat }, { { 18, 15, 0 }, 62, Pitch::flat }, { { 17, 14, 0 }, 62, Pitch::flat }, { { 16, 14, 0 }, 62, Pitch::flat }, { { 15, 14, 0 }, 62, Pitch::flat }, { { 14, 14, 0 }, 62, Pitch::flat }, { { 13, 14, 0 }, 62, Pitch::flat }, { { 12, 13, 0 }, 62, Pitch::flat }, { { 11, 13, 0 }, 62, Pitch::flat }, { { 10, 13, 0 }, 62, Pitch::flat }, { { 9, 13, 0 }, 62, Pitch::flat }, { { 8, 12, 0 }, 60, Pitch::flat }, { { 7, 12, 0 }, 60, Pitch::flat }, { { 6, 12, 0 }, 60, Pitch::flat }, { { 5, 11, 0 }, 60, Pitch::flat }, { { 4, 11, 0 }, 60, Pitch::flat }, { { 3, 11, 0 }, 60, Pitch::flat }, { { 2, 10, 0 }, 60, Pitch::flat }, { { 1, 10, 0 }, 60, Pitch::flat }, { { 0, 9, 0 }, 60, Pitch::flat }, { { -1, 9, 0 }, 60, Pitch::flat }, { { -2, 8, 0 }, 60, Pitch::flat }, { { -3, 8, 0 }, 60, Pitch::flat }, { { -4, 7, 0 }, 60, Pitch::flat }, { { -5, 7, 0 }, 60, Pitch::flat }, { { -6, 6, 0 }, 60, Pitch::flat }, { { -7, 6, 0 }, 58, Pitch::flat }, { { -8, 5, 0 }, 58, Pitch::flat }, { { -9, 4, 0 }, 58, Pitch::flat }, { { -10, 4, 0 }, 58, Pitch::flat }, { { -11, 3, 0 }, 58, Pitch::flat }, { { -12, 2, 0 }, 58, Pitch::flat }, { { -13, 2, 0 }, 58, Pitch::flat }, { { -14, 1, 0 }, 58, Pitch::flat }, { { -15, 0, 0 }, 58, Pitch::flat }, { { -16, 0, 0 }, 58, Pitch::flat }, { { -17, -1, 0 }, 58, Pitch::flat }, { { -18, -2, 0 }, 58, Pitch::flat }, { { -19, -3, 0 }, 56, Pitch::flat }, { { -20, -3, 0 }, 56, Pitch::flat }, { { -21, -4, 0 }, 56, Pitch::flat }, { { -22, -5, 0 }, 56, Pitch::flat }, { { -23, -6, 0 }, 56, Pitch::flat }, { { -24, -7, 0 }, 56, Pitch::flat }, { { -25, -7, 0 }, 56, Pitch::flat }, { { -26, -8, 0 }, 56, Pitch::flat }, { { -27, -9, 0 }, 56, Pitch::flat }, { { -28, -10, 0 }, 56, Pitch::flat }, { { -29, -11, 0 }, 56, Pitch::flat }, { { -29, -12, 0 }, 56, Pitch::flat }, { { -30, -13, 0 }, 54, Pitch::flat }, { { -31, -14, 0 }, 54, Pitch::flat }, { { -32, -15, 0 }, 54, Pitch::flat }, { { -32, -16, 0 }, 54, Pitch::flat }, { { -33, -17, 0 }, 54, Pitch::flat }, { { -34, -18, 0 }, 54, Pitch::flat }, { { -34, -19, 0 }, 54, Pitch::flat }, { { -35, -20, 0 }, 54, Pitch::flat }, { { -36, -21, 0 }, 54, Pitch::flat }, { { -36, -22, 0 }, 54, Pitch::flat }, { { -37, -23, 0 }, 54, Pitch::flat }, { { -38, -24, 0 }, 54, Pitch::flat }, { { -38, -25, 0 }, 52, Pitch::flat }, { { -39, -26, 0 }, 52, Pitch::flat }, { { -39, -27, 0 }, 52, Pitch::flat }, { { -40, -28, 0 }, 52, Pitch::flat }, { { -40, -29, 0 }, 52, Pitch::flat }, { { -41, -30, 0 }, 52, Pitch::flat }, { { -41, -31, 0 }, 52, Pitch::flat }, { { -42, -32, 0 }, 52, Pitch::flat }, { { -42, -33, 0 }, 52, Pitch::flat }, { { -43, -34, 0 }, 52, Pitch::flat }, { { -43, -35, 0 }, 52, Pitch::flat }, { { -43, -36, 0 }, 52, Pitch::flat }, { { -44, -37, 0 }, 52, Pitch::flat }, { { -44, -38, 0 }, 50, Pitch::flat }, { { -44, -39, 0 }, 50, Pitch::flat }, { { -45, -40, 0 }, 50, Pitch::flat }, { { -45, -41, 0 }, 50, Pitch::flat }, { { -45, -42, 0 }, 50, Pitch::flat }, { { -45, -43, 0 }, 50, Pitch::flat }, { { -46, -44, 0 }, 50, Pitch::flat }, { { -46, -45, 0 }, 50, Pitch::flat }, { { -46, -46, 0 }, 50, Pitch::flat }, { { -46, -47, 0 }, 50, Pitch::flat }, { { -46, -48, 0 }, 50, Pitch::flat }, { { -47, -49, 0 }, 50, Pitch::flat }, { { -47, -50, 0 }, 50, Pitch::flat }, { { -47, -51, 0 }, 50, Pitch::flat }, { { -47, -52, 0 }, 50, Pitch::flat }, { { -47, -53, 0 }, 50, Pitch::flat }, { { -47, -54, 0 }, 50, Pitch::flat }, { { -48, -55, 0 }, 50, Pitch::flat }, { { -48, -56, 0 }, 48, Pitch::flat }, { { -48, -57, 0 }, 48, Pitch::flat }, { { -48, -58, 0 }, 48, Pitch::flat }, { { -48, -59, 0 }, 48, Pitch::flat }, { { -48, -60, 0 }, 48, Pitch::flat }, { { -48, -61, 0 }, 48, Pitch::flat }, { { -48, -62, 0 }, 48, Pitch::flat }, { { -48, -63, 0 }, 48, Pitch::flat }, { { -48, -64, 0 }, 48, Pitch::flat }, }); // 0x4e0da8 // Track 6. Reversed 0. Direction 1 static constexpr auto moveInfoT6R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 14, Pitch::flat }, { { 15, 9, 0 }, 14, Pitch::flat }, { { 15, 10, 0 }, 14, Pitch::flat }, { { 15, 11, 0 }, 14, Pitch::flat }, { { 15, 12, 0 }, 14, Pitch::flat }, { { 15, 13, 0 }, 14, Pitch::flat }, { { 15, 14, 0 }, 14, Pitch::flat }, { { 14, 15, 0 }, 14, Pitch::flat }, { { 14, 16, 0 }, 14, Pitch::flat }, { { 14, 17, 0 }, 14, Pitch::flat }, { { 14, 18, 0 }, 14, Pitch::flat }, { { 14, 19, 0 }, 14, Pitch::flat }, { { 13, 20, 0 }, 14, Pitch::flat }, { { 13, 21, 0 }, 14, Pitch::flat }, { { 13, 22, 0 }, 14, Pitch::flat }, { { 13, 23, 0 }, 14, Pitch::flat }, { { 12, 24, 0 }, 12, Pitch::flat }, { { 12, 25, 0 }, 12, Pitch::flat }, { { 12, 26, 0 }, 12, Pitch::flat }, { { 11, 27, 0 }, 12, Pitch::flat }, { { 11, 28, 0 }, 12, Pitch::flat }, { { 11, 29, 0 }, 12, Pitch::flat }, { { 10, 30, 0 }, 12, Pitch::flat }, { { 10, 31, 0 }, 12, Pitch::flat }, { { 9, 32, 0 }, 12, Pitch::flat }, { { 9, 33, 0 }, 12, Pitch::flat }, { { 8, 34, 0 }, 12, Pitch::flat }, { { 8, 35, 0 }, 12, Pitch::flat }, { { 7, 36, 0 }, 12, Pitch::flat }, { { 7, 37, 0 }, 12, Pitch::flat }, { { 6, 38, 0 }, 12, Pitch::flat }, { { 6, 39, 0 }, 10, Pitch::flat }, { { 5, 40, 0 }, 10, Pitch::flat }, { { 4, 41, 0 }, 10, Pitch::flat }, { { 4, 42, 0 }, 10, Pitch::flat }, { { 3, 43, 0 }, 10, Pitch::flat }, { { 2, 44, 0 }, 10, Pitch::flat }, { { 2, 45, 0 }, 10, Pitch::flat }, { { 1, 46, 0 }, 10, Pitch::flat }, { { 0, 47, 0 }, 10, Pitch::flat }, { { 0, 48, 0 }, 10, Pitch::flat }, { { -1, 49, 0 }, 10, Pitch::flat }, { { -2, 50, 0 }, 10, Pitch::flat }, { { -3, 51, 0 }, 8, Pitch::flat }, { { -3, 52, 0 }, 8, Pitch::flat }, { { -4, 53, 0 }, 8, Pitch::flat }, { { -5, 54, 0 }, 8, Pitch::flat }, { { -6, 55, 0 }, 8, Pitch::flat }, { { -7, 56, 0 }, 8, Pitch::flat }, { { -7, 57, 0 }, 8, Pitch::flat }, { { -8, 58, 0 }, 8, Pitch::flat }, { { -9, 59, 0 }, 8, Pitch::flat }, { { -10, 60, 0 }, 8, Pitch::flat }, { { -11, 61, 0 }, 8, Pitch::flat }, { { -12, 61, 0 }, 8, Pitch::flat }, { { -13, 62, 0 }, 6, Pitch::flat }, { { -14, 63, 0 }, 6, Pitch::flat }, { { -15, 64, 0 }, 6, Pitch::flat }, { { -16, 64, 0 }, 6, Pitch::flat }, { { -17, 65, 0 }, 6, Pitch::flat }, { { -18, 66, 0 }, 6, Pitch::flat }, { { -19, 66, 0 }, 6, Pitch::flat }, { { -20, 67, 0 }, 6, Pitch::flat }, { { -21, 68, 0 }, 6, Pitch::flat }, { { -22, 68, 0 }, 6, Pitch::flat }, { { -23, 69, 0 }, 6, Pitch::flat }, { { -24, 70, 0 }, 6, Pitch::flat }, { { -25, 70, 0 }, 4, Pitch::flat }, { { -26, 71, 0 }, 4, Pitch::flat }, { { -27, 71, 0 }, 4, Pitch::flat }, { { -28, 72, 0 }, 4, Pitch::flat }, { { -29, 72, 0 }, 4, Pitch::flat }, { { -30, 73, 0 }, 4, Pitch::flat }, { { -31, 73, 0 }, 4, Pitch::flat }, { { -32, 74, 0 }, 4, Pitch::flat }, { { -33, 74, 0 }, 4, Pitch::flat }, { { -34, 75, 0 }, 4, Pitch::flat }, { { -35, 75, 0 }, 4, Pitch::flat }, { { -36, 75, 0 }, 4, Pitch::flat }, { { -37, 76, 0 }, 4, Pitch::flat }, { { -38, 76, 0 }, 2, Pitch::flat }, { { -39, 76, 0 }, 2, Pitch::flat }, { { -40, 77, 0 }, 2, Pitch::flat }, { { -41, 77, 0 }, 2, Pitch::flat }, { { -42, 77, 0 }, 2, Pitch::flat }, { { -43, 77, 0 }, 2, Pitch::flat }, { { -44, 78, 0 }, 2, Pitch::flat }, { { -45, 78, 0 }, 2, Pitch::flat }, { { -46, 78, 0 }, 2, Pitch::flat }, { { -47, 78, 0 }, 2, Pitch::flat }, { { -48, 78, 0 }, 2, Pitch::flat }, { { -49, 79, 0 }, 2, Pitch::flat }, { { -50, 79, 0 }, 2, Pitch::flat }, { { -51, 79, 0 }, 2, Pitch::flat }, { { -52, 79, 0 }, 2, Pitch::flat }, { { -53, 79, 0 }, 2, Pitch::flat }, { { -54, 79, 0 }, 2, Pitch::flat }, { { -55, 80, 0 }, 2, Pitch::flat }, { { -56, 80, 0 }, 0, Pitch::flat }, { { -57, 80, 0 }, 0, Pitch::flat }, { { -58, 80, 0 }, 0, Pitch::flat }, { { -59, 80, 0 }, 0, Pitch::flat }, { { -60, 80, 0 }, 0, Pitch::flat }, { { -61, 80, 0 }, 0, Pitch::flat }, { { -62, 80, 0 }, 0, Pitch::flat }, { { -63, 80, 0 }, 0, Pitch::flat }, { { -64, 80, 0 }, 0, Pitch::flat }, }); // 0x4e1142 // Track 6. Reversed 0. Direction 2 static constexpr auto moveInfoT6R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 30, Pitch::flat }, { { 9, 17, 0 }, 30, Pitch::flat }, { { 10, 17, 0 }, 30, Pitch::flat }, { { 11, 17, 0 }, 30, Pitch::flat }, { { 12, 17, 0 }, 30, Pitch::flat }, { { 13, 17, 0 }, 30, Pitch::flat }, { { 14, 17, 0 }, 30, Pitch::flat }, { { 15, 18, 0 }, 30, Pitch::flat }, { { 16, 18, 0 }, 30, Pitch::flat }, { { 17, 18, 0 }, 30, Pitch::flat }, { { 18, 18, 0 }, 30, Pitch::flat }, { { 19, 18, 0 }, 30, Pitch::flat }, { { 20, 19, 0 }, 30, Pitch::flat }, { { 21, 19, 0 }, 30, Pitch::flat }, { { 22, 19, 0 }, 30, Pitch::flat }, { { 23, 19, 0 }, 30, Pitch::flat }, { { 24, 20, 0 }, 28, Pitch::flat }, { { 25, 20, 0 }, 28, Pitch::flat }, { { 26, 20, 0 }, 28, Pitch::flat }, { { 27, 21, 0 }, 28, Pitch::flat }, { { 28, 21, 0 }, 28, Pitch::flat }, { { 29, 21, 0 }, 28, Pitch::flat }, { { 30, 22, 0 }, 28, Pitch::flat }, { { 31, 22, 0 }, 28, Pitch::flat }, { { 32, 23, 0 }, 28, Pitch::flat }, { { 33, 23, 0 }, 28, Pitch::flat }, { { 34, 24, 0 }, 28, Pitch::flat }, { { 35, 24, 0 }, 28, Pitch::flat }, { { 36, 25, 0 }, 28, Pitch::flat }, { { 37, 25, 0 }, 28, Pitch::flat }, { { 38, 26, 0 }, 28, Pitch::flat }, { { 39, 26, 0 }, 26, Pitch::flat }, { { 40, 27, 0 }, 26, Pitch::flat }, { { 41, 28, 0 }, 26, Pitch::flat }, { { 42, 28, 0 }, 26, Pitch::flat }, { { 43, 29, 0 }, 26, Pitch::flat }, { { 44, 30, 0 }, 26, Pitch::flat }, { { 45, 30, 0 }, 26, Pitch::flat }, { { 46, 31, 0 }, 26, Pitch::flat }, { { 47, 32, 0 }, 26, Pitch::flat }, { { 48, 32, 0 }, 26, Pitch::flat }, { { 49, 33, 0 }, 26, Pitch::flat }, { { 50, 34, 0 }, 26, Pitch::flat }, { { 51, 35, 0 }, 24, Pitch::flat }, { { 52, 35, 0 }, 24, Pitch::flat }, { { 53, 36, 0 }, 24, Pitch::flat }, { { 54, 37, 0 }, 24, Pitch::flat }, { { 55, 38, 0 }, 24, Pitch::flat }, { { 56, 39, 0 }, 24, Pitch::flat }, { { 57, 39, 0 }, 24, Pitch::flat }, { { 58, 40, 0 }, 24, Pitch::flat }, { { 59, 41, 0 }, 24, Pitch::flat }, { { 60, 42, 0 }, 24, Pitch::flat }, { { 61, 43, 0 }, 24, Pitch::flat }, { { 61, 44, 0 }, 24, Pitch::flat }, { { 62, 45, 0 }, 22, Pitch::flat }, { { 63, 46, 0 }, 22, Pitch::flat }, { { 64, 47, 0 }, 22, Pitch::flat }, { { 64, 48, 0 }, 22, Pitch::flat }, { { 65, 49, 0 }, 22, Pitch::flat }, { { 66, 50, 0 }, 22, Pitch::flat }, { { 66, 51, 0 }, 22, Pitch::flat }, { { 67, 52, 0 }, 22, Pitch::flat }, { { 68, 53, 0 }, 22, Pitch::flat }, { { 68, 54, 0 }, 22, Pitch::flat }, { { 69, 55, 0 }, 22, Pitch::flat }, { { 70, 56, 0 }, 22, Pitch::flat }, { { 70, 57, 0 }, 20, Pitch::flat }, { { 71, 58, 0 }, 20, Pitch::flat }, { { 71, 59, 0 }, 20, Pitch::flat }, { { 72, 60, 0 }, 20, Pitch::flat }, { { 72, 61, 0 }, 20, Pitch::flat }, { { 73, 62, 0 }, 20, Pitch::flat }, { { 73, 63, 0 }, 20, Pitch::flat }, { { 74, 64, 0 }, 20, Pitch::flat }, { { 74, 65, 0 }, 20, Pitch::flat }, { { 75, 66, 0 }, 20, Pitch::flat }, { { 75, 67, 0 }, 20, Pitch::flat }, { { 75, 68, 0 }, 20, Pitch::flat }, { { 76, 69, 0 }, 20, Pitch::flat }, { { 76, 70, 0 }, 18, Pitch::flat }, { { 76, 71, 0 }, 18, Pitch::flat }, { { 77, 72, 0 }, 18, Pitch::flat }, { { 77, 73, 0 }, 18, Pitch::flat }, { { 77, 74, 0 }, 18, Pitch::flat }, { { 77, 75, 0 }, 18, Pitch::flat }, { { 78, 76, 0 }, 18, Pitch::flat }, { { 78, 77, 0 }, 18, Pitch::flat }, { { 78, 78, 0 }, 18, Pitch::flat }, { { 78, 79, 0 }, 18, Pitch::flat }, { { 78, 80, 0 }, 18, Pitch::flat }, { { 79, 81, 0 }, 18, Pitch::flat }, { { 79, 82, 0 }, 18, Pitch::flat }, { { 79, 83, 0 }, 18, Pitch::flat }, { { 79, 84, 0 }, 18, Pitch::flat }, { { 79, 85, 0 }, 18, Pitch::flat }, { { 79, 86, 0 }, 18, Pitch::flat }, { { 80, 87, 0 }, 18, Pitch::flat }, { { 80, 88, 0 }, 16, Pitch::flat }, { { 80, 89, 0 }, 16, Pitch::flat }, { { 80, 90, 0 }, 16, Pitch::flat }, { { 80, 91, 0 }, 16, Pitch::flat }, { { 80, 92, 0 }, 16, Pitch::flat }, { { 80, 93, 0 }, 16, Pitch::flat }, { { 80, 94, 0 }, 16, Pitch::flat }, { { 80, 95, 0 }, 16, Pitch::flat }, }); // 0x4e14d4 // Track 6. Reversed 0. Direction 3 static constexpr auto moveInfoT6R0D3 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 46, Pitch::flat }, { { 17, 23, 0 }, 46, Pitch::flat }, { { 17, 22, 0 }, 46, Pitch::flat }, { { 17, 21, 0 }, 46, Pitch::flat }, { { 17, 20, 0 }, 46, Pitch::flat }, { { 17, 19, 0 }, 46, Pitch::flat }, { { 17, 18, 0 }, 46, Pitch::flat }, { { 18, 17, 0 }, 46, Pitch::flat }, { { 18, 16, 0 }, 46, Pitch::flat }, { { 18, 15, 0 }, 46, Pitch::flat }, { { 18, 14, 0 }, 46, Pitch::flat }, { { 18, 13, 0 }, 46, Pitch::flat }, { { 19, 12, 0 }, 46, Pitch::flat }, { { 19, 11, 0 }, 46, Pitch::flat }, { { 19, 10, 0 }, 46, Pitch::flat }, { { 19, 9, 0 }, 46, Pitch::flat }, { { 20, 8, 0 }, 44, Pitch::flat }, { { 20, 7, 0 }, 44, Pitch::flat }, { { 20, 6, 0 }, 44, Pitch::flat }, { { 21, 5, 0 }, 44, Pitch::flat }, { { 21, 4, 0 }, 44, Pitch::flat }, { { 21, 3, 0 }, 44, Pitch::flat }, { { 22, 2, 0 }, 44, Pitch::flat }, { { 22, 1, 0 }, 44, Pitch::flat }, { { 23, 0, 0 }, 44, Pitch::flat }, { { 23, -1, 0 }, 44, Pitch::flat }, { { 24, -2, 0 }, 44, Pitch::flat }, { { 24, -3, 0 }, 44, Pitch::flat }, { { 25, -4, 0 }, 44, Pitch::flat }, { { 25, -5, 0 }, 44, Pitch::flat }, { { 26, -6, 0 }, 44, Pitch::flat }, { { 26, -7, 0 }, 42, Pitch::flat }, { { 27, -8, 0 }, 42, Pitch::flat }, { { 28, -9, 0 }, 42, Pitch::flat }, { { 28, -10, 0 }, 42, Pitch::flat }, { { 29, -11, 0 }, 42, Pitch::flat }, { { 30, -12, 0 }, 42, Pitch::flat }, { { 30, -13, 0 }, 42, Pitch::flat }, { { 31, -14, 0 }, 42, Pitch::flat }, { { 32, -15, 0 }, 42, Pitch::flat }, { { 32, -16, 0 }, 42, Pitch::flat }, { { 33, -17, 0 }, 42, Pitch::flat }, { { 34, -18, 0 }, 42, Pitch::flat }, { { 35, -19, 0 }, 40, Pitch::flat }, { { 35, -20, 0 }, 40, Pitch::flat }, { { 36, -21, 0 }, 40, Pitch::flat }, { { 37, -22, 0 }, 40, Pitch::flat }, { { 38, -23, 0 }, 40, Pitch::flat }, { { 39, -24, 0 }, 40, Pitch::flat }, { { 39, -25, 0 }, 40, Pitch::flat }, { { 40, -26, 0 }, 40, Pitch::flat }, { { 41, -27, 0 }, 40, Pitch::flat }, { { 42, -28, 0 }, 40, Pitch::flat }, { { 43, -29, 0 }, 40, Pitch::flat }, { { 44, -29, 0 }, 40, Pitch::flat }, { { 45, -30, 0 }, 38, Pitch::flat }, { { 46, -31, 0 }, 38, Pitch::flat }, { { 47, -32, 0 }, 38, Pitch::flat }, { { 48, -32, 0 }, 38, Pitch::flat }, { { 49, -33, 0 }, 38, Pitch::flat }, { { 50, -34, 0 }, 38, Pitch::flat }, { { 51, -34, 0 }, 38, Pitch::flat }, { { 52, -35, 0 }, 38, Pitch::flat }, { { 53, -36, 0 }, 38, Pitch::flat }, { { 54, -36, 0 }, 38, Pitch::flat }, { { 55, -37, 0 }, 38, Pitch::flat }, { { 56, -38, 0 }, 38, Pitch::flat }, { { 57, -38, 0 }, 36, Pitch::flat }, { { 58, -39, 0 }, 36, Pitch::flat }, { { 59, -39, 0 }, 36, Pitch::flat }, { { 60, -40, 0 }, 36, Pitch::flat }, { { 61, -40, 0 }, 36, Pitch::flat }, { { 62, -41, 0 }, 36, Pitch::flat }, { { 63, -41, 0 }, 36, Pitch::flat }, { { 64, -42, 0 }, 36, Pitch::flat }, { { 65, -42, 0 }, 36, Pitch::flat }, { { 66, -43, 0 }, 36, Pitch::flat }, { { 67, -43, 0 }, 36, Pitch::flat }, { { 68, -43, 0 }, 36, Pitch::flat }, { { 69, -44, 0 }, 36, Pitch::flat }, { { 70, -44, 0 }, 34, Pitch::flat }, { { 71, -44, 0 }, 34, Pitch::flat }, { { 72, -45, 0 }, 34, Pitch::flat }, { { 73, -45, 0 }, 34, Pitch::flat }, { { 74, -45, 0 }, 34, Pitch::flat }, { { 75, -45, 0 }, 34, Pitch::flat }, { { 76, -46, 0 }, 34, Pitch::flat }, { { 77, -46, 0 }, 34, Pitch::flat }, { { 78, -46, 0 }, 34, Pitch::flat }, { { 79, -46, 0 }, 34, Pitch::flat }, { { 80, -46, 0 }, 34, Pitch::flat }, { { 81, -47, 0 }, 34, Pitch::flat }, { { 82, -47, 0 }, 34, Pitch::flat }, { { 83, -47, 0 }, 34, Pitch::flat }, { { 84, -47, 0 }, 34, Pitch::flat }, { { 85, -47, 0 }, 34, Pitch::flat }, { { 86, -47, 0 }, 34, Pitch::flat }, { { 87, -48, 0 }, 34, Pitch::flat }, { { 88, -48, 0 }, 32, Pitch::flat }, { { 89, -48, 0 }, 32, Pitch::flat }, { { 90, -48, 0 }, 32, Pitch::flat }, { { 91, -48, 0 }, 32, Pitch::flat }, { { 92, -48, 0 }, 32, Pitch::flat }, { { 93, -48, 0 }, 32, Pitch::flat }, { { 94, -48, 0 }, 32, Pitch::flat }, { { 95, -48, 0 }, 32, Pitch::flat }, }); // 0x4e1be8 // Track 6. Reversed 1. Direction 0 static constexpr auto moveInfoT6R1D0 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 18, Pitch::flat }, { { 17, 9, 0 }, 18, Pitch::flat }, { { 17, 10, 0 }, 18, Pitch::flat }, { { 17, 11, 0 }, 18, Pitch::flat }, { { 17, 12, 0 }, 18, Pitch::flat }, { { 17, 13, 0 }, 18, Pitch::flat }, { { 17, 14, 0 }, 18, Pitch::flat }, { { 18, 15, 0 }, 18, Pitch::flat }, { { 18, 16, 0 }, 18, Pitch::flat }, { { 18, 17, 0 }, 18, Pitch::flat }, { { 18, 18, 0 }, 18, Pitch::flat }, { { 18, 19, 0 }, 18, Pitch::flat }, { { 19, 20, 0 }, 18, Pitch::flat }, { { 19, 21, 0 }, 18, Pitch::flat }, { { 19, 22, 0 }, 18, Pitch::flat }, { { 19, 23, 0 }, 18, Pitch::flat }, { { 20, 24, 0 }, 20, Pitch::flat }, { { 20, 25, 0 }, 20, Pitch::flat }, { { 20, 26, 0 }, 20, Pitch::flat }, { { 21, 27, 0 }, 20, Pitch::flat }, { { 21, 28, 0 }, 20, Pitch::flat }, { { 21, 29, 0 }, 20, Pitch::flat }, { { 22, 30, 0 }, 20, Pitch::flat }, { { 22, 31, 0 }, 20, Pitch::flat }, { { 23, 32, 0 }, 20, Pitch::flat }, { { 23, 33, 0 }, 20, Pitch::flat }, { { 24, 34, 0 }, 20, Pitch::flat }, { { 24, 35, 0 }, 20, Pitch::flat }, { { 25, 36, 0 }, 20, Pitch::flat }, { { 25, 37, 0 }, 20, Pitch::flat }, { { 26, 38, 0 }, 20, Pitch::flat }, { { 26, 39, 0 }, 22, Pitch::flat }, { { 27, 40, 0 }, 22, Pitch::flat }, { { 28, 41, 0 }, 22, Pitch::flat }, { { 28, 42, 0 }, 22, Pitch::flat }, { { 29, 43, 0 }, 22, Pitch::flat }, { { 30, 44, 0 }, 22, Pitch::flat }, { { 30, 45, 0 }, 22, Pitch::flat }, { { 31, 46, 0 }, 22, Pitch::flat }, { { 32, 47, 0 }, 22, Pitch::flat }, { { 32, 48, 0 }, 22, Pitch::flat }, { { 33, 49, 0 }, 22, Pitch::flat }, { { 34, 50, 0 }, 22, Pitch::flat }, { { 35, 51, 0 }, 24, Pitch::flat }, { { 35, 52, 0 }, 24, Pitch::flat }, { { 36, 53, 0 }, 24, Pitch::flat }, { { 37, 54, 0 }, 24, Pitch::flat }, { { 38, 55, 0 }, 24, Pitch::flat }, { { 39, 56, 0 }, 24, Pitch::flat }, { { 39, 57, 0 }, 24, Pitch::flat }, { { 40, 58, 0 }, 24, Pitch::flat }, { { 41, 59, 0 }, 24, Pitch::flat }, { { 42, 60, 0 }, 24, Pitch::flat }, { { 43, 61, 0 }, 24, Pitch::flat }, { { 44, 61, 0 }, 24, Pitch::flat }, { { 45, 62, 0 }, 26, Pitch::flat }, { { 46, 63, 0 }, 26, Pitch::flat }, { { 47, 64, 0 }, 26, Pitch::flat }, { { 48, 64, 0 }, 26, Pitch::flat }, { { 49, 65, 0 }, 26, Pitch::flat }, { { 50, 66, 0 }, 26, Pitch::flat }, { { 51, 66, 0 }, 26, Pitch::flat }, { { 52, 67, 0 }, 26, Pitch::flat }, { { 53, 68, 0 }, 26, Pitch::flat }, { { 54, 68, 0 }, 26, Pitch::flat }, { { 55, 69, 0 }, 26, Pitch::flat }, { { 56, 70, 0 }, 26, Pitch::flat }, { { 57, 70, 0 }, 28, Pitch::flat }, { { 58, 71, 0 }, 28, Pitch::flat }, { { 59, 71, 0 }, 28, Pitch::flat }, { { 60, 72, 0 }, 28, Pitch::flat }, { { 61, 72, 0 }, 28, Pitch::flat }, { { 62, 73, 0 }, 28, Pitch::flat }, { { 63, 73, 0 }, 28, Pitch::flat }, { { 64, 74, 0 }, 28, Pitch::flat }, { { 65, 74, 0 }, 28, Pitch::flat }, { { 66, 75, 0 }, 28, Pitch::flat }, { { 67, 75, 0 }, 28, Pitch::flat }, { { 68, 75, 0 }, 28, Pitch::flat }, { { 69, 76, 0 }, 28, Pitch::flat }, { { 70, 76, 0 }, 30, Pitch::flat }, { { 71, 76, 0 }, 30, Pitch::flat }, { { 72, 77, 0 }, 30, Pitch::flat }, { { 73, 77, 0 }, 30, Pitch::flat }, { { 74, 77, 0 }, 30, Pitch::flat }, { { 75, 77, 0 }, 30, Pitch::flat }, { { 76, 78, 0 }, 30, Pitch::flat }, { { 77, 78, 0 }, 30, Pitch::flat }, { { 78, 78, 0 }, 30, Pitch::flat }, { { 79, 78, 0 }, 30, Pitch::flat }, { { 80, 78, 0 }, 30, Pitch::flat }, { { 81, 79, 0 }, 30, Pitch::flat }, { { 82, 79, 0 }, 30, Pitch::flat }, { { 83, 79, 0 }, 30, Pitch::flat }, { { 84, 79, 0 }, 30, Pitch::flat }, { { 85, 79, 0 }, 30, Pitch::flat }, { { 86, 79, 0 }, 30, Pitch::flat }, { { 87, 80, 0 }, 30, Pitch::flat }, { { 88, 80, 0 }, 32, Pitch::flat }, { { 89, 80, 0 }, 32, Pitch::flat }, { { 90, 80, 0 }, 32, Pitch::flat }, { { 91, 80, 0 }, 32, Pitch::flat }, { { 92, 80, 0 }, 32, Pitch::flat }, { { 93, 80, 0 }, 32, Pitch::flat }, { { 94, 80, 0 }, 32, Pitch::flat }, { { 95, 80, 0 }, 32, Pitch::flat }, }); // 0x4e1f7a // Track 6. Reversed 1. Direction 1 static constexpr auto moveInfoT6R1D1 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 34, Pitch::flat }, { { 9, 15, 0 }, 34, Pitch::flat }, { { 10, 15, 0 }, 34, Pitch::flat }, { { 11, 15, 0 }, 34, Pitch::flat }, { { 12, 15, 0 }, 34, Pitch::flat }, { { 13, 15, 0 }, 34, Pitch::flat }, { { 14, 15, 0 }, 34, Pitch::flat }, { { 15, 14, 0 }, 34, Pitch::flat }, { { 16, 14, 0 }, 34, Pitch::flat }, { { 17, 14, 0 }, 34, Pitch::flat }, { { 18, 14, 0 }, 34, Pitch::flat }, { { 19, 14, 0 }, 34, Pitch::flat }, { { 20, 13, 0 }, 34, Pitch::flat }, { { 21, 13, 0 }, 34, Pitch::flat }, { { 22, 13, 0 }, 34, Pitch::flat }, { { 23, 13, 0 }, 34, Pitch::flat }, { { 24, 12, 0 }, 36, Pitch::flat }, { { 25, 12, 0 }, 36, Pitch::flat }, { { 26, 12, 0 }, 36, Pitch::flat }, { { 27, 11, 0 }, 36, Pitch::flat }, { { 28, 11, 0 }, 36, Pitch::flat }, { { 29, 11, 0 }, 36, Pitch::flat }, { { 30, 10, 0 }, 36, Pitch::flat }, { { 31, 10, 0 }, 36, Pitch::flat }, { { 32, 9, 0 }, 36, Pitch::flat }, { { 33, 9, 0 }, 36, Pitch::flat }, { { 34, 8, 0 }, 36, Pitch::flat }, { { 35, 8, 0 }, 36, Pitch::flat }, { { 36, 7, 0 }, 36, Pitch::flat }, { { 37, 7, 0 }, 36, Pitch::flat }, { { 38, 6, 0 }, 36, Pitch::flat }, { { 39, 6, 0 }, 38, Pitch::flat }, { { 40, 5, 0 }, 38, Pitch::flat }, { { 41, 4, 0 }, 38, Pitch::flat }, { { 42, 4, 0 }, 38, Pitch::flat }, { { 43, 3, 0 }, 38, Pitch::flat }, { { 44, 2, 0 }, 38, Pitch::flat }, { { 45, 2, 0 }, 38, Pitch::flat }, { { 46, 1, 0 }, 38, Pitch::flat }, { { 47, 0, 0 }, 38, Pitch::flat }, { { 48, 0, 0 }, 38, Pitch::flat }, { { 49, -1, 0 }, 38, Pitch::flat }, { { 50, -2, 0 }, 38, Pitch::flat }, { { 51, -3, 0 }, 40, Pitch::flat }, { { 52, -3, 0 }, 40, Pitch::flat }, { { 53, -4, 0 }, 40, Pitch::flat }, { { 54, -5, 0 }, 40, Pitch::flat }, { { 55, -6, 0 }, 40, Pitch::flat }, { { 56, -7, 0 }, 40, Pitch::flat }, { { 57, -7, 0 }, 40, Pitch::flat }, { { 58, -8, 0 }, 40, Pitch::flat }, { { 59, -9, 0 }, 40, Pitch::flat }, { { 60, -10, 0 }, 40, Pitch::flat }, { { 61, -11, 0 }, 40, Pitch::flat }, { { 61, -12, 0 }, 40, Pitch::flat }, { { 62, -13, 0 }, 42, Pitch::flat }, { { 63, -14, 0 }, 42, Pitch::flat }, { { 64, -15, 0 }, 42, Pitch::flat }, { { 64, -16, 0 }, 42, Pitch::flat }, { { 65, -17, 0 }, 42, Pitch::flat }, { { 66, -18, 0 }, 42, Pitch::flat }, { { 66, -19, 0 }, 42, Pitch::flat }, { { 67, -20, 0 }, 42, Pitch::flat }, { { 68, -21, 0 }, 42, Pitch::flat }, { { 68, -22, 0 }, 42, Pitch::flat }, { { 69, -23, 0 }, 42, Pitch::flat }, { { 70, -24, 0 }, 42, Pitch::flat }, { { 70, -25, 0 }, 44, Pitch::flat }, { { 71, -26, 0 }, 44, Pitch::flat }, { { 71, -27, 0 }, 44, Pitch::flat }, { { 72, -28, 0 }, 44, Pitch::flat }, { { 72, -29, 0 }, 44, Pitch::flat }, { { 73, -30, 0 }, 44, Pitch::flat }, { { 73, -31, 0 }, 44, Pitch::flat }, { { 74, -32, 0 }, 44, Pitch::flat }, { { 74, -33, 0 }, 44, Pitch::flat }, { { 75, -34, 0 }, 44, Pitch::flat }, { { 75, -35, 0 }, 44, Pitch::flat }, { { 75, -36, 0 }, 44, Pitch::flat }, { { 76, -37, 0 }, 44, Pitch::flat }, { { 76, -38, 0 }, 46, Pitch::flat }, { { 76, -39, 0 }, 46, Pitch::flat }, { { 77, -40, 0 }, 46, Pitch::flat }, { { 77, -41, 0 }, 46, Pitch::flat }, { { 77, -42, 0 }, 46, Pitch::flat }, { { 77, -43, 0 }, 46, Pitch::flat }, { { 78, -44, 0 }, 46, Pitch::flat }, { { 78, -45, 0 }, 46, Pitch::flat }, { { 78, -46, 0 }, 46, Pitch::flat }, { { 78, -47, 0 }, 46, Pitch::flat }, { { 78, -48, 0 }, 46, Pitch::flat }, { { 79, -49, 0 }, 46, Pitch::flat }, { { 79, -50, 0 }, 46, Pitch::flat }, { { 79, -51, 0 }, 46, Pitch::flat }, { { 79, -52, 0 }, 46, Pitch::flat }, { { 79, -53, 0 }, 46, Pitch::flat }, { { 79, -54, 0 }, 46, Pitch::flat }, { { 80, -55, 0 }, 46, Pitch::flat }, { { 80, -56, 0 }, 48, Pitch::flat }, { { 80, -57, 0 }, 48, Pitch::flat }, { { 80, -58, 0 }, 48, Pitch::flat }, { { 80, -59, 0 }, 48, Pitch::flat }, { { 80, -60, 0 }, 48, Pitch::flat }, { { 80, -61, 0 }, 48, Pitch::flat }, { { 80, -62, 0 }, 48, Pitch::flat }, { { 80, -63, 0 }, 48, Pitch::flat }, { { 80, -64, 0 }, 48, Pitch::flat }, }); // 0x4e2314 // Track 6. Reversed 1. Direction 2 static constexpr auto moveInfoT6R1D2 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 50, Pitch::flat }, { { 15, 23, 0 }, 50, Pitch::flat }, { { 15, 22, 0 }, 50, Pitch::flat }, { { 15, 21, 0 }, 50, Pitch::flat }, { { 15, 20, 0 }, 50, Pitch::flat }, { { 15, 19, 0 }, 50, Pitch::flat }, { { 15, 18, 0 }, 50, Pitch::flat }, { { 14, 17, 0 }, 50, Pitch::flat }, { { 14, 16, 0 }, 50, Pitch::flat }, { { 14, 15, 0 }, 50, Pitch::flat }, { { 14, 14, 0 }, 50, Pitch::flat }, { { 14, 13, 0 }, 50, Pitch::flat }, { { 13, 12, 0 }, 50, Pitch::flat }, { { 13, 11, 0 }, 50, Pitch::flat }, { { 13, 10, 0 }, 50, Pitch::flat }, { { 13, 9, 0 }, 50, Pitch::flat }, { { 12, 8, 0 }, 52, Pitch::flat }, { { 12, 7, 0 }, 52, Pitch::flat }, { { 12, 6, 0 }, 52, Pitch::flat }, { { 11, 5, 0 }, 52, Pitch::flat }, { { 11, 4, 0 }, 52, Pitch::flat }, { { 11, 3, 0 }, 52, Pitch::flat }, { { 10, 2, 0 }, 52, Pitch::flat }, { { 10, 1, 0 }, 52, Pitch::flat }, { { 9, 0, 0 }, 52, Pitch::flat }, { { 9, -1, 0 }, 52, Pitch::flat }, { { 8, -2, 0 }, 52, Pitch::flat }, { { 8, -3, 0 }, 52, Pitch::flat }, { { 7, -4, 0 }, 52, Pitch::flat }, { { 7, -5, 0 }, 52, Pitch::flat }, { { 6, -6, 0 }, 52, Pitch::flat }, { { 6, -7, 0 }, 54, Pitch::flat }, { { 5, -8, 0 }, 54, Pitch::flat }, { { 4, -9, 0 }, 54, Pitch::flat }, { { 4, -10, 0 }, 54, Pitch::flat }, { { 3, -11, 0 }, 54, Pitch::flat }, { { 2, -12, 0 }, 54, Pitch::flat }, { { 2, -13, 0 }, 54, Pitch::flat }, { { 1, -14, 0 }, 54, Pitch::flat }, { { 0, -15, 0 }, 54, Pitch::flat }, { { 0, -16, 0 }, 54, Pitch::flat }, { { -1, -17, 0 }, 54, Pitch::flat }, { { -2, -18, 0 }, 54, Pitch::flat }, { { -3, -19, 0 }, 56, Pitch::flat }, { { -3, -20, 0 }, 56, Pitch::flat }, { { -4, -21, 0 }, 56, Pitch::flat }, { { -5, -22, 0 }, 56, Pitch::flat }, { { -6, -23, 0 }, 56, Pitch::flat }, { { -7, -24, 0 }, 56, Pitch::flat }, { { -7, -25, 0 }, 56, Pitch::flat }, { { -8, -26, 0 }, 56, Pitch::flat }, { { -9, -27, 0 }, 56, Pitch::flat }, { { -10, -28, 0 }, 56, Pitch::flat }, { { -11, -29, 0 }, 56, Pitch::flat }, { { -12, -29, 0 }, 56, Pitch::flat }, { { -13, -30, 0 }, 58, Pitch::flat }, { { -14, -31, 0 }, 58, Pitch::flat }, { { -15, -32, 0 }, 58, Pitch::flat }, { { -16, -32, 0 }, 58, Pitch::flat }, { { -17, -33, 0 }, 58, Pitch::flat }, { { -18, -34, 0 }, 58, Pitch::flat }, { { -19, -34, 0 }, 58, Pitch::flat }, { { -20, -35, 0 }, 58, Pitch::flat }, { { -21, -36, 0 }, 58, Pitch::flat }, { { -22, -36, 0 }, 58, Pitch::flat }, { { -23, -37, 0 }, 58, Pitch::flat }, { { -24, -38, 0 }, 58, Pitch::flat }, { { -25, -38, 0 }, 60, Pitch::flat }, { { -26, -39, 0 }, 60, Pitch::flat }, { { -27, -39, 0 }, 60, Pitch::flat }, { { -28, -40, 0 }, 60, Pitch::flat }, { { -29, -40, 0 }, 60, Pitch::flat }, { { -30, -41, 0 }, 60, Pitch::flat }, { { -31, -41, 0 }, 60, Pitch::flat }, { { -32, -42, 0 }, 60, Pitch::flat }, { { -33, -42, 0 }, 60, Pitch::flat }, { { -34, -43, 0 }, 60, Pitch::flat }, { { -35, -43, 0 }, 60, Pitch::flat }, { { -36, -43, 0 }, 60, Pitch::flat }, { { -37, -44, 0 }, 60, Pitch::flat }, { { -38, -44, 0 }, 62, Pitch::flat }, { { -39, -44, 0 }, 62, Pitch::flat }, { { -40, -45, 0 }, 62, Pitch::flat }, { { -41, -45, 0 }, 62, Pitch::flat }, { { -42, -45, 0 }, 62, Pitch::flat }, { { -43, -45, 0 }, 62, Pitch::flat }, { { -44, -46, 0 }, 62, Pitch::flat }, { { -45, -46, 0 }, 62, Pitch::flat }, { { -46, -46, 0 }, 62, Pitch::flat }, { { -47, -46, 0 }, 62, Pitch::flat }, { { -48, -46, 0 }, 62, Pitch::flat }, { { -49, -47, 0 }, 62, Pitch::flat }, { { -50, -47, 0 }, 62, Pitch::flat }, { { -51, -47, 0 }, 62, Pitch::flat }, { { -52, -47, 0 }, 62, Pitch::flat }, { { -53, -47, 0 }, 62, Pitch::flat }, { { -54, -47, 0 }, 62, Pitch::flat }, { { -55, -48, 0 }, 62, Pitch::flat }, { { -56, -48, 0 }, 0, Pitch::flat }, { { -57, -48, 0 }, 0, Pitch::flat }, { { -58, -48, 0 }, 0, Pitch::flat }, { { -59, -48, 0 }, 0, Pitch::flat }, { { -60, -48, 0 }, 0, Pitch::flat }, { { -61, -48, 0 }, 0, Pitch::flat }, { { -62, -48, 0 }, 0, Pitch::flat }, { { -63, -48, 0 }, 0, Pitch::flat }, { { -64, -48, 0 }, 0, Pitch::flat }, }); // 0x4e185e // Track 6. Reversed 1. Direction 3 static constexpr auto moveInfoT6R1D3 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 2, Pitch::flat }, { { 23, 17, 0 }, 2, Pitch::flat }, { { 22, 17, 0 }, 2, Pitch::flat }, { { 21, 17, 0 }, 2, Pitch::flat }, { { 20, 17, 0 }, 2, Pitch::flat }, { { 19, 17, 0 }, 2, Pitch::flat }, { { 18, 17, 0 }, 2, Pitch::flat }, { { 17, 18, 0 }, 2, Pitch::flat }, { { 16, 18, 0 }, 2, Pitch::flat }, { { 15, 18, 0 }, 2, Pitch::flat }, { { 14, 18, 0 }, 2, Pitch::flat }, { { 13, 18, 0 }, 2, Pitch::flat }, { { 12, 19, 0 }, 2, Pitch::flat }, { { 11, 19, 0 }, 2, Pitch::flat }, { { 10, 19, 0 }, 2, Pitch::flat }, { { 9, 19, 0 }, 2, Pitch::flat }, { { 8, 20, 0 }, 4, Pitch::flat }, { { 7, 20, 0 }, 4, Pitch::flat }, { { 6, 20, 0 }, 4, Pitch::flat }, { { 5, 21, 0 }, 4, Pitch::flat }, { { 4, 21, 0 }, 4, Pitch::flat }, { { 3, 21, 0 }, 4, Pitch::flat }, { { 2, 22, 0 }, 4, Pitch::flat }, { { 1, 22, 0 }, 4, Pitch::flat }, { { 0, 23, 0 }, 4, Pitch::flat }, { { -1, 23, 0 }, 4, Pitch::flat }, { { -2, 24, 0 }, 4, Pitch::flat }, { { -3, 24, 0 }, 4, Pitch::flat }, { { -4, 25, 0 }, 4, Pitch::flat }, { { -5, 25, 0 }, 4, Pitch::flat }, { { -6, 26, 0 }, 4, Pitch::flat }, { { -7, 26, 0 }, 6, Pitch::flat }, { { -8, 27, 0 }, 6, Pitch::flat }, { { -9, 28, 0 }, 6, Pitch::flat }, { { -10, 28, 0 }, 6, Pitch::flat }, { { -11, 29, 0 }, 6, Pitch::flat }, { { -12, 30, 0 }, 6, Pitch::flat }, { { -13, 30, 0 }, 6, Pitch::flat }, { { -14, 31, 0 }, 6, Pitch::flat }, { { -15, 32, 0 }, 6, Pitch::flat }, { { -16, 32, 0 }, 6, Pitch::flat }, { { -17, 33, 0 }, 6, Pitch::flat }, { { -18, 34, 0 }, 6, Pitch::flat }, { { -19, 35, 0 }, 8, Pitch::flat }, { { -20, 35, 0 }, 8, Pitch::flat }, { { -21, 36, 0 }, 8, Pitch::flat }, { { -22, 37, 0 }, 8, Pitch::flat }, { { -23, 38, 0 }, 8, Pitch::flat }, { { -24, 39, 0 }, 8, Pitch::flat }, { { -25, 39, 0 }, 8, Pitch::flat }, { { -26, 40, 0 }, 8, Pitch::flat }, { { -27, 41, 0 }, 8, Pitch::flat }, { { -28, 42, 0 }, 8, Pitch::flat }, { { -29, 43, 0 }, 8, Pitch::flat }, { { -29, 44, 0 }, 8, Pitch::flat }, { { -30, 45, 0 }, 10, Pitch::flat }, { { -31, 46, 0 }, 10, Pitch::flat }, { { -32, 47, 0 }, 10, Pitch::flat }, { { -32, 48, 0 }, 10, Pitch::flat }, { { -33, 49, 0 }, 10, Pitch::flat }, { { -34, 50, 0 }, 10, Pitch::flat }, { { -34, 51, 0 }, 10, Pitch::flat }, { { -35, 52, 0 }, 10, Pitch::flat }, { { -36, 53, 0 }, 10, Pitch::flat }, { { -36, 54, 0 }, 10, Pitch::flat }, { { -37, 55, 0 }, 10, Pitch::flat }, { { -38, 56, 0 }, 10, Pitch::flat }, { { -38, 57, 0 }, 12, Pitch::flat }, { { -39, 58, 0 }, 12, Pitch::flat }, { { -39, 59, 0 }, 12, Pitch::flat }, { { -40, 60, 0 }, 12, Pitch::flat }, { { -40, 61, 0 }, 12, Pitch::flat }, { { -41, 62, 0 }, 12, Pitch::flat }, { { -41, 63, 0 }, 12, Pitch::flat }, { { -42, 64, 0 }, 12, Pitch::flat }, { { -42, 65, 0 }, 12, Pitch::flat }, { { -43, 66, 0 }, 12, Pitch::flat }, { { -43, 67, 0 }, 12, Pitch::flat }, { { -43, 68, 0 }, 12, Pitch::flat }, { { -44, 69, 0 }, 12, Pitch::flat }, { { -44, 70, 0 }, 14, Pitch::flat }, { { -44, 71, 0 }, 14, Pitch::flat }, { { -45, 72, 0 }, 14, Pitch::flat }, { { -45, 73, 0 }, 14, Pitch::flat }, { { -45, 74, 0 }, 14, Pitch::flat }, { { -45, 75, 0 }, 14, Pitch::flat }, { { -46, 76, 0 }, 14, Pitch::flat }, { { -46, 77, 0 }, 14, Pitch::flat }, { { -46, 78, 0 }, 14, Pitch::flat }, { { -46, 79, 0 }, 14, Pitch::flat }, { { -46, 80, 0 }, 14, Pitch::flat }, { { -47, 81, 0 }, 14, Pitch::flat }, { { -47, 82, 0 }, 14, Pitch::flat }, { { -47, 83, 0 }, 14, Pitch::flat }, { { -47, 84, 0 }, 14, Pitch::flat }, { { -47, 85, 0 }, 14, Pitch::flat }, { { -47, 86, 0 }, 14, Pitch::flat }, { { -48, 87, 0 }, 14, Pitch::flat }, { { -48, 88, 0 }, 16, Pitch::flat }, { { -48, 89, 0 }, 16, Pitch::flat }, { { -48, 90, 0 }, 16, Pitch::flat }, { { -48, 91, 0 }, 16, Pitch::flat }, { { -48, 92, 0 }, 16, Pitch::flat }, { { -48, 93, 0 }, 16, Pitch::flat }, { { -48, 94, 0 }, 16, Pitch::flat }, { { -48, 95, 0 }, 16, Pitch::flat }, }); // 0x4e26a6 // Track 8. Reversed 0. Direction 0 static constexpr auto moveInfoT8R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 0, Pitch::flat }, { { 23, 16, 0 }, 0, Pitch::flat }, { { 22, 16, 0 }, 0, Pitch::flat }, { { 21, 16, 0 }, 62, Pitch::flat }, { { 20, 16, 0 }, 62, Pitch::flat }, { { 19, 15, 0 }, 62, Pitch::flat }, { { 18, 15, 0 }, 62, Pitch::flat }, { { 17, 15, 0 }, 62, Pitch::flat }, { { 16, 15, 0 }, 62, Pitch::flat }, { { 15, 15, 0 }, 62, Pitch::flat }, { { 14, 14, 0 }, 62, Pitch::flat }, { { 13, 14, 0 }, 62, Pitch::flat }, { { 12, 14, 0 }, 62, Pitch::flat }, { { 11, 14, 0 }, 62, Pitch::flat }, { { 10, 14, 0 }, 62, Pitch::flat }, { { 9, 13, 0 }, 62, Pitch::flat }, { { 8, 13, 0 }, 62, Pitch::flat }, { { 7, 13, 0 }, 62, Pitch::flat }, { { 6, 13, 0 }, 62, Pitch::flat }, { { 5, 13, 0 }, 62, Pitch::flat }, { { 4, 12, 0 }, 62, Pitch::flat }, { { 3, 12, 0 }, 62, Pitch::flat }, { { 2, 12, 0 }, 62, Pitch::flat }, { { 1, 12, 0 }, 62, Pitch::flat }, { { 0, 11, 0 }, 60, Pitch::flat }, { { -1, 11, 0 }, 60, Pitch::flat }, { { -2, 11, 0 }, 60, Pitch::flat }, { { -3, 11, 0 }, 60, Pitch::flat }, { { -4, 10, 0 }, 60, Pitch::flat }, { { -5, 10, 0 }, 60, Pitch::flat }, { { -6, 10, 0 }, 60, Pitch::flat }, { { -7, 9, 0 }, 60, Pitch::flat }, { { -8, 9, 0 }, 60, Pitch::flat }, { { -9, 9, 0 }, 60, Pitch::flat }, { { -10, 8, 0 }, 60, Pitch::flat }, { { -11, 8, 0 }, 60, Pitch::flat }, { { -12, 8, 0 }, 60, Pitch::flat }, { { -13, 7, 0 }, 60, Pitch::flat }, { { -14, 7, 0 }, 60, Pitch::flat }, { { -15, 6, 0 }, 60, Pitch::flat }, { { -16, 6, 0 }, 60, Pitch::flat }, { { -17, 5, 0 }, 60, Pitch::flat }, { { -18, 5, 0 }, 60, Pitch::flat }, { { -19, 4, 0 }, 60, Pitch::flat }, { { -20, 4, 0 }, 60, Pitch::flat }, { { -21, 3, 0 }, 58, Pitch::flat }, { { -22, 3, 0 }, 58, Pitch::flat }, { { -23, 2, 0 }, 58, Pitch::flat }, { { -24, 2, 0 }, 58, Pitch::flat }, { { -25, 1, 0 }, 58, Pitch::flat }, { { -26, 0, 0 }, 58, Pitch::flat }, { { -27, 0, 0 }, 58, Pitch::flat }, { { -28, -1, 0 }, 58, Pitch::flat }, { { -29, -2, 0 }, 58, Pitch::flat }, { { -30, -2, 0 }, 58, Pitch::flat }, { { -31, -3, 0 }, 58, Pitch::flat }, { { -32, -4, 0 }, 58, Pitch::flat }, { { -33, -4, 0 }, 58, Pitch::flat }, { { -34, -5, 0 }, 58, Pitch::flat }, { { -35, -6, 0 }, 58, Pitch::flat }, { { -36, -7, 0 }, 58, Pitch::flat }, { { -37, -7, 0 }, 58, Pitch::flat }, { { -38, -8, 0 }, 58, Pitch::flat }, { { -39, -9, 0 }, 56, Pitch::flat }, { { -40, -10, 0 }, 56, Pitch::flat }, { { -41, -11, 0 }, 56, Pitch::flat }, { { -42, -12, 0 }, 56, Pitch::flat }, { { -43, -12, 0 }, 56, Pitch::flat }, { { -44, -13, 0 }, 56, Pitch::flat }, { { -45, -14, 0 }, 56, Pitch::flat }, { { -46, -15, 0 }, 56, Pitch::flat }, { { -47, -16, 0 }, 56, Pitch::flat }, }); // 0x4e2920 // Track 8. Reversed 0. Direction 1 static constexpr auto moveInfoT8R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 16, Pitch::flat }, { { 16, 9, 0 }, 16, Pitch::flat }, { { 16, 10, 0 }, 16, Pitch::flat }, { { 16, 11, 0 }, 14, Pitch::flat }, { { 16, 12, 0 }, 14, Pitch::flat }, { { 15, 13, 0 }, 14, Pitch::flat }, { { 15, 14, 0 }, 14, Pitch::flat }, { { 15, 15, 0 }, 14, Pitch::flat }, { { 15, 16, 0 }, 14, Pitch::flat }, { { 15, 17, 0 }, 14, Pitch::flat }, { { 14, 18, 0 }, 14, Pitch::flat }, { { 14, 19, 0 }, 14, Pitch::flat }, { { 14, 20, 0 }, 14, Pitch::flat }, { { 14, 21, 0 }, 14, Pitch::flat }, { { 14, 22, 0 }, 14, Pitch::flat }, { { 13, 23, 0 }, 14, Pitch::flat }, { { 13, 24, 0 }, 14, Pitch::flat }, { { 13, 25, 0 }, 14, Pitch::flat }, { { 13, 26, 0 }, 14, Pitch::flat }, { { 13, 27, 0 }, 14, Pitch::flat }, { { 12, 28, 0 }, 14, Pitch::flat }, { { 12, 29, 0 }, 14, Pitch::flat }, { { 12, 30, 0 }, 14, Pitch::flat }, { { 12, 31, 0 }, 14, Pitch::flat }, { { 11, 32, 0 }, 12, Pitch::flat }, { { 11, 33, 0 }, 12, Pitch::flat }, { { 11, 34, 0 }, 12, Pitch::flat }, { { 11, 35, 0 }, 12, Pitch::flat }, { { 10, 36, 0 }, 12, Pitch::flat }, { { 10, 37, 0 }, 12, Pitch::flat }, { { 10, 38, 0 }, 12, Pitch::flat }, { { 9, 39, 0 }, 12, Pitch::flat }, { { 9, 40, 0 }, 12, Pitch::flat }, { { 9, 41, 0 }, 12, Pitch::flat }, { { 8, 42, 0 }, 12, Pitch::flat }, { { 8, 43, 0 }, 12, Pitch::flat }, { { 8, 44, 0 }, 12, Pitch::flat }, { { 7, 45, 0 }, 12, Pitch::flat }, { { 7, 46, 0 }, 12, Pitch::flat }, { { 6, 47, 0 }, 12, Pitch::flat }, { { 6, 48, 0 }, 12, Pitch::flat }, { { 5, 49, 0 }, 12, Pitch::flat }, { { 5, 50, 0 }, 12, Pitch::flat }, { { 4, 51, 0 }, 12, Pitch::flat }, { { 4, 52, 0 }, 12, Pitch::flat }, { { 3, 53, 0 }, 10, Pitch::flat }, { { 3, 54, 0 }, 10, Pitch::flat }, { { 2, 55, 0 }, 10, Pitch::flat }, { { 2, 56, 0 }, 10, Pitch::flat }, { { 1, 57, 0 }, 10, Pitch::flat }, { { 0, 58, 0 }, 10, Pitch::flat }, { { 0, 59, 0 }, 10, Pitch::flat }, { { -1, 60, 0 }, 10, Pitch::flat }, { { -2, 61, 0 }, 10, Pitch::flat }, { { -2, 62, 0 }, 10, Pitch::flat }, { { -3, 63, 0 }, 10, Pitch::flat }, { { -4, 64, 0 }, 10, Pitch::flat }, { { -4, 65, 0 }, 10, Pitch::flat }, { { -5, 66, 0 }, 10, Pitch::flat }, { { -6, 67, 0 }, 10, Pitch::flat }, { { -7, 68, 0 }, 10, Pitch::flat }, { { -7, 69, 0 }, 10, Pitch::flat }, { { -8, 70, 0 }, 10, Pitch::flat }, { { -9, 71, 0 }, 8, Pitch::flat }, { { -10, 72, 0 }, 8, Pitch::flat }, { { -11, 73, 0 }, 8, Pitch::flat }, { { -12, 74, 0 }, 8, Pitch::flat }, { { -12, 75, 0 }, 8, Pitch::flat }, { { -13, 76, 0 }, 8, Pitch::flat }, { { -14, 77, 0 }, 8, Pitch::flat }, { { -15, 78, 0 }, 8, Pitch::flat }, { { -16, 79, 0 }, 8, Pitch::flat }, }); // 0x4e2ba2 // Track 8. Reversed 0. Direction 2 static constexpr auto moveInfoT8R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 32, Pitch::flat }, { { 9, 16, 0 }, 32, Pitch::flat }, { { 10, 16, 0 }, 32, Pitch::flat }, { { 11, 16, 0 }, 30, Pitch::flat }, { { 12, 16, 0 }, 30, Pitch::flat }, { { 13, 16, 0 }, 30, Pitch::flat }, { { 14, 17, 0 }, 30, Pitch::flat }, { { 15, 17, 0 }, 30, Pitch::flat }, { { 16, 17, 0 }, 30, Pitch::flat }, { { 17, 17, 0 }, 30, Pitch::flat }, { { 18, 17, 0 }, 30, Pitch::flat }, { { 19, 18, 0 }, 30, Pitch::flat }, { { 20, 18, 0 }, 30, Pitch::flat }, { { 21, 18, 0 }, 30, Pitch::flat }, { { 22, 18, 0 }, 30, Pitch::flat }, { { 23, 18, 0 }, 30, Pitch::flat }, { { 24, 19, 0 }, 30, Pitch::flat }, { { 25, 19, 0 }, 30, Pitch::flat }, { { 26, 19, 0 }, 30, Pitch::flat }, { { 27, 19, 0 }, 30, Pitch::flat }, { { 28, 19, 0 }, 30, Pitch::flat }, { { 29, 20, 0 }, 30, Pitch::flat }, { { 30, 20, 0 }, 30, Pitch::flat }, { { 31, 20, 0 }, 30, Pitch::flat }, { { 32, 20, 0 }, 28, Pitch::flat }, { { 33, 21, 0 }, 28, Pitch::flat }, { { 34, 21, 0 }, 28, Pitch::flat }, { { 35, 21, 0 }, 28, Pitch::flat }, { { 36, 21, 0 }, 28, Pitch::flat }, { { 37, 22, 0 }, 28, Pitch::flat }, { { 38, 22, 0 }, 28, Pitch::flat }, { { 39, 22, 0 }, 28, Pitch::flat }, { { 40, 23, 0 }, 28, Pitch::flat }, { { 41, 23, 0 }, 28, Pitch::flat }, { { 42, 23, 0 }, 28, Pitch::flat }, { { 43, 24, 0 }, 28, Pitch::flat }, { { 44, 24, 0 }, 28, Pitch::flat }, { { 45, 24, 0 }, 28, Pitch::flat }, { { 46, 25, 0 }, 28, Pitch::flat }, { { 47, 25, 0 }, 28, Pitch::flat }, { { 48, 26, 0 }, 28, Pitch::flat }, { { 49, 26, 0 }, 28, Pitch::flat }, { { 50, 27, 0 }, 28, Pitch::flat }, { { 51, 27, 0 }, 28, Pitch::flat }, { { 52, 28, 0 }, 28, Pitch::flat }, { { 53, 28, 0 }, 26, Pitch::flat }, { { 54, 29, 0 }, 26, Pitch::flat }, { { 55, 29, 0 }, 26, Pitch::flat }, { { 56, 30, 0 }, 26, Pitch::flat }, { { 57, 30, 0 }, 26, Pitch::flat }, { { 58, 31, 0 }, 26, Pitch::flat }, { { 59, 32, 0 }, 26, Pitch::flat }, { { 60, 32, 0 }, 26, Pitch::flat }, { { 61, 33, 0 }, 26, Pitch::flat }, { { 62, 34, 0 }, 26, Pitch::flat }, { { 63, 34, 0 }, 26, Pitch::flat }, { { 64, 35, 0 }, 26, Pitch::flat }, { { 65, 36, 0 }, 26, Pitch::flat }, { { 66, 36, 0 }, 26, Pitch::flat }, { { 67, 37, 0 }, 26, Pitch::flat }, { { 68, 38, 0 }, 26, Pitch::flat }, { { 69, 39, 0 }, 26, Pitch::flat }, { { 70, 39, 0 }, 26, Pitch::flat }, { { 71, 40, 0 }, 24, Pitch::flat }, { { 72, 41, 0 }, 24, Pitch::flat }, { { 73, 42, 0 }, 24, Pitch::flat }, { { 74, 43, 0 }, 24, Pitch::flat }, { { 75, 44, 0 }, 24, Pitch::flat }, { { 76, 44, 0 }, 24, Pitch::flat }, { { 77, 45, 0 }, 24, Pitch::flat }, { { 78, 46, 0 }, 24, Pitch::flat }, { { 79, 47, 0 }, 24, Pitch::flat }, }); // 0x4e2e24 // Track 8. Reversed 0. Direction 3 static constexpr auto moveInfoT8R0D3 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 48, Pitch::flat }, { { 16, 23, 0 }, 48, Pitch::flat }, { { 16, 22, 0 }, 48, Pitch::flat }, { { 16, 21, 0 }, 46, Pitch::flat }, { { 16, 20, 0 }, 46, Pitch::flat }, { { 16, 19, 0 }, 46, Pitch::flat }, { { 16, 18, 0 }, 46, Pitch::flat }, { { 17, 17, 0 }, 46, Pitch::flat }, { { 17, 16, 0 }, 46, Pitch::flat }, { { 17, 15, 0 }, 46, Pitch::flat }, { { 17, 14, 0 }, 46, Pitch::flat }, { { 17, 13, 0 }, 46, Pitch::flat }, { { 18, 12, 0 }, 46, Pitch::flat }, { { 18, 11, 0 }, 46, Pitch::flat }, { { 18, 10, 0 }, 46, Pitch::flat }, { { 18, 9, 0 }, 46, Pitch::flat }, { { 18, 8, 0 }, 46, Pitch::flat }, { { 19, 7, 0 }, 46, Pitch::flat }, { { 19, 6, 0 }, 46, Pitch::flat }, { { 19, 5, 0 }, 46, Pitch::flat }, { { 19, 4, 0 }, 46, Pitch::flat }, { { 19, 3, 0 }, 46, Pitch::flat }, { { 20, 2, 0 }, 46, Pitch::flat }, { { 20, 1, 0 }, 46, Pitch::flat }, { { 20, 0, 0 }, 44, Pitch::flat }, { { 20, -1, 0 }, 44, Pitch::flat }, { { 21, -2, 0 }, 44, Pitch::flat }, { { 21, -3, 0 }, 44, Pitch::flat }, { { 21, -4, 0 }, 44, Pitch::flat }, { { 21, -5, 0 }, 44, Pitch::flat }, { { 22, -6, 0 }, 44, Pitch::flat }, { { 22, -7, 0 }, 44, Pitch::flat }, { { 22, -8, 0 }, 44, Pitch::flat }, { { 23, -9, 0 }, 44, Pitch::flat }, { { 23, -10, 0 }, 44, Pitch::flat }, { { 23, -11, 0 }, 44, Pitch::flat }, { { 24, -12, 0 }, 44, Pitch::flat }, { { 24, -13, 0 }, 44, Pitch::flat }, { { 24, -14, 0 }, 44, Pitch::flat }, { { 25, -15, 0 }, 44, Pitch::flat }, { { 25, -16, 0 }, 44, Pitch::flat }, { { 26, -17, 0 }, 44, Pitch::flat }, { { 26, -18, 0 }, 44, Pitch::flat }, { { 27, -19, 0 }, 44, Pitch::flat }, { { 27, -20, 0 }, 44, Pitch::flat }, { { 28, -21, 0 }, 42, Pitch::flat }, { { 28, -22, 0 }, 42, Pitch::flat }, { { 29, -23, 0 }, 42, Pitch::flat }, { { 29, -24, 0 }, 42, Pitch::flat }, { { 30, -25, 0 }, 42, Pitch::flat }, { { 30, -26, 0 }, 42, Pitch::flat }, { { 31, -27, 0 }, 42, Pitch::flat }, { { 32, -28, 0 }, 42, Pitch::flat }, { { 32, -29, 0 }, 42, Pitch::flat }, { { 33, -30, 0 }, 42, Pitch::flat }, { { 34, -31, 0 }, 42, Pitch::flat }, { { 34, -32, 0 }, 42, Pitch::flat }, { { 35, -33, 0 }, 42, Pitch::flat }, { { 36, -34, 0 }, 42, Pitch::flat }, { { 36, -35, 0 }, 42, Pitch::flat }, { { 37, -36, 0 }, 42, Pitch::flat }, { { 38, -37, 0 }, 42, Pitch::flat }, { { 39, -38, 0 }, 42, Pitch::flat }, { { 39, -39, 0 }, 40, Pitch::flat }, { { 40, -40, 0 }, 40, Pitch::flat }, { { 41, -41, 0 }, 40, Pitch::flat }, { { 42, -42, 0 }, 40, Pitch::flat }, { { 43, -43, 0 }, 40, Pitch::flat }, { { 44, -44, 0 }, 40, Pitch::flat }, { { 44, -45, 0 }, 40, Pitch::flat }, { { 45, -46, 0 }, 40, Pitch::flat }, { { 46, -47, 0 }, 40, Pitch::flat }, { { 47, -48, 0 }, 40, Pitch::flat }, }); // 0x4e4728 // Track 8. Reversed 1. Direction 0 static constexpr auto moveInfoT8R1D0 = std::to_array<MoveInfo>( { { { 16, 16, 0 }, 24, Pitch::flat }, { { 17, 17, 0 }, 24, Pitch::flat }, { { 18, 18, 0 }, 24, Pitch::flat }, { { 19, 19, 0 }, 24, Pitch::flat }, { { 20, 20, 0 }, 24, Pitch::flat }, { { 21, 20, 0 }, 24, Pitch::flat }, { { 22, 21, 0 }, 24, Pitch::flat }, { { 23, 22, 0 }, 24, Pitch::flat }, { { 24, 23, 0 }, 26, Pitch::flat }, { { 25, 24, 0 }, 26, Pitch::flat }, { { 26, 25, 0 }, 26, Pitch::flat }, { { 27, 25, 0 }, 26, Pitch::flat }, { { 28, 26, 0 }, 26, Pitch::flat }, { { 29, 27, 0 }, 26, Pitch::flat }, { { 30, 28, 0 }, 26, Pitch::flat }, { { 31, 28, 0 }, 26, Pitch::flat }, { { 32, 29, 0 }, 26, Pitch::flat }, { { 33, 30, 0 }, 26, Pitch::flat }, { { 34, 30, 0 }, 26, Pitch::flat }, { { 35, 31, 0 }, 26, Pitch::flat }, { { 36, 32, 0 }, 26, Pitch::flat }, { { 37, 32, 0 }, 26, Pitch::flat }, { { 38, 33, 0 }, 26, Pitch::flat }, { { 39, 34, 0 }, 26, Pitch::flat }, { { 40, 34, 0 }, 26, Pitch::flat }, { { 41, 35, 0 }, 26, Pitch::flat }, { { 42, 35, 0 }, 26, Pitch::flat }, { { 43, 36, 0 }, 28, Pitch::flat }, { { 44, 36, 0 }, 28, Pitch::flat }, { { 45, 37, 0 }, 28, Pitch::flat }, { { 46, 37, 0 }, 28, Pitch::flat }, { { 47, 38, 0 }, 28, Pitch::flat }, { { 48, 38, 0 }, 28, Pitch::flat }, { { 49, 39, 0 }, 28, Pitch::flat }, { { 50, 39, 0 }, 28, Pitch::flat }, { { 51, 40, 0 }, 28, Pitch::flat }, { { 52, 40, 0 }, 28, Pitch::flat }, { { 53, 40, 0 }, 28, Pitch::flat }, { { 54, 41, 0 }, 28, Pitch::flat }, { { 55, 41, 0 }, 28, Pitch::flat }, { { 56, 41, 0 }, 28, Pitch::flat }, { { 57, 42, 0 }, 28, Pitch::flat }, { { 58, 42, 0 }, 28, Pitch::flat }, { { 59, 42, 0 }, 28, Pitch::flat }, { { 60, 43, 0 }, 28, Pitch::flat }, { { 61, 43, 0 }, 28, Pitch::flat }, { { 62, 43, 0 }, 28, Pitch::flat }, { { 63, 43, 0 }, 30, Pitch::flat }, { { 64, 44, 0 }, 30, Pitch::flat }, { { 65, 44, 0 }, 30, Pitch::flat }, { { 66, 44, 0 }, 30, Pitch::flat }, { { 67, 44, 0 }, 30, Pitch::flat }, { { 68, 45, 0 }, 30, Pitch::flat }, { { 69, 45, 0 }, 30, Pitch::flat }, { { 70, 45, 0 }, 30, Pitch::flat }, { { 71, 45, 0 }, 30, Pitch::flat }, { { 72, 45, 0 }, 30, Pitch::flat }, { { 73, 46, 0 }, 30, Pitch::flat }, { { 74, 46, 0 }, 30, Pitch::flat }, { { 75, 46, 0 }, 30, Pitch::flat }, { { 76, 46, 0 }, 30, Pitch::flat }, { { 77, 46, 0 }, 30, Pitch::flat }, { { 78, 47, 0 }, 30, Pitch::flat }, { { 79, 47, 0 }, 30, Pitch::flat }, { { 80, 47, 0 }, 30, Pitch::flat }, { { 81, 47, 0 }, 30, Pitch::flat }, { { 82, 47, 0 }, 30, Pitch::flat }, { { 83, 48, 0 }, 32, Pitch::flat }, { { 84, 48, 0 }, 32, Pitch::flat }, { { 85, 48, 0 }, 32, Pitch::flat }, { { 86, 48, 0 }, 32, Pitch::flat }, { { 87, 48, 0 }, 32, Pitch::flat }, { { 88, 48, 0 }, 32, Pitch::flat }, { { 89, 48, 0 }, 32, Pitch::flat }, { { 90, 48, 0 }, 32, Pitch::flat }, { { 91, 48, 0 }, 32, Pitch::flat }, { { 92, 48, 0 }, 32, Pitch::flat }, { { 93, 48, 0 }, 32, Pitch::flat }, { { 94, 48, 0 }, 32, Pitch::flat }, { { 95, 48, 0 }, 32, Pitch::flat }, }); // 0x4e49aa // Track 8. Reversed 1. Direction 1 static constexpr auto moveInfoT8R1D1 = std::to_array<MoveInfo>( { { { 16, 15, 0 }, 40, Pitch::flat }, { { 17, 14, 0 }, 40, Pitch::flat }, { { 18, 13, 0 }, 40, Pitch::flat }, { { 19, 12, 0 }, 40, Pitch::flat }, { { 19, 11, 0 }, 40, Pitch::flat }, { { 20, 10, 0 }, 40, Pitch::flat }, { { 21, 9, 0 }, 40, Pitch::flat }, { { 22, 8, 0 }, 42, Pitch::flat }, { { 23, 7, 0 }, 42, Pitch::flat }, { { 24, 6, 0 }, 42, Pitch::flat }, { { 24, 5, 0 }, 42, Pitch::flat }, { { 25, 4, 0 }, 42, Pitch::flat }, { { 26, 3, 0 }, 42, Pitch::flat }, { { 27, 2, 0 }, 42, Pitch::flat }, { { 27, 1, 0 }, 42, Pitch::flat }, { { 28, 0, 0 }, 42, Pitch::flat }, { { 29, -1, 0 }, 42, Pitch::flat }, { { 29, -2, 0 }, 42, Pitch::flat }, { { 30, -3, 0 }, 42, Pitch::flat }, { { 31, -4, 0 }, 42, Pitch::flat }, { { 31, -5, 0 }, 42, Pitch::flat }, { { 32, -6, 0 }, 42, Pitch::flat }, { { 33, -7, 0 }, 42, Pitch::flat }, { { 33, -8, 0 }, 42, Pitch::flat }, { { 34, -9, 0 }, 42, Pitch::flat }, { { 34, -10, 0 }, 42, Pitch::flat }, { { 35, -11, 0 }, 44, Pitch::flat }, { { 35, -12, 0 }, 44, Pitch::flat }, { { 36, -13, 0 }, 44, Pitch::flat }, { { 36, -14, 0 }, 44, Pitch::flat }, { { 37, -15, 0 }, 44, Pitch::flat }, { { 37, -16, 0 }, 44, Pitch::flat }, { { 38, -17, 0 }, 44, Pitch::flat }, { { 38, -18, 0 }, 44, Pitch::flat }, { { 39, -19, 0 }, 44, Pitch::flat }, { { 39, -20, 0 }, 44, Pitch::flat }, { { 39, -21, 0 }, 44, Pitch::flat }, { { 40, -22, 0 }, 44, Pitch::flat }, { { 40, -23, 0 }, 44, Pitch::flat }, { { 40, -24, 0 }, 44, Pitch::flat }, { { 41, -25, 0 }, 44, Pitch::flat }, { { 41, -26, 0 }, 44, Pitch::flat }, { { 41, -27, 0 }, 44, Pitch::flat }, { { 42, -28, 0 }, 44, Pitch::flat }, { { 42, -29, 0 }, 44, Pitch::flat }, { { 42, -30, 0 }, 44, Pitch::flat }, { { 42, -31, 0 }, 46, Pitch::flat }, { { 43, -32, 0 }, 46, Pitch::flat }, { { 43, -33, 0 }, 46, Pitch::flat }, { { 43, -34, 0 }, 46, Pitch::flat }, { { 43, -35, 0 }, 46, Pitch::flat }, { { 44, -36, 0 }, 46, Pitch::flat }, { { 44, -37, 0 }, 46, Pitch::flat }, { { 44, -38, 0 }, 46, Pitch::flat }, { { 44, -39, 0 }, 46, Pitch::flat }, { { 44, -40, 0 }, 46, Pitch::flat }, { { 45, -41, 0 }, 46, Pitch::flat }, { { 45, -42, 0 }, 46, Pitch::flat }, { { 45, -43, 0 }, 46, Pitch::flat }, { { 45, -44, 0 }, 46, Pitch::flat }, { { 45, -45, 0 }, 46, Pitch::flat }, { { 46, -46, 0 }, 46, Pitch::flat }, { { 46, -47, 0 }, 46, Pitch::flat }, { { 46, -48, 0 }, 46, Pitch::flat }, { { 46, -49, 0 }, 46, Pitch::flat }, { { 46, -50, 0 }, 46, Pitch::flat }, { { 47, -51, 0 }, 48, Pitch::flat }, { { 47, -52, 0 }, 48, Pitch::flat }, { { 47, -53, 0 }, 48, Pitch::flat }, { { 47, -54, 0 }, 48, Pitch::flat }, { { 47, -55, 0 }, 48, Pitch::flat }, { { 47, -56, 0 }, 48, Pitch::flat }, { { 47, -57, 0 }, 48, Pitch::flat }, { { 47, -58, 0 }, 48, Pitch::flat }, { { 47, -59, 0 }, 48, Pitch::flat }, { { 47, -60, 0 }, 48, Pitch::flat }, { { 47, -61, 0 }, 48, Pitch::flat }, { { 47, -62, 0 }, 48, Pitch::flat }, { { 47, -63, 0 }, 48, Pitch::flat }, { { 47, -64, 0 }, 48, Pitch::flat }, }); // 0x4e4c2c // Track 8. Reversed 1. Direction 2 static constexpr auto moveInfoT8R1D2 = std::to_array<MoveInfo>( { { { 15, 15, 0 }, 56, Pitch::flat }, { { 14, 14, 0 }, 56, Pitch::flat }, { { 13, 13, 0 }, 56, Pitch::flat }, { { 12, 12, 0 }, 56, Pitch::flat }, { { 11, 12, 0 }, 56, Pitch::flat }, { { 10, 11, 0 }, 56, Pitch::flat }, { { 9, 10, 0 }, 56, Pitch::flat }, { { 8, 9, 0 }, 58, Pitch::flat }, { { 7, 8, 0 }, 58, Pitch::flat }, { { 6, 7, 0 }, 58, Pitch::flat }, { { 5, 7, 0 }, 58, Pitch::flat }, { { 4, 6, 0 }, 58, Pitch::flat }, { { 3, 5, 0 }, 58, Pitch::flat }, { { 2, 4, 0 }, 58, Pitch::flat }, { { 1, 4, 0 }, 58, Pitch::flat }, { { 0, 3, 0 }, 58, Pitch::flat }, { { -1, 2, 0 }, 58, Pitch::flat }, { { -2, 2, 0 }, 58, Pitch::flat }, { { -3, 1, 0 }, 58, Pitch::flat }, { { -4, 0, 0 }, 58, Pitch::flat }, { { -5, 0, 0 }, 58, Pitch::flat }, { { -6, -1, 0 }, 58, Pitch::flat }, { { -7, -2, 0 }, 58, Pitch::flat }, { { -8, -2, 0 }, 58, Pitch::flat }, { { -9, -3, 0 }, 58, Pitch::flat }, { { -10, -3, 0 }, 58, Pitch::flat }, { { -11, -4, 0 }, 60, Pitch::flat }, { { -12, -4, 0 }, 60, Pitch::flat }, { { -13, -5, 0 }, 60, Pitch::flat }, { { -14, -5, 0 }, 60, Pitch::flat }, { { -15, -6, 0 }, 60, Pitch::flat }, { { -16, -6, 0 }, 60, Pitch::flat }, { { -17, -7, 0 }, 60, Pitch::flat }, { { -18, -7, 0 }, 60, Pitch::flat }, { { -19, -8, 0 }, 60, Pitch::flat }, { { -20, -8, 0 }, 60, Pitch::flat }, { { -21, -8, 0 }, 60, Pitch::flat }, { { -22, -9, 0 }, 60, Pitch::flat }, { { -23, -9, 0 }, 60, Pitch::flat }, { { -24, -9, 0 }, 60, Pitch::flat }, { { -25, -10, 0 }, 60, Pitch::flat }, { { -26, -10, 0 }, 60, Pitch::flat }, { { -27, -10, 0 }, 60, Pitch::flat }, { { -28, -11, 0 }, 60, Pitch::flat }, { { -29, -11, 0 }, 60, Pitch::flat }, { { -30, -11, 0 }, 60, Pitch::flat }, { { -31, -11, 0 }, 62, Pitch::flat }, { { -32, -12, 0 }, 62, Pitch::flat }, { { -33, -12, 0 }, 62, Pitch::flat }, { { -34, -12, 0 }, 62, Pitch::flat }, { { -35, -12, 0 }, 62, Pitch::flat }, { { -36, -13, 0 }, 62, Pitch::flat }, { { -37, -13, 0 }, 62, Pitch::flat }, { { -38, -13, 0 }, 62, Pitch::flat }, { { -39, -13, 0 }, 62, Pitch::flat }, { { -40, -13, 0 }, 62, Pitch::flat }, { { -41, -14, 0 }, 62, Pitch::flat }, { { -42, -14, 0 }, 62, Pitch::flat }, { { -43, -14, 0 }, 62, Pitch::flat }, { { -44, -14, 0 }, 62, Pitch::flat }, { { -45, -14, 0 }, 62, Pitch::flat }, { { -46, -15, 0 }, 62, Pitch::flat }, { { -47, -15, 0 }, 62, Pitch::flat }, { { -48, -15, 0 }, 62, Pitch::flat }, { { -49, -15, 0 }, 62, Pitch::flat }, { { -50, -15, 0 }, 62, Pitch::flat }, { { -51, -16, 0 }, 0, Pitch::flat }, { { -52, -16, 0 }, 0, Pitch::flat }, { { -53, -16, 0 }, 0, Pitch::flat }, { { -54, -16, 0 }, 0, Pitch::flat }, { { -55, -16, 0 }, 0, Pitch::flat }, { { -56, -16, 0 }, 0, Pitch::flat }, { { -57, -16, 0 }, 0, Pitch::flat }, { { -58, -16, 0 }, 0, Pitch::flat }, { { -59, -16, 0 }, 0, Pitch::flat }, { { -60, -16, 0 }, 0, Pitch::flat }, { { -61, -16, 0 }, 0, Pitch::flat }, { { -62, -16, 0 }, 0, Pitch::flat }, { { -63, -16, 0 }, 0, Pitch::flat }, { { -64, -16, 0 }, 0, Pitch::flat }, }); // 0x4e44ae // Track 8. Reversed 1. Direction 3 static constexpr auto moveInfoT8R1D3 = std::to_array<MoveInfo>( { { { 15, 17, 0 }, 8, Pitch::flat }, { { 14, 18, 0 }, 8, Pitch::flat }, { { 13, 19, 0 }, 8, Pitch::flat }, { { 12, 20, 0 }, 8, Pitch::flat }, { { 12, 21, 0 }, 8, Pitch::flat }, { { 11, 22, 0 }, 8, Pitch::flat }, { { 10, 23, 0 }, 8, Pitch::flat }, { { 9, 24, 0 }, 10, Pitch::flat }, { { 8, 25, 0 }, 10, Pitch::flat }, { { 7, 26, 0 }, 10, Pitch::flat }, { { 7, 27, 0 }, 10, Pitch::flat }, { { 6, 28, 0 }, 10, Pitch::flat }, { { 5, 29, 0 }, 10, Pitch::flat }, { { 4, 30, 0 }, 10, Pitch::flat }, { { 4, 31, 0 }, 10, Pitch::flat }, { { 3, 32, 0 }, 10, Pitch::flat }, { { 2, 33, 0 }, 10, Pitch::flat }, { { 2, 34, 0 }, 10, Pitch::flat }, { { 1, 35, 0 }, 10, Pitch::flat }, { { 0, 36, 0 }, 10, Pitch::flat }, { { 0, 37, 0 }, 10, Pitch::flat }, { { -1, 38, 0 }, 10, Pitch::flat }, { { -2, 39, 0 }, 10, Pitch::flat }, { { -2, 40, 0 }, 10, Pitch::flat }, { { -3, 41, 0 }, 10, Pitch::flat }, { { -3, 42, 0 }, 10, Pitch::flat }, { { -4, 43, 0 }, 12, Pitch::flat }, { { -4, 44, 0 }, 12, Pitch::flat }, { { -5, 45, 0 }, 12, Pitch::flat }, { { -5, 46, 0 }, 12, Pitch::flat }, { { -6, 47, 0 }, 12, Pitch::flat }, { { -6, 48, 0 }, 12, Pitch::flat }, { { -7, 49, 0 }, 12, Pitch::flat }, { { -7, 50, 0 }, 12, Pitch::flat }, { { -8, 51, 0 }, 12, Pitch::flat }, { { -8, 52, 0 }, 12, Pitch::flat }, { { -8, 53, 0 }, 12, Pitch::flat }, { { -9, 54, 0 }, 12, Pitch::flat }, { { -9, 55, 0 }, 12, Pitch::flat }, { { -9, 56, 0 }, 12, Pitch::flat }, { { -10, 57, 0 }, 12, Pitch::flat }, { { -10, 58, 0 }, 12, Pitch::flat }, { { -10, 59, 0 }, 12, Pitch::flat }, { { -11, 60, 0 }, 12, Pitch::flat }, { { -11, 61, 0 }, 12, Pitch::flat }, { { -11, 62, 0 }, 12, Pitch::flat }, { { -11, 63, 0 }, 14, Pitch::flat }, { { -12, 64, 0 }, 14, Pitch::flat }, { { -12, 65, 0 }, 14, Pitch::flat }, { { -12, 66, 0 }, 14, Pitch::flat }, { { -12, 67, 0 }, 14, Pitch::flat }, { { -13, 68, 0 }, 14, Pitch::flat }, { { -13, 69, 0 }, 14, Pitch::flat }, { { -13, 70, 0 }, 14, Pitch::flat }, { { -13, 71, 0 }, 14, Pitch::flat }, { { -13, 72, 0 }, 14, Pitch::flat }, { { -14, 73, 0 }, 14, Pitch::flat }, { { -14, 74, 0 }, 14, Pitch::flat }, { { -14, 75, 0 }, 14, Pitch::flat }, { { -14, 76, 0 }, 14, Pitch::flat }, { { -14, 77, 0 }, 14, Pitch::flat }, { { -15, 78, 0 }, 14, Pitch::flat }, { { -15, 79, 0 }, 14, Pitch::flat }, { { -15, 80, 0 }, 14, Pitch::flat }, { { -15, 81, 0 }, 14, Pitch::flat }, { { -15, 82, 0 }, 14, Pitch::flat }, { { -16, 83, 0 }, 16, Pitch::flat }, { { -16, 84, 0 }, 16, Pitch::flat }, { { -16, 85, 0 }, 16, Pitch::flat }, { { -16, 86, 0 }, 16, Pitch::flat }, { { -16, 87, 0 }, 16, Pitch::flat }, { { -16, 88, 0 }, 16, Pitch::flat }, { { -16, 89, 0 }, 16, Pitch::flat }, { { -16, 90, 0 }, 16, Pitch::flat }, { { -16, 91, 0 }, 16, Pitch::flat }, { { -16, 92, 0 }, 16, Pitch::flat }, { { -16, 93, 0 }, 16, Pitch::flat }, { { -16, 94, 0 }, 16, Pitch::flat }, { { -16, 95, 0 }, 16, Pitch::flat }, }); // 0x4e3aa6 // Track 9. Reversed 0. Direction 0 static constexpr auto moveInfoT9R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 0, Pitch::flat }, { { 23, 16, 0 }, 0, Pitch::flat }, { { 22, 16, 0 }, 0, Pitch::flat }, { { 21, 16, 0 }, 2, Pitch::flat }, { { 20, 16, 0 }, 2, Pitch::flat }, { { 19, 16, 0 }, 2, Pitch::flat }, { { 18, 16, 0 }, 2, Pitch::flat }, { { 17, 17, 0 }, 2, Pitch::flat }, { { 16, 17, 0 }, 2, Pitch::flat }, { { 15, 17, 0 }, 2, Pitch::flat }, { { 14, 17, 0 }, 2, Pitch::flat }, { { 13, 17, 0 }, 2, Pitch::flat }, { { 12, 18, 0 }, 2, Pitch::flat }, { { 11, 18, 0 }, 2, Pitch::flat }, { { 10, 18, 0 }, 2, Pitch::flat }, { { 9, 18, 0 }, 2, Pitch::flat }, { { 8, 18, 0 }, 2, Pitch::flat }, { { 7, 19, 0 }, 2, Pitch::flat }, { { 6, 19, 0 }, 2, Pitch::flat }, { { 5, 19, 0 }, 2, Pitch::flat }, { { 4, 19, 0 }, 2, Pitch::flat }, { { 3, 19, 0 }, 2, Pitch::flat }, { { 2, 20, 0 }, 2, Pitch::flat }, { { 1, 20, 0 }, 2, Pitch::flat }, { { 0, 20, 0 }, 4, Pitch::flat }, { { -1, 20, 0 }, 4, Pitch::flat }, { { -2, 21, 0 }, 4, Pitch::flat }, { { -3, 21, 0 }, 4, Pitch::flat }, { { -4, 21, 0 }, 4, Pitch::flat }, { { -5, 21, 0 }, 4, Pitch::flat }, { { -6, 22, 0 }, 4, Pitch::flat }, { { -7, 22, 0 }, 4, Pitch::flat }, { { -8, 22, 0 }, 4, Pitch::flat }, { { -9, 23, 0 }, 4, Pitch::flat }, { { -10, 23, 0 }, 4, Pitch::flat }, { { -11, 23, 0 }, 4, Pitch::flat }, { { -12, 24, 0 }, 4, Pitch::flat }, { { -13, 24, 0 }, 4, Pitch::flat }, { { -14, 24, 0 }, 4, Pitch::flat }, { { -15, 25, 0 }, 4, Pitch::flat }, { { -16, 25, 0 }, 4, Pitch::flat }, { { -17, 26, 0 }, 4, Pitch::flat }, { { -18, 26, 0 }, 4, Pitch::flat }, { { -19, 27, 0 }, 4, Pitch::flat }, { { -20, 27, 0 }, 4, Pitch::flat }, { { -21, 28, 0 }, 6, Pitch::flat }, { { -22, 28, 0 }, 6, Pitch::flat }, { { -23, 29, 0 }, 6, Pitch::flat }, { { -24, 29, 0 }, 6, Pitch::flat }, { { -25, 30, 0 }, 6, Pitch::flat }, { { -26, 30, 0 }, 6, Pitch::flat }, { { -27, 31, 0 }, 6, Pitch::flat }, { { -28, 32, 0 }, 6, Pitch::flat }, { { -29, 32, 0 }, 6, Pitch::flat }, { { -30, 33, 0 }, 6, Pitch::flat }, { { -31, 34, 0 }, 6, Pitch::flat }, { { -32, 34, 0 }, 6, Pitch::flat }, { { -33, 35, 0 }, 6, Pitch::flat }, { { -34, 36, 0 }, 6, Pitch::flat }, { { -35, 36, 0 }, 6, Pitch::flat }, { { -36, 37, 0 }, 6, Pitch::flat }, { { -37, 38, 0 }, 6, Pitch::flat }, { { -38, 39, 0 }, 6, Pitch::flat }, { { -39, 39, 0 }, 8, Pitch::flat }, { { -40, 40, 0 }, 8, Pitch::flat }, { { -41, 41, 0 }, 8, Pitch::flat }, { { -42, 42, 0 }, 8, Pitch::flat }, { { -43, 43, 0 }, 8, Pitch::flat }, { { -44, 44, 0 }, 8, Pitch::flat }, { { -45, 44, 0 }, 8, Pitch::flat }, { { -46, 45, 0 }, 8, Pitch::flat }, { { -47, 46, 0 }, 8, Pitch::flat }, { { -48, 47, 0 }, 8, Pitch::flat }, }); // 0x4e3d28 // Track 9. Reversed 0. Direction 1 static constexpr auto moveInfoT9R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 16, Pitch::flat }, { { 16, 9, 0 }, 16, Pitch::flat }, { { 16, 10, 0 }, 16, Pitch::flat }, { { 16, 11, 0 }, 18, Pitch::flat }, { { 16, 12, 0 }, 18, Pitch::flat }, { { 16, 13, 0 }, 18, Pitch::flat }, { { 17, 14, 0 }, 18, Pitch::flat }, { { 17, 15, 0 }, 18, Pitch::flat }, { { 17, 16, 0 }, 18, Pitch::flat }, { { 17, 17, 0 }, 18, Pitch::flat }, { { 17, 18, 0 }, 18, Pitch::flat }, { { 18, 19, 0 }, 18, Pitch::flat }, { { 18, 20, 0 }, 18, Pitch::flat }, { { 18, 21, 0 }, 18, Pitch::flat }, { { 18, 22, 0 }, 18, Pitch::flat }, { { 18, 23, 0 }, 18, Pitch::flat }, { { 19, 24, 0 }, 18, Pitch::flat }, { { 19, 25, 0 }, 18, Pitch::flat }, { { 19, 26, 0 }, 18, Pitch::flat }, { { 19, 27, 0 }, 18, Pitch::flat }, { { 19, 28, 0 }, 18, Pitch::flat }, { { 20, 29, 0 }, 18, Pitch::flat }, { { 20, 30, 0 }, 18, Pitch::flat }, { { 20, 31, 0 }, 18, Pitch::flat }, { { 20, 32, 0 }, 20, Pitch::flat }, { { 21, 33, 0 }, 20, Pitch::flat }, { { 21, 34, 0 }, 20, Pitch::flat }, { { 21, 35, 0 }, 20, Pitch::flat }, { { 21, 36, 0 }, 20, Pitch::flat }, { { 22, 37, 0 }, 20, Pitch::flat }, { { 22, 38, 0 }, 20, Pitch::flat }, { { 22, 39, 0 }, 20, Pitch::flat }, { { 23, 40, 0 }, 20, Pitch::flat }, { { 23, 41, 0 }, 20, Pitch::flat }, { { 23, 42, 0 }, 20, Pitch::flat }, { { 24, 43, 0 }, 20, Pitch::flat }, { { 24, 44, 0 }, 20, Pitch::flat }, { { 24, 45, 0 }, 20, Pitch::flat }, { { 25, 46, 0 }, 20, Pitch::flat }, { { 25, 47, 0 }, 20, Pitch::flat }, { { 26, 48, 0 }, 20, Pitch::flat }, { { 26, 49, 0 }, 20, Pitch::flat }, { { 27, 50, 0 }, 20, Pitch::flat }, { { 27, 51, 0 }, 20, Pitch::flat }, { { 28, 52, 0 }, 20, Pitch::flat }, { { 28, 53, 0 }, 22, Pitch::flat }, { { 29, 54, 0 }, 22, Pitch::flat }, { { 29, 55, 0 }, 22, Pitch::flat }, { { 30, 56, 0 }, 22, Pitch::flat }, { { 30, 57, 0 }, 22, Pitch::flat }, { { 31, 58, 0 }, 22, Pitch::flat }, { { 32, 59, 0 }, 22, Pitch::flat }, { { 32, 60, 0 }, 22, Pitch::flat }, { { 33, 61, 0 }, 22, Pitch::flat }, { { 34, 62, 0 }, 22, Pitch::flat }, { { 34, 63, 0 }, 22, Pitch::flat }, { { 35, 64, 0 }, 22, Pitch::flat }, { { 36, 65, 0 }, 22, Pitch::flat }, { { 36, 66, 0 }, 22, Pitch::flat }, { { 37, 67, 0 }, 22, Pitch::flat }, { { 38, 68, 0 }, 22, Pitch::flat }, { { 39, 69, 0 }, 22, Pitch::flat }, { { 39, 70, 0 }, 22, Pitch::flat }, { { 40, 71, 0 }, 24, Pitch::flat }, { { 41, 72, 0 }, 24, Pitch::flat }, { { 42, 73, 0 }, 24, Pitch::flat }, { { 43, 74, 0 }, 24, Pitch::flat }, { { 44, 75, 0 }, 24, Pitch::flat }, { { 44, 76, 0 }, 24, Pitch::flat }, { { 45, 77, 0 }, 24, Pitch::flat }, { { 46, 78, 0 }, 24, Pitch::flat }, { { 47, 79, 0 }, 24, Pitch::flat }, }); // 0x4e3faa // Track 9. Reversed 0. Direction 2 static constexpr auto moveInfoT9R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 32, Pitch::flat }, { { 9, 16, 0 }, 32, Pitch::flat }, { { 10, 16, 0 }, 32, Pitch::flat }, { { 11, 16, 0 }, 34, Pitch::flat }, { { 12, 16, 0 }, 34, Pitch::flat }, { { 13, 15, 0 }, 34, Pitch::flat }, { { 14, 15, 0 }, 34, Pitch::flat }, { { 15, 15, 0 }, 34, Pitch::flat }, { { 16, 15, 0 }, 34, Pitch::flat }, { { 17, 15, 0 }, 34, Pitch::flat }, { { 18, 14, 0 }, 34, Pitch::flat }, { { 19, 14, 0 }, 34, Pitch::flat }, { { 20, 14, 0 }, 34, Pitch::flat }, { { 21, 14, 0 }, 34, Pitch::flat }, { { 22, 14, 0 }, 34, Pitch::flat }, { { 23, 13, 0 }, 34, Pitch::flat }, { { 24, 13, 0 }, 34, Pitch::flat }, { { 25, 13, 0 }, 34, Pitch::flat }, { { 26, 13, 0 }, 34, Pitch::flat }, { { 27, 13, 0 }, 34, Pitch::flat }, { { 28, 12, 0 }, 34, Pitch::flat }, { { 29, 12, 0 }, 34, Pitch::flat }, { { 30, 12, 0 }, 34, Pitch::flat }, { { 31, 12, 0 }, 34, Pitch::flat }, { { 32, 11, 0 }, 36, Pitch::flat }, { { 33, 11, 0 }, 36, Pitch::flat }, { { 34, 11, 0 }, 36, Pitch::flat }, { { 35, 11, 0 }, 36, Pitch::flat }, { { 36, 10, 0 }, 36, Pitch::flat }, { { 37, 10, 0 }, 36, Pitch::flat }, { { 38, 10, 0 }, 36, Pitch::flat }, { { 39, 9, 0 }, 36, Pitch::flat }, { { 40, 9, 0 }, 36, Pitch::flat }, { { 41, 9, 0 }, 36, Pitch::flat }, { { 42, 8, 0 }, 36, Pitch::flat }, { { 43, 8, 0 }, 36, Pitch::flat }, { { 44, 8, 0 }, 36, Pitch::flat }, { { 45, 7, 0 }, 36, Pitch::flat }, { { 46, 7, 0 }, 36, Pitch::flat }, { { 47, 6, 0 }, 36, Pitch::flat }, { { 48, 6, 0 }, 36, Pitch::flat }, { { 49, 5, 0 }, 36, Pitch::flat }, { { 50, 5, 0 }, 36, Pitch::flat }, { { 51, 4, 0 }, 36, Pitch::flat }, { { 52, 4, 0 }, 36, Pitch::flat }, { { 53, 3, 0 }, 38, Pitch::flat }, { { 54, 3, 0 }, 38, Pitch::flat }, { { 55, 2, 0 }, 38, Pitch::flat }, { { 56, 2, 0 }, 38, Pitch::flat }, { { 57, 1, 0 }, 38, Pitch::flat }, { { 58, 0, 0 }, 38, Pitch::flat }, { { 59, 0, 0 }, 38, Pitch::flat }, { { 60, -1, 0 }, 38, Pitch::flat }, { { 61, -2, 0 }, 38, Pitch::flat }, { { 62, -2, 0 }, 38, Pitch::flat }, { { 63, -3, 0 }, 38, Pitch::flat }, { { 64, -4, 0 }, 38, Pitch::flat }, { { 65, -4, 0 }, 38, Pitch::flat }, { { 66, -5, 0 }, 38, Pitch::flat }, { { 67, -6, 0 }, 38, Pitch::flat }, { { 68, -7, 0 }, 38, Pitch::flat }, { { 69, -7, 0 }, 38, Pitch::flat }, { { 70, -8, 0 }, 38, Pitch::flat }, { { 71, -9, 0 }, 40, Pitch::flat }, { { 72, -10, 0 }, 40, Pitch::flat }, { { 73, -11, 0 }, 40, Pitch::flat }, { { 74, -12, 0 }, 40, Pitch::flat }, { { 75, -12, 0 }, 40, Pitch::flat }, { { 76, -13, 0 }, 40, Pitch::flat }, { { 77, -14, 0 }, 40, Pitch::flat }, { { 78, -15, 0 }, 40, Pitch::flat }, { { 79, -16, 0 }, 40, Pitch::flat }, }); // 0x4e422c // Track 9. Reversed 0. Direction 3 static constexpr auto moveInfoT9R0D3 = std::to_array<MoveInfo>( { { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 48, Pitch::flat }, { { 16, 23, 0 }, 48, Pitch::flat }, { { 16, 22, 0 }, 48, Pitch::flat }, { { 16, 21, 0 }, 50, Pitch::flat }, { { 16, 20, 0 }, 50, Pitch::flat }, { { 16, 19, 0 }, 50, Pitch::flat }, { { 15, 18, 0 }, 50, Pitch::flat }, { { 15, 17, 0 }, 50, Pitch::flat }, { { 15, 16, 0 }, 50, Pitch::flat }, { { 15, 15, 0 }, 50, Pitch::flat }, { { 15, 14, 0 }, 50, Pitch::flat }, { { 14, 13, 0 }, 50, Pitch::flat }, { { 14, 12, 0 }, 50, Pitch::flat }, { { 14, 11, 0 }, 50, Pitch::flat }, { { 14, 10, 0 }, 50, Pitch::flat }, { { 14, 9, 0 }, 50, Pitch::flat }, { { 13, 8, 0 }, 50, Pitch::flat }, { { 13, 7, 0 }, 50, Pitch::flat }, { { 13, 6, 0 }, 50, Pitch::flat }, { { 13, 5, 0 }, 50, Pitch::flat }, { { 13, 4, 0 }, 50, Pitch::flat }, { { 12, 3, 0 }, 50, Pitch::flat }, { { 12, 2, 0 }, 50, Pitch::flat }, { { 12, 1, 0 }, 50, Pitch::flat }, { { 12, 0, 0 }, 52, Pitch::flat }, { { 11, -1, 0 }, 52, Pitch::flat }, { { 11, -2, 0 }, 52, Pitch::flat }, { { 11, -3, 0 }, 52, Pitch::flat }, { { 11, -4, 0 }, 52, Pitch::flat }, { { 10, -5, 0 }, 52, Pitch::flat }, { { 10, -6, 0 }, 52, Pitch::flat }, { { 10, -7, 0 }, 52, Pitch::flat }, { { 9, -8, 0 }, 52, Pitch::flat }, { { 9, -9, 0 }, 52, Pitch::flat }, { { 9, -10, 0 }, 52, Pitch::flat }, { { 8, -11, 0 }, 52, Pitch::flat }, { { 8, -12, 0 }, 52, Pitch::flat }, { { 8, -13, 0 }, 52, Pitch::flat }, { { 7, -14, 0 }, 52, Pitch::flat }, { { 7, -15, 0 }, 52, Pitch::flat }, { { 6, -16, 0 }, 52, Pitch::flat }, { { 6, -17, 0 }, 52, Pitch::flat }, { { 5, -18, 0 }, 52, Pitch::flat }, { { 5, -19, 0 }, 52, Pitch::flat }, { { 4, -20, 0 }, 52, Pitch::flat }, { { 4, -21, 0 }, 54, Pitch::flat }, { { 3, -22, 0 }, 54, Pitch::flat }, { { 3, -23, 0 }, 54, Pitch::flat }, { { 2, -24, 0 }, 54, Pitch::flat }, { { 2, -25, 0 }, 54, Pitch::flat }, { { 1, -26, 0 }, 54, Pitch::flat }, { { 0, -27, 0 }, 54, Pitch::flat }, { { 0, -28, 0 }, 54, Pitch::flat }, { { -1, -29, 0 }, 54, Pitch::flat }, { { -2, -30, 0 }, 54, Pitch::flat }, { { -2, -31, 0 }, 54, Pitch::flat }, { { -3, -32, 0 }, 54, Pitch::flat }, { { -4, -33, 0 }, 54, Pitch::flat }, { { -4, -34, 0 }, 54, Pitch::flat }, { { -5, -35, 0 }, 54, Pitch::flat }, { { -6, -36, 0 }, 54, Pitch::flat }, { { -7, -37, 0 }, 54, Pitch::flat }, { { -7, -38, 0 }, 54, Pitch::flat }, { { -8, -39, 0 }, 56, Pitch::flat }, { { -9, -40, 0 }, 56, Pitch::flat }, { { -10, -41, 0 }, 56, Pitch::flat }, { { -11, -42, 0 }, 56, Pitch::flat }, { { -12, -43, 0 }, 56, Pitch::flat }, { { -12, -44, 0 }, 56, Pitch::flat }, { { -13, -45, 0 }, 56, Pitch::flat }, { { -14, -46, 0 }, 56, Pitch::flat }, { { -15, -47, 0 }, 56, Pitch::flat }, { { -16, -48, 0 }, 56, Pitch::flat }, }); // 0x4e35a2 // Track 9. Reversed 1. Direction 0 static constexpr auto moveInfoT9R1D0 = std::to_array<MoveInfo>( { { { 16, 15, 0 }, 40, Pitch::flat }, { { 17, 14, 0 }, 40, Pitch::flat }, { { 18, 13, 0 }, 40, Pitch::flat }, { { 19, 12, 0 }, 40, Pitch::flat }, { { 20, 12, 0 }, 40, Pitch::flat }, { { 21, 11, 0 }, 40, Pitch::flat }, { { 22, 10, 0 }, 40, Pitch::flat }, { { 23, 9, 0 }, 38, Pitch::flat }, { { 24, 8, 0 }, 38, Pitch::flat }, { { 25, 7, 0 }, 38, Pitch::flat }, { { 26, 7, 0 }, 38, Pitch::flat }, { { 27, 6, 0 }, 38, Pitch::flat }, { { 28, 5, 0 }, 38, Pitch::flat }, { { 29, 4, 0 }, 38, Pitch::flat }, { { 30, 4, 0 }, 38, Pitch::flat }, { { 31, 3, 0 }, 38, Pitch::flat }, { { 32, 2, 0 }, 38, Pitch::flat }, { { 33, 2, 0 }, 38, Pitch::flat }, { { 34, 1, 0 }, 38, Pitch::flat }, { { 35, 0, 0 }, 38, Pitch::flat }, { { 36, 0, 0 }, 38, Pitch::flat }, { { 37, -1, 0 }, 38, Pitch::flat }, { { 38, -2, 0 }, 38, Pitch::flat }, { { 39, -2, 0 }, 38, Pitch::flat }, { { 40, -3, 0 }, 38, Pitch::flat }, { { 41, -3, 0 }, 38, Pitch::flat }, { { 42, -4, 0 }, 36, Pitch::flat }, { { 43, -4, 0 }, 36, Pitch::flat }, { { 44, -5, 0 }, 36, Pitch::flat }, { { 45, -5, 0 }, 36, Pitch::flat }, { { 46, -6, 0 }, 36, Pitch::flat }, { { 47, -6, 0 }, 36, Pitch::flat }, { { 48, -7, 0 }, 36, Pitch::flat }, { { 49, -7, 0 }, 36, Pitch::flat }, { { 50, -8, 0 }, 36, Pitch::flat }, { { 51, -8, 0 }, 36, Pitch::flat }, { { 52, -8, 0 }, 36, Pitch::flat }, { { 53, -9, 0 }, 36, Pitch::flat }, { { 54, -9, 0 }, 36, Pitch::flat }, { { 55, -9, 0 }, 36, Pitch::flat }, { { 56, -10, 0 }, 36, Pitch::flat }, { { 57, -10, 0 }, 36, Pitch::flat }, { { 58, -10, 0 }, 36, Pitch::flat }, { { 59, -11, 0 }, 36, Pitch::flat }, { { 60, -11, 0 }, 36, Pitch::flat }, { { 61, -11, 0 }, 36, Pitch::flat }, { { 62, -11, 0 }, 34, Pitch::flat }, { { 63, -12, 0 }, 34, Pitch::flat }, { { 64, -12, 0 }, 34, Pitch::flat }, { { 65, -12, 0 }, 34, Pitch::flat }, { { 66, -12, 0 }, 34, Pitch::flat }, { { 67, -13, 0 }, 34, Pitch::flat }, { { 68, -13, 0 }, 34, Pitch::flat }, { { 69, -13, 0 }, 34, Pitch::flat }, { { 70, -13, 0 }, 34, Pitch::flat }, { { 71, -13, 0 }, 34, Pitch::flat }, { { 72, -14, 0 }, 34, Pitch::flat }, { { 73, -14, 0 }, 34, Pitch::flat }, { { 74, -14, 0 }, 34, Pitch::flat }, { { 75, -14, 0 }, 34, Pitch::flat }, { { 76, -14, 0 }, 34, Pitch::flat }, { { 77, -15, 0 }, 34, Pitch::flat }, { { 78, -15, 0 }, 34, Pitch::flat }, { { 79, -15, 0 }, 34, Pitch::flat }, { { 80, -15, 0 }, 34, Pitch::flat }, { { 81, -15, 0 }, 34, Pitch::flat }, { { 82, -16, 0 }, 32, Pitch::flat }, { { 83, -16, 0 }, 32, Pitch::flat }, { { 84, -16, 0 }, 32, Pitch::flat }, { { 85, -16, 0 }, 32, Pitch::flat }, { { 86, -16, 0 }, 32, Pitch::flat }, { { 87, -16, 0 }, 32, Pitch::flat }, { { 88, -16, 0 }, 32, Pitch::flat }, { { 89, -16, 0 }, 32, Pitch::flat }, { { 90, -16, 0 }, 32, Pitch::flat }, { { 91, -16, 0 }, 32, Pitch::flat }, { { 92, -16, 0 }, 32, Pitch::flat }, { { 93, -16, 0 }, 32, Pitch::flat }, { { 94, -16, 0 }, 32, Pitch::flat }, { { 95, -16, 0 }, 32, Pitch::flat }, }); // 0x4e3824 // Track 9. Reversed 1. Direction 1 static constexpr auto moveInfoT9R1D1 = std::to_array<MoveInfo>( { { { 15, 15, 0 }, 56, Pitch::flat }, { { 14, 14, 0 }, 56, Pitch::flat }, { { 13, 13, 0 }, 56, Pitch::flat }, { { 12, 12, 0 }, 56, Pitch::flat }, { { 12, 11, 0 }, 56, Pitch::flat }, { { 11, 10, 0 }, 56, Pitch::flat }, { { 10, 9, 0 }, 56, Pitch::flat }, { { 9, 8, 0 }, 54, Pitch::flat }, { { 8, 7, 0 }, 54, Pitch::flat }, { { 7, 6, 0 }, 54, Pitch::flat }, { { 7, 5, 0 }, 54, Pitch::flat }, { { 6, 4, 0 }, 54, Pitch::flat }, { { 5, 3, 0 }, 54, Pitch::flat }, { { 4, 2, 0 }, 54, Pitch::flat }, { { 4, 1, 0 }, 54, Pitch::flat }, { { 3, 0, 0 }, 54, Pitch::flat }, { { 2, -1, 0 }, 54, Pitch::flat }, { { 2, -2, 0 }, 54, Pitch::flat }, { { 1, -3, 0 }, 54, Pitch::flat }, { { 0, -4, 0 }, 54, Pitch::flat }, { { 0, -5, 0 }, 54, Pitch::flat }, { { -1, -6, 0 }, 54, Pitch::flat }, { { -2, -7, 0 }, 54, Pitch::flat }, { { -2, -8, 0 }, 54, Pitch::flat }, { { -3, -9, 0 }, 54, Pitch::flat }, { { -3, -10, 0 }, 54, Pitch::flat }, { { -4, -11, 0 }, 52, Pitch::flat }, { { -4, -12, 0 }, 52, Pitch::flat }, { { -5, -13, 0 }, 52, Pitch::flat }, { { -5, -14, 0 }, 52, Pitch::flat }, { { -6, -15, 0 }, 52, Pitch::flat }, { { -6, -16, 0 }, 52, Pitch::flat }, { { -7, -17, 0 }, 52, Pitch::flat }, { { -7, -18, 0 }, 52, Pitch::flat }, { { -8, -19, 0 }, 52, Pitch::flat }, { { -8, -20, 0 }, 52, Pitch::flat }, { { -8, -21, 0 }, 52, Pitch::flat }, { { -9, -22, 0 }, 52, Pitch::flat }, { { -9, -23, 0 }, 52, Pitch::flat }, { { -9, -24, 0 }, 52, Pitch::flat }, { { -10, -25, 0 }, 52, Pitch::flat }, { { -10, -26, 0 }, 52, Pitch::flat }, { { -10, -27, 0 }, 52, Pitch::flat }, { { -11, -28, 0 }, 52, Pitch::flat }, { { -11, -29, 0 }, 52, Pitch::flat }, { { -11, -30, 0 }, 52, Pitch::flat }, { { -11, -31, 0 }, 50, Pitch::flat }, { { -12, -32, 0 }, 50, Pitch::flat }, { { -12, -33, 0 }, 50, Pitch::flat }, { { -12, -34, 0 }, 50, Pitch::flat }, { { -12, -35, 0 }, 50, Pitch::flat }, { { -13, -36, 0 }, 50, Pitch::flat }, { { -13, -37, 0 }, 50, Pitch::flat }, { { -13, -38, 0 }, 50, Pitch::flat }, { { -13, -39, 0 }, 50, Pitch::flat }, { { -13, -40, 0 }, 50, Pitch::flat }, { { -14, -41, 0 }, 50, Pitch::flat }, { { -14, -42, 0 }, 50, Pitch::flat }, { { -14, -43, 0 }, 50, Pitch::flat }, { { -14, -44, 0 }, 50, Pitch::flat }, { { -14, -45, 0 }, 50, Pitch::flat }, { { -15, -46, 0 }, 50, Pitch::flat }, { { -15, -47, 0 }, 50, Pitch::flat }, { { -15, -48, 0 }, 50, Pitch::flat }, { { -15, -49, 0 }, 50, Pitch::flat }, { { -15, -50, 0 }, 50, Pitch::flat }, { { -16, -51, 0 }, 48, Pitch::flat }, { { -16, -52, 0 }, 48, Pitch::flat }, { { -16, -53, 0 }, 48, Pitch::flat }, { { -16, -54, 0 }, 48, Pitch::flat }, { { -16, -55, 0 }, 48, Pitch::flat }, { { -16, -56, 0 }, 48, Pitch::flat }, { { -16, -57, 0 }, 48, Pitch::flat }, { { -16, -58, 0 }, 48, Pitch::flat }, { { -16, -59, 0 }, 48, Pitch::flat }, { { -16, -60, 0 }, 48, Pitch::flat }, { { -16, -61, 0 }, 48, Pitch::flat }, { { -16, -62, 0 }, 48, Pitch::flat }, { { -16, -63, 0 }, 48, Pitch::flat }, { { -16, -64, 0 }, 48, Pitch::flat }, }); // 0x4e30a6 // Track 9. Reversed 1. Direction 2 static constexpr auto moveInfoT9R1D2 = std::to_array<MoveInfo>( { { { 15, 17, 0 }, 8, Pitch::flat }, { { 14, 18, 0 }, 8, Pitch::flat }, { { 13, 19, 0 }, 8, Pitch::flat }, { { 12, 20, 0 }, 8, Pitch::flat }, { { 11, 20, 0 }, 8, Pitch::flat }, { { 10, 21, 0 }, 8, Pitch::flat }, { { 9, 22, 0 }, 8, Pitch::flat }, { { 8, 23, 0 }, 6, Pitch::flat }, { { 7, 24, 0 }, 6, Pitch::flat }, { { 6, 25, 0 }, 6, Pitch::flat }, { { 5, 25, 0 }, 6, Pitch::flat }, { { 4, 26, 0 }, 6, Pitch::flat }, { { 3, 27, 0 }, 6, Pitch::flat }, { { 2, 28, 0 }, 6, Pitch::flat }, { { 1, 28, 0 }, 6, Pitch::flat }, { { 0, 29, 0 }, 6, Pitch::flat }, { { -1, 30, 0 }, 6, Pitch::flat }, { { -2, 30, 0 }, 6, Pitch::flat }, { { -3, 31, 0 }, 6, Pitch::flat }, { { -4, 32, 0 }, 6, Pitch::flat }, { { -5, 32, 0 }, 6, Pitch::flat }, { { -6, 33, 0 }, 6, Pitch::flat }, { { -7, 34, 0 }, 6, Pitch::flat }, { { -8, 34, 0 }, 6, Pitch::flat }, { { -9, 35, 0 }, 6, Pitch::flat }, { { -10, 35, 0 }, 6, Pitch::flat }, { { -11, 36, 0 }, 4, Pitch::flat }, { { -12, 36, 0 }, 4, Pitch::flat }, { { -13, 37, 0 }, 4, Pitch::flat }, { { -14, 37, 0 }, 4, Pitch::flat }, { { -15, 38, 0 }, 4, Pitch::flat }, { { -16, 38, 0 }, 4, Pitch::flat }, { { -17, 39, 0 }, 4, Pitch::flat }, { { -18, 39, 0 }, 4, Pitch::flat }, { { -19, 40, 0 }, 4, Pitch::flat }, { { -20, 40, 0 }, 4, Pitch::flat }, { { -21, 40, 0 }, 4, Pitch::flat }, { { -22, 41, 0 }, 4, Pitch::flat }, { { -23, 41, 0 }, 4, Pitch::flat }, { { -24, 41, 0 }, 4, Pitch::flat }, { { -25, 42, 0 }, 4, Pitch::flat }, { { -26, 42, 0 }, 4, Pitch::flat }, { { -27, 42, 0 }, 4, Pitch::flat }, { { -28, 43, 0 }, 4, Pitch::flat }, { { -29, 43, 0 }, 4, Pitch::flat }, { { -30, 43, 0 }, 4, Pitch::flat }, { { -31, 43, 0 }, 2, Pitch::flat }, { { -32, 44, 0 }, 2, Pitch::flat }, { { -33, 44, 0 }, 2, Pitch::flat }, { { -34, 44, 0 }, 2, Pitch::flat }, { { -35, 44, 0 }, 2, Pitch::flat }, { { -36, 45, 0 }, 2, Pitch::flat }, { { -37, 45, 0 }, 2, Pitch::flat }, { { -38, 45, 0 }, 2, Pitch::flat }, { { -39, 45, 0 }, 2, Pitch::flat }, { { -40, 45, 0 }, 2, Pitch::flat }, { { -41, 46, 0 }, 2, Pitch::flat }, { { -42, 46, 0 }, 2, Pitch::flat }, { { -43, 46, 0 }, 2, Pitch::flat }, { { -44, 46, 0 }, 2, Pitch::flat }, { { -45, 46, 0 }, 2, Pitch::flat }, { { -46, 47, 0 }, 2, Pitch::flat }, { { -47, 47, 0 }, 2, Pitch::flat }, { { -48, 47, 0 }, 2, Pitch::flat }, { { -49, 47, 0 }, 2, Pitch::flat }, { { -50, 47, 0 }, 2, Pitch::flat }, { { -51, 48, 0 }, 0, Pitch::flat }, { { -52, 48, 0 }, 0, Pitch::flat }, { { -53, 48, 0 }, 0, Pitch::flat }, { { -54, 48, 0 }, 0, Pitch::flat }, { { -55, 48, 0 }, 0, Pitch::flat }, { { -56, 48, 0 }, 0, Pitch::flat }, { { -57, 48, 0 }, 0, Pitch::flat }, { { -58, 48, 0 }, 0, Pitch::flat }, { { -59, 48, 0 }, 0, Pitch::flat }, { { -60, 48, 0 }, 0, Pitch::flat }, { { -61, 48, 0 }, 0, Pitch::flat }, { { -62, 48, 0 }, 0, Pitch::flat }, { { -63, 48, 0 }, 0, Pitch::flat }, }); // 0x4e3320 // Track 9. Reversed 1. Direction 3 static constexpr auto moveInfoT9R1D3 = std::to_array<MoveInfo>( { { { 16, 16, 0 }, 24, Pitch::flat }, { { 17, 17, 0 }, 24, Pitch::flat }, { { 18, 18, 0 }, 24, Pitch::flat }, { { 19, 19, 0 }, 24, Pitch::flat }, { { 20, 20, 0 }, 24, Pitch::flat }, { { 20, 21, 0 }, 24, Pitch::flat }, { { 21, 22, 0 }, 24, Pitch::flat }, { { 22, 23, 0 }, 24, Pitch::flat }, { { 23, 24, 0 }, 22, Pitch::flat }, { { 24, 25, 0 }, 22, Pitch::flat }, { { 25, 26, 0 }, 22, Pitch::flat }, { { 25, 27, 0 }, 22, Pitch::flat }, { { 26, 28, 0 }, 22, Pitch::flat }, { { 27, 29, 0 }, 22, Pitch::flat }, { { 28, 30, 0 }, 22, Pitch::flat }, { { 28, 31, 0 }, 22, Pitch::flat }, { { 29, 32, 0 }, 22, Pitch::flat }, { { 30, 33, 0 }, 22, Pitch::flat }, { { 30, 34, 0 }, 22, Pitch::flat }, { { 31, 35, 0 }, 22, Pitch::flat }, { { 32, 36, 0 }, 22, Pitch::flat }, { { 32, 37, 0 }, 22, Pitch::flat }, { { 33, 38, 0 }, 22, Pitch::flat }, { { 34, 39, 0 }, 22, Pitch::flat }, { { 34, 40, 0 }, 22, Pitch::flat }, { { 35, 41, 0 }, 22, Pitch::flat }, { { 35, 42, 0 }, 22, Pitch::flat }, { { 36, 43, 0 }, 20, Pitch::flat }, { { 36, 44, 0 }, 20, Pitch::flat }, { { 37, 45, 0 }, 20, Pitch::flat }, { { 37, 46, 0 }, 20, Pitch::flat }, { { 38, 47, 0 }, 20, Pitch::flat }, { { 38, 48, 0 }, 20, Pitch::flat }, { { 39, 49, 0 }, 20, Pitch::flat }, { { 39, 50, 0 }, 20, Pitch::flat }, { { 40, 51, 0 }, 20, Pitch::flat }, { { 40, 52, 0 }, 20, Pitch::flat }, { { 40, 53, 0 }, 20, Pitch::flat }, { { 41, 54, 0 }, 20, Pitch::flat }, { { 41, 55, 0 }, 20, Pitch::flat }, { { 41, 56, 0 }, 20, Pitch::flat }, { { 42, 57, 0 }, 20, Pitch::flat }, { { 42, 58, 0 }, 20, Pitch::flat }, { { 42, 59, 0 }, 20, Pitch::flat }, { { 43, 60, 0 }, 20, Pitch::flat }, { { 43, 61, 0 }, 20, Pitch::flat }, { { 43, 62, 0 }, 20, Pitch::flat }, { { 43, 63, 0 }, 18, Pitch::flat }, { { 44, 64, 0 }, 18, Pitch::flat }, { { 44, 65, 0 }, 18, Pitch::flat }, { { 44, 66, 0 }, 18, Pitch::flat }, { { 44, 67, 0 }, 18, Pitch::flat }, { { 45, 68, 0 }, 18, Pitch::flat }, { { 45, 69, 0 }, 18, Pitch::flat }, { { 45, 70, 0 }, 18, Pitch::flat }, { { 45, 71, 0 }, 18, Pitch::flat }, { { 45, 72, 0 }, 18, Pitch::flat }, { { 46, 73, 0 }, 18, Pitch::flat }, { { 46, 74, 0 }, 18, Pitch::flat }, { { 46, 75, 0 }, 18, Pitch::flat }, { { 46, 76, 0 }, 18, Pitch::flat }, { { 46, 77, 0 }, 18, Pitch::flat }, { { 47, 78, 0 }, 18, Pitch::flat }, { { 47, 79, 0 }, 18, Pitch::flat }, { { 47, 80, 0 }, 18, Pitch::flat }, { { 47, 81, 0 }, 18, Pitch::flat }, { { 47, 82, 0 }, 18, Pitch::flat }, { { 48, 83, 0 }, 16, Pitch::flat }, { { 48, 84, 0 }, 16, Pitch::flat }, { { 48, 85, 0 }, 16, Pitch::flat }, { { 48, 86, 0 }, 16, Pitch::flat }, { { 48, 87, 0 }, 16, Pitch::flat }, { { 48, 88, 0 }, 16, Pitch::flat }, { { 48, 89, 0 }, 16, Pitch::flat }, { { 48, 90, 0 }, 16, Pitch::flat }, { { 48, 91, 0 }, 16, Pitch::flat }, { { 48, 92, 0 }, 16, Pitch::flat }, { { 48, 93, 0 }, 16, Pitch::flat }, { { 48, 94, 0 }, 16, Pitch::flat }, { { 48, 95, 0 }, 16, Pitch::flat }, }); // 0x4e4eae // Track 12. Reversed 0. Direction 0 static constexpr auto moveInfoT12R0D0 = std::to_array<MoveInfo>( { { { 32, 16, 0 }, 0, Pitch::flat }, { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 62, Pitch::flat }, { { 23, 15, 0 }, 62, Pitch::flat }, { { 22, 15, 0 }, 62, Pitch::flat }, { { 21, 15, 0 }, 62, Pitch::flat }, { { 20, 15, 0 }, 62, Pitch::flat }, { { 19, 15, 0 }, 62, Pitch::flat }, { { 18, 15, 0 }, 62, Pitch::flat }, { { 17, 14, 0 }, 62, Pitch::flat }, { { 16, 14, 0 }, 62, Pitch::flat }, { { 15, 14, 0 }, 62, Pitch::flat }, { { 14, 14, 0 }, 62, Pitch::flat }, { { 13, 14, 0 }, 62, Pitch::flat }, { { 12, 13, 0 }, 62, Pitch::flat }, { { 11, 13, 0 }, 62, Pitch::flat }, { { 10, 13, 0 }, 62, Pitch::flat }, { { 9, 13, 0 }, 62, Pitch::flat }, { { 8, 12, 0 }, 60, Pitch::flat }, { { 7, 12, 0 }, 60, Pitch::flat }, { { 6, 12, 0 }, 60, Pitch::flat }, { { 5, 11, 0 }, 60, Pitch::flat }, { { 4, 11, 0 }, 60, Pitch::flat }, { { 3, 11, 0 }, 60, Pitch::flat }, { { 2, 10, 0 }, 60, Pitch::flat }, { { 1, 10, 0 }, 60, Pitch::flat }, { { 0, 9, 0 }, 60, Pitch::flat }, { { -1, 9, 0 }, 60, Pitch::flat }, { { -2, 8, 0 }, 60, Pitch::flat }, { { -3, 8, 0 }, 60, Pitch::flat }, { { -4, 7, 0 }, 60, Pitch::flat }, { { -5, 7, 0 }, 58, Pitch::flat }, { { -6, 6, 0 }, 58, Pitch::flat }, { { -7, 6, 0 }, 58, Pitch::flat }, { { -8, 5, 0 }, 58, Pitch::flat }, { { -9, 4, 0 }, 58, Pitch::flat }, { { -10, 4, 0 }, 58, Pitch::flat }, { { -11, 3, 0 }, 58, Pitch::flat }, { { -12, 2, 0 }, 58, Pitch::flat }, { { -13, 2, 0 }, 56, Pitch::flat }, { { -14, 1, 0 }, 56, Pitch::flat }, { { -15, 0, 0 }, 56, Pitch::flat }, { { -16, 0, 0 }, 56, Pitch::flat }, { { -17, -1, 0 }, 56, Pitch::flat }, { { -18, -2, 0 }, 56, Pitch::flat }, { { -19, -2, 0 }, 58, Pitch::flat }, { { -20, -3, 0 }, 58, Pitch::flat }, { { -21, -4, 0 }, 58, Pitch::flat }, { { -22, -4, 0 }, 58, Pitch::flat }, { { -23, -5, 0 }, 58, Pitch::flat }, { { -24, -6, 0 }, 58, Pitch::flat }, { { -25, -6, 0 }, 58, Pitch::flat }, { { -26, -7, 0 }, 58, Pitch::flat }, { { -27, -7, 0 }, 58, Pitch::flat }, { { -28, -8, 0 }, 60, Pitch::flat }, { { -29, -8, 0 }, 60, Pitch::flat }, { { -30, -9, 0 }, 60, Pitch::flat }, { { -31, -9, 0 }, 60, Pitch::flat }, { { -32, -10, 0 }, 60, Pitch::flat }, { { -33, -10, 0 }, 60, Pitch::flat }, { { -34, -11, 0 }, 60, Pitch::flat }, { { -35, -11, 0 }, 60, Pitch::flat }, { { -36, -11, 0 }, 60, Pitch::flat }, { { -37, -12, 0 }, 60, Pitch::flat }, { { -38, -12, 0 }, 60, Pitch::flat }, { { -39, -12, 0 }, 60, Pitch::flat }, { { -40, -13, 0 }, 62, Pitch::flat }, { { -41, -13, 0 }, 62, Pitch::flat }, { { -42, -13, 0 }, 62, Pitch::flat }, { { -43, -13, 0 }, 62, Pitch::flat }, { { -44, -14, 0 }, 62, Pitch::flat }, { { -45, -14, 0 }, 62, Pitch::flat }, { { -46, -14, 0 }, 62, Pitch::flat }, { { -47, -14, 0 }, 62, Pitch::flat }, { { -48, -14, 0 }, 62, Pitch::flat }, { { -49, -15, 0 }, 62, Pitch::flat }, { { -50, -15, 0 }, 62, Pitch::flat }, { { -51, -15, 0 }, 62, Pitch::flat }, { { -52, -15, 0 }, 62, Pitch::flat }, { { -53, -15, 0 }, 62, Pitch::flat }, { { -54, -15, 0 }, 62, Pitch::flat }, { { -55, -16, 0 }, 62, Pitch::flat }, { { -56, -16, 0 }, 0, Pitch::flat }, { { -57, -16, 0 }, 0, Pitch::flat }, { { -58, -16, 0 }, 0, Pitch::flat }, { { -59, -16, 0 }, 0, Pitch::flat }, { { -60, -16, 0 }, 0, Pitch::flat }, { { -61, -16, 0 }, 0, Pitch::flat }, { { -62, -16, 0 }, 0, Pitch::flat }, { { -63, -16, 0 }, 0, Pitch::flat }, }); // 0x4e51b0 // Track 12. Reversed 0. Direction 1 static constexpr auto moveInfoT12R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 14, Pitch::flat }, { { 15, 9, 0 }, 14, Pitch::flat }, { { 15, 10, 0 }, 14, Pitch::flat }, { { 15, 11, 0 }, 14, Pitch::flat }, { { 15, 12, 0 }, 14, Pitch::flat }, { { 15, 13, 0 }, 14, Pitch::flat }, { { 15, 14, 0 }, 14, Pitch::flat }, { { 14, 15, 0 }, 14, Pitch::flat }, { { 14, 16, 0 }, 14, Pitch::flat }, { { 14, 17, 0 }, 14, Pitch::flat }, { { 14, 18, 0 }, 14, Pitch::flat }, { { 14, 19, 0 }, 14, Pitch::flat }, { { 13, 20, 0 }, 14, Pitch::flat }, { { 13, 21, 0 }, 14, Pitch::flat }, { { 13, 22, 0 }, 14, Pitch::flat }, { { 13, 23, 0 }, 14, Pitch::flat }, { { 12, 24, 0 }, 12, Pitch::flat }, { { 12, 25, 0 }, 12, Pitch::flat }, { { 12, 26, 0 }, 12, Pitch::flat }, { { 11, 27, 0 }, 12, Pitch::flat }, { { 11, 28, 0 }, 12, Pitch::flat }, { { 11, 29, 0 }, 12, Pitch::flat }, { { 10, 30, 0 }, 12, Pitch::flat }, { { 10, 31, 0 }, 12, Pitch::flat }, { { 9, 32, 0 }, 12, Pitch::flat }, { { 9, 33, 0 }, 12, Pitch::flat }, { { 8, 34, 0 }, 12, Pitch::flat }, { { 8, 35, 0 }, 12, Pitch::flat }, { { 7, 36, 0 }, 12, Pitch::flat }, { { 7, 37, 0 }, 10, Pitch::flat }, { { 6, 38, 0 }, 10, Pitch::flat }, { { 6, 39, 0 }, 10, Pitch::flat }, { { 5, 40, 0 }, 10, Pitch::flat }, { { 4, 41, 0 }, 10, Pitch::flat }, { { 4, 42, 0 }, 10, Pitch::flat }, { { 3, 43, 0 }, 10, Pitch::flat }, { { 2, 44, 0 }, 10, Pitch::flat }, { { 2, 45, 0 }, 8, Pitch::flat }, { { 1, 46, 0 }, 8, Pitch::flat }, { { 0, 47, 0 }, 8, Pitch::flat }, { { 0, 48, 0 }, 8, Pitch::flat }, { { -1, 49, 0 }, 8, Pitch::flat }, { { -2, 50, 0 }, 8, Pitch::flat }, { { -2, 51, 0 }, 10, Pitch::flat }, { { -3, 52, 0 }, 10, Pitch::flat }, { { -4, 53, 0 }, 10, Pitch::flat }, { { -4, 54, 0 }, 10, Pitch::flat }, { { -5, 55, 0 }, 10, Pitch::flat }, { { -6, 56, 0 }, 10, Pitch::flat }, { { -6, 57, 0 }, 10, Pitch::flat }, { { -7, 58, 0 }, 10, Pitch::flat }, { { -7, 59, 0 }, 10, Pitch::flat }, { { -8, 60, 0 }, 12, Pitch::flat }, { { -8, 61, 0 }, 12, Pitch::flat }, { { -9, 62, 0 }, 12, Pitch::flat }, { { -9, 63, 0 }, 12, Pitch::flat }, { { -10, 64, 0 }, 12, Pitch::flat }, { { -10, 65, 0 }, 12, Pitch::flat }, { { -11, 66, 0 }, 12, Pitch::flat }, { { -11, 67, 0 }, 12, Pitch::flat }, { { -11, 68, 0 }, 12, Pitch::flat }, { { -12, 69, 0 }, 12, Pitch::flat }, { { -12, 70, 0 }, 12, Pitch::flat }, { { -12, 71, 0 }, 12, Pitch::flat }, { { -13, 72, 0 }, 14, Pitch::flat }, { { -13, 73, 0 }, 14, Pitch::flat }, { { -13, 74, 0 }, 14, Pitch::flat }, { { -13, 75, 0 }, 14, Pitch::flat }, { { -14, 76, 0 }, 14, Pitch::flat }, { { -14, 77, 0 }, 14, Pitch::flat }, { { -14, 78, 0 }, 14, Pitch::flat }, { { -14, 79, 0 }, 14, Pitch::flat }, { { -14, 80, 0 }, 14, Pitch::flat }, { { -15, 81, 0 }, 14, Pitch::flat }, { { -15, 82, 0 }, 14, Pitch::flat }, { { -15, 83, 0 }, 14, Pitch::flat }, { { -15, 84, 0 }, 14, Pitch::flat }, { { -15, 85, 0 }, 14, Pitch::flat }, { { -15, 86, 0 }, 14, Pitch::flat }, { { -16, 87, 0 }, 14, Pitch::flat }, { { -16, 88, 0 }, 16, Pitch::flat }, { { -16, 89, 0 }, 16, Pitch::flat }, { { -16, 90, 0 }, 16, Pitch::flat }, { { -16, 91, 0 }, 16, Pitch::flat }, { { -16, 92, 0 }, 16, Pitch::flat }, { { -16, 93, 0 }, 16, Pitch::flat }, { { -16, 94, 0 }, 16, Pitch::flat }, { { -16, 95, 0 }, 16, Pitch::flat }, }); // 0x4e54b2 // Track 12. Reversed 0. Direction 2 static constexpr auto moveInfoT12R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 30, Pitch::flat }, { { 9, 17, 0 }, 30, Pitch::flat }, { { 10, 17, 0 }, 30, Pitch::flat }, { { 11, 17, 0 }, 30, Pitch::flat }, { { 12, 17, 0 }, 30, Pitch::flat }, { { 13, 17, 0 }, 30, Pitch::flat }, { { 14, 17, 0 }, 30, Pitch::flat }, { { 15, 18, 0 }, 30, Pitch::flat }, { { 16, 18, 0 }, 30, Pitch::flat }, { { 17, 18, 0 }, 30, Pitch::flat }, { { 18, 18, 0 }, 30, Pitch::flat }, { { 19, 18, 0 }, 30, Pitch::flat }, { { 20, 19, 0 }, 30, Pitch::flat }, { { 21, 19, 0 }, 30, Pitch::flat }, { { 22, 19, 0 }, 30, Pitch::flat }, { { 23, 19, 0 }, 30, Pitch::flat }, { { 24, 20, 0 }, 28, Pitch::flat }, { { 25, 20, 0 }, 28, Pitch::flat }, { { 26, 20, 0 }, 28, Pitch::flat }, { { 27, 21, 0 }, 28, Pitch::flat }, { { 28, 21, 0 }, 28, Pitch::flat }, { { 29, 21, 0 }, 28, Pitch::flat }, { { 30, 22, 0 }, 28, Pitch::flat }, { { 31, 22, 0 }, 28, Pitch::flat }, { { 32, 23, 0 }, 28, Pitch::flat }, { { 33, 23, 0 }, 28, Pitch::flat }, { { 34, 24, 0 }, 28, Pitch::flat }, { { 35, 24, 0 }, 28, Pitch::flat }, { { 36, 25, 0 }, 28, Pitch::flat }, { { 37, 25, 0 }, 26, Pitch::flat }, { { 38, 26, 0 }, 26, Pitch::flat }, { { 39, 26, 0 }, 26, Pitch::flat }, { { 40, 27, 0 }, 26, Pitch::flat }, { { 41, 28, 0 }, 26, Pitch::flat }, { { 42, 28, 0 }, 26, Pitch::flat }, { { 43, 29, 0 }, 26, Pitch::flat }, { { 44, 30, 0 }, 26, Pitch::flat }, { { 45, 30, 0 }, 24, Pitch::flat }, { { 46, 31, 0 }, 24, Pitch::flat }, { { 47, 32, 0 }, 24, Pitch::flat }, { { 48, 32, 0 }, 24, Pitch::flat }, { { 49, 33, 0 }, 24, Pitch::flat }, { { 50, 34, 0 }, 24, Pitch::flat }, { { 51, 34, 0 }, 26, Pitch::flat }, { { 52, 35, 0 }, 26, Pitch::flat }, { { 53, 36, 0 }, 26, Pitch::flat }, { { 54, 36, 0 }, 26, Pitch::flat }, { { 55, 37, 0 }, 26, Pitch::flat }, { { 56, 38, 0 }, 26, Pitch::flat }, { { 57, 38, 0 }, 26, Pitch::flat }, { { 58, 39, 0 }, 26, Pitch::flat }, { { 59, 39, 0 }, 26, Pitch::flat }, { { 60, 40, 0 }, 28, Pitch::flat }, { { 61, 40, 0 }, 28, Pitch::flat }, { { 62, 41, 0 }, 28, Pitch::flat }, { { 63, 41, 0 }, 28, Pitch::flat }, { { 64, 42, 0 }, 28, Pitch::flat }, { { 65, 42, 0 }, 28, Pitch::flat }, { { 66, 43, 0 }, 28, Pitch::flat }, { { 67, 43, 0 }, 28, Pitch::flat }, { { 68, 43, 0 }, 28, Pitch::flat }, { { 69, 44, 0 }, 28, Pitch::flat }, { { 70, 44, 0 }, 28, Pitch::flat }, { { 71, 44, 0 }, 28, Pitch::flat }, { { 72, 45, 0 }, 30, Pitch::flat }, { { 73, 45, 0 }, 30, Pitch::flat }, { { 74, 45, 0 }, 30, Pitch::flat }, { { 75, 45, 0 }, 30, Pitch::flat }, { { 76, 46, 0 }, 30, Pitch::flat }, { { 77, 46, 0 }, 30, Pitch::flat }, { { 78, 46, 0 }, 30, Pitch::flat }, { { 79, 46, 0 }, 30, Pitch::flat }, { { 80, 46, 0 }, 30, Pitch::flat }, { { 81, 47, 0 }, 30, Pitch::flat }, { { 82, 47, 0 }, 30, Pitch::flat }, { { 83, 47, 0 }, 30, Pitch::flat }, { { 84, 47, 0 }, 30, Pitch::flat }, { { 85, 47, 0 }, 30, Pitch::flat }, { { 86, 47, 0 }, 30, Pitch::flat }, { { 87, 48, 0 }, 30, Pitch::flat }, { { 88, 48, 0 }, 32, Pitch::flat }, { { 89, 48, 0 }, 32, Pitch::flat }, { { 90, 48, 0 }, 32, Pitch::flat }, { { 91, 48, 0 }, 32, Pitch::flat }, { { 92, 48, 0 }, 32, Pitch::flat }, { { 93, 48, 0 }, 32, Pitch::flat }, { { 94, 48, 0 }, 32, Pitch::flat }, { { 95, 48, 0 }, 32, Pitch::flat }, }); // 0x4e57b4 // Track 12. Reversed 0. Direction 3 static constexpr auto moveInfoT12R0D3 = std::to_array<MoveInfo>( { { { 16, 32, 0 }, 48, Pitch::flat }, { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 46, Pitch::flat }, { { 17, 23, 0 }, 46, Pitch::flat }, { { 17, 22, 0 }, 46, Pitch::flat }, { { 17, 21, 0 }, 46, Pitch::flat }, { { 17, 20, 0 }, 46, Pitch::flat }, { { 17, 19, 0 }, 46, Pitch::flat }, { { 17, 18, 0 }, 46, Pitch::flat }, { { 18, 17, 0 }, 46, Pitch::flat }, { { 18, 16, 0 }, 46, Pitch::flat }, { { 18, 15, 0 }, 46, Pitch::flat }, { { 18, 14, 0 }, 46, Pitch::flat }, { { 18, 13, 0 }, 46, Pitch::flat }, { { 19, 12, 0 }, 46, Pitch::flat }, { { 19, 11, 0 }, 46, Pitch::flat }, { { 19, 10, 0 }, 46, Pitch::flat }, { { 19, 9, 0 }, 46, Pitch::flat }, { { 20, 8, 0 }, 44, Pitch::flat }, { { 20, 7, 0 }, 44, Pitch::flat }, { { 20, 6, 0 }, 44, Pitch::flat }, { { 21, 5, 0 }, 44, Pitch::flat }, { { 21, 4, 0 }, 44, Pitch::flat }, { { 21, 3, 0 }, 44, Pitch::flat }, { { 22, 2, 0 }, 44, Pitch::flat }, { { 22, 1, 0 }, 44, Pitch::flat }, { { 23, 0, 0 }, 44, Pitch::flat }, { { 23, -1, 0 }, 44, Pitch::flat }, { { 24, -2, 0 }, 44, Pitch::flat }, { { 24, -3, 0 }, 44, Pitch::flat }, { { 25, -4, 0 }, 44, Pitch::flat }, { { 25, -5, 0 }, 42, Pitch::flat }, { { 26, -6, 0 }, 42, Pitch::flat }, { { 26, -7, 0 }, 42, Pitch::flat }, { { 27, -8, 0 }, 42, Pitch::flat }, { { 28, -9, 0 }, 42, Pitch::flat }, { { 28, -10, 0 }, 42, Pitch::flat }, { { 29, -11, 0 }, 42, Pitch::flat }, { { 30, -12, 0 }, 42, Pitch::flat }, { { 30, -13, 0 }, 40, Pitch::flat }, { { 31, -14, 0 }, 40, Pitch::flat }, { { 32, -15, 0 }, 40, Pitch::flat }, { { 32, -16, 0 }, 40, Pitch::flat }, { { 33, -17, 0 }, 40, Pitch::flat }, { { 34, -18, 0 }, 40, Pitch::flat }, { { 34, -19, 0 }, 42, Pitch::flat }, { { 35, -20, 0 }, 42, Pitch::flat }, { { 36, -21, 0 }, 42, Pitch::flat }, { { 36, -22, 0 }, 42, Pitch::flat }, { { 37, -23, 0 }, 42, Pitch::flat }, { { 38, -24, 0 }, 42, Pitch::flat }, { { 38, -25, 0 }, 42, Pitch::flat }, { { 39, -26, 0 }, 42, Pitch::flat }, { { 39, -27, 0 }, 42, Pitch::flat }, { { 40, -28, 0 }, 44, Pitch::flat }, { { 40, -29, 0 }, 44, Pitch::flat }, { { 41, -30, 0 }, 44, Pitch::flat }, { { 41, -31, 0 }, 44, Pitch::flat }, { { 42, -32, 0 }, 44, Pitch::flat }, { { 42, -33, 0 }, 44, Pitch::flat }, { { 43, -34, 0 }, 44, Pitch::flat }, { { 43, -35, 0 }, 44, Pitch::flat }, { { 43, -36, 0 }, 44, Pitch::flat }, { { 44, -37, 0 }, 44, Pitch::flat }, { { 44, -38, 0 }, 44, Pitch::flat }, { { 44, -39, 0 }, 44, Pitch::flat }, { { 45, -40, 0 }, 46, Pitch::flat }, { { 45, -41, 0 }, 46, Pitch::flat }, { { 45, -42, 0 }, 46, Pitch::flat }, { { 45, -43, 0 }, 46, Pitch::flat }, { { 46, -44, 0 }, 46, Pitch::flat }, { { 46, -45, 0 }, 46, Pitch::flat }, { { 46, -46, 0 }, 46, Pitch::flat }, { { 46, -47, 0 }, 46, Pitch::flat }, { { 46, -48, 0 }, 46, Pitch::flat }, { { 47, -49, 0 }, 46, Pitch::flat }, { { 47, -50, 0 }, 46, Pitch::flat }, { { 47, -51, 0 }, 46, Pitch::flat }, { { 47, -52, 0 }, 46, Pitch::flat }, { { 47, -53, 0 }, 46, Pitch::flat }, { { 47, -54, 0 }, 46, Pitch::flat }, { { 48, -55, 0 }, 46, Pitch::flat }, { { 48, -56, 0 }, 48, Pitch::flat }, { { 48, -57, 0 }, 48, Pitch::flat }, { { 48, -58, 0 }, 48, Pitch::flat }, { { 48, -59, 0 }, 48, Pitch::flat }, { { 48, -60, 0 }, 48, Pitch::flat }, { { 48, -61, 0 }, 48, Pitch::flat }, { { 48, -62, 0 }, 48, Pitch::flat }, { { 48, -63, 0 }, 48, Pitch::flat }, }); // 0x4e5ab6 // Track 13. Reversed 0. Direction 0 static constexpr auto moveInfoT13R0D0 = std::to_array<MoveInfo>( { { { 32, 16, 0 }, 0, Pitch::flat }, { { 31, 16, 0 }, 0, Pitch::flat }, { { 30, 16, 0 }, 0, Pitch::flat }, { { 29, 16, 0 }, 0, Pitch::flat }, { { 28, 16, 0 }, 0, Pitch::flat }, { { 27, 16, 0 }, 0, Pitch::flat }, { { 26, 16, 0 }, 0, Pitch::flat }, { { 25, 16, 0 }, 0, Pitch::flat }, { { 24, 16, 0 }, 2, Pitch::flat }, { { 23, 17, 0 }, 2, Pitch::flat }, { { 22, 17, 0 }, 2, Pitch::flat }, { { 21, 17, 0 }, 2, Pitch::flat }, { { 20, 17, 0 }, 2, Pitch::flat }, { { 19, 17, 0 }, 2, Pitch::flat }, { { 18, 17, 0 }, 2, Pitch::flat }, { { 17, 18, 0 }, 2, Pitch::flat }, { { 16, 18, 0 }, 2, Pitch::flat }, { { 15, 18, 0 }, 2, Pitch::flat }, { { 14, 18, 0 }, 2, Pitch::flat }, { { 13, 18, 0 }, 2, Pitch::flat }, { { 12, 19, 0 }, 2, Pitch::flat }, { { 11, 19, 0 }, 2, Pitch::flat }, { { 10, 19, 0 }, 2, Pitch::flat }, { { 9, 19, 0 }, 2, Pitch::flat }, { { 8, 20, 0 }, 4, Pitch::flat }, { { 7, 20, 0 }, 4, Pitch::flat }, { { 6, 20, 0 }, 4, Pitch::flat }, { { 5, 21, 0 }, 4, Pitch::flat }, { { 4, 21, 0 }, 4, Pitch::flat }, { { 3, 21, 0 }, 4, Pitch::flat }, { { 2, 22, 0 }, 4, Pitch::flat }, { { 1, 22, 0 }, 4, Pitch::flat }, { { 0, 23, 0 }, 4, Pitch::flat }, { { -1, 23, 0 }, 4, Pitch::flat }, { { -2, 24, 0 }, 4, Pitch::flat }, { { -3, 24, 0 }, 4, Pitch::flat }, { { -4, 25, 0 }, 4, Pitch::flat }, { { -5, 25, 0 }, 10, Pitch::flat }, { { -6, 26, 0 }, 10, Pitch::flat }, { { -7, 26, 0 }, 10, Pitch::flat }, { { -8, 27, 0 }, 10, Pitch::flat }, { { -9, 28, 0 }, 10, Pitch::flat }, { { -10, 28, 0 }, 10, Pitch::flat }, { { -11, 29, 0 }, 10, Pitch::flat }, { { -12, 30, 0 }, 10, Pitch::flat }, { { -13, 30, 0 }, 8, Pitch::flat }, { { -14, 31, 0 }, 8, Pitch::flat }, { { -15, 32, 0 }, 8, Pitch::flat }, { { -16, 32, 0 }, 8, Pitch::flat }, { { -17, 33, 0 }, 8, Pitch::flat }, { { -18, 34, 0 }, 8, Pitch::flat }, { { -19, 34, 0 }, 6, Pitch::flat }, { { -20, 35, 0 }, 6, Pitch::flat }, { { -21, 36, 0 }, 6, Pitch::flat }, { { -22, 36, 0 }, 6, Pitch::flat }, { { -23, 37, 0 }, 6, Pitch::flat }, { { -24, 38, 0 }, 6, Pitch::flat }, { { -25, 38, 0 }, 6, Pitch::flat }, { { -26, 39, 0 }, 6, Pitch::flat }, { { -27, 39, 0 }, 6, Pitch::flat }, { { -28, 40, 0 }, 4, Pitch::flat }, { { -29, 40, 0 }, 4, Pitch::flat }, { { -30, 41, 0 }, 4, Pitch::flat }, { { -31, 41, 0 }, 4, Pitch::flat }, { { -32, 42, 0 }, 4, Pitch::flat }, { { -33, 42, 0 }, 4, Pitch::flat }, { { -34, 43, 0 }, 4, Pitch::flat }, { { -35, 43, 0 }, 4, Pitch::flat }, { { -36, 43, 0 }, 4, Pitch::flat }, { { -37, 44, 0 }, 4, Pitch::flat }, { { -38, 44, 0 }, 4, Pitch::flat }, { { -39, 44, 0 }, 4, Pitch::flat }, { { -40, 45, 0 }, 2, Pitch::flat }, { { -41, 45, 0 }, 2, Pitch::flat }, { { -42, 45, 0 }, 2, Pitch::flat }, { { -43, 45, 0 }, 2, Pitch::flat }, { { -44, 46, 0 }, 2, Pitch::flat }, { { -45, 46, 0 }, 2, Pitch::flat }, { { -46, 46, 0 }, 2, Pitch::flat }, { { -47, 46, 0 }, 2, Pitch::flat }, { { -48, 46, 0 }, 2, Pitch::flat }, { { -49, 47, 0 }, 2, Pitch::flat }, { { -50, 47, 0 }, 2, Pitch::flat }, { { -51, 47, 0 }, 2, Pitch::flat }, { { -52, 47, 0 }, 2, Pitch::flat }, { { -53, 47, 0 }, 2, Pitch::flat }, { { -54, 47, 0 }, 2, Pitch::flat }, { { -55, 48, 0 }, 2, Pitch::flat }, { { -56, 48, 0 }, 0, Pitch::flat }, { { -57, 48, 0 }, 0, Pitch::flat }, { { -58, 48, 0 }, 0, Pitch::flat }, { { -59, 48, 0 }, 0, Pitch::flat }, { { -60, 48, 0 }, 0, Pitch::flat }, { { -61, 48, 0 }, 0, Pitch::flat }, { { -62, 48, 0 }, 0, Pitch::flat }, { { -63, 48, 0 }, 0, Pitch::flat }, }); // 0x4e5db8 // Track 13. Reversed 0. Direction 1 static constexpr auto moveInfoT13R0D1 = std::to_array<MoveInfo>( { { { 16, 0, 0 }, 16, Pitch::flat }, { { 16, 1, 0 }, 16, Pitch::flat }, { { 16, 2, 0 }, 16, Pitch::flat }, { { 16, 3, 0 }, 16, Pitch::flat }, { { 16, 4, 0 }, 16, Pitch::flat }, { { 16, 5, 0 }, 16, Pitch::flat }, { { 16, 6, 0 }, 16, Pitch::flat }, { { 16, 7, 0 }, 16, Pitch::flat }, { { 16, 8, 0 }, 18, Pitch::flat }, { { 17, 9, 0 }, 18, Pitch::flat }, { { 17, 10, 0 }, 18, Pitch::flat }, { { 17, 11, 0 }, 18, Pitch::flat }, { { 17, 12, 0 }, 18, Pitch::flat }, { { 17, 13, 0 }, 18, Pitch::flat }, { { 17, 14, 0 }, 18, Pitch::flat }, { { 18, 15, 0 }, 18, Pitch::flat }, { { 18, 16, 0 }, 18, Pitch::flat }, { { 18, 17, 0 }, 18, Pitch::flat }, { { 18, 18, 0 }, 18, Pitch::flat }, { { 18, 19, 0 }, 18, Pitch::flat }, { { 19, 20, 0 }, 18, Pitch::flat }, { { 19, 21, 0 }, 18, Pitch::flat }, { { 19, 22, 0 }, 18, Pitch::flat }, { { 19, 23, 0 }, 18, Pitch::flat }, { { 20, 24, 0 }, 20, Pitch::flat }, { { 20, 25, 0 }, 20, Pitch::flat }, { { 20, 26, 0 }, 20, Pitch::flat }, { { 21, 27, 0 }, 20, Pitch::flat }, { { 21, 28, 0 }, 20, Pitch::flat }, { { 21, 29, 0 }, 20, Pitch::flat }, { { 22, 30, 0 }, 20, Pitch::flat }, { { 22, 31, 0 }, 20, Pitch::flat }, { { 23, 32, 0 }, 20, Pitch::flat }, { { 23, 33, 0 }, 20, Pitch::flat }, { { 24, 34, 0 }, 20, Pitch::flat }, { { 24, 35, 0 }, 20, Pitch::flat }, { { 25, 36, 0 }, 20, Pitch::flat }, { { 25, 37, 0 }, 26, Pitch::flat }, { { 26, 38, 0 }, 26, Pitch::flat }, { { 26, 39, 0 }, 26, Pitch::flat }, { { 27, 40, 0 }, 26, Pitch::flat }, { { 28, 41, 0 }, 26, Pitch::flat }, { { 28, 42, 0 }, 26, Pitch::flat }, { { 29, 43, 0 }, 26, Pitch::flat }, { { 30, 44, 0 }, 26, Pitch::flat }, { { 30, 45, 0 }, 24, Pitch::flat }, { { 31, 46, 0 }, 24, Pitch::flat }, { { 32, 47, 0 }, 24, Pitch::flat }, { { 32, 48, 0 }, 24, Pitch::flat }, { { 33, 49, 0 }, 24, Pitch::flat }, { { 34, 50, 0 }, 24, Pitch::flat }, { { 34, 51, 0 }, 22, Pitch::flat }, { { 35, 52, 0 }, 22, Pitch::flat }, { { 36, 53, 0 }, 22, Pitch::flat }, { { 36, 54, 0 }, 22, Pitch::flat }, { { 37, 55, 0 }, 22, Pitch::flat }, { { 38, 56, 0 }, 22, Pitch::flat }, { { 38, 57, 0 }, 22, Pitch::flat }, { { 39, 58, 0 }, 22, Pitch::flat }, { { 39, 59, 0 }, 22, Pitch::flat }, { { 40, 60, 0 }, 20, Pitch::flat }, { { 40, 61, 0 }, 20, Pitch::flat }, { { 41, 62, 0 }, 20, Pitch::flat }, { { 41, 63, 0 }, 20, Pitch::flat }, { { 42, 64, 0 }, 20, Pitch::flat }, { { 42, 65, 0 }, 20, Pitch::flat }, { { 43, 66, 0 }, 20, Pitch::flat }, { { 43, 67, 0 }, 20, Pitch::flat }, { { 43, 68, 0 }, 20, Pitch::flat }, { { 44, 69, 0 }, 20, Pitch::flat }, { { 44, 70, 0 }, 20, Pitch::flat }, { { 44, 71, 0 }, 20, Pitch::flat }, { { 45, 72, 0 }, 18, Pitch::flat }, { { 45, 73, 0 }, 18, Pitch::flat }, { { 45, 74, 0 }, 18, Pitch::flat }, { { 45, 75, 0 }, 18, Pitch::flat }, { { 46, 76, 0 }, 18, Pitch::flat }, { { 46, 77, 0 }, 18, Pitch::flat }, { { 46, 78, 0 }, 18, Pitch::flat }, { { 46, 79, 0 }, 18, Pitch::flat }, { { 46, 80, 0 }, 18, Pitch::flat }, { { 47, 81, 0 }, 18, Pitch::flat }, { { 47, 82, 0 }, 18, Pitch::flat }, { { 47, 83, 0 }, 18, Pitch::flat }, { { 47, 84, 0 }, 18, Pitch::flat }, { { 47, 85, 0 }, 18, Pitch::flat }, { { 47, 86, 0 }, 18, Pitch::flat }, { { 48, 87, 0 }, 18, Pitch::flat }, { { 48, 88, 0 }, 16, Pitch::flat }, { { 48, 89, 0 }, 16, Pitch::flat }, { { 48, 90, 0 }, 16, Pitch::flat }, { { 48, 91, 0 }, 16, Pitch::flat }, { { 48, 92, 0 }, 16, Pitch::flat }, { { 48, 93, 0 }, 16, Pitch::flat }, { { 48, 94, 0 }, 16, Pitch::flat }, { { 48, 95, 0 }, 16, Pitch::flat }, }); // 0x4e60ba // Track 13. Reversed 0. Direction 2 static constexpr auto moveInfoT13R0D2 = std::to_array<MoveInfo>( { { { 0, 16, 0 }, 32, Pitch::flat }, { { 1, 16, 0 }, 32, Pitch::flat }, { { 2, 16, 0 }, 32, Pitch::flat }, { { 3, 16, 0 }, 32, Pitch::flat }, { { 4, 16, 0 }, 32, Pitch::flat }, { { 5, 16, 0 }, 32, Pitch::flat }, { { 6, 16, 0 }, 32, Pitch::flat }, { { 7, 16, 0 }, 32, Pitch::flat }, { { 8, 16, 0 }, 34, Pitch::flat }, { { 9, 15, 0 }, 34, Pitch::flat }, { { 10, 15, 0 }, 34, Pitch::flat }, { { 11, 15, 0 }, 34, Pitch::flat }, { { 12, 15, 0 }, 34, Pitch::flat }, { { 13, 15, 0 }, 34, Pitch::flat }, { { 14, 15, 0 }, 34, Pitch::flat }, { { 15, 14, 0 }, 34, Pitch::flat }, { { 16, 14, 0 }, 34, Pitch::flat }, { { 17, 14, 0 }, 34, Pitch::flat }, { { 18, 14, 0 }, 34, Pitch::flat }, { { 19, 14, 0 }, 34, Pitch::flat }, { { 20, 13, 0 }, 34, Pitch::flat }, { { 21, 13, 0 }, 34, Pitch::flat }, { { 22, 13, 0 }, 34, Pitch::flat }, { { 23, 13, 0 }, 34, Pitch::flat }, { { 24, 12, 0 }, 36, Pitch::flat }, { { 25, 12, 0 }, 36, Pitch::flat }, { { 26, 12, 0 }, 36, Pitch::flat }, { { 27, 11, 0 }, 36, Pitch::flat }, { { 28, 11, 0 }, 36, Pitch::flat }, { { 29, 11, 0 }, 36, Pitch::flat }, { { 30, 10, 0 }, 36, Pitch::flat }, { { 31, 10, 0 }, 36, Pitch::flat }, { { 32, 9, 0 }, 36, Pitch::flat }, { { 33, 9, 0 }, 36, Pitch::flat }, { { 34, 8, 0 }, 36, Pitch::flat }, { { 35, 8, 0 }, 36, Pitch::flat }, { { 36, 7, 0 }, 36, Pitch::flat }, { { 37, 7, 0 }, 42, Pitch::flat }, { { 38, 6, 0 }, 42, Pitch::flat }, { { 39, 6, 0 }, 42, Pitch::flat }, { { 40, 5, 0 }, 42, Pitch::flat }, { { 41, 4, 0 }, 42, Pitch::flat }, { { 42, 4, 0 }, 42, Pitch::flat }, { { 43, 3, 0 }, 42, Pitch::flat }, { { 44, 2, 0 }, 42, Pitch::flat }, { { 45, 2, 0 }, 40, Pitch::flat }, { { 46, 1, 0 }, 40, Pitch::flat }, { { 47, 0, 0 }, 40, Pitch::flat }, { { 48, 0, 0 }, 40, Pitch::flat }, { { 49, -1, 0 }, 40, Pitch::flat }, { { 50, -2, 0 }, 40, Pitch::flat }, { { 51, -2, 0 }, 38, Pitch::flat }, { { 52, -3, 0 }, 38, Pitch::flat }, { { 53, -4, 0 }, 38, Pitch::flat }, { { 54, -4, 0 }, 38, Pitch::flat }, { { 55, -5, 0 }, 38, Pitch::flat }, { { 56, -6, 0 }, 38, Pitch::flat }, { { 57, -6, 0 }, 38, Pitch::flat }, { { 58, -7, 0 }, 38, Pitch::flat }, { { 59, -7, 0 }, 38, Pitch::flat }, { { 60, -8, 0 }, 36, Pitch::flat }, { { 61, -8, 0 }, 36, Pitch::flat }, { { 62, -9, 0 }, 36, Pitch::flat }, { { 63, -9, 0 }, 36, Pitch::flat }, { { 64, -10, 0 }, 36, Pitch::flat }, { { 65, -10, 0 }, 36, Pitch::flat }, { { 66, -11, 0 }, 36, Pitch::flat }, { { 67, -11, 0 }, 36, Pitch::flat }, { { 68, -11, 0 }, 36, Pitch::flat }, { { 69, -12, 0 }, 36, Pitch::flat }, { { 70, -12, 0 }, 36, Pitch::flat }, { { 71, -12, 0 }, 36, Pitch::flat }, { { 72, -13, 0 }, 34, Pitch::flat }, { { 73, -13, 0 }, 34, Pitch::flat }, { { 74, -13, 0 }, 34, Pitch::flat }, { { 75, -13, 0 }, 34, Pitch::flat }, { { 76, -14, 0 }, 34, Pitch::flat }, { { 77, -14, 0 }, 34, Pitch::flat }, { { 78, -14, 0 }, 34, Pitch::flat }, { { 79, -14, 0 }, 34, Pitch::flat }, { { 80, -14, 0 }, 34, Pitch::flat }, { { 81, -15, 0 }, 34, Pitch::flat }, { { 82, -15, 0 }, 34, Pitch::flat }, { { 83, -15, 0 }, 34, Pitch::flat }, { { 84, -15, 0 }, 34, Pitch::flat }, { { 85, -15, 0 }, 34, Pitch::flat }, { { 86, -15, 0 }, 34, Pitch::flat }, { { 87, -16, 0 }, 34, Pitch::flat }, { { 88, -16, 0 }, 32, Pitch::flat }, { { 89, -16, 0 }, 32, Pitch::flat }, { { 90, -16, 0 }, 32, Pitch::flat }, { { 91, -16, 0 }, 32, Pitch::flat }, { { 92, -16, 0 }, 32, Pitch::flat }, { { 93, -16, 0 }, 32, Pitch::flat }, { { 94, -16, 0 }, 32, Pitch::flat }, { { 95, -16, 0 }, 32, Pitch::flat }, }); // 0x4e63bc // Track 13. Reversed 0. Direction 3 static constexpr auto moveInfoT13R0D3 = std::to_array<MoveInfo>( { { { 16, 32, 0 }, 48, Pitch::flat }, { { 16, 31, 0 }, 48, Pitch::flat }, { { 16, 30, 0 }, 48, Pitch::flat }, { { 16, 29, 0 }, 48, Pitch::flat }, { { 16, 28, 0 }, 48, Pitch::flat }, { { 16, 27, 0 }, 48, Pitch::flat }, { { 16, 26, 0 }, 48, Pitch::flat }, { { 16, 25, 0 }, 48, Pitch::flat }, { { 16, 24, 0 }, 50, Pitch::flat }, { { 15, 23, 0 }, 50, Pitch::flat }, { { 15, 22, 0 }, 50, Pitch::flat }, { { 15, 21, 0 }, 50, Pitch::flat }, { { 15, 20, 0 }, 50, Pitch::flat }, { { 15, 19, 0 }, 50, Pitch::flat }, { { 15, 18, 0 }, 50, Pitch::flat }, { { 14, 17, 0 }, 50, Pitch::flat }, { { 14, 16, 0 }, 50, Pitch::flat }, { { 14, 15, 0 }, 50, Pitch::flat }, { { 14, 14, 0 }, 50, Pitch::flat }, { { 14, 13, 0 }, 50, Pitch::flat }, { { 13, 12, 0 }, 50, Pitch::flat }, { { 13, 11, 0 }, 50, Pitch::flat }, { { 13, 10, 0 }, 50, Pitch::flat }, { { 13, 9, 0 }, 50, Pitch::flat }, { { 12, 8, 0 }, 52, Pitch::flat }, { { 12, 7, 0 }, 52, Pitch::flat }, { { 12, 6, 0 }, 52, Pitch::flat }, { { 11, 5, 0 }, 52, Pitch::flat }, { { 11, 4, 0 }, 52, Pitch::flat }, { { 11, 3, 0 }, 52, Pitch::flat }, { { 10, 2, 0 }, 52, Pitch::flat }, { { 10, 1, 0 }, 52, Pitch::flat }, { { 9, 0, 0 }, 52, Pitch::flat }, { { 9, -1, 0 }, 52, Pitch::flat }, { { 8, -2, 0 }, 52, Pitch::flat }, { { 8, -3, 0 }, 52, Pitch::flat }, { { 7, -4, 0 }, 52, Pitch::flat }, { { 7, -5, 0 }, 58, Pitch::flat }, { { 6, -6, 0 }, 58, Pitch::flat }, { { 6, -7, 0 }, 58, Pitch::flat }, { { 5, -8, 0 }, 58, Pitch::flat }, { { 4, -9, 0 }, 58, Pitch::flat }, { { 4, -10, 0 }, 58, Pitch::flat }, { { 3, -11, 0 }, 58, Pitch::flat }, { { 2, -12, 0 }, 58, Pitch::flat }, { { 2, -13, 0 }, 56, Pitch::flat }, { { 1, -14, 0 }, 56, Pitch::flat }, { { 0, -15, 0 }, 56, Pitch::flat }, { { 0, -16, 0 }, 56, Pitch::flat }, { { -1, -17, 0 }, 56, Pitch::flat }, { { -2, -18, 0 }, 56, Pitch::flat }, { { -2, -19, 0 }, 54, Pitch::flat }, { { -3, -20, 0 }, 54, Pitch::flat }, { { -4, -21, 0 }, 54, Pitch::flat }, { { -4, -22, 0 }, 54, Pitch::flat }, { { -5, -23, 0 }, 54, Pitch::flat }, { { -6, -24, 0 }, 54, Pitch::flat }, { { -6, -25, 0 }, 54, Pitch::flat }, { { -7, -26, 0 }, 54, Pitch::flat }, { { -7, -27, 0 }, 54, Pitch::flat }, { { -8, -28, 0 }, 52, Pitch::flat }, { { -8, -29, 0 }, 52, Pitch::flat }, { { -9, -30, 0 }, 52, Pitch::flat }, { { -9, -31, 0 }, 52, Pitch::flat }, { { -10, -32, 0 }, 52, Pitch::flat }, { { -10, -33, 0 }, 52, Pitch::flat }, { { -11, -34, 0 }, 52, Pitch::flat }, { { -11, -35, 0 }, 52, Pitch::flat }, { { -11, -36, 0 }, 52, Pitch::flat }, { { -12, -37, 0 }, 52, Pitch::flat }, { { -12, -38, 0 }, 52, Pitch::flat }, { { -12, -39, 0 }, 52, Pitch::flat }, { { -13, -40, 0 }, 50, Pitch::flat }, { { -13, -41, 0 }, 50, Pitch::flat }, { { -13, -42, 0 }, 50, Pitch::flat }, { { -13, -43, 0 }, 50, Pitch::flat }, { { -14, -44, 0 }, 50, Pitch::flat }, { { -14, -45, 0 }, 50, Pitch::flat }, { { -14, -46, 0 }, 50, Pitch::flat }, { { -14, -47, 0 }, 50, Pitch::flat }, { { -14, -48, 0 }, 50, Pitch::flat }, { { -15, -49, 0 }, 50, Pitch::flat }, { { -15, -50, 0 }, 50, Pitch::flat }, { { -15, -51, 0 }, 50, Pitch::flat }, { { -15, -52, 0 }, 50, Pitch::flat }, { { -15, -53, 0 }, 50, Pitch::flat }, { { -15, -54, 0 }, 50, Pitch::flat }, { { -16, -55, 0 }, 50, Pitch::flat }, { { -16, -56, 0 }, 48, Pitch::flat }, { { -16, -57, 0 }, 48, Pitch::flat }, { { -16, -58, 0 }, 48, Pitch::flat }, { { -16, -59, 0 }, 48, Pitch::flat }, { { -16, -60, 0 }, 48, Pitch::flat }, { { -16, -61, 0 }, 48, Pitch::flat }, { { -16, -62, 0 }, 48, Pitch::flat }, { { -16, -63, 0 }, 48, Pitch::flat }, }); // 0x4da92e // Track 14. Reversed 0. Direction 0 static constexpr auto moveInfoT14R0D0 = std::to_array<MoveInfo>( { { { 31, 16, 0 }, 0, Pitch::up12deg }, { { 30, 16, 0 }, 0, Pitch::up12deg }, { { 29, 16, 0 }, 0, Pitch::up12deg }, { { 28, 16, 0 }, 0, Pitch::up12deg }, { { 27, 16, 1 }, 0, Pitch::up12deg }, { { 26, 16, 1 }, 0, Pitch::up12deg }, { { 25, 16, 1 }, 0, Pitch::up12deg }, { { 24, 16, 1 }, 0, Pitch::up12deg }, { { 23, 16, 2 }, 0, Pitch::up12deg }, { { 22, 16, 2 }, 0, Pitch::up12deg }, { { 21, 16, 2 }, 0, Pitch::up12deg }, { { 20, 16, 2 }, 0, Pitch::up12deg }, { { 19, 16, 3 }, 0, Pitch::up12deg }, { { 18, 16, 3 }, 0, Pitch::up12deg }, { { 17, 16, 3 }, 0, Pitch::up12deg }, { { 16, 16, 3 }, 0, Pitch::up12deg }, { { 15, 16, 4 }, 0, Pitch::up12deg }, { { 14, 16, 4 }, 0, Pitch::up12deg }, { { 13, 16, 4 }, 0, Pitch::up12deg }, { { 12, 16, 4 }, 0, Pitch::up12deg }, { { 11, 16, 5 }, 0, Pitch::up12deg }, { { 10, 16, 5 }, 0, Pitch::up12deg }, { { 9, 16, 5 }, 0, Pitch::up12deg }, { { 8, 16, 5 }, 0, Pitch::up12deg }, { { 7, 16, 6 }, 0, Pitch::up12deg }, { { 6, 16, 6 }, 0, Pitch::up12deg }, { { 5, 16, 6 }, 0, Pitch::up12deg }, { { 4, 16, 6 }, 0, Pitch::up12deg }, { { 3, 16, 7 }, 0, Pitch::up12deg }, { { 2, 16, 7 }, 0, Pitch::up12deg }, { { 1, 16, 7 }, 0, Pitch::up12deg }, { { 0, 16, 7 }, 0, Pitch::up12deg }, { { -1, 16, 8 }, 0, Pitch::up12deg }, { { -2, 16, 8 }, 0, Pitch::up12deg }, { { -3, 16, 8 }, 0, Pitch::up12deg }, { { -4, 16, 8 }, 0, Pitch::up12deg }, { { -5, 16, 9 }, 0, Pitch::up12deg }, { { -6, 16, 9 }, 0, Pitch::up12deg }, { { -7, 16, 9 }, 0, Pitch::up12deg }, { { -8, 16, 9 }, 0, Pitch::up12deg }, { { -9, 16, 10 }, 0, Pitch::up12deg }, { { -10, 16, 10 }, 0, Pitch::up12deg }, { { -11, 16, 10 }, 0, Pitch::up12deg }, { { -12, 16, 10 }, 0, Pitch::up12deg }, { { -13, 16, 11 }, 0, Pitch::up12deg }, { { -14, 16, 11 }, 0, Pitch::up12deg }, { { -15, 16, 11 }, 0, Pitch::up12deg }, { { -16, 16, 11 }, 0, Pitch::up12deg }, ``` > [truncated] --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/SubpositionData.h ```h #pragma once #include "Types.hpp" #include <OpenLoco/Engine/World.hpp> #include <span> namespace OpenLoco { enum class Pitch : uint8_t; } namespace OpenLoco::World::TrackData { #pragma pack(push, 1) struct MoveInfo { World::Pos3 loc; // 0x00 uint8_t yaw; // 0x06 Pitch pitch; // 0x07 }; #pragma pack(pop) static_assert(sizeof(MoveInfo) == 0x8); std::span<const MoveInfo> getTrackSubPositon(const uint16_t trackAndDirection); std::span<const MoveInfo> getRoadSubPositon(const uint16_t trackAndDirection); std::span<const MoveInfo> getRoadPlacementSubPositon(const uint16_t trackAndDirection); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/Track.cpp ```cpp #include "Track.h" #include "GameState.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "TrackData.h" namespace OpenLoco::World::Track { // Part of 0x00478895 // For 0x00478895 call this followed by getRoadConnections ConnectionEnd getRoadConnectionEnd(const World::Pos3& pos, const uint16_t trackAndDirection) { const auto& roadData = TrackData::getUnkRoad(trackAndDirection); return ConnectionEnd{ pos + roadData.pos, roadData.rotationEnd }; } // 0x004788C8 template<bool checkOneWay, bool aiAllocated> static RoadConnections getRoadConnectionsImpl(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods) { RoadConnections result{}; uint8_t baseZ = nextTrackPos.z / 4; const auto tile = World::TileManager::get(nextTrackPos); for (const auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (!(getGameState().roadObjectIdIsFlag7 & (1 << elRoad->roadObjectId()))) { if (elRoad->owner() != company) { continue; } } if (elRoad->roadObjectId() != roadObjectId) { if (roadObjectId != 0xFF) { continue; } if (!(getGameState().roadObjectIdIsNotTram & (1 << elRoad->roadObjectId()))) { continue; } } if ((elRoad->mods() & requiredMods) != requiredMods) { continue; } if constexpr (aiAllocated) { if (!elRoad->isAiAllocated()) { continue; } } else { if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } } if (elRoad->sequenceIndex() == 0) { auto trackAndDirection2 = (elRoad->roadId() << 3) | elRoad->rotation(); if (nextRotation == TrackData::getUnkRoad(trackAndDirection2).rotationBegin) { const auto& roadPiece = TrackData::getRoadPiece(elRoad->roadId()); if (baseZ == (elRoad->baseZ() - roadPiece[0].z / 4)) { if (elRoad->hasBridge()) { trackAndDirection2 |= elRoad->bridge() << 9; trackAndDirection2 |= AdditionalTaDFlags::hasBridge; } if ((queryMods & elRoad->mods()) != 0) { trackAndDirection2 |= AdditionalTaDFlags::hasMods; } if (elRoad->hasStationElement()) { auto* elStation = tile.roadStation(elRoad->roadId(), elRoad->rotation(), elRoad->baseZ()); if (elStation == nullptr) { continue; } if (!elStation->isAiAllocated() && !elStation->isGhost()) { result.stationId = elStation->stationId(); result.stationObjectId = elStation->objectId(); } } result.roadObjectId = elRoad->roadObjectId(); result.connections.push_back(trackAndDirection2); } } } if (!elRoad->isFlag6()) { continue; } auto trackAndDirection2 = (elRoad->roadId() << 3) | (1 << 2) | elRoad->rotation(); if (nextRotation != TrackData::getUnkRoad(trackAndDirection2).rotationBegin) { continue; } const auto& roadPiece = TrackData::getRoadPiece(elRoad->roadId()); if (baseZ != (elRoad->baseZ() - (TrackData::getUnkRoad(trackAndDirection2).pos.z + roadPiece[elRoad->sequenceIndex()].z) / 4)) { continue; } if constexpr (checkOneWay) { auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (roadObj->hasFlags(RoadObjectFlags::isOneWay)) { continue; } } if (elRoad->hasBridge()) { trackAndDirection2 |= elRoad->bridge() << 9; trackAndDirection2 |= AdditionalTaDFlags::hasBridge; } if ((queryMods & elRoad->mods()) != 0) { trackAndDirection2 |= AdditionalTaDFlags::hasMods; } if (elRoad->hasStationElement()) { auto* elStation = tile.roadStation(elRoad->roadId(), elRoad->rotation(), elRoad->baseZ()); if (elStation == nullptr) { continue; } if (!elStation->isAiAllocated() && !elStation->isGhost()) { result.stationId = elStation->stationId(); result.stationObjectId = elStation->objectId(); } } result.roadObjectId = elRoad->roadObjectId(); result.connections.push_back(trackAndDirection2); } return result; } // 0x004788C8 RoadConnections getRoadConnections(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods) { return getRoadConnectionsImpl<false, false>(nextTrackPos, nextRotation, company, roadObjectId, requiredMods, queryMods); } // 0x00478D16 // For 0x00478CE9 call getRoadConnectionEnd followed by this RoadConnections getRoadConnectionsOneWay(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods) { return getRoadConnectionsImpl<true, false>(nextTrackPos, nextRotation, company, roadObjectId, requiredMods, queryMods); } // 0x00478AF6 // For 0x00478AC9 call getRoadConnectionEnd followed by this RoadConnections getRoadConnectionsAiAllocated(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods) { return getRoadConnectionsImpl<false, true>(nextTrackPos, nextRotation, company, roadObjectId, requiredMods, queryMods); } // Part of 0x004A2604 // For 0x004A2604 call this followed by getTrackConnections ConnectionEnd getTrackConnectionEnd(const World::Pos3& pos, const uint16_t trackAndDirection) { const auto& trackData = TrackData::getUnkTrack(trackAndDirection); return ConnectionEnd{ pos + trackData.pos, trackData.rotationEnd }; } constexpr uint16_t kNullTad = 0xFFFFU; static uint16_t getElTrackConnection(const World::TrackElement& elTrack, uint8_t nextRotation, uint8_t baseZ, uint8_t queryMods) { if (elTrack.sequenceIndex() == 0) { auto trackAndDirection2 = (elTrack.trackId() << 3) | elTrack.rotation(); if (nextRotation == TrackData::getUnkTrack(trackAndDirection2).rotationBegin) { const auto& trackPiece = TrackData::getTrackPiece(elTrack.trackId()); if (baseZ == (elTrack.baseZ() - trackPiece[0].z / 4)) { if (elTrack.hasBridge()) { trackAndDirection2 |= elTrack.bridge() << 9; trackAndDirection2 |= AdditionalTaDFlags::hasBridge; } if ((queryMods & elTrack.mods()) != 0) { trackAndDirection2 |= AdditionalTaDFlags::hasMods; } if (elTrack.hasSignal()) { auto* elSignal = elTrack.next()->as<SignalElement>(); if (elSignal != nullptr) { if (!elSignal->isAiAllocated() && !elSignal->isGhost()) { trackAndDirection2 |= (1 << 15); } } } return trackAndDirection2; } } } if (!elTrack.isFlag6()) { return kNullTad; } auto trackAndDirection2 = (elTrack.trackId() << 3) | (1 << 2) | elTrack.rotation(); if (nextRotation != TrackData::getUnkTrack(trackAndDirection2).rotationBegin) { return kNullTad; } const auto previousBaseZ = elTrack.baseZ() - (TrackData::getTrackPiece(elTrack.trackId())[elTrack.sequenceIndex()].z + TrackData::getUnkTrack(trackAndDirection2).pos.z) / 4; if (previousBaseZ != baseZ) { return kNullTad; } if (elTrack.hasBridge()) { trackAndDirection2 |= elTrack.bridge() << 9; trackAndDirection2 |= AdditionalTaDFlags::hasBridge; } if ((queryMods & elTrack.mods()) != 0) { trackAndDirection2 |= AdditionalTaDFlags::hasMods; } if (elTrack.hasSignal()) { auto* elSignal = elTrack.next()->as<SignalElement>(); if (elSignal != nullptr) { if (!elSignal->isAiAllocated() && !elSignal->isGhost()) { trackAndDirection2 |= AdditionalTaDFlags::hasSignal; } } } return trackAndDirection2; } // 0x004A2638, 0x004A2601 TrackConnections getTrackConnections(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t trackObjectId, const uint8_t requiredMods, const uint8_t queryMods) { TrackConnections result{}; uint8_t baseZ = nextTrackPos.z / 4; const auto tile = World::TileManager::get(nextTrackPos); for (const auto& el : tile) { auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->owner() != company) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if ((elTrack->mods() & requiredMods) != requiredMods) { continue; } if (elTrack->isGhost() || elTrack->isAiAllocated()) { continue; } const auto connection = getElTrackConnection(*elTrack, nextRotation, baseZ, queryMods); if (connection == kNullTad) { continue; } result.connections.push_back(connection); if (elTrack->hasStationElement()) { auto* elStation = elTrack->next()->as<StationElement>(); if (elStation != nullptr) { if (!elStation->isAiAllocated() && !elStation->isGhost()) { result.stationId = elStation->stationId(); } } } if (elTrack->hasLevelCrossing()) { result.hasLevelCrossing = 1; } } return result; } // 0x004A2820, 0x004A2854 // For 0x004A2820 call getTrackConnectionEnd first then this TrackConnections getTrackConnectionsAi(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t trackObjectId, const uint8_t requiredMods, const uint8_t queryMods) { // Same as getTrackConnections but for aiAllocated preview track // i.e. can find connections on track that isn't visible yet. TrackConnections result{}; uint8_t baseZ = nextTrackPos.z / 4; const auto tile = World::TileManager::get(nextTrackPos); for (const auto& el : tile) { auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->owner() != company) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if ((elTrack->mods() & requiredMods) != requiredMods) { continue; } if (!elTrack->isAiAllocated()) { continue; } const auto connection = getElTrackConnection(*elTrack, nextRotation, baseZ, queryMods); if (connection == kNullTad) { continue; } result.connections.push_back(connection); if (elTrack->hasStationElement()) { auto* elStation = elTrack->next()->as<StationElement>(); if (elStation != nullptr) { // No need to consider aiAllocated or ghost flags result.stationId = elStation->stationId(); } } if (elTrack->hasLevelCrossing()) { result.hasLevelCrossing = 1; } } return result; } } namespace OpenLoco::World { TrackElement::TrackElement(World::SmallZ baseZ, World::SmallZ clearZ, uint8_t direction, uint8_t quarterTile, uint8_t sequenceIndex, uint8_t trackObjId, uint8_t trackId, std::optional<uint8_t> bridge, CompanyId owner, uint8_t mods) { setType(World::ElementType::track); setBaseZ(baseZ); setClearZ(clearZ); _type |= direction & 0x3; _flags = quarterTile & 0xF; _4 = (trackId & 0x3F) | (bridge ? 0x80 : 0); _5 = (sequenceIndex & 0xF) | ((trackObjId & 0xF) << 4); _6 = bridge ? (*bridge << 5) : 0; _7 = enumValue(owner) | (mods << 4); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/Track.h ```h #pragma once #include "Types.hpp" #include <OpenLoco/Engine/World.hpp> #include <sfl/static_vector.hpp> #include <utility> namespace OpenLoco::World::Track { namespace AdditionalTaDFlags { constexpr uint16_t basicTaDMask = 0b0000'0001'1111'1111; constexpr uint16_t basicRaDMask = 0b0000'0000'0111'1111; constexpr uint16_t bridgeMask = 0b0000'1110'0000'0000; constexpr uint16_t isOvertaking = (1U << 7); // road only constexpr uint16_t isChangingLane = (1U << 8); // road only constexpr uint16_t hasBridge = (1U << 12); constexpr uint16_t hasMods = (1U << 13); constexpr uint16_t hasSignal = (1U << 15); // Track only (not roads) constexpr uint16_t basicTaDWithSignalMask = basicTaDMask | hasSignal; constexpr uint16_t basicRaDWithSignalMask = basicRaDMask | hasSignal; // Roads don't have signals so this seems a bit pointless } struct RoadConnections { sfl::static_vector<uint16_t, 16> connections; StationId stationId = StationId::null; // 0x01135FAE uint8_t stationObjectId = 0U; // 0x01136087 uint8_t roadObjectId = 0xFFU; // 0x0112C2ED (I wouldn't trust this to be correct which connection!) }; // requiredMods : 0x0113601A // queryMods : 0x0113601B // // if set requiredMods must exist on connections to be added to connection list // e.g. if required mods is `0b10` then tracks with mods `0b10` and `0b11` can connect // but `0b00` and `0b01` cannot // if requiredMods == 0 then mods ignored // // queryMods sets AdditionalTaDFlags::hasMods of connection if connection has the queryMods RoadConnections getRoadConnections(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods); RoadConnections getRoadConnectionsOneWay(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods); RoadConnections getRoadConnectionsAiAllocated(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t roadObjectId, const uint8_t requiredMods, const uint8_t queryMods); struct ConnectionEnd { World::Pos3 nextPos; uint8_t nextRotation; }; ConnectionEnd getRoadConnectionEnd(const World::Pos3& pos, const uint16_t trackAndDirection); struct TrackConnections { sfl::static_vector<uint16_t, 16> connections; bool hasLevelCrossing = false; // 0x0113607D StationId stationId = StationId::null; // 0x01135FAE }; // requiredMods : 0x0113601A // queryMods : 0x0113601B // // if set requiredMods must exist on connections to be added to connection list // e.g. if required mods is `0b10` then tracks with mods `0b10` and `0b11` can connect // but `0b00` and `0b01` cannot // if requiredMods == 0 then mods ignored // // queryMods sets AdditionalTaDFlags::hasMods of connection if connection has the queryMods TrackConnections getTrackConnections(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t trackObjectId, const uint8_t requiredMods, const uint8_t queryMods); TrackConnections getTrackConnectionsAi(const World::Pos3& nextTrackPos, const uint8_t nextRotation, const CompanyId company, const uint8_t trackObjectId, const uint8_t requiredMods, const uint8_t queryMods); ConnectionEnd getTrackConnectionEnd(const World::Pos3& pos, const uint16_t trackAndDirection); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/TrackData.cpp ```cpp #include "TrackData.h" #include "TrackEnum.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <array> #include <bit> #include <cassert> using namespace OpenLoco::World::Track; namespace OpenLoco::World::TrackData { constexpr ConnectionsByRotation generateConnections(uint8_t connection) { return { connection, std::rotl(connection, 2), std::rotl(connection, 4), std::rotl(connection, 6), }; } const std::array<PreviewTrack, 1> trackPiece0 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 4> trackPiece1 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x07) }, PreviewTrack{ 1, 0, 32, 0, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x08) }, PreviewTrack{ 3, -32, 32, 0, 0, QuarterTile{ 0b0110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x70) }, }; const std::array<PreviewTrack, 1> trackPiece2 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 1> trackPiece3 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 4> trackPiece4 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, PreviewTrack{ 1, 0, -32, 0, 0, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x02) }, PreviewTrack{ 2, -32, 0, 0, 0, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x70) }, PreviewTrack{ 3, -32, -32, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 4> trackPiece5 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, PreviewTrack{ 1, 0, 32, 0, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x1C) }, PreviewTrack{ 3, -32, 32, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 5> trackPiece6 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, PreviewTrack{ 2, -32, -32, 0, 0, QuarterTile{ 0b1101, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x8F) }, PreviewTrack{ 3, -64, -32, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, PreviewTrack{ 4, -64, -64, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 5> trackPiece7 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, PreviewTrack{ 2, -32, 32, 0, 0, QuarterTile{ 0b1110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xE3) }, PreviewTrack{ 3, -64, 32, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, PreviewTrack{ 4, -64, 64, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 5> trackPiece8 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, PreviewTrack{ 2, -32, -32, 0, 0, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x02) }, PreviewTrack{ 3, -64, 0, 0, 0, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x20) }, PreviewTrack{ 4, -64, -32, 0, 0, QuarterTile{ 0b0011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x1C) }, }; const std::array<PreviewTrack, 5> trackPiece9 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, PreviewTrack{ 2, -32, 32, 0, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x80) }, PreviewTrack{ 3, -64, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x08) }, PreviewTrack{ 4, -64, 32, 0, 0, QuarterTile{ 0b0110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x70) }, }; const std::array<PreviewTrack, 5> trackPiece10 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x07) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x08) }, PreviewTrack{ 2, 0, 32, 0, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x80) }, PreviewTrack{ 3, -32, 32, 0, 0, QuarterTile{ 0b1110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xE3) }, PreviewTrack{ 4, -64, 32, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 5> trackPiece11 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x07) }, PreviewTrack{ 1, 0, 32, 0, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x08) }, PreviewTrack{ 3, -32, 32, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, PreviewTrack{ 4, -32, 64, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 4> trackPiece12 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF9) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b0110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x60) }, PreviewTrack{ 2, -32, -32, 0, 0, QuarterTile{ 0b1001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x06) }, PreviewTrack{ 3, -64, -32, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x9F) }, }; const std::array<PreviewTrack, 4> trackPiece13 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3F) }, PreviewTrack{ 1, -32, 0, 0, 0, QuarterTile{ 0b1001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x0C) }, PreviewTrack{ 2, -32, 32, 0, 0, QuarterTile{ 0b0110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xC0) }, PreviewTrack{ 3, -64, 32, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF3) }, }; const std::array<PreviewTrack, 2> trackPiece14 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, 0, 16, QuarterTile{ 0b1111, 0b1100 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 2> trackPiece15 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1111, 0b0011 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, -16, 16, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 1> trackPiece16 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1111, 0b1100 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk2, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 1> trackPiece17 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1111, 0b0011 }, PreviewTrackFlags::unk1 | PreviewTrackFlags::unk0, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 4> trackPiece18 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0xF8) }, PreviewTrack{ 1, 0, -32, 0, 16, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x02) }, PreviewTrack{ 2, -32, 0, 0, 16, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x70) }, PreviewTrack{ 3, -32, -32, 0, 16, QuarterTile{ 0b0111, 0b0110 }, PreviewTrackFlags::unk4, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 4> trackPiece19 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x3E) }, PreviewTrack{ 1, 0, 32, 0, 16, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, 0, 16, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x1C) }, PreviewTrack{ 3, -32, 32, 0, 16, QuarterTile{ 0b1011, 0b1001 }, PreviewTrackFlags::unk4, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 4> trackPiece20 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b0111, 0b0011 }, PreviewTrackFlags::unk4, generateConnections(0xF8) }, PreviewTrack{ 1, 0, -32, -16, 16, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x02) }, PreviewTrack{ 2, -32, 0, -16, 16, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x70) }, PreviewTrack{ 3, -32, -32, -16, 16, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 4> trackPiece21 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1011, 0b0011 }, PreviewTrackFlags::unk4, generateConnections(0x3E) }, PreviewTrack{ 1, 0, 32, -16, 16, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, -16, 16, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x1C) }, PreviewTrack{ 3, -32, 32, -16, 16, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 4> trackPiece22 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b0111, 0b0100 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk2, generateConnections(0xF8) }, PreviewTrack{ 1, 0, -32, 16, 0, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x02) }, PreviewTrack{ 2, -32, 0, 16, 0, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x70) }, PreviewTrack{ 3, -32, -32, 16, 16, QuarterTile{ 0b0111, 0b0110 }, PreviewTrackFlags::unk2 | PreviewTrackFlags::unk1, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 4> trackPiece23 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1011, 0b1000 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk2, generateConnections(0x3E) }, PreviewTrack{ 1, 0, 32, 16, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, 16, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x1C) }, PreviewTrack{ 3, -32, 32, 16, 16, QuarterTile{ 0b1011, 0b1001 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk0, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 4> trackPiece24 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b0111, 0b0011 }, PreviewTrackFlags::unk1 | PreviewTrackFlags::unk0, generateConnections(0xF8) }, PreviewTrack{ 1, 0, -32, -16, 0, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x02) }, PreviewTrack{ 2, -32, 0, -16, 0, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x70) }, PreviewTrack{ 3, -32, -32, -32, 16, QuarterTile{ 0b0111, 0b0001 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk0, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 4> trackPiece25 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1011, 0b0011 }, PreviewTrackFlags::unk1 | PreviewTrackFlags::unk0, generateConnections(0x3E) }, PreviewTrack{ 1, 0, 32, -16, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal | PreviewTrackFlags::unk4, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, -16, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0x1C) }, PreviewTrack{ 3, -32, 32, -32, 16, QuarterTile{ 0b1011, 0b0010 }, PreviewTrackFlags::unk2 | PreviewTrackFlags::unk1, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 1> trackPiece26 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0110, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xE0) }, }; const std::array<PreviewTrack, 1> trackPiece27 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x0E) }, }; const std::array<PreviewTrack, 1> trackPiece28 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x20) }, }; const std::array<PreviewTrack, 1> trackPiece29 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x8D) }, }; const std::array<PreviewTrack, 1> trackPiece30 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x63) }, }; const std::array<PreviewTrack, 1> trackPiece31 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x08) }, }; const std::array<PreviewTrack, 1> trackPiece32 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x77) }, }; const std::array<PreviewTrack, 1> trackPiece33 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xDD) }, }; const std::array<PreviewTrack, 1> trackPiece34 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b0110, 0b1100 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk2, generateConnections(0xE0) }, }; const std::array<PreviewTrack, 1> trackPiece35 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1001, 0b1100 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk2, generateConnections(0x0E) }, }; const std::array<PreviewTrack, 1> trackPiece36 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b0110, 0b0011 }, PreviewTrackFlags::unk1 | PreviewTrackFlags::unk0, generateConnections(0xE0) }, }; const std::array<PreviewTrack, 1> trackPiece37 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1001, 0b0011 }, PreviewTrackFlags::unk1 | PreviewTrackFlags::unk0, generateConnections(0x0E) }, }; const std::array<PreviewTrack, 1> trackPiece38 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFD) }, }; const std::array<PreviewTrack, 1> trackPiece39 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x7F) }, }; const std::array<PreviewTrack, 1> trackPiece40 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF7) }, }; const std::array<PreviewTrack, 1> trackPiece41 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xDF) }, }; const std::array<PreviewTrack, 1> trackPiece42 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x38) }, }; const std::array<PreviewTrack, 1> trackPiece43 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x38) }, }; // 0x004F73D8, 0x004F78F8 const std::array<std::span<const PreviewTrack>, 44> trackPieces = { { trackPiece0, trackPiece1, trackPiece2, trackPiece3, trackPiece4, trackPiece5, trackPiece6, trackPiece7, trackPiece8, trackPiece9, trackPiece10, trackPiece11, trackPiece12, trackPiece13, trackPiece14, trackPiece15, trackPiece16, trackPiece17, trackPiece18, trackPiece19, trackPiece20, trackPiece21, trackPiece22, trackPiece23, trackPiece24, trackPiece25, trackPiece26, trackPiece27, trackPiece28, trackPiece29, trackPiece30, trackPiece31, trackPiece32, trackPiece33, trackPiece34, trackPiece35, trackPiece36, trackPiece37, trackPiece38, trackPiece39, trackPiece40, trackPiece41, trackPiece42, trackPiece43, } }; const std::array<PreviewTrack, 1> roadPiece0 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 1> roadPiece1 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 1> roadPiece2 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 4> roadPiece3 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, PreviewTrack{ 1, 0, -32, 0, 0, QuarterTile{ 0b1000, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x02) }, PreviewTrack{ 2, -32, 0, 0, 0, QuarterTile{ 0b0010, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x70) }, PreviewTrack{ 3, -32, -32, 0, 0, QuarterTile{ 0b0111, 0b0000 }, PreviewTrackFlags::none, generateConnections(0xF8) }, }; const std::array<PreviewTrack, 4> roadPiece4 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, PreviewTrack{ 1, 0, 32, 0, 0, QuarterTile{ 0b0100, 0b0000 }, PreviewTrackFlags::diagonal, generateConnections(0x80) }, PreviewTrack{ 2, -32, 0, 0, 0, QuarterTile{ 0b0001, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x1C) }, PreviewTrack{ 3, -32, 32, 0, 0, QuarterTile{ 0b1011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x3E) }, }; const std::array<PreviewTrack, 2> roadPiece5 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, 0, 16, QuarterTile{ 0b1111, 0b1100 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 2> roadPiece6 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1111, 0b0011 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, PreviewTrack{ 1, -32, 0, -16, 16, QuarterTile{ 0b1111, 0b0000 }, PreviewTrackFlags::unk4, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 1> roadPiece7 = { PreviewTrack{ 0, 0, 0, 0, 16, QuarterTile{ 0b1111, 0b1100 }, PreviewTrackFlags::unk3 | PreviewTrackFlags::unk2, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 1> roadPiece8 = { PreviewTrack{ 0, 0, 0, -16, 16, QuarterTile{ 0b1111, 0b0011 }, PreviewTrackFlags::unk1 | PreviewTrackFlags::unk0, generateConnections(0xFF) }, }; const std::array<PreviewTrack, 1> roadPiece9 = { PreviewTrack{ 0, 0, 0, 0, 0, QuarterTile{ 0b0011, 0b0000 }, PreviewTrackFlags::none, generateConnections(0x38) }, }; // 0x004F6D1C, 0x004F6F1C const std::array<std::span<const PreviewTrack>, 10> roadPieces = { { roadPiece0, roadPiece1, roadPiece2, roadPiece3, roadPiece4, roadPiece5, roadPiece6, roadPiece7, roadPiece8, roadPiece9, } }; const std::span<const PreviewTrack> getTrackPiece(size_t trackId) { assert(trackId < trackPieces.size()); return trackPieces[trackId]; } const std::span<const PreviewTrack> getRoadPiece(size_t trackId) { assert(trackId < roadPieces.size()); return roadPieces[trackId]; } static Interop::loco_global<TrackCoordinates[80], 0x004F6F8C> _4F6F8C; static Interop::loco_global<TrackCoordinates[352], 0x004F7B5C> _4F7B5C; const TrackCoordinates& getUnkTrack(uint16_t trackAndDirection) { return _4F7B5C[trackAndDirection]; } const TrackCoordinates& getUnkRoad(uint16_t trackAndDirection) { return _4F6F8C[trackAndDirection]; } constexpr std::array<TrackMiscData, 44> _miscData = { // straight TrackMiscData{ .costFactor = 0x100, .flags = CommonTraitFlags::none, .reverseTrackId = 0, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::none, .curveSpeedFraction = 0xFFFF, .unkWeighting = 32, .sparkDirection = true }, // diagonal TrackMiscData{ .costFactor = 0x16A, .flags = CommonTraitFlags::diagonal, .reverseTrackId = 1, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::diagonal, .curveSpeedFraction = 0xFFFF, .unkWeighting = 45, .sparkDirection = false }, // leftCurveVerySmall TrackMiscData{ .costFactor = 0x0C9, .flags = CommonTraitFlags::verySmallCurve, .reverseTrackId = 3, .reverseRotation = 1, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::verySmallCurve, .curveSpeedFraction = 0x0CCD, .unkWeighting = 25, .sparkDirection = true }, // rightCurveVerySmall TrackMiscData{ .costFactor = 0x0C9, .flags = CommonTraitFlags::verySmallCurve, .reverseTrackId = 2, .reverseRotation = 3, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::verySmallCurve, .curveSpeedFraction = 0x0CCD, .unkWeighting = 25, .sparkDirection = false }, // leftCurveSmall TrackMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::smallCurve, .reverseTrackId = 5, .reverseRotation = 1, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::smallCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 75, .sparkDirection = true }, // rightCurveSmall TrackMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::smallCurve, .reverseTrackId = 4, .reverseRotation = 3, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::smallCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 75, .sparkDirection = false }, // leftCurve TrackMiscData{ .costFactor = 0x3ED, .flags = CommonTraitFlags::curve, .reverseTrackId = 7, .reverseRotation = 1, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::normalCurve, .curveSpeedFraction = 0x2666, .unkWeighting = 126, .sparkDirection = true }, // rightCurve TrackMiscData{ .costFactor = 0x3ED, .flags = CommonTraitFlags::curve, .reverseTrackId = 6, .reverseRotation = 3, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::normalCurve, .curveSpeedFraction = 0x2666, .unkWeighting = 126, .sparkDirection = false }, // leftCurveLarge TrackMiscData{ .costFactor = 0x2BF, .flags = CommonTraitFlags::largeCurve, .reverseTrackId = 11, .reverseRotation = 1, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::largeCurve, .curveSpeedFraction = 0x4000, .unkWeighting = 88, .sparkDirection = true }, // rightCurveLarge TrackMiscData{ .costFactor = 0x2BF, .flags = CommonTraitFlags::largeCurve, .reverseTrackId = 10, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::largeCurve, .curveSpeedFraction = 0x4000, .unkWeighting = 88, .sparkDirection = false }, // diagonalLeftCurveLarge TrackMiscData{ .costFactor = 0x2BF, .flags = CommonTraitFlags::largeCurve, .reverseTrackId = 9, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::largeCurve, .curveSpeedFraction = 0x4000, .unkWeighting = 88, .sparkDirection = true }, // diagonalRightCurveLarge TrackMiscData{ .costFactor = 0x2BF, .flags = CommonTraitFlags::largeCurve, .reverseTrackId = 8, .reverseRotation = 3, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::largeCurve, .curveSpeedFraction = 0x4000, .unkWeighting = 88, .sparkDirection = false }, // sBendLeft TrackMiscData{ .costFactor = 0x380, .flags = CommonTraitFlags::sBendCurve, .reverseTrackId = 12, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::sBend, .curveSpeedFraction = 0x2666, .unkWeighting = 106, .sparkDirection = false }, // sBendRight TrackMiscData{ .costFactor = 0x380, .flags = CommonTraitFlags::sBendCurve, .reverseTrackId = 13, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::sBend, .curveSpeedFraction = 0x2666, .unkWeighting = 106, .sparkDirection = false }, // straightSlopeUp TrackMiscData{ .costFactor = 0x220, .flags = CommonTraitFlags::slope, .reverseTrackId = 15, .reverseRotation = 2, .signalHeightOffsetLeft = 1, .signalHeightOffsetRight = 15, .compatibleFlags = TrackTraitFlags::slope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 66, .sparkDirection = false }, // straightSlopeDown TrackMiscData{ .costFactor = 0x220, .flags = CommonTraitFlags::slope, .reverseTrackId = 14, .reverseRotation = 2, .signalHeightOffsetLeft = 15, .signalHeightOffsetRight = 1, .compatibleFlags = TrackTraitFlags::slope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 66, .sparkDirection = true }, // straightSteepSlopeUp TrackMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope, .reverseTrackId = 17, .reverseRotation = 2, .signalHeightOffsetLeft = 2, .signalHeightOffsetRight = 14, .compatibleFlags = TrackTraitFlags::steepSlope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, .sparkDirection = false }, // straightSteepSlopeDown TrackMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope, .reverseTrackId = 16, .reverseRotation = 2, .signalHeightOffsetLeft = 14, .signalHeightOffsetRight = 2, .compatibleFlags = TrackTraitFlags::steepSlope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, .sparkDirection = true }, // leftCurveSmallSlopeUp TrackMiscData{ .costFactor = 0x350, .flags = CommonTraitFlags::slope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 21, .reverseRotation = 1, .signalHeightOffsetLeft = 1, .signalHeightOffsetRight = 15, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::slope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 77, .sparkDirection = true }, // rightCurveSmallSlopeUp TrackMiscData{ .costFactor = 0x350, .flags = CommonTraitFlags::slope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 20, .reverseRotation = 3, .signalHeightOffsetLeft = 1, .signalHeightOffsetRight = 15, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::slope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 77, .sparkDirection = false }, // leftCurveSmallSlopeDown TrackMiscData{ .costFactor = 0x350, .flags = CommonTraitFlags::slope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 19, .reverseRotation = 1, .signalHeightOffsetLeft = 15, .signalHeightOffsetRight = 1, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::slope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 77, .sparkDirection = true }, // rightCurveSmallSlopeDown TrackMiscData{ .costFactor = 0x350, .flags = CommonTraitFlags::slope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 18, .reverseRotation = 3, .signalHeightOffsetLeft = 15, .signalHeightOffsetRight = 1, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::slope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 77, .sparkDirection = false }, // leftCurveSmallSteepSlopeUp TrackMiscData{ .costFactor = 0x41F, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 25, .reverseRotation = 1, .signalHeightOffsetLeft = 2, .signalHeightOffsetRight = 14, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::steepSlope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 82, .sparkDirection = true }, // rightCurveSmallSteepSlopeUp TrackMiscData{ .costFactor = 0x41F, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 24, .reverseRotation = 3, .signalHeightOffsetLeft = 2, .signalHeightOffsetRight = 14, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::steepSlope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 82, .sparkDirection = false }, // leftCurveSmallSteepSlopeDown TrackMiscData{ .costFactor = 0x41F, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 23, .reverseRotation = 1, .signalHeightOffsetLeft = 14, .signalHeightOffsetRight = 2, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::steepSlope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 82, .sparkDirection = true }, // rightCurveSmallSteepSlopeDown TrackMiscData{ .costFactor = 0x41F, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::curveSlope | CommonTraitFlags::smallCurve, .reverseTrackId = 22, .reverseRotation = 3, .signalHeightOffsetLeft = 14, .signalHeightOffsetRight = 2, .compatibleFlags = TrackTraitFlags::smallCurve | TrackTraitFlags::steepSlope | TrackTraitFlags::slopedCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 82, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x100, .flags = CommonTraitFlags::oneSided, .reverseTrackId = 27, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0xFFFF, .unkWeighting = 32, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x100, .flags = CommonTraitFlags::oneSided, .reverseTrackId = 26, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0xFFFF, .unkWeighting = 32, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x064, .flags = CommonTraitFlags::verySmallCurve | CommonTraitFlags::oneSided, .reverseTrackId = 31, .reverseRotation = 1, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::verySmallCurve | TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 13, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x12D, .flags = CommonTraitFlags::verySmallCurve | CommonTraitFlags::oneSided, .reverseTrackId = 30, .reverseRotation = 1, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::verySmallCurve | TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 38, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x12D, .flags = CommonTraitFlags::verySmallCurve | CommonTraitFlags::oneSided, .reverseTrackId = 29, .reverseRotation = 3, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::verySmallCurve | TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 38, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x064, .flags = CommonTraitFlags::verySmallCurve | CommonTraitFlags::oneSided, .reverseTrackId = 28, .reverseRotation = 3, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::verySmallCurve | TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 13, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x126, .flags = CommonTraitFlags::sBendCurve | CommonTraitFlags::oneSided, .reverseTrackId = 32, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 36, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x126, .flags = CommonTraitFlags::sBendCurve | CommonTraitFlags::oneSided, .reverseTrackId = 33, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 36, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::oneSided, .reverseTrackId = 37, .reverseRotation = 2, .signalHeightOffsetLeft = 2, .signalHeightOffsetRight = 14, .compatibleFlags = TrackTraitFlags::steepSlope | TrackTraitFlags::oneSided, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::oneSided, .reverseTrackId = 36, .reverseRotation = 2, .signalHeightOffsetLeft = 2, .signalHeightOffsetRight = 14, .compatibleFlags = TrackTraitFlags::steepSlope | TrackTraitFlags::oneSided, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::oneSided, .reverseTrackId = 35, .reverseRotation = 2, .signalHeightOffsetLeft = 14, .signalHeightOffsetRight = 2, .compatibleFlags = TrackTraitFlags::steepSlope | TrackTraitFlags::oneSided, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope | CommonTraitFlags::oneSided, .reverseTrackId = 34, .reverseRotation = 2, .signalHeightOffsetLeft = 14, .signalHeightOffsetRight = 2, .compatibleFlags = TrackTraitFlags::steepSlope | TrackTraitFlags::oneSided, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x114, .flags = CommonTraitFlags::sBendCurve | CommonTraitFlags::oneSided, .reverseTrackId = 41, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 34, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x114, .flags = CommonTraitFlags::sBendCurve | CommonTraitFlags::oneSided, .reverseTrackId = 40, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 34, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x114, .flags = CommonTraitFlags::sBendCurve | CommonTraitFlags::oneSided, .reverseTrackId = 39, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 34, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x114, .flags = CommonTraitFlags::sBendCurve | CommonTraitFlags::oneSided, .reverseTrackId = 38, .reverseRotation = 2, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 34, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::verySmallCurve | CommonTraitFlags::oneSided, .reverseTrackId = 43, .reverseRotation = 0, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 26, .sparkDirection = false }, // unused TrackMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::verySmallCurve | CommonTraitFlags::oneSided, .reverseTrackId = 42, .reverseRotation = 0, .signalHeightOffsetLeft = 0, .signalHeightOffsetRight = 0, .compatibleFlags = TrackTraitFlags::oneSided, .curveSpeedFraction = 0x0CCD, .unkWeighting = 26, .sparkDirection = false }, }; const TrackMiscData& getTrackMiscData(size_t trackId) { return _miscData[trackId]; } constexpr std::array<RoadMiscData, 10> _roadMiscData = { // straight RoadMiscData{ .costFactor = 0x100, .flags = CommonTraitFlags::none, .reverseRoadId = 0, .reverseRotation = 2, .reverseLane = 1, .compatibleFlags = RoadTraitFlags::none, .curveSpeedFraction = 0xFFFF, .unkWeighting = 32, }, // leftCurveVerySmall RoadMiscData{ .costFactor = 0x0C9, .flags = CommonTraitFlags::verySmallCurve, .reverseRoadId = 2, .reverseRotation = 1, .reverseLane = 1, .compatibleFlags = RoadTraitFlags::verySmallCurve, .curveSpeedFraction = 0x0CCD, .unkWeighting = 25, }, // rightCurveVerySmall RoadMiscData{ .costFactor = 0x0C9, .flags = CommonTraitFlags::verySmallCurve, .reverseRoadId = 1, .reverseRotation = 3, .reverseLane = 1, .compatibleFlags = RoadTraitFlags::verySmallCurve, .curveSpeedFraction = 0x0CCD, .unkWeighting = 25, }, // leftCurveSmall RoadMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::smallCurve, .reverseRoadId = 4, .reverseRotation = 1, .reverseLane = 4, .compatibleFlags = RoadTraitFlags::smallCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 75, }, // rightCurveSmall RoadMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::smallCurve, .reverseRoadId = 3, .reverseRotation = 3, .reverseLane = 4, .compatibleFlags = RoadTraitFlags::smallCurve, .curveSpeedFraction = 0x199A, .unkWeighting = 75, }, // straightSlopeUp RoadMiscData{ .costFactor = 0x220, .flags = CommonTraitFlags::slope, .reverseRoadId = 6, .reverseRotation = 2, .reverseLane = 2, .compatibleFlags = RoadTraitFlags::slope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 66, }, // straightSlopeDown RoadMiscData{ .costFactor = 0x220, .flags = CommonTraitFlags::slope, .reverseRoadId = 5, .reverseRotation = 2, .reverseLane = 2, .compatibleFlags = RoadTraitFlags::slope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 66, }, // straightSteepSlopeUp RoadMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope, .reverseRoadId = 8, .reverseRotation = 2, .reverseLane = 1, .compatibleFlags = RoadTraitFlags::steepSlope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, }, // straightSteepSlopeDown RoadMiscData{ .costFactor = 0x138, .flags = CommonTraitFlags::steepSlope, .reverseRoadId = 7, .reverseRotation = 2, .reverseLane = 1, .compatibleFlags = RoadTraitFlags::steepSlope, .curveSpeedFraction = 0xFFFF, .unkWeighting = 36, }, // turnaround RoadMiscData{ .costFactor = 0x25B, .flags = CommonTraitFlags::none, .reverseRoadId = 9, .reverseRotation = 0, .reverseLane = 1, .compatibleFlags = RoadTraitFlags::turnaround, .curveSpeedFraction = 0x0CCD, .unkWeighting = 26, }, }; const RoadMiscData& getRoadMiscData(size_t roadId) { return _roadMiscData[roadId]; } // TODO: The following i think can be further deduplicated/generated static constexpr std::array<RoadUnkNextTo, 2> kStraightUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 2> kLeftCurveVerySmallUnkNextTo = { RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, 0, 0 }, .rotation = 2, }, }; static constexpr std::array<RoadUnkNextTo, 2> kRightCurveVerySmallUnkNextTo = { RoadUnkNextTo{ .pos = { -32, 0, 0 }, .rotation = 2, }, RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, }; static constexpr std::array<RoadUnkNextTo, 4> kLeftCurveSmallLUnkNextTo = { RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, 32, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -64, 0, 0 }, .rotation = 2, }, RoadUnkNextTo{ .pos = { -64, -32, 0 }, .rotation = 2, }, }; static constexpr std::array<RoadUnkNextTo, 4> kLeftCurveSmallRUnkNextTo = { RoadUnkNextTo{ .pos = { 32, 64, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { 0, 64, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, 0, 0 }, .rotation = 2, }, RoadUnkNextTo{ .pos = { -32, 32, 0 }, .rotation = 2, }, }; static constexpr std::array<RoadUnkNextTo, 4> kRightCurveSmallLUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -32, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -64, 0, 0 }, .rotation = 2, }, RoadUnkNextTo{ .pos = { -64, 32, 0 }, .rotation = 2, }, }; static constexpr std::array<RoadUnkNextTo, 4> kRightCurveSmallRUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -64, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 32, -64, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -32, 0, 0 }, .rotation = 2, }, RoadUnkNextTo{ .pos = { -32, -32, 0 }, .rotation = 2, }, }; static constexpr std::array<RoadUnkNextTo, 4> kStraightSlopeUpLUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, -32, 16 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -32, 32, 16 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 4> kStraightSlopeUpRUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 16 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 16 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -32, 32, 0 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 4> kStraightSlopeDownLUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 16 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 16 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -32, 32, 0 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 4> kStraightSlopeDownRUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, RoadUnkNextTo{ .pos = { -32, -32, 16 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { -32, 32, 16 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 2> kStraightSteepSlopeUpLUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 16 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 16 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 2> kStraightSteepSlopeUpRUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 2> kStraightSteepSlopeDownLUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 0 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 0 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 2> kStraightSteepSlopeDownRUnkNextTo = { RoadUnkNextTo{ .pos = { 0, -32, 16 }, .rotation = 1, }, RoadUnkNextTo{ .pos = { 0, 32, 16 }, .rotation = 3, }, }; static constexpr std::array<RoadUnkNextTo, 2> kTurnaroundUnkNextTo = kStraightUnkNextTo; // 0x004F6E02 static constexpr std::array<std::span<const RoadUnkNextTo>, 20> kRoadUnkNextTo = { kStraightUnkNextTo, kStraightUnkNextTo, kLeftCurveVerySmallUnkNextTo, kLeftCurveVerySmallUnkNextTo, kRightCurveVerySmallUnkNextTo, kRightCurveVerySmallUnkNextTo, kLeftCurveSmallLUnkNextTo, kLeftCurveSmallRUnkNextTo, kRightCurveSmallLUnkNextTo, kRightCurveSmallRUnkNextTo, kStraightSlopeUpLUnkNextTo, kStraightSlopeUpRUnkNextTo, kStraightSlopeDownLUnkNextTo, kStraightSlopeDownRUnkNextTo, kStraightSteepSlopeUpLUnkNextTo, kStraightSteepSlopeUpRUnkNextTo, kStraightSteepSlopeDownLUnkNextTo, kStraightSteepSlopeDownRUnkNextTo, kTurnaroundUnkNextTo, kTurnaroundUnkNextTo, }; std::span<const RoadUnkNextTo> getRoadUnkNextTo(uint16_t trackAndDirection) { assert(static_cast<size_t>(trackAndDirection / 4) < kRoadUnkNextTo.size()); return kRoadUnkNextTo[trackAndDirection / 4]; } // 0x004F7358 // Lane occupation mask lookup table // Indexed by (trackAndDirection._data >> 2), which encodes: // - roadId (track piece identifier) // - isBackwards (direction of travel) // - isOvertakeLane (which lane the vehicle is in) // - isChangingLane (whether the vehicle is in the process of changing lanes) // Upper nibble (>> 4) contains 2-bit lane occupation mask static constexpr std::array<uint8_t, 128> kRoadOccupationMasks = { { // clang-format off 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, // clang-format on } }; uint8_t getRoadOccupationMask(uint8_t index) { assert(index < kRoadOccupationMasks.size()); return kRoadOccupationMasks[index]; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/TrackData.h ```h #pragma once #include "Map/QuarterTile.h" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/World.hpp> #include <array> #include <cstddef> #include <cstdlib> #include <span> namespace OpenLoco::World::Track { enum class TrackTraitFlags : uint16_t; enum class RoadTraitFlags : uint16_t; enum class CommonTraitFlags : uint16_t; } namespace OpenLoco::World::TrackData { using ConnectionsByRotation = std::array<uint8_t, 4>; enum class PreviewTrackFlags : uint8_t { none = 0U, unk0 = 1U << 0, // unk0 - unk3 are a group and depend on rotation unk1 = 1U << 1, unk2 = 1U << 2, unk3 = 1U << 3, unk4 = 1U << 4, unused = 1U << 6, // Not set on any track piece diagonal = 1U << 7, }; OPENLOCO_ENABLE_ENUM_OPERATORS(PreviewTrackFlags); struct PreviewTrack { uint8_t index; // 0x00 int16_t x; // 0x01 int16_t y; // 0x03 int16_t z; // 0x05 uint8_t clearZ; // 0x07 despite being a uint8_t this is in bigZ QuarterTile subTileClearance; // 0x08 PreviewTrackFlags flags; // 0x09 ConnectionsByRotation connectFlags; // From 0x004F78F8 & 0x004F6F1C constexpr bool hasFlags(PreviewTrackFlags flagsToTest) const { return (flags & flagsToTest) != PreviewTrackFlags::none; }; }; #pragma pack(push, 1) // Pos is difference from the next first tile and the track first tile struct TrackCoordinates { uint8_t rotationBegin; // 0x00 uint8_t rotationEnd; // 0x01 World::Pos3 pos; // 0x02 }; static_assert(sizeof(TrackCoordinates) == 0x8); #pragma pack(pop) const std::span<const PreviewTrack> getTrackPiece(size_t trackId); const std::span<const PreviewTrack> getRoadPiece(size_t trackId); const TrackCoordinates& getUnkTrack(uint16_t trackAndDirection); const TrackCoordinates& getUnkRoad(uint16_t trackAndDirection); struct TrackMiscData { uint16_t costFactor; // 0x004F870C Track::CommonTraitFlags flags; // 0x004F8764 uint8_t reverseTrackId; // 0x004F87BC uint8_t reverseRotation; // 0x004F87BD uint8_t signalHeightOffsetLeft; // 0x004F87BE uint8_t signalHeightOffsetRight; // 0x004F87BF Track::TrackTraitFlags compatibleFlags; // 0x004F891C uint16_t curveSpeedFraction; // 0x004F8974 uint32_t unkWeighting; // 0x004F89CC bool sparkDirection; // 0x004F8A7C true == right }; struct RoadMiscData { uint16_t costFactor; // 0x004F7270 Track::CommonTraitFlags flags; // 0x004F7284 uint8_t reverseRoadId; // 0x004F7298 uint8_t reverseRotation; // 0x004F7299 uint8_t reverseLane; // 0x004F729C Track::RoadTraitFlags compatibleFlags; // 0x004F72E8 uint16_t curveSpeedFraction; // 0x004F72FC uint32_t unkWeighting; // 0x004F7310 }; const TrackMiscData& getTrackMiscData(size_t trackId); const RoadMiscData& getRoadMiscData(size_t roadId); struct RoadUnkNextTo { World::Pos3 pos; // 0x00 (was 3x int8) uint8_t rotation; // 0x03 }; std::span<const RoadUnkNextTo> getRoadUnkNextTo(uint16_t trackAndDirection); // 0x004F7358 // Returns the lane occupation mask for a given road trackAndDirection value. // The index is (trackAndDirection._data >> 2), which encodes: // - roadId (track piece identifier) // - isBackwards (direction of travel) // - isOvertakeLane (which lane the vehicle is in) // - isChangingLane (whether the vehicle is in the process of changing lanes) // The returned value's upper nibble (>> 4) contains a 2-bit lane occupation mask. uint8_t getRoadOccupationMask(uint8_t index); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/TrackEnum.h ```h #pragma once #include <OpenLoco/Core/EnumFlags.hpp> #include <cstdint> namespace OpenLoco::World::Track { enum class TrackId : uint8_t { straight, diagonal, leftCurveVerySmall, rightCurveVerySmall, leftCurveSmall, rightCurveSmall, leftCurve, rightCurve, leftCurveLarge, rightCurveLarge, diagonalLeftCurveLarge, diagonalRightCurveLarge, sBendLeft, sBendRight, straightSlopeUp, straightSlopeDown, straightSteepSlopeUp, straightSteepSlopeDown, leftCurveSmallSlopeUp, rightCurveSmallSlopeUp, leftCurveSmallSlopeDown, rightCurveSmallSlopeDown, leftCurveSmallSteepSlopeUp, rightCurveSmallSteepSlopeUp, leftCurveSmallSteepSlopeDown, rightCurveSmallSteepSlopeDown, unkStraight1, unkStraight2, unkLeftCurveVerySmall1, unkLeftCurveVerySmall2, unkRightCurveVerySmall1, unkRightCurveVerySmall2, unkSBendRight, unkSBendLeft, unkStraightSteepSlopeUp1, unkStraightSteepSlopeUp2, unkStraightSteepSlopeDown1, unkStraightSteepSlopeDown2, sBendToDualTrack, sBendToSingleTrack, unkSBendToDualTrack, unkSBendToSingleTrack, turnaround, unkTurnaround, }; enum class RoadId : uint8_t { straight, leftCurveVerySmall, rightCurveVerySmall, leftCurveSmall, rightCurveSmall, straightSlopeUp, straightSlopeDown, straightSteepSlopeUp, straightSteepSlopeDown, turnaround, }; // For some reason we have Common, Track and Road Trait flags // but they are all pretty much the same thing. One day we should // look into amalgamating them into one. enum class CommonTraitFlags : uint16_t { none = 0U, slope = 1U << 0, steepSlope = 1U << 1, curveSlope = 1U << 2, diagonal = 1U << 3, verySmallCurve = 1U << 4, smallCurve = 1U << 5, curve = 1U << 6, largeCurve = 1U << 7, sBendCurve = 1U << 8, oneSided = 1U << 9, startsAtHalfHeight = 1U << 10, // Not used. From RCT2 junction = 1U << 11, unk12 = 1U << 12, }; OPENLOCO_ENABLE_ENUM_OPERATORS(CommonTraitFlags); enum class TrackTraitFlags : uint16_t { none = 0U, diagonal = 1U << 0, largeCurve = 1U << 1, normalCurve = 1U << 2, smallCurve = 1U << 3, verySmallCurve = 1U << 4, slope = 1U << 5, steepSlope = 1U << 6, oneSided = 1U << 7, slopedCurve = 1U << 8, sBend = 1U << 9, junction = 1U << 10, }; OPENLOCO_ENABLE_ENUM_OPERATORS(TrackTraitFlags); enum class RoadTraitFlags : uint16_t { none = 0U, smallCurve = 1U << 0, verySmallCurve = 1U << 1, slope = 1U << 2, steepSlope = 1U << 3, unk4 = 1U << 4, turnaround = 1U << 5, junction = 1U << 6, }; OPENLOCO_ENABLE_ENUM_OPERATORS(RoadTraitFlags); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Map/Track/TrackModSection.h ```h #pragma once #include <cstdint> namespace OpenLoco::World::Track { enum class ModSection : uint8_t { single = 0, block = 1, allConnected = 2, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/Network.cpp ```cpp #include "Network.h" #include "CommandLine.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Graphics/Gfx.h" #include "Logging.h" #include "NetworkClient.h" #include "NetworkServer.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "Socket.h" #include <cassert> #include <stdexcept> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Network { enum class NetworkMode { none, server, client }; static NetworkMode _mode; static std::unique_ptr<NetworkServer> _server; static std::unique_ptr<NetworkClient> _client; static NetworkBase* getServerOrClient() { switch (_mode) { case NetworkMode::server: return _server.get(); case NetworkMode::client: return _client.get(); default: return nullptr; } } void openServer() { assert(_mode == NetworkMode::none); try { const auto& cmdlineOptions = getCommandLineOptions(); auto& bind = cmdlineOptions.bind; auto port = cmdlineOptions.port.value_or(kDefaultPort); _server = std::make_unique<NetworkServer>(); _server->listen(bind, port); _mode = NetworkMode::server; SceneManager::addSceneFlags(SceneManager::Flags::networked); SceneManager::addSceneFlags(SceneManager::Flags::networkHost); Gfx::invalidateScreen(); } catch (...) { _server = nullptr; throw; } } void joinServer(std::string_view host) { joinServer(host, kDefaultPort); } void joinServer(std::string_view host, port_t port) { assert(_mode == NetworkMode::none); try { _client = std::make_unique<NetworkClient>(); _client->connect(host, port); _mode = NetworkMode::client; } catch (...) { _client = nullptr; throw; } } void close() { _server = nullptr; _client = nullptr; _mode = NetworkMode::none; } void update() { auto serverOrClient = getServerOrClient(); if (serverOrClient != nullptr) { serverOrClient->update(); if (serverOrClient->isClosed()) { close(); } } } void sendChatMessage(std::string_view message) { auto serverOrClient = getServerOrClient(); if (serverOrClient != nullptr) { serverOrClient->sendChatMessage(message); } } void receiveChatMessage(client_id_t client, std::string_view message) { Logging::info("Player #{}: {}", static_cast<int>(client), message); } void queueGameCommand(CompanyId company, const OpenLoco::Interop::registers& regs) { // TEMP debug code if (regs.esi == 73) { return; } if (_mode == NetworkMode::server) { _server->queueGameCommand(company, regs); } else { _client->sendGameCommand(company, regs); } } bool shouldProcessTick(uint32_t tick) { if (_mode == NetworkMode::client) { return _client->shouldProcessTick(tick); } else { return true; } } void processGameCommands(uint32_t tick) { switch (_mode) { case NetworkMode::none: break; case NetworkMode::server: _server->runGameCommands(); break; case NetworkMode::client: _client->runGameCommandsForTick(tick); break; } } bool isConnected() { switch (_mode) { default: case NetworkMode::none: return false; case NetworkMode::server: return true; case NetworkMode::client: return _client->getStatus() == NetworkClientStatus::connected; } } uint32_t getServerTick() { if (_mode == NetworkMode::client) { return _client->getLocalTick(); } return ScenarioManager::getScenarioTicks(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/Network.h ```h #pragma once #include "Types.hpp" #include <cstdint> #include <string_view> namespace OpenLoco::Interop { struct registers; } namespace OpenLoco::Network { using client_id_t = uint32_t; using port_t = uint16_t; constexpr port_t kDefaultPort = 11754; constexpr uint16_t kMaxPacketSize = 4096; constexpr uint16_t kNetworkVersion = 1; void openServer(); void joinServer(std::string_view host); void joinServer(std::string_view host, port_t port); void close(); void update(); void sendChatMessage(std::string_view message); void receiveChatMessage(client_id_t client, std::string_view message); void queueGameCommand(CompanyId company, const OpenLoco::Interop::registers& regs); bool shouldProcessTick(uint32_t tick); void processGameCommands(uint32_t tick); /** * Whether the game state is networked. * This will return false if the client is still receiving the map from the server. */ bool isConnected(); /** * Gets the current tick the server is on. */ uint32_t getServerTick(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkBase.cpp ```cpp #include "NetworkBase.h" #include "Logging.h" #include "Packet.h" #include <OpenLoco/Platform/Platform.h> using namespace OpenLoco; using namespace OpenLoco::Network; NetworkBase::NetworkBase() { } NetworkBase::~NetworkBase() { close(); } bool NetworkBase::isClosed() const { return _isClosed; }; void NetworkBase::receivePacketLoop() { while (!_endReceivePacketLoop) { bool receivedPacket{}; for (auto& socket : _sockets) { Packet packet; size_t packetSize{}; std::unique_ptr<INetworkEndpoint> endpoint; auto result = socket->receiveData(&packet, sizeof(Packet), &packetSize, &endpoint); if (result == NetworkReadPacket::success) { // Validate packet if (packet.header.dataSize <= packetSize - sizeof(PacketHeader)) { onReceivePacket(*socket, std::move(endpoint), packet); } receivedPacket = true; } } if (!receivedPacket) { std::this_thread::sleep_for(std::chrono::milliseconds(1)); } } } void NetworkBase::beginReceivePacketLoop() { _endReceivePacketLoop = false; _receivePacketThread = std::thread([this] { receivePacketLoop(); }); } void NetworkBase::endReceivePacketLoop() { _endReceivePacketLoop = true; if (_receivePacketThread.joinable()) { _receivePacketThread.join(); } _receivePacketThread = {}; } void NetworkBase::update() { onUpdate(); } void NetworkBase::onClose() { } void NetworkBase::onUpdate() { } void NetworkBase::onReceivePacket(IUdpSocket&, std::unique_ptr<INetworkEndpoint>, const Packet&) { } void NetworkBase::close() { if (_isClosed) { return; } endReceivePacketLoop(); onClose(); _sockets.clear(); _isClosed = true; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkBase.h ```h #pragma once #include "Network.h" #include "Packet.h" #include "Socket.h" #include <cstdint> #include <memory> #include <thread> namespace OpenLoco::Network { class NetworkBase { private: std::thread _receivePacketThread; bool _endReceivePacketLoop{}; bool _isClosed{}; void receivePacketLoop(); protected: std::vector<std::unique_ptr<IUdpSocket>> _sockets; void beginReceivePacketLoop(); void endReceivePacketLoop(); virtual void onClose(); virtual void onUpdate(); virtual void onReceivePacket(IUdpSocket& socket, std::unique_ptr<INetworkEndpoint> endpoint, const Packet& packet); public: NetworkBase(); virtual ~NetworkBase(); bool isClosed() const; void close(); void update(); virtual void sendChatMessage(std::string_view message) = 0; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkClient.cpp ```cpp #include "NetworkClient.h" #include "Config.h" #include "GameCommands/GameCommands.h" #include "Logging.h" #include "NetworkConnection.h" #include "S5/S5.h" #include "SceneManager.h" #include "Ui/WindowManager.h" #include <OpenLoco/Core/BinaryStream.h> #include <OpenLoco/Platform/Platform.h> using namespace OpenLoco; using namespace OpenLoco::Network; using namespace OpenLoco::Diagnostics; NetworkClient::~NetworkClient() { close(); } NetworkClientStatus NetworkClient::getStatus() const { return _status; } uint32_t NetworkClient::getLocalTick() const { return _localTick; } void NetworkClient::connect(std::string_view host, port_t port) { auto szHost = std::string(host); _serverEndpoint = Socket::resolve(Protocol::any, szHost, port); _sockets.push_back(Socket::createUdp()); auto& socket = _sockets.back(); _serverConnection = std::make_unique<NetworkConnection>(socket.get(), _serverEndpoint->clone()); auto szHostIpAddress = _serverEndpoint->getIpAddress(); Logging::info("Resolved endpoint for {}:{}", szHostIpAddress, port); beginReceivePacketLoop(); _status = NetworkClientStatus::connecting; _timeout = Platform::getTime() + 5000; sendConnectPacket(); initStatus("Connecting to " + szHost + "..."); } void NetworkClient::onClose() { _serverConnection = nullptr; if (_status != NetworkClientStatus::none && _status != NetworkClientStatus::connecting) { _status = NetworkClientStatus::closed; SceneManager::removeSceneFlags(SceneManager::Flags::networked); Logging::info("Disconnected from server"); } else if (_status == NetworkClientStatus::connecting) { endStatus("Failed to connect to server"); _status = NetworkClientStatus::closed; } } void NetworkClient::onUpdate() { processReceivedPackets(); if (_status == NetworkClientStatus::connecting) { if (Platform::getTime() >= _timeout) { close(); Logging::info("Failed to connect to server"); endStatus("Failed to connect to server"); } } else { if (hasTimedOut()) { Logging::info("Connection with server timed out"); close(); } else { switch (_status) { case NetworkClientStatus::connectedSuccessfully: sendRequestStatePacket(); _status = NetworkClientStatus::waitingForState; break; case NetworkClientStatus::waitingForState: break; default: break; } } } } void NetworkClient::processReceivedPackets() { if (_serverConnection != nullptr) { while (auto packet = _serverConnection->takeNextPacket()) { onReceivePacketFromServer(*packet); // A packet handler may close the connection if (_serverConnection == nullptr) { return; } } _serverConnection->update(); } } bool NetworkClient::hasTimedOut() const { if (_serverConnection != nullptr) { return _serverConnection->hasTimedOut(); } return false; } void NetworkClient::onReceivePacket([[maybe_unused]] IUdpSocket& socket, std::unique_ptr<INetworkEndpoint> endpoint, const Packet& packet) { // TODO do we really need the check, it is possible but unlikely // for something else to hijack the UDP client port if (_serverEndpoint != nullptr && endpoint->equals(*_serverEndpoint)) { _serverConnection->receivePacket(packet); } } void NetworkClient::onCancel() { switch (_status) { case NetworkClientStatus::connecting: Logging::info("Connecting to server cancelled"); close(); break; default: break; } } void NetworkClient::onReceivePacketFromServer(const Packet& packet) { switch (packet.header.kind) { case PacketKind::connectResponse: receiveConnectionResponsePacket(*reinterpret_cast<const ConnectResponsePacket*>(packet.data)); break; case PacketKind::requestStateResponse: receiveRequestStateResponsePacket(*reinterpret_cast<const RequestStateResponse*>(packet.data)); break; case PacketKind::requestStateResponseChunk: receiveRequestStateResponseChunkPacket(*reinterpret_cast<const RequestStateResponseChunk*>(packet.data)); break; case PacketKind::receiveChatMessage: receiveChatMessagePacket(*reinterpret_cast<const ReceiveChatMessage*>(packet.data)); break; case PacketKind::ping: receivePingPacket(*reinterpret_cast<const PingPacket*>(packet.data)); break; case PacketKind::gameCommand: receiveGameCommandPacket(*reinterpret_cast<const GameCommandPacket*>(packet.data)); break; default: break; } } void NetworkClient::sendConnectPacket() { const auto& config = Config::get(); ConnectPacket packet; std::strncpy(packet.name, config.preferredOwnerName.c_str(), sizeof(packet.name)); packet.version = kNetworkVersion; _serverConnection->sendPacket(packet); } void NetworkClient::sendRequestStatePacket() { _requestStateCookie = (std::rand() << 16) | std::rand(); _requestStateChunksReceived.clear(); RequestStatePacket packet; packet.cookie = _requestStateCookie; _serverConnection->sendPacket(packet); } void NetworkClient::receiveConnectionResponsePacket(const ConnectResponsePacket& response) { if (response.result == ConnectionResult::success) { _status = NetworkClientStatus::connectedSuccessfully; setStatus("Connected to server successfully"); SceneManager::addSceneFlags(SceneManager::Flags::networked); } else { close(); } } void NetworkClient::receiveRequestStateResponsePacket(const RequestStateResponse& response) { if (response.cookie == _requestStateCookie) { _requestStateNumChunks = response.numChunks; _requestStateTotalSize = response.totalSize; _requestStateReceivedChunks = 0; } } void NetworkClient::receiveRequestStateResponseChunkPacket(const RequestStateResponseChunk& responseChunk) { if (responseChunk.cookie == _requestStateCookie) { if (_requestStateChunksReceived.size() <= responseChunk.index) { _requestStateChunksReceived.resize(responseChunk.index + 1); } auto& rchunk = _requestStateChunksReceived[responseChunk.index]; if (rchunk.data.size() == 0) { rchunk.offset = responseChunk.offset; rchunk.data.assign(responseChunk.data, responseChunk.data + responseChunk.dataSize); _requestStateReceivedChunks++; _requestStateReceivedBytes += responseChunk.dataSize; setStatus("Receiving state: " + std::to_string(_requestStateReceivedBytes) + " / " + std::to_string(_requestStateTotalSize)); } if (_requestStateReceivedChunks >= _requestStateNumChunks) { // Construct full data std::vector<uint8_t> fullData; for (size_t i = 0; i < _requestStateChunksReceived.size(); i++) { fullData.insert(fullData.end(), _requestStateChunksReceived[i].data.begin(), _requestStateChunksReceived[i].data.end()); } clearStatus(); _status = NetworkClientStatus::connected; processFullState(fullData); } } } void NetworkClient::processFullState(std::span<uint8_t const> fullData) { auto* extra = reinterpret_cast<const ExtraState*>(fullData.data() + fullData.size() - sizeof(ExtraState)); _localGameCommandIndex = extra->gameCommandIndex; _localTick = extra->tick; updateLocalTick(); BinaryStream bs(fullData.data(), fullData.size() - sizeof(ExtraState)); S5::importSaveToGameState(bs, S5::LoadFlags::none); } void NetworkClient::receiveChatMessagePacket(const ReceiveChatMessage& packet) { Network::receiveChatMessage(packet.sender, packet.getText()); } void NetworkClient::receivePingPacket(const PingPacket& packet) { if (_status != NetworkClientStatus::connected) { return; } // Update the latest knowledge of server state _serverTick = std::max(_serverTick, packet.tick); _serverGameCommandIndex = std::max(_serverGameCommandIndex, packet.gameCommandIndex); if (_localGameCommandIndex == _serverGameCommandIndex) { // No pending game commands, we can update to this tick _localTick = packet.tick; } } void NetworkClient::receiveGameCommandPacket(const GameCommandPacket& packet) { // Update the latest knowledge of server state _serverTick = std::max(_serverTick, packet.tick); _serverGameCommandIndex = std::max(_serverGameCommandIndex, packet.index); // Catch old or repeated game command index assert(packet.index > _localGameCommandIndex); // Insert into ordered game command queue for (auto it = _receivedGameCommands.begin(); it != _receivedGameCommands.end(); it++) { auto& p = *it; // Catch duplicate game command index assert(packet.index != p.index); if (packet.index <= p.index) { _receivedGameCommands.insert(it, packet); return; } } _receivedGameCommands.push_back(packet); updateLocalTick(); } void NetworkClient::sendChatMessage(std::string_view message) { if (_serverConnection != nullptr) { SendChatMessage packet; packet.length = static_cast<uint16_t>(message.size() + 1); std::memcpy(packet.text, message.data(), message.size()); _serverConnection->sendPacket(packet); } } void NetworkClient::sendGameCommand(CompanyId company, const OpenLoco::Interop::registers& regs) { if (_serverConnection != nullptr && _status == NetworkClientStatus::connected) { GameCommandPacket packet; packet.company = company; packet.regs = regs; _serverConnection->sendPacket(packet); } } void NetworkClient::updateLocalTick() { // If we have the next game command, we can set local tick to the tick for that command if (!_receivedGameCommands.empty()) { auto& nextGameCommand = _receivedGameCommands.front(); if (nextGameCommand.index == _localGameCommandIndex + 1) { // We already have the next game command, so we can update to the tick for that command _localTick = nextGameCommand.tick; } } } bool NetworkClient::shouldProcessTick(uint32_t tick) const { if (_status != NetworkClientStatus::connected) { return true; } return _localTick >= tick; } void NetworkClient::runGameCommandsForTick(uint32_t tick) { if (_status != NetworkClientStatus::connected) { return; } // Execute all following commands if previously received while (!_receivedGameCommands.empty()) { auto& nextPacket = _receivedGameCommands.front(); if (nextPacket.index == _localGameCommandIndex + 1 && nextPacket.tick == tick) { _localGameCommandIndex++; GameCommands::doCommandForReal(static_cast<GameCommands::GameCommand>(nextPacket.regs.esi), nextPacket.company, nextPacket.regs); _receivedGameCommands.pop_front(); } else { break; } } updateLocalTick(); } void NetworkClient::initStatus(std::string_view text) { Ui::Windows::NetworkStatus::open(text, [this]() { onCancel(); }); } void NetworkClient::setStatus(std::string_view text) { Ui::Windows::NetworkStatus::setText(text); } void NetworkClient::endStatus(std::string_view text) { Ui::Windows::NetworkStatus::setText(text, nullptr); } void NetworkClient::clearStatus() { Ui::Windows::NetworkStatus::close(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkClient.h ```h #pragma once #include "Network.h" #include "NetworkBase.h" #include "Socket.h" #include <cstdint> #include <list> #include <span> #include <vector> namespace OpenLoco::Network { class NetworkConnection; enum class NetworkClientStatus { none, connecting, connectedSuccessfully, waitingForState, connected, closed, }; class NetworkClient : public NetworkBase { private: std::unique_ptr<INetworkEndpoint> _serverEndpoint; std::unique_ptr<NetworkConnection> _serverConnection; NetworkClientStatus _status{}; uint32_t _timeout{}; uint32_t _localGameCommandIndex; uint32_t _serverGameCommandIndex; uint32_t _localTick; uint32_t _serverTick; std::list<GameCommandPacket> _receivedGameCommands; struct ReceivedChunk { uint32_t offset{}; std::vector<uint8_t> data; }; uint32_t _requestStateCookie{}; uint32_t _requestStateTotalSize{}; uint16_t _requestStateNumChunks{}; std::vector<ReceivedChunk> _requestStateChunksReceived; uint32_t _requestStateReceivedBytes{}; uint32_t _requestStateReceivedChunks{}; void onCancel(); void processReceivedPackets(); bool hasTimedOut() const; void onReceivePacketFromServer(const Packet& packet); void processFullState(std::span<uint8_t const> data); void updateLocalTick(); void initStatus(std::string_view text); void setStatus(std::string_view text); void clearStatus(); void endStatus(std::string_view text); void sendConnectPacket(); void sendRequestStatePacket(); void receiveConnectionResponsePacket(const ConnectResponsePacket& response); void receiveRequestStateResponsePacket(const RequestStateResponse& response); void receiveRequestStateResponseChunkPacket(const RequestStateResponseChunk& responseChunk); void receiveChatMessagePacket(const ReceiveChatMessage& packet); void receivePingPacket(const PingPacket& packet); void receiveGameCommandPacket(const GameCommandPacket& packet); protected: void onClose() override; void onUpdate() override; void onReceivePacket(IUdpSocket& socket, std::unique_ptr<INetworkEndpoint> endpoint, const Packet& packet) override; public: ~NetworkClient() override; NetworkClientStatus getStatus() const; uint32_t getLocalTick() const; void connect(std::string_view host, port_t port); void sendChatMessage(std::string_view message) override; void sendGameCommand(CompanyId company, const OpenLoco::Interop::registers& regs); bool shouldProcessTick(uint32_t tick) const; void runGameCommandsForTick(uint32_t tick); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkConnection.cpp ```cpp #include "NetworkConnection.h" #include "Logging.h" #include <OpenLoco/Platform/Platform.h> #include <cstring> using namespace OpenLoco::Network; constexpr uint32_t kRedeliverTimeout = 1000; constexpr uint32_t kConnectionTimeout = 15000; NetworkConnection::NetworkConnection(IUdpSocket* socket, std::unique_ptr<INetworkEndpoint> endpoint) : _socket(socket) , _endpoint(std::move(endpoint)) { } const INetworkEndpoint& NetworkConnection::getEndpoint() const { return *_endpoint; } uint32_t NetworkConnection::getTime() { return Platform::getTime(); } bool NetworkConnection::hasTimedOut() const { auto durationSinceLastPacket = getTime() - _timeOfLastReceivedPacket; if (durationSinceLastPacket > kConnectionTimeout) { return true; } return false; } void NetworkConnection::update() { resendUndeliveredPackets(); } bool NetworkConnection::checkOrRecordReceivedSequence(sequence_t sequence) { for (auto s : _receivedSequences) { if (s == sequence) { return true; } } while (_receivedSequences.size() >= 1024) { _receivedSequences.pop_back(); } _receivedSequences.push_back(sequence); return false; } void NetworkConnection::receivePacket(const Packet& packet) { _timeOfLastReceivedPacket = Platform::getTime(); logPacket(packet, false, false); if (packet.header.kind == PacketKind::ack) { receiveAcknowledgePacket(packet.header.sequence); } else { // Send ACK back, even if we have already received this packet before // the ACK we sent before, may not have been delivered successfully sendAcknowledgePacket(packet.header.sequence); // Only store the packet, if this is the first time we received it if (!checkOrRecordReceivedSequence(packet.header.sequence)) { std::unique_lock<std::mutex> lk(_receivedPacketsSync); _receivedPackets.push(packet); } } } void NetworkConnection::sendPacket(PacketKind kind, size_t dataSize, const void* packetData) { assert(dataSize <= kMaxPacketDataSize); Packet packet; packet.header.kind = kind; packet.header.sequence = _sendSequence++; packet.header.dataSize = static_cast<uint16_t>(dataSize); std::memcpy(packet.data, packetData, packet.header.dataSize); sendPacket(packet); } void NetworkConnection::sendPacket(const Packet& packet) { if (packet.header.kind != PacketKind::ack) { std::unique_lock<std::mutex> lk(_sentPacketsSync); auto timestamp = getTime(); _sentPackets.push_back({ timestamp, packet }); } size_t packetSize = sizeof(PacketHeader) + packet.header.dataSize; _socket->sendData(*_endpoint, &packet, packetSize); logPacket(packet, true, false); } void NetworkConnection::receiveAcknowledgePacket(sequence_t sequence) { std::unique_lock<std::mutex> lk(_sentPacketsSync); for (size_t i = 0; i < _sentPackets.size(); i++) { if (_sentPackets[i].packet.header.sequence == sequence) { _sentPackets.erase(_sentPackets.begin() + i); break; } } } void NetworkConnection::sendAcknowledgePacket(sequence_t sequence) { Packet packet; packet.header.kind = PacketKind::ack; packet.header.sequence = sequence; packet.header.dataSize = 0; sendPacket(packet); } void NetworkConnection::resendUndeliveredPackets() { std::unique_lock<std::mutex> lk(_sentPacketsSync); auto now = getTime(); auto timestamp = now - kRedeliverTimeout; for (size_t i = 0; i < _sentPackets.size(); i++) { auto& sentPacket = _sentPackets[i]; if (sentPacket.timestamp < timestamp) { size_t packetSize = sizeof(PacketHeader) + sentPacket.packet.header.dataSize; _socket->sendData(*_endpoint, &sentPacket.packet, packetSize); logPacket(sentPacket.packet, true, true); sentPacket.timestamp = now; } } } std::optional<Packet> NetworkConnection::takeNextPacket() { std::unique_lock<std::mutex> lk(_receivedPacketsSync); if (!_receivedPackets.empty()) { auto packet = _receivedPackets.front(); _receivedPackets.pop(); return packet; } return std::nullopt; } [[maybe_unused]] static const char* getPacketKindString(PacketKind kind) { switch (kind) { case PacketKind::ack: return "ACK"; case PacketKind::ping: return "PING"; case PacketKind::connect: return "CONNECT"; case PacketKind::connectResponse: return "CONNECT RESPONSE"; case PacketKind::requestState: return "REQUEST STATE"; case PacketKind::requestStateResponse: return "REQUEST STATE RESPONSE"; case PacketKind::requestStateResponseChunk: return "REQUEST STATE RESPONSE CHUNK"; case PacketKind::sendChatMessage: return "SEND CHAT"; case PacketKind::receiveChatMessage: return "RECEIVE CHAT"; case PacketKind::gameCommand: return "GAME COMMAND"; default: return "UNKNOWN"; } } void NetworkConnection::logPacket([[maybe_unused]] const Packet& packet, [[maybe_unused]] bool sent, [[maybe_unused]] bool resend) { #if defined(DEBUG) #ifdef LOG_PACKETS auto szDirection = sent ? "SENT" : "RECV"; auto seq = static_cast<int32_t>(packet.header.sequence); auto bytes = static_cast<int32_t>(packet.header.dataSize); if (packet.header.kind == PacketKind::ack || packet.header.kind == PacketKind::ping || resend) { #ifdef LOG_ACK_PACKETS Logging::info("[{}] #{:04} | ACK", szDirection, seq); #endif } else if (resend) { Logging::info("[{}] #{:04} | RESEND", szDirection, seq); } else if (packet.header.kind == PacketKind::gameCommand) { auto kind = getPacketKindString(packet.header.kind); const auto& gc = packet.Cast<GameCommandPacket>(); Logging::info("[{}] #{:04} | {} (Index = {} Tick = {} Command = {})", szDirection, seq, kind, gc->index, gc->tick, gc->regs.esi); } else { auto kind = getPacketKindString(packet.header.kind); Logging::info("[{}] #{:04} | {} ({} bytes)", szDirection, seq, kind, bytes); } #endif #endif } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkConnection.h ```h #pragma once #include "Network.h" #include "Packet.h" #include "Socket.h" #include <cassert> #include <cstdint> #include <deque> #include <memory> #include <mutex> #include <optional> #include <queue> #include <thread> namespace OpenLoco::Network { class NetworkConnection { private: struct SentPacket { uint32_t timestamp; Packet packet; }; IUdpSocket* _socket; std::unique_ptr<INetworkEndpoint> _endpoint; std::mutex _sentPacketsSync; std::mutex _receivedPacketsSync; std::vector<SentPacket> _sentPackets; std::queue<Packet> _receivedPackets; std::deque<sequence_t> _receivedSequences; uint16_t _sendSequence{}; uint32_t _timeOfLastReceivedPacket{}; static uint32_t getTime(); bool checkOrRecordReceivedSequence(sequence_t sequence); void receiveAcknowledgePacket(sequence_t sequence); void sendAcknowledgePacket(sequence_t sequence); void resendUndeliveredPackets(); void sendPacket(PacketKind kind, size_t dataSize, const void* packetData); void logPacket(const Packet& packet, bool sent, bool resend); public: NetworkConnection(IUdpSocket* socket, std::unique_ptr<INetworkEndpoint> endpoint); const INetworkEndpoint& getEndpoint() const; bool hasTimedOut() const; void update(); void receivePacket(const Packet& packet); void sendPacket(const Packet& packet); std::optional<Packet> takeNextPacket(); template<typename T> void sendPacket(const T& packetData) { sendPacket(T::kind, packetData.size(), &packetData); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkServer.cpp ```cpp #include "NetworkServer.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Logging.h" #include "NetworkConnection.h" #include "S5/S5.h" #include "ScenarioManager.h" #include "SceneManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Core/MemoryStream.h> #include <OpenLoco/Platform/Platform.h> #include <OpenLoco/Utility/String.hpp> #include <span> using namespace OpenLoco; using namespace OpenLoco::Network; using namespace OpenLoco::Diagnostics; constexpr uint32_t kPingInterval = 30; NetworkServer::~NetworkServer() { close(); } void NetworkServer::listen(const std::string& bind, port_t port) { // IPv4 try { auto socket4 = Socket::createUdp(); socket4->listen(Protocol::ipv4, bind, port); _sockets.push_back(std::move(socket4)); } catch (...) { } // IPv6 try { auto socket6 = Socket::createUdp(); socket6->listen(Protocol::ipv6, bind, port); _sockets.push_back(std::move(socket6)); } catch (...) { } if (_sockets.empty()) { throw Exception::RuntimeError("Unable to listen on " + bind + ", port " + std::to_string(port)); } beginReceivePacketLoop(); SceneManager::addSceneFlags(SceneManager::Flags::networked); SceneManager::addSceneFlags(SceneManager::Flags::networkHost); Logging::info("Server opened"); for (const auto& socket : _sockets) { auto ipAddress = socket->getIpAddress(); if (socket->getProtocol() == Protocol::ipv6) { ipAddress = '[' + ipAddress + ']'; } Logging::info("Listening for incoming connections on {}:{}...", ipAddress.c_str(), port); } } void NetworkServer::onClose() { SceneManager::removeSceneFlags(SceneManager::Flags::networked); SceneManager::removeSceneFlags(SceneManager::Flags::networkHost); Logging::info("Server closed"); } Client* NetworkServer::findClient(const INetworkEndpoint& endpoint) { for (auto& client : _clients) { if (client->connection->getEndpoint().equals(endpoint)) { return client.get(); } } return nullptr; } void NetworkServer::createNewClient(std::unique_ptr<NetworkConnection> conn, const ConnectPacket& packet) { auto newClient = std::make_unique<Client>(); newClient->id = _nextClientId++; newClient->connection = std::move(conn); newClient->name = Utility::nullTerminatedView(packet.name); _clients.push_back(std::move(newClient)); auto& newClientPtr = *_clients.back(); ConnectResponsePacket response; response.result = ConnectionResult::success; newClientPtr.connection->sendPacket(response); Logging::info("Accepted new client: {}", newClientPtr.name); } void NetworkServer::onReceivePacket(IUdpSocket& socket, std::unique_ptr<INetworkEndpoint> endpoint, const Packet& packet) { auto client = findClient(*endpoint); if (client == nullptr) { auto connectPacket = packet.as<PacketKind::connect, ConnectPacket>(); if (connectPacket != nullptr) { auto conn = std::make_unique<NetworkConnection>(&socket, std::move(endpoint)); conn->receivePacket(packet); std::unique_lock<std::mutex> lk(_incomingConnectionsSync); _incomingConnections.push_back(std::move(conn)); } } else { client->connection->receivePacket(packet); } } void NetworkServer::onReceivePacketFromClient(Client& client, const Packet& packet) { switch (packet.header.kind) { case PacketKind::requestState: onReceiveStateRequestPacket(client, *packet.cast<RequestStatePacket>()); break; case PacketKind::sendChatMessage: onReceiveSendChatMessagePacket(client, *packet.cast<SendChatMessage>()); break; case PacketKind::gameCommand: onReceiveGameCommandPacket(client, *packet.cast<GameCommandPacket>()); break; default: break; } } void NetworkServer::onReceiveStateRequestPacket(Client& client, const RequestStatePacket& request) { constexpr uint16_t kChunkSize = 4000; // Dump S5 data to stream MemoryStream ms; S5::exportGameStateToFile(ms, S5::SaveFlags::noWindowClose); // Append extra state ExtraState extra; extra.gameCommandIndex = _gameCommandIndex; extra.tick = ScenarioManager::getScenarioTicks(); ms.write(&extra, sizeof(extra)); RequestStateResponse response; response.cookie = request.cookie; response.totalSize = ms.getLength(); response.numChunks = static_cast<uint16_t>((ms.getLength() + (kChunkSize - 1)) / kChunkSize); client.connection->sendPacket(response); uint32_t offset = 0; uint32_t remaining = response.totalSize; uint16_t index = 0; while (index < response.numChunks) { RequestStateResponseChunk chunk; chunk.cookie = request.cookie; chunk.index = index; chunk.offset = offset; chunk.dataSize = std::min<uint32_t>(kChunkSize, remaining - offset); std::memcpy(chunk.data, reinterpret_cast<const uint8_t*>(ms.data()) + offset, chunk.dataSize); client.connection->sendPacket(chunk); offset += chunk.dataSize; index++; } } void NetworkServer::onReceiveSendChatMessagePacket(Client& client, const SendChatMessage& packet) { std::unique_lock<std::mutex> lk(_chatMessageQueueSync); _chatMessageQueue.push({ client.id, std::string(packet.getText()) }); } void NetworkServer::onReceiveGameCommandPacket([[maybe_unused]] Client& client, const GameCommandPacket& packet) { queueGameCommand(packet.company, packet.regs); } void NetworkServer::removedTimedOutClients() { for (auto it = _clients.begin(); it != _clients.end();) { auto& client = *it; if (client->connection->hasTimedOut()) { Logging::info("Client timed out: %s", client->name); it = _clients.erase(it); } else { it++; } } _clients.erase( std::remove_if(_clients.begin(), _clients.end(), [](const std::unique_ptr<Client>& client) { return client->connection->hasTimedOut(); }), _clients.end()); } void NetworkServer::sendPings() { auto now = Platform::getTime(); if (now - _lastPing > kPingInterval) { _lastPing = now; auto& gameState = getGameState(); PingPacket packet; packet.gameCommandIndex = _gameCommandIndex; packet.tick = gameState.scenarioTicks; packet.srand0 = gameState.rng.srand_0(); packet.srand1 = gameState.rng.srand_1(); for (auto& client : _clients) { client->connection->sendPacket(packet); } } } void NetworkServer::sendChatMessages() { std::unique_lock<std::mutex> lk(_chatMessageQueueSync); while (!_chatMessageQueue.empty()) { const auto& message = _chatMessageQueue.front(); Network::receiveChatMessage(message.sender, message.message); ReceiveChatMessage packet; packet.sender = message.sender; packet.length = static_cast<uint16_t>(message.message.size() + 1); std::memcpy(packet.text, message.message.data(), message.message.size()); sendPacketToAll(packet); _chatMessageQueue.pop(); } } void NetworkServer::processIncomingConnections() { std::unique_lock<std::mutex> lk(_incomingConnectionsSync); for (auto& conn : _incomingConnections) { // The connect packet should be the first one while (auto packet = conn->takeNextPacket()) { if (auto connectPacket = packet->as<PacketKind::connect, ConnectPacket>()) { createNewClient(std::move(conn), *connectPacket); break; } } } _incomingConnections.clear(); } void NetworkServer::processPackets() { for (auto& client : _clients) { while (auto packet = client->connection->takeNextPacket()) { onReceivePacketFromClient(*client, *packet); } } } void NetworkServer::onUpdate() { processIncomingConnections(); processPackets(); updateClients(); sendChatMessages(); sendPings(); removedTimedOutClients(); } void NetworkServer::updateClients() { for (auto& client : _clients) { client->connection->update(); } } void NetworkServer::sendChatMessage(std::string_view message) { std::unique_lock<std::mutex> lk(_chatMessageQueueSync); _chatMessageQueue.push({ 0, std::string(message) }); } void NetworkServer::sendGameCommand(uint32_t index, uint32_t tick, CompanyId company, const OpenLoco::Interop::registers& regs) { GameCommandPacket packet; packet.index = index; packet.tick = tick; packet.company = company; packet.regs = regs; sendPacketToAll(packet); } void NetworkServer::queueGameCommand(CompanyId company, const OpenLoco::Interop::registers& regs) { GameCommandPacket newPacket; newPacket.index = ++_gameCommandIndex; newPacket.tick = 0; newPacket.company = company; newPacket.regs = regs; _gameCommands.push(newPacket); } void NetworkServer::runGameCommands() { auto& gameState = getGameState(); auto tick = gameState.scenarioTicks; // Execute all following commands if previously received while (!_gameCommands.empty()) { auto& gc = _gameCommands.front(); [[maybe_unused]] auto result = GameCommands::doCommandForReal(static_cast<GameCommands::GameCommand>(gc.regs.esi), gc.company, gc.regs); // TODO We can't do this, we have to send a dummy command to the clients // otherwise we skip a game command index // if (result != 0x80000000) // { sendGameCommand(gc.index, tick, gc.company, gc.regs); // } _gameCommands.pop(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/NetworkServer.h ```h #pragma once #include "Network.h" #include "NetworkBase.h" #include "NetworkConnection.h" #include "Socket.h" #include <mutex> namespace OpenLoco::Network { class NetworkConnection; struct Client { client_id_t id{}; std::unique_ptr<NetworkConnection> connection; std::string name; }; struct ChatMessage { client_id_t sender; std::string message; }; class NetworkServer : public NetworkBase { private: std::mutex _incomingConnectionsSync; std::mutex _chatMessageQueueSync; std::vector<std::unique_ptr<NetworkConnection>> _incomingConnections; std::vector<std::unique_ptr<Client>> _clients; std::queue<ChatMessage> _chatMessageQueue; client_id_t _nextClientId = 1; uint32_t _lastPing{}; uint32_t _gameCommandIndex{}; std::queue<GameCommandPacket> _gameCommands; Client* findClient(const INetworkEndpoint& endpoint); void createNewClient(std::unique_ptr<NetworkConnection> conn, const ConnectPacket& packet); void onReceivePacketFromClient(Client& client, const Packet& packet); void onReceiveStateRequestPacket(Client& client, const RequestStatePacket& packet); void onReceiveSendChatMessagePacket(Client& client, const SendChatMessage& packet); void onReceiveGameCommandPacket(Client& client, const GameCommandPacket& packet); void removedTimedOutClients(); void sendPings(); void sendChatMessages(); void processIncomingConnections(); void processPackets(); void updateClients(); template<typename T> void sendPacketToAll(const T& packet) { for (auto& client : _clients) { client->connection->sendPacket(packet); } } protected: void onClose() override; void onReceivePacket(IUdpSocket& socket, std::unique_ptr<INetworkEndpoint> endpoint, const Packet& packet) override; void onUpdate() override; public: ~NetworkServer() override; void listen(const std::string& bind, port_t port); void sendChatMessage(std::string_view message) override; void sendGameCommand(uint32_t index, uint32_t tick, CompanyId company, const OpenLoco::Interop::registers& regs); void queueGameCommand(CompanyId company, const OpenLoco::Interop::registers& regs); void runGameCommands(); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/Packet.h ```h #pragma once #include <cstdint> #include <cstdlib> #include <string_view> #include "Network.h" #include <OpenLoco/Interop/Interop.hpp> namespace OpenLoco::Network { using sequence_t = uint16_t; #pragma pack(push, 1) enum class PacketKind : uint16_t { unknown, ack, ping, connect, connectResponse, requestState, requestStateResponse, requestStateResponseChunk, sendChatMessage, receiveChatMessage, gameCommand, }; struct PacketHeader { PacketKind kind{}; sequence_t sequence{}; uint16_t dataSize{}; }; constexpr uint16_t kMaxPacketDataSize = kMaxPacketSize - sizeof(PacketHeader); struct Packet { PacketHeader header; uint8_t data[kMaxPacketDataSize]{}; template<typename T> const T* cast() const { return reinterpret_cast<const T*>(data); } template<PacketKind TKind, typename T> const T* as() const { if (header.kind == TKind && header.dataSize >= sizeof(T)) { return cast<T>(); } return nullptr; } }; struct PingPacket { static constexpr PacketKind kind = PacketKind::ping; size_t size() const { return sizeof(PingPacket); } uint32_t gameCommandIndex{}; uint32_t tick{}; uint32_t srand0{}; uint32_t srand1{}; }; struct ConnectPacket { static constexpr PacketKind kind = PacketKind::connect; size_t size() const { return sizeof(ConnectPacket); } uint16_t version{}; char name[32]{}; }; enum class ConnectionResult { success, error, }; struct ConnectResponsePacket { static constexpr PacketKind kind = PacketKind::connectResponse; size_t size() const { return sizeof(ConnectResponsePacket); } ConnectionResult result; char message[256]{}; }; struct RequestStatePacket { static constexpr PacketKind kind = PacketKind::requestState; size_t size() const { return sizeof(RequestStatePacket); } uint32_t cookie{}; }; struct RequestStateResponse { static constexpr PacketKind kind = PacketKind::requestStateResponse; size_t size() const { return sizeof(RequestStateResponse); } uint32_t cookie{}; uint32_t totalSize{}; uint16_t numChunks{}; }; struct RequestStateResponseChunk { static constexpr PacketKind kind = PacketKind::requestStateResponseChunk; size_t size() const { return reinterpret_cast<size_t>(this->data + dataSize) - reinterpret_cast<size_t>(this); } uint32_t cookie{}; uint16_t index{}; uint32_t offset{}; uint32_t dataSize{}; uint8_t data[kMaxPacketDataSize - 14]{}; }; static_assert(sizeof(RequestStateResponseChunk) == kMaxPacketDataSize); /** * Extra state on top of S5 that we want to send over network */ struct ExtraState { uint32_t gameCommandIndex{}; uint32_t tick; }; struct SendChatMessage { static constexpr PacketKind kind = PacketKind::sendChatMessage; size_t size() const { return reinterpret_cast<size_t>(this->text + length) - reinterpret_cast<size_t>(this); } uint16_t length{}; char text[2048]{}; std::string_view getText() const { return std::string_view(text, length); } }; static_assert(sizeof(SendChatMessage) <= kMaxPacketDataSize); struct ReceiveChatMessage { static constexpr PacketKind kind = PacketKind::receiveChatMessage; size_t size() const { return reinterpret_cast<size_t>(this->text + length) - reinterpret_cast<size_t>(this); } client_id_t sender{}; uint16_t length{}; char text[2048]{}; std::string_view getText() const { return std::string_view(text, length); } }; static_assert(sizeof(SendChatMessage) <= kMaxPacketDataSize); struct GameCommandPacket { static constexpr PacketKind kind = PacketKind::gameCommand; size_t size() const { return sizeof(GameCommandPacket); } uint32_t index{}; uint32_t tick{}; CompanyId company{}; OpenLoco::Interop::registers regs; }; #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/Socket.cpp ```cpp #include <OpenLoco/Core/Exception.hpp> #include <atomic> #include <cassert> #include <chrono> #include <cmath> #include <cstring> #include <future> #include <string> #include <thread> // clang-format off // MSVC: include <math.h> here otherwise PI gets defined twice #include <cmath> #ifdef _WIN32 #pragma comment(lib, "Ws2_32.lib") // winsock2 must be included before windows.h #include <winsock2.h> #include <ws2tcpip.h> #define LAST_SOCKET_ERROR() WSAGetLastError() #undef EWOULDBLOCK #define EWOULDBLOCK WSAEWOULDBLOCK #ifndef SHUT_RD #define SHUT_RD SD_RECEIVE #endif #ifndef SHUT_WR #define SHUT_WR SD_SEND #endif #ifndef SHUT_RDWR #define SHUT_RDWR SD_BOTH #endif #define FLAG_NO_PIPE 0 #else #include <arpa/inet.h> #include <cerrno> #include <fcntl.h> #include <net/if.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/ioctl.h> #include <sys/socket.h> #include <unistd.h> using SOCKET = int32_t; #define SOCKET_ERROR -1 #define INVALID_SOCKET -1 #define LAST_SOCKET_ERROR() errno #define closesocket ::close #define ioctlsocket ioctl #if defined(__linux__) #define FLAG_NO_PIPE MSG_NOSIGNAL #else #define FLAG_NO_PIPE 0 #endif // defined(__linux__) #endif // _WIN32 // clang-format on #include "Socket.h" #include <OpenLoco/Diagnostics/Logging.h> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Network { // RAII WSA initialisation needed for Windows #ifdef _WIN32 class WSA { private: bool _isInitialised{}; public: bool isInitialised() const { return _isInitialised; } bool initialise() { if (!_isInitialised) { Logging::verbose("WSAStartup()"); WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) { Logging::error("Unable to initialise winsock."); return false; } _isInitialised = true; } return true; } ~WSA() { if (_isInitialised) { Logging::verbose("WSACleanup()"); WSACleanup(); _isInitialised = false; } } }; static bool initialiseWSA() { static WSA wsa; return wsa.initialise(); } #else static bool initialiseWSA() { return true; } #endif class SocketException : public std::runtime_error { public: explicit SocketException(const std::string& message) : std::runtime_error(message) { } }; class NetworkEndpoint final : public INetworkEndpoint { private: union { sockaddr _address; sockaddr_in _address4; sockaddr_in6 _address6; }; socklen_t _addressLen{}; public: NetworkEndpoint() { } NetworkEndpoint(const sockaddr* address, socklen_t addressLen) { std::memcpy(&_address, address, addressLen); _addressLen = addressLen; } NetworkEndpoint(const sockaddr_storage* address, socklen_t addressLen) : NetworkEndpoint(reinterpret_cast<const sockaddr*>(address), addressLen) { } const sockaddr& getAddress() const { return _address; } socklen_t getAddressLen() const { return _addressLen; } int32_t getPort() const { return _address.sa_family == AF_INET6 ? _address6.sin6_port : _address4.sin_port; } Protocol getProtocol() const override { switch (_address.sa_family) { case AF_INET: return Protocol::ipv4; case AF_INET6: return Protocol::ipv6; default: throw Exception::InvalidArgument("Unknown protocol"); } } std::string getIpAddress() const override { char buffer[256]{}; switch (_address.sa_family) { case AF_INET: inet_ntop(AF_INET, &_address4.sin_addr, buffer, sizeof(buffer)); break; case AF_INET6: inet_ntop(AF_INET6, &_address6.sin6_addr, buffer, sizeof(buffer)); break; } return buffer; } std::string getHostname() const override { char hostname[256]{}; int res = getnameinfo(&_address, _addressLen, hostname, sizeof(hostname), nullptr, 0, NI_NUMERICHOST); if (res == 0) { return hostname; } return {}; } std::unique_ptr<INetworkEndpoint> clone() const override { return std::make_unique<NetworkEndpoint>(*this); } bool equals(const INetworkEndpoint& other) const override { auto& other2 = *static_cast<const NetworkEndpoint*>(&other); return compareSockets(&_address, &other2._address) == 0; } private: #if defined(__MINGW32__) static const char* inet_ntop(int af, const void* src, char* dst, socklen_t len) { if (af == AF_INET) { struct sockaddr_in in; std::memset(&in, 0, sizeof(in)); in.sin_family = AF_INET; std::memcpy(&in.sin_addr, src, sizeof(in_addr)); getnameinfo(reinterpret_cast<sockaddr*>(&in), sizeof(sockaddr_in), dst, len, NULL, 0, NI_NUMERICHOST); return dst; } else if (af == AF_INET6) { struct sockaddr_in6 in; std::memset(&in, 0, sizeof(in)); in.sin6_family = AF_INET6; std::memcpy(&in.sin6_addr, src, sizeof(in_addr6)); getnameinfo(reinterpret_cast<sockaddr*>(&in), sizeof(sockaddr_in6), dst, len, NULL, 0, NI_NUMERICHOST); return dst; } else { throw Exception::InvalidArgument("Invalid protocol"); } } #endif static int compareSockets(const sockaddr* x, const sockaddr* y) { #define CMP(a, b) \ if (a != b) \ return a < b ? -1 : 1 CMP(x->sa_family, y->sa_family); if (x->sa_family == AF_INET) { const sockaddr_in *xin = (const sockaddr_in*)x, *yin = (const sockaddr_in*)y; CMP(ntohl(xin->sin_addr.s_addr), ntohl(yin->sin_addr.s_addr)); CMP(ntohs(xin->sin_port), ntohs(yin->sin_port)); } else if (x->sa_family == AF_INET6) { const sockaddr_in6 *xin6 = (const sockaddr_in6*)x, *yin6 = (const sockaddr_in6*)y; int r = memcmp(xin6->sin6_addr.s6_addr, yin6->sin6_addr.s6_addr, sizeof(xin6->sin6_addr.s6_addr)); if (r != 0) { return r; } CMP(ntohs(xin6->sin6_port), ntohs(yin6->sin6_port)); CMP(xin6->sin6_flowinfo, yin6->sin6_flowinfo); CMP(xin6->sin6_scope_id, yin6->sin6_scope_id); } else { return -1; } #undef CMP return 0; } }; class BaseSocket { protected: static bool setNonBlocking(SOCKET socket, bool on) { #ifdef _WIN32 u_long nonBlocking = on; return ioctlsocket(socket, FIONBIO, &nonBlocking) == 0; #else int32_t flags = fcntl(socket, F_GETFL, 0); return fcntl(socket, F_SETFL, on ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK)) == 0; #endif } static bool setOption(SOCKET socket, int32_t a, int32_t b, bool value) { int32_t ivalue = value ? 1 : 0; return setsockopt(socket, a, b, reinterpret_cast<const char*>(&ivalue), sizeof(ivalue)) == 0; } static int protocolToFamily(Protocol protocol) { switch (protocol) { case Protocol::ipv4: return AF_INET; case Protocol::ipv6: return AF_INET6; case Protocol::any: return AF_UNSPEC; default: throw Exception::InvalidArgument("Invalid protocol"); } } public: static void resolveAddress( Protocol protocol, const std::string& address, uint16_t port, sockaddr_storage* ss, socklen_t* ss_len) { std::string error; if (protocol == Protocol::any) { // Prioritise resolving IPv4 addresses if (tryResolveAddress(Protocol::ipv4, address, port, ss, ss_len, error)) { return; } if (tryResolveAddress(Protocol::ipv6, address, port, ss, ss_len, error)) { return; } } else { if (tryResolveAddress(protocol, address, port, ss, ss_len, error)) { return; } } throw SocketException(error); } private: static bool tryResolveAddress(Protocol protocol, const std::string& address, uint16_t port, sockaddr_storage* ss, socklen_t* ss_len, std::string& outError) { std::string serviceName = std::to_string(port); addrinfo hints = {}; hints.ai_family = protocolToFamily(protocol); if (address.empty()) { hints.ai_flags = AI_PASSIVE; } addrinfo* result = nullptr; int errorcode = getaddrinfo(address.empty() ? nullptr : address.c_str(), serviceName.c_str(), &hints, &result); if (errorcode != 0) { auto msg = gai_strerror(errorcode); outError = "Unable to resolve address: " + std::to_string(errorcode) + " " + msg; return false; } if (result == nullptr) { outError = "Unable to resolve address"; return false; } std::memcpy(ss, result->ai_addr, result->ai_addrlen); *ss_len = static_cast<socklen_t>(result->ai_addrlen); freeaddrinfo(result); return true; } }; class UdpSocket final : public IUdpSocket, protected BaseSocket { private: SocketStatus _status = SocketStatus::closed; sockaddr_storage _listeningAddress{}; socklen_t _listeningAddressLen; uint16_t _listeningPort = 0; SOCKET _socket = INVALID_SOCKET; NetworkEndpoint _endpoint; std::string _hostName; std::string _error; public: UdpSocket() = default; ~UdpSocket() override { closeSocket(); } SocketStatus getStatus() const override { return _status; } const char* getError() const override { return _error.empty() ? nullptr : _error.c_str(); } void listen(Protocol protocol, uint16_t port) override { listen(protocol, "", port); } void listen(Protocol protocol, const std::string& address, uint16_t port) override { if (_status != SocketStatus::closed) { throw Exception::InvalidArgument("Socket not closed."); } sockaddr_storage ss{}; socklen_t ssLen; resolveAddress(protocol, address, port, &ss, &ssLen); // Create the listening socket _socket = createSocket(protocol); try { // Bind to address:port and listen if (bind(_socket, reinterpret_cast<sockaddr*>(&ss), ssLen) != 0) { throw SocketException("Unable to bind to socket."); } } catch (const std::exception&) { closeSocket(); throw; } _listeningAddress = ss; _listeningAddressLen = ssLen; _listeningPort = port; _status = SocketStatus::listening; } size_t sendData(Protocol protocol, const std::string& address, uint16_t port, const void* buffer, size_t size) override { sockaddr_storage ss{}; socklen_t ssLen; resolveAddress(protocol, address, port, &ss, &ssLen); NetworkEndpoint endpoint(reinterpret_cast<const sockaddr*>(&ss), ssLen); return sendData(endpoint, buffer, size); } size_t sendData(const INetworkEndpoint& destination, const void* buffer, size_t size) override { if (_socket == INVALID_SOCKET) { _socket = createSocket(destination.getProtocol()); } const auto& dest = dynamic_cast<const NetworkEndpoint*>(&destination); if (dest == nullptr) { throw Exception::InvalidArgument("destination is not compatible."); } auto ss = &dest->getAddress(); auto ss_len = dest->getAddressLen(); if (_status != SocketStatus::listening) { _endpoint = *dest; } size_t totalSent = 0; do { const char* bufferStart = static_cast<const char*>(buffer) + totalSent; size_t remainingSize = size - totalSent; int32_t sentBytes = sendto( _socket, bufferStart, static_cast<int32_t>(remainingSize), FLAG_NO_PIPE, ss, ss_len); if (sentBytes == SOCKET_ERROR) { return totalSent; } totalSent += sentBytes; } while (totalSent < size); return totalSent; } NetworkReadPacket receiveData( void* buffer, size_t size, size_t* sizeReceived, std::unique_ptr<INetworkEndpoint>* sender) override { sockaddr_in6 senderAddr{}; socklen_t senderAddrLen = sizeof(sockaddr_in); if (_status != SocketStatus::listening) { senderAddrLen = _endpoint.getAddressLen(); std::memcpy(&senderAddr, &_endpoint.getAddress(), senderAddrLen); } auto readBytes = recvfrom( _socket, static_cast<char*>(buffer), static_cast<int32_t>(size), 0, reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen); if (readBytes <= 0) { *sizeReceived = 0; return NetworkReadPacket::noData; } *sizeReceived = readBytes; if (sender != nullptr) { *sender = std::make_unique<NetworkEndpoint>(reinterpret_cast<sockaddr*>(&senderAddr), senderAddrLen); } return NetworkReadPacket::success; } void close() override { closeSocket(); } const char* getHostName() const override { return _hostName.empty() ? nullptr : _hostName.c_str(); } Protocol getProtocol() const override { NetworkEndpoint endpoint(&_listeningAddress, _listeningAddressLen); return endpoint.getProtocol(); } std::string getIpAddress() const override { NetworkEndpoint endpoint(&_listeningAddress, _listeningAddressLen); return endpoint.getIpAddress(); } private: explicit UdpSocket(SOCKET socket, const std::string& hostName) : _status(SocketStatus::connected) , _socket(socket) , _hostName(hostName) { } SOCKET createSocket(Protocol protocol) { auto family = protocolToFamily(protocol); if (protocol == Protocol::any) { family = AF_INET6; } auto sock = socket(family, SOCK_DGRAM, IPPROTO_UDP); if (sock == INVALID_SOCKET) { throw SocketException("Unable to create socket."); } // Enable send and receiving of broadcast messages // if (!setOption(sock, SOL_SOCKET, SO_BROADCAST, true)) // { // Console::logVerbose("setsockopt(socket, SO_BROADCAST) failed: %d", LAST_SOCKET_ERROR()); // } if (protocol == Protocol::any) { // Turn off IPV6_V6ONLY so we can accept both v4 and v6 connections // Incoming IPv4 addresses will be mapped to IPv6 addresses if (!setOption(sock, IPPROTO_IPV6, IPV6_V6ONLY, false)) { Logging::warn("setsockopt(socket, IPV6_V6ONLY) failed: {}", LAST_SOCKET_ERROR()); } } else if (protocol == Protocol::ipv6) { // Turn on IPV6_V6ONLY so we only accept both v6 connections if (!setOption(sock, IPPROTO_IPV6, IPV6_V6ONLY, true)) { Logging::warn("setsockopt(socket, IPV6_V6ONLY) failed: {}", LAST_SOCKET_ERROR()); } } if (!setOption(sock, SOL_SOCKET, SO_REUSEADDR, true)) { Logging::warn("setsockopt(socket, SO_REUSEADDR) failed: {}", LAST_SOCKET_ERROR()); } if (!setNonBlocking(sock, true)) { throw SocketException("Failed to set non-blocking mode."); } return sock; } void closeSocket() { if (_socket != INVALID_SOCKET) { closesocket(_socket); _socket = INVALID_SOCKET; } _status = SocketStatus::closed; } }; namespace Socket { std::unique_ptr<IUdpSocket> createUdp() { initialiseWSA(); return std::make_unique<UdpSocket>(); } std::unique_ptr<INetworkEndpoint> resolve(Protocol protocol, const std::string& address, uint16_t port) { initialiseWSA(); sockaddr_storage ss{}; socklen_t ssLen; BaseSocket::resolveAddress(protocol, address, port, &ss, &ssLen); return std::make_unique<NetworkEndpoint>(reinterpret_cast<const sockaddr*>(&ss), ssLen); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Network/Socket.h ```h #pragma once #include <memory> #include <string> #include <vector> namespace OpenLoco::Network { enum class Protocol { any, ipv4, ipv6 }; enum class SocketStatus { closed, waiting, resolving, connecting, connected, listening, }; enum class NetworkReadPacket : int32_t { success, noData, moreData, disconnected }; /** * Represents an address and port. */ struct INetworkEndpoint { virtual ~INetworkEndpoint() { } virtual Protocol getProtocol() const = 0; virtual std::string getIpAddress() const = 0; virtual std::string getHostname() const = 0; virtual std::unique_ptr<INetworkEndpoint> clone() const = 0; virtual bool equals(const INetworkEndpoint& other) const = 0; }; /** * Represents a UDP socket / listener. */ struct IUdpSocket { public: virtual ~IUdpSocket() = default; virtual SocketStatus getStatus() const = 0; virtual const char* getError() const = 0; virtual const char* getHostName() const = 0; virtual Protocol getProtocol() const = 0; virtual std::string getIpAddress() const = 0; virtual void listen(Protocol procotol, uint16_t port) = 0; virtual void listen(Protocol procotol, const std::string& address, uint16_t port) = 0; virtual size_t sendData(Protocol protocol, const std::string& address, uint16_t port, const void* buffer, size_t size) = 0; virtual size_t sendData(const INetworkEndpoint& destination, const void* buffer, size_t size) = 0; virtual NetworkReadPacket receiveData( void* buffer, size_t size, size_t* sizeReceived, std::unique_ptr<INetworkEndpoint>* sender) = 0; virtual void close() = 0; }; namespace Socket { [[nodiscard]] std::unique_ptr<IUdpSocket> createUdp(); std::unique_ptr<INetworkEndpoint> resolve(Protocol protocol, const std::string& address, uint16_t port); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Engine/Limits.h ```h #pragma once #include "S5/Limits.h" namespace OpenLoco::Limits { using namespace OpenLoco::S5::Limits; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Company.cpp ```cpp #include "Company.h" #include "CompanyManager.h" #include "Date.h" #include "Economy/Economy.h" #include "Entities/EntityManager.h" #include "GameCommands/Company/ChangeLoan.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Vehicles/VehicleChangeRunningMode.h" #include "GameState.h" #include "Graphics/Gfx.h" #include "IndustryManager.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "MessageManager.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "StationManager.h" #include "TownManager.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "ViewportManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Bound.hpp> #include <algorithm> #include <array> #include <map> #include <sfl/static_unordered_set.hpp> using namespace OpenLoco::Interop; namespace OpenLoco { bool Company::empty() const { return name == StringIds::empty; } // 0x00437ED0 void Company::recalculateTransportCounts() { // Reset all counts to 0 for (auto& count : transportTypeCount) { count = 0; } auto companyId = id(); for (auto* v : VehicleManager::VehicleList()) { if (v->owner == companyId) { transportTypeCount[enumValue(v->vehicleType)]++; } } Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(companyId)); } void Company::clearOwnerStatusForDeletedVehicle(EntityId vehicleId) { // Prevent any possible owner status with a dangling reference to a deleted vehicle if (ownerStatus.isEntity() && ownerStatus.getEntity() == vehicleId) { ownerStatus = OwnerStatus(); } } // 0x00437FC5 void Company::updateDaily() { updateOwnerEmotion(); for (auto& emotionDuration : activeEmotions) { emotionDuration = Math::Bound::sub(emotionDuration, 1u); } updateDailyLogic(); observationTimeout = Math::Bound::sub(observationTimeout, 1u); if (jailStatus != 0) { jailStatus = Math::Bound::sub(jailStatus, 1u); if (jailStatus == 0) { Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(id())); Ui::WindowManager::invalidate(Ui::WindowType::news); Ui::WindowManager::invalidate(Ui::WindowType(0x2E)); } } if (CompanyManager::isPlayerCompany(id())) { updateDailyPlayer(); } if (CompanyManager::getControllingId() == id()) { updateDailyControllingPlayer(); } } // 0x00438205 void Company::updateDailyLogic() { if (CompanyManager::isPlayerCompany(id())) { if (observationTimeout != 0) { return; } if (ownerStatus.isEmpty()) { return; } if (ownerStatus.isEntity()) { if (EntityManager::get<Vehicles::VehicleBase>(ownerStatus.getEntity()) == nullptr) { assert(EntityManager::get<Vehicles::VehicleBase>(ownerStatus.getEntity()) != nullptr); return; } Vehicles::Vehicle train(ownerStatus.getEntity()); if (train.veh2->position.x != Location::null) { companySetObservation(id(), ObservationStatus::checkingServices, train.veh2->position, train.head->id, 0xFFFFU); } } else { companySetObservation(id(), ObservationStatus::surveyingLandscape, ownerStatus.getPosition(), EntityId::null, 0xFFFFU); } } else { setAiObservation(id()); } } // 0x004387D0 void Company::updateDailyPlayer() { if (SceneManager::isEditorMode() || SceneManager::isTitleMode()) { return; } const auto newProgress = getNewChallengeProgress(); if (newProgress != challengeProgress) { challengeProgress = newProgress; Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(id())); } constexpr auto requiredFlags = CompanyFlags::challengeBeatenByOpponent | CompanyFlags::challengeCompleted | CompanyFlags::challengeFailed; if ((challengeFlags & requiredFlags) != CompanyFlags::none) { return; } evaluateChallengeProgress(); } // Split off from updateDailyPlayer void Company::evaluateChallengeProgress() { if (challengeProgress == 100) { challengeFlags |= CompanyFlags::challengeCompleted; if (CompanyManager::getControllingId() == id()) { if (CompanyManager::getSecondaryPlayerId() != CompanyId::null) { auto* secondaryPlayer = CompanyManager::get(CompanyManager::getSecondaryPlayerId()); secondaryPlayer->challengeFlags |= CompanyFlags::challengeBeatenByOpponent; Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(secondaryPlayer->id())); } MessageManager::post(MessageType::congratulationsCompleted, id(), enumValue(id()), 0xFFFF); companyEmotionEvent(id(), Emotion::happy); updateOwnerEmotion(); Ui::Windows::CompanyWindow::openChallenge(id()); Scenario::getObjectiveProgress().completedChallengeInMonths = Scenario::getObjectiveProgress().monthsInChallenge; ScenarioManager::saveNewScore(Scenario::getObjectiveProgress(), id()); } else { if (CompanyManager::getControllingId() != CompanyId::null) { auto* secondaryPlayer = CompanyManager::get(CompanyManager::getControllingId()); secondaryPlayer->challengeFlags |= CompanyFlags::challengeBeatenByOpponent; Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(secondaryPlayer->id())); } MessageManager::post(MessageType::haveBeenBeaten, id(), enumValue(id()), 0xFFFF); companyEmotionEvent(id(), Emotion::surprised); updateOwnerEmotion(); Ui::Windows::CompanyWindow::openChallenge(id()); Scenario::getObjectiveProgress().completedChallengeInMonths = Scenario::getObjectiveProgress().monthsInChallenge; } } else if (challengeProgress == 255) { challengeFlags |= CompanyFlags::challengeFailed; if (CompanyManager::getControllingId() == id()) { MessageManager::post(MessageType::failedObjectives, id(), enumValue(id()), 0xFFFF); companyEmotionEvent(id(), Emotion::dejected); updateOwnerEmotion(); Ui::Windows::CompanyWindow::openChallenge(id()); } } } // Converts performance index to rating // 0x00437D60 // input: // ax = performanceIndex // output: // ax = return value, corporate rating constexpr CorporateRating performanceToRating(int16_t performanceIndex) { return static_cast<CorporateRating>(std::min(9, performanceIndex / 100)); } static std::map<CorporateRating, StringId> _ratingNames = { { CorporateRating::platelayer, StringIds::corporate_rating_platelayer }, { CorporateRating::engineer, StringIds::corporate_rating_engineer }, { CorporateRating::trafficManager, StringIds::corporate_rating_traffic_manager }, { CorporateRating::transportCoordinator, StringIds::corporate_rating_transport_coordinator }, { CorporateRating::routeSupervisor, StringIds::corporate_rating_route_supervisor }, { CorporateRating::director, StringIds::corporate_rating_director }, { CorporateRating::chiefExecutive, StringIds::corporate_rating_chief_executive }, { CorporateRating::chairman, StringIds::corporate_rating_chairman }, { CorporateRating::president, StringIds::corporate_rating_president }, { CorporateRating::tycoon, StringIds::corporate_rating_tycoon }, }; StringId getCorporateRatingAsStringId(CorporateRating rating) { auto it = _ratingNames.find(rating); if (it != _ratingNames.end()) { return it->second; } return StringIds::corporate_rating_platelayer; } void formatPerformanceIndex(const int16_t performanceIndex, FormatArguments& args) { args.push(performanceIndex); args.push(getCorporateRatingAsStringId(performanceToRating(performanceIndex))); } // 0x004F9462 constexpr uint8_t kEmotionDurations[] = { 0, 31, 10, 7, 31, 10, 31, 31, 11, }; // 0x00437F29 // companyId: ah // emotion: al void companyEmotionEvent(CompanyId companyId, Emotion emotion) { auto company = CompanyManager::get(companyId); company->activeEmotions[enumValue(emotion)] = kEmotionDurations[enumValue(emotion)]; } static bool shouldSetObservation(Company& company, ObservationStatus status, World::Pos2 pos, EntityId entity, uint16_t object) { if (company.observationTimeout == 0) { return true; } if (status == ObservationStatus::surveyingLandscape && company.observationStatus != ObservationStatus::surveyingLandscape) { return false; } if (status != company.observationStatus) { return true; } if (pos.x != company.observationX) { return true; } if (pos.y != company.observationY) { return true; } if (object != company.observationObject) { return true; } if (entity != company.observationEntity) { return true; } return false; } // 0x00438167 void companySetObservation(CompanyId id, ObservationStatus status, World::Pos2 pos, EntityId entity, uint16_t object) { auto* company = CompanyManager::get(id); if (shouldSetObservation(*company, status, pos, entity, object)) { company->observationX = pos.x; company->observationY = pos.y; company->observationEntity = entity; company->observationObject = object; company->observationStatus = status; auto closestTown = TownManager::getClosestTownAndDensity(pos); if (closestTown.has_value()) { company->observationTownId = closestTown->first; } Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(id)); Ui::WindowManager::invalidate(Ui::WindowType::companyList); } company->observationTimeout = 5; } /* 0x004A6841 * Creates a vector of all the available rail track (trains and trams) for a company * Tram track is marked with a (1<<7) flag within the uint8_t */ AvailableTracksAndRoads companyGetAvailableRailTracks(const CompanyId id) { AvailableTracksAndRoads result; const auto* company = CompanyManager::get(id); sfl::static_unordered_set<uint8_t, Limits::kMaxTrackObjects> tracks; for (auto i = 0u; i < ObjectManager::getMaxObjects(ObjectType::vehicle); ++i) { const auto* vehObj = ObjectManager::get<VehicleObject>(i); if (vehObj == nullptr) { continue; } if (company->isVehicleIndexUnlocked(i) && vehObj->mode == TransportMode::rail) { tracks.insert(vehObj->trackType); } } std::copy_if(std::begin(tracks), std::end(tracks), std::back_inserter(result), [](uint8_t trackIdx) { const auto* trackObj = ObjectManager::get<TrackObject>(trackIdx); return !trackObj->hasFlags(TrackObjectFlags::unk_02); }); sfl::static_unordered_set<uint8_t, Limits::kMaxRoadObjects> roads; for (auto i = 0u; i < ObjectManager::getMaxObjects(ObjectType::vehicle); ++i) { const auto* vehObj = ObjectManager::get<VehicleObject>(i); if (vehObj == nullptr) { continue; } if (company->isVehicleIndexUnlocked(i) && vehObj->mode == TransportMode::road) { if (vehObj->trackType != 0xFF) { roads.insert(vehObj->trackType | (1 << 7)); } } } for (auto i = 0u; i < ObjectManager::getMaxObjects(ObjectType::road); ++i) { const auto* roadObj = ObjectManager::get<RoadObject>(i); if (roadObj == nullptr) { continue; } if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { roads.insert(i | (1 << 7)); } } std::copy_if(std::begin(roads), std::end(roads), std::back_inserter(result), [](uint8_t trackIdx) { const auto* trackObj = ObjectManager::get<RoadObject>(trackIdx & ~(1 << 7)); return trackObj->hasFlags(RoadObjectFlags::unk_01); }); return result; } /* 0x00478265 * Creates a vector of all the available road track (roads {no trams} and tracks with no rails??) for a company * Roads are marked with a (1<<7) flag within the uint8_t */ AvailableTracksAndRoads companyGetAvailableRoads(const CompanyId id) { AvailableTracksAndRoads result; const auto* company = CompanyManager::get(id); sfl::static_unordered_set<uint8_t, Limits::kMaxRoadObjects> roads; for (auto i = 0u; i < ObjectManager::getMaxObjects(ObjectType::vehicle); ++i) { const auto* vehObj = ObjectManager::get<VehicleObject>(i); if (vehObj == nullptr) { continue; } if (company->isVehicleIndexUnlocked(i) && vehObj->mode == TransportMode::road && vehObj->trackType != 0xFFU) { roads.insert(vehObj->trackType | (1U << 7)); } } for (auto i = 0u; i < ObjectManager::getMaxObjects(ObjectType::road); ++i) { const auto* roadObj = ObjectManager::get<RoadObject>(i); if (roadObj == nullptr) { continue; } if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { roads.insert(i | (1U << 7)); } } std::copy_if(std::begin(roads), std::end(roads), std::back_inserter(result), [](uint8_t roadId) { const auto* roadObj = ObjectManager::get<RoadObject>(roadId & ~(1U << 7)); return !roadObj->hasFlags(RoadObjectFlags::unk_01); }); sfl::static_unordered_set<uint8_t, Limits::kMaxTrackObjects> tracks; for (auto i = 0u; i < ObjectManager::getMaxObjects(ObjectType::vehicle); ++i) { const auto* vehObj = ObjectManager::get<VehicleObject>(i); if (vehObj == nullptr) { continue; } if (company->isVehicleIndexUnlocked(i) && vehObj->mode == TransportMode::rail) { tracks.insert(vehObj->trackType); } } std::copy_if(std::begin(tracks), std::end(tracks), std::back_inserter(result), [](uint8_t trackIdx) { const auto* trackObj = ObjectManager::get<TrackObject>(trackIdx); return trackObj->hasFlags(TrackObjectFlags::unk_02); }); return result; } // 0x004312D2 void updateYearly(Company& company) { for (auto type = 0U; type < ExpenditureType::Count; ++type) { currency32_t lastExpend = 0; for (auto i = 0U; i < kExpenditureHistoryCapacity; ++i) { std::swap(lastExpend, company.expenditures[i][type]); } } company.numExpenditureYears = std::min<uint8_t>(company.numExpenditureYears + 1, kExpenditureHistoryCapacity); } bool Company::isVehicleIndexUnlocked(const uint8_t vehicleIndex) const { return unlockedVehicles[vehicleIndex]; } // 0x00487FCC void Company::updateQuarterly() { for (auto& thought : aiThoughts) { if (thought.type == AiThoughtType::null) { continue; } thought.var_88 = std::min(0xFF, thought.var_88 + 1); thought.var_84 = thought.var_80; thought.var_80 = 0; currency32_t totalRunCost = 0; for (auto i = 0; i < thought.numVehicles; ++i) { auto* vehHead = EntityManager::get<Vehicles::VehicleHead>(thought.vehicles[i]); if (vehHead != nullptr) { totalRunCost += vehHead->calculateRunningCost(); } } thought.var_7C = totalRunCost; } } void Company::updateDailyControllingPlayer() { updateLoanAutorepay(); } // 0x0042F220 void Company::updateMonthlyHeadquarters() { setHeadquartersVariation(getHeadquarterPerformanceVariation()); } // 0x00437C8C static int16_t calculatePerformanceIndex(const Company& company) { if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { return 0; } currency32_t totalProfit = 0; for (auto head : VehicleManager::VehicleList()) { if (head->owner != company.id()) { continue; } Vehicles::Vehicle train(*head); // Unsure why >> 1, /2 // Note: To match vanilla using >> 1. Use /2 when diverging allowed. currency32_t trainProfit = train.veh2->totalRecentProfit() >> 1; if (static_cast<int64_t>(totalProfit) + trainProfit < std::numeric_limits<currency32_t>::max()) { totalProfit += trainProfit; } } totalProfit = std::max(0, totalProfit); const auto partialProfitFactor = Math::Vector::fastSquareRoot(totalProfit) * 75; const auto ecoFactor = Math::Vector::fastSquareRoot(Economy::getCurrencyMultiplicationFactor(0)); uint16_t profitFactor = 500; if (partialProfitFactor < ecoFactor * 500) { profitFactor = partialProfitFactor / ecoFactor; } const auto cargoFactor = std::min<uint16_t>(500, Math::Vector::fastSquareRoot(company.cargoUnitsDistanceHistory[0] / 4)); return profitFactor + cargoFactor; } // 0x00437D79 ProfitAndValue calculateCompanyValue(const Company& company) { if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { return { 0, 0 }; } currency48_t totalValue = company.cash; totalValue -= company.currentLoan; currency48_t totalVehicleProfit = 0; for (auto head : VehicleManager::VehicleList()) { if (head->owner != company.id()) { continue; } if (head->has38Flags(Vehicles::Flags38::isGhost)) { continue; } Vehicles::Vehicle train(*head); currency32_t trainProfit = train.veh2->totalRecentProfit(); // Unsure why >>2, /4 // Note: To match vanilla using >> 2. Use /4 when diverging allowed. totalVehicleProfit += trainProfit >> 2; totalValue += trainProfit * 8; for (auto& car : train.cars) { totalValue += car.front->refundCost; } } totalValue = std::max<currency48_t>(0, totalValue); return { totalVehicleProfit, totalValue }; } // 0x004389CC static void stopAllCompanyVehicles(const CompanyId companyId) { const auto prevUpdateCompany = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(companyId); for (auto head : VehicleManager::VehicleList()) { if (head->owner != companyId) { continue; } if (head->has38Flags(Vehicles::Flags38::isGhost)) { continue; } GameCommands::VehicleChangeRunningModeArgs args{}; args.head = head->id; args.mode = GameCommands::VehicleChangeRunningModeArgs::Mode::stopVehicle; // This used to call the command directly GameCommands::doCommand(args, GameCommands::Flags::apply); } GameCommands::setUpdatingCompanyId(prevUpdateCompany); } void Company::updateMonthly1() { std::rotate(std::begin(cargoUnitsDeliveredHistory), std::end(cargoUnitsDeliveredHistory) - 1, std::end(cargoUnitsDeliveredHistory)); cargoUnitsDeliveredHistory[0] = cargoUnitsTotalDelivered; cargoUnitsTotalDelivered = 0; std::rotate(std::begin(cargoUnitsDistanceHistory), std::end(cargoUnitsDistanceHistory) - 1, std::end(cargoUnitsDistanceHistory)); cargoUnitsDistanceHistory[0] = cargoUnitsTotalDistance; cargoUnitsTotalDistance = 0; if (historySize >= 2) { // Note: At this point cargoUnitsDeliveredHistory already has historySize + 1 // valid entries inside of it. This is why it is safe to access cargoUnitsDeliveredHistory[2] // after the if (historySize >= 2) if (cargoUnitsDeliveredHistory[0] < cargoUnitsDeliveredHistory[1] && cargoUnitsDeliveredHistory[1] < cargoUnitsDeliveredHistory[2]) { companyEmotionEvent(id(), Emotion::angry); } } const auto newPerformance = calculatePerformanceIndex(*this); challengeFlags &= ~(CompanyFlags::increasedPerformance | CompanyFlags::decreasedPerformance); if (newPerformance != performanceIndex) { if (newPerformance < performanceIndex) { challengeFlags |= CompanyFlags::decreasedPerformance; } else { challengeFlags |= CompanyFlags::increasedPerformance; } } std::rotate(std::begin(performanceIndexHistory), std::end(performanceIndexHistory) - 1, std::end(performanceIndexHistory)); performanceIndexHistory[0] = newPerformance; performanceIndex = newPerformance; const auto rating = performanceToRating(newPerformance); if (rating > currentRating) { currentRating = rating; if (CompanyManager::getControllingId() == id()) { MessageManager::post(MessageType::companyPromoted, CompanyId::null, enumValue(id()), enumValue(rating)); } } if ((challengeFlags & CompanyFlags::increasedPerformance) != CompanyFlags::none) { companyEmotionEvent(id(), Emotion::happy); } if ((challengeFlags & CompanyFlags::decreasedPerformance) != CompanyFlags::none) { companyEmotionEvent(id(), Emotion::scared); } const auto newValue = calculateCompanyValue(*this); std::rotate(std::begin(companyValueHistory), std::end(companyValueHistory) - 1, std::end(companyValueHistory)); companyValueHistory[0] = newValue.companyValue; vehicleProfit = newValue.vehicleProfit; historySize++; if (historySize > 120) { historySize = 120; } if (!CompanyManager::isPlayerCompany(id())) { // Auto pay loan while (currentLoan >= 1000) { if (cash < 1000) { break; } currentLoan -= 1000; cash -= 1000; } } const auto monthlyInterest = (currentLoan * getGameState().loanInterestRate) / 1200; CompanyManager::ensureCompanyFunding(id(), monthlyInterest + 1); CompanyManager::applyPaymentToCompany(id(), monthlyInterest, ExpenditureType::LoanInterest); if (cash <= 0) { companyEmotionEvent(id(), Emotion::worried); } if ((challengeFlags & CompanyFlags::bankrupt) == CompanyFlags::none) { if (cash < 0) { numMonthsInTheRed++; if (numMonthsInTheRed == 9) { const auto message = CompanyManager::getControllingId() == id() ? MessageType::bankruptcyDeclared : MessageType::bankruptcyDeclaredCompetitor; MessageManager::post(message, id(), enumValue(id()), 0xFFFFU); challengeFlags |= CompanyFlags::bankrupt; if ((challengeFlags & (CompanyFlags::challengeBeatenByOpponent | CompanyFlags::challengeCompleted)) == CompanyFlags::none) { challengeFlags |= CompanyFlags::challengeFailed; } companyEmotionEvent(id(), Emotion::dejected); stopAllCompanyVehicles(id()); } if (id() == CompanyManager::getControllingId()) { if (numMonthsInTheRed == 3) { MessageManager::post(MessageType::bankruptcyWarning6MonthsRemaining, id(), enumValue(id()), 0xFFFFU); companyEmotionEvent(id(), Emotion::scared); } else if (numMonthsInTheRed == 6) { MessageManager::post(MessageType::bankruptcyWarning3MonthsRemaining, id(), enumValue(id()), 0xFFFFU); companyEmotionEvent(id(), Emotion::scared); } } } else { numMonthsInTheRed = 0; } } } void Company::updateLoanAutorepay() { if (currentLoan > 0 && cash > 0 && ((challengeFlags & CompanyFlags::autopayLoan) != CompanyFlags::none)) { GameCommands::ChangeLoanArgs args{}; args.newLoan = currentLoan - std::max<currency32_t>(0, std::min<currency32_t>(currentLoan, cash.asInt64())); GameCommands::setUpdatingCompanyId(id()); GameCommands::doCommand(args, GameCommands::Flags::apply); } } // 0x004B8ED2 void Company::updateVehicleColours() { for (auto* v : VehicleManager::VehicleList()) { if (v->owner != id()) { continue; } Vehicles::Vehicle train(*v); for (auto& car : train.cars) { const auto* vehObject = car.body->getObject(); auto colour = mainColours; if (customVehicleColoursSet & (1 << vehObject->colourType)) { colour = vehicleColours[vehObject->colourType - 1]; } car.applyToComponents([colour](auto& component) { component.colourScheme = colour; }); } } Gfx::invalidateScreen(); } // 0x0042F0C1 static void updateHeadquartersColourAtTile(const World::TilePos2& pos, uint8_t zPos, Colour newColour) { auto tile = World::TileManager::get(pos); for (auto& element : tile) { if (element.baseZ() != zPos) { continue; } auto* building = element.as<World::BuildingElement>(); if (building == nullptr) { continue; } building->setColour(newColour); return; } } // 0x0042F07B void Company::updateHeadquartersColour() { if (headquartersX == -1) { return; } const auto colour = mainColours.primary; auto hqPos = World::toTileSpace(World::Pos2(headquartersX, headquartersY)); updateHeadquartersColourAtTile(hqPos + World::TilePos2(0, 0), headquartersZ, colour); updateHeadquartersColourAtTile(hqPos + World::TilePos2(1, 0), headquartersZ, colour); updateHeadquartersColourAtTile(hqPos + World::TilePos2(1, 1), headquartersZ, colour); updateHeadquartersColourAtTile(hqPos + World::TilePos2(0, 1), headquartersZ, colour); } constexpr std::array<uint8_t, 9> emotionWeightings = { 0, 4, 6, 5, 3, 8, 1, 2, 7, }; // 0x00437F47 void Company::updateOwnerEmotion() { Emotion newEmotion = Emotion::dejected; if ((challengeFlags & CompanyFlags::bankrupt) == CompanyFlags::none) { newEmotion = Emotion::neutral; uint8_t newEmotionWeight = 0; for (auto emotion = 0U; emotion < std::size(activeEmotions); ++emotion) { if (activeEmotions[emotion] == 0) { continue; } const auto emotionWeight = emotionWeightings[emotion]; if (newEmotionWeight <= emotionWeight) { newEmotionWeight = emotionWeight; newEmotion = static_cast<Emotion>(emotion); } } } if (newEmotion == ownerEmotion) { return; } ownerEmotion = newEmotion; Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(id())); if (id() == CompanyManager::getControllingId()) { Ui::WindowManager::invalidate(Ui::WindowType::playerInfoToolbar); } Ui::WindowManager::invalidate(Ui::WindowType::vehicleList, enumValue(id())); Ui::WindowManager::invalidate(Ui::WindowType::stationList, enumValue(id())); Ui::WindowManager::invalidate(Ui::WindowType::news); Ui::WindowManager::invalidate(Ui::WindowType::companyList); } // 0x0042F042 uint8_t Company::getHeadquarterPerformanceVariation() const { return std::min(performanceIndex / 200, 4); } bool Company::hashTableContains(const Unk25C0HashTableEntry& entry) const { auto index = entry.calculateHash(); while (var_25C0[index].var_00 != 0xFFFF) { auto& rhsEntry = var_25C0[index]; if (rhsEntry.getPosition() == entry.getPosition() && rhsEntry.getDirection() == entry.getDirection() && rhsEntry.getTrackRoadId() == entry.getTrackRoadId()) { return true; } if (!(rhsEntry.hasHashCollision())) { break; } index++; if (index >= std::size(var_25C0)) { index = 0; } } return false; } bool Company::addHashTableEntry(const Unk25C0HashTableEntry& entry) { if (var_25C0_length >= 2048) { return false; // Hash table is full } auto index = entry.calculateHash(); while (var_25C0[index].var_00 != 0xFFFF) { auto& rhsEntry = var_25C0[index]; rhsEntry.var_02 |= 1U << 0; // mark as hash collision index++; if (index >= std::size(var_25C0)) { index = 0; } } var_25C0[index] = entry; var_25C0_length++; return true; } // 0x0042F0FC void Company::setHeadquartersVariation(const uint8_t variation) { if (headquartersX == -1) { return; } const auto headPos = World::toTileSpace({ headquartersX, headquartersY }); for (const auto& pos : World::TilePosRangeView(headPos, headPos + World::TilePos2{ 1, 1 })) { setHeadquartersVariation(variation, pos); } } // 0x0042F142 void Company::setHeadquartersVariation(const uint8_t variation, const World::TilePos2& pos) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { continue; } if (elBuilding->baseZ() != headquartersZ) { continue; } if (elBuilding->variation() == variation) { break; } elBuilding->setVariation(variation); elBuilding->setAge(0); elBuilding->setConstructed(false); elBuilding->setUnk5u(0); Ui::ViewportManager::invalidate(World::toWorldSpace(pos), elBuilding->baseHeight(), elBuilding->clearHeight()); const auto* buildingObj = elBuilding->getObject(); auto totalHeight = 0; const auto partHeights = buildingObj->getBuildingPartHeights(); for (auto part : buildingObj->getBuildingParts(elBuilding->variation())) { totalHeight += partHeights[part]; } elBuilding->setClearZ((totalHeight / 4) + elBuilding->baseZ()); Ui::ViewportManager::invalidate(World::toWorldSpace(pos), elBuilding->baseHeight(), elBuilding->clearHeight()); break; } } // 0x00438747 static uint8_t applyBeTopProgressModifiers(const uint8_t progress, const Scenario::Objective& objective, const Company& company) { if ((objective.flags & (Scenario::ObjectiveFlags::beTopCompany | Scenario::ObjectiveFlags::beWithinTopThreeCompanies)) == Scenario::ObjectiveFlags::none) { return progress; } auto numCompaniesBetterPerforming = 0U; for (auto& otherCompany : CompanyManager::companies()) { if (otherCompany.id() == company.id()) { continue; } if (company.performanceIndex < otherCompany.performanceIndex) { numCompaniesBetterPerforming++; } } if ((objective.flags & Scenario::ObjectiveFlags::beTopCompany) != Scenario::ObjectiveFlags::none) { if (numCompaniesBetterPerforming != 0) { return std::max(progress - 10, 0); } return progress; } if ((objective.flags & Scenario::ObjectiveFlags::beWithinTopThreeCompanies) != Scenario::ObjectiveFlags::none) { if (numCompaniesBetterPerforming >= 3) { // Reduces progress by 10% for each company outside of top 3 better performing than the player // Caps out at 30% reduction const auto multiplier = std::min(numCompaniesBetterPerforming - 2, 3U); return std::max(progress - 10 * multiplier, 0U); } return progress; } return progress; } // 0x004385F6 uint8_t Company::getNewChallengeProgress() const { if ((challengeFlags & CompanyFlags::challengeCompleted) != CompanyFlags::none) { return 100; } if ((challengeFlags & (CompanyFlags::challengeFailed | CompanyFlags::challengeBeatenByOpponent)) != CompanyFlags::none) { return 255; } auto& objectiveProgress = Scenario::getObjectiveProgress(); auto& objective = Scenario::getObjective(); if ((challengeFlags & CompanyFlags::unk2) != CompanyFlags::none) { if (objectiveProgress.timeLimitUntilYear < getCurrentYear() && getCurrentMonth() != MonthId::january) { return 255; } } uint8_t progress = 0U; switch (objective.type) { case Scenario::ObjectiveType::companyValue: { const auto curMonthValue = companyValueHistory[0]; if (curMonthValue >= currency32_t(objective.companyValue)) { return 100; } return curMonthValue.asInt64() / (objective.companyValue / 100); } case Scenario::ObjectiveType::vehicleProfit: { if (vehicleProfit <= 0) { return 0; } if (vehicleProfit >= currency32_t(objective.monthlyVehicleProfit)) { progress = 100; break; } progress = vehicleProfit.asInt64() / (objective.monthlyVehicleProfit / 100); break; } case Scenario::ObjectiveType::performanceIndex: { if (objective.performanceIndex * 10 <= performanceIndex) { progress = 100; break; } progress = (performanceIndex * 10) / objective.performanceIndex; break; } case Scenario::ObjectiveType::cargoDelivery: { if (objective.deliveredCargoType == 0xFFU) { return 0; } auto* cargoObj = ObjectManager::get<CargoObject>(objective.deliveredCargoType); if (cargoObj == nullptr) { return 0; } const auto cargoQty = cargoDelivered[objective.deliveredCargoType]; if (cargoQty >= objective.deliveredCargoAmount) { progress = 100; break; } progress = cargoQty / (objective.deliveredCargoAmount / 100); break; } } return applyBeTopProgressModifiers(progress, objective, *this); } Company::Unk25C0HashTableEntry::Unk25C0HashTableEntry(World::Pos3 pos, uint8_t trackRoadId, uint8_t direction) { var_00 = pos.x; var_02 = pos.y; var_04 = pos.z / World::kSmallZStep; var_05 = (trackRoadId & 0x3F) | (direction << 6); } constexpr uint16_t Company::Unk25C0HashTableEntry::calculateHash() const { const auto direction = getDirection(); const auto pos = getPosition(); const auto trackRoadId = getTrackRoadId(); const auto hash1 = direction ^ ((pos.z / World::kSmallZStep) & 0xFF); const auto hash2 = hash1 ^ ((pos.x / 32) * 8); const auto hash3 = hash2 ^ (pos.y / 32); const auto hash4 = hash3 ^ (trackRoadId * 64); return hash4 & 0xFFFU; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Company.h ```h #pragma once #include "CompanyAi/CompanyAi.h" #include "Economy/Currency.h" #include "Economy/Expenditures.h" #include "Engine/Limits.h" #include "Types.hpp" #include <OpenLoco/Core/BitSet.hpp> #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/World.hpp> #include <cstddef> #include <cstdint> #include <limits> #include <sfl/static_vector.hpp> #include <vector> namespace OpenLoco { enum class CompanyFlags : uint32_t { none = 0U, unk0 = (1U << 0), // 0x01 unk1 = (1U << 1), // 0x02 unk2 = (1U << 2), // 0x04 sorted = (1U << 3), // 0x08 increasedPerformance = (1U << 4), // 0x10 decreasedPerformance = (1U << 5), // 0x20 challengeCompleted = (1U << 6), // 0x40 challengeFailed = (1U << 7), // 0x80 challengeBeatenByOpponent = (1U << 8), // 0x100 bankrupt = (1U << 9), // 0x200 autopayLoan = (1U << 31), // 0x80000000 new for OpenLoco }; OPENLOCO_ENABLE_ENUM_OPERATORS(CompanyFlags); enum class AiPlaystyleFlags : uint32_t { none = 0U, unk0 = (1U << 0), // 0x01 unk1 = (1U << 1), // 0x02 unk2 = (1U << 2), // 0x04 unk3 = (1U << 3), // 0x08 noAir = (1U << 4), // 0x10 noWater = (1U << 5), // 0x20 unk6 = (1U << 6), // 0x40 unk7 = (1U << 7), // 0x80 townIdSet = (1U << 8), // 0x100 }; OPENLOCO_ENABLE_ENUM_OPERATORS(AiPlaystyleFlags); enum class CorporateRating : uint8_t { platelayer, // 0 - 9.9% engineer, // 10 - 19.9% trafficManager, // 20 - 29.9% transportCoordinator, // 30 - 39.9% routeSupervisor, // 40 - 49.9% director, // 50 - 59.9% chiefExecutive, // 60 - 69.9% chairman, // 70 - 79.9% president, // 80 - 89.9% tycoon // 90 - 100% }; enum ObservationStatus : uint8_t { empty, buildingTrackRoad, buildingAirport, buildingDock, checkingServices, surveyingLandscape, }; enum class Emotion : uint8_t { neutral, happy, worried, thinking, dejected, surprised, scared, angry, disgusted, }; class OwnerStatus { int16_t data[2]; public: OwnerStatus() { data[0] = -1; data[1] = 0; } OwnerStatus(EntityId id) { data[0] = -2; data[1] = enumValue(id); } OwnerStatus(const World::Pos2& pos) { data[0] = pos.x; data[1] = pos.y; } OwnerStatus(int16_t ax, int16_t cx) { data[0] = ax; data[1] = cx; } void getData(int16_t* res) const { res[0] = data[0]; res[1] = data[1]; } bool isEmpty() const { return data[0] == -1; } bool isEntity() const { return data[0] == -2; } EntityId getEntity() const { if (isEntity()) { return static_cast<EntityId>(data[1]); } return EntityId::null; } World::Pos2 getPosition() const { if (isEntity()) { return {}; } return World::Pos2{ data[0], data[1] }; } }; void formatPerformanceIndex(const int16_t performanceIndex, FormatArguments& args); constexpr size_t kExpenditureHistoryCapacity = 16; #pragma pack(push, 1) struct Company { struct Unk25C0HashTableEntry { uint16_t var_00; // x uint16_t var_02; // y + flags uint8_t var_04; // z uint8_t var_05; // trackId | (direction << 6) Unk25C0HashTableEntry() = default; Unk25C0HashTableEntry(World::Pos3 pos, uint8_t trackRoadId, uint8_t direction); constexpr World::Pos3 getPosition() const { return World::Pos3(var_00, var_02 & 0xFFFE, var_04 * 4 /*World::kSmallZStep*/); } constexpr uint8_t getTrackRoadId() const { return var_05 & 0x3F; } constexpr uint8_t getDirection() const { return (var_05 >> 6) & 0x03; } // When looking up the hash table entry if there is a hash collision check the next entries in // the table as well for matches until no hash collision or match is found constexpr bool hasHashCollision() const { return (var_02 & (1U << 0)) != 0; } constexpr uint16_t calculateHash() const; }; StringId name; StringId ownerName; CompanyFlags challengeFlags; // 0x04 currency48_t cash; // 0x08 currency32_t currentLoan; // 0x0E uint32_t updateCounter; // 0x12 int16_t performanceIndex; // 0x16 uint8_t competitorId; // 0x18 Emotion ownerEmotion; // 0x19 ColourScheme mainColours; // 0x1A ColourScheme vehicleColours[10]; // 0x1C uint32_t customVehicleColoursSet; // 0x30 BitSet<224> unlockedVehicles; // 0x34 uint16_t availableVehicles; // 0x50 AiPlaystyleFlags aiPlaystyleFlags; // 0x52 uint8_t aiPlaystyleTownId; // 0x56 uint8_t numExpenditureYears; // 0x57 currency32_t expenditures[kExpenditureHistoryCapacity][ExpenditureType::Count]; // 0x58 uint32_t startedDate; // 0x0498 uint32_t var_49C; uint32_t var_4A0; AiThinkState var_4A4; // 0x04A4 uint8_t var_4A5; AiPlaceVehicleState var_4A6; uint8_t var_4A7; AiThought aiThoughts[kMaxAiThoughts]; // 0x04A8 uint8_t activeThoughtId; // 0x2578 World::SmallZ headquartersZ; // 0x2579 coord_t headquartersX; // 0x257A -1 on no headquarter placed coord_t headquartersY; // 0x257C union { currency32_t activeThoughtRevenueEstimate; // 0x257E Also used for thoughtState2AiStationIdx in sub_430CEC TODO: Don't do this uint32_t thoughtState2AiStationIdx; // 0x257E Also used mostly for activeThoughtRevenueEstimate TODO: Don't do this }; uint32_t var_2582; uint8_t pad_2586[0x2596 - 0x2586]; uint32_t var_2596; uint8_t var_259A; uint8_t var_259B; uint8_t var_259C; uint8_t pad_259D; uint32_t aiPlaceVehicleIndex; uint8_t pad_25A2[0x25BE - 0x25A2]; AiThoughtType var_25BE; CorporateRating currentRating; // 0x25BF Unk25C0HashTableEntry var_25C0[0x1000]; // 0x25C0 Hash table entries uint16_t var_25C0_length; // 0x85C0 Hash table length uint8_t var_85C2; uint8_t var_85C3; World::Pos2 var_85C4; World::SmallZ var_85C8; World::Pos2 var_85C9; World::SmallZ var_85CD; uint8_t var_85CE; uint8_t var_85CF; World::Pos2 var_85D0; World::SmallZ var_85D4; uint16_t var_85D5; World::Pos2 var_85D7; World::SmallZ var_85DB; uint16_t var_85DC; uint32_t var_85DE; uint32_t var_85E2; uint16_t var_85E6; uint16_t var_85E8; uint32_t var_85EA; uint8_t var_85EE; uint8_t var_85EF; uint16_t var_85F0; currency32_t var_85F2; uint16_t var_85F6; uint32_t cargoUnitsTotalDelivered; // 0x85F8 uint32_t cargoUnitsDeliveredHistory[120]; // 0x85FC int16_t performanceIndexHistory[120]; // 0x87DC uint16_t historySize; // 0x88CC currency48_t companyValueHistory[120]; // 0x88CE currency48_t vehicleProfit; // 0x8B9E uint16_t transportTypeCount[6]; // 0x8BA4 uint8_t activeEmotions[9]; // 0x8BB0 duration in days that emotion is active 0 == not active ObservationStatus observationStatus; // 0x8BB9; TownId observationTownId; // 0x8BBA; EntityId observationEntity; // 0x8BBC; int16_t observationX; // 0x8BBE; int16_t observationY; // 0x8BC0; uint16_t observationObject; // 0x8BC2; uint16_t observationTimeout; // 0x8BC4 OwnerStatus ownerStatus; // 0x8BC6 uint8_t pad_8BCA[0x8BCE - 0x8BCA]; uint32_t cargoDelivered[32]; // 0x8BCE; uint8_t challengeProgress; // 0x8C4E - percent completed on challenge uint8_t numMonthsInTheRed; // 0x8C4F uint32_t cargoUnitsTotalDistance; // 0x8C50 uint32_t cargoUnitsDistanceHistory[120]; // 0x8C54 uint16_t jailStatus; // 0x8E34 uint8_t pad_8E36[0x8FA8 - 0x8E36]; CompanyId id() const; bool empty() const; bool isVehicleIndexUnlocked(const uint8_t vehicleIndex) const; void recalculateTransportCounts(); void clearOwnerStatusForDeletedVehicle(EntityId vehicleId); void updateDaily(); void updateDailyLogic(); void updateDailyPlayer(); void evaluateChallengeProgress(); void updateDailyControllingPlayer(); void updateMonthlyHeadquarters(); void updateMonthly1(); void updateLoanAutorepay(); void updateQuarterly(); void updateVehicleColours(); void updateHeadquartersColour(); void updateOwnerEmotion(); uint8_t getHeadquarterPerformanceVariation() const; bool hashTableContains(const Unk25C0HashTableEntry& entry) const; bool addHashTableEntry(const Unk25C0HashTableEntry& entry); private: void setHeadquartersVariation(const uint8_t variation); void setHeadquartersVariation(const uint8_t variation, const World::TilePos2& pos); uint8_t getNewChallengeProgress() const; }; #pragma pack(pop) static_assert(sizeof(Company) == 0x8FA8); static_assert(sizeof(Company::expenditures) == 0x440); static_assert(offsetof(Company, companyValueHistory[0]) == 0x88CE); static_assert(offsetof(Company, vehicleProfit) == 0x8B9E); static_assert(offsetof(Company, challengeProgress) == 0x8C4E); static_assert(offsetof(Company, activeEmotions) == 0x8BB0); StringId getCorporateRatingAsStringId(CorporateRating rating); constexpr CorporateRating performanceToRating(int16_t performanceIndex); void formatPerformanceIndex(const int16_t performanceIndex, FormatArguments& args); void companyEmotionEvent(CompanyId companyId, Emotion emotion); void companySetObservation(CompanyId id, ObservationStatus status, World::Pos2 pos, EntityId entity, uint16_t object); // This is kMaxRoadObjects + kMaxTrackObjects as tram tracks are roads but are tracks // and vice versa there was capabilities for some unknown track type to be classed as a road using AvailableTracksAndRoads = sfl::static_vector<uint8_t, Limits::kMaxRoadObjects + Limits::kMaxTrackObjects>; AvailableTracksAndRoads companyGetAvailableRailTracks(const CompanyId id); AvailableTracksAndRoads companyGetAvailableRoads(const CompanyId id); void updateYearly(Company& company); struct ProfitAndValue { currency48_t vehicleProfit; currency48_t companyValue; }; // 0x00437D79 ProfitAndValue calculateCompanyValue(const Company& company); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyManager.cpp ```cpp #include "CompanyManager.h" #include "CompanyAi/CompanyAi.h" #include "CompanyRecords.h" #include "Config.h" #include "Date.h" #include "Economy/Economy.h" #include "Effects/Effect.h" #include "Effects/MoneyEffect.h" #include "Entities/EntityManager.h" #include "GameCommands/Company/RemoveCompanyHeadquarters.h" #include "GameCommands/Company/RenameCompanyName.h" #include "GameCommands/Company/RenameCompanyOwner.h" #include "GameCommands/Company/UpdateOwnerStatus.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "GameStateFlags.h" #include "Graphics/Colour.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "MessageManager.h" #include "Objects/AirportObject.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/CompetitorObject.h" #include "Objects/DockObject.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "Scenario.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "TownManager.h" #include "Ui/Dropdown.h" #include "Ui/ViewportInteraction.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include <OpenLoco/Math/Bound.hpp> #include <array> #include <sfl/static_vector.hpp> using namespace OpenLoco::Ui; namespace OpenLoco::CompanyManager { static std::array<Colour, Limits::kMaxCompanies + 1> _companyColours; // 0x009C645C static void produceCompanies(); static auto& rawCompanies() { return getGameState().companies; } static auto& rawPlayerCompanies() { return getGameState().playerCompanies; } // 0x0042F7F8 void reset() { // First, empty all non-empty companies. for (auto& company : companies()) { company.name = StringIds::empty; } getGameState().produceAICompanyTimeout = 0; // Reset player companies depending on network mode. if (SceneManager::isNetworkHost()) { rawPlayerCompanies()[0] = CompanyId(1); rawPlayerCompanies()[1] = CompanyId(0); } else if (SceneManager::isNetworked()) { rawPlayerCompanies()[0] = CompanyId(0); rawPlayerCompanies()[1] = CompanyId(1); } else { rawPlayerCompanies()[0] = CompanyId(0); rawPlayerCompanies()[1] = CompanyId::null; } // Reset primary company colours. rawCompanies()[0].mainColours.primary = Colour::mutedSeaGreen; updateColours(); } // 0x00525FB7 uint8_t getMaxCompetingCompanies() { return getGameState().maxCompetingCompanies; } void setMaxCompetingCompanies(uint8_t competingCompanies) { getGameState().maxCompetingCompanies = competingCompanies; } // 0x00526214 uint8_t getCompetitorStartDelay() { return getGameState().competitorStartDelay; } void setCompetitorStartDelay(uint8_t competetorStartDelay) { getGameState().competitorStartDelay = competetorStartDelay; } // 0x0052621A uint16_t getMaxLoanSize() { return getGameState().maxLoanSize; } void setMaxLoanSize(uint16_t loanSize) { getGameState().maxLoanSize = loanSize; } // 0x00526218 uint16_t getStartingLoanSize() { return getGameState().startingLoanSize; } void setStartingLoanSize(uint16_t loanSize) { getGameState().startingLoanSize = loanSize; } const Records& getRecords() { return getGameState().companyRecords; } void setRecords(const Records& records) { getGameState().companyRecords = records; } void removeCompaniesRecords(CompanyId id) { auto records = getRecords(); for (auto i = 0U; i < 3; ++i) { if (records.speed[i] == kSpeedZero) { continue; } if (records.company[i] == id) { records.company[i] = CompanyId::null; } } setRecords(records); } FixedVector<Company, Limits::kMaxCompanies> companies() { return FixedVector(rawCompanies()); } Company* get(CompanyId id) { auto index = enumValue(id); if (index < Limits::kMaxCompanies) { return &rawCompanies()[index]; } return nullptr; } CompanyId getControllingId() { return rawPlayerCompanies()[0]; } CompanyId getSecondaryPlayerId() { return rawPlayerCompanies()[1]; } void setControllingId(CompanyId id) { rawPlayerCompanies()[0] = id; } void setSecondaryPlayerId(CompanyId id) { rawPlayerCompanies()[1] = id; } Company* getPlayerCompany() { return get(rawPlayerCompanies()[0]); } Colour getCompanyColour(CompanyId id) { return _companyColours[enumValue(id)]; } Colour getPlayerCompanyColour() { return _companyColours[enumValue(rawPlayerCompanies()[0])]; } bool isPlayerCompany(CompanyId id) { auto findResult = std::find( std::begin(rawPlayerCompanies()), std::end(rawPlayerCompanies()), id); return findResult != std::end(rawPlayerCompanies()); } // 0x00430319 void update() { if (!SceneManager::isEditorMode() && !Config::get().companyAIDisabled) { CompanyId id = CompanyId(ScenarioManager::getScenarioTicks() & 0x0F); auto company = get(id); if (company != nullptr && !isPlayerCompany(id) && !company->empty()) { // Only the host should update AI, AI will run game commands // which will be sent to all the clients if (!SceneManager::isNetworked() || SceneManager::isNetworkHost()) { GameCommands::setUpdatingCompanyId(id); aiThink(id); } } getGameState().produceAICompanyTimeout++; if (getGameState().produceAICompanyTimeout >= 192) { getGameState().produceAICompanyTimeout = 0; produceCompanies(); } } } // 0x00437FB8 void updateDaily() { for (auto& company : companies()) { company.updateDaily(); } } // 0x0043037B void updateMonthly1() { setCompetitorStartDelay(Math::Bound::sub(getCompetitorStartDelay(), 1U)); for (auto& company : companies()) { company.updateMonthly1(); } Ui::WindowManager::invalidate(Ui::WindowType::company); Ui::WindowManager::invalidate(Ui::WindowType::companyList); Ui::WindowManager::invalidate(Ui::WindowType::playerInfoToolbar); uint8_t numActiveCompanies = std::distance(std::begin(companies()), std::end(companies())); auto minPerformance = std::min_element(std::begin(companies()), std::end(companies()), [](const Company& lhs, const Company& rhs) { return lhs.performanceIndex < rhs.performanceIndex; }); if (minPerformance != std::end(companies()) && numActiveCompanies != 1) { companyEmotionEvent((*minPerformance).id(), Emotion::dejected); } } // 0x0042F213 void updateMonthlyHeadquarters() { for (auto& company : companies()) { company.updateMonthlyHeadquarters(); } } // 0x00487FC1 void updateQuarterly() { for (auto& company : companies()) { company.updateQuarterly(); } } // 0x004312C7 void updateYearly() { for (auto& company : companies()) { updateYearly(company); } WindowManager::invalidate(Ui::WindowType::company); } constexpr std::array<uint8_t, 10> kAiToMetric = { 1, 1, 1, 1, 2, 2, 2, 3, 3, 3 }; // 0x0042FD62 static LoadedObjectId selectNewCompetitorFromHeader(const ObjectHeader& header) { auto loadedObj = ObjectManager::findObjectHandle(header); if (loadedObj.has_value()) { return loadedObj.value().id; } bool freeSlot = false; for (LoadedObjectId id = 0U; id < ObjectManager::getMaxObjects(ObjectType::competitor); ++id) { auto* competitorObj = ObjectManager::get<CompetitorObject>(id); if (competitorObj == nullptr) { freeSlot = true; break; } } if (!freeSlot) { LoadedObjectId id = 0U; for (; id < ObjectManager::getMaxObjects(ObjectType::competitor); ++id) { const bool isUnused = std::none_of(companies().begin(), companies().end(), [id](Company& company) { return company.competitorId == id; }); if (isUnused) { break; } } if (id == ObjectManager::getMaxObjects(ObjectType::competitor)) { return kNullObjectId; } ObjectManager::unload(ObjectManager::getHeader(LoadedObjectHandle{ ObjectType::competitor, id })); ObjectManager::reloadAll(); Ui::Dropdown::forceCloseCompanySelect(); } ObjectManager::load(header); ObjectManager::reloadAll(); Ui::Dropdown::forceCloseCompanySelect(); loadedObj = ObjectManager::findObjectHandle(header); if (loadedObj.has_value()) { return loadedObj.value().id; } return kNullObjectId; } // 0x0042F9CB static LoadedObjectId selectNewCompetitor() { sfl::static_vector<LoadedObjectId, ObjectManager::getMaxObjects(ObjectType::competitor)> loadedUnusedCompetitors; for (LoadedObjectId id = 0U; id < ObjectManager::getMaxObjects(ObjectType::competitor); ++id) { auto* competitorObj = ObjectManager::get<CompetitorObject>(id); if (competitorObj == nullptr) { continue; } const bool isFree = std::none_of(companies().begin(), companies().end(), [id](Company& company) { return company.competitorId == id; }); if (isFree) { loadedUnusedCompetitors.push_back(id); } } if (!loadedUnusedCompetitors.empty()) { const auto r = ((gPrng1().randNext() & 0xFFFFU) * loadedUnusedCompetitors.size()) / 65536; return loadedUnusedCompetitors[r]; } std::optional<std::vector<ObjectHeader>> bestInstalled = std::nullopt; uint8_t bestInstalledValue = 0xFFU; auto installedCompetitors = ObjectManager::getAvailableObjects(ObjectType::competitor); for (auto& installed : installedCompetitors) { bool isInUse = false; for (LoadedObjectId id = 0U; id < ObjectManager::getMaxObjects(ObjectType::competitor); ++id) { if (ObjectManager::get<CompetitorObject>(id) == nullptr) { continue; } auto& loadedHeader = ObjectManager::getHeader(LoadedObjectHandle{ ObjectType::competitor, id }); if (loadedHeader == installed.object._header) { isInUse = true; break; } } if (isInUse) { continue; } uint8_t metric = 0; if (getGameState().preferredAIIntelligence != 0) { metric += std::abs(kAiToMetric[installed.object._displayData.intelligence] - getGameState().preferredAIIntelligence); } if (getGameState().preferredAIAggressiveness != 0) { metric += std::abs(kAiToMetric[installed.object._displayData.aggressiveness] - getGameState().preferredAIAggressiveness); } if (getGameState().preferredAICompetitiveness != 0) { metric += std::abs(kAiToMetric[installed.object._displayData.competitiveness] - getGameState().preferredAICompetitiveness); } if (metric < bestInstalledValue) { bestInstalled = std::vector<ObjectHeader>{ installed.object._header }; bestInstalledValue = metric; } else if (metric == bestInstalledValue) { assert(bestInstalled.has_value()); bestInstalled->push_back(installed.object._header); } } if (!bestInstalled.has_value()) { return kNullObjectId; } const auto r = ((gPrng1().randNext() & 0xFFFFU) * bestInstalled->size()) / 65536; const auto& chosenHeader = (*bestInstalled)[r]; return selectNewCompetitorFromHeader(chosenHeader); } // 0x004F93F8 static constexpr std::array<Colour, 13> kAiPrimaryColours = { Colour::black, Colour::grey, Colour::white, Colour::mutedDarkPurple, Colour::blue, Colour::green, Colour::amber, Colour::darkOrange, Colour::mutedYellow, Colour::mutedDarkRed, Colour::red, Colour::max, // Pick randomcolour Colour::max, // Pick randomcolour }; // 0x004F9405 static constexpr std::array<Colour, 31> kPrimaryToSecondary = { Colour::mutedDarkPurple, Colour::mutedDarkRed, Colour::mutedTeal, Colour::white, Colour::mutedPurple, Colour::white, Colour::white, Colour::blue, Colour::white, Colour::darkRed, Colour::mutedGrassGreen, Colour::white, Colour::yellow, Colour::mutedGrassGreen, Colour::darkGreen, Colour::yellow, Colour::red, Colour::mutedOrange, Colour::mutedYellow, Colour::amber, Colour::white, Colour::mutedDarkRed, Colour::white, Colour::yellow, Colour::white, Colour::white, Colour::yellow, Colour::white, Colour::darkPink, Colour::white, Colour::mutedDarkRed, }; // 0x004F93C4 static constexpr std::array<AiPlaystyleFlags, 13> kCompanyAiPlaystyleFlags = { AiPlaystyleFlags::none, AiPlaystyleFlags::none, AiPlaystyleFlags::none, AiPlaystyleFlags::unk1 | AiPlaystyleFlags::unk2 | AiPlaystyleFlags::noAir | AiPlaystyleFlags::noWater, AiPlaystyleFlags::unk0 | AiPlaystyleFlags::unk2 | AiPlaystyleFlags::noAir | AiPlaystyleFlags::noWater, AiPlaystyleFlags::unk0 | AiPlaystyleFlags::unk1 | AiPlaystyleFlags::unk2 | AiPlaystyleFlags::unk3 | AiPlaystyleFlags::noWater, AiPlaystyleFlags::unk1 | AiPlaystyleFlags::unk2 | AiPlaystyleFlags::noAir | AiPlaystyleFlags::noWater, AiPlaystyleFlags::unk6, AiPlaystyleFlags::unk1 | AiPlaystyleFlags::unk2 | AiPlaystyleFlags::noAir | AiPlaystyleFlags::noWater, AiPlaystyleFlags::unk6, AiPlaystyleFlags::unk6, AiPlaystyleFlags::unk6, AiPlaystyleFlags::unk0 | AiPlaystyleFlags::unk1 | AiPlaystyleFlags::unk3 | AiPlaystyleFlags::noAir | AiPlaystyleFlags::noWater, }; static constexpr std::array<StringId, 13> kCompanyAiNamePrefixes = { StringIds::company_ai_name_ebony, StringIds::company_ai_name_silver, StringIds::company_ai_name_ivory, StringIds::company_ai_name_indigo, StringIds::company_ai_name_sapphire, StringIds::company_ai_name_emerald, StringIds::company_ai_name_golden, StringIds::company_ai_name_amber, StringIds::company_ai_name_bronze, StringIds::company_ai_name_burgundy, StringIds::company_ai_name_scarlet, StringIds::company_ai_name_string, StringIds::company_ai_name_pop_string, }; static constexpr std::array<StringId, 13> kCompanyAiPlaystyleString = { StringIds::company_ai_name_string_transport, StringIds::company_ai_name_string_express, StringIds::company_ai_name_string_lines, StringIds::company_ai_name_string_tracks, StringIds::company_ai_name_string_coaches, StringIds::company_ai_name_string_air, StringIds::company_ai_name_string_rail, StringIds::company_ai_name_string_carts, StringIds::company_ai_name_string_trains, StringIds::company_ai_name_string_haulage, StringIds::company_ai_name_string_shipping, StringIds::company_ai_name_string_freight, StringIds::company_ai_name_string_trucks, }; // 0x0042FE06 static CompanyId createCompany(LoadedObjectId competitorId, bool isPlayer) { auto chosenCompanyId = []() { for (auto& company : rawCompanies()) { if (company.empty()) { return company.id(); } } return CompanyId::null; }(); if (chosenCompanyId == CompanyId::null) { return CompanyId::null; } auto* company = get(chosenCompanyId); company->competitorId = competitorId; auto* competitorObj = ObjectManager::get<CompetitorObject>(competitorId); company->challengeFlags = CompanyFlags::none; company->var_49C = 0; company->var_4A0 = 0; company->ownerEmotion = Emotion::neutral; company->name = StringIds::new_company; company->ownerName = StringIds::new_owner; company->startedDate = getCurrentDay(); if (isPlayer) { Colour primaryColour = Colour::max; while (true) { const auto randVal = gPrng1().randNext(); primaryColour = static_cast<Colour>(((randVal & 0xFFU) * enumValue(Colour::max)) / 256); const auto colourMask = competingColourMask(chosenCompanyId); if (colourMask & (1U << enumValue(primaryColour))) { continue; } break; } const auto secondaryColour = kPrimaryToSecondary[enumValue(primaryColour)]; const auto colourScheme = ColourScheme{ primaryColour, secondaryColour }; company->mainColours = colourScheme; std::fill(std::begin(company->vehicleColours), std::end(company->vehicleColours), colourScheme); company->customVehicleColoursSet = 0; } else { company->ownerName = competitorObj->name; uint32_t randVal = 0; uint8_t companyNamePrefix = 0; // Usually a colour but can be a town uint8_t companyPlaystyle = 0; Colour primaryColour = Colour::max; bool colourOk = false; for (auto i = 0U; i < 250; ++i) { randVal = gPrng1().randNext(); sfl::static_vector<uint8_t, 32> availableNamePrefixes; for (auto j = 0U; j < 32; ++j) { if (competitorObj->availablePlayStyles & (1U << j)) { availableNamePrefixes.push_back(j); } } companyNamePrefix = availableNamePrefixes[availableNamePrefixes.size() * (randVal & 0xFFU) / 256]; randVal = std::rotr(randVal, 8); sfl::static_vector<uint8_t, 32> availablePlaystyles; for (auto j = 0U; j < 32; ++j) { if (competitorObj->var_08 & (1U << j)) { availablePlaystyles.push_back(j); } } companyPlaystyle = availablePlaystyles[availablePlaystyles.size() * (randVal & 0xFFU) / 256]; randVal = std::rotr(randVal, 8); primaryColour = kAiPrimaryColours[companyNamePrefix]; if (primaryColour == Colour::max) { primaryColour = static_cast<Colour>((randVal & 0xFFU) * 31 / 256); randVal = std::rotr(randVal, 8); } const auto colourMask = competingColourMask(chosenCompanyId); if (colourMask & (1U << enumValue(primaryColour))) { continue; } colourOk = true; break; } if (!colourOk) { company->name = StringIds::empty; return CompanyId::null; } const auto secondaryColour = kPrimaryToSecondary[enumValue(primaryColour)]; const auto colourScheme = ColourScheme{ primaryColour, secondaryColour }; company->mainColours = colourScheme; std::fill(std::begin(company->vehicleColours), std::end(company->vehicleColours), colourScheme); company->customVehicleColoursSet = 0; company->aiPlaystyleFlags = kCompanyAiPlaystyleFlags[companyPlaystyle]; company->aiPlaystyleTownId = 0xFFU; if (companyNamePrefix == 12) { const auto numTowns = TownManager::towns().size(); if (numTowns == 0) { company->name = StringIds::empty; return CompanyId::null; } auto randTown = (((randVal & 0xFFU) * numTowns) / 256) + 1; randVal = std::rotr(randVal, 8); const auto randTownId = [&randTown]() { for (auto& town : TownManager::towns()) { randTown--; if (randTown == 0) { return town.id(); } } return TownId::null; }(); for (auto& otherCompany : companies()) { if (otherCompany.id() == chosenCompanyId) { continue; } if ((otherCompany.aiPlaystyleFlags & AiPlaystyleFlags::townIdSet) != AiPlaystyleFlags::none) { continue; } if (static_cast<TownId>(otherCompany.aiPlaystyleTownId) == randTownId) { company->name = StringIds::empty; return CompanyId::null; } } company->aiPlaystyleTownId = enumValue(randTownId); company->aiPlaystyleFlags |= AiPlaystyleFlags::townIdSet; } const auto stringId = kCompanyAiPlaystyleString[companyPlaystyle]; auto args = FormatArguments::common(kCompanyAiNamePrefixes[companyNamePrefix], competitorObj->availableNamePrefixes); if (company->aiPlaystyleTownId != 0xFFU) { args.push(TownManager::get(static_cast<TownId>(company->aiPlaystyleTownId))->name); } char buffer[256]{}; StringManager::formatString(buffer, 256U, stringId, args); for (auto& otherCompany : companies()) { if (otherCompany.id() == chosenCompanyId) { continue; } char buffer2[256]{}; StringManager::formatString(buffer2, 256U, otherCompany.name); if (std::strncmp(buffer, buffer2, 256) == 0) { company->name = StringIds::empty; return CompanyId::null; } } company->name = StringManager::userStringAllocate(buffer, false); if (company->name == StringIds::empty) { return CompanyId::null; } } company->numExpenditureYears = 1; for (auto i = 0U; i < ExpenditureType::Count; ++i) { company->expenditures[0][i] = 0; } company->var_4A4 = AiThinkState::unk0; company->var_4A6 = AiPlaceVehicleState::begin; company->var_85F6 = 0; for (auto& thought : company->aiThoughts) { thought.type = AiThoughtType::null; } company->headquartersX = -1; company->var_25BE = AiThoughtType::null; company->unlockedVehicles.reset(); company->availableVehicles = 0; company->currentLoan = getInflationAdjustedStartingLoan(); company->cash = company->currentLoan; VehicleManager::determineAvailableVehicles(*company); company->cargoUnitsTotalDelivered = 0; company->cargoUnitsTotalDistance = 0; company->historySize = 1; company->performanceIndex = 0; company->performanceIndexHistory[0] = 0; company->cargoUnitsDeliveredHistory[0] = 0; std::fill(std::begin(company->transportTypeCount), std::end(company->transportTypeCount), 0); std::fill(std::begin(company->activeEmotions), std::end(company->activeEmotions), 0); const auto value = calculateCompanyValue(*company); company->companyValueHistory[0] = value.companyValue; company->vehicleProfit = value.vehicleProfit; updateColours(); company->observationStatus = ObservationStatus::empty; company->observationEntity = EntityId::null; company->observationX = -1; company->observationY = -1; company->observationObject = 0xFFFFU; company->observationTimeout = 0; company->ownerStatus = OwnerStatus(); company->updateCounter = 0; company->currentRating = CorporateRating::platelayer; company->challengeProgress = 0; company->numMonthsInTheRed = 0; company->jailStatus = 0; std::fill(std::begin(company->cargoDelivered), std::end(company->cargoDelivered), 0); for (auto& town : TownManager::towns()) { town.companyRatings[enumValue(chosenCompanyId)] = 500; town.companiesWithRating &= ~(1 << enumValue(chosenCompanyId)); } return chosenCompanyId; } // 0x004A6DA9 void updatePlayerInfrastructureOptions() { auto* playerCompany = getPlayerCompany(); auto& gameState = getGameState(); auto roadType = gameState.lastTrackTypeOption | (1U << 7); if (roadType == 0xFFU) { const auto roads = companyGetAvailableRoads(playerCompany->id()); roadType = roads.empty() ? 0xFFU : roads[0]; } gameState.lastRoadOption = roadType; const auto tracks = companyGetAvailableRailTracks(playerCompany->id()); gameState.lastRailroadOption = tracks.empty() ? 0xFFU : tracks[0]; auto vehicleTypeInt = Numerics::bitScanForward(playerCompany->availableVehicles); const auto vehicleType = vehicleTypeInt == -1 ? VehicleType::train : static_cast<VehicleType>(vehicleTypeInt); gameState.lastVehicleType = vehicleType; gameState.lastBuildVehiclesOption = vehicleType; gameState.lastAirport = 0xFFU; gameState.lastShipPort = 0xFFU; Ui::Windows::Construction::updateAvailableAirportAndDockOptions(); } // 0x0042F863 void createPlayerCompany() { // Original network logic removed auto& gameState = getGameState(); gameState.flags |= GameStateFlags::preferredOwnerName; // Any preference with respect to owner face? auto competitorId = Config::get().usePreferredOwnerFace ? selectNewCompetitorFromHeader(Config::get().preferredOwnerFace) : selectNewCompetitor(); // This might happen if a preferredOwner object header does not exist anymore. if (competitorId == kNullObjectId) { competitorId = selectNewCompetitor(); } gameState.playerCompanies[0] = createCompany(competitorId, true); gameState.playerCompanies[1] = CompanyId::null; updatePlayerInfrastructureOptions(); } // 0x0042F9AC static void createAiCompany() { auto competitorId = selectNewCompetitor(); if (competitorId != kNullObjectId) { createCompany(competitorId, false); } } // 0x0042F23C currency32_t calculateDeliveredCargoPayment(uint8_t cargoItem, int32_t numUnits, int32_t distance, uint16_t numDays) { const auto* cargoObj = ObjectManager::get<CargoObject>(cargoItem); // Shift payment factor by 16 for integer maths auto paymentFactorPercent = cargoObj->paymentFactor << 16; // Integer maths for updating payment factor percentage // the percentage is 0 - 65535 // Ultimate identical to floating point paymentFactor * (1-(percentage/65535)) const auto updatePaymentFactorPercent = [&](int32_t percentage) { paymentFactorPercent = std::max(0, paymentFactorPercent - cargoObj->paymentFactor * percentage); }; // Payment is split into 3 categories // Premium : Full Payment // NonPremium : Reduced Payment rate based on num days passed premium // Penalty : Further reduced payment rate based on num days passed max non premium (capped at 255) auto nonPremiumDays = numDays - cargoObj->premiumDays; if (nonPremiumDays > 0) { updatePaymentFactorPercent(cargoObj->nonPremiumRate * std::min<int32_t>(nonPremiumDays, cargoObj->maxNonPremiumDays)); auto penaltyDays = std::min(255, nonPremiumDays - cargoObj->maxNonPremiumDays); if (penaltyDays > 0) { updatePaymentFactorPercent(cargoObj->penaltyRate * penaltyDays); } } paymentFactorPercent >>= 16; // Promote to 64bit for second part of payment calc. const auto unitDistancePayment = static_cast<int64_t>(Economy::getInflationAdjustedCost(paymentFactorPercent, cargoObj->paymentIndex, 8)); const auto payment = (unitDistancePayment * numUnits * distance) / 4096; return payment; } // 0x0042FDE2 void determineAvailableVehicles() { for (auto& company : companies()) { VehicleManager::determineAvailableVehicles(company); } } // 0x004306D1 static void produceCompanies() { if (getCompetitorStartDelay() == 0 && getMaxCompetingCompanies() != 0) { int32_t activeCompanies = 0; for (const auto& company : companies()) { if (!isPlayerCompany(company.id())) { activeCompanies++; } } auto& prng = gPrng1(); if (prng.randNext(16) == 0) { if (prng.randNext(getMaxCompetingCompanies()) + 1 > activeCompanies) { createAiCompany(); } } } } Company* getOpponent() { return get(rawPlayerCompanies()[1]); } // 0x00438047 // Returns a string between 1810 and 1816 with up to two arguments. StringId getOwnerStatus(CompanyId id, FormatArguments& args) { auto* company = get(id); if (company == nullptr) { return StringIds::company_status_empty; } if ((company->challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { return StringIds::company_status_bankrupt; } const StringId observationStatusStrings[] = { StringIds::company_status_empty, StringIds::company_status_building_track_road, StringIds::company_status_building_airport, StringIds::company_status_building_dock, StringIds::company_status_checking_services, StringIds::company_status_surveying_landscape, }; StringId statusString = observationStatusStrings[company->observationStatus]; if (company->observationStatus == ObservationStatus::empty || company->observationTownId == TownId::null) { return StringIds::company_status_empty; } switch (company->observationStatus) { case ObservationStatus::buildingTrackRoad: if (company->observationObject & 0x80) { auto* obj = ObjectManager::get<RoadObject>(company->observationObject & 0xFF7F); if (obj != nullptr) { args.push(obj->name); } } else { auto* obj = ObjectManager::get<TrackObject>(company->observationObject); if (obj != nullptr) { args.push(obj->name); } } break; case ObservationStatus::buildingAirport: { auto* obj = ObjectManager::get<AirportObject>(company->observationObject); if (obj != nullptr) { args.push(obj->name); } break; } case ObservationStatus::buildingDock: { auto* obj = ObjectManager::get<DockObject>(company->observationObject); if (obj != nullptr) { args.push(obj->name); } break; } default: break; } auto* town = TownManager::get(company->observationTownId); args.push(town->name); return statusString; } // 0x004383ED void updateOwnerStatus() { if (SceneManager::isTitleMode() || SceneManager::isEditorMode()) { return; } auto companyId = GameCommands::getUpdatingCompanyId(); auto company = CompanyManager::get(companyId); if (company == nullptr) { return; } company->updateCounter += 1; if ((company->updateCounter % 128) != 0) { return; } for (size_t i = 0; i < WindowManager::count(); i++) { auto w = WindowManager::get(i); if (w->type != WindowType::vehicle) { continue; } auto* vehicle = EntityManager::get<Vehicles::VehicleBase>(EntityId(w->number)); if (vehicle == nullptr) { continue; } if (vehicle->position.x == Location::null) { continue; } if (vehicle->owner != companyId) { continue; } GameCommands::UpdateOwnerStatusArgs args{}; args.ownerStatus = OwnerStatus(vehicle->id); GameCommands::doCommand(args, GameCommands::Flags::apply); return; } auto main = WindowManager::getMainWindow(); if (main == nullptr) { return; } auto viewport = main->viewports[0]; if (viewport == nullptr) { return; } auto screenPosition = viewport->getUiCentre(); auto res = Ui::ViewportInteraction::getSurfaceLocFromUi(screenPosition); World::Pos2 mapPosition{}; if (!res || res->second != viewport) { // Happens if centre of viewport is obstructed. Probably estimates the centre location mapPosition = viewport->getCentreMapPosition(); } else { mapPosition = res->first; } GameCommands::UpdateOwnerStatusArgs args{}; args.ownerStatus = OwnerStatus(mapPosition); GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x0046DC9F // loc : gGameCommandMapX/Y/Z global // company : updatingCompanyId global // amount : ebx void spendMoneyEffect(const World::Pos3& loc, const CompanyId company, const currency32_t amount) { if (SceneManager::isEditorMode()) { return; } World::Pos3 pos = loc; if (loc.x == Location::null) { auto* view = Ui::WindowManager::getMainViewport(); if (view == nullptr) { return; } auto centre = view->getCentreScreenMapPosition(); if (!centre) { return; } pos = World::Pos3(centre->x, centre->y, World::TileManager::getHeight(*centre).landHeight); } pos.z += 10; MoneyEffect::create(pos, company, -amount); } // 0x0046DE2B // id : updatingCompanyId global var // payment : ebx (subtracted from company balance) // type : gGameCommandExpenditureType global var void applyPaymentToCompany(const CompanyId id, const currency32_t payment, const ExpenditureType type) { auto* company = get(id); if (company == nullptr || SceneManager::isEditorMode()) { return; } WindowManager::invalidate(WindowType::company, enumValue(id)); // Invalidate the company balance if this is the player company if (getControllingId() == id) { Ui::Windows::PlayerInfoPanel::invalidateFrame(); } auto cost = currency48_t{ payment }; company->cash -= cost; company->expenditures[0][static_cast<uint8_t>(type)] -= payment; } constexpr currency32_t kAiLoanStep = 1000; // 0x0046DD06 // id : updatingCompanyId global var // payment : ebp // return : ebp == 0x80000000 for false bool ensureCompanyFunding(const CompanyId id, const currency32_t payment) { if (payment <= 0) { return true; } if (SceneManager::isEditorMode()) { return true; } if (id == CompanyId::neutral) { return true; } auto* company = get(id); if (isPlayerCompany(id)) { if ((company->challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { GameCommands::setErrorText(StringIds::company_is_bankrupt); return false; } if (company->cash < payment) { FormatArguments::common(payment); GameCommands::setErrorText(StringIds::not_enough_cash_requires_currency32); return false; } return true; } else { if (company->cash < payment) { const auto requiredAdditionalFunds = -(company->cash - payment).asInt64(); if (requiredAdditionalFunds > 0) { // Round up to nearest kAiLoanStep const auto requiredAdditionalLoan = ((requiredAdditionalFunds + kAiLoanStep - 1) / kAiLoanStep) * kAiLoanStep; const auto maxLoan = Economy::getInflationAdjustedCost(CompanyManager::getMaxLoanSize(), 0, 8); if (requiredAdditionalLoan + company->currentLoan > maxLoan) { FormatArguments::common(payment); GameCommands::setErrorText(StringIds::not_enough_cash_requires_currency32); return false; } company->currentLoan += requiredAdditionalLoan; company->cash += requiredAdditionalLoan; Ui::WindowManager::invalidate(Ui::WindowType::company, enumValue(id)); } } return true; } } // 0x004302EF void updateColours() { size_t index = 0; for (auto& company : rawCompanies()) { _companyColours[index] = company.mainColours.primary; index++; } _companyColours[enumValue(CompanyId::neutral)] = Colour::grey; } // 0x004C95A6 void setPreferredName() { if (!Config::get().usePreferredOwnerName) { return; } // First, set the owner name. GameCommands::setErrorTitle(StringIds::cannot_change_owner_name); { GameCommands::ChangeCompanyOwnerNameArgs args{}; args.companyId = GameCommands::getUpdatingCompanyId(); args.bufferIndex = 1; std::memcpy(args.newName, Config::get().preferredOwnerName.c_str(), 36); GameCommands::doCommand(args, GameCommands::Flags::apply); args.bufferIndex = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.bufferIndex = 0; if (GameCommands::doCommand(args, GameCommands::Flags::apply)) { Ui::Windows::TextInput::cancel(); } } // Only continue if we've not set a custom company name yet. auto* company = get(GameCommands::getUpdatingCompanyId()); if (company == nullptr || company->name != StringIds::new_company) { return; } // Temporarily store the preferred name in buffer string 2039. char* buffer_2039 = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(buffer_2039, Config::get().preferredOwnerName.c_str(), 256); // Prepare '{NAME} Transport' in a buffer. { char companyName[256] = { 0 }; FormatArguments args{}; args.push(StringIds::buffer_2039); StringManager::formatString(companyName, StringIds::company_owner_name_transport, args); // Now, set the company name. GameCommands::setErrorTitle(StringIds::cannot_rename_this_company); GameCommands::ChangeCompanyNameArgs changeCompanyNameArgs{}; changeCompanyNameArgs.companyId = GameCommands::getUpdatingCompanyId(); changeCompanyNameArgs.bufferIndex = 1; std::memcpy(changeCompanyNameArgs.buffer, companyName, 36); GameCommands::doCommand(changeCompanyNameArgs, GameCommands::Flags::apply); changeCompanyNameArgs.bufferIndex = 2; GameCommands::doCommand(changeCompanyNameArgs, GameCommands::Flags::apply); changeCompanyNameArgs.bufferIndex = 0; GameCommands::doCommand(changeCompanyNameArgs, GameCommands::Flags::apply); } } uint32_t competingColourMask(CompanyId companyId) { const uint32_t similarColourMask[] = { 0b11, 0b11, 0b100, 0b11000, 0b11000, 0b100000, 0b11000000, 0b11000000, 0b1100000000, 0b1100000000, 0b11110000000000, 0b11110000000000, 0b11110000000000, 0b11110000000000, 0b1100000000000000, 0b1100000000000000, 0b10110000000000000000, 0b10110000000000000000, 0b101000000000000000000, 0b10110000000000000000, 0b101000000000000000000, 0b11000000000000000000000, 0b11000000000000000000000, 0b100000000000000000000000, 0b1000000000000000000000000, 0b10000000000000000000000000, 0b1100000000000000000000000000, 0b1100000000000000000000000000, 0b110000000000000000000000000000, 0b110000000000000000000000000000, 0b1000000000000000000000000000000, }; uint32_t mask = 0; for (auto& company : companies()) { if (company.id() == companyId) { continue; } mask |= similarColourMask[enumValue(company.mainColours.primary)]; } return mask; } uint32_t competingColourMask() { return competingColourMask(GameCommands::getUpdatingCompanyId()); } // 0x00434F2D uint8_t getHeadquarterBuildingType() { for (size_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::building); ++i) { auto* buildingObj = ObjectManager::get<BuildingObject>(i); if (buildingObj == nullptr) { continue; } if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters)) { return static_cast<uint8_t>(i); } } return 0; } // 0x004353F4 std::vector<uint32_t> findAllOtherInUseCompetitors(const CompanyId id) { std::vector<uint8_t> takenCompetitorIds; for (const auto& c : companies()) { if (c.id() != id) { takenCompetitorIds.push_back(c.competitorId); } } std::vector<uint32_t> inUseCompetitors; for (const auto& object : ObjectManager::getAvailableObjects(ObjectType::competitor)) { auto competitorId = ObjectManager::findObjectHandle(object.object._header); if (competitorId) { auto res = std::find(takenCompetitorIds.begin(), takenCompetitorIds.end(), competitorId->id); if (res != takenCompetitorIds.end()) { inUseCompetitors.push_back(object.index); } } } return inUseCompetitors; } // 0x00435AEF void aiDestroy(const CompanyId id) { auto* company = get(id); if (company == nullptr) { return; } if (company->headquartersX != -1) { GameCommands::HeadquarterRemovalArgs args{}; args.pos = World::Pos3(company->headquartersX, company->headquartersY, company->headquartersZ * kSmallZStep); GameCommands::doCommand(args, GameCommands::Flags::apply); } Ui::WindowManager::close(Ui::WindowType::company, enumValue(id)); Ui::WindowManager::close(Ui::WindowType::vehicleList, enumValue(id)); Ui::WindowManager::close(Ui::WindowType::stationList, enumValue(id)); Ui::WindowManager::close(Ui::WindowType::map); Ui::Windows::CompanyList::removeCompany(id); MessageManager::removeAllSubjectRefs(enumValue(id), MessageItemArgumentType::company); removeCompaniesRecords(id); StringManager::emptyUserString(company->name); company->name = StringIds::empty; StringManager::emptyUserString(company->ownerName); // TODO: Change this when we want to diverge from vanilla // company->ownerName = StringIds::empty; ObjectManager::unload(ObjectManager::getHeader(LoadedObjectHandle{ ObjectType::competitor, company->competitorId })); ObjectManager::reloadAll(); Ui::Dropdown::forceCloseCompanySelect(); } // 0x0046E306 currency32_t getInflationAdjustedStartingLoan() { return Economy::getInflationAdjustedCost(getStartingLoanSize(), 0, 8) / 100 * 100; } } namespace OpenLoco { CompanyId Company::id() const { auto* first = &CompanyManager::rawCompanies()[0]; return CompanyId(this - first); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyManager.h ```h #pragma once #include "Company.h" #include "Engine/Limits.h" #include "Types.hpp" #include <OpenLoco/Core/LocoFixedVector.hpp> #include <OpenLoco/Engine/World.hpp> #include <array> #include <cstddef> namespace OpenLoco::CompanyManager { void reset(); uint8_t getMaxCompetingCompanies(); void setMaxCompetingCompanies(uint8_t competingCompanies); uint8_t getCompetitorStartDelay(); void setCompetitorStartDelay(uint8_t competetorStartDelay); uint16_t getMaxLoanSize(); void setMaxLoanSize(uint16_t loanSize); uint16_t getStartingLoanSize(); currency32_t getInflationAdjustedStartingLoan(); void setStartingLoanSize(uint16_t loanSize); FixedVector<Company, Limits::kMaxCompanies> companies(); Company* get(CompanyId id); CompanyId getControllingId(); CompanyId getSecondaryPlayerId(); void setControllingId(CompanyId id); void setSecondaryPlayerId(CompanyId id); Company* getPlayerCompany(); Colour getCompanyColour(CompanyId id); Colour getPlayerCompanyColour(); bool isPlayerCompany(CompanyId id); void update(); void updateDaily(); void updateMonthly1(); void updateMonthlyHeadquarters(); void updateQuarterly(); void updateYearly(); void determineAvailableVehicles(); currency32_t calculateDeliveredCargoPayment(uint8_t cargoItem, int32_t numUnits, int32_t distance, uint16_t numDays); Company* getOpponent(); StringId getOwnerStatus(CompanyId id, FormatArguments& args); void updateOwnerStatus(); void updateColours(); void setPreferredName(); void spendMoneyEffect(const World::Pos3& loc, const CompanyId company, const currency32_t amount); void applyPaymentToCompany(const CompanyId id, const currency32_t payment, const ExpenditureType type); bool ensureCompanyFunding(const CompanyId id, const currency32_t payment); uint32_t competingColourMask(CompanyId companyId); uint32_t competingColourMask(); void createPlayerCompany(); uint8_t getHeadquarterBuildingType(); // Vector of competitor object index's that are in use that aren't @id's competitor object index. std::vector<uint32_t> findAllOtherInUseCompetitors(const CompanyId id); void aiDestroy(const CompanyId id); void updatePlayerInfrastructureOptions(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyRecords.h ```h #pragma once #include "Speed.hpp" #include "Types.hpp" namespace OpenLoco::CompanyManager { #pragma pack(push, 1) struct Records { Speed16 speed[3]; // 0x000436 (0x0052624E) CompanyId company[3]; // 0x00043C (0x00526254) uint8_t pad_43A; uint32_t date[3]; // 0x000440 (0x00526258) }; #pragma pack(pop) constexpr CompanyManager::Records kZeroRecords{ { kSpeedZero, kSpeedZero, kSpeedZero }, { CompanyId::null, CompanyId::null, CompanyId::null }, {}, { 0, 0, 0 }, }; const Records& getRecords(); void setRecords(const Records& records); void removeCompaniesRecords(CompanyId id); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Industry.cpp ```cpp #include "Industry.h" #include "Date.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Industries/RemoveIndustry.h" #include "GameCommands/Terraform/CreateWall.h" #include "IndustryManager.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/AnimationManager.h" #include "Map/IndustryElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Map/WallElement.h" #include "MessageManager.h" #include "Objects/CargoObject.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Random.h" #include "StationManager.h" #include "ViewportManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Bound.hpp> #include <algorithm> using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco { const std::array<Unk4F9274, 1> word_4F9274 = { Unk4F9274{ { 0, 0 }, 0 }, }; const std::array<Unk4F9274, 4> word_4F927C = { Unk4F9274{ { 0, 0 }, 0 }, Unk4F9274{ { 0, 32 }, 1 }, Unk4F9274{ { 32, 32 }, 2 }, Unk4F9274{ { 32, 0 }, 3 }, }; const std::span<const Unk4F9274> getBuildingTileOffsets(bool type) { if (type) { return word_4F927C; } return word_4F9274; } const IndustryObject* Industry::getObject() const { return ObjectManager::get<IndustryObject>(objectId); } bool Industry::empty() const { return name == StringIds::null; } bool Industry::canReceiveCargo() const { auto receiveCargoState = false; for (const auto& receivedCargo : ObjectManager::get<IndustryObject>(objectId)->requiredCargoType) { if (receivedCargo != 0xff) { receiveCargoState = true; } } return receiveCargoState; } bool Industry::canProduceCargo() const { auto produceCargoState = false; for (const auto& producedCargo : ObjectManager::get<IndustryObject>(objectId)->producedCargoType) { if (producedCargo != 0xff) { produceCargoState = true; } } return produceCargoState; } static bool findTree(SurfaceElement* surface) { auto element = surface; while (!element->isLast()) { element++; if (element->type() == ElementType::tree) { return true; } } return false; } // 0x0045935F void Industry::getStatusString(const char* buffer) { char* ptr = (char*)buffer; *ptr = '\0'; const auto* industryObj = getObject(); // Closing Down if (hasFlags(IndustryFlags::closingDown)) { ptr = StringManager::formatString(ptr, StringIds::industry_closing_down); return; } // Under Construction if (under_construction != 0xFF) { ptr = StringManager::formatString(ptr, StringIds::industry_under_construction); return; } // Produced Cargo Only if (!canReceiveCargo()) { if (!canProduceCargo()) { return; } ptr = StringManager::formatString(ptr, StringIds::industry_producing); ptr = industryObj->getProducedCargoString(ptr); return; } // Required Cargo ptr = StringManager::formatString(ptr, StringIds::industry_requires); ptr = industryObj->getRequiredCargoString(ptr); if (!canProduceCargo()) { return; } // Production and Received Cargo ptr = StringManager::formatString(ptr, StringIds::cargo_to_produce); ptr = industryObj->getProducedCargoString(ptr); } // 0x00453275 void Industry::update() { // Maybe worthwhile returning early if the industry does not use farm tiles if (!hasFlags(IndustryFlags::isGhost) && under_construction == 0xFF) { // Run tile loop for 100 iterations every tick; whole 384x384 map scans in 1475 ticks/15 days/37 seconds for (int i = 0; i < 100; i++) { isFarmTileProducing(tileLoop.current()); // loc_453318 if (tileLoop.next() == Pos2()) { calculateFarmProduction(); break; } } } } // 0x004534BD void Industry::updateDaily() { if (hasFlags(IndustryFlags::isGhost)) { return; } auto* indObj = getObject(); uint16_t amountToProduce = 0; if (indObj->hasFlags(IndustryObjectFlags::requiresAllCargo)) { amountToProduce = std::numeric_limits<uint16_t>::max(); for (auto i = 0; i < 3; ++i) { if (indObj->requiredCargoType[i] != 0xFF) { amountToProduce = std::min(amountToProduce, receivedCargoQuantityDailyTotal[i]); } } if (amountToProduce != 0) { for (auto i = 0; i < 3; ++i) { if (indObj->requiredCargoType[i] != 0xFF) { receivedCargoQuantityDailyTotal[i] -= amountToProduce; } } } } else { for (auto i = 0; i < 3; ++i) { if (indObj->requiredCargoType[i] != 0xFF) { amountToProduce = Math::Bound::add(amountToProduce, receivedCargoQuantityDailyTotal[i]); receivedCargoQuantityDailyTotal[i] = 0; } } } if (amountToProduce != 0) { for (auto i = 0; i < 2; ++i) { if (indObj->producedCargoType[i] != 0xFF) { outputBuffer[i] = Math::Bound::add(outputBuffer[i], amountToProduce); } } } for (auto i = 0; i < 3; ++i) { // Lose a 16th of required cargo if requiresAllCargo and not equally satisfied receivedCargoQuantityDailyTotal[i] -= Math::Bound::add(receivedCargoQuantityDailyTotal[i], 15) / 16; } for (auto i = 0; i < 2; ++i) { if (indObj->producedCargoType[i] == 0xFF) { continue; } uint16_t realDailyProductionTarget = (dailyProductionTarget[i] * productionRate) / 256; if (realDailyProductionTarget < dailyProduction[i]) { dailyProduction[i]--; } else if (realDailyProductionTarget > dailyProduction[i]) { dailyProduction[i]++; } outputBuffer[i] = Math::Bound::add(dailyProduction[i], outputBuffer[i]); if (outputBuffer[i] >= 8) { const auto quantityToSend = std::min<uint16_t>(outputBuffer[i], 255); outputBuffer[i] -= quantityToSend; producedCargoQuantityMonthlyTotal[i] = Math::Bound::add(producedCargoQuantityMonthlyTotal[i], quantityToSend); std::vector<StationId> stations; for (auto stationId : producedCargoStatsStation[i]) { if (stationId != StationId::null) { stations.push_back(stationId); } } const auto quantityDelivered = StationManager::deliverCargoToStations(stations, indObj->producedCargoType[i], quantityToSend); producedCargoQuantityDeliveredMonthlyTotal[i] = Math::Bound::add(quantityDelivered, producedCargoQuantityDeliveredMonthlyTotal[i]); } } } // 0x00453868 void Industry::updateMonthly() { if (hasFlags(IndustryFlags::isGhost)) { return; } if (hasFlags(IndustryFlags::closingDown) && dailyProduction[0] == 0 && dailyProduction[1] == 0) { GameCommands::IndustryRemovalArgs args; args.industryId = id(); GameCommands::doCommand(args, GameCommands::Flags::apply); return; } bool hasEvent = false; const auto* indObj = getObject(); if (under_construction == 0xFF && (!hasFlags(IndustryFlags::closingDown)) && indObj->requiredCargoType[0] == 0xFF) { if (isMonthlyProductionUp()) { dailyProductionTarget[0] = std::min(100, dailyProductionTarget[0] * 2); dailyProductionTarget[1] = std::min(100, dailyProductionTarget[1] * 2); MessageManager::post(MessageType::industryProductionUp, CompanyId::null, enumValue(id()), 0xFFFF); hasEvent = true; } else if (isMonthlyProductionDown()) { dailyProductionTarget[0] /= 2; dailyProductionTarget[1] /= 2; MessageManager::post(MessageType::industryProductionDown, CompanyId::null, enumValue(id()), 0xFFFF); hasEvent = true; } } if (!hasEvent && !IndustryManager::hasFlags(IndustryManager::Flags::disallowIndustriesCloseDown) && under_construction == 0xFF && !hasFlags(IndustryFlags::closingDown)) { if (isMonthlyProductionClosing()) { flags |= IndustryFlags::closingDown; dailyProductionTarget[0] = 0; dailyProductionTarget[1] = 0; MessageManager::post(MessageType::industryClosingDown, CompanyId::null, enumValue(id()), 0xFFFF); } } if (producedCargoMonthlyHistorySize[0] == std::size(producedCargoMonthlyHistory1)) { std::rotate(std::begin(producedCargoMonthlyHistory1), std::begin(producedCargoMonthlyHistory1) + 1, std::end(producedCargoMonthlyHistory1)); } else { producedCargoMonthlyHistorySize[0]++; } const auto newValue = static_cast<uint8_t>(std::min<uint32_t>(producedCargoQuantityMonthlyTotal[0], 12750u) / 50); producedCargoMonthlyHistory1[producedCargoMonthlyHistorySize[0] - 1] = newValue; if (producedCargoMonthlyHistorySize[1] == std::size(producedCargoMonthlyHistory2)) { std::rotate(std::begin(producedCargoMonthlyHistory2), std::begin(producedCargoMonthlyHistory2) + 1, std::end(producedCargoMonthlyHistory2)); } else { producedCargoMonthlyHistorySize[1]++; } const auto newValue2 = static_cast<uint8_t>(std::min<uint32_t>(producedCargoQuantityMonthlyTotal[1], 12750u) / 50); producedCargoMonthlyHistory2[producedCargoMonthlyHistorySize[1] - 1] = newValue2; producedCargoQuantityPreviousMonth[0] = producedCargoQuantityMonthlyTotal[0]; producedCargoQuantityMonthlyTotal[0] = 0; producedCargoQuantityDeliveredPreviousMonth[0] = producedCargoQuantityDeliveredMonthlyTotal[0]; producedCargoQuantityDeliveredMonthlyTotal[0] = 0; auto transported = std::min(producedCargoQuantityPreviousMonth[0], producedCargoQuantityDeliveredPreviousMonth[0]); if (producedCargoQuantityPreviousMonth[0] != 0) { transported = (transported * 100) / producedCargoQuantityPreviousMonth[0]; } producedCargoPercentTransportedPreviousMonth[0] = transported; producedCargoQuantityPreviousMonth[1] = producedCargoQuantityMonthlyTotal[1]; producedCargoQuantityMonthlyTotal[1] = 0; producedCargoQuantityDeliveredPreviousMonth[1] = producedCargoQuantityDeliveredMonthlyTotal[1]; producedCargoQuantityDeliveredMonthlyTotal[1] = 0; auto transported2 = std::min(producedCargoQuantityPreviousMonth[1], producedCargoQuantityDeliveredPreviousMonth[1]); if (producedCargoQuantityPreviousMonth[1] != 0) { transported2 = (transported2 * 100) / producedCargoQuantityPreviousMonth[1]; } producedCargoPercentTransportedPreviousMonth[1] = transported2; receivedCargoQuantityPreviousMonth[0] = receivedCargoQuantityMonthlyTotal[0]; receivedCargoQuantityPreviousMonth[1] = receivedCargoQuantityMonthlyTotal[1]; receivedCargoQuantityPreviousMonth[2] = receivedCargoQuantityMonthlyTotal[2]; receivedCargoQuantityMonthlyTotal[0] = 0; receivedCargoQuantityMonthlyTotal[1] = 0; receivedCargoQuantityMonthlyTotal[2] = 0; } bool Industry::isMonthlyProductionUp() { auto* indObj = getObject(); if (!indObj->hasFlags(IndustryObjectFlags::canIncreaseProduction)) { return false; } return producedCargoPercentTransportedPreviousMonth[0] > 70 && gPrng1().randNext(31) == 0 && dailyProductionTarget[0] < 100 && dailyProductionTarget[1] < 100; } bool Industry::isMonthlyProductionDown() { auto* indObj = getObject(); if (!indObj->hasFlags(IndustryObjectFlags::canDecreaseProduction)) { return false; } return (producedCargoPercentTransportedPreviousMonth[0] > 50 && dailyProductionTarget[0] > 20 && gPrng1().randNext(31) == 0) || (producedCargoPercentTransportedPreviousMonth[0] <= 50 && dailyProductionTarget[0] > 10 && gPrng1().randNext(15) == 0); } bool Industry::isMonthlyProductionClosing() { auto* indObj = getObject(); // isObsolete or isTooLowProduction return (getCurrentYear() > indObj->obsoleteYear && prng.randNext(0xFFFF) < 102) || (indObj->monthlyClosureChance != 0 && indObj->monthlyClosureChance > prng.randNext(0xFFFF)); } // 0x0045329B void Industry::isFarmTileProducing(const Pos2& pos) { const auto& surface = TileManager::get(pos).surface(); if (surface != nullptr) { if (surface->isIndustrial()) { if (surface->industryId() == id()) { uint8_t growthStage = surface->getGrowthStage(); const auto* obj = getObject(); if (growthStage == 0 || growthStage != obj->farmTileGrowthStageNoProduction) { // loc_4532E5 numFarmTiles++; if ((!obj->hasFlags(IndustryObjectFlags::farmProductionIgnoresSnow) && surface->snowCoverage() != 0) || findTree(surface)) { numIdleFarmTiles++; } } } } } } void Industry::calculateFarmProduction() { // 0x00453366 // subtract 6% of farm tiles from idle farm tiles, prevents complete shutdown of production in winter int16_t adjustedIdleFarmTiles = std::max(0, numIdleFarmTiles - numFarmTiles / 16); int16_t productiveFarmTiles = numFarmTiles - adjustedIdleFarmTiles; int16_t relativeFarmSize = std::min(productiveFarmTiles / 25, 255); const auto* obj = getObject(); if (relativeFarmSize < obj->farmNumFields) { productionRate = ((relativeFarmSize * 256) / obj->farmNumFields) & 0xFF; } else { // 0x0045335F; moved here. productionRate = 255; } // 0x004533B2 numFarmTiles = 0; numIdleFarmTiles = 0; // if the farm is significantly smaller than ideal and 13% of cargo was transported last month, 1/2 chance to grow farm size by one field if (productionRate < 224) { if (producedCargoQuantityPreviousMonth[0] / 8 <= producedCargoQuantityDeliveredPreviousMonth[0] || producedCargoQuantityPreviousMonth[1] / 8 <= producedCargoQuantityDeliveredPreviousMonth[1]) { if (prng.randBool()) { World::Pos2 randTile{ static_cast<coord_t>(x + (prng.randNext(-15, 16) * 32)), static_cast<coord_t>(y + (prng.randNext(-15, 16) * 32)) }; uint8_t wallType = obj->wallTypes[0]; uint8_t wallEntranceType = obj->wallTypes[1]; if (obj->wallTypes[2] != 0xFF && prng.randBool()) { wallType = obj->wallTypes[2]; wallEntranceType = obj->wallTypes[3]; } uint8_t updateTimerVal = prng.randNext(7); expandGrounds(randTile, wallType, wallEntranceType, 0, updateTimerVal); } } } } // 0x0045510C bl == 0 static bool isSurfaceClaimed(const World::TilePos2& pos) { if (!World::validCoords(pos)) { return false; } const auto tile = World::TileManager::get(pos); bool passedSurface = false; for (auto& el : tile) { auto* elSurface = el.as<World::SurfaceElement>(); if (elSurface != nullptr) { if (elSurface->water() != 0) { return false; } if (elSurface->hasType6Flag()) { return false; } passedSurface = true; continue; } if (!passedSurface) { continue; } if (el.isGhost()) { continue; } if (el.as<World::WallElement>() != nullptr || el.as<World::TreeElement>() != nullptr) { continue; } return false; } return true; } // 0x0045510C bl == 1 // originally argument 3 was a union of two fields 0bYYY00XXX; X is growthStage and Y is updateTimer bool claimSurfaceForIndustry(const World::TilePos2& pos, IndustryId industryId, uint8_t growthStage, uint8_t updateTimer) { if (!isSurfaceClaimed(pos)) { return false; } const auto tile = World::TileManager::get(pos); World::SurfaceElement* surface = tile.surface(); surface->setIsIndustrialFlag(true); surface->setIndustry(industryId); surface->setUpdateTimer(updateTimer); surface->setGrowthStage(growthStage); Ui::ViewportManager::invalidate(World::toWorldSpace(pos), surface->baseHeight(), surface->baseHeight() + 32); World::TileManager::removeAllWallsOnTileAbove(pos, surface->baseZ()); return true; } // 0x00454A43 // originally argument 3 was a union of two fields 0bYYY00XXX; X is growthStage and Y is updateTimer void Industry::expandGrounds(const Pos2& pos, uint8_t wallType, uint8_t wallEntranceType, uint8_t growthStage, uint8_t updateTimer) { std::size_t numBorders = 0; // Search a 5x5 area centred on Pos const auto initialTilePos = toTileSpace(pos); const auto topRight = initialTilePos - TilePos2{ 2, 2 }; const auto bottomLeft = initialTilePos + TilePos2{ 2, 2 }; for (const auto& tilePos : getClampedRange(topRight, bottomLeft)) { if (isSurfaceClaimed(tilePos)) { numBorders++; } } if (numBorders < 20) { return; } const auto* indObj = ObjectManager::get<IndustryObject>(objectId); std::optional<Core::Prng> isGrowthStageDesyncPrng; if (indObj->hasFlags(IndustryObjectFlags::farmTilesGrowthStageDesynchronized)) { isGrowthStageDesyncPrng = prng; } std::optional<Core::Prng> isPartialCoveragePrng; if (indObj->hasFlags(IndustryObjectFlags::farmTilesPartialCoverage)) { // Vanilla mistake here, prng was not set! It would just recycle from a previous isPartialCoveragePrng caller isPartialCoveragePrng = prng; } uint32_t randEntraceMask = 0; if (wallType != 0xFF && wallEntranceType != 0xFF) { randEntraceMask = 1U << (prng.srand_0() & 0xF); randEntraceMask |= 1U << ((prng.srand_0() >> 4) & 0x1F); } std::size_t i = 0; for (const auto& tilePos : getClampedRange(topRight, bottomLeft)) { if (isGrowthStageDesyncPrng.has_value()) { const auto randVal = isGrowthStageDesyncPrng->randNext(); growthStage = ((randVal & 0xFF) * indObj->farmTileNumGrowthStages) / 256; updateTimer = (randVal >> 8) & 0x7; } bool skipBorderClear = false; if (isPartialCoveragePrng.has_value()) { // 87% chance that farm tile is not generated. Note that 5x5 fields can overlap so this can be checked multiple times per tile. if (isPartialCoveragePrng->randNext() & 0x7) { skipBorderClear = true; } } if (!skipBorderClear) { claimSurfaceForIndustry(tilePos, id(), growthStage, updateTimer); } if (wallType == 0xFF) { continue; } auto getWallPlacementArgs = [randEntraceMask, &i, wallEntranceType, wallType, &tilePos](const uint8_t rotation) { GameCommands::WallPlacementArgs args; args.pos = World::Pos3(World::toWorldSpace(tilePos), 0); args.rotation = rotation; args.type = randEntraceMask & (1U << i) ? wallEntranceType : wallType; i++; args.primaryColour = Colour::black; args.secondaryColour = Colour::black; args.tertiaryColour = Colour::black; return args; }; // If on an edge add a wall if (tilePos.x == topRight.x) { GameCommands::doCommand(getWallPlacementArgs(0), GameCommands::Flags::apply); } // Must not be else if as corners have two walls if (tilePos.x == bottomLeft.x) { GameCommands::doCommand(getWallPlacementArgs(2), GameCommands::Flags::apply); } if (tilePos.y == topRight.y) { GameCommands::doCommand(getWallPlacementArgs(3), GameCommands::Flags::apply); } if (tilePos.y == bottomLeft.y) { GameCommands::doCommand(getWallPlacementArgs(1), GameCommands::Flags::apply); } } } // 0x00459D43 void Industry::createMapAnimations() { for (size_t i = 0; i < numTiles; i++) { auto& tilePos = tiles[i]; auto baseZ = (tilePos.z & ~Location::null) / 4; auto tile = TileManager::get(tilePos); for (auto& el : tile) { auto* industryEl = el.as<IndustryElement>(); if (industryEl == nullptr) { continue; } if (industryEl->baseZ() != baseZ) { continue; } auto tileIndustry = industryEl->industry(); if (tileIndustry != nullptr) { const auto* industryObject = tileIndustry->getObject(); if (industryObject != nullptr) { auto animOffsets = getBuildingTileOffsets(industryObject->buildingSizeFlags & (1U << industryEl->buildingType())); for (auto animOffset : animOffsets) { AnimationManager::createAnimation(3, animOffset.pos + tilePos, baseZ); } } } } } } // 0x004574F7 void Industry::updateProducedCargoStats() { const auto* industryObj = getObject(); for (auto cargoNum = 0; cargoNum < 2; ++cargoNum) { auto& indStatsStation = producedCargoStatsStation[cargoNum]; auto& indStatsRating = producedCargoStatsRating[cargoNum]; std::fill(std::begin(indStatsStation), std::end(indStatsStation), StationId::null); const auto cargoType = industryObj->producedCargoType[cargoNum]; if (cargoType == 0xFF) { continue; } auto id = 0; for (const auto& hasBit : stationsInRange) { const auto stationId = static_cast<StationId>(id); id++; if (!hasBit) { continue; } const auto* station = StationManager::get(stationId); if (station->empty()) { continue; } const auto& cargoStats = station->cargoStats[cargoType]; if ((cargoStats.flags & StationCargoStatsFlags::acceptedFromProducer) == StationCargoStatsFlags::none) { continue; } const auto rating = cargoStats.rating; for (auto index = 0; index < 4; ++index) { if (indStatsStation[index] == StationId::null || indStatsRating[index] <= rating) { // This is an insertion sort. // Rotate so that we overwrite the last entry std::rotate(std::begin(indStatsStation) + index, std::end(indStatsStation) - 1, std::end(indStatsStation)); std::rotate(std::begin(indStatsRating) + index, std::end(indStatsRating) - 1, std::end(indStatsRating)); indStatsStation[index] = stationId; indStatsRating[index] = rating; break; } } } uint8_t ratingFraction = 0xFF; for (auto& rating : indStatsRating) { rating = (rating * ratingFraction) / 256; ratingFraction = -rating; } } stationsInRange.reset(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Industry.h ```h #pragma once #include "Engine/Limits.h" #include "Map/Tile.h" #include "Map/TileLoop.hpp" #include "Types.hpp" #include <OpenLoco/Core/BitSet.hpp> #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Prng.h> #include <limits> #include <span> namespace OpenLoco { struct IndustryObject; // TODO: Move this to a different header shared with buildings struct Unk4F9274 { World::Pos2 pos; uint8_t index; }; const std::span<const Unk4F9274> getBuildingTileOffsets(bool type); enum class IndustryFlags : uint16_t { none = 0U, isGhost = 1U << 0, sorted = 1U << 1, closingDown = 1U << 2, flag_04 = 1U << 3, }; OPENLOCO_ENABLE_ENUM_OPERATORS(IndustryFlags); #pragma pack(push, 1) struct Industry { StringId name; coord_t x; // 0x02 coord_t y; // 0x04 IndustryFlags flags; // 0x06 Core::Prng prng; // 0x08 uint8_t objectId; // 0x10 uint8_t under_construction; // 0x11 (0xFF = Finished) uint16_t foundingYear; // 0x12 uint8_t numTiles; // 0x14 World::Pos3 tiles[32]; // 0x15 bit 15 of z indicates if multiTile (2x2) TownId town; // 0xD5 World::TileLoop tileLoop; // 0xD7 int16_t numFarmTiles; // 0xDB int16_t numIdleFarmTiles; // 0xDD uint8_t productionRate; // 0xDF fraction of dailyTargetProduction out of 256 CompanyId owner; // 0xE0 BitSet<Limits::kMaxStations> stationsInRange; // 0xE1 each bit represents one station StationId producedCargoStatsStation[2][4]; // 0x161 uint8_t producedCargoStatsRating[2][4]; // 0x171 uint16_t dailyProductionTarget[2]; // 0x179 uint16_t dailyProduction[2]; // 0x17D uint16_t outputBuffer[2]; // 0x181 uint16_t producedCargoQuantityMonthlyTotal[2]; // 0x185 uint16_t producedCargoQuantityPreviousMonth[2]; // 0x189 uint16_t receivedCargoQuantityMonthlyTotal[3]; // 0x18D uint16_t receivedCargoQuantityPreviousMonth[3]; // 0x193 uint16_t receivedCargoQuantityDailyTotal[3]; // 0x199 uint16_t producedCargoQuantityDeliveredMonthlyTotal[2]; // 0x19F uint16_t producedCargoQuantityDeliveredPreviousMonth[2]; // 0x1A3 uint8_t producedCargoPercentTransportedPreviousMonth[2]; // 0x1A7 (%) uint8_t producedCargoMonthlyHistorySize[2]; // 0x1A9 (<= 20 * 12) uint8_t producedCargoMonthlyHistory1[20 * 12]; // 0x1AB (20 years, 12 months) uint8_t producedCargoMonthlyHistory2[20 * 12]; // 0x29B int32_t history_min_production[2]; // 0x38B uint8_t pad_393[0x453 - 0x393]; IndustryId id() const; const IndustryObject* getObject() const; bool empty() const; bool canReceiveCargo() const; bool canProduceCargo() const; void getStatusString(const char* buffer); void update(); void updateDaily(); void updateMonthly(); bool isMonthlyProductionUp(); bool isMonthlyProductionDown(); bool isMonthlyProductionClosing(); void isFarmTileProducing(const World::Pos2& pos); void calculateFarmProduction(); void expandGrounds(const World::Pos2& pos, uint8_t primaryWallType, uint8_t wallEntranceType, uint8_t growthStage, uint8_t updateTimer); void createMapAnimations(); void updateProducedCargoStats(); constexpr bool hasFlags(IndustryFlags flagsToTest) const { return (flags & flagsToTest) != IndustryFlags::none; } }; #pragma pack(pop) static_assert(sizeof(Industry) == 0x453); bool claimSurfaceForIndustry(const World::TilePos2& pos, IndustryId industryId, uint8_t growthStage, uint8_t updateTimer); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/IndustryManager.cpp ```cpp #include "IndustryManager.h" #include "CompanyManager.h" #include "Date.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Industries/CreateIndustry.h" #include "GameState.h" #include "GameStateFlags.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/ClimateObject.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Random.h" #include "SceneManager.h" #include "TownManager.h" #include "Ui/WindowManager.h" #include <OpenLoco/Math/Vector.hpp> #include <numeric> namespace OpenLoco::IndustryManager { static auto& rawIndustries() { return getGameState().industries; } static auto getTotalIndustriesFactor() { return getGameState().numberOfIndustries; } Flags getFlags() { return getGameState().industryFlags; } constexpr int32_t kCloseIndustryDistanceMax = 480; constexpr int32_t kIndustryWithinClusterDistance = 960; constexpr int32_t kNumIndustryInCluster = 3; constexpr int32_t kFindRandomNewIndustryAttempts = 250; // Above this is classed as high ground constexpr World::SmallZ kIndustryHighGroundMin = 48; // Below this is classed as low ground constexpr World::SmallZ kIndustryLowGroundMax = 56; // Below this is classed as flat ground constexpr int32_t kIndustryFlatGroundMountainMax = 32; constexpr uint32_t kIndustryTilesToBeInDesertMin = 100; constexpr uint32_t kIndustryTilesToBeNearDesertMax = 70; constexpr uint32_t kIndustryTilesToBeNearWaterMin = 10; constexpr uint32_t kIndustryTilesToBeAwayWaterMax = 0; constexpr int32_t kIndustryDistToBeNearTownMax = 576; constexpr int32_t kIndustryDistToBeAwayTownMin = 768; constexpr uint32_t kIndustryNumTreesToBeNearTreesMin = 25; constexpr uint32_t kIndustryNumTressToBeOpenSpaceMax = 3; void setFlags(const Flags flags) { getGameState().industryFlags = flags; } bool hasFlags(const Flags flags) { return (getGameState().industryFlags & flags) != Flags::none; } // 0x00453214 void reset() { for (auto& industry : rawIndustries()) { industry.name = StringIds::null; } Ui::Windows::IndustryList::reset(); } FixedVector<Industry, Limits::kMaxIndustries> industries() { return FixedVector(rawIndustries()); } Industry* get(IndustryId id) { if (enumValue(id) >= Limits::kMaxIndustries) { return nullptr; } return &rawIndustries()[enumValue(id)]; } // 0x00453234 void update() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded) && !SceneManager::isEditorMode()) { GameCommands::setUpdatingCompanyId(CompanyId::neutral); for (auto& industry : industries()) { industry.update(); } } } // 0x00453487 void updateDaily() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded)) { GameCommands::setUpdatingCompanyId(CompanyId::neutral); for (auto& industry : industries()) { industry.updateDaily(); } } } // 0x0047EA42 uint8_t getMostCommonBuildingCargoType() { // First generate a count of all the different cargo based on what building could generate std::array<uint32_t, ObjectManager::getMaxObjects(ObjectType::cargo)> cargoCounts{}; for (size_t buildObjId = 0; buildObjId < ObjectManager::getMaxObjects(ObjectType::building); ++buildObjId) { const auto* buildObj = ObjectManager::get<BuildingObject>(buildObjId); if (buildObj == nullptr) { continue; } if (!buildObj->hasFlags(BuildingObjectFlags::miscBuilding) && buildObj->producedQuantity[0] != 0) { cargoCounts[buildObj->producedCargoType[0]]++; } } // Then pick the most common auto maxEl = std::max_element(std::begin(cargoCounts), std::end(cargoCounts)); if (*maxEl != 0) { return std::distance(std::begin(cargoCounts), maxEl); } // If none are common pick any valid cargo object for (uint8_t cargoObjId = 0; cargoObjId < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoObjId) { const auto* cargoObj = ObjectManager::get<CargoObject>(cargoObjId); if (cargoObj == nullptr) { continue; } return cargoObjId; } // This should really be an error! return 0; } // 0x0045960E static bool canCargoTypeBeProducedInWorld(uint8_t cargoType) { if (cargoType == getMostCommonBuildingCargoType()) { return true; } for (auto& industry : industries()) { const auto* indObj = industry.getObject(); auto res = std::find(std::begin(indObj->producedCargoType), std::end(indObj->producedCargoType), cargoType); if (res != std::end(indObj->producedCargoType)) { return true; } } return false; } static bool canIndustryObjBeCreated(const IndustryObject& indObj) { if (getCurrentYear() < indObj.designedYear) { return false; } if (getCurrentYear() >= indObj.obsoleteYear) { return false; } // If industry is a self producer i.e. no requirements to produce if (indObj.requiredCargoType[0] == 0xFF) { return true; } if (indObj.hasFlags(IndustryObjectFlags::requiresAllCargo)) { // All required cargo must be producable in world for (auto i = 0; i < 3; ++i) { if (indObj.requiredCargoType[i] == 0xFF) { continue; } if (!canCargoTypeBeProducedInWorld(indObj.requiredCargoType[i])) { return false; } } return true; } else { // At least one required cargo must be producable in world for (auto i = 0; i < 3; ++i) { if (indObj.requiredCargoType[i] == 0xFF) { continue; } if (canCargoTypeBeProducedInWorld(indObj.requiredCargoType[i])) { return true; } } return false; } } // 0x00459A05 static bool isTooCloseToNearbyIndustries(const World::Pos2& loc) { for (auto& industry : industries()) { const auto dist = Math::Vector::manhattanDistance2D(loc, World::Pos2{ industry.x, industry.y }); if (dist < kCloseIndustryDistanceMax) { return true; } } return false; } // 0x00459A50 static bool isOutwithCluster(const World::Pos2& loc, const uint8_t indObjId) { auto numClusters = 0; for (auto& industry : industries()) { if (industry.objectId != indObjId) { continue; } numClusters++; const auto dist = Math::Vector::manhattanDistance2D(loc, World::Pos2{ industry.x, industry.y }); if (dist < kIndustryWithinClusterDistance) { return false; } } if (numClusters < kNumIndustryInCluster) { return false; } return true; } // 0x004599B3 static std::optional<World::Pos2> findRandomNewIndustryLocation(const uint8_t indObjId) { auto* indObj = ObjectManager::get<IndustryObject>(indObjId); for (auto i = 0; i < kFindRandomNewIndustryAttempts; ++i) { // Replace the below with this after validating the function // Map::Pos2 randomPos{ // Map::TilePos2(gPrng1().randNext(Map::kMapRows), gPrng1().randNext(Map::kMapColumns)) // }; const auto randomNum = gPrng1().randNext(); const auto randomPos = World::toWorldSpace(World::TilePos2( (((randomNum >> 16) * World::kMapRows) >> 16), (((randomNum & 0xFFFF) * World::kMapColumns) >> 16))); if (isTooCloseToNearbyIndustries(randomPos)) { continue; } if (indObj->hasFlags(IndustryObjectFlags::builtInClusters)) { if (isOutwithCluster(randomPos, indObjId)) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtOnHighGround)) { auto tile = World::TileManager::get(randomPos); auto* surface = tile.surface(); if (surface == nullptr || surface->baseZ() < kIndustryHighGroundMin) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtOnLowGround)) { auto tile = World::TileManager::get(randomPos); auto* surface = tile.surface(); if (surface == nullptr || surface->baseZ() > kIndustryLowGroundMax) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtOnSnow)) { auto tile = World::TileManager::get(randomPos); auto* surface = tile.surface(); auto* climateObj = ObjectManager::get<ClimateObject>(); if (surface == nullptr || surface->baseZ() < climateObj->summerSnowLine) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtBelowSnowLine)) { auto tile = World::TileManager::get(randomPos); auto* surface = tile.surface(); auto* climateObj = ObjectManager::get<ClimateObject>(); if (surface == nullptr || surface->baseZ() > climateObj->winterSnowLine) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtOnFlatGround)) { if (World::TileManager::mountainHeight(randomPos) > kIndustryFlatGroundMountainMax) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtInDesert)) { if (World::TileManager::countSurroundingDesertTiles(randomPos) < kIndustryTilesToBeInDesertMin) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtNearDesert)) { if (World::TileManager::countSurroundingDesertTiles(randomPos) >= kIndustryTilesToBeNearDesertMax) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtNearWater)) { if (World::TileManager::countSurroundingWaterTiles(randomPos) < kIndustryTilesToBeNearWaterMin) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtAwayFromWater)) { if (World::TileManager::countSurroundingWaterTiles(randomPos) > kIndustryTilesToBeAwayWaterMax) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtOnWater)) { auto tile = World::TileManager::get(randomPos); auto* surface = tile.surface(); if (surface != nullptr && surface->water() == 0) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtNearTown)) { auto res = TownManager::getClosestTownAndDensity(randomPos); if (!res.has_value()) { continue; } const auto& [townId, density] = *res; if (density == 0) { const auto* town = TownManager::get(townId); if (Math::Vector::manhattanDistance2D(randomPos, World::Pos2{ town->x, town->y }) > kIndustryDistToBeNearTownMax) { continue; } } } if (indObj->hasFlags(IndustryObjectFlags::builtAwayFromTown)) { auto res = TownManager::getClosestTownAndDensity(randomPos); if (!res.has_value()) { continue; } const auto townId = res->first; const auto* town = TownManager::get(townId); if (Math::Vector::manhattanDistance2D(randomPos, World::Pos2{ town->x, town->y }) < kIndustryDistToBeAwayTownMin) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtNearTrees)) { if (World::TileManager::countSurroundingTrees(randomPos) < kIndustryNumTreesToBeNearTreesMin) { continue; } } if (indObj->hasFlags(IndustryObjectFlags::builtRequiresOpenSpace)) { if (World::TileManager::countSurroundingTrees(randomPos) > kIndustryNumTressToBeOpenSpaceMax) { continue; } } return randomPos; } return std::nullopt; } // 0x00459722 & 0x004598F0 int32_t capOfTypeOfIndustry(const uint8_t indObjId, const uint8_t numIndustriesFactor) { const auto* indObj = ObjectManager::get<IndustryObject>(indObjId); // totalOfTypeInScenario is in the range of 1->32 inclusive // numIndustriesFactor is in the range of 0->2 (low, med, high) // This formula is ultimately staticPreferredTotalOfType = 1/4 * ((numIndustriesFactor + 1) * indObj->totalOfTypeInScenario) // but we will do it in two steps to keep identical results. const auto intermediate1 = ((numIndustriesFactor + 1) * indObj->totalOfTypeInScenario) / 3; const auto staticPreferredTotalOfType = intermediate1 - intermediate1 / 4; // The preferred total can vary by up to a half of the static preferred total. const auto randomPreferredTotalOfType = (staticPreferredTotalOfType / 2) * (gPrng1().randNext(0xFF) / 256); return staticPreferredTotalOfType + randomPreferredTotalOfType; } // 0x00459722 static bool hasReachedCapOfTypeOfIndustry(const uint8_t indObjId) { const uint8_t numIndustriesFactor = getTotalIndustriesFactor(); const auto preferredTotalOfType = capOfTypeOfIndustry(indObjId, numIndustriesFactor); const auto totalOfThisType = std::count_if(std::begin(industries()), std::end(industries()), [indObjId](const auto& industry) { return (industry.objectId == indObjId); }); return totalOfThisType >= preferredTotalOfType; } // 0x0045979C & 0x00459949 void createNewIndustry(const uint8_t indObjId, const bool buildImmediately, const int32_t numAttempts) { // Try find valid coordinates for this industry for (auto attempt = 0; attempt < numAttempts; ++attempt) { auto randomIndustryLoc = findRandomNewIndustryLocation(indObjId); if (randomIndustryLoc.has_value()) { GameCommands::IndustryPlacementArgs args; args.type = indObjId; args.buildImmediately = buildImmediately; args.pos = *randomIndustryLoc; // To match vanilla we will do this. // TODO: Once match confirmed replace with two randNext() calls const auto temp = gPrng1().srand_0(); gPrng1().randNext(); args.srand0 = gPrng1().srand_0() - temp; args.srand1 = gPrng1().srand_1(); auto res = GameCommands::doCommand(args, GameCommands::Flags::apply); if (res != GameCommands::FAILURE) { break; } } } } // 0x00459659 static void tryCreateNewIndustriesMonthly() { if ((getFlags() & Flags::disallowIndustriesStartUp) != Flags::none) { return; } for (uint8_t indObjId = 0; static_cast<size_t>(indObjId) < ObjectManager::getMaxObjects(ObjectType::industry); ++indObjId) { auto* indObj = ObjectManager::get<IndustryObject>(indObjId); if (indObj == nullptr) { continue; } if (!canIndustryObjBeCreated(*indObj)) { continue; } if (hasReachedCapOfTypeOfIndustry(indObjId)) { continue; } createNewIndustry(indObjId, false, 25); } } // 0x0045383B void updateMonthly() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded)) { GameCommands::setUpdatingCompanyId(CompanyId::neutral); tryCreateNewIndustriesMonthly(); for (auto& industry : industries()) { industry.updateMonthly(); } Ui::WindowManager::invalidate(Ui::WindowType::industry); } } // 0x00459D2D void createAllMapAnimations() { if (!Game::hasFlags(GameStateFlags::tileManagerLoaded)) { return; } for (auto& industry : industries()) { industry.createMapAnimations(); } } // 0x048FE92 bool industryNearPosition(const World::Pos2& position, IndustryObjectFlags flags) { for (auto& industry : industries()) { const auto* industryObj = industry.getObject(); if (!industryObj->hasFlags(flags)) { continue; } auto manhattanDistance = Math::Vector::manhattanDistance2D(World::Pos2{ industry.x, industry.y }, position); if (manhattanDistance / World::kTileSize < 11) { return true; } } return false; } // 0x004574E8 void updateProducedCargoStats() { for (auto& industry : industries()) { industry.updateProducedCargoStats(); } } // 0x00454DBE IndustryId allocateNewIndustry(const uint8_t type, const World::Pos2& pos, const Core::Prng& prng, const TownId nearbyTown) { const auto* indObj = ObjectManager::get<IndustryObject>(type); for (auto i = 0U; i < Limits::kMaxIndustries; ++i) { const auto id = static_cast<IndustryId>(i); auto* industry = IndustryManager::get(id); if (!industry->empty()) { continue; } industry->prng = prng; industry->flags = IndustryFlags::none; industry->objectId = type; industry->x = pos.x; industry->y = pos.y; industry->numTiles = 0; industry->under_construction = 0; industry->tileLoop = World::TileLoop{}; industry->numFarmTiles = 0; industry->numIdleFarmTiles = 0; industry->productionRate = 25; industry->foundingYear = getCurrentYear(); industry->stationsInRange = {}; for (auto& stats : industry->producedCargoStatsStation) { std::fill(std::begin(stats), std::end(stats), StationId::null); } std::fill(std::begin(industry->dailyProduction), std::end(industry->dailyProduction), 0); std::fill(std::begin(industry->outputBuffer), std::end(industry->outputBuffer), 0); std::fill(std::begin(industry->producedCargoQuantityMonthlyTotal), std::end(industry->producedCargoQuantityMonthlyTotal), 0); std::fill(std::begin(industry->producedCargoQuantityPreviousMonth), std::end(industry->producedCargoQuantityPreviousMonth), 0); std::fill(std::begin(industry->receivedCargoQuantityMonthlyTotal), std::end(industry->receivedCargoQuantityMonthlyTotal), 0); std::fill(std::begin(industry->receivedCargoQuantityPreviousMonth), std::end(industry->receivedCargoQuantityPreviousMonth), 0); std::fill(std::begin(industry->receivedCargoQuantityDailyTotal), std::end(industry->receivedCargoQuantityDailyTotal), 0); std::fill(std::begin(industry->producedCargoQuantityDeliveredMonthlyTotal), std::end(industry->producedCargoQuantityDeliveredMonthlyTotal), 0); std::fill(std::begin(industry->producedCargoQuantityDeliveredPreviousMonth), std::end(industry->producedCargoQuantityDeliveredPreviousMonth), 0); std::fill(std::begin(industry->producedCargoPercentTransportedPreviousMonth), std::end(industry->producedCargoPercentTransportedPreviousMonth), 0); std::fill(std::begin(industry->producedCargoMonthlyHistorySize), std::end(industry->producedCargoMonthlyHistorySize), 1); // Note: vanilla just set to 0 first entry change this when allowing divergence // std::fill(std::begin(industry->producedCargoMonthlyHistory1), std::end(industry->producedCargoMonthlyHistory1), 0); // std::fill(std::begin(industry->producedCargoMonthlyHistory2), std::end(industry->producedCargoMonthlyHistory2), 0); industry->producedCargoMonthlyHistory1[0] = 0; industry->producedCargoMonthlyHistory2[0] = 0; std::fill(std::begin(industry->history_min_production), std::end(industry->history_min_production), 0); industry->town = nearbyTown; industry->name = indObj->var_02; for (auto& innerInd : IndustryManager::industries()) { if (innerInd.name != industry->name) { continue; } if (&innerInd == industry) { continue; } if (innerInd.town != industry->town) { continue; } for (auto unique = 1; unique < 0xFFF; ++unique) { FormatArguments args{}; args.push<uint16_t>(unique); char buffer[512]{}; StringManager::formatString(buffer, indObj->var_02 + 1, args); const auto newName = StringManager::userStringAllocate(buffer, true); if (newName == StringIds::empty) { continue; } industry->name = newName; break; } } return id; } return IndustryId::null; } } OpenLoco::IndustryId OpenLoco::Industry::id() const { auto* first = &IndustryManager::rawIndustries()[0]; return IndustryId(this - first); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/IndustryManager.h ```h #pragma once #include "Engine/Limits.h" #include "Industry.h" #include "Objects/IndustryObject.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/LocoFixedVector.hpp> #include <array> #include <cstddef> namespace OpenLoco::IndustryManager { enum class Flags : uint8_t { none = 0U, disallowIndustriesCloseDown = 1U << 0, disallowIndustriesStartUp = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(Flags); void reset(); FixedVector<Industry, Limits::kMaxIndustries> industries(); Industry* get(IndustryId id); Flags getFlags(); bool hasFlags(const Flags flags); void setFlags(const Flags flags); void update(); void updateDaily(); uint8_t getMostCommonBuildingCargoType(); void updateMonthly(); int32_t capOfTypeOfIndustry(const uint8_t indObjId, const uint8_t numIndustriesFactor); void createNewIndustry(const uint8_t indObjId, const bool buildImmediately, const int32_t numAttempts); void createAllMapAnimations(); bool industryNearPosition(const World::Pos2& position, IndustryObjectFlags flags); void updateProducedCargoStats(); IndustryId allocateNewIndustry(const uint8_t type, const World::Pos2& pos, const Core::Prng& prng, const TownId nearbyTown); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Station.cpp ```cpp #include "Station.h" #include "CompanyManager.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingContext.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "IndustryManager.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "MessageManager.h" #include "Objects/AirportObject.h" #include "Objects/BridgeObject.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainStationObject.h" #include "Random.h" #include "StationManager.h" #include "TownManager.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Bound.hpp> #include <algorithm> #include <cassert> using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::Ui; using namespace OpenLoco::Literals; namespace OpenLoco { constexpr uint8_t kMinCargoRating = 0; constexpr uint8_t kMaxCargoRating = 200; constexpr uint8_t catchmentSize = 4; struct CargoSearchState { private: inline static loco_global<uint8_t[kMapSize], 0x00F00484> _map; inline static loco_global<uint32_t, 0x0112C68C> _filter; inline static loco_global<uint32_t[kMaxCargoStats], 0x0112C690> _score; inline static loco_global<uint32_t, 0x0112C710> _producedCargoTypes; inline static loco_global<IndustryId[kMaxCargoStats], 0x0112C7D2> _industry; inline static loco_global<uint8_t, 0x0112C7F2> _byte_112C7F2; public: bool mapHas1(const tile_coord_t x, const tile_coord_t y) const { return (_map[y * kMapColumns + x] & (1 << enumValue(CatchmentFlags::flag_0))) != 0; } bool mapHas2(const tile_coord_t x, const tile_coord_t y) const { return (_map[y * kMapColumns + x] & (1 << enumValue(CatchmentFlags::flag_1))) != 0; } void mapRemove2(const tile_coord_t x, const tile_coord_t y) { _map[y * kMapColumns + x] &= ~(1 << enumValue(CatchmentFlags::flag_1)); } void setTile(const tile_coord_t x, const tile_coord_t y, const CatchmentFlags flag) { _map[y * kMapColumns + x] |= (1 << enumValue(flag)); } void resetTile(const tile_coord_t x, const tile_coord_t y, const CatchmentFlags flag) { _map[y * kMapColumns + x] &= ~(1 << enumValue(flag)); } void setTileRegion(tile_coord_t x, tile_coord_t y, int16_t xTileCount, int16_t yTileCount, const CatchmentFlags flag) { auto xStart = x; auto xTileStartCount = xTileCount; while (yTileCount > 0) { while (xTileCount > 0) { setTile(x, y, flag); x++; xTileCount--; } x = xStart; xTileCount = xTileStartCount; y++; yTileCount--; } } void resetTileRegion(tile_coord_t x, tile_coord_t y, int16_t xTileCount, int16_t yTileCount, const CatchmentFlags flag) { auto xStart = x; auto xTileStartCount = xTileCount; while (yTileCount > 0) { while (xTileCount > 0) { resetTile(x, y, flag); x++; xTileCount--; } x = xStart; xTileCount = xTileStartCount; y++; yTileCount--; } } uint32_t filter() const { return _filter; } void filter(const uint32_t value) { _filter = value; } void resetScores() { std::fill_n(_score.get(), kMaxCargoStats, 0); } uint32_t score(const uint8_t cargo) { return _score[cargo]; } void addScore(const uint8_t cargo, const int32_t value) { _score[cargo] += value; } uint32_t producedCargoTypes() const { return _producedCargoTypes; } void resetProducedCargoTypes() { _producedCargoTypes = 0; } void addProducedCargoType(const uint8_t cargoId) { _producedCargoTypes = _producedCargoTypes | (1 << cargoId); } void byte_112C7F2(const uint8_t value) { _byte_112C7F2 = value; } bool cargoFilterHasBeenRecalculated() const { return _byte_112C7F2 == 0; } void resetIndustryMap() { std::fill_n(_industry.get(), kMaxCargoStats, IndustryId::null); } IndustryId getIndustry(const uint8_t cargo) const { return _industry[cargo]; } void setIndustry(const uint8_t cargo, const IndustryId id) { _industry[cargo] = id; } }; // 0x0048B23E void Station::update() { updateCargoAcceptance(); } // 0x00492640 void Station::updateCargoAcceptance() { CargoSearchState cargoSearchState; uint32_t currentAcceptedCargo = calcAcceptedCargo(cargoSearchState); uint32_t originallyAcceptedCargo = 0; for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { auto& stationCargoStats = cargoStats[cargoId]; stationCargoStats.industryId = cargoSearchState.getIndustry(cargoId); if (stationCargoStats.isAccepted()) { originallyAcceptedCargo |= (1 << cargoId); } bool isNowAccepted = (currentAcceptedCargo & (1 << cargoId)) != 0; stationCargoStats.isAccepted(isNowAccepted); } if (originallyAcceptedCargo != currentAcceptedCargo) { if (owner == CompanyManager::getControllingId()) { alertCargoAcceptanceChange(originallyAcceptedCargo, currentAcceptedCargo); } invalidateWindow(); } } // 0x00492683 void Station::alertCargoAcceptanceChange(uint32_t oldCargoAcc, uint32_t newCargoAcc) { for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { bool acceptedBefore = (oldCargoAcc & (1 << cargoId)) != 0; bool acceptedNow = (newCargoAcc & (1 << cargoId)) != 0; if (acceptedBefore && !acceptedNow) { MessageManager::post( MessageType::cargoNoLongerAccepted, owner, enumValue(id()), cargoId); } else if (!acceptedBefore && acceptedNow) { MessageManager::post( MessageType::cargoNowAccepted, owner, enumValue(id()), cargoId); } } } // 0x00492026 static uint32_t doCalcAcceptedCargo(const Station* station, CargoSearchState& cargoSearchState) { cargoSearchState.resetScores(); cargoSearchState.resetProducedCargoTypes(); if (station != nullptr) { // See also recalculateStationModes which has a similar loop for (uint16_t i = 0; i < station->stationTileSize; i++) { auto pos = station->stationTiles[i]; auto stationElement = getStationElement(pos); if (stationElement == nullptr) { continue; } cargoSearchState.byte_112C7F2(0); if (stationElement->stationType() == StationType::roadStation) { auto obj = ObjectManager::get<RoadStationObject>(stationElement->objectId()); if (obj->hasFlags(RoadStationFlags::passenger)) { cargoSearchState.filter(cargoSearchState.filter() | (1 << obj->cargoType)); } else if (obj->hasFlags(RoadStationFlags::freight)) { cargoSearchState.filter(cargoSearchState.filter() | ~(1 << obj->cargoType)); } } else { cargoSearchState.filter(~0U); } } } if (cargoSearchState.filter() == 0) { cargoSearchState.filter(~0U); } for (tile_coord_t ty = 0; ty < kMapColumns; ty++) { for (tile_coord_t tx = 0; tx < kMapRows; tx++) { if (cargoSearchState.mapHas2(tx, ty)) { auto pos = Pos2(tx * kTileSize, ty * kTileSize); auto tile = TileManager::get(pos); for (auto& el : tile) { if (el.isGhost()) { continue; } switch (el.type()) { case ElementType::industry: { auto& industryEl = el.get<IndustryElement>(); auto* industry = industryEl.industry(); if (industry == nullptr || industry->under_construction != 0xFF) { break; } const auto* obj = industry->getObject(); if (obj == nullptr) { break; } for (auto cargoId : obj->requiredCargoType) { if (cargoId != 0xFF && (cargoSearchState.filter() & (1 << cargoId))) { cargoSearchState.addScore(cargoId, 8); cargoSearchState.setIndustry(cargoId, industry->id()); } } for (auto cargoId : obj->producedCargoType) { if (cargoId != 0xFF && (cargoSearchState.filter() & (1 << cargoId))) { cargoSearchState.addProducedCargoType(cargoId); } } break; } case ElementType::building: { auto& buildingEl = el.get<BuildingElement>(); if (buildingEl.isMiscBuilding() || !buildingEl.isConstructed()) { break; } const auto* obj = buildingEl.getObject(); if (obj == nullptr) { break; } for (int i = 0; i < 2; i++) { const auto cargoId = obj->producedCargoType[i]; if (cargoId != 0xFF && (cargoSearchState.filter() & (1 << cargoId))) { cargoSearchState.addScore(cargoId, obj->var_A6[i]); if (obj->producedQuantity[i] != 0) { cargoSearchState.addProducedCargoType(cargoId); } } } for (int i = 0; i < 2; i++) { if (obj->requiredCargoType[i] != 0xFF && (cargoSearchState.filter() & (1 << obj->requiredCargoType[i]))) { cargoSearchState.addScore(obj->requiredCargoType[i], obj->var_A8[i]); } } // Multi tile buildings should only be counted once so remove the other tiles from the search if (obj->hasFlags(BuildingObjectFlags::largeTile)) { auto index = buildingEl.sequenceIndex(); tile_coord_t xPos = (pos.x - World::kOffsets[index].x) / kTileSize; tile_coord_t yPos = (pos.y - World::kOffsets[index].y) / kTileSize; cargoSearchState.mapRemove2(xPos + 0, yPos + 0); cargoSearchState.mapRemove2(xPos + 0, yPos + 1); cargoSearchState.mapRemove2(xPos + 1, yPos + 0); cargoSearchState.mapRemove2(xPos + 1, yPos + 1); } break; } default: continue; } } } } } uint32_t acceptedCargos = 0; for (uint8_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { if (cargoSearchState.score(cargoId) >= 8) { acceptedCargos |= (1 << cargoId); } } return acceptedCargos; } // 0x0049239A PotentialCargo calcAcceptedCargoAi(const TilePos2 minPos, const TilePos2 maxPos) { CargoSearchState cargoSearchState; cargoSearchState.filter(0); setCatchmentDisplay(nullptr, CatchmentFlags::flag_1); for (auto& tilePos : getClampedRange(minPos, maxPos)) { const auto pos = World::toWorldSpace(tilePos); sub_491BF5(pos, CatchmentFlags::flag_1); } cargoSearchState.resetIndustryMap(); PotentialCargo res{}; res.accepted = doCalcAcceptedCargo(nullptr, cargoSearchState); res.produced = cargoSearchState.producedCargoTypes(); return res; } // 0x00491FE0 // THIS FUNCTION ONLY TO BE CALLED ON NORMAL STATIONS uint32_t Station::calcAcceptedCargo(CargoSearchState& cargoSearchState) const { cargoSearchState.byte_112C7F2(1); cargoSearchState.filter(0); cargoSearchState.resetIndustryMap(); setCatchmentDisplay(this, CatchmentFlags::flag_1); return doCalcAcceptedCargo(this, cargoSearchState); } // 0x00491FE0 // WARNING: this may be called with station (ebp) = -1 // THIS FUNCTION ONLY TO BE CALLED ON GHOST TRACK STATIONS PotentialCargo calcAcceptedCargoTrainStationGhost(const Station* ghostStation, const Pos2& location, const uint32_t filter) { CargoSearchState cargoSearchState; cargoSearchState.byte_112C7F2(1); cargoSearchState.filter(0); cargoSearchState.filter(filter); cargoSearchState.resetIndustryMap(); setCatchmentDisplay(ghostStation, CatchmentFlags::flag_1); sub_491BF5(location, CatchmentFlags::flag_1); PotentialCargo res{}; res.accepted = doCalcAcceptedCargo(ghostStation, cargoSearchState); res.produced = cargoSearchState.producedCargoTypes(); return res; } // 0x00491F43 // WARNING: this may be called with station (ebp) = -1 // THIS FUNCTION ONLY TO BE CALLED ON GHOST AIRPORT STATIONS PotentialCargo calcAcceptedCargoAirportGhost(const Station* ghostStation, const uint8_t type, const Pos2& location, const uint8_t rotation, const uint32_t filter) { CargoSearchState cargoSearchState; cargoSearchState.byte_112C7F2(1); cargoSearchState.filter(0); cargoSearchState.filter(filter); cargoSearchState.resetIndustryMap(); setCatchmentDisplay(ghostStation, CatchmentFlags::flag_1); sub_491C6F(type, location, rotation, CatchmentFlags::flag_1); PotentialCargo res{}; res.accepted = doCalcAcceptedCargo(ghostStation, cargoSearchState); res.produced = cargoSearchState.producedCargoTypes(); return res; } // 0x00491F93 // WARNING: this may be called with station (ebp) = -1 // THIS FUNCTION ONLY TO BE CALLED ON GHOST DOCK STATIONS PotentialCargo calcAcceptedCargoDockGhost(const Station* ghostStation, const Pos2& location, const uint32_t filter) { CargoSearchState cargoSearchState; cargoSearchState.byte_112C7F2(1); cargoSearchState.filter(0); cargoSearchState.filter(filter); cargoSearchState.resetIndustryMap(); setCatchmentDisplay(ghostStation, CatchmentFlags::flag_1); sub_491D20(location, CatchmentFlags::flag_1); PotentialCargo res{}; res.accepted = doCalcAcceptedCargo(ghostStation, cargoSearchState); res.produced = cargoSearchState.producedCargoTypes(); return res; } static void setStationCatchmentRegion(CargoSearchState& cargoSearchState, TilePos2 minPos, TilePos2 maxPos, const CatchmentFlags flags); // 0x00491D70 // catchment flag should not be shifted (1, 2, 3, 4) and NOT (1 << 0, 1 << 1) void setCatchmentDisplay(const Station* station, const CatchmentFlags catchmentFlag) { CargoSearchState cargoSearchState; cargoSearchState.resetTileRegion(0, 0, kMapColumns, kMapRows, catchmentFlag); if (station == nullptr) { return; } if (station->stationTileSize == 0) { return; } for (uint16_t i = 0; i < station->stationTileSize; i++) { auto pos = station->stationTiles[i]; pos.z = World::heightFloor(pos.z); auto stationElement = getStationElement(pos); if (stationElement == nullptr) { continue; } switch (stationElement->stationType()) { case StationType::airport: { auto airportObject = ObjectManager::get<AirportObject>(stationElement->objectId()); auto [minPos, maxPos] = airportObject->getAirportExtents(World::toTileSpace(pos), stationElement->rotation()); minPos.x -= catchmentSize; minPos.y -= catchmentSize; maxPos.x += catchmentSize; maxPos.y += catchmentSize; setStationCatchmentRegion(cargoSearchState, minPos, maxPos, catchmentFlag); } break; case StationType::docks: { auto minPos = World::toTileSpace(pos); auto maxPos = minPos; minPos.x -= catchmentSize; minPos.y -= catchmentSize; // Docks are always size 2x2 maxPos.x += catchmentSize + 1; maxPos.y += catchmentSize + 1; setStationCatchmentRegion(cargoSearchState, minPos, maxPos, catchmentFlag); } break; default: { auto minPos = World::toTileSpace(pos); auto maxPos = minPos; minPos.x -= catchmentSize; minPos.y -= catchmentSize; maxPos.x += catchmentSize; maxPos.y += catchmentSize; setStationCatchmentRegion(cargoSearchState, minPos, maxPos, catchmentFlag); } } } } bool isWithinCatchmentDisplay(const World::Pos2 pos) { CargoSearchState cargoSearchState; const auto tilePos = World::toTileSpace(pos); return cargoSearchState.mapHas1(tilePos.x, tilePos.y); } // 0x0049B4E0 void Station::deliverCargoToTown(uint8_t cargoType, uint16_t cargoQuantity) { auto twn = TownManager::get(town); twn->monthlyCargoDelivered[cargoType] = Math::Bound::add(twn->monthlyCargoDelivered[cargoType], cargoQuantity); } // 0x0042F489 void Station::deliverCargoToStation(const uint8_t cargoType, const uint8_t cargoQuantity) { auto& stationCargoStat = cargoStats[cargoType]; stationCargoStat.quantity = Math::Bound::add(stationCargoStat.quantity, cargoQuantity); stationCargoStat.enrouteAge = 0; stationCargoStat.origin = id(); updateCargoDistribution(); } // 0x00492A98 char* Station::getStatusString(char* buffer) { char* ptr = buffer; *ptr = '\0'; for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { auto& stationCargoStat = cargoStats[cargoId]; if (stationCargoStat.quantity == 0) { continue; } if (*buffer != '\0') { ptr = StringManager::formatString(ptr, StringIds::waiting_cargo_separator); } FormatArguments args{}; args.push<uint32_t>(stationCargoStat.quantity); auto cargo = ObjectManager::get<CargoObject>(cargoId); auto unitName = stationCargoStat.quantity == 1 ? cargo->unitNameSingular : cargo->unitNamePlural; ptr = StringManager::formatString(ptr, unitName, args); } StringId suffix = *buffer == '\0' ? StringIds::nothing_waiting : StringIds::waiting; return StringManager::formatString(ptr, suffix); } // 0x00492793 bool Station::updateCargo() { bool atLeastOneGoodRating = false; bool quantityUpdated = false; var_3B0 = std::min(var_3B0 + 1, 255); var_3B1 = std::min(var_3B1 + 1, 255); auto& rng = gPrng1(); for (uint32_t i = 0; i < kMaxCargoStats; i++) { auto& stationCargo = cargoStats[i]; if (!stationCargo.empty()) { if (stationCargo.quantity != 0 && stationCargo.origin != id()) { stationCargo.enrouteAge = std::min(stationCargo.enrouteAge + 1, 255); } else { // Change from vanilla to deal with the cargo transfer bug: // Reset en-route age once the station cargo gets cleared // or else the age keeps increasing stationCargo.enrouteAge = 0; } stationCargo.age = std::min(stationCargo.age + 1, 255); auto targetRating = calculateCargoRating(stationCargo); // Limit to +/- 2 minimum change auto ratingDelta = std::clamp(targetRating - stationCargo.rating, -2, 2); stationCargo.rating += ratingDelta; if (stationCargo.rating <= 50) { // Rating < 25%, decrease cargo if (stationCargo.quantity >= 400) { stationCargo.quantity -= rng.randNext(1, 32); quantityUpdated = true; } else if (stationCargo.quantity >= 200) { stationCargo.quantity -= rng.randNext(1, 8); quantityUpdated = true; } } if (stationCargo.rating >= 100) { atLeastOneGoodRating = true; } if (stationCargo.rating <= 100 && stationCargo.quantity != 0) { if (stationCargo.rating <= rng.randNext(0, 127)) { stationCargo.quantity = std::max(0, stationCargo.quantity - rng.randNext(1, 4)); quantityUpdated = true; } } } } updateCargoDistribution(); auto w = WindowManager::find(WindowType::station, enumValue(id())); if (w != nullptr && (w->currentTab == 2 || w->currentTab == 1 || quantityUpdated)) { w->invalidate(); } return atLeastOneGoodRating; } // 0x004927F6 int32_t Station::calculateCargoRating(const StationCargoStats& cargo) const { int32_t rating = 0; // Bonus if cargo is fresh if (cargo.age <= 45) { rating += 40; if (cargo.age <= 30) { rating += 45; if (cargo.age <= 15) { rating += 45; if (cargo.age <= 7) { rating += 35; } } } } // Penalty if lots of cargo waiting rating -= 130; if (cargo.quantity <= 1000) { rating += 30; if (cargo.quantity <= 500) { rating += 30; if (cargo.quantity <= 300) { rating += 30; if (cargo.quantity <= 200) { rating += 20; if (cargo.quantity <= 100) { rating += 20; } } } } } if ((flags & (StationFlags::flag_7 | StationFlags::flag_8)) == StationFlags::none && !CompanyManager::isPlayerCompany(owner)) { rating = 120; } Speed16 vehicleSpeed = std::min(cargo.vehicleSpeed, 250_mph); if (vehicleSpeed > 35_mph) { rating += ((vehicleSpeed - 35_mph).getRaw()) / 4; } if (cargo.vehicleAge < 4) { rating += 10; if (cargo.vehicleAge < 2) { rating += 10; if (cargo.vehicleAge < 1) { rating += 13; } } } return std::clamp<int32_t>(rating, kMinCargoRating, kMaxCargoRating); } // 0x004929DB void Station::updateCargoDistribution() { invalidateWindow(); WindowManager::invalidate(Ui::WindowType::stationList); bool hasChanged = false; for (uint8_t i = 0; i < kMaxCargoStats; ++i) { auto& stationCargo = cargoStats[i]; auto newDensity = 0; if (stationCargo.quantity != 0) { if (stationTileSize != 0) { newDensity = stationCargo.quantity / stationTileSize; auto* cargoObj = ObjectManager::get<CargoObject>(i); newDensity += (1 << cargoObj->stationCargoDensity) - 1; newDensity >>= cargoObj->stationCargoDensity; newDensity = std::min<int32_t>(newDensity, Limits::kMaxStationCargoDensity); } } if (stationCargo.densityPerTile != newDensity) { stationCargo.densityPerTile = newDensity; hasChanged = true; } } if (hasChanged) { for (auto i = 0; i < stationTileSize; ++i) { const auto& tile = stationTiles[i]; Ui::ViewportManager::invalidate({ tile.x, tile.y }, World::heightFloor(tile.z), World::heightFloor(tile.z) + 32, ZoomLevel::full); } } } struct StationBorder { uint32_t left; uint32_t right; uint16_t width; uint16_t height; }; static constexpr std::array<StationBorder, 4> kZoomToStationBorder = { StationBorder{ ImageIds::curved_border_left_medium, ImageIds::curved_border_right_medium, 3, 11, }, StationBorder{ ImageIds::curved_border_left_medium, ImageIds::curved_border_right_medium, 3, 11, }, StationBorder{ ImageIds::curved_border_left_small, ImageIds::curved_border_right_small, 1, 7, }, StationBorder{ ImageIds::curved_border_left_small, ImageIds::curved_border_right_small, 1, 7, }, }; static constexpr std::array<Gfx::Font, 4> kZoomToStationFonts = { Gfx::Font::medium_bold, Gfx::Font::medium_bold, Gfx::Font::small, Gfx::Font::small, }; // 0x0048DF4D, 0x0048E13B void drawStationName(Gfx::DrawingContext& drawingCtx, const Station& station, uint8_t zoom, bool isHovered) { const Gfx::RenderTarget& unZoomedRt = drawingCtx.currentRenderTarget(); if (!station.labelFrame.contains(unZoomedRt.getDrawableRect(), zoom)) { return; } auto& borderImages = kZoomToStationBorder[zoom]; const auto companyColour = [&station]() { if (station.owner == CompanyId::null) { return Colour::grey; } else { return CompanyManager::getCompanyColour(station.owner); } }(); const auto colour = Colours::getTranslucent(companyColour, isHovered ? 0 : 1); Ui::Point topLeft = { station.labelFrame.left[zoom], station.labelFrame.top[zoom] }; Ui::Point bottomRight = { station.labelFrame.right[zoom], station.labelFrame.bottom[zoom] }; drawingCtx.drawImage(topLeft, ImageId(borderImages.left).withTranslucency(ExtColour::unk34)); drawingCtx.drawImage(topLeft, ImageId(borderImages.left).withTranslucency(colour)); Ui::Point topRight = { static_cast<int16_t>(bottomRight.x - borderImages.width) + 1, topLeft.y }; drawingCtx.drawImage(topRight, ImageId(borderImages.right).withTranslucency(ExtColour::unk34)); drawingCtx.drawImage(topRight, ImageId(borderImages.right).withTranslucency(colour)); drawingCtx.drawRect(topLeft.x + borderImages.width + 1, topLeft.y, bottomRight.x - topLeft.x - 2 * borderImages.width, bottomRight.y - topLeft.y + 1, enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); drawingCtx.drawRect(topLeft.x + borderImages.width + 1, topLeft.y, bottomRight.x - topLeft.x - 2 * borderImages.width, bottomRight.y - topLeft.y + 1, enumValue(colour), Gfx::RectFlags::transparent); char buffer[512]{}; FormatArguments args; args.push<uint16_t>(enumValue(station.town)); auto* str = buffer; *str++ = ControlCodes::Colour::black; str = StringManager::formatString(str, station.name, args); *str++ = ' '; StringManager::formatString(str, getTransportIconsFromStationFlags(station.flags)); auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(kZoomToStationFonts[zoom]); auto point = topLeft + Point(borderImages.width, 0); tr.drawString(point, Colour::black, buffer); } // 0x0048DCA5 void Station::updateLabel() { // duplicate of drawStationName in Viewport.cpp char buffer[256]{}; FormatArguments args{}; args.push(town); auto* strEnd = StringManager::formatString(buffer, 256, name, args); *strEnd++ = ' '; *strEnd = '\0'; const auto remainingLength = strEnd - buffer; StringManager::formatString(strEnd, remainingLength, getTransportIconsFromStationFlags(flags)); for (auto zoom = 0U; zoom < 4; ++zoom) { Ui::Viewport virtualVp{}; virtualVp.zoom = zoom; const auto labelCenter = World::Pos3{ x, y, z }; const auto vpPos = World::gameToScreen(labelCenter, WindowManager::getCurrentRotation()); const auto font = kZoomToStationFonts[zoom]; const auto width = Gfx::TextRenderer::getStringWidth(font, buffer) + kZoomToStationBorder[zoom].width * 2; const auto height = kZoomToStationBorder[zoom].height; const auto [zoomWidth, zoomHeight] = ScreenToViewport::scaleTransform(Ui::Point(width, height), virtualVp); const auto left = vpPos.x - zoomWidth / 2; const auto right = left + zoomWidth; const auto top = vpPos.y - zoomHeight / 2 - 32; const auto bottom = top + zoomHeight; const auto [uiLeft, uiTop] = ViewportToScreen::scaleTransform(Ui::Point(left, top), virtualVp); const auto [uiRight, uiBottom] = ViewportToScreen::scaleTransform(Ui::Point(right, bottom), virtualVp); labelFrame.left[zoom] = uiLeft; labelFrame.right[zoom] = uiRight; labelFrame.top[zoom] = uiTop; labelFrame.bottom[zoom] = uiBottom; } } // 0x004CBA2D void Station::invalidate() { Ui::ViewportManager::invalidate(this); } void Station::invalidateWindow() { WindowManager::invalidate(WindowType::station, enumValue(id())); } // 0x0048F6D4 StationElement* getStationElement(const Pos3& pos) { auto tile = TileManager::get(pos.x, pos.y); auto baseZ = pos.z / 4; for (auto& element : tile) { auto* stationElement = element.as<StationElement>(); if (stationElement == nullptr) { continue; } if (stationElement->baseZ() != baseZ) { continue; } if (!stationElement->isAiAllocated()) { return stationElement; } else { return nullptr; } } return nullptr; } // 0x00491EDC static void setStationCatchmentRegion(CargoSearchState& cargoSearchState, TilePos2 minPos, TilePos2 maxPos, const CatchmentFlags flag) { minPos.x = std::max(minPos.x, static_cast<coord_t>(0)); minPos.y = std::max(minPos.y, static_cast<coord_t>(0)); maxPos.x = std::min(maxPos.x, static_cast<coord_t>(kMapColumns - 1)); maxPos.y = std::min(maxPos.y, static_cast<coord_t>(kMapRows - 1)); maxPos.x -= minPos.x; maxPos.y -= minPos.y; maxPos.x++; maxPos.y++; cargoSearchState.setTileRegion(minPos.x, minPos.y, maxPos.x, maxPos.y, flag); } // 0x00491BF5 void sub_491BF5(const Pos2& pos, const CatchmentFlags flag) { auto minPos = World::toTileSpace(pos); auto maxPos = minPos; maxPos.x += catchmentSize; maxPos.y += catchmentSize; minPos.x -= catchmentSize; minPos.y -= catchmentSize; CargoSearchState cargoSearchState; setStationCatchmentRegion(cargoSearchState, minPos, maxPos, flag); } // 0x0048F716 void recalculateStationCenter(const StationId stationId) { auto* station = StationManager::get(stationId); int32_t totalX = 0; int32_t totalY = 0; int16_t maxZ = 0; uint16_t count = 0; for (auto i = 0U; i < station->stationTileSize; ++i) { auto& tile = station->stationTiles[i]; auto* elStation = getStationElement(tile); if (elStation == nullptr) { continue; } totalX += tile.x; totalY += tile.y; maxZ = std::max(World::heightFloor(tile.z), maxZ); count++; } if (count != 0) { station->z = maxZ; station->x = (totalX / count) + 16; station->y = (totalY / count) + 16; station->updateLabel(); } } // 0x0048F529 void recalculateStationModes(const StationId stationId) { auto* station = StationManager::get(stationId); uint32_t acceptedCargoTypes = 0; station->flags &= ~StationFlags::allModes; // This loop is similar to the start of doCalcAcceptedCargo except for the // following difference: // 1. It doesn't accept ghost station tiles // 2. It also works out the StationFlags transport mode // 3. RoadStations with both RoadStationFlags::passenger and freight unset // are handled differently. (Perhaps vanilla bug) for (auto i = 0U; i < station->stationTileSize; ++i) { auto& pos = station->stationTiles[i]; StationElement* elStation = getStationElement(pos); if (elStation == nullptr || elStation->isGhost()) { continue; } switch (elStation->stationType()) { case StationType::trainStation: { auto* elTrack = elStation->prev()->as<TrackElement>(); if (elTrack == nullptr) { break; } auto* trackObj = ObjectManager::get<TrackObject>(elTrack->trackObjectId()); station->flags |= trackObj->hasFlags(TrackObjectFlags::unk_02) ? StationFlags::transportModeRoad : StationFlags::transportModeRail; acceptedCargoTypes = ~0U; break; } case StationType::roadStation: { // Loop from start as road element can be variable number of elements below station auto tile = TileManager::get(pos); for (auto& el2 : tile) { if (&el2 == reinterpret_cast<TileElement*>(&elStation)) { break; } auto* elRoad = el2.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseZ() != elStation->baseZ()) { continue; } if (elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); station->flags |= roadObj->hasFlags(RoadObjectFlags::unk_01) ? StationFlags::transportModeRail : StationFlags::transportModeRoad; } auto* roadStationObj = ObjectManager::get<RoadStationObject>(elStation->objectId()); if (roadStationObj->hasFlags(RoadStationFlags::passenger)) { acceptedCargoTypes |= 1U << roadStationObj->cargoType; } else if (roadStationObj->hasFlags(RoadStationFlags::freight)) { // Exclude passengers from this station type acceptedCargoTypes |= ~(1U << roadStationObj->cargoType); } else { acceptedCargoTypes = ~0U; } break; } case StationType::airport: station->flags |= StationFlags::transportModeAir; acceptedCargoTypes = ~0U; break; case StationType::docks: station->flags |= StationFlags::transportModeWater; acceptedCargoTypes = ~0U; break; } } for (auto cargoType = 0U; cargoType < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoType) { auto* cargoObj = ObjectManager::get<CargoObject>(cargoType); if (cargoObj == nullptr) { continue; } station->cargoStats[cargoType].flags &= ~StationCargoStatsFlags::acceptedFromProducer; if (acceptedCargoTypes & (1U << cargoType)) { station->cargoStats[cargoType].flags |= StationCargoStatsFlags::acceptedFromProducer; } } } // 0x0048F321 void addTileToStation(const StationId stationId, const World::Pos3& pos, uint8_t rotation) { auto* station = StationManager::get(stationId); station->stationTiles[station->stationTileSize] = pos; station->stationTiles[station->stationTileSize].z &= ~0x3; station->stationTiles[station->stationTileSize].z |= (rotation & 0x3); station->stationTileSize++; CargoSearchState cargoSearchState; const auto acceptedCargos = station->calcAcceptedCargo(cargoSearchState); if (cargoSearchState.cargoFilterHasBeenRecalculated() && (station->flags & StationFlags::flag_5) != StationFlags::none) { station->flags &= ~StationFlags::flag_5; auto* town = TownManager::get(station->town); town->numStations++; Ui::WindowManager::invalidate(WindowType::town, enumValue(station->town)); for (auto& station2 : StationManager::stations()) { if (station2.owner == station->owner) { continue; } // THIS LOOKS WRONG WHY ISN'T IT station2.flags (vanilla mistake?) if ((station->flags & StationFlags::flag_5) != StationFlags::none) { continue; } const auto distance = Math::Vector::manhattanDistance2D(World::Pos2{ station->x, station->y }, World::Pos2{ station2.x, station2.y }); if (distance <= 256) { companyEmotionEvent(station2.owner, Emotion::surprised); } } } for (auto cargoId = 0U; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoId) { auto& stats = station->cargoStats[cargoId]; stats.industryId = cargoSearchState.getIndustry(cargoId); bool isAccepted = (acceptedCargos & (1 << cargoId)) != 0; stats.isAccepted(isAccepted); } } // 0x0048F43A void removeTileFromStation(const StationId stationId, const World::Pos3& pos, uint8_t rotation) { auto* station = StationManager::get(stationId); auto findPos = pos; findPos.z |= rotation; // Find tile to remove auto foundTilePos = std::find(std::begin(station->stationTiles), std::end(station->stationTiles), findPos); if (foundTilePos == std::end(station->stationTiles)) { // Bug mitigation: ensure stationTileSize does not exceed the actual array length station->stationTileSize = std::clamp<int16_t>(station->stationTileSize - 1, 0, static_cast<uint16_t>(std::size(station->stationTiles))); return; } // Remove tile by moving the remaining tiles over the one to remove // NB: erasing is handled by StationManager::zeroUnused; not calling std::erase due to type mismatches std::rotate(foundTilePos, foundTilePos + 1, std::end(station->stationTiles)); station->stationTileSize--; } // 0x0048F482 void removeTileFromStationAndRecalcCargo(const StationId stationId, const World::Pos3& pos, uint8_t rotation) { removeTileFromStation(stationId, pos, rotation); auto* station = StationManager::get(stationId); // Recalculate accepted cargo CargoSearchState cargoSearchState; const auto acceptedCargos = station->calcAcceptedCargo(cargoSearchState); // Reset cargo acceptance stats for this station for (auto cargoId = 0U; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoId) { auto& stats = station->cargoStats[cargoId]; stats.industryId = cargoSearchState.getIndustry(cargoId); bool isAccepted = (acceptedCargos & (1 << cargoId)) != 0; stats.isAccepted(isAccepted); } } // 0x00491C6F void sub_491C6F(const uint8_t type, const Pos2& pos, const uint8_t rotation, const CatchmentFlags flag) { auto airportObject = ObjectManager::get<AirportObject>(type); auto [minPos, maxPos] = airportObject->getAirportExtents(World::toTileSpace(pos), rotation); minPos.x -= catchmentSize; minPos.y -= catchmentSize; maxPos.x += catchmentSize; maxPos.y += catchmentSize; CargoSearchState cargoSearchState; setStationCatchmentRegion(cargoSearchState, minPos, maxPos, flag); } // 0x00491D20 void sub_491D20(const Pos2& pos, const CatchmentFlags flag) { auto minPos = World::toTileSpace(pos); auto maxPos = minPos + TilePos2{ 1, 1 }; maxPos.x += catchmentSize; maxPos.y += catchmentSize; minPos.x -= catchmentSize; minPos.y -= catchmentSize; CargoSearchState cargoSearchState; setStationCatchmentRegion(cargoSearchState, minPos, maxPos, flag); } StringId getTransportIconsFromStationFlags(const StationFlags flags) { constexpr StringId label_icons[] = { StringIds::label_icons_none, StringIds::label_icons_rail, StringIds::label_icons_road, StringIds::label_icons_rail_road, StringIds::label_icons_air, StringIds::label_icons_rail_air, StringIds::label_icons_road_air, StringIds::label_icons_rail_road_air, StringIds::label_icons_water, StringIds::label_icons_rail_water, StringIds::label_icons_road_water, StringIds::label_icons_rail_road_water, StringIds::label_icons_air_water, StringIds::label_icons_rail_air_water, StringIds::label_icons_road_air_water, StringIds::label_icons_rail_road_air_water, }; const auto label = enumValue(flags & StationFlags::allModes); return label_icons[label]; } // 0x00426D52 // used to return NodeMovementFlags on ebx std::optional<World::Pos3> getAirportMovementNodeLoc(const StationId stationId, uint8_t node) { auto* station = StationManager::get(stationId); auto tile = World::TileManager::get(station->airportStartPos); World::StationElement* elStation = nullptr; for (auto& el : tile) { elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != station->airportStartPos.z / 4) { elStation = nullptr; continue; } break; } if (elStation == nullptr) { return {}; } auto* airportObj = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementNodes = airportObj->getMovementNodes(); const auto& movementNode = movementNodes[node]; auto nodeOffset = Math::Vector::rotate(World::Pos2(movementNode.x, movementNode.y) - World::Pos2(16, 16), elStation->rotation()) + World::Pos2(16, 16); auto nodeLoc = World::Pos3{ nodeOffset.x, nodeOffset.y, movementNode.z } + station->airportStartPos; if (!movementNode.hasFlags(AirportMovementNodeFlags::taxiing)) { nodeLoc.z = station->airportStartPos.z + 255; if (!movementNode.hasFlags(AirportMovementNodeFlags::inFlight)) { nodeLoc.z = 30 * 32; } } return { nodeLoc }; } // 0x0048DBC2 // Iterates over all station elements of a track piece apply function `func` to each station element template<typename Func> static void forEachStationElement(const World::Pos3 pos, const uint8_t rotation, World::StationElement* firstElStation, Func&& func) { auto* firstElTrack = firstElStation->prev()->as<TrackElement>(); assert(firstElTrack != nullptr); if (firstElTrack == nullptr) { return; } auto& trackPieces = TrackData::getTrackPiece(firstElTrack->trackId()); for (auto& piece : trackPieces) { const auto trackLoc = pos + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto tile = TileManager::get(trackLoc); bool hasPassedSurface = false; for (auto& el : tile) { auto* elSurface = el.as<World::SurfaceElement>(); if (elSurface != nullptr) { hasPassedSurface = true; continue; } auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseHeight() != trackLoc.z) { continue; } auto* elTrack = elStation->prev()->as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->sequenceIndex() != piece.index) { continue; } if (elTrack->rotation() != rotation) { continue; } func(elStation, trackLoc, hasPassedSurface); } } } static bool isStationTrackConnected(const World::Pos3 connectTrackPos, const uint8_t connectRotation, const CompanyId owner, const StationId stationId) { auto tile = TileManager::get(connectTrackPos); for (auto& el : tile) { auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (!elTrack->hasStationElement()) { continue; } if (elTrack->owner() != owner) { continue; } auto* nextElStation = elTrack->next()->as<StationElement>(); if (nextElStation == nullptr) { continue; } if (nextElStation->isAiAllocated() || nextElStation->isGhost()) { continue; } if (nextElStation->stationId() != stationId) { continue; } uint16_t nextTad = (elTrack->trackId() << 3) | elTrack->rotation(); if (elTrack->sequenceIndex() == 0 && connectRotation == TrackData::getUnkTrack(nextTad).rotationBegin) { const auto& nextTrackPiece = TrackData::getTrackPiece(elTrack->trackId())[0]; if (elTrack->baseHeight() - nextTrackPiece.z == connectTrackPos.z) { return true; } } if (elTrack->isFlag6()) { nextTad |= (1U << 2); if (connectRotation == TrackData::getUnkTrack(nextTad).rotationBegin) { const auto& nextTrackPiece = TrackData::getTrackPiece(elTrack->trackId())[elTrack->sequenceIndex()]; const auto startBaseHeight = elTrack->baseHeight() - (nextTrackPiece.z + TrackData::getUnkTrack(nextTad).pos.z); if (startBaseHeight == connectTrackPos.z) { return true; } } } } return false; } // 0x0048D794 void sub_48D794(const Station& station) { for (auto i = 0U; i < station.stationTileSize; ++i) { auto pos = station.stationTiles[i]; const uint8_t rotation = pos.z & 0x3; pos.z = Numerics::floor2(pos.z, 4); auto* elStation = [&pos]() -> World::StationElement* { auto tile = TileManager::get(pos); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseHeight() != pos.z) { continue; } if (elStation->stationType() != StationType::trainStation) { break; } auto* elTrack = elStation->prev()->as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->sequenceIndex() != 0) { continue; } return elStation; } return nullptr; }(); if (elStation == nullptr) { continue; } // 0x0112C7AB bool isCovered = false; auto* stationObj = ObjectManager::get<TrainStationObject>(elStation->objectId()); // Also resets the station sequence index to 0 auto isStationElementCovered = [&isCovered](World::StationElement* elStation, const World::Pos3 pos, bool hasPassedSurface) { elStation->setSequenceIndex(0); isCovered |= [hasPassedSurface, elStation]() { if (!hasPassedSurface) { return true; } else { auto* elTrack = elStation->prev()->as<TrackElement>(); if (elTrack == nullptr) { return false; } if (elTrack->hasBridge()) { auto* bridgeObj = ObjectManager::get<BridgeObject>(elTrack->bridge()); if ((bridgeObj->flags & BridgeObjectFlags::hasRoof) != BridgeObjectFlags::none) { return true; } } if (elStation->isLast()) { return false; } auto* el = elStation->next(); do { if (el->baseZ() != elStation->baseZ()) { if (el->baseZ() - 4 < elStation->clearZ()) { return true; } } el = el->next(); } while (!el->isLast()); return false; } }(); Ui::ViewportManager::invalidate(pos, elStation->baseHeight(), elStation->clearHeight()); }; forEachStationElement(pos, rotation, elStation, isStationElementCovered); if (isCovered || stationObj->var_0B == 0) { continue; } if (stationObj->var_0B != 1) { auto* elTrack = elStation->prev()->as<TrackElement>(); if (elTrack == nullptr) { continue; } const uint16_t tad = (elTrack->trackId() << 3) | elTrack->rotation(); const auto& trackSize = World::TrackData::getUnkTrack(tad); const auto forwardTrackPos = pos + trackSize.pos; const auto forwardRotation = trackSize.rotationEnd; const auto forwardConnection = isStationTrackConnected(forwardTrackPos, forwardRotation, elTrack->owner(), elStation->stationId()); if (!forwardConnection) { continue; } auto backwardTrackPos = pos; const auto backwardRotation = kReverseRotation[trackSize.rotationBegin]; if (backwardRotation < 12) { backwardTrackPos += World::Pos3{ World::kRotationOffset[backwardRotation], 0 }; } const auto backwardConnection = isStationTrackConnected(backwardTrackPos, backwardRotation, elTrack->owner(), elStation->stationId()); if (!backwardConnection) { continue; } auto setStationSequenceIndex = [](World::StationElement* elStation, const World::Pos3 pos, bool) { elStation->setSequenceIndex(1); Ui::ViewportManager::invalidate(pos, elStation->baseHeight(), elStation->clearHeight()); }; forEachStationElement(pos, rotation, elStation, setStationSequenceIndex); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Station.h ```h #pragma once #include "LabelFrame.h" #include "Localisation/StringManager.h" #include "Map/Tile.h" #include "Speed.hpp" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Numerics.hpp> #include <cstdint> #include <limits> #include <optional> namespace OpenLoco { namespace Gfx { class DrawingContext; } namespace World { struct StationElement; } #pragma pack(push, 1) enum class StationCargoStatsFlags : uint8_t { none = 0U, // Is there a consumer of this cargo at this station. acceptedForConsumer = (1U << 0), // Can a producer (town building, industry) distribute cargo to // this station. acceptedFromProducer = (1U << 1), flag2 = (1U << 2), flag3 = (1U << 3), }; OPENLOCO_ENABLE_ENUM_OPERATORS(StationCargoStatsFlags); struct StationCargoStats { uint16_t quantity{}; // 0x2E StationId origin = StationId::null; // 0x30 StationCargoStatsFlags flags{}; // 0x32 uint8_t age{}; // 0x33 uint8_t rating{}; // 0x34 uint8_t enrouteAge{}; // 0x35 Speed16 vehicleSpeed{ 0 }; // 0x36 max speed of vehicle that transported the cargo uint8_t vehicleAge{}; // 0x38 age of the vehicle (car) that transported the cargo IndustryId industryId{}; // 0x39 uint8_t densityPerTile{}; // 0x3A amount of cargo visible per tile of station bool empty() const { return origin == StationId::null; } bool isAccepted() const { return (flags & StationCargoStatsFlags::acceptedForConsumer) != StationCargoStatsFlags::none; } void isAccepted(bool value) { flags = Numerics::setMask<StationCargoStatsFlags>(flags, StationCargoStatsFlags::acceptedForConsumer, value); } }; constexpr size_t kMaxCargoStats = 32; enum class StationType : uint8_t { trainStation = 0, roadStation, airport, docks, }; enum class StationFlags : uint16_t { none = 0U, transportModeRail = (1U << 0), transportModeRoad = (1U << 1), transportModeAir = (1U << 2), transportModeWater = (1U << 3), flag_4 = (1U << 4), flag_5 = (1U << 5), // isNotFullyCreated ?? like ghost will never have this set flag_6 = (1U << 6), flag_7 = (1U << 7), flag_8 = (1U << 8), allModes = StationFlags::transportModeRail | StationFlags::transportModeRoad | StationFlags::transportModeAir | StationFlags::transportModeWater, }; OPENLOCO_ENABLE_ENUM_OPERATORS(StationFlags); StringId getTransportIconsFromStationFlags(const StationFlags flags); struct CargoSearchState; enum class CatchmentFlags : uint8_t { flag_0 = 0U, flag_1 = 1U, }; // 0x004FEBD0 // Where: // - Q is the port origin // - P is the port // - X represents the border offsets // // X X // X Q P X // X P P X // X X constexpr std::array<World::TilePos2, 8> kPortBorderOffsets = { World::TilePos2{ -1, 0 }, World::TilePos2{ -1, 1 }, World::TilePos2{ 0, 2 }, World::TilePos2{ 1, 2 }, World::TilePos2{ 2, 1 }, World::TilePos2{ 2, 0 }, World::TilePos2{ 1, -1 }, World::TilePos2{ 0, -1 }, }; struct Station { StringId name = StringIds::null; // 0x00 coord_t x{}; // 0x02 coord_t y{}; // 0x04 coord_t z{}; // 0x06 LabelFrame labelFrame; // 0x08 CompanyId owner{}; // 0x28 uint8_t noTilesTimeout{}; // 0x29 measured in days StationFlags flags{}; // 0x2A TownId town{}; // 0x2C StationCargoStats cargoStats[kMaxCargoStats]; // 0x2E uint16_t stationTileSize{}; // 0x1CE World::Pos3 stationTiles[80]; // 0x1D0 Note: z coordinate also contains rotation so always floor uint8_t var_3B0{}; uint8_t var_3B1{}; uint8_t var_3B2{}; uint8_t airportRotation{}; // 0x3B3 World::Pos3 airportStartPos{}; // 0x3B4 uint32_t airportMovementOccupiedEdges{}; // 0x3BA uint8_t pad_3BE[0x3D2 - 0x3BE]{}; bool empty() const { return name == StringIds::null; } StationId id() const; void update(); uint32_t calcAcceptedCargo(CargoSearchState& cargoSearchState) const; char* getStatusString(char* buffer); bool updateCargo(); int32_t calculateCargoRating(const StationCargoStats& cargo) const; void updateLabel(); void invalidate(); void invalidateWindow(); void deliverCargoToStation(const uint8_t cargoType, const uint8_t cargoQuantity); void deliverCargoToTown(uint8_t cargoType, uint16_t cargoQuantity); void updateCargoDistribution(); private: void updateCargoAcceptance(); void alertCargoAcceptanceChange(uint32_t oldCargoAcc, uint32_t newCargoAcc); }; static_assert(sizeof(Station) == 0x3D2); #pragma pack(pop) void setCatchmentDisplay(const Station* station, const CatchmentFlags flags); bool isWithinCatchmentDisplay(const World::Pos2 pos); struct PotentialCargo { uint32_t accepted; uint32_t produced; }; PotentialCargo calcAcceptedCargoTrainStationGhost(const Station* ghostStation, const World::Pos2& location, const uint32_t filter); PotentialCargo calcAcceptedCargoAirportGhost(const Station* ghostStation, const uint8_t type, const World::Pos2& location, const uint8_t rotation, const uint32_t filter); PotentialCargo calcAcceptedCargoDockGhost(const Station* ghostStation, const World::Pos2& location, const uint32_t filter); PotentialCargo calcAcceptedCargoAi(const World::TilePos2 minPos, const World::TilePos2 maxPos); void sub_491C6F(const uint8_t type, const World::Pos2& pos, const uint8_t rotation, const CatchmentFlags flag); void sub_491D20(const World::Pos2& pos, const CatchmentFlags flag); void sub_491BF5(const World::Pos2& pos, const CatchmentFlags flag); void recalculateStationCenter(const StationId stationId); void recalculateStationModes(const StationId stationId); void addTileToStation(const StationId stationId, const World::Pos3& pos, uint8_t rotation); void removeTileFromStation(const StationId stationId, const World::Pos3& pos, uint8_t rotation); void removeTileFromStationAndRecalcCargo(const StationId stationId, const World::Pos3& pos, uint8_t rotation); World::StationElement* getStationElement(const World::Pos3& pos); std::optional<World::Pos3> getAirportMovementNodeLoc(const StationId stationId, uint8_t node); void sub_48D794(const Station& station); void drawStationName(Gfx::DrawingContext& drawingCtx, const Station& station, uint8_t zoom, bool isHovered); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/StationManager.cpp ```cpp #include "StationManager.h" #include "CompanyManager.h" #include "Config.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "GameStateFlags.h" #include "IndustryManager.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "MessageManager.h" #include "Objects/IndustryObject.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "TownManager.h" #include "Ui/Window.h" #include "Ui/WindowManager.h" #include "Ui/Windows/Construction/Construction.h" #include "Vehicles/OrderManager.h" #include "Vehicles/VehicleManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Vector.hpp> #include <bitset> #include <numeric> #include <sfl/static_vector.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Ui; using namespace OpenLoco::World; namespace OpenLoco::StationManager { constexpr auto kStationDistanceLimit = 8 * World::kTileSize; static auto& rawStations() { return getGameState().stations; } // 0x0048B1D8 void reset() { for (auto& station : rawStations()) { station.name = StringIds::null; } Ui::Windows::Station::reset(); } FixedVector<Station, Limits::kMaxStations> stations() { return FixedVector(rawStations()); } Station* get(StationId id) { auto index = (size_t)id; if (index < Limits::kMaxStations) { return &rawStations()[index]; } return nullptr; } // 0x0048B1FA void update() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded) && !SceneManager::isEditorMode()) { const auto id = StationId(ScenarioManager::getScenarioTicks() & 0x3FF); auto station = get(id); if (station != nullptr && !station->empty()) { station->update(); } } } // 0x0048DDC3 void updateLabels() { for (auto& station : stations()) { station.updateLabel(); } } // 0x0048B244 void updateDaily() { for (auto& town : TownManager::towns()) { town.flags &= ~TownFlags::ratingAdjusted; } for (auto& station : stations()) { if (station.stationTileSize == 0) { station.noTilesTimeout++; if (station.noTilesTimeout == 5 && CompanyManager::isPlayerCompany(station.owner)) { companyEmotionEvent(station.owner, Emotion::disgusted); } if (station.noTilesTimeout >= 10) { Ui::Windows::Construction::Station::sub_49E1F1(station.id()); station.invalidate(); deallocateStation(station.id()); } } else { station.noTilesTimeout = 0; } if (station.updateCargo()) { auto town = TownManager::get(station.town); if (town != nullptr && (town->flags & TownFlags::ratingAdjusted) == TownFlags::none) { town->flags |= TownFlags::ratingAdjusted; town->adjustCompanyRating(station.owner, 1); } } } } // 0x048F988 StringId generateNewStationName(StationId stationId, TownId townId, World::Pos3 position, uint8_t mode) { enum StationName : uint8_t { townDefault, townNorth, townSouth, townEast, townWest, townCentral, townTransfer, townHalt, townValley, townHeights, townWoods, townLakeside, townExchange, townAirport, townOilfield, townMines, townDocks, townAnnexe, townSidings, townBranch, upperTown, lowerTown, townHeliport, townForest, townJunction, townCross, townViews, townOrd1, townOrd2, townOrd3, townOrd4, townOrd5, townOrd6, townOrd7, townOrd8, townOrd9, townOrd10, townOrd11, townOrd12, townOrd13, townOrd14, townOrd15, townOrd16, townOrd17, townOrd18, townOrd19, townOrd20, }; // Bit mask for station names already used in the current town. std::bitset<27> realNamesInUse{}; // ebp std::bitset<20> ordinalNamesInUse{}; // edi for (auto& station : stations()) { if (!StringManager::isTownName(station.name)) { continue; } auto nameKey = StringManager::fromTownName(station.name) - StringIds::station_town; if (nameKey > StationName::townOrd20) { continue; } if (station.town != townId) { continue; } if (nameKey < StationName::townOrd1) { realNamesInUse.set(nameKey, true); } else { ordinalNamesInUse.set(nameKey - StationName::townOrd1, true); } } if (mode == 1) { // Airport if (!realNamesInUse.test(StationName::townAirport)) { return StringManager::toTownName(StringIds::station_town_airport); } } else if (mode == 2) { // Heliport if (!realNamesInUse.test(StationName::townHeliport)) { return StringManager::toTownName(StringIds::station_town_heliport); } } else if (mode == 3) { // 0x0048FA00 auto tile = TileManager::get(World::Pos2(position.x, position.y)); auto* surface = tile.surface(); if (surface != nullptr && surface->water() == 0) { // Docks if (!realNamesInUse.test(StationName::townDocks)) { return StringManager::toTownName(StringIds::station_town_docks); } } } // 0x0048FA41 if (IndustryManager::industryNearPosition(position, IndustryObjectFlags::oilfieldStationName)) { if (!realNamesInUse.test(StationName::townOilfield)) { return StringManager::toTownName(StringIds::station_town_oilfield); } } if (IndustryManager::industryNearPosition(position, IndustryObjectFlags::minesStationName)) { if (!realNamesInUse.test(StationName::townMines)) { return StringManager::toTownName(StringIds::station_town_mines); } } // 0x0048FA91 auto numSurroundingWaterTiles = TileManager::countSurroundingWaterTiles(position); if (numSurroundingWaterTiles >= 24) { auto tile = TileManager::get(position); auto* surface = tile.surface(); if (surface != nullptr && surface->water() == 0) { // Lakeside if (!realNamesInUse.test(StationName::townLakeside)) { return StringManager::toTownName(StringIds::station_town_lakeside); } } } // 0x0048FAEB auto numSurroundingTrees = TileManager::countSurroundingTrees(position); if (numSurroundingTrees > 40) { // Forest if (!realNamesInUse.test(StationName::townForest)) { return StringManager::toTownName(StringIds::station_town_forest); } } else if (numSurroundingTrees > 20) { // Woods if (!realNamesInUse.test(StationName::townWoods)) { return StringManager::toTownName(StringIds::station_town_woods); } } // 0x0048FB29 { auto* town = TownManager::get(townId); auto tile = TileManager::get(World::Pos2(town->x, town->y)); auto* surface = tile.surface(); if (surface != nullptr) { auto townHeightDiff = (position.z / 4) - surface->baseZ(); if (townHeightDiff > 20) { // Heights if (!realNamesInUse.test(StationName::townHeights)) { return StringManager::toTownName(StringIds::station_town_heights); } } else if (townHeightDiff < -20) { // Valley if (!realNamesInUse.test(StationName::townValley)) { return StringManager::toTownName(StringIds::station_town_valley); } } } } // 0x0048FB8B if (!realNamesInUse.test(StationName::townDefault)) { return StringManager::toTownName(StringIds::station_town); } auto town = TownManager::get(townId); { auto manhattanDistance = Math::Vector::manhattanDistance2D(position, World::Pos2{ town->x, town->y }); if (manhattanDistance / World::kTileSize <= 9) { // Central if (!realNamesInUse.test(StationName::townCentral)) { return StringManager::toTownName(StringIds::station_town_central); } } } if (position.x <= town->x && position.y <= town->y) { // North if (!realNamesInUse.test(StationName::townNorth)) { return StringManager::toTownName(StringIds::station_town_north); } } if (position.x >= town->x && position.y >= town->y) { // South if (!realNamesInUse.test(StationName::townSouth)) { return StringManager::toTownName(StringIds::station_town_south); } } if (position.x <= town->x && position.y >= town->y) { // East if (!realNamesInUse.test(StationName::townEast)) { return StringManager::toTownName(StringIds::station_town_east); } } if (position.x >= town->x && position.y <= town->y) { // West if (!realNamesInUse.test(StationName::townWest)) { return StringManager::toTownName(StringIds::station_town_west); } } // Additional names to try static constexpr std::pair<const StationName, const StringId> additionalNamePairs[] = { { StationName::townTransfer, StringIds::station_town_transfer }, { StationName::townHalt, StringIds::station_town_halt }, { StationName::townAnnexe, StringIds::station_town_annexe }, { StationName::townSidings, StringIds::station_town_sidings }, { StationName::townBranch, StringIds::station_town_branch }, { StationName::townJunction, StringIds::station_town_junction }, { StationName::townCross, StringIds::station_town_cross }, { StationName::townViews, StringIds::station_town_views }, }; for (auto [name, stringId] : additionalNamePairs) { if (!realNamesInUse.test(name)) { return StringManager::toTownName(stringId); } } // Ordinal names to try static constexpr std::pair<const StationName, const StringId> ordinalNamePairs[] = { { StationName::townOrd1, StringIds::station_town_ord_1 }, { StationName::townOrd2, StringIds::station_town_ord_2 }, { StationName::townOrd3, StringIds::station_town_ord_3 }, { StationName::townOrd4, StringIds::station_town_ord_4 }, { StationName::townOrd5, StringIds::station_town_ord_5 }, { StationName::townOrd6, StringIds::station_town_ord_6 }, { StationName::townOrd7, StringIds::station_town_ord_7 }, { StationName::townOrd8, StringIds::station_town_ord_8 }, { StationName::townOrd9, StringIds::station_town_ord_9 }, { StationName::townOrd10, StringIds::station_town_ord_10 }, { StationName::townOrd11, StringIds::station_town_ord_11 }, { StationName::townOrd12, StringIds::station_town_ord_12 }, { StationName::townOrd13, StringIds::station_town_ord_13 }, { StationName::townOrd14, StringIds::station_town_ord_14 }, { StationName::townOrd15, StringIds::station_town_ord_15 }, { StationName::townOrd16, StringIds::station_town_ord_16 }, { StationName::townOrd17, StringIds::station_town_ord_17 }, { StationName::townOrd18, StringIds::station_town_ord_18 }, { StationName::townOrd19, StringIds::station_town_ord_19 }, { StationName::townOrd20, StringIds::station_town_ord_20 }, }; for (auto [name, stringId] : ordinalNamePairs) { if (!ordinalNamesInUse.test(name - StationName::townOrd1)) { return StringManager::toTownName(stringId); } } // Default to an ordinal string instead, e.g. 'Station 42'. char stationName[256] = ""; FormatArguments args{}; args.push(stationId); StringManager::formatString(stationName, StringIds::station_name_ordinal, args); return StringManager::userStringAllocate(stationName, true); } // 0x0049088B void zeroUnused() { for (auto& station : rawStations()) { if (station.empty()) { // Zero unused station station = {}; } else { // Zero unused station tiles for (auto i = station.stationTileSize; i < std::size(station.stationTiles); i++) { station.stationTiles[i] = {}; } } } } using CargoStations = sfl::static_vector<std::pair<StationId, uint8_t>, 16>; static CargoStations findStationsForCargoType(const uint8_t cargoType, const World::Pos2& pos, const World::TilePos2& size) { const auto initialLoc = World::toTileSpace(pos) - TilePos2(4, 4); const auto catchmentSize = size + TilePos2(8, 8); CargoStations foundStations; for (TilePos2 searchOffset{ 0, 0 }; searchOffset.y < catchmentSize.y; ++searchOffset.y) { for (; searchOffset.x < catchmentSize.x; ++searchOffset.x) { const auto searchLoc = initialLoc + searchOffset; if (!World::validCoords(searchLoc)) { continue; } const auto tile = TileManager::get(searchLoc); for (const auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->isAiAllocated() || elStation->isGhost()) { continue; } if (foundStations.size() > 15) { break; } auto res = std::find_if(foundStations.begin(), foundStations.end(), [stationId = elStation->stationId()](const std::pair<StationId, uint8_t>& item) { return item.first == stationId; }); if (res != foundStations.end()) { continue; } auto* station = get(elStation->stationId()); if (station == nullptr) { continue; } if ((station->cargoStats[cargoType].flags & StationCargoStatsFlags::acceptedFromProducer) == StationCargoStatsFlags::none) { continue; } foundStations.push_back(std::make_pair(elStation->stationId(), station->cargoStats[cargoType].rating)); } } searchOffset.x = 0; } return foundStations; } static uint16_t deliverCargoToStations(const CargoStations& foundStations, const uint8_t cargoType, const uint8_t cargoQty) { const auto ratingTotal = std::accumulate(foundStations.begin(), foundStations.end(), 0, [](const int32_t a, const std::pair<StationId, uint8_t>& b) { return a + b.second * b.second; }); if (ratingTotal == 0) { return 0; } uint16_t cargoQtyDelivered = 0; for (const auto& [stationId, rating] : foundStations) { auto* station = get(stationId); if (station == nullptr) { continue; } const auto defaultShare = (rating * rating * cargoQty) / ratingTotal; const auto alternateShare = (rating * cargoQty) / 256; auto share = std::min(defaultShare, alternateShare); if (rating > 66) { share++; } cargoQtyDelivered += share; station->deliverCargoToStation(cargoType, share); } return std::min<uint16_t>(cargoQtyDelivered, cargoQty); } // 0x0042F2FE uint16_t deliverCargoToNearbyStations(const uint8_t cargoType, const uint8_t cargoQty, const World::Pos2& pos, const World::TilePos2& size) { const auto foundStations = findStationsForCargoType(cargoType, pos, size); if (foundStations.empty()) { return 0; } return deliverCargoToStations(foundStations, cargoType, cargoQty); } // 0x0042F2BF uint16_t deliverCargoToStations(std::span<const StationId> stations, const uint8_t cargoType, const uint8_t cargoQty) { CargoStations foundStations; for (auto stationId : stations) { auto* station = get(stationId); if (station == nullptr) { continue; } foundStations.push_back(std::make_pair(stationId, station->cargoStats[cargoType].rating)); } if (foundStations.empty()) { return 0; } return deliverCargoToStations(foundStations, cargoType, cargoQty); } // 0x0048FEF4 bool exceedsStationSize(Station& station, World::Pos3 pos) { if (Config::get().disableStationSizeLimit) { return false; } auto centreTile = World::Pos2(pos.x + World::kTileSize / 2, pos.y + World::kTileSize / 2); auto stationCentre = World::Pos2(station.x, station.y); auto distance = Math::Vector::chebyshevDistance2D(centreTile, stationCentre); return distance > kStationDistanceLimit; } // 0x0048F8A0 StationId allocateNewStation(const World::Pos3 pos, const CompanyId owner, const uint8_t mode) { if (!World::validCoords(pos)) { GameCommands::setErrorTitle(StringIds::off_edge_of_map); return StationId::null; } // Find first available station for (auto& station : rawStations()) { if (!station.empty()) { continue; } auto maybeTown = TownManager::getClosestTownAndDensity(pos); if (!maybeTown) { GameCommands::setErrorTitle(StringIds::town_must_be_built_first); return StationId::null; } station.town = maybeTown->first; station.owner = owner; station.name = generateNewStationName(station.id(), station.town, pos, mode); // Reset cargo stats for (auto& stats : station.cargoStats) { stats.quantity = 0; stats.origin = StationId::null; stats.flags = StationCargoStatsFlags::none; stats.rating = 150; stats.densityPerTile = 0; } station.x = pos.x; station.y = pos.y; station.z = pos.z; station.flags = StationFlags::flag_5; station.stationTileSize = 0; station.noTilesTimeout = 0; station.var_3B0 = 0; station.var_3B1 = 0; return station.id(); } GameCommands::setErrorTitle(StringIds::too_many_stations_in_game); return StationId::null; } // 0x0048F850 static void removeStationFromCargoStats(const StationId removedStationId) { for (auto& station : stations()) { for (auto& stats : station.cargoStats) { if (stats.origin == removedStationId) { stats.origin = StationId::null; stats.quantity = 0; Ui::WindowManager::invalidate(Ui::WindowType::station, enumValue(station.id())); } } } } // 0x0048F7D1 void deallocateStation(const StationId stationId) { WindowManager::close(WindowType::station, WindowNumber_t(stationId)); auto station = get(stationId); if (station == nullptr) { return; } if ((station->flags & StationFlags::flag_5) == StationFlags::none) { auto town = TownManager::get(station->town); if (town != nullptr) { town->numStations--; WindowManager::invalidate(WindowType::town, WindowNumber_t(station->town)); } } Windows::StationList::removeStationFromList(stationId); Vehicles::OrderManager::removeOrdersForStation(stationId); removeStationFromCargoStats(stationId); VehicleManager::resetIfHeadingForStation(stationId); MessageManager::removeAllSubjectRefs(enumValue(stationId), MessageItemArgumentType::station); StringManager::emptyUserString(station->name); station->name = StringIds::null; } StationId findNearbyEmptyStation(const World::Pos3 pos, const CompanyId companyId, const int16_t currentMinDistanceStation) { // After removing a station the station is still available for a time but left empty // this function will find these empty stations so that a new station can reuse the // empty station and its name. auto minDistanceStation = StationId::null; auto minDistance = currentMinDistanceStation; for (const auto& station : StationManager::stations()) { if (station.stationTileSize != 0) { continue; } if (station.owner != companyId) { continue; } const auto distance = Math::Vector::chebyshevDistance2D(World::Pos2{ station.x, station.y }, pos); auto distDiffZ = std::abs(station.z - pos.z); if (distDiffZ > kMaxStationNearbyDistance) { continue; } if (distance > kMaxStationNearbyDistance) { continue; } if (distance < minDistance) { minDistance = distance; minDistanceStation = station.id(); } } return minDistanceStation; } // 0x004901B0 NearbyStation findNearbyStation(World::Pos3 pos, CompanyId companyId) { const auto tilePosA = World::toTileSpace(pos) - World::TilePos2(2, 2); const auto tilePosB = World::toTileSpace(pos) + World::TilePos2(2, 2); auto minDistanceStation = StationId::null; auto minDistance = std::numeric_limits<int16_t>::max(); bool isPhysicallyAttached = false; for (const auto& tilePos : World::getClampedRange(tilePosA, tilePosB)) { const auto tile = World::TileManager::get(tilePos); for (const auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->isGhost()) { continue; } auto* station = StationManager::get(elStation->stationId()); if (station->owner != companyId) { continue; } const auto distance = Math::Vector::chebyshevDistance2D(World::toWorldSpace(tilePos), pos); if (distance < minDistance) { auto distDiffZ = std::abs(elStation->baseHeight() - pos.z); if (distDiffZ > kMaxStationNearbyDistance) { continue; } minDistance = distance + distDiffZ / 2; if (minDistance <= kMaxStationNearbyDistance) { isPhysicallyAttached = true; } minDistanceStation = elStation->stationId(); } } } const auto nearbyEmptyStation = findNearbyEmptyStation(pos, companyId, minDistance); if (nearbyEmptyStation != StationId::null) { return NearbyStation{ nearbyEmptyStation, isPhysicallyAttached }; } else { return NearbyStation{ minDistanceStation, isPhysicallyAttached }; } } } OpenLoco::StationId OpenLoco::Station::id() const { // TODO check if this is stored in station structure // otherwise add it when possible auto index = (size_t)(this - &StationManager::rawStations()[0]); if (index >= Limits::kMaxStations) { return StationId::null; } return StationId(index); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/StationManager.h ```h #pragma once #include "Engine/Limits.h" #include "Station.h" #include <OpenLoco/Core/LocoFixedVector.hpp> #include <array> #include <cstddef> #include <span> namespace OpenLoco::StationManager { // If it exceeds this distance, it will not be considered a nearby station constexpr int16_t kMaxStationNearbyDistance = 64; void reset(); FixedVector<Station, Limits::kMaxStations> stations(); Station* get(StationId id); void update(); void updateLabels(); void updateDaily(); StringId generateNewStationName(StationId stationId, TownId townId, World::Pos3 position, uint8_t mode); void zeroUnused(); uint16_t deliverCargoToNearbyStations(const uint8_t cargoType, const uint8_t cargoQty, const World::Pos2& pos, const World::TilePos2& size); uint16_t deliverCargoToStations(std::span<const StationId> stations, const uint8_t cargoType, const uint8_t cargoQty); bool exceedsStationSize(Station& station, World::Pos3 pos); StationId allocateNewStation(const World::Pos3 pos, const CompanyId owner, const uint8_t mode); void deallocateStation(const StationId stationId); struct NearbyStation { StationId id; bool isPhysicallyAttached; }; NearbyStation findNearbyStation(World::Pos3 pos, CompanyId companyId); // Subfunction of findNearbyStation (For create airport) StationId findNearbyEmptyStation(const World::Pos3 pos, const CompanyId companyId, const int16_t currentMinDistanceStation); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Town.cpp ```cpp #include "Town.h" #include "Config.h" #include "Date.h" #include "GameCommands/Buildings/CreateBuilding.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/CreateRoad.h" #include "GameCommands/Terraform/LowerLand.h" #include "GameCommands/Terraform/RaiseLand.h" #include "GameState.h" #include "Graphics/RenderTarget.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TreeElement.h" #include "Objects/BuildingObject.h" #include "Objects/ObjectManager.h" #include "Objects/ObjectUtils.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/StreetLightObject.h" #include "Random.h" #include "TownManager.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <algorithm> #include <bit> using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco { constexpr auto kMaxTownBridgeLength = 15U; bool Town::empty() const { return name == StringIds::null; } /** * 0x0049742F * Update town * * @param this @<esi> */ void Town::update() { recalculateSize(); if (Config::get().townGrowthDisabled) { return; } static constexpr std::array<uint8_t, 12> kBuildSpeedToGrowthPerTick = { 0, 1, 3, 5, 7, 9, 12, 16, 22, 0, 0, 0 }; auto growthPerTick = kBuildSpeedToGrowthPerTick[this->buildSpeed]; if (growthPerTick == 0 || (growthPerTick == 1 && (gPrng1().randNext() & 7))) { grow(TownGrowFlags::buildInitialRoad | TownGrowFlags::roadUpdate | TownGrowFlags::neutralRoadTakeover); } else { for (int32_t counter = 0; counter < growthPerTick; ++counter) { grow(TownGrowFlags::buildInitialRoad | TownGrowFlags::roadUpdate | TownGrowFlags::neutralRoadTakeover | TownGrowFlags::allowRoadExpansion | TownGrowFlags::allowRoadBranching | TownGrowFlags::constructBuildings); } } } // 0x004FF6F4 static constexpr std::array<Gfx::Font, 4> kZoomToTownFonts = { Gfx::Font::medium_bold, Gfx::Font::medium_bold, Gfx::Font::medium_normal, Gfx::Font::medium_normal, }; void Town::drawLabel(Gfx::DrawingContext& drawingCtx, const Gfx::RenderTarget& rt) { if (!labelFrame.contains(rt.getDrawableRect(), rt.zoomLevel)) { return; } auto tr = Gfx::TextRenderer(drawingCtx); char buffer[512]{}; StringManager::formatString(buffer, name); tr.setCurrentFont(kZoomToTownFonts[rt.zoomLevel]); auto point = Ui::Point(labelFrame.left[rt.zoomLevel] + 1, labelFrame.top[rt.zoomLevel] + 1); tr.drawString(point, AdvancedColour(Colour::white).outline(), buffer); } // 0x00497616 void Town::updateLabel() { char buffer[256]{}; StringManager::formatString(buffer, 256, name); auto height = TileManager::getHeight(Pos2(x, y)); auto pos = Pos3(x + kTileSize / 2, y + kTileSize / 2, height.landHeight); auto rotated = World::gameToScreen(pos, Ui::WindowManager::getCurrentRotation()); rotated.y -= 48; for (auto zoomLevel = 0; zoomLevel < 4; zoomLevel++) { auto font = kZoomToTownFonts[zoomLevel]; auto nameWidth = (Gfx::TextRenderer::getStringWidth(font, buffer) + 2) << zoomLevel; auto nameHeight = 11 << zoomLevel; // was a lookup on 0x4FF6FC; same for all zoom levels auto xOffset = rotated.x - (nameWidth / 2); auto yOffset = rotated.y - (nameHeight / 2); labelFrame.left[zoomLevel] = xOffset >> zoomLevel; labelFrame.right[zoomLevel] = (xOffset + nameWidth) >> zoomLevel; labelFrame.top[zoomLevel] = yOffset >> zoomLevel; labelFrame.bottom[zoomLevel] = (yOffset + nameHeight) >> zoomLevel; } } // 0x0049749B void Town::updateMonthly() { // Scroll history if (historySize == std::size(history)) { for (size_t i = 0; i < std::size(history) - 1; i++) { history[i] = history[i + 1]; } } else { historySize++; } // Compute population growth. uint32_t popSteps = std::max<int32_t>(population - historyMinPopulation, 0) / 50; uint32_t popGrowth = 0; while (popSteps > 255) { popSteps -= 20; popGrowth += 1000; } // Any population growth to account for? if (popGrowth != 0) { historyMinPopulation += popGrowth; uint8_t offset = (popGrowth / 50) & 0xFF; for (uint8_t i = 0; i < historySize; i++) { int16_t newHistory = history[i] - offset; history[i] = newHistory >= 0 ? static_cast<uint8_t>(newHistory) : 0; } } // Write new history point. auto histIndex = std::clamp<int32_t>(historySize - 1, 0, std::size(history)); history[histIndex] = popSteps & 0xFF; // Find historical maximum population. uint8_t maxPopulation = 0; for (int i = 0; i < historySize; i++) { maxPopulation = std::max(maxPopulation, history[i]); } int32_t popOffset = historyMinPopulation; while (maxPopulation <= 235 && popOffset > 0) { maxPopulation += 20; popOffset -= 1000; } popOffset -= historyMinPopulation; if (popOffset != 0) { popOffset = -popOffset; historyMinPopulation -= popOffset; popOffset /= 50; for (int i = 0; i < historySize; i++) { history[i] += popOffset; } } // Work towards computing new build speed. // will be the smallest of the influence cargo delivered to the town // i.e. to get maximum growth max of the influence cargo must be delivered // every update. If no influence cargo the grows at max rate uint16_t minCargoDelivered = std::numeric_limits<uint16_t>::max(); uint32_t cargoFlags = cargoInfluenceFlags; while (cargoFlags != 0) { uint32_t cargoId = Numerics::bitScanForward(cargoFlags); cargoFlags &= ~(1 << cargoId); minCargoDelivered = std::min(minCargoDelivered, monthlyCargoDelivered[cargoId]); } // Compute build speed (1=slow build speed, 4=fast build speed) buildSpeed = std::clamp((minCargoDelivered / 100) + 1, 1, 4); // Reset all monthlyCargoDelivered intermediaries to zero. memset(&monthlyCargoDelivered, 0, sizeof(monthlyCargoDelivered)); } void Town::adjustCompanyRating(CompanyId cid, int amount) { companiesWithRating |= (1 << enumValue(cid)); companyRatings[enumValue(cid)] = std::clamp( companyRatings[enumValue(cid)] + amount, kMinCompanyRating, kMaxCompanyRating); } // 0x004FF714 constexpr uint32_t _populations[]{ 0, 150, 500, 2500, 8000 }; /** * 0x004975E0 * Recalculate size * * @param this @<esi> */ void Town::recalculateSize() { auto newSize = enumValue(size); if (size < TownSize::metropolis && populationCapacity >= _populations[enumValue(size) + 1]) { newSize++; } else if (size != TownSize::hamlet && populationCapacity + 100 < _populations[enumValue(size)]) { newSize--; } if (static_cast<TownSize>(newSize) != size) { size = static_cast<TownSize>(newSize); Ui::WindowManager::invalidate(Ui::WindowType::townList); } } // 0x00497F1F static std::optional<uint8_t> getIdealTownRoadId(const Town& town) { struct Res { uint8_t roadObjId; // dl TownSize foundSize; // cl }; std::optional<Res> findResult; for (uint8_t roadObjId = 0; roadObjId < ObjectManager::getMaxObjects(ObjectType::road); ++roadObjId) { auto* roadObj = ObjectManager::get<RoadObject>(roadObjId); if (roadObj == nullptr) { continue; } if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { continue; } if (roadObj->hasFlags(RoadObjectFlags::isOneWay)) { continue; } if (findResult.has_value()) { bool setNewFound = false; if (roadObj->targetTownSize == town.size) { setNewFound = true; } else { if (roadObj->targetTownSize < town.size) { if (findResult->foundSize > town.size || roadObj->targetTownSize >= findResult->foundSize) { setNewFound = true; } } else { if (findResult->foundSize > town.size && roadObj->targetTownSize < findResult->foundSize) { setNewFound = true; } } } if (!setNewFound) { continue; } } findResult = Res{ roadObjId, roadObj->targetTownSize }; } if (findResult.has_value()) { return findResult->roadObjId; } return std::nullopt; } struct RoadInformation { CompanyId owner; // bl uint8_t roadObjId; // bh bool isStationRoadEnd; // ebx >> 23 std::optional<uint8_t> streetLightStyle; // ebx >> 16 && ebx >> 24 }; // 0x00498D21 // pos : ax, cx, dx // rotation : bl // return : flags Carry == found road static bool sub_498D21(const World::Pos3 pos, const uint8_t rotation) { if (!World::validCoords(pos)) { return false; } auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != pos.z) { continue; } if (!(getGameState().roadObjectIdIsNotTram & (1U << elRoad->roadObjectId()))) { continue; } if (elRoad->roadId() != 0) { continue; } if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } if (rotation == elRoad->rotation() || (rotation ^ (1U << 1)) == elRoad->rotation()) { return true; } } return false; } // 0x0042CEBF // year : ax // dx : dx // largeTile : bl // unk1 : 525D24 // targetHeight : esi // return : ebp static sfl::static_vector<uint8_t, ObjectManager::getMaxObjects(ObjectType::building)> sub_42CEBF(uint16_t year, uint16_t dx, bool largeTile, uint32_t unk1, uint16_t targetHeight) { sfl::static_vector<uint8_t, ObjectManager::getMaxObjects(ObjectType::building)> potentialBuildings; for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::building); ++i) { auto* buildingObj = ObjectManager::get<BuildingObject>(i); if (buildingObj == nullptr) { continue; } if (buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { continue; } if (!(buildingObj->generatorFunction & (1U << dx))) { continue; } if (year < buildingObj->designedYear || year > buildingObj->obsoleteYear) { continue; } if (largeTile != buildingObj->hasFlags(BuildingObjectFlags::largeTile)) { continue; } if (buildingObj->var_AC != 0xFFU) { if (!(unk1 & (1U << buildingObj->var_AC))) { continue; } } for (auto j = 0U; j < buildingObj->numVariations; ++j) { uint16_t height = 0; const auto parts = buildingObj->getBuildingParts(j); const auto partHeights = buildingObj->getBuildingPartHeights(); for (const auto part : parts) { height += partHeights[part]; } if (height <= targetHeight) { potentialBuildings.push_back(i); break; } } } return potentialBuildings; } // 0x004F6CCC // index with tad side doesn't matter // Note: only valid for straight and very small curves static constexpr std::array<uint8_t, 80> kRoadTadConnectionEdge = { 0b0101, // straight rotation 0 side 0 0b1010, // straight rotation 1 side 0 0b0101, // straight rotation 2 side 0 0b1010, // straight rotation 3 side 0 0b0101, // straight rotation 0 side 1 0b1010, // straight rotation 1 side 1 0b0101, // straight rotation 2 side 1 0b1010, // straight rotation 3 side 1 0b1100, // left curve very small rotation 0 side 0 0b1001, 0b0011, 0b0110, 0b1100, // left curve very small rotation 0 side 1 0b1001, 0b0011, 0b0110, 0b0110, // right curve very small rotation 0 side 0 0b1100, 0b1001, 0b0011, 0b0110, // right curve very small rotation 0 side 1 0b1100, 0b1001, 0b0011, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; // 0x00498D9A // pos : ax, cx, dx // edge : ebx (must be below 32) // return : flags Carry == found road static bool sub_498D9A(const World::Pos3 pos, uint8_t edge) { if (!World::validCoords(pos)) { return false; } assert(edge < 32); auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != pos.z) { continue; } if (!(getGameState().roadObjectIdIsNotTram & (1U << elRoad->roadObjectId()))) { continue; } if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } const uint16_t tad = (elRoad->roadId() << 3) | elRoad->rotation(); if (kRoadTadConnectionEdge[tad] & (1U << edge)) { return true; } } return false; } static constexpr std::array<uint8_t, 8> k4F92A6 = { 1, 1, 2, 2, 1, 3, 1, 1, }; // 0x0042DB35 // Part of calculating the max height clearance for a new building on this tile // A collision in this function means that the building/obstacle will not be removed // Optionally `allowBuildingUpdate` ignores buildings that are old and not headquarters (to allow for their removal) static World::TileClearance::ClearFuncResult getBuildingMaxHeightClearFunc(World::TileElement& el, uint8_t baseZ, uint8_t& minZDiff, bool allowBuildingUpdate) { auto* elTree = el.as<World::TreeElement>(); auto* elBuilding = el.as<World::BuildingElement>(); if (elTree != nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } else if (elBuilding != nullptr) { if (!allowBuildingUpdate) { return World::TileClearance::ClearFuncResult::collision; } if (!elBuilding->isConstructed()) { return World::TileClearance::ClearFuncResult::collision; } auto* buildingObj = ObjectManager::get<BuildingObject>(elBuilding->objectId()); if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters)) { return World::TileClearance::ClearFuncResult::collision; } if (elBuilding->age() > 30) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; } else { const auto diff = el.baseZ() - baseZ; if (diff <= 0) { return World::TileClearance::ClearFuncResult::collision; } minZDiff = std::min<uint8_t>(minZDiff, diff); return World::TileClearance::ClearFuncResult::noCollision; } } // 0x0042D9FA // If 0 then no new building can be created here // pos : (ax, cx, dx) // isLargeTile : bh bit 0 // allowBuildingUpdate : bh bit 2 // return maxHeightOfBuilding: ebp static int16_t getMaxHeightOfNewBuilding(const World::Pos3 pos, bool isLargeTile, bool allowBuildingUpdate) { auto offsets = getBuildingTileOffsets(isLargeTile); int32_t maxHeightDiff = 0; for (auto& offset : offsets) { const auto loc = World::Pos2{ pos } + offset.pos; if (!World::validCoords(loc)) { continue; } const auto elSurface = World::TileManager::get(loc).surface(); const auto heightDiff = std::abs(elSurface->baseHeight() - pos.z); maxHeightDiff = std::max(heightDiff, maxHeightDiff); } const auto smallMaxHeightDiff = maxHeightDiff / World::kSmallZStep; if (smallMaxHeightDiff > 8) { return 0; } uint8_t minClear = 0xFFU; for (auto& offset : offsets) { const auto loc = World::Pos2{ pos } + offset.pos; if (!World::validCoords(loc)) { return 0; } const auto elSurface = World::TileManager::get(loc).surface(); const auto minZ = std::min(elSurface->baseHeight(), pos.z) / World::kSmallZStep; World::QuarterTile qt(0xF, 0xF); auto clearFunc = [baseZ = pos.z / World::kSmallZStep, &minClear, allowBuildingUpdate](TileElement& el) { return getBuildingMaxHeightClearFunc(el, baseZ, minClear, allowBuildingUpdate); }; if (!World::TileClearance::applyClearAtStandardHeight(loc, minZ, 255, qt, clearFunc)) { return 0; } } return minClear * World::kSmallZStep; } // 0x0042CF7C // targetTown // pos : (ax, cx, di) // isLargeTile : bh bit 0 // buildImmediately : bh bit 1 // rotation : bl // targetHeight : ebp // return std::nullopt : Carry flag set // See also BuildingPlacementArgs static std::optional<GameCommands::BuildingPlacementArgs> generateNewBuildingArgs(const TownId targetTown, const World::Pos3 pos, int16_t targetHeight, uint8_t rotation, bool isLargeTile, bool buildImmediately) { const auto res = TownManager::getClosestTownAndDensity(pos); if (!res.has_value()) { return std::nullopt; } const auto& [townId, townDensity] = res.value(); auto* town = TownManager::get(townId); uint32_t unk525D24 = 0; const auto buildingsFactor = (town->numBuildings + 64) / 128; for (auto i = 0U; i < std::size(k4F92A6); ++i) { if (k4F92A6[i] * buildingsFactor > town->var_150[i]) { unk525D24 |= (1U << i); } } const auto curYear = getCurrentYear(); auto potentialBuildings = sub_42CEBF(curYear, townDensity, isLargeTile, unk525D24, targetHeight); if (potentialBuildings.empty()) { if (townDensity == 0) { return std::nullopt; } potentialBuildings = sub_42CEBF(curYear, townDensity - 1, isLargeTile, unk525D24, targetHeight); if (potentialBuildings.empty()) { return std::nullopt; } } const auto randBuilding = ((town->prng.randNext() & 0xFFFFU) * potentialBuildings.size()) / 65536; const auto buildingObjId = potentialBuildings[randBuilding]; auto* buildingObj = ObjectManager::get<BuildingObject>(buildingObjId); sfl::static_vector<uint8_t, 32> potentialVariations; for (auto j = 0U; j < buildingObj->numVariations; ++j) { uint16_t height = 0; const auto parts = buildingObj->getBuildingParts(j); const auto partHeights = buildingObj->getBuildingPartHeights(); for (const auto part : parts) { height += partHeights[part]; } if (height <= targetHeight) { potentialVariations.push_back(j); } } const auto randVariationIndex = ((town->prng.randNext() & 0xFFFFU) * potentialVariations.size()) / 65536; const auto variation = potentialVariations[randVariationIndex]; sfl::static_vector<Colour, 32> potentialColours; for (auto j = 0U; j < enumValue(Colour::max); ++j) { if (buildingObj->colours & (1U << j)) { potentialColours.push_back(static_cast<Colour>(j)); } } auto colour = Colour::black; if (!potentialColours.empty()) { const auto randColourIndex = ((town->prng.randNext() & 0xFFFFU) * potentialColours.size()) / 65536; colour = potentialColours[randColourIndex]; } // TODO: This should be done earlier but would cause a divergence // move higher when we want to diverge if (targetTown != townId) { return std::nullopt; } GameCommands::BuildingPlacementArgs args{}; args.buildImmediately = buildImmediately; args.pos = pos; args.colour = colour; args.rotation = rotation; args.type = buildingObjId; args.variation = variation; return args; } // 0x00498CB7 // Searches a 3x3 square around the centerPos for any buildings // centerPos : ax, cx (Actually in World::Pos2 format) // return : flags Carry == building found static bool hasNearbyBuildings(World::TilePos2 centerPos) { const auto tileA = centerPos - World::TilePos2{ 2, 2 }; const auto tileB = centerPos + World::TilePos2{ 2, 2 }; for (const auto& tilePos : World::getClampedRange(tileA, tileB)) { auto tile = World::TileManager::get(tilePos); for (const auto& el : tile) { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { continue; } return true; } } return false; } // 0x0047AD83 // pos : ax, cx, dx // tad : ebp // newRoadObjId : bh // newOwner : bl // newStreetLightStyle : ebx >> 16 static void updateAndTakeoverRoad(const World::Pos3 pos, const Vehicles::TrackAndDirection::_RoadAndDirection tad, const uint8_t newRoadObjId, const CompanyId newOwner, const uint8_t newStreetLightStyle) { auto* newRoadObj = ObjectManager::get<RoadObject>(newRoadObjId); const auto roadPiecesFlags = World::TrackData::getRoadMiscData(tad.id()).compatibleFlags; if ((roadPiecesFlags & newRoadObj->roadPieces) != roadPiecesFlags) { return; } const auto roadStart = [tad, &pos]() { if (tad.isReversed()) { auto& roadSize = World::TrackData::getUnkRoad(tad._data); auto roadStart = pos + roadSize.pos; if (roadSize.rotationEnd < 12) { roadStart -= World::Pos3{ kRotationOffset[roadSize.rotationEnd], 0 }; } return roadStart; } else { return pos; }; }(); const auto pieces = World::TrackData::getRoadPiece(tad.id()); for (auto& piece : pieces) { const auto roadPos = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, tad.cardinalDirection()), piece.z }; auto tile = World::TileManager::get(roadPos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != roadPos.z) { continue; } if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { continue; } elRoad->setOwner(newOwner); elRoad->setRoadObjectId(newRoadObjId); if (!elRoad->hasLevelCrossing()) { elRoad->setStreetLightStyle(newStreetLightStyle); } Ui::ViewportManager::invalidate(roadPos, elRoad->baseHeight(), elRoad->clearHeight(), ZoomLevel::half); } } } // 0x00498C6B // roadObjId : bh // townDensity : 0x01135C5F // return : edi static uint32_t getStreetLightStyle(uint8_t roadObjId, uint8_t townDensity) { auto* roadObj = ObjectManager::get<RoadObject>(roadObjId); if (!roadObj->hasFlags(RoadObjectFlags::unk_08) || townDensity == 0) { return 0; } return []() { auto* streetLightObj = ObjectManager::get<StreetLightObject>(); const auto curYear = getCurrentYear(); for (auto i = 0U; i < std::size(streetLightObj->designedYear); ++i) { if (curYear < streetLightObj->designedYear[i]) { return i; } } return static_cast<uint32_t>(std::size(streetLightObj->designedYear)); }(); } // 0x0047AC3E static RoadInformation getRoadInformation(const World::Pos3& loc, Vehicles::TrackAndDirection::_RoadAndDirection tad) { const auto roadStart = [tad, &loc]() { if (tad.isReversed()) { auto& roadSize = World::TrackData::getUnkRoad(tad._data); auto roadStart = loc + roadSize.pos; if (roadSize.rotationEnd < 12) { roadStart -= World::Pos3{ kRotationOffset[roadSize.rotationEnd], 0 }; } return roadStart; } else { return loc; }; }(); const auto startDirection = tad.cardinalDirection(); const auto& roadPieceZero = World::TrackData::getRoadPiece(tad.id())[0]; const auto nextRoadStart = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPieceZero.x, roadPieceZero.y }, startDirection), roadPieceZero.z }; auto* nextElRoad = [nextRoadStart, startDirection, tad]() -> World::RoadElement* { auto tile = World::TileManager::get(nextRoadStart); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != nextRoadStart.z) { continue; } if (elRoad->rotation() != startDirection) { continue; } if (elRoad->sequenceIndex() != 0) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { continue; } if (elRoad->roadId() != tad.id()) { continue; } return elRoad; } return nullptr; }(); if (nextElRoad == nullptr) { // TODO return RoadInformation{ CompanyId::null, 0, false, std::nullopt }; } RoadInformation result{}; result.owner = nextElRoad->owner(); result.roadObjId = nextElRoad->roadObjectId(); result.streetLightStyle = std::nullopt; result.isStationRoadEnd = false; const bool hasLevelCrossing = nextElRoad->hasLevelCrossing(); if (!hasLevelCrossing) { result.streetLightStyle = nextElRoad->streetLightStyle(); } if (nextElRoad->hasStationElement()) { auto* elStation = World::TileManager::get(nextRoadStart).roadStation(tad.id(), startDirection, nextRoadStart.z / World::kSmallZStep); if (elStation != nullptr) { auto* roadStationObj = ObjectManager::get<RoadStationObject>(elStation->objectId()); if (roadStationObj->hasFlags(RoadStationFlags::roadEnd)) { result.isStationRoadEnd = true; } } } return result; } static constexpr std::array<World::Pos2, 4> k4FF704 = { World::Pos2{ 0, 0 }, World::Pos2{ 0, -32 }, World::Pos2{ -32, -32 }, World::Pos2{ -32, 0 }, }; static constexpr std::array<std::array<World::TilePos2, 4>, 2> kIntersectionCheck = { std::array<World::TilePos2, 4>{ World::TilePos2{ 0, -2 }, World::TilePos2{ 0, -1 }, World::TilePos2{ 0, 1 }, World::TilePos2{ 0, 2 }, }, std::array<World::TilePos2, 4>{ World::TilePos2{ -2, 0 }, World::TilePos2{ -1, 0 }, World::TilePos2{ 1, 0 }, World::TilePos2{ 2, 0 }, }, }; // 0x004984C5 static bool addRoadJunction(Town& town, const World::Pos3 pos, const Vehicles::TrackAndDirection::_RoadAndDirection tad, const bool onBridge, const uint8_t roadObjId, const sfl::static_vector<uint16_t, 16>& connections) { const auto roadId = tad.id(); if (roadId != 0 && roadId != 1 && roadId != 2) { return false; } if (onBridge) { return false; } auto randVal = town.prng.randNext(); if ((randVal & 0xFFFFU) > 0x666) { return false; } auto* surface = TileManager::get(pos).surface(); if (pos.z < surface->baseHeight()) { return false; } uint8_t edges = 0; for (auto c : connections) { edges |= kRoadTadConnectionEdge[c & World::Track::AdditionalTaDFlags::basicTaDMask]; } edges ^= 0xF; const auto numEdges = std::popcount(edges); if (numEdges == 0) { return false; } auto randEdge = [randVal, numEdges, edges]() { int32_t num = ((randVal >> 16) & 0xFFU) * numEdges / 256; auto i = 0U; for (; i < 4 && num >= 0; ++i) { if (edges & (1U << i)) { --num; } } return i - 1; }(); bool hasIncompatibleRoad = [curPos = pos, randEdge]() { for (const auto& offset : kIntersectionCheck[randEdge & 1]) { const auto pos = curPos + World::Pos3(World::toWorldSpace(offset), 0); if (sub_498D9A(pos, randEdge)) { return true; } } return false; }(); if (hasIncompatibleRoad) { return false; } // 0x00498676 uint8_t newRoadId = 0; if (edges & (1U << (randEdge ^ (1U << 1)))) { if (edges & (1U << ((randEdge - 1) & 0x3))) { newRoadId = 1; } else { newRoadId = 2; } } GameCommands::RoadPlacementArgs args{}; args.roadId = newRoadId; args.pos = pos; args.roadObjectId = roadObjId; args.bridge = 0xFFU; args.rotation = randEdge ^ (1U << 1); args.mods = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); return true; } static constexpr std::array<Pos2, 6> kBuggedRotationOffset = { Pos2{ -25, 0 }, Pos2{ -32, 0 }, Pos2{ 0, 32 }, Pos2{ 32, 0 }, Pos2{ 0, -32 }, Pos2{ -32, 0 }, }; // 0x00498801 static bool placeRoadBridge(Town& town, const World::Pos3 pos, const uint8_t rotation, const uint8_t roadObjectId) { assert(rotation < 4); auto validBridgeTypes = getAvailableCompatibleBridges(roadObjectId, TransportMode::road); auto bridgePos = pos; auto bridgeLength = 1U; bool bridgesWater = false; bool bridgeIsHigh = false; // Bridge length is 1 based! for (; bridgeLength <= kMaxTownBridgeLength; ++bridgeLength) { sfl::static_vector<uint8_t, Limits::kMaxBridgeObjects> iterationValidBridgeTypes; for (auto bridgeObjId : validBridgeTypes) { GameCommands::RoadPlacementArgs args{}; args.bridge = bridgeObjId; args.pos = bridgePos; args.mods = 0; args.roadId = 0; args.roadObjectId = roadObjectId; args.rotation = rotation; if (GameCommands::doCommand(args, 0) != GameCommands::FAILURE) { iterationValidBridgeTypes.push_back(bridgeObjId); } } if (iterationValidBridgeTypes.empty()) { return false; } validBridgeTypes = iterationValidBridgeTypes; auto tile = TileManager::get(bridgePos); auto* surface = tile.surface(); if (surface->water()) { bridgesWater = true; } auto bridgeHeight = bridgePos.z - surface->baseHeight(); if (bridgeHeight >= 8 * kSmallZStep) { bridgeIsHigh = true; } bridgePos += World::Pos3{ World::kRotationOffset[rotation], 0 }; if (!World::validCoords(bridgePos)) { return false; } auto nextTile = TileManager::get(bridgePos); auto* nextSurface = nextTile.surface(); if (bridgePos.z <= nextSurface->baseHeight()) { break; } } if ((!bridgeIsHigh && !bridgesWater) || bridgeLength > kMaxTownBridgeLength) { return false; } const auto randBridgeId = validBridgeTypes[((town.prng.randNext() & 0xFFU) * validBridgeTypes.size()) / 256]; bridgePos = pos; for (auto i = 0U; i < bridgeLength; ++i) { GameCommands::RoadPlacementArgs args{}; args.bridge = randBridgeId; args.pos = bridgePos; args.mods = 0; args.roadId = 0; args.roadObjectId = roadObjectId; args.rotation = rotation; GameCommands::doCommand(args, GameCommands::Flags::apply); bridgePos += World::Pos3{ World::kRotationOffset[rotation], 0 }; } return true; } // 0x004986EA static void appendToRoadEnd(Town& town, const World::Pos3 pos, const uint8_t rotation, const uint8_t roadObjectId, const uint32_t iteration, const bool isOnBridge) { if (!World::validCoords(pos)) { return; } if (iteration >= 2 && !isOnBridge) { auto numBuildingsInArea = [pos]() { const auto tileA = World::toTileSpace(pos) - World::TilePos2{ 2, 2 }; const auto tileB = tileA + World::TilePos2{ 4, 4 }; uint32_t numBuildings = 0; for (const auto& tilePos : getClampedRange(tileA, tileB)) { auto tile = TileManager::get(tilePos); for (const auto& el : tile) { if (el.as<BuildingElement>() != nullptr) { numBuildings++; } } } return numBuildings; }(); if (numBuildingsInArea < 2) { return; } } for (auto j : { -1, 1 }) { // NOTE: CS mistake here! const auto checkPos = pos + World::Pos3{ kBuggedRotationOffset[1 + (rotation + j)], 0 }; // const auto checkPos = pos + World::Pos3{ World::kRotationOffset[(rotation + j) & 0x3], 0 }; if (sub_498D21(checkPos, rotation)) { return; } } const auto tile = TileManager::get(pos); auto* surface = tile.surface(); if (pos.z > surface->baseHeight()) { if (placeRoadBridge(town, pos, rotation, roadObjectId)) { return; } } // 0x00498A06 if (surface->water() != 0) { return; } auto heightDiff = pos.z / World::kSmallZStep - surface->baseZ(); if (heightDiff > 0) { if (heightDiff == 4 && !surface->isSlopeDoubleHeight()) { const auto normalisedCorners = Numerics::rotr4bit(surface->slopeCorners(), rotation); if (normalisedCorners == SurfaceSlope::SideUp::northeast) { // Create straightSteepSlopeDown GameCommands::RoadPlacementArgs args{}; args.pos = pos; args.bridge = 0xFFU; args.roadId = 8; args.mods = 0; args.roadObjectId = roadObjectId; args.rotation = rotation; GameCommands::doCommand(args, GameCommands::Flags::apply); return; } // TODO: Remove this its just due to a mistake by CS if (normalisedCorners > 8) { return; } } if (heightDiff > 8) { return; } GameCommands::RaiseLandArgs args{}; args.pointA = pos; args.pointB = pos; args.centre = pos; args.corner = MapSelectionType::full; GameCommands::doCommand(args, GameCommands::Flags::apply); return; } if (heightDiff < 0 && heightDiff >= -4) { GameCommands::LowerLandArgs args{}; args.pointA = pos; args.pointB = pos; args.centre = pos; args.corner = MapSelectionType::full; GameCommands::doCommand(args, GameCommands::Flags::apply); return; } if (surface->slope() && heightDiff == 0) { const auto normalisedCorners = Numerics::rotr4bit(surface->slopeCorners(), rotation); if (!surface->isSlopeDoubleHeight() && normalisedCorners == SurfaceSlope::SideUp::southwest) { // Create straightSteepSlopeUp GameCommands::RoadPlacementArgs args{}; args.pos = pos; args.bridge = 0xFFU; args.roadId = 7; args.mods = 0; args.roadObjectId = roadObjectId; args.rotation = rotation; GameCommands::doCommand(args, GameCommands::Flags::apply); return; } GameCommands::LowerLandArgs args{}; args.pointA = pos; args.pointB = pos; args.centre = pos; args.corner = MapSelectionType::full; GameCommands::doCommand(args, GameCommands::Flags::apply); return; } const auto randVar = town.prng.randNext() & 0xFFFFU; uint8_t roadId = 0; // straight if (randVar < 0x028F) // 1% { roadId = 1; // left curve } else if (randVar < 0x051E) // 1% { roadId = 2; // right curve } auto* elRoad = [&tile, z = pos.z]() -> const World::RoadElement* { for (const auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != z) { continue; } return elRoad; } return nullptr; }(); if (elRoad != nullptr) { const auto existingRotation = elRoad->rotation(); const auto existingRoadId = elRoad->roadId(); if (roadId == 1) { if (existingRoadId == 1) { if ((existingRotation ^ (1U << 1)) == rotation) { roadId = 0; } } else if (existingRoadId == 2) { if (((existingRotation + 1) & 0x3) == rotation) { roadId = 0; } } } else if (roadId == 2) { if (existingRoadId == 1) { if (((existingRotation - 1) & 0x3) == rotation) { roadId = 0; } } else if (existingRoadId == 2) { if ((existingRotation ^ (1U << 1)) == rotation) { roadId = 0; } } } else { if (existingRoadId == 0) { if ((existingRotation ^ (1U << 1)) != rotation) { roadId = 1; } } } } GameCommands::RoadPlacementArgs args{}; args.pos = pos; args.bridge = 0xFFU; args.roadId = roadId; args.mods = 0; args.roadObjectId = roadObjectId; args.rotation = rotation; GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x00498320 static void constructBuilding(Town& town, const World::Pos3 pos, const Vehicles::TrackAndDirection::_RoadAndDirection tad, const TownGrowFlags growFlags) { auto* surface = TileManager::get(pos).surface(); if (pos.z < surface->baseHeight()) { return; } const auto nextToData = TrackData::getRoadUnkNextTo(tad._data); const auto randItem = (nextToData.size() * (town.prng.randNext() & 0xFFU)) / 256; const auto& nextTo = nextToData[randItem]; auto buildingPos = pos + World::Pos3(Math::Vector::rotate(nextTo.pos, tad.cardinalDirection()), nextTo.pos.z); const auto buildingRot = (nextTo.rotation + tad.cardinalDirection()) & 0x3; // TODO: Urgh dirty, use a normal randBool bool isLarge = false; if (town.prng.srand_0() & (1U << 31)) { isLarge = true; buildingPos.x += k4FF704[buildingRot].x; buildingPos.y += k4FF704[buildingRot].y; } bool allowBuildingUpdate = false; // TODO: Even more dirty if ((growFlags & TownGrowFlags::alwaysUpdateBuildings) != TownGrowFlags::none || (isLarge && !(town.prng.srand_0() & 0x7C000000))) { allowBuildingUpdate = true; } const auto maxHeight = getMaxHeightOfNewBuilding(buildingPos, isLarge, allowBuildingUpdate); if (maxHeight == 0) { return; } auto args = generateNewBuildingArgs(town.id(), buildingPos, maxHeight, buildingRot, isLarge, false); if (args.has_value()) { if ((growFlags & TownGrowFlags::buildImmediately) != TownGrowFlags::none) { args->buildImmediately = true; } GameCommands::doCommand(args.value(), GameCommands::Flags::apply); } } template<size_t searchSize> constexpr auto kSquareSearchRange = []() { /* Searches in a square of increasing size * X, Y, Z, J, K * * -4-3-2-1 0 1 2 3 4 5 * ____________________ * 4 | K K K K K K K K K K * 3 | K J J J J J J J J K * 2 | K J Z Z Z Z Z Z J K * 1 | K J Z Y Y Y Y Z J K * 0 | K J Z Y X X Y Z J K * -1 | K J Z Y X X Y Z J K * -2 | K J Z Y Y Y Y Z J K * -3 | K J Z Z Z Z Z Z J K * -4 | K J J J J J J J J K * -5 | K K K K K K K K K K */ static_assert((searchSize % 2) == 1, "Must not be an even value"); std::array<World::TilePos2, (searchSize + 1) * (searchSize + 1)> range{}; // 0x00503C6C std::array<World::TilePos2, 4> kDirections = { World::TilePos2{ -1, 0 }, World::TilePos2{ 0, 1 }, World::TilePos2{ 1, 0 }, World::TilePos2{ 0, -1 }, }; World::TilePos2 pos{ 0, 0 }; uint8_t k = 0; for (uint8_t i = 1; i <= searchSize; i += 2) { for (uint8_t direction = 0; direction < 4; ++direction) { for (auto j = i; j != 0; --j) { range[k++] = pos; pos += kDirections[direction]; } } pos += World::TilePos2{ 1, -1 }; } return range; }(); // 0x00463BD2 template<typename Func> static void squareSearch(const World::Pos2& centre, [[maybe_unused]] uint8_t searchSize, Func&& predicate) { assert(searchSize == 9); for (auto& offset : kSquareSearchRange<9>) { const World::Pos2 pos = World::toWorldSpace(offset) + centre; if (World::validCoords(pos)) { if (!predicate(pos)) { return; } } } } struct RoadExtentResult { World::Pos3 roadStart; uint16_t tad; bool isBridge; }; // 0x00497FFC static std::optional<RoadExtentResult> findRoadExtent(const Town& town) { struct FindResult { World::Pos2 loc; World::RoadElement* elRoad; }; std::optional<FindResult> res; // 0x00497F74 auto validRoad = [randVal = town.prng.srand_0(), &res](const World::Pos2& loc) mutable { auto tile = World::TileManager::get(loc); bool hasPassedSurface = false; for (auto& el : tile) { auto* elSurface = el.as<World::SurfaceElement>(); if (elSurface != nullptr) { hasPassedSurface = true; continue; } if (!hasPassedSurface) { continue; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } if (elRoad->sequenceIndex() != 0) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { continue; } // There is a 50% chance that it will use a new result if (res.has_value()) { bool bitRes = randVal & 1; randVal = std::rotr(randVal, 1); if (bitRes) { return true; } } res = FindResult{ loc, elRoad }; return true; } return true; }; squareSearch({ town.x, town.y }, 9, validRoad); if (!res.has_value()) { return std::nullopt; } auto& roadPiece = World::TrackData::getRoadPiece(res->elRoad->roadId()); return RoadExtentResult{ World::Pos3(res->loc, res->elRoad->baseHeight() - roadPiece[0].z), static_cast<uint16_t>((res->elRoad->roadId() << 3) | res->elRoad->rotation()), res->elRoad->hasBridge() }; } // 0x00498101 static void buildInitialRoad(Town& town) { // 0x0049807D auto placeRoadAtTile = [&town](const World::Pos2& loc) { auto tile = World::TileManager::get(loc); auto* elSurface = tile.surface(); auto height = elSurface->baseHeight(); if (elSurface->slope()) { height += 16; if (elSurface->isSlopeDoubleHeight()) { height += 16; } } auto roadObjId = getIdealTownRoadId(town); if (!roadObjId.has_value()) { return true; } GameCommands::RoadPlacementArgs args{}; args.pos = World::Pos3{ loc, height }; args.rotation = town.prng.randNext(3); args.roadId = 0; args.mods = 0; args.bridge = 0xFF; args.roadObjectId = roadObjId.value(); args.unkFlags = 0; return GameCommands::doCommand(args, GameCommands::Flags::apply) == GameCommands::FAILURE; }; squareSearch({ town.x, town.y }, 9, placeRoadAtTile); } /** * 0x00498116 * Grow * * @param this @<esi> * @param growFlags @<eax> */ void Town::grow(TownGrowFlags growFlags) { const auto oldUpatingCompany = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(CompanyId::neutral); const auto extent = findRoadExtent(*this); if (!extent.has_value()) { if ((growFlags & TownGrowFlags::buildInitialRoad) != TownGrowFlags::none) { buildInitialRoad(*this); } GameCommands::setUpdatingCompanyId(oldUpatingCompany); return; } auto roadStart = extent->roadStart; Vehicles::TrackAndDirection::_RoadAndDirection tad(0, 0); tad._data = extent->tad; if (prng.randBool()) { auto& roadSize = World::TrackData::getUnkRoad(tad._data); roadStart += roadSize.pos; if (roadSize.rotationEnd < 12) { roadStart -= World::Pos3{ kRotationOffset[roadSize.rotationEnd], 0 }; } tad.setReversed(!tad.isReversed()); } const auto idealRoadId = getIdealTownRoadId(*this); if (!idealRoadId.has_value()) { GameCommands::setUpdatingCompanyId(oldUpatingCompany); return; } auto curRoadPos = roadStart; bool curOnBridge = extent->isBridge; for (auto i = 0U; i < 75; ++i) { auto res = TownManager::getClosestTownAndDensity(curRoadPos); if (!res.has_value() || res->first != id()) { break; } const auto curRoadInfo = getRoadInformation(curRoadPos, tad); if (curRoadInfo.owner != CompanyId::neutral) { if ((growFlags & TownGrowFlags::neutralRoadTakeover) != TownGrowFlags::none) { if (curOnBridge || hasNearbyBuildings(World::toTileSpace(curRoadPos))) { updateAndTakeoverRoad(curRoadPos, tad, curRoadInfo.roadObjId, CompanyId::neutral, curRoadInfo.streetLightStyle.value_or(0U)); break; } } } else { if (curRoadInfo.roadObjId != idealRoadId.value()) { const auto* curRoadObj = ObjectManager::get<RoadObject>(curRoadInfo.roadObjId); if (!curRoadObj->hasFlags(RoadObjectFlags::isOneWay)) { const auto* idealRoadObj = ObjectManager::get<RoadObject>(idealRoadId.value()); if (curRoadObj->maxSpeed <= idealRoadObj->maxSpeed) { if ((growFlags & TownGrowFlags::roadUpdate) != TownGrowFlags::none) { if (curOnBridge || hasNearbyBuildings(World::toTileSpace(curRoadPos))) { updateAndTakeoverRoad(curRoadPos, tad, idealRoadId.value(), curRoadInfo.owner, curRoadInfo.streetLightStyle.value_or(0U)); break; } } } } } else { if ((growFlags & TownGrowFlags::roadUpdate) != TownGrowFlags::none) { if (curRoadInfo.streetLightStyle.has_value()) { const auto newStyle = getStreetLightStyle(curRoadInfo.roadObjId, res->second); if (newStyle != curRoadInfo.streetLightStyle.value()) { if (curOnBridge || hasNearbyBuildings(World::toTileSpace(curRoadPos))) { updateAndTakeoverRoad(curRoadPos, tad, curRoadInfo.roadObjId, curRoadInfo.owner, newStyle); } } } } } } if ((growFlags & TownGrowFlags::constructBuildings) != TownGrowFlags::none && !curOnBridge) { constructBuilding(*this, curRoadPos, tad, growFlags); } const auto roadEnd = World::Track::getRoadConnectionEnd(curRoadPos, tad._data); const auto rc = World::Track::getRoadConnections(roadEnd.nextPos, roadEnd.nextRotation, CompanyId::neutral, 0xFFU, 0, 0); if (rc.connections.empty()) { if ((growFlags & TownGrowFlags::allowRoadExpansion) != TownGrowFlags::none && !curRoadInfo.isStationRoadEnd) { appendToRoadEnd(*this, roadEnd.nextPos, roadEnd.nextRotation, idealRoadId.value(), i, curOnBridge); } break; } auto connection = rc.connections[0]; // If there are multiple branches choose a random direction to walk if (rc.connections.size() > 1) { const auto randConnect = ((prng.randNext() & 0xFFFF) * rc.connections.size()) / 65536; connection = rc.connections[randConnect]; } curRoadPos = roadEnd.nextPos; curOnBridge = connection & World::Track::AdditionalTaDFlags::hasBridge; tad._data = connection & World::Track::AdditionalTaDFlags::basicTaDMask; if ((growFlags & TownGrowFlags::allowRoadBranching) == TownGrowFlags::none) { continue; } if (!addRoadJunction(*this, curRoadPos, tad, curOnBridge, idealRoadId.value(), rc.connections)) { continue; } break; } GameCommands::setUpdatingCompanyId(oldUpatingCompany); } StringId Town::getTownSizeString() const { static StringId townSizeNames[5] = { StringIds::town_size_hamlet, StringIds::town_size_village, StringIds::town_size_town, StringIds::town_size_city, StringIds::town_size_metropolis }; if (static_cast<uint8_t>(size) < std::size(townSizeNames)) { return townSizeNames[static_cast<uint8_t>(size)]; } return StringIds::town_size_hamlet; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/Town.h ```h #pragma once #include "Company.h" #include "LabelFrame.h" #include "Map/Tile.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Prng.h> #include <limits> #include <optional> namespace OpenLoco { constexpr int32_t kMinCompanyRating = -1000; constexpr int32_t kMaxCompanyRating = 1000; enum class TownFlags : uint16_t { none = 0U, sorted = 1U << 0, ratingAdjusted = 1U << 1 }; OPENLOCO_ENABLE_ENUM_OPERATORS(TownFlags); enum class TownGrowFlags : uint8_t { none = 0U, buildInitialRoad = 1U << 0, // initial road can be built (No town growth without a single road) roadUpdate = 1U << 1, // roads can be updated with newer types and streetlights can update style neutralRoadTakeover = 1U << 2, // towns can take over company roads and make them neutral owner allowRoadExpansion = 1U << 3, // Road ends can be extended and bridges can be built allowRoadBranching = 1U << 4, // Existing roads can be branched constructBuildings = 1U << 5, // new buildings can be constructed buildImmediately = 1U << 6, // constructed buildings do not require scaffolding alwaysUpdateBuildings = 1U << 7, // buildings if visited will always be updated with newer versions (if possible) all = buildInitialRoad | roadUpdate | neutralRoadTakeover | allowRoadExpansion | allowRoadBranching | constructBuildings | buildImmediately | alwaysUpdateBuildings, }; OPENLOCO_ENABLE_ENUM_OPERATORS(TownGrowFlags); enum class TownSize : uint8_t { hamlet, village, town, city, metropolis, }; namespace Gfx { class DrawingContext; struct RenderTarget; } #pragma pack(push, 1) struct Town { StringId name; // 0x00 coord_t x; // 0x02 coord_t y; // 0x04 TownFlags flags; // 0x06 LabelFrame labelFrame; // 0x08 Core::Prng prng; // 0x28 uint32_t population; // 0x30 uint32_t populationCapacity; // 0x34 int16_t numBuildings; // 0x38 int16_t companyRatings[15]; // 0x3A uint16_t companiesWithRating; // 0x58 TownSize size; // 0x5A uint8_t historySize; // 0x5B (<= 20 * 12) uint8_t history[20 * 12]; // 0x5C (20 years, 12 months) int32_t historyMinPopulation; // 0x14C uint8_t var_150[8]; uint16_t monthlyCargoDelivered[32]; // 0x158 uint32_t cargoInfluenceFlags; // 0x198 uint16_t var_19C[2][2]; uint8_t buildSpeed; // 0x1A4, 1=slow build speed, 4=fast build speed uint8_t numberOfAirports; // 0x1A5 uint16_t numStations; // 0x1A6 uint32_t var_1A8; uint8_t pad_1AC[0x270 - 0x1AC]; bool empty() const; TownId id() const; void update(); void drawLabel(Gfx::DrawingContext& drawingCtx, const Gfx::RenderTarget& rt); void updateLabel(); void updateMonthly(); void adjustCompanyRating(CompanyId cid, int amount); void recalculateSize(); void grow(TownGrowFlags growFlags); StringId getTownSizeString() const; }; static_assert(sizeof(Town) == 0x270); #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/TownManager.cpp ```cpp #include "TownManager.h" #include "CompanyManager.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "GameStateFlags.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Localisation/StringManager.h" #include "Map/BuildingElement.h" #include "Map/SurfaceElement.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "Objects/ClimateObject.h" #include "Objects/ObjectManager.h" #include "Objects/RegionObject.h" #include "Objects/TownNamesObject.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "Ui/WindowManager.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::TownManager { // 0x0049B45F static uint32_t calcCargoInfluenceFlags(const Town& town) { uint32_t flags = 0; const auto* regionObj = ObjectManager::get<RegionObject>(); for (auto i = 0U; i < regionObj->numCargoInflunceObjects; ++i) { bool hasInfluence = false; switch (regionObj->cargoInfluenceTownFilter[i]) { using enum CargoInfluenceTownFilterType; case allTowns: { hasInfluence = true; } break; case maySnow: { auto tile = TileManager::get(town.x, town.y); const auto* climageObj = ObjectManager::get<ClimateObject>(); const auto* surface = tile.surface(); hasInfluence = surface->baseZ() >= climageObj->summerSnowLine; } break; case inDesert: { hasInfluence = TileManager::countSurroundingDesertTiles({ town.x, town.y }) >= 100; } break; default: assert(false); break; } if (hasInfluence) { flags |= (1U << regionObj->cargoInfluenceObjectIds[i]); } } return flags; } enum class LocationFlags : uint8_t { none = 0, adjacentToLargeWaterBody = 1 << 0, notMountaineous = 1 << 1, adjacentToSmallWaterBody = 1 << 2, }; OPENLOCO_ENABLE_ENUM_OPERATORS(LocationFlags); // 0x00497D70 static LocationFlags copyTownNameToBuffer(const TownNamesObject* namesObj, uint32_t categoryOffset, uint16_t index, char* buffer) { // Offset into the string table for the requested category, located just after the names object header. auto* offsetPtr = reinterpret_cast<const std::byte*>(namesObj) + categoryOffset; auto srcOffset = *reinterpret_cast<const int16_t*>(offsetPtr + index * 2); auto* srcPtr = reinterpret_cast<const char*>(offsetPtr + srcOffset); strcpy(buffer, srcPtr); // Location flags are stored at the end of the string LocationFlags flags = *reinterpret_cast<const LocationFlags*>(srcPtr + strlen(srcPtr) + 1); return flags; } // 0x00497A6A static LocationFlags townNameFromNamesObject(uint32_t rand, const char* buffer) { auto* namesObj = ObjectManager::get<TownNamesObject>(); LocationFlags locationFlags = LocationFlags::none; // Town names are concatenated from six morpheme categories: // {CAT1}{CAT2}{CAT3}{CAT4}{CAT5}{CAT6} // Seperators are defined in each of the category strings; either '-', ' ', or nothing. // Categories can be completely empty, or can be skipped based on randomness. // e.g. "Fort " + "Apple " + "Green" for "Fort Apple Green" for (auto& category : namesObj->categories) { if (category.count == 0) { continue; } uint16_t ax = rand; uint16_t dx = category.count + category.bias; int16_t index = ((ax * dx) >> 16) - category.bias; if (index >= 0) { char* strEnd = const_cast<char*>(buffer + strlen(buffer)); locationFlags |= copyTownNameToBuffer(namesObj, category.offset, index, strEnd); } for (auto shifts = category.count + category.bias; shifts > 0; shifts >>= 1) { rand = std::rotr(rand, 1); } } return locationFlags; } // 0x004978B7 static bool generateTownName(Town* town) { for (auto attemptsLeft = 400U; attemptsLeft > 0; attemptsLeft--) { char buffer[256]{}; auto rand = town->prng.randNext(); auto locationFlags = townNameFromNamesObject(rand, buffer); if (strlen(buffer) == 0) { continue; } if (strlen(buffer) > StringManager::kUserStringSize) { continue; } if (Gfx::TextRenderer::getStringWidth(Gfx::Font::medium_bold, buffer) > 200) { continue; } // clang-format off auto numSurroundingWaterTilesAboveThreshold = [](Pos2 pos, uint8_t threshold) { return TileManager::countSurroundingWaterTiles(pos + Pos2(6 * kTileSize, 0)) > threshold || TileManager::countSurroundingWaterTiles(pos + Pos2(0, 6 * kTileSize)) > threshold || TileManager::countSurroundingWaterTiles(pos + Pos2(0 - 6 * kTileSize, 0)) > threshold || TileManager::countSurroundingWaterTiles(pos + Pos2(0, 0 - 6 * kTileSize)) > threshold; }; // clang-format on if ((locationFlags & LocationFlags::adjacentToLargeWaterBody) != LocationFlags::none) { // Check that the town is adjacent to a large amount of water tiles on at least one side. auto pos = Pos2(town->x, town->y); if (!(numSurroundingWaterTilesAboveThreshold(pos, 65))) { continue; } } if ((locationFlags & LocationFlags::notMountaineous) != LocationFlags::none) { auto pos = Pos2(town->x + kTileSize / 2, town->y + kTileSize / 2); auto height = TileManager::getHeight(pos); if (height.landHeight < 192) { continue; } } if ((locationFlags & LocationFlags::adjacentToSmallWaterBody) != LocationFlags::none) { // Check that the town is adjacent to a low amount of water tiles on at least one side. auto pos = Pos2(town->x, town->y); if (!(numSurroundingWaterTilesAboveThreshold(pos, 15))) { continue; } } bool nameInUse = false; for (auto& candidateTown : towns()) { // Ensure the town name doesn't exist yet char candidateTownName[256]{}; StringManager::formatString(candidateTownName, candidateTown.name); if (strcmp(buffer, candidateTownName) == 0) { nameInUse = true; break; } } if (nameInUse) { continue; } StringId newNameId = StringManager::userStringAllocate(buffer, true); if (newNameId == StringIds::empty) { continue; } town->name = newNameId; town->updateLabel(); return true; } return false; } static auto& rawTowns() { return getGameState().towns; } // 0x00496FE7 Town* initialiseTown(World::Pos2 pos) { Town* town = nullptr; for (auto& candidateTown : rawTowns()) { if (candidateTown.empty()) { town = &candidateTown; break; } } // No space for a new town? if (town == nullptr) { return nullptr; } // Initialise the new town town->x = pos.x; town->y = pos.y; town->flags = TownFlags::none; town->population = 0; town->populationCapacity = 0; town->numBuildings = 0; town->size = TownSize::hamlet; town->historySize = 1; town->history[0] = 0; town->historyMinPopulation = 0; std::fill_n(&town->var_150[0], std::size(town->var_150), 0); town->var_19C[0][0] = 0; town->var_19C[0][1] = 0; town->var_19C[1][0] = 0; town->var_19C[1][1] = 0; town->numStations = 0; town->numberOfAirports = 0; town->var_1A8 = 0; town->prng = getGameState().rng; std::fill_n(&town->companyRatings[0], std::size(town->companyRatings), 500); town->companiesWithRating = 0; std::fill_n(&town->monthlyCargoDelivered[0], std::size(town->monthlyCargoDelivered), 0); town->cargoInfluenceFlags = calcCargoInfluenceFlags(*town); town->buildSpeed = 1; // Figure out a name for this town? if (!generateTownName(town)) { town->name = StringIds::null; return nullptr; } // Figure out if we need to reset building influence for (auto& otherTown : towns()) { if (otherTown.numBuildings == 0 && otherTown.population == 0 && otherTown.populationCapacity == 0) { continue; } resetBuildingsInfluence(); break; } return town; } // 0x00497DC1 // esi population // edi capacity // ebp rating | (numBuildings << 16) Town* updateTownInfo(const World::Pos2& loc, uint32_t population, uint32_t populationCapacity, int16_t rating, int16_t numBuildings) { auto res = getClosestTownAndDensity(loc); if (res == std::nullopt) { return nullptr; } auto townId = res->first; auto town = get(townId); if (town == nullptr) { return nullptr; } town->populationCapacity += populationCapacity; if (population != 0) { town->population += population; Ui::WindowManager::invalidate(Ui::WindowType::townList); Ui::WindowManager::invalidate(Ui::WindowType::town, enumValue(town->id())); } if (rating != 0) { auto companyId = GameCommands::getUpdatingCompanyId(); if (companyId != CompanyId::neutral) { if (!SceneManager::isEditorMode()) { town->adjustCompanyRating(companyId, rating); Ui::WindowManager::invalidate(Ui::WindowType::town, enumValue(town->id())); } } } if (town->numBuildings + numBuildings <= std::numeric_limits<int16_t>::max()) { town->numBuildings += numBuildings; } return town; } // 0x00497348 void resetBuildingsInfluence() { for (auto& town : towns()) { town.numBuildings = 0; town.population = 0; town.populationCapacity = 0; std::fill(std::begin(town.var_150), std::end(town.var_150), 0); } for (const auto& tilePos : World::getWorldRange()) { auto tile = World::TileManager::get(tilePos); for (auto& element : tile) { auto* building = element.as<World::BuildingElement>(); if (building == nullptr) { continue; } if (building->isGhost()) { continue; } if (building->isMiscBuilding()) { continue; } if (building->sequenceIndex() != 0) { continue; } auto objectId = building->objectId(); auto* buildingObj = ObjectManager::get<BuildingObject>(objectId); auto producedQuantity = buildingObj->producedQuantity[0]; uint32_t population; if (!building->isConstructed()) { population = 0; } else { population = producedQuantity; } auto* town = updateTownInfo(World::toWorldSpace(tilePos), population, producedQuantity, 0, 1); if (town != nullptr) { if (buildingObj->var_AC != 0xFF) { town->var_150[buildingObj->var_AC] += 1; } } } } Gfx::invalidateScreen(); } // 0x00496B38 void reset() { for (auto& town : rawTowns()) { town.name = StringIds::null; } Ui::Windows::TownList::reset(); } FixedVector<Town, Limits::kMaxTowns> towns() { return FixedVector(rawTowns()); } Town* get(TownId id) { if (enumValue(id) >= Limits::kMaxTowns) { return nullptr; } return &rawTowns()[enumValue(id)]; } // 0x00496B6D void update() { if (Game::hasFlags(GameStateFlags::tileManagerLoaded) && !SceneManager::isEditorMode()) { auto ticks = ScenarioManager::getScenarioTicks(); if (ticks % 8 == 0) { const auto id = TownId((ticks / 8) % 0x7F); auto town = get(id); if (town != nullptr && !town->empty()) { GameCommands::setUpdatingCompanyId(CompanyId::neutral); town->update(); } } } } // 0x0049771C void updateLabels() { for (Town& town : towns()) { town.updateLabel(); } } // 0x0049748C void updateMonthly() { for (Town& currTown : towns()) { currTown.updateMonthly(); } Ui::WindowManager::invalidate(Ui::WindowType::town); } // 0x00497E52 std::optional<std::pair<TownId, uint8_t>> getClosestTownAndDensity(const World::Pos2& loc) { int32_t closestDistance = std::numeric_limits<uint16_t>::max(); auto closestTown = TownId::null; // ebx for (const auto& town : towns()) { const auto distance = Math::Vector::manhattanDistance2D(World::Pos2(town.x, town.y), loc); if (distance < closestDistance) { closestDistance = distance; closestTown = town.id(); } } if (closestDistance == std::numeric_limits<uint16_t>::max()) { return std::nullopt; } const auto* town = get(closestTown); if (town == nullptr) { return std::nullopt; } const int32_t realDistance = Math::Vector::distance2D(World::Pos2(town->x, town->y), loc); // Works out a proxy for how likely there is to be buildings at the location // i.e. how dense the area is. const auto unk = std::clamp((realDistance - town->numBuildings * 4 + 512) / 128, 0, 4); const uint8_t density = std::min(4 - unk, 3); // edx return { std::make_pair(town->id(), density) }; } } OpenLoco::TownId OpenLoco::Town::id() const { // TODO check if this is stored in Town structure // otherwise add it when possible auto index = static_cast<size_t>(this - &TownManager::rawTowns()[0]); if (index > Limits::kMaxTowns) { return OpenLoco::TownId::null; } return OpenLoco::TownId(index); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/TownManager.h ```h #pragma once #include "Engine/Limits.h" #include "Town.h" #include <OpenLoco/Core/LocoFixedVector.hpp> #include <array> #include <optional> namespace OpenLoco::TownManager { Town* initialiseTown(World::Pos2 pos); void reset(); FixedVector<Town, Limits::kMaxTowns> towns(); Town* get(TownId id); std::optional<std::pair<TownId, uint8_t>> getClosestTownAndDensity(const World::Pos2& loc); void update(); void updateLabels(); void updateMonthly(); Town* updateTownInfo(const World::Pos2& loc, uint32_t population, uint32_t populationCapacity, int16_t rating, int16_t numBuildings); void resetBuildingsInfluence(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyAi/CompanyAi.cpp ```cpp #include "CompanyAi.h" #include "CompanyAiPathfinding.h" #include "CompanyAiPlaceVehicle.h" #include "Date.h" #include "Economy/Economy.h" #include "GameCommands/Airports/CreateAirport.h" #include "GameCommands/Airports/RemoveAirport.h" #include "GameCommands/Company/BuildCompanyHeadquarters.h" #include "GameCommands/Company/RemoveCompanyHeadquarters.h" #include "GameCommands/CompanyAi/AiCreateRoadAndStation.h" #include "GameCommands/CompanyAi/AiCreateTrackAndStation.h" #include "GameCommands/CompanyAi/AiTrackReplacement.h" #include "GameCommands/Docks/CreatePort.h" #include "GameCommands/Docks/RemovePort.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/CreateRoad.h" #include "GameCommands/Road/CreateRoadMod.h" #include "GameCommands/Road/CreateRoadStation.h" #include "GameCommands/Road/RemoveRoad.h" #include "GameCommands/Road/RemoveRoadStation.h" #include "GameCommands/Track/CreateSignal.h" #include "GameCommands/Track/CreateTrackMod.h" #include "GameCommands/Track/RemoveTrack.h" #include "GameCommands/Track/RemoveTrainStation.h" #include "GameCommands/Vehicles/CreateVehicle.h" #include "GameCommands/Vehicles/VehicleChangeRunningMode.h" #include "GameCommands/Vehicles/VehicleOrderInsert.h" #include "GameCommands/Vehicles/VehicleOrderSkip.h" #include "GameCommands/Vehicles/VehiclePickup.h" #include "GameCommands/Vehicles/VehiclePickupAir.h" #include "GameCommands/Vehicles/VehiclePickupWater.h" #include "GameCommands/Vehicles/VehicleRefit.h" #include "GameCommands/Vehicles/VehicleSell.h" #include "GameState.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "MessageManager.h" #include "Objects/BridgeObject.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/CompetitorObject.h" #include "Objects/DockObject.h" #include "Objects/ObjectManager.h" #include "Objects/ObjectUtils.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainSignalObject.h" #include "Objects/TrainStationObject.h" #include "Objects/TreeObject.h" #include "Random.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "World/Company.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/IndustryManager.h" #include "World/Station.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <bit> #include <numeric> using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::Literals; using namespace OpenLoco::CompanyAi; // Eventually this will all be under this namespace namespace OpenLoco { static void removeEntityFromThought(AiThought& thought, size_t index); static loco_global<StationId, 0x0112C730> _lastPlacedTrackStationId; static loco_global<StationId, 0x0112C744> _lastPlacedAirportStationId; static loco_global<StationId, 0x0112C748> _lastPlacedPortStationId; static loco_global<EntityId, 0x0113642A> _lastCreatedVehicleId; enum class ThoughtTypeFlags : uint32_t { none = 0U, singleDestination = 1U << 0, // I.e. could be all based in one town destinationAIsIndustry = 1U << 1, destinationBIsIndustry = 1U << 2, railBased = 1U << 3, tramBased = 1U << 4, roadBased = 1U << 5, // But not tram unk6 = 1U << 6, // Circular track - 4 stations unk7 = 1U << 7, unk8 = 1U << 8, unk9 = 1U << 9, // Tunnel (unused) unk10 = 1U << 10, unk11 = 1U << 11, unk12 = 1U << 12, unk13 = 1U << 13, unk14 = 1U << 14, airBased = 1U << 15, waterBased = 1U << 16, unk17 = 1U << 17, }; OPENLOCO_ENABLE_ENUM_OPERATORS(ThoughtTypeFlags); // 0x004FE720 static constexpr std::array<ThoughtTypeFlags, kAiThoughtTypeCount> kThoughtTypeFlags = { ThoughtTypeFlags::railBased | ThoughtTypeFlags::singleDestination | ThoughtTypeFlags::unk6 | ThoughtTypeFlags::unk11, ThoughtTypeFlags::tramBased | ThoughtTypeFlags::singleDestination | ThoughtTypeFlags::unk14, ThoughtTypeFlags::tramBased | ThoughtTypeFlags::singleDestination | ThoughtTypeFlags::unk6 | ThoughtTypeFlags::unk14, ThoughtTypeFlags::railBased | ThoughtTypeFlags::unk11, ThoughtTypeFlags::railBased | ThoughtTypeFlags::unk11 | ThoughtTypeFlags::unk17, ThoughtTypeFlags::roadBased | ThoughtTypeFlags::singleDestination | ThoughtTypeFlags::unk10 | ThoughtTypeFlags::unk12, ThoughtTypeFlags::roadBased | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk12, ThoughtTypeFlags::railBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::destinationBIsIndustry | ThoughtTypeFlags::unk7 | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk11, ThoughtTypeFlags::railBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::destinationBIsIndustry | ThoughtTypeFlags::unk7 | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk11 | ThoughtTypeFlags::unk17, ThoughtTypeFlags::railBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk7 | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk11, ThoughtTypeFlags::railBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk7 | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk11 | ThoughtTypeFlags::unk17, ThoughtTypeFlags::roadBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::destinationBIsIndustry | ThoughtTypeFlags::unk7 | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk13, ThoughtTypeFlags::roadBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk7 | ThoughtTypeFlags::unk8 | ThoughtTypeFlags::unk13, ThoughtTypeFlags::airBased, ThoughtTypeFlags::airBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk7, ThoughtTypeFlags::waterBased, ThoughtTypeFlags::waterBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::destinationBIsIndustry | ThoughtTypeFlags::unk7, ThoughtTypeFlags::waterBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk7, ThoughtTypeFlags::railBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk11, ThoughtTypeFlags::railBased | ThoughtTypeFlags::destinationAIsIndustry | ThoughtTypeFlags::unk11 | ThoughtTypeFlags::unk17, }; // 0x004FE770 static constexpr std::array<uint8_t, kAiThoughtTypeCount> kThoughtTypeNumStations = { 4, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, }; struct ThoughtMinMaxVehicles { uint8_t min; uint8_t max; }; // 0x004FE784 & 0x004FE785 static constexpr auto kThoughtTypeMinMaxNumVehicles = std::to_array<ThoughtMinMaxVehicles>({ { 1, 3 }, { 1, 3 }, { 2, 6 }, { 1, 1 }, { 2, 5 }, { 1, 3 }, { 2, 5 }, { 1, 1 }, { 2, 5 }, { 1, 1 }, { 2, 5 }, { 2, 5 }, { 2, 5 }, { 1, 3 }, { 1, 2 }, { 1, 3 }, { 1, 4 }, { 1, 3 }, { 1, 1 }, { 2, 5 }, }); static_assert(std::size(kThoughtTypeMinMaxNumVehicles) == kAiThoughtTypeCount); static bool thoughtTypeHasFlags(AiThoughtType type, ThoughtTypeFlags flags) { return (kThoughtTypeFlags[enumValue(type)] & flags) != ThoughtTypeFlags::none; } struct DestinationPositions { Pos2 posA; std::optional<Pos2> posB; }; static DestinationPositions getDestinationPositions(const AiThought& thought) { DestinationPositions destPos; destPos.posA = thought.getDestinationPositionA(); if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::singleDestination)) { destPos.posB = thought.getDestinationPositionB(); } return destPos; } // 0x00483778 static void clearThought(AiThought& thought) { thought.type = AiThoughtType::null; } // 0x00487144 static void sub_487144(Company& company) { company.var_85C2 = 0; company.var_85C3 = 0; company.var_85F0 = 0; } enum class PurchaseVehicleResult { success = 0, // But maybe not all required purchases allVehiclesPurchased = 1, failure = 2 }; // 0x00486ECF static PurchaseVehicleResult purchaseVehicle(Company& company, AiThought& thought) { if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { return PurchaseVehicleResult::failure; } if (thought.numVehicles >= thought.var_43) { return PurchaseVehicleResult::allVehiclesPurchased; } EntityId trainHeadId = EntityId::null; for (auto i = 0; i < thought.var_45; ++i) { GameCommands::VehicleCreateArgs createArgs{}; createArgs.vehicleId = trainHeadId; createArgs.vehicleType = thought.var_46[i]; auto res = GameCommands::doCommand(createArgs, GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { // If we can't create a vehicle try create a free vehicle! res = GameCommands::doCommand(createArgs, GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { return PurchaseVehicleResult::failure; } } if (trainHeadId == EntityId::null) { trainHeadId = _lastCreatedVehicleId; } // There was some broken code that would try read the head as a body here // auto* veh = EntityManager::get<Vehicles::VehicleBogie>(_lastCreatedVehicleId); lol no this wouldn't work // auto train = Vehicles::Vehicle(veh->head); // auto car = [&train, veh]() { // for (auto& car : train.cars) // { // if (car.front == veh) // { // return car; // } // } // return Vehicles::Car{}; // }(); // if (car.front->secondaryCargo.maxQty != 0) //{ // if (car.front->secondaryCargo.acceptedTypes & (1U << thought.cargoType)) // { // car.front->secondaryCargo.type = thought.cargoType; // } // } // if (car.body->primaryCargo.maxQty != 0) //{ // if (car.body->primaryCargo.acceptedTypes & (1U << thought.cargoType)) // { // car.body->primaryCargo.type = thought.cargoType; // } // } } thought.vehicles[thought.numVehicles] = trainHeadId; thought.numVehicles++; auto train = Vehicles::Vehicle(trainHeadId); train.head->aiThoughtId = company.activeThoughtId; auto* vehicleObj = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); if (vehicleObj->hasFlags(VehicleObjectFlags::refittable)) { auto shouldRefit = [&vehicleObj, &thought]() { for (auto j = 0; j < 2; ++j) { if (vehicleObj->maxCargo[j] != 0 && (vehicleObj->compatibleCargoCategories[j] & (1U << thought.cargoType))) { return false; } } return true; }(); if (shouldRefit) { auto* cargoObj = ObjectManager::get<CargoObject>(thought.cargoType); if (cargoObj->hasFlags(CargoObjectFlags::refit)) { GameCommands::VehicleRefitArgs refitArgs{}; refitArgs.head = trainHeadId; refitArgs.cargoType = thought.cargoType; GameCommands::doCommand(refitArgs, GameCommands::Flags::apply); } } } StationId destStation = StationId::null; uint32_t orderOffset = 0; for (auto i = 0; i < thought.numStations; ++i) { auto& aiStation = thought.stations[i]; if (destStation == aiStation.id) { continue; } GameCommands::VehicleOrderInsertArgs insertArgs{}; insertArgs.head = trainHeadId; insertArgs.orderOffset = orderOffset; Vehicles::OrderStopAt stopAt{ aiStation.id }; destStation = aiStation.id; insertArgs.rawOrder = stopAt.getRaw(); auto insertRes = GameCommands::doCommand(insertArgs, GameCommands::Flags::apply); // Fix vanilla bug if (insertRes != GameCommands::FAILURE) { orderOffset += sizeof(stopAt); } if (i != 0) { continue; } // Potential vanilla issue below it checks for 1ULL << 11 here 1ULL << 7 if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7) && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationAIsIndustry)) { GameCommands::VehicleOrderInsertArgs insertArgs2{}; insertArgs2.head = trainHeadId; insertArgs2.orderOffset = orderOffset; Vehicles::OrderWaitFor waitFor{ thought.cargoType }; insertArgs2.rawOrder = waitFor.getRaw(); auto insert2Res = GameCommands::doCommand(insertArgs2, GameCommands::Flags::apply); // Fix vanilla bug if (insert2Res != GameCommands::FAILURE) { orderOffset += sizeof(waitFor); } } } if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationAIsIndustry)) { return PurchaseVehicleResult::success; } if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk11)) { return PurchaseVehicleResult::success; } if (thought.var_43 > 1) { // Why?? GameCommands::VehicleOrderSkipArgs skipArgs{}; skipArgs.head = trainHeadId; GameCommands::doCommand(skipArgs, GameCommands::Flags::apply); GameCommands::doCommand(skipArgs, GameCommands::Flags::apply); } return PurchaseVehicleResult::success; } // 0x004876CB static void sub_4876CB(AiThought& thought) { for (auto i = 0U; i < thought.numVehicles; ++i) { auto* head = EntityManager::get<Vehicles::VehicleHead>(thought.vehicles[i]); if (head == nullptr) { continue; } if (head->tileX != -1) { continue; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { head->aiPlacementPos = thought.stations[0].pos; head->aiPlacementBaseZ = thought.stations[0].baseZ; head->aiPlacementTaD = thought.stations[0].rotation; // For air and water this doesn't actually get used } else { head->aiPlacementPos = thought.stations[0].pos; head->aiPlacementBaseZ = thought.stations[0].baseZ; uint8_t tad = thought.stations[0].rotation | (0U << 3); // Always trackId/roadId 0 (straight) if (thought.trackObjId & (1U << 7)) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { if (i & 0b1) { tad ^= (1U << 2); } } } head->aiPlacementTaD = tad; } head->breakdownFlags |= Vehicles::BreakdownFlags::breakdownPending; thought.var_88 = 0; } } // 0x00494805 static void tryRemovePortsAndAirports(Company& company) { // If set the port/airport is not removed? std::array<uint8_t, Limits::kMaxStations> unkStationFlags{}; for (auto& thought : company.aiThoughts) { if (thought.type == AiThoughtType::null) { continue; } for (auto i = 0; i < 4 && i < thought.numStations; ++i) { const auto& aiStation = thought.stations[i]; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased)) { unkStationFlags[enumValue(aiStation.id)] |= 1U << 0; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased)) { unkStationFlags[enumValue(aiStation.id)] |= 1U << 1; } } } for (auto& station : StationManager::stations()) { if (station.owner != company.id()) { continue; } if (((station.flags & StationFlags::transportModeAir) != StationFlags::none) && !(unkStationFlags[enumValue(station.id())] & (1U << 0))) { for (auto i = 0; i < station.stationTileSize; ++i) { auto& tileLoc = station.stationTiles[i]; const auto tile = World::TileManager::get(tileLoc); bool stationElFound = false; for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != tileLoc.z / World::kSmallZStep) { continue; } if (elStation->stationType() != StationType::airport) { continue; } stationElFound = true; break; } if (!stationElFound) { continue; } GameCommands::AirportRemovalArgs args{}; args.pos = tileLoc; args.pos.z = World::heightFloor(args.pos.z); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } if (((station.flags & StationFlags::transportModeWater) != StationFlags::none) && !(unkStationFlags[enumValue(station.id())] & (1U << 1))) { for (auto i = 0; i < station.stationTileSize; ++i) { auto& tileLoc = station.stationTiles[i]; const auto tile = World::TileManager::get(tileLoc); bool stationElFound = false; for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != tileLoc.z / World::kSmallZStep) { continue; } if (elStation->stationType() != StationType::docks) { continue; } stationElFound = true; break; } if (!stationElFound) { continue; } GameCommands::PortRemovalArgs args{}; args.pos = tileLoc; args.pos.z = World::heightFloor(args.pos.z); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } } } // 0x004308D4 static void aiThinkState0(Company& company) { company.var_85F6++; if (company.var_85F6 < 672) { company.var_4A4 = AiThinkState::unk2; company.var_4A5 = 0; return; } if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { bool hasAssets = false; for (auto& thought : company.aiThoughts) { if (thought.type != AiThoughtType::null) { hasAssets = true; break; } } if (!hasAssets) { for (auto& station : StationManager::stations()) { if (station.owner == company.id()) { hasAssets = true; break; } } } if (!hasAssets) { company.var_4A4 = AiThinkState::endCompany; company.var_85C4 = World::Pos2{ 0, 0 }; return; } } company.var_85F6 = 0; company.var_4A4 = AiThinkState::unk1; company.activeThoughtId = kAiThoughtIdNull; tryRemovePortsAndAirports(company); } // 0x00487F8D static bool sub_487F8D(const Company& company, const AiThought& thought) { if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { return true; } if (thought.var_88 < 3) { return false; } // 27 / 8 ??? const auto val = thought.var_7C * 3; const auto val2 = val + (val / 8); return thought.var_84 < val2; } struct VehiclePurchaseObjects { uint16_t cargoObjId; uint16_t frontObjId; uint16_t secondObjId; }; // 0x00480CD5 static std::optional<VehiclePurchaseObjects> getAirBasedIdealObjects(const Company& company, const AiThought& thought) { Speed16 bestSpeed = 0_mph; uint16_t bestDesignedYear = 0; uint16_t bestVehicleObjId = 0xFFFF; auto* cargoObj = ObjectManager::get<CargoObject>(thought.cargoType); for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != TransportMode::air) { continue; } if (vehicleObj->hasFlags(VehicleObjectFlags::aircraftIsHelicopter)) { continue; } bool compatibleCargo = false; for (auto j = 0U; j < 2; ++j) { if (vehicleObj->maxCargo[j] != 0 && (vehicleObj->compatibleCargoCategories[j] & (1U << thought.cargoType))) { compatibleCargo = true; break; } } if (!compatibleCargo) { if (!vehicleObj->hasFlags(VehicleObjectFlags::refittable) || !cargoObj->hasFlags(CargoObjectFlags::refit)) { continue; } } if (!company.unlockedVehicles[i]) { continue; } if (vehicleObj->speed >= bestSpeed) { if (vehicleObj->speed == bestSpeed) { if (bestDesignedYear > vehicleObj->designed) { continue; } } bestSpeed = vehicleObj->speed; bestDesignedYear = vehicleObj->designed; bestVehicleObjId = i; } } if (bestSpeed == 0_mph) { return std::nullopt; } return VehiclePurchaseObjects{ bestVehicleObjId, 0xFFFFU, 0xFFFFU }; } // 0x00480DC6 static std::optional<VehiclePurchaseObjects> getWaterBasedIdealObjects(const Company& company, const AiThought& thought) { Speed16 bestSpeed = 0_mph; uint16_t bestDesignedYear = 0; uint16_t bestVehicleObjId = 0xFFFF; auto* cargoObj = ObjectManager::get<CargoObject>(thought.cargoType); for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != TransportMode::water) { continue; } bool compatibleCargo = false; for (auto j = 0U; j < 2; ++j) { if (vehicleObj->maxCargo[j] != 0 && (vehicleObj->compatibleCargoCategories[j] & (1U << thought.cargoType))) { compatibleCargo = true; break; } } if (!compatibleCargo) { if (!vehicleObj->hasFlags(VehicleObjectFlags::refittable) || !cargoObj->hasFlags(CargoObjectFlags::refit)) { continue; } } if (!company.unlockedVehicles[i]) { continue; } if (vehicleObj->speed >= bestSpeed) { if (vehicleObj->speed == bestSpeed) { if (bestDesignedYear > vehicleObj->designed) { continue; } } bestSpeed = vehicleObj->speed; bestDesignedYear = vehicleObj->designed; bestVehicleObjId = i; } } if (bestSpeed == 0_mph) { return std::nullopt; } return VehiclePurchaseObjects{ bestVehicleObjId, 0xFFFFU, 0xFFFFU }; } // 0x004802F7 static std::optional<VehiclePurchaseObjects> getTrackAndRoadIdealObjects(const Company& company, const AiThought& thought) { uint8_t unk112C5A6 = thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7) ? 3 : 6; uint8_t trackType = thought.trackObjId; TransportMode mode = TransportMode::rail; if (trackType & (1U << 7)) { trackType &= ~(1U << 7); mode = TransportMode::road; auto* roadObj = ObjectManager::get<RoadObject>(trackType); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { trackType = 0xFFU; } } Speed16 bestSpeed = 0_mph; uint16_t bestDesignedYear = 0; uint16_t bestVehicleObjId = 0xFFFF; for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != mode) { continue; } if (vehicleObj->trackType != trackType) { continue; } bool compatibleCargo = false; for (auto j = 0U; j < 2; ++j) { if (vehicleObj->maxCargo[j] != 0 && (vehicleObj->compatibleCargoCategories[j] & (1U << thought.cargoType))) { compatibleCargo = true; break; } } if (!compatibleCargo) { continue; } auto speed = vehicleObj->speed; if (vehicleObj->power != 0) { speed -= 1_mph; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { speed = (speed + 1_mph) * 4; const auto speedRand = Speed16(gPrng1().randNext() & 0x3F); speed += speedRand; } } if (!company.unlockedVehicles[i]) { continue; } if (speed >= bestSpeed) { if (speed == bestSpeed) { if (bestDesignedYear > vehicleObj->designed) { continue; } } if (vehicleObj->power != 0 && !vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { if (thought.hasPurchaseFlags(AiPurchaseFlags::unk0)) { continue; } } bestSpeed = speed; bestDesignedYear = vehicleObj->designed; bestVehicleObjId = i; } } if (bestSpeed == 0_mph) { return std::nullopt; } VehiclePurchaseObjects chosenObjects{ 0xFFFFU, 0xFFFFU, 0xFFFFU }; chosenObjects.cargoObjId = bestVehicleObjId; auto* cargoCarriageObj = ObjectManager::get<VehicleObject>(chosenObjects.cargoObjId); auto minSpeed = cargoCarriageObj->speed; if (cargoCarriageObj->power == 0) { bool longDistane = false; if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6 | ThoughtTypeFlags::singleDestination)) { const auto posA = thought.getDestinationPositionA(); const auto posB = thought.getDestinationPositionB(); const auto distance = Math::Vector::distance2D(posA, posB); longDistane = distance > 40 * 32; } if (longDistane) { // 0x004806A9 int16_t bestScore = 0; uint16_t bestDesignedYearObj2 = 0; uint16_t bestVehicleObjIdObj2 = 0xFFFF; for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != mode) { continue; } if (vehicleObj->trackType != trackType) { continue; } if (vehicleObj->power == 0) { continue; } if (!Vehicles::canVehiclesCouple(chosenObjects.cargoObjId, i)) { continue; } const auto adjustedPower = vehicleObj->power >> unk112C5A6; const auto adjustedSpeed = std::min(minSpeed, vehicleObj->speed); const auto speedRand = Speed16(gPrng1().randNext() & 0x3F); auto score = (adjustedSpeed + speedRand).getRaw() + adjustedPower; if (score < bestScore) { continue; } if (score == bestScore) { if (bestDesignedYearObj2 > vehicleObj->designed) { continue; } } if (!company.unlockedVehicles[i]) { continue; } if (vehicleObj->power != 0 && !vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { if (thought.hasPurchaseFlags(AiPurchaseFlags::unk0)) { continue; } } bestScore = score; bestDesignedYearObj2 = vehicleObj->designed; bestVehicleObjIdObj2 = i; } if (bestScore == 0) { return std::nullopt; } chosenObjects.frontObjId = bestVehicleObjIdObj2; } else { // 0x00480551 int16_t bestScore = -32000; uint16_t bestDesignedYearObj2 = 0; uint16_t bestVehicleObjIdObj2 = 0xFFFF; for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != mode) { continue; } if (vehicleObj->trackType != trackType) { continue; } if (vehicleObj->power == 0) { continue; } if (!Vehicles::canVehiclesCouple(chosenObjects.cargoObjId, i)) { continue; } auto adjustedPower = vehicleObj->power >> unk112C5A6; auto adjustedSpeed = std::min(minSpeed, vehicleObj->speed); auto speed = Speed16((adjustedPower + adjustedSpeed.getRaw()) / 2); const auto speedRand = Speed16(gPrng1().randNext() & 0x3F); speed += speedRand; const auto score = static_cast<int16_t>(speed.getRaw()) - static_cast<int16_t>(vehicleObj->getLength()); if (score < bestScore) { continue; } if (score == bestScore) { if (bestDesignedYearObj2 > vehicleObj->designed) { continue; } } if (!company.unlockedVehicles[i]) { continue; } if (vehicleObj->power != 0 && !vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { if (thought.hasPurchaseFlags(AiPurchaseFlags::unk0)) { continue; } } bestScore = score; bestDesignedYearObj2 = vehicleObj->designed; bestVehicleObjIdObj2 = i; } if (bestScore == -32000) { return std::nullopt; } chosenObjects.frontObjId = bestVehicleObjIdObj2; } } // 0x004807E5 auto requiresFurtherVehicle = [](uint16_t objId) { if (objId == 0xFFFFU) { return true; } auto* vehicleObj = ObjectManager::get<VehicleObject>(objId); if (vehicleObj == nullptr) { return true; } if (vehicleObj->hasFlags(VehicleObjectFlags::topAndTailPosition)) { return false; } if (vehicleObj->power == 0) { return true; } return vehicleObj->hasFlags(VehicleObjectFlags::centerPosition); }; if (requiresFurtherVehicle(chosenObjects.cargoObjId) && requiresFurtherVehicle(chosenObjects.frontObjId)) { Speed16 bestScore = 0_mph; uint16_t bestDesignedYearObj3 = 0; uint16_t bestVehicleObjIdObj3 = 0xFFFF; for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != mode) { continue; } if (vehicleObj->trackType != trackType) { continue; } if (!vehicleObj->hasFlags(VehicleObjectFlags::topAndTailPosition)) { continue; } if (!Vehicles::canVehiclesCouple(chosenObjects.cargoObjId, i)) { continue; } const auto score = vehicleObj->speed; if (score < bestScore) { continue; } if (score == bestScore) { if (bestDesignedYearObj3 > vehicleObj->designed) { continue; } } if (!company.unlockedVehicles[i]) { continue; } if (vehicleObj->power != 0 && !vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { if (thought.hasPurchaseFlags(AiPurchaseFlags::unk0)) { continue; } } bestScore = score; bestDesignedYearObj3 = vehicleObj->designed; bestVehicleObjIdObj3 = i; } if (bestScore == 0_mph) { return std::nullopt; } chosenObjects.secondObjId = bestVehicleObjIdObj3; } if (chosenObjects.secondObjId != 0xFFFFU) { return chosenObjects; } auto isTopAndTailVehicle = [](uint16_t objId) { if (objId == 0xFFFFU) { return false; } auto* vehicleObj = ObjectManager::get<VehicleObject>(objId); if (vehicleObj == nullptr) { return false; } return !vehicleObj->hasFlags(VehicleObjectFlags::topAndTailPosition); }; if (!isTopAndTailVehicle(chosenObjects.cargoObjId) && !isTopAndTailVehicle(chosenObjects.frontObjId)) { Speed16 bestScore = 0_mph; uint16_t bestDesignedYearObj3 = 0; uint16_t bestVehicleObjIdObj3 = 0xFFFF; for (auto i = 0U; i < Limits::kMaxVehicleObjects; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(i); if (vehicleObj == nullptr) { continue; } if (vehicleObj->mode != mode) { continue; } if (vehicleObj->trackType != trackType) { continue; } if (!vehicleObj->hasFlags(VehicleObjectFlags::topAndTailPosition)) { continue; } if (vehicleObj->power != 0) { continue; } if (!Vehicles::canVehiclesCouple(chosenObjects.cargoObjId, i)) { continue; } bool compatibleCargo = false; for (auto j = 0U; j < 2; ++j) { if (vehicleObj->maxCargo[j] != 0 && (vehicleObj->compatibleCargoCategories[j] & (1U << thought.cargoType))) { compatibleCargo = true; break; } } if (!compatibleCargo) { continue; } const auto score = vehicleObj->speed; if (score < bestScore) { continue; } if (score == bestScore) { if (bestDesignedYearObj3 > vehicleObj->designed) { continue; } } if (!company.unlockedVehicles[i]) { continue; } bestScore = score; bestDesignedYearObj3 = vehicleObj->designed; bestVehicleObjIdObj3 = i; } if (bestScore != 0_mph) { chosenObjects.secondObjId = bestVehicleObjIdObj3; } } return chosenObjects; } struct VehiclePurchaseRequest { uint8_t numVehicleObjects; // cl uint8_t dl; // dl currency32_t trainRunCost; // ebx currency32_t trainCost; // eax }; // 0x004802D0 static VehiclePurchaseRequest aiGenerateVehiclePurchaseRequest(const Company& company, AiThought& thought, uint16_t* requestBuffer) { sfl::static_vector<uint16_t, 16> requests; std::optional<VehiclePurchaseObjects> chosenObjects; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased)) { chosenObjects = getAirBasedIdealObjects(company, thought); } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased)) { chosenObjects = getWaterBasedIdealObjects(company, thought); } else { chosenObjects = getTrackAndRoadIdealObjects(company, thought); } // 0x00480A74 if (!chosenObjects.has_value()) { return VehiclePurchaseRequest{}; } // Build a train from the chosen objects int32_t targetLengthWorld = 0; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::roadBased)) { targetLengthWorld = 44; } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::tramBased)) { targetLengthWorld = 64; } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased | ThoughtTypeFlags::airBased)) { targetLengthWorld = 1; } else { targetLengthWorld = thought.stationLength * 32 - 2; } auto targetLength = targetLengthWorld * 4; currency32_t totalCost = 0; uint8_t numVehicleObjects = 0; if (chosenObjects->frontObjId != 0xFFFFU) { auto* vehObj = ObjectManager::get<VehicleObject>(chosenObjects->frontObjId); const auto length = vehObj->getLength(); targetLength -= length; requests.push_back(chosenObjects->frontObjId); totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); numVehicleObjects++; if (vehObj->hasFlags(VehicleObjectFlags::mustHavePair)) { targetLength -= length; totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); requests.push_back(chosenObjects->frontObjId); numVehicleObjects++; } } if (chosenObjects->secondObjId != 0xFFFFU) { auto* vehObj = ObjectManager::get<VehicleObject>(chosenObjects->secondObjId); const auto length = vehObj->getLength(); targetLength -= length; requests.push_back(chosenObjects->secondObjId); totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); numVehicleObjects++; if (vehObj->hasFlags(VehicleObjectFlags::mustHavePair)) { targetLength -= length; totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); requests.push_back(chosenObjects->secondObjId); numVehicleObjects++; } } const auto* vehObj = ObjectManager::get<VehicleObject>(chosenObjects->cargoObjId); const int32_t length = vehObj->getLength(); targetLength -= length; requests.push_back(chosenObjects->cargoObjId); totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); numVehicleObjects++; if (vehObj->hasFlags(VehicleObjectFlags::mustHavePair)) { targetLength -= length; totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); requests.push_back(chosenObjects->cargoObjId); numVehicleObjects++; } if (Vehicles::canVehiclesCouple(chosenObjects->cargoObjId, chosenObjects->cargoObjId)) { while (targetLength - length >= 0) { targetLength -= length; if (numVehicleObjects >= 16) { break; } if (vehObj->hasFlags(VehicleObjectFlags::mustHavePair)) { if (targetLength - length < 0) { break; } targetLength -= length; if (numVehicleObjects >= 15) { break; } } requests.push_back(chosenObjects->cargoObjId); totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); numVehicleObjects++; if (vehObj->hasFlags(VehicleObjectFlags::mustHavePair)) { totalCost += Economy::getInflationAdjustedCost(vehObj->costFactor, vehObj->costIndex, 6); requests.push_back(chosenObjects->cargoObjId); numVehicleObjects++; } } } currency32_t totalRunCost = 0; for (auto requestObjId : requests) { *requestBuffer++ = requestObjId; auto* tempObj = ObjectManager::get<VehicleObject>(requestObjId); totalRunCost += Economy::getInflationAdjustedCost(tempObj->runCostFactor, tempObj->runCostIndex, 10); } return VehiclePurchaseRequest{ .numVehicleObjects = static_cast<uint8_t>(requests.size()), .dl = kThoughtTypeMinMaxNumVehicles[enumValue(thought.type)].min, .trainRunCost = totalRunCost, .trainCost = totalCost }; } // 0x004883D4 static int32_t getUntransportedQuantity(const AiThought& thought) { int32_t quantity = 0; for (auto i = 0U; i < thought.numStations; ++i) { auto& aiStation = thought.stations[i]; auto* station = StationManager::get(aiStation.id); auto& cargoStats = station->cargoStats[thought.cargoType]; quantity += cargoStats.quantity; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { break; } } if (thought.numVehicles == 0) { return quantity; } auto train = Vehicles::Vehicle(thought.vehicles[0]); for (const auto& car : train.cars) { auto* vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); for (auto i = 0U; i < 2; ++i) { if (vehicleObj->compatibleCargoCategories[i] & (1U << thought.cargoType)) { quantity -= vehicleObj->maxCargo[i]; } } } return quantity; } // 0x00480096 static bool determineStationAndTrackModTypes(AiThought& thought) { uint16_t mods = 0; uint8_t rackRail = 0xFFU; for (auto i = 0U; i < thought.var_45; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(thought.var_46[i]); for (auto j = 0U; j < vehicleObj->numTrackExtras; ++j) { mods |= (1U << vehicleObj->requiredTrackExtras[j]); } if (vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { if (thought.hasPurchaseFlags(AiPurchaseFlags::unk0)) { rackRail = vehicleObj->rackRailType; } } } thought.mods = mods; thought.rackRailType = rackRail; uint8_t chosenStationObject = 0xFFU; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased)) { const auto airports = getAvailableAirports(); int16_t bestDesignYear = -1; for (const auto airportObjId : airports) { auto* airportObj = ObjectManager::get<AirportObject>(airportObjId); if (airportObj->hasFlags(AirportObjectFlags::acceptsHeavyPlanes | AirportObjectFlags::acceptsLightPlanes)) { if (bestDesignYear < airportObj->designedYear) { bestDesignYear = airportObj->designedYear; chosenStationObject = airportObjId; } } } if (bestDesignYear == -1) { return true; } thought.stationObjId = chosenStationObject; thought.signalObjId = 0xFFU; return false; } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased)) { const auto docks = getAvailableDocks(); int16_t bestDesignYear = -1; for (const auto dockObjId : docks) { auto* dockObj = ObjectManager::get<DockObject>(dockObjId); if (bestDesignYear < dockObj->designedYear) { bestDesignYear = dockObj->designedYear; chosenStationObject = dockObjId; } } if (bestDesignYear == -1) { return true; } thought.stationObjId = chosenStationObject; thought.signalObjId = 0xFFU; return false; } else if (thought.trackObjId & (1U << 7)) { auto roadStations = getAvailableCompatibleStations(thought.trackObjId & ~(1U << 7), TransportMode::road); int16_t bestDesignYear = -1; bool hadIdealSelection = false; for (const auto roadStationObjId : roadStations) { auto* roadStationObj = ObjectManager::get<RoadStationObject>(roadStationObjId); if (roadStationObj->hasFlags(RoadStationFlags::passenger) && roadStationObj->cargoType != thought.cargoType) { continue; } if (roadStationObj->hasFlags(RoadStationFlags::freight) && roadStationObj->cargoType == thought.cargoType) // Why?? { continue; } bool hasRequiredRoadEnd = roadStationObj->hasFlags(RoadStationFlags::roadEnd) == thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk8); // If we have previously used a fallback we want to remove the fallback and use // the ideal selection bool alwaysSelect = hasRequiredRoadEnd && !hadIdealSelection; // We have now entered ideal selection mode so can remove non-ideal stations // from potential selection if (hadIdealSelection && !hasRequiredRoadEnd) { continue; } hadIdealSelection |= hasRequiredRoadEnd; if (!alwaysSelect) { if (bestDesignYear >= roadStationObj->designedYear) { continue; } } bestDesignYear = roadStationObj->designedYear; chosenStationObject = roadStationObjId; } if (bestDesignYear == -1) { return true; } thought.stationObjId = chosenStationObject; thought.signalObjId = 0xFFU; return false; } else { const auto trainStations = getAvailableCompatibleStations(thought.trackObjId, TransportMode::rail); int16_t bestDesignYear = -1; for (const auto trainStationObjId : trainStations) { auto* trainStationObj = ObjectManager::get<TrainStationObject>(trainStationObjId); if (bestDesignYear < trainStationObj->designedYear) { bestDesignYear = trainStationObj->designedYear; chosenStationObject = trainStationObjId; } } if (bestDesignYear == -1) { return true; } thought.stationObjId = chosenStationObject; const auto signals = getAvailableCompatibleSignals(thought.trackObjId); bestDesignYear = -1; uint8_t chosenSignal = 0xFFU; for (const auto signalObjId : signals) { auto* signalObj = ObjectManager::get<TrainSignalObject>(signalObjId); if (bestDesignYear < signalObj->designedYear) { bestDesignYear = signalObj->designedYear; chosenSignal = signalObjId; } } thought.signalObjId = chosenSignal; return false; } } // 0x00488050 static bool sub_488050(const Company& company, AiThought& thought) { thought.purchaseFlags &= ~(AiPurchaseFlags::unk2 | AiPurchaseFlags::requiresMods); if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { return false; } if (thought.numVehicles != 0) { auto train = Vehicles::Vehicle(thought.vehicles[0]); for (auto& car : train.cars) { auto* vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); const auto reliability = car.front->reliability; if (vehicleObj->power != 0 && (getCurrentYear() >= vehicleObj->obsolete || (reliability != 0 && reliability < 0x1900))) { const auto purchaseRequest = aiGenerateVehiclePurchaseRequest(company, thought, thought.var_46); if (purchaseRequest.numVehicleObjects == 0) { return false; } thought.var_43 = purchaseRequest.dl; thought.var_45 = purchaseRequest.numVehicleObjects; thought.purchaseFlags |= AiPurchaseFlags::unk2; if (determineStationAndTrackModTypes(thought)) { return false; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return true; } uint16_t existingMods = 0xFFFFU; auto tile = World::TileManager::get(thought.stations[0].pos); for (const auto& el : tile) { if (el.baseZ() != thought.stations[0].baseZ) { continue; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { existingMods = 0U; auto* trackObj = ObjectManager::get<TrackObject>(elTrack->trackObjectId()); for (auto i = 0U; i < 4; ++i) { if (elTrack->hasMod(i)) { existingMods |= 1U << trackObj->mods[i]; } } break; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { const bool targetIsNotTram = getGameState().roadObjectIdIsNotTram & (1U << (thought.trackObjId & ~(1U << 7))); const bool elIsNotTram = getGameState().roadObjectIdIsNotTram & (1U << elRoad->roadObjectId()); if (targetIsNotTram) { if (!elIsNotTram) { continue; } } else { if (elIsNotTram) { continue; } if (thought.trackObjId != elRoad->roadObjectId()) { continue; } } existingMods = 0U; auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { for (auto i = 0U; i < 2; ++i) { if (elRoad->hasMod(i)) { existingMods |= 1U << roadObj->mods[i]; } } } break; } } if (existingMods == 0xFFFFU) { return false; } if (thought.mods != existingMods) { thought.mods |= existingMods; thought.purchaseFlags |= AiPurchaseFlags::requiresMods; } return true; } } } // 0x00488149 if (thought.var_88 < 2) { return false; } if (thought.hasPurchaseFlags(AiPurchaseFlags::unk4)) { return false; } if (thought.numVehicles >= kThoughtTypeMinMaxNumVehicles[enumValue(thought.type)].max) { return false; } if (getUntransportedQuantity(thought) <= 50) { return false; } const auto purchaseRequest = aiGenerateVehiclePurchaseRequest(company, thought, thought.var_46); if (purchaseRequest.numVehicleObjects == 0) { return false; } thought.var_43 = thought.numVehicles + 1; thought.var_45 = purchaseRequest.numVehicleObjects; thought.purchaseFlags &= ~AiPurchaseFlags::unk2; if (determineStationAndTrackModTypes(thought)) { return false; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return true; } uint16_t existingMods = 0xFFFFU; auto tile = World::TileManager::get(thought.stations[0].pos); for (const auto& el : tile) { if (el.baseZ() != thought.stations[0].baseZ) { continue; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { existingMods = 0U; auto* trackObj = ObjectManager::get<TrackObject>(elTrack->trackObjectId()); for (auto i = 0U; i < 4; ++i) { if (elTrack->hasMod(i)) { existingMods |= 1U << trackObj->mods[i]; } } break; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { existingMods = 0U; auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); for (auto i = 0U; i < 2; ++i) { if (elRoad->hasMod(i)) { existingMods |= 1U << roadObj->mods[i]; } } break; } } if (existingMods == 0xFFFFU) { return false; } if (thought.mods != existingMods) { thought.mods |= existingMods; thought.purchaseFlags |= AiPurchaseFlags::requiresMods; } return true; } // 0x00430971 static void aiThinkState1(Company& company) { company.activeThoughtId++; if (company.activeThoughtId < kMaxAiThoughts) { auto& thought = company.aiThoughts[company.activeThoughtId]; if (thought.type == AiThoughtType::null) { aiThinkState1(company); return; } if (sub_487F8D(company, thought)) { company.var_4A4 = AiThinkState::unk7; company.var_4A5 = 0; companyEmotionEvent(company.id(), Emotion::disgusted); return; } if (sub_488050(company, thought)) { company.var_4A4 = AiThinkState::unk8; company.var_4A5 = 0; } return; } if (((company.challengeFlags & CompanyFlags::unk0) != CompanyFlags::none) || (getCurrentDay() - company.startedDate <= 42)) { company.var_4A4 = AiThinkState::unk2; company.var_4A5 = 0; return; } CompanyManager::aiDestroy(company.id()); } // 0x00430B31 static void state2ClearActiveThought(Company& company) { if (company.activeThoughtId != 0xFFU) { auto& thought = company.aiThoughts[company.activeThoughtId]; clearThought(thought); } company.var_4A5 = 13; } // 0x0047EABE & 0x0047EB17 static TownId generateTargetTownByPopulation(uint32_t randVal, uint32_t minPopulationCapcity) { sfl::static_vector<TownId, Limits::kMaxTowns> possibleTowns; for (auto& town : TownManager::towns()) { if (town.populationCapacity >= minPopulationCapcity) { possibleTowns.push_back(town.id()); } } if (possibleTowns.empty()) { return TownId::null; } const auto randTown = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); return randTown; } struct TownDestinations { TownId townA; TownId townB; }; // 0x0047EB70, 0x0047EC43 static TownDestinations generateTargetTowns(uint32_t randVal, uint32_t minPopulationCapcity, int32_t minDistance, int32_t maxDistance) { sfl::static_vector<TownId, Limits::kMaxTowns> possibleTowns; for (auto& town : TownManager::towns()) { if (town.populationCapacity >= minPopulationCapcity) { possibleTowns.push_back(town.id()); } } if (possibleTowns.empty()) { return { TownId::null, TownId::null }; } const auto randTownA = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); const auto* townA = TownManager::get(randTownA); const auto townAPos = World::Pos2{ townA->x, townA->y }; possibleTowns.clear(); for (auto& town : TownManager::towns()) { if (town.populationCapacity >= minPopulationCapcity && town.id() != randTownA) { const auto townBPos = World::Pos2{ town.x, town.y }; const auto dist = Math::Vector::manhattanDistance2D(townAPos, townBPos); if (dist <= maxDistance && dist >= minDistance) { possibleTowns.push_back(town.id()); } } } if (possibleTowns.empty()) { return { TownId::null, TownId::null }; } const auto randTownB = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); return { randTownA, randTownB }; } // 0x0047EDF0 static TownDestinations generateTargetTownsWater(uint32_t randVal, uint32_t minPopulationCapcity, int32_t minDistance, int32_t maxDistance) { sfl::static_vector<TownId, Limits::kMaxTowns> possibleTowns; for (auto& town : TownManager::towns()) { if (town.populationCapacity < minPopulationCapcity) { continue; } const auto numWaterTiles = World::TileManager::countNearbyWaterTiles(World::Pos2{ town.x, town.y }); if (numWaterTiles < 20) { continue; } possibleTowns.push_back(town.id()); } if (possibleTowns.empty()) { return { TownId::null, TownId::null }; } const auto randTownA = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); const auto* townA = TownManager::get(randTownA); const auto townAPos = World::Pos2{ townA->x, townA->y }; possibleTowns.clear(); for (auto& town : TownManager::towns()) { if (town.id() == randTownA) { continue; } if (town.populationCapacity < minPopulationCapcity) { continue; } const auto townBPos = World::Pos2{ town.x, town.y }; const auto numWaterTiles = World::TileManager::countNearbyWaterTiles(townBPos); if (numWaterTiles < 20) { continue; } const auto dist = Math::Vector::manhattanDistance2D(townAPos, townBPos); if (dist > maxDistance || dist < minDistance) { continue; } const auto middlePos = (townAPos + townBPos) / 2; const auto* elSurface = World::TileManager::get(middlePos).surface(); if (elSurface->water() != 0) { possibleTowns.push_back(town.id()); } } if (possibleTowns.empty()) { return { TownId::null, TownId::null }; } const auto randTownB = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); return { randTownA, randTownB }; } struct IndustryDestinations { IndustryId industryA; IndustryId industryB; uint8_t cargoType; }; // 0x0047EF49 & 0x0047F0C7 static IndustryDestinations generateTargetIndustries(uint32_t randVal, int32_t minDistance, int32_t maxDistance) { sfl::static_vector<IndustryId, Limits::kMaxIndustries> possibleIndustries; for (auto& industry : IndustryManager::industries()) { if (industry.hasFlags(IndustryFlags::closingDown)) { continue; } bool shouldAdd = false; for (auto i = 0; i < 2; ++i) { if (industry.producedCargoQuantityPreviousMonth[i] >= 150) { shouldAdd = true; break; } if (industry.dailyProduction[i] >= 8) { shouldAdd = true; break; } } if (shouldAdd) { possibleIndustries.push_back(industry.id()); } } if (possibleIndustries.empty()) { return { IndustryId::null, IndustryId::null, 0 }; } const auto randIndustryA = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); auto* industryA = IndustryManager::get(randIndustryA); const auto industryAPos = World::Pos2{ industryA->x, industryA->y }; auto* industryObj = industryA->getObject(); uint8_t cargoType = industryObj->producedCargoType[0]; if (industryA->producedCargoQuantityPreviousMonth[1] >= 150 || industryA->dailyProduction[1] >= 8) { cargoType = industryObj->producedCargoType[1]; if (industryA->producedCargoQuantityPreviousMonth[0] >= 150 || industryA->dailyProduction[0] >= 8) { if (randVal & (1U << 31)) { cargoType = industryObj->producedCargoType[0]; } randVal = std::rotr(randVal, 1); } } possibleIndustries.clear(); for (auto& industry : IndustryManager::industries()) { auto* industryObjB = industry.getObject(); bool takesRequiredCargo = false; for (auto i = 0U; i < 3; ++i) { if (industryObjB->requiredCargoType[i] == cargoType) { takesRequiredCargo = true; break; } } if (!takesRequiredCargo) { continue; } const auto industryBPos = World::Pos2{ industry.x, industry.y }; const auto dist = Math::Vector::manhattanDistance2D(industryAPos, industryBPos); if (dist <= maxDistance && dist >= minDistance) { possibleIndustries.push_back(industry.id()); } } if (possibleIndustries.empty()) { return { IndustryId::null, IndustryId::null, 0 }; } const auto randIndustryB = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); return { randIndustryA, randIndustryB, cargoType }; } // 0x0047F245 static IndustryDestinations generateTargetIndustriesWater(uint32_t randVal, int32_t minDistance, int32_t maxDistance) { sfl::static_vector<IndustryId, Limits::kMaxIndustries> possibleIndustries; for (auto& industry : IndustryManager::industries()) { if (industry.hasFlags(IndustryFlags::closingDown)) { continue; } bool shouldAdd = false; for (auto i = 0; i < 2; ++i) { if (industry.producedCargoQuantityPreviousMonth[i] >= 150) { shouldAdd = true; break; } if (industry.dailyProduction[i] >= 8) { shouldAdd = true; break; } } if (!shouldAdd) { continue; } const auto numWaterTiles = World::TileManager::countNearbyWaterTiles(World::Pos2{ industry.x, industry.y }); if (numWaterTiles < 20) { continue; } possibleIndustries.push_back(industry.id()); } if (possibleIndustries.empty()) { return { IndustryId::null, IndustryId::null, 0 }; } const auto randIndustryA = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); auto* industryA = IndustryManager::get(randIndustryA); const auto industryAPos = World::Pos2{ industryA->x, industryA->y }; auto* industryObj = industryA->getObject(); uint8_t cargoType = industryObj->producedCargoType[0]; if (industryA->producedCargoQuantityPreviousMonth[1] >= 150 || industryA->dailyProduction[1] >= 8) { cargoType = industryObj->producedCargoType[1]; if (industryA->producedCargoQuantityPreviousMonth[0] >= 150 || industryA->dailyProduction[0] >= 8) { if (randVal & (1U << 31)) { cargoType = industryObj->producedCargoType[0]; } randVal = std::rotr(randVal, 1); } } possibleIndustries.clear(); for (auto& industry : IndustryManager::industries()) { auto* industryObjB = industry.getObject(); bool takesRequiredCargo = false; for (auto i = 0U; i < 3; ++i) { if (industryObjB->requiredCargoType[i] == cargoType) { takesRequiredCargo = true; break; } } if (!takesRequiredCargo) { continue; } const auto numWaterTiles = World::TileManager::countNearbyWaterTiles(World::Pos2{ industry.x, industry.y }); if (numWaterTiles < 20) { continue; } const auto industryBPos = World::Pos2{ industry.x, industry.y }; const auto dist = Math::Vector::manhattanDistance2D(industryAPos, industryBPos); if (dist > maxDistance || dist < minDistance) { continue; } const auto middlePos = (industryAPos + industryBPos) / 2; const auto* elSurface = World::TileManager::get(middlePos).surface(); if (elSurface->water() != 0) { possibleIndustries.push_back(industry.id()); } } if (possibleIndustries.empty()) { return { IndustryId::null, IndustryId::null, 0 }; } const auto randIndustryB = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); return { randIndustryA, randIndustryB, cargoType }; } struct MixedDestinations { IndustryId industryA; TownId townB; uint8_t cargoType; }; // 0x00492B33 static uint32_t getTownRequiredCargoTypes(const Town& town) { std::array<uint32_t, Limits::kMaxCargoObjects> scores{}; World::Pos2 townPos{ town.x, town.y }; auto tilePosA = toTileSpace(townPos) - World::TilePos2{ 5, 5 }; auto tilePosB = toTileSpace(townPos) + World::TilePos2{ 5, 5 }; for (auto& tilePos : getClampedRange(tilePosA, tilePosB)) { auto tile = TileManager::get(tilePos); for (auto& el : tile) { auto* elBuilding = el.as<BuildingElement>(); if (elBuilding == nullptr) { continue; } if (elBuilding->isGhost()) { continue; } if (elBuilding->isMiscBuilding()) { continue; } if (!elBuilding->isConstructed()) { continue; } auto* buildingObj = ObjectManager::get<BuildingObject>(elBuilding->objectId()); for (auto i = 0U; i < 2; ++i) { if (buildingObj->requiredCargoType[i] == 0xFFU) { continue; } uint8_t quantity = buildingObj->var_A8[i]; if (buildingObj->hasFlags(BuildingObjectFlags::largeTile)) { quantity *= 4; } scores[buildingObj->requiredCargoType[i]] += quantity; } } } uint32_t cargoBitSet = 0U; for (auto i = 0U; i < scores.size(); ++i) { const auto score = scores[i]; if (score >= 32) { cargoBitSet |= 1U << i; } } return cargoBitSet; } // 0x0047F43E & 0x0047F5D6 & 0x0047F76E static MixedDestinations generateTargetMixedIndustries(uint32_t randVal, int32_t minDistance, int32_t maxDistance) { const uint8_t cargoType = IndustryManager::getMostCommonBuildingCargoType(); sfl::static_vector<std::pair<TownId, uint32_t>, Limits::kMaxTowns> possibleTowns; for (auto& town : TownManager::towns()) { if (town.populationCapacity < 2200) { continue; } auto cargoTypes = getTownRequiredCargoTypes(town); cargoTypes &= ~(1U << cargoType); if (cargoTypes != 0) { possibleTowns.emplace_back(town.id(), cargoTypes); } } if (possibleTowns.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto [randTownB, townBCargoTypes] = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); const auto* townB = TownManager::get(randTownB); const auto townBPos = World::Pos2{ townB->x, townB->y }; sfl::static_vector<uint8_t, Limits::kMaxCargoObjects> possibleCargoTypes; for (auto i = 0U; i < 32; ++i) { if (townBCargoTypes & (1U << i)) { possibleCargoTypes.push_back(i); } } if (possibleCargoTypes.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto chosenCargo = possibleCargoTypes[(randVal & 0x1F) * possibleCargoTypes.size() / 32]; randVal = std::rotr(randVal, 5); sfl::static_vector<IndustryId, Limits::kMaxIndustries> possibleIndustries; for (auto& industry : IndustryManager::industries()) { // NOTE: missing from vanilla! // if (industry.hasFlags(IndustryFlags::closingDown)) //{ // continue; //} auto* industryObj = industry.getObject(); bool shouldAdd = false; for (auto i = 0; i < 2; ++i) { if (industryObj->producedCargoType[i] != chosenCargo) { continue; } if (industry.producedCargoQuantityPreviousMonth[i] >= 150) { shouldAdd = true; break; } } if (shouldAdd) { const auto industryAPos = World::Pos2{ industry.x, industry.y }; const auto dist = Math::Vector::manhattanDistance2D(industryAPos, townBPos); if (dist <= maxDistance && dist >= minDistance) { possibleIndustries.push_back(industry.id()); } } } if (possibleIndustries.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto randIndustryA = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); return { randIndustryA, randTownB, chosenCargo }; } // 0x0047F8FF static MixedDestinations generateTargetMixedIndustriesWater(uint32_t randVal, int32_t minDistance, int32_t maxDistance) { const uint8_t cargoType = IndustryManager::getMostCommonBuildingCargoType(); sfl::static_vector<std::pair<TownId, uint32_t>, Limits::kMaxTowns> possibleTowns; for (auto& town : TownManager::towns()) { if (town.populationCapacity < 2200) { continue; } auto cargoTypes = getTownRequiredCargoTypes(town); cargoTypes &= ~(1U << cargoType); if (cargoTypes == 0) { continue; } const auto numWaterTiles = World::TileManager::countNearbyWaterTiles(World::Pos2{ town.x, town.y }); if (numWaterTiles < 20) { continue; } possibleTowns.emplace_back(town.id(), cargoTypes); } if (possibleTowns.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto [randTownB, townBCargoTypes] = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); const auto* townB = TownManager::get(randTownB); const auto townBPos = World::Pos2{ townB->x, townB->y }; sfl::static_vector<uint8_t, Limits::kMaxCargoObjects> possibleCargoTypes; for (auto i = 0U; i < 32; ++i) { if (townBCargoTypes & (1U << i)) { possibleCargoTypes.push_back(i); } } if (possibleCargoTypes.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto chosenCargo = possibleCargoTypes[(randVal & 0x1F) * possibleCargoTypes.size() / 32]; randVal = std::rotr(randVal, 5); sfl::static_vector<IndustryId, Limits::kMaxIndustries> possibleIndustries; for (auto& industry : IndustryManager::industries()) { // NOTE: missing from vanilla! // if (industry.hasFlags(IndustryFlags::closingDown)) //{ // continue; //} auto* industryObj = industry.getObject(); bool shouldAdd = false; for (auto i = 0; i < 2; ++i) { if (industryObj->producedCargoType[i] != chosenCargo) { continue; } if (industry.producedCargoQuantityPreviousMonth[i] >= 150) { shouldAdd = true; break; } } if (!shouldAdd) { continue; } const auto industryAPos = World::Pos2{ industry.x, industry.y }; const auto numWaterTiles = World::TileManager::countNearbyWaterTiles(industryAPos); if (numWaterTiles < 20) { continue; } const auto dist = Math::Vector::manhattanDistance2D(industryAPos, townBPos); if (dist > maxDistance || dist < minDistance) { continue; } const auto middlePos = (industryAPos + townBPos) / 2; const auto* elSurface = World::TileManager::get(middlePos).surface(); if (elSurface->water() != 0) { possibleIndustries.push_back(industry.id()); } } if (possibleIndustries.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto randIndustryA = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); return { randIndustryA, randTownB, chosenCargo }; } // 0x0047FB1D & 0x0047FC56 static MixedDestinations generateTargetMixedIndustriesAir(uint32_t randVal, uint32_t minPopulationCapacity, int32_t minDistance, int32_t maxDistance) { sfl::static_vector<TownId, Limits::kMaxTowns> possibleTowns; for (auto& town : TownManager::towns()) { if (town.populationCapacity < minPopulationCapacity) { continue; } possibleTowns.emplace_back(town.id()); } if (possibleTowns.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto randTownB = possibleTowns[(randVal & 0x7F) * possibleTowns.size() / 128]; randVal = std::rotr(randVal, 7); const uint8_t cargoType = IndustryManager::getMostCommonBuildingCargoType(); const auto* townB = TownManager::get(randTownB); const auto townBPos = World::Pos2{ townB->x, townB->y }; sfl::static_vector<IndustryId, Limits::kMaxIndustries> possibleIndustries; for (auto& industry : IndustryManager::industries()) { // NOTE: missing from vanilla! // if (industry.hasFlags(IndustryFlags::closingDown)) //{ // continue; //} auto* industryObj = industry.getObject(); bool shouldAdd = false; for (auto i = 0; i < 2; ++i) { if (industryObj->producedCargoType[i] == cargoType) { shouldAdd = true; break; } } if (shouldAdd) { const auto industryAPos = World::Pos2{ industry.x, industry.y }; const auto dist = Math::Vector::manhattanDistance2D(industryAPos, townBPos); if (dist <= maxDistance && dist >= minDistance) { possibleIndustries.push_back(industry.id()); } } } if (possibleIndustries.empty()) { return { IndustryId::null, TownId::null, 0 }; } const auto randIndustryA = possibleIndustries[(randVal & 0xFF) * possibleIndustries.size() / 256]; randVal = std::rotr(randVal, 8); return { randIndustryA, randTownB, cargoType }; } // 0x0047E7DC static void generateNewThought(Company& company, AiThought& thought) { thought.var_84 = 0; thought.var_80 = 0; thought.var_7C = 0; thought.var_76 = 0; thought.var_88 = 0; thought.trackObjId = 0xFFU; thought.signalObjId = 0xFFU; thought.stationObjId = 0xFFU; thought.mods = 0; thought.rackRailType = 0xFFU; thought.var_45 = 0xFFU; thought.numVehicles = 0; thought.var_43 = 0; thought.purchaseFlags = AiPurchaseFlags::none; auto randVal = gPrng1().randNext(); if ((company.challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { thought.type = AiThoughtType::null; return; } bool use25BE = false; const auto var25BE = company.var_25BE; if (var25BE != AiThoughtType::null) { if (randVal & 0x1F) { use25BE = true; } randVal = std::rotr(randVal, 5); } thought.type = var25BE; if (!use25BE) { thought.type = static_cast<AiThoughtType>(((randVal & 0x1F) * 20) / 32); randVal = std::rotr(randVal, 5); } company.var_25BE = thought.type; switch (thought.type) { case AiThoughtType::unk0: case AiThoughtType::unk2: { // 0x0047E8C8 const auto destination = generateTargetTownByPopulation(randVal, 1200); if (destination == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(destination); thought.cargoType = IndustryManager::getMostCommonBuildingCargoType(); break; } case AiThoughtType::unk1: case AiThoughtType::unk5: { // 0x0047E8AA const auto destination = generateTargetTownByPopulation(randVal, 600); if (destination == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(destination); thought.cargoType = IndustryManager::getMostCommonBuildingCargoType(); break; } case AiThoughtType::unk3: case AiThoughtType::unk6: { // 0x0047E8E6 const auto [destinationA, destinationB] = generateTargetTowns(randVal, 800, 0, 85 * 32); if (destinationA == TownId::null || destinationB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(destinationA); thought.destinationB = enumValue(destinationB); thought.cargoType = IndustryManager::getMostCommonBuildingCargoType(); break; } case AiThoughtType::unk4: { // 0x0047E907 const auto [destinationA, destinationB] = generateTargetTowns(randVal, 800, 40 * 32, 220 * 32); if (destinationA == TownId::null || destinationB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(destinationA); thought.destinationB = enumValue(destinationB); thought.cargoType = IndustryManager::getMostCommonBuildingCargoType(); break; } case AiThoughtType::unk7: case AiThoughtType::unk11: { // 0x0047E928 const auto dest = generateTargetIndustries(randVal, 20 * 32, 80 * 32); if (dest.industryA == IndustryId::null || dest.industryB == IndustryId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.industryB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk8: { // 0x0047E944 const auto dest = generateTargetIndustries(randVal, 60 * 32, 250 * 32); if (dest.industryA == IndustryId::null || dest.industryB == IndustryId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.industryB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk9: case AiThoughtType::unk12: { // 0x0047E960 const auto dest = generateTargetMixedIndustries(randVal, 20 * 32, 80 * 32); if (dest.industryA == IndustryId::null || dest.townB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.townB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk10: { // 0x0047E97C const auto dest = generateTargetMixedIndustries(randVal, 60 * 32, 240 * 32); if (dest.industryA == IndustryId::null || dest.townB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.townB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk13: { // 0x0047E998 const auto [destinationA, destinationB] = generateTargetTowns(randVal, 1200, 120 * 32, std::numeric_limits<int32_t>::max()); if (destinationA == TownId::null || destinationB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(destinationA); thought.destinationB = enumValue(destinationB); thought.cargoType = IndustryManager::getMostCommonBuildingCargoType(); break; } case AiThoughtType::unk14: { // 0x0047E9B9 const auto dest = generateTargetMixedIndustries(randVal, 100 * 32, std::numeric_limits<int32_t>::max()); if (dest.industryA == IndustryId::null || dest.townB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.townB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk15: { // 0x0047E9CE const auto [destinationA, destinationB] = generateTargetTownsWater(randVal, 800, 23 * 32, 105 * 32); if (destinationA == TownId::null || destinationB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(destinationA); thought.destinationB = enumValue(destinationB); thought.cargoType = IndustryManager::getMostCommonBuildingCargoType(); break; } case AiThoughtType::unk16: { // 0x0047E9E8 const auto dest = generateTargetIndustriesWater(randVal, 20 * 32, 95 * 32); if (dest.industryA == IndustryId::null || dest.industryB == IndustryId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.industryB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk17: { // 0x0047E9FD const auto dest = generateTargetMixedIndustriesWater(randVal, 20 * 32, 80 * 32); if (dest.industryA == IndustryId::null || dest.townB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.townB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk18: { // 0x0047EA12 const auto dest = generateTargetMixedIndustriesAir(randVal, 450, 15 * 32, 80 * 32); if (dest.industryA == IndustryId::null || dest.townB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.townB); thought.cargoType = dest.cargoType; break; } case AiThoughtType::unk19: { // 0x0047EA27 const auto dest = generateTargetMixedIndustriesAir(randVal, 750, 60 * 32, 240 * 32); if (dest.industryA == IndustryId::null || dest.townB == TownId::null) { thought.type = AiThoughtType::null; return; } thought.destinationA = enumValue(dest.industryA); thought.destinationB = enumValue(dest.townB); thought.cargoType = dest.cargoType; break; } default: assert(false); break; } } // 0x00430A12 static void sub_430A12(Company& company) { company.activeThoughtId = 0xFFU; for (auto thoughtId = 0U; thoughtId < std::size(company.aiThoughts); ++thoughtId) { auto& thought = company.aiThoughts[thoughtId]; if (thought.type != AiThoughtType::null) { continue; } company.activeThoughtId = thoughtId; company.challengeFlags &= ~(CompanyFlags::unk1 | CompanyFlags::unk2); for (auto i = 0U; i < 20; ++i) { generateNewThought(company, thought); if (thought.type != AiThoughtType::null) { company.var_4A5 = 1; return; } } break; } state2ClearActiveThought(company); } struct SimilarThoughts { uint8_t total; uint8_t totalUnprofitable; bool inSameCompany; }; // 0x00480EA8 static SimilarThoughts getSimilarThoughtsInAllCompanies(Company& company, AiThought& thought) { uint8_t numSimilarThoughts = 0; uint8_t numUnprofitableThoughts = 0; for (auto& otherCompany : CompanyManager::companies()) { for (auto& otherThought : otherCompany.aiThoughts) { if (otherThought.type == AiThoughtType::null) { continue; } if (otherThought.cargoType != thought.cargoType) { continue; } auto compatibleThought = [&otherThought, &thought]() { if (thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::singleDestination) != thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::singleDestination)) { return false; } if (otherThought.destinationA == thought.destinationA) { if (thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::singleDestination) || otherThought.destinationB == thought.destinationB) { if (thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::destinationAIsIndustry) == thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationAIsIndustry) && thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::destinationBIsIndustry) == thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationBIsIndustry)) { return true; } } } if (thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::singleDestination)) { return false; } if (otherThought.destinationB != thought.destinationA) { return false; } if (otherThought.destinationA != thought.destinationB) { return false; } // Note: unk1 unk2 are swapped on our thought if (thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::destinationAIsIndustry) != thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationBIsIndustry) || thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::destinationBIsIndustry) != thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationAIsIndustry)) { return false; } return true; }(); if (!compatibleThought) { continue; } // 0x00480F6C if (&company != &otherCompany) { if (numSimilarThoughts != 0xFFU) { ++numSimilarThoughts; } if (otherThought.var_84 >= 3 * otherThought.var_7C) { ++numUnprofitableThoughts; } } else { if (&otherThought == &thought) { continue; } return { 0, 0, true }; } } } return SimilarThoughts{ numSimilarThoughts, numUnprofitableThoughts, false }; } // 0x00430B5D static void sub_430B5D(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; auto similarThoughts = getSimilarThoughtsInAllCompanies(company, thought); if (similarThoughts.inSameCompany || similarThoughts.total > 1) { clearThought(thought); company.var_4A5 = 13; return; } if (similarThoughts.total == 1) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk12 | ThoughtTypeFlags::unk13)) { if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { clearThought(thought); company.var_4A5 = 13; return; } } if (similarThoughts.total != similarThoughts.totalUnprofitable) { clearThought(thought); company.var_4A5 = 13; return; } } company.var_4A5 = 2; } // 0x00480FC3 static bool applyPlaystyleRestrictions(Company& company, AiThought& thought) { if ((company.aiPlaystyleFlags & AiPlaystyleFlags::unk0) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk11)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::unk1) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk12)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::unk2) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk13)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::unk3) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk14)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::noAir) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::noWater) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::unk7) != AiPlaystyleFlags::none && thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::unk6) != AiPlaystyleFlags::none && !thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { return true; } if ((company.aiPlaystyleFlags & AiPlaystyleFlags::townIdSet) != AiPlaystyleFlags::none) { // The first thought of this play style must be located near to the home town chosen for the company // this ensures that the company is based around that town bool noOtherThoughts = true; for (auto& otherThought : company.aiThoughts) { if (&otherThought == &thought) { continue; } if (otherThought.type != AiThoughtType::null) { noOtherThoughts = false; break; } } if (noOtherThoughts) { auto destinationReferenceHomeTown = [&company](bool isIndustry, uint8_t destination) { if (isIndustry) { const auto* industry = IndustryManager::get(static_cast<IndustryId>(destination)); const auto* homeTown = TownManager::get(static_cast<TownId>(company.aiPlaystyleTownId)); const auto distance = Math::Vector::manhattanDistance2D(Pos2{ industry->x, industry->y }, Pos2{ homeTown->x, homeTown->y }); return distance < 33 * kTileSize; } else { return destination == company.aiPlaystyleTownId; } }; const bool destAReferencesHomeTown = destinationReferenceHomeTown(thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationAIsIndustry), thought.destinationA); if (!destAReferencesHomeTown) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::singleDestination)) { return true; } const bool destBReferencesHomeTown = destinationReferenceHomeTown(thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::destinationBIsIndustry), thought.destinationB); if (!destBReferencesHomeTown) { return true; } } } } // Thoughts from a company must all be located nearby to at least one other thought from the same company // nearby is defined as within 60 tiles const auto destPositions = getDestinationPositions(thought); const auto destAPos = destPositions.posA; const auto destBPos = destPositions.posB.value_or(destAPos); bool otherThoughts = false; bool otherThoughtNearby = false; for (auto& otherThought : company.aiThoughts) { if (&otherThought == &thought) { continue; } if (otherThought.type == AiThoughtType::null) { continue; } otherThoughts = true; const auto otherDestPositions = getDestinationPositions(otherThought); const auto otherDestAPos = otherDestPositions.posA; const auto distAA = Math::Vector::distance2D(destAPos, otherDestAPos); if (distAA <= 60 * kTileSize) { otherThoughtNearby = true; break; } const auto distBA = Math::Vector::distance2D(destBPos, otherDestAPos); if (distBA <= 60 * kTileSize) { otherThoughtNearby = true; break; } if (!otherDestPositions.posB.has_value()) { continue; } const auto otherDestBPos = otherDestPositions.posB.value(); const auto distAB = Math::Vector::distance2D(destAPos, otherDestBPos); if (distAB <= 60 * kTileSize) { otherThoughtNearby = true; break; } const auto distBB = Math::Vector::distance2D(destBPos, otherDestBPos); if (distBB <= 60 * kTileSize) { otherThoughtNearby = true; break; } } if (otherThoughts && !otherThoughtNearby) { return true; } auto* competitorObj = ObjectManager::get<CompetitorObject>(company.competitorId); if (competitorObj->competitiveness < 5) { return getSimilarThoughtsInAllCompanies(company, thought).total != 0; } return false; } // 0x00430BAB static void sub_430BAB(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; if (applyPlaystyleRestrictions(company, thought)) { company.var_25BE = AiThoughtType::null; state2ClearActiveThought(company); return; } company.var_4A5 = 3; } // 0x00481433 static int32_t distanceBetweenDestinations(AiThought& thought) { const auto posA = thought.getDestinationPositionA(); const auto posB = thought.getDestinationPositionB(); return Math::Vector::distance2D(posA, posB); } // 0x0048137F static void setupStationCountAndLength(AiThought& thought) { thought.numStations = kThoughtTypeNumStations[enumValue(thought.type)]; for (auto i = 0U; i < thought.numStations; ++i) { auto& aiStation = thought.stations[i]; aiStation.var_02 = AiThoughtStationFlags::none; } if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk11)) { thought.stationLength = 1; } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { if (getCurrentYear() < 1945) { thought.stationLength = 5; } else if (getCurrentYear() < 1991) { thought.stationLength = 6; } else { thought.stationLength = 7; } } else { const auto distance = distanceBetweenDestinations(thought); auto baseStationLength = (std::max(0, distance - 32 * 28) / 1024) + 5; auto yearAdditionalLength = 0; if (getCurrentYear() >= 1925 && getCurrentYear() < 1955) { yearAdditionalLength = 1; } else if (getCurrentYear() < 1985) { yearAdditionalLength = 2; } else { yearAdditionalLength = 3; } const auto minLength = thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk17) ? 7 : 0; thought.stationLength = std::clamp(baseStationLength + yearAdditionalLength, minLength, 11); } } // 0x00481D6F // If there are less than 4 buildings in the area (5x5) then the station can be placed there static bool isSuitableForStation(const World::Pos2& pos) { auto tilePosA = toTileSpace(pos) - TilePos2{ 2, 2 }; auto tilePosB = toTileSpace(pos) + TilePos2{ 2, 2 }; auto numBuildings = 0U; for (const auto& tilePos : TilePosRangeView(tilePosA, tilePosB)) { auto tile = World::TileManager::get(tilePos); for (auto& el : tile) { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding != nullptr) { numBuildings++; } } } return numBuildings < 4; } // 0x00503CBC 3bit yaw to rotation offset static constexpr std::array<World::Pos2, 8> kYaw0RotationOffsets = { World::Pos2{ -32, 0 }, World::Pos2{ -32, 32 }, World::Pos2{ 0, 32 }, World::Pos2{ 32, 32 }, World::Pos2{ 32, 0 }, World::Pos2{ 32, -32 }, World::Pos2{ 0, -32 }, World::Pos2{ -32, -32 }, }; // 0x00481A2D static bool setupIntraCityUnk6Stations(AiThought& thought) { // 0x00112C5A4 // 2bit rotation auto randDirection = gPrng1().randNext() & 0b10; const auto* town = TownManager::get(static_cast<TownId>(thought.destinationA)); const auto townPos = World::Pos2{ town->x, town->y }; auto& aiStation0 = thought.stations[0]; if (!aiStation0.hasFlags(AiThoughtStationFlags::operational)) { auto pos0 = kRotationOffset[randDirection] * 3 + townPos; for (auto i = 0U; i < 18; ++i) { if (isSuitableForStation(pos0)) { break; } pos0 += kRotationOffset[randDirection]; if (i == 17) { return true; } } pos0 -= kRotationOffset[randDirection]; aiStation0.pos = pos0; aiStation0.rotation = 1; aiStation0.var_9 = 3; aiStation0.var_A = 1; aiStation0.var_B = 0; aiStation0.var_C = 0; } auto& aiStation1 = thought.stations[1]; if (!aiStation1.hasFlags(AiThoughtStationFlags::operational)) { auto pos1 = kRotationOffset[1] * 3 + townPos; for (auto i = 0U; i < 18; ++i) { if (isSuitableForStation(pos1)) { break; } pos1 += kRotationOffset[1]; if (i == 17) { return true; } } pos1 -= kRotationOffset[1]; aiStation1.pos = pos1; aiStation1.rotation = 0b10 ^ randDirection; aiStation1.var_9 = 0; aiStation1.var_A = 2; aiStation1.var_B = 0; aiStation1.var_C = 0; } auto& aiStation2 = thought.stations[2]; if (!aiStation2.hasFlags(AiThoughtStationFlags::operational)) { const auto stationRot = randDirection ^ 0b10; auto pos1 = kRotationOffset[stationRot] * 3 + townPos; for (auto i = 0U; i < 18; ++i) { if (isSuitableForStation(pos1)) { break; } pos1 += kRotationOffset[stationRot]; if (i == 17) { return true; } } pos1 -= kRotationOffset[stationRot]; aiStation2.pos = pos1; aiStation2.rotation = 3; aiStation2.var_9 = 1; aiStation2.var_A = 3; aiStation2.var_B = 0; aiStation2.var_C = 0; } auto& aiStation3 = thought.stations[3]; if (!aiStation3.hasFlags(AiThoughtStationFlags::operational)) { auto pos1 = kRotationOffset[3] * 3 + townPos; for (auto i = 0U; i < 18; ++i) { if (isSuitableForStation(pos1)) { break; } pos1 += kRotationOffset[3]; if (i == 17) { return true; } } pos1 -= kRotationOffset[3]; aiStation3.pos = pos1; aiStation3.rotation = randDirection; aiStation3.var_9 = 2; aiStation3.var_A = 0; aiStation3.var_B = 0; aiStation3.var_C = 0; } auto minBaseZ = std::numeric_limits<SmallZ>::max(); auto maxBaseZ = std::numeric_limits<SmallZ>::min(); for (auto& aiStation : thought.stations) { if (!World::validCoords(aiStation.pos)) { continue; } auto* elSurface = World::TileManager::get(aiStation.pos).surface(); minBaseZ = std::min(elSurface->baseZ(), minBaseZ); maxBaseZ = std::max(elSurface->baseZ(), maxBaseZ); } return (maxBaseZ - minBaseZ > 20); } // 0x004816D9 static bool setupIntraCityBasicStations(AiThought& thought) { // 3bit yaw rotation auto randDirection = gPrng1().randNext() & 0b111; const auto* town = TownManager::get(static_cast<TownId>(thought.destinationA)); const auto townPos = World::Pos2{ town->x, town->y }; auto& aiStation0 = thought.stations[0]; if (!aiStation0.hasFlags(AiThoughtStationFlags::operational)) { auto pos0 = kYaw0RotationOffsets[randDirection] * 3 + townPos; for (auto i = 0U; i < 15; ++i) { if (isSuitableForStation(pos0)) { break; } pos0 += kYaw0RotationOffsets[randDirection]; if (i == 14) { return true; } } pos0 -= kYaw0RotationOffsets[randDirection] * 2; aiStation0.pos = pos0; aiStation0.rotation = randDirection; aiStation0.var_9 = 0xFFU; aiStation0.var_A = 1; if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::roadBased)) { aiStation0.var_9 = 0; } aiStation0.var_B = 0; aiStation0.var_C = 0; } auto& aiStation1 = thought.stations[1]; if (!aiStation1.hasFlags(AiThoughtStationFlags::operational)) { const auto direction = randDirection ^ 0b100; auto pos1 = kYaw0RotationOffsets[direction] * 3 + townPos; for (auto i = 0U; i < 15; ++i) { if (isSuitableForStation(pos1)) { break; } pos1 += kYaw0RotationOffsets[direction]; if (i == 14) { return true; } } pos1 -= kYaw0RotationOffsets[direction] * 2; aiStation1.pos = pos1; aiStation1.var_9 = 0xFFU; aiStation1.var_A = 0; if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::roadBased)) { aiStation1.var_9 = 1; } aiStation1.var_B = 0; aiStation1.var_C = 0; } if (thought.numStations > 2) { auto& aiStation2 = thought.stations[2]; if (!aiStation2.hasFlags(AiThoughtStationFlags::operational)) { const auto direction = (randDirection + 0b10) & 0x7; auto pos2 = kYaw0RotationOffsets[direction] * 3 + townPos; for (auto i = 0U; i < 9; ++i) { if (isSuitableForStation(pos2)) { break; } pos2 += kYaw0RotationOffsets[direction]; } pos2 -= kYaw0RotationOffsets[direction] * 3; aiStation2.pos = pos2; aiStation2.var_9 = 0; aiStation2.var_A = 3; aiStation2.var_B = 0; aiStation2.var_C = 0; aiStation0.var_A = 2; aiStation1.var_A = 3; } auto& aiStation3 = thought.stations[3]; if (!aiStation3.hasFlags(AiThoughtStationFlags::operational)) { const auto direction = (randDirection - 0b10) & 0x7; auto pos3 = kYaw0RotationOffsets[direction] * 3 + townPos; for (auto i = 0U; i < 9; ++i) { if (isSuitableForStation(pos3)) { break; } pos3 += kYaw0RotationOffsets[direction]; } pos3 -= kYaw0RotationOffsets[direction] * 3; aiStation3.pos = pos3; aiStation3.var_9 = 2; aiStation3.var_A = 1; aiStation3.var_B = 0; aiStation3.var_C = 0; } } return false; } // 0x004816D9 static bool setupPointToPointStations(AiThought& thought) { auto& aiStationA = thought.stations[0]; if (!aiStationA.hasFlags(AiThoughtStationFlags::operational)) { auto posA = thought.getDestinationPositionA(); aiStationA.pos = posA; aiStationA.var_9 = 1; aiStationA.var_A = 0xFFU; aiStationA.var_B = 0; aiStationA.var_C = 0; aiStationA.var_B |= thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk17) ? (1U << 0) : 0; } auto& aiStationB = thought.stations[1]; if (!aiStationB.hasFlags(AiThoughtStationFlags::operational)) { auto posB = thought.getDestinationPositionB(); aiStationB.pos = posB; aiStationB.var_9 = 0; aiStationB.var_A = 0xFFU; aiStationB.var_B = 0; aiStationB.var_C = 0; aiStationB.var_B |= thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk17) ? (1U << 0) : 0; } if (!aiStationA.hasFlags(AiThoughtStationFlags::operational)) { const auto posDiff1 = toTileSpace(aiStationB.pos - aiStationA.pos); const auto rotation1 = Vehicles::calculateYaw1FromVector(posDiff1.x, posDiff1.y) / 8; aiStationA.pos += kYaw0RotationOffsets[rotation1] * 4; const auto posDiff2 = aiStationB.pos - aiStationA.pos; const auto rotation2 = (Vehicles::calculateYaw0FromVector(posDiff2.x, posDiff2.y) / 16) ^ (1U << 1); aiStationA.rotation = rotation2; } if (!aiStationB.hasFlags(AiThoughtStationFlags::operational)) { const auto posDiff1 = toTileSpace(aiStationA.pos - aiStationB.pos); const auto rotation1 = Vehicles::calculateYaw1FromVector(posDiff1.x, posDiff1.y) / 8; aiStationB.pos += kYaw0RotationOffsets[rotation1] * 4; const auto posDiff2 = aiStationA.pos - aiStationB.pos; const auto rotation2 = (Vehicles::calculateYaw0FromVector(posDiff2.x, posDiff2.y) / 16) ^ (1U << 1); aiStationB.rotation = rotation2; } return false; } // 0x004814D6 static bool setupAiStations(AiThought& thought) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::singleDestination)) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { return setupIntraCityUnk6Stations(thought); } else { return setupIntraCityBasicStations(thought); } } else { return setupPointToPointStations(thought); } } // 0x00430BDA static void sub_430BDA(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; setupStationCountAndLength(thought); if (setupAiStations(thought)) { state2ClearActiveThought(company); return; } company.var_4A5 = 4; } // 0x0047FE3A static bool chooseTrackObject(CompanyId companyId, AiThought& thought) { const auto destinations = getDestinationPositions(thought); using enum World::Track::TrackTraitFlags; auto requiredTraits = smallCurve | slope | junction; if (destinations.posB.has_value()) { auto* surfaceA = TileManager::get(destinations.posA).surface(); auto* surfaceB = TileManager::get(destinations.posB.value()).surface(); auto heightDiff = std::abs(surfaceA->baseZ() - surfaceB->baseZ()); const auto dist = Math::Vector::distance2D(destinations.posA, destinations.posB.value()); if (heightDiff > 32 && dist <= 45 * 32) { requiredTraits |= steepSlope; } } const auto tracks = companyGetAvailableRailTracks(companyId); Speed16 maxSpeed = 0_mph; uint8_t bestTrack = 0xFFU; for (const auto trackObjId : tracks) { if (trackObjId & (1U << 7)) { continue; } auto* trackObj = ObjectManager::get<TrackObject>(trackObjId); if ((trackObj->trackPieces & requiredTraits) != requiredTraits) { continue; } if (maxSpeed < trackObj->curveSpeed) { maxSpeed = trackObj->curveSpeed; bestTrack = trackObjId; } } if (bestTrack == 0xFFU) { return true; } thought.trackObjId = bestTrack; if ((requiredTraits & steepSlope) != World::Track::TrackTraitFlags::none) { thought.purchaseFlags |= AiPurchaseFlags::unk0; } auto* trackObj = ObjectManager::get<TrackObject>(bestTrack); if (trackObj->hasFlags(TrackObjectFlags::unk_04)) { thought.purchaseFlags |= AiPurchaseFlags::unk1; } return false; } // 0x0047FFE5 static bool chooseBasicRoadObject(CompanyId companyId, AiThought& thought) { const auto roads = companyGetAvailableRoads(companyId); const auto requiredTraits = World::Track::RoadTraitFlags::verySmallCurve | World::Track::RoadTraitFlags::slope | World::Track::RoadTraitFlags::steepSlope | World::Track::RoadTraitFlags::unk4 | World::Track::RoadTraitFlags::junction; Speed16 maxSpeed = 0_mph; uint8_t bestRoad = 0xFFU; for (const auto roadObjId : roads) { if (!(roadObjId & (1U << 7))) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(roadObjId & ~(1U << 7)); using enum RoadObjectFlags; if ((roadObj->flags & (unk_07 | isRoad | unk_03 | unk_02)) != (unk_07 | isRoad | unk_03 | unk_02)) { continue; } if (roadObj->hasFlags(isOneWay)) { continue; } if ((roadObj->roadPieces & requiredTraits) != requiredTraits) { continue; } if (maxSpeed < roadObj->maxSpeed) { maxSpeed = roadObj->maxSpeed; bestRoad = roadObjId; } } if (bestRoad == 0xFFU) { return true; } thought.trackObjId = bestRoad | (1U << 7); return false; } // 0x0047FF77 static bool chooseTramRoadObject(CompanyId companyId, AiThought& thought) { const auto roads = companyGetAvailableRailTracks(companyId); const auto requiredTraits = World::Track::RoadTraitFlags::verySmallCurve | World::Track::RoadTraitFlags::slope | World::Track::RoadTraitFlags::steepSlope | World::Track::RoadTraitFlags::unk4 | World::Track::RoadTraitFlags::junction | World::Track::RoadTraitFlags::turnaround; Speed16 maxSpeed = 0_mph; uint8_t bestRoad = 0xFFU; for (const auto roadObjId : roads) { if (!(roadObjId & (1U << 7))) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(roadObjId & ~(1U << 7)); using enum RoadObjectFlags; if (roadObj->hasFlags(unk_07 | isRoad | unk_03 | isOneWay)) { continue; } if ((roadObj->roadPieces & requiredTraits) != requiredTraits) { continue; } if (maxSpeed < roadObj->maxSpeed) { maxSpeed = roadObj->maxSpeed; bestRoad = roadObjId; } } if (bestRoad == 0xFFU) { return true; } thought.trackObjId = bestRoad | (1U << 7); return false; } // 0x00480059 static bool chooseTrackRoadObject(CompanyId companyId, AiThought& thought) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased | ThoughtTypeFlags::airBased)) { return false; } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::railBased)) { return chooseTrackObject(companyId, thought); } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::roadBased)) { return chooseBasicRoadObject(companyId, thought); } else { return chooseTramRoadObject(companyId, thought); } } // 0x00430C06 static void sub_430C06(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; if (chooseTrackRoadObject(company.id(), thought)) { state2ClearActiveThought(company); } else { company.var_4A5 = 5; } } // 0x00430C2D static void sub_430C2D(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; const auto request = aiGenerateVehiclePurchaseRequest(company, thought, thought.var_46); if (request.numVehicleObjects == 0) { state2ClearActiveThought(company); return; } thought.var_45 = request.numVehicleObjects; thought.var_43 = request.dl; thought.var_7C = request.dl * request.trainRunCost; thought.var_76 += request.trainCost; company.var_85F2 = request.trainCost; company.var_4A5 = 6; } // 0x00430C73 static void sub_430C73(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; if (determineStationAndTrackModTypes(thought)) { state2ClearActiveThought(company); } else { company.var_4A5 = 7; } } // 0x00481DE3 static currency32_t estimateStationCost(const AiThought& thought) { currency32_t baseCost = 0; uint8_t costMultiplier = kThoughtTypeNumStations[enumValue(thought.type)]; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased)) { auto* airportObj = ObjectManager::get<AirportObject>(thought.stationObjId); baseCost = Economy::getInflationAdjustedCost(airportObj->buildCostFactor, airportObj->costIndex, 6); } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased)) { auto* dockObj = ObjectManager::get<DockObject>(thought.stationObjId); baseCost = Economy::getInflationAdjustedCost(dockObj->buildCostFactor, dockObj->costIndex, 7); } else { if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::tramBased | ThoughtTypeFlags::roadBased)) { costMultiplier *= thought.stationLength; } if (thought.trackObjId & (1U << 7)) { { const auto roadObjId = thought.trackObjId & ~(1U << 7); auto* roadObj = ObjectManager::get<RoadObject>(roadObjId); const auto trackBaseCost = Economy::getInflationAdjustedCost(roadObj->buildCostFactor, roadObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getRoadMiscData(0).costFactor) / 256; baseCost += cost; } { for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::roadExtra); ++i) { if (thought.mods & (1U << i)) { auto* roadExtraObj = ObjectManager::get<RoadExtraObject>(i); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(roadExtraObj->buildCostFactor, roadExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getRoadMiscData(0).costFactor) / 256; baseCost += cost; } } } { auto* stationObj = ObjectManager::get<RoadStationObject>(thought.stationObjId); const auto stationBaseCost = Economy::getInflationAdjustedCost(stationObj->buildCostFactor, stationObj->costIndex, 8); const auto cost = (stationBaseCost * World::TrackData::getRoadMiscData(0).costFactor) / 256; baseCost += cost; } } else { auto* trackObj = ObjectManager::get<TrackObject>(thought.trackObjId); { const auto trackBaseCost = Economy::getInflationAdjustedCost(trackObj->buildCostFactor, trackObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; baseCost += cost; } { for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::trackExtra); ++i) { if (thought.mods & (1U << i)) { auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(i); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(trackExtraObj->buildCostFactor, trackExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; baseCost += cost; } } } { auto* stationObj = ObjectManager::get<TrainStationObject>(thought.stationObjId); const auto stationBaseCost = Economy::getInflationAdjustedCost(stationObj->buildCostFactor, stationObj->costIndex, 8); const auto cost = (stationBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; baseCost += cost; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk9)) { const auto tunnelBaseCost = Economy::getInflationAdjustedCost(trackObj->tunnelCostFactor, trackObj->costIndex, 10); const auto tunnelCost = (tunnelBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; baseCost += tunnelCost; } } } } return baseCost * costMultiplier; } // 0x00430C9A static void sub_430C9A(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; thought.var_76 += estimateStationCost(thought); company.var_4A5 = 8; } // 0x004821C5 static uint32_t aiStationsManhattenTileDistance(const AiThought& thought, uint8_t aiStationIdx0, uint8_t aiStationIdx1) { auto& aiStation0 = thought.stations[aiStationIdx0]; auto& aiStation1 = thought.stations[aiStationIdx1]; const auto tilePos0 = toTileSpace(aiStation0.pos); const auto tilePos1 = toTileSpace(aiStation1.pos); return Math::Vector::manhattanDistance2D(tilePos0, tilePos1); } // 0x00481FF0 static currency32_t estimateTrackPlacementCosts(const AiThought& thought) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return 0; } currency32_t tileCost = 0; if (thought.trackObjId & (1U << 7)) { { const auto roadObjId = thought.trackObjId & ~(1U << 7); auto* roadObj = ObjectManager::get<RoadObject>(roadObjId); const auto trackBaseCost = Economy::getInflationAdjustedCost(roadObj->buildCostFactor, roadObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getRoadMiscData(0).costFactor) / 256; tileCost += cost; } { for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::roadExtra); ++i) { if (thought.mods & (1U << i)) { auto* roadExtraObj = ObjectManager::get<RoadExtraObject>(i); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(roadExtraObj->buildCostFactor, roadExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getRoadMiscData(0).costFactor) / 256; tileCost += cost; } } } } else { auto* trackObj = ObjectManager::get<TrackObject>(thought.trackObjId); { const auto trackBaseCost = Economy::getInflationAdjustedCost(trackObj->buildCostFactor, trackObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; tileCost += cost; } { for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::trackExtra); ++i) { if (thought.mods & (1U << i)) { auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(i); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(trackExtraObj->buildCostFactor, trackExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; tileCost += cost; } } } if (thought.rackRailType != 0xFFU) { auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(thought.rackRailType); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(trackExtraObj->buildCostFactor, trackExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; tileCost += cost; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk9)) { const auto trackBaseCost = Economy::getInflationAdjustedCost(trackObj->tunnelCostFactor, trackObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getTrackMiscData(0).costFactor) / 256; tileCost += cost; } } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk10)) { return 0; } uint32_t totalTileDistance = 0; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { totalTileDistance += aiStationsManhattenTileDistance(thought, 0, 1); totalTileDistance += aiStationsManhattenTileDistance(thought, 1, 2); totalTileDistance += aiStationsManhattenTileDistance(thought, 2, 3); totalTileDistance += aiStationsManhattenTileDistance(thought, 3, 0); } else { totalTileDistance += aiStationsManhattenTileDistance(thought, 0, 1); } return totalTileDistance * tileCost; } // 0x00430CBE static void sub_430CBE(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; thought.var_76 += estimateTrackPlacementCosts(thought); company.var_4A5 = 9; // TODO: activeThoughtRevenueEstimate has same address as the thoughtState2AiStationIdx variable // in the future we should use a new offset. company.thoughtState2AiStationIdx = 0; } // 0x004821EF static currency32_t estimateStationClearageCosts(const AiThought& thought, uint8_t aiStationIdx) { if (aiStationIdx >= thought.numStations) { return 0; } auto& aiStation = thought.stations[aiStationIdx]; if (aiStation.hasFlags(AiThoughtStationFlags::operational)) { return 0; } currency32_t totalCost = 0; const auto minPos = aiStation.pos - World::Pos2{ 64, 64 }; const auto maxPos = aiStation.pos + World::Pos2{ 64, 64 }; for (const auto& pos : getClampedRange(minPos, maxPos)) { auto tile = TileManager::get(pos); for (const auto& el : tile) { auto* elTree = el.as<TreeElement>(); auto* elBuilding = el.as<BuildingElement>(); if (elBuilding != nullptr) { if (elBuilding->sequenceIndex() == 0) { auto* buildingObj = ObjectManager::get<BuildingObject>(elBuilding->objectId()); if (!buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters | BuildingObjectFlags::indestructible)) { totalCost += Economy::getInflationAdjustedCost(buildingObj->clearCostFactor, buildingObj->clearCostIndex, 8); } } } else if (elTree != nullptr) { auto* treeObj = ObjectManager::get<TreeObject>(elTree->treeObjectId()); totalCost += Economy::getInflationAdjustedCost(treeObj->clearCostFactor, treeObj->costIndex, 12); } } } return totalCost; } // 0x00430CEC static void sub_430CEC(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; // TODO: activeThoughtRevenueEstimate has same address as the thoughtState2AiStationIdx variable // in the future we should use a new offset. thought.var_76 += estimateStationClearageCosts(thought, company.thoughtState2AiStationIdx); company.thoughtState2AiStationIdx++; if (company.thoughtState2AiStationIdx >= 4) { company.var_4A5 = 10; } } // 0x004824F8 static uint32_t aiStationsTileDistance(const AiThought& thought, uint8_t aiStationIdx0, uint8_t aiStationIdx1) { auto& aiStation0 = thought.stations[aiStationIdx0]; auto& aiStation1 = thought.stations[aiStationIdx1]; const auto tilePos0 = toTileSpace(aiStation0.pos); const auto tilePos1 = toTileSpace(aiStation1.pos); return Math::Vector::distance2D(tilePos0, tilePos1); } // 0x004822E8 static currency32_t estimateThoughtRevenue(const AiThought& thought) { uint32_t averageTrackTileDistance = 0; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { uint32_t totalTrackTileDistance = aiStationsTileDistance(thought, 0, 1); totalTrackTileDistance += aiStationsTileDistance(thought, 1, 2); totalTrackTileDistance += aiStationsTileDistance(thought, 2, 3); totalTrackTileDistance += aiStationsTileDistance(thought, 3, 0); averageTrackTileDistance = totalTrackTileDistance / 4; } else { averageTrackTileDistance += aiStationsTileDistance(thought, 0, 1); } Speed16 minSpeed = kSpeed16Max; for (auto i = 0U; i < thought.var_45; ++i) { auto* vehicleObj = ObjectManager::get<VehicleObject>(thought.var_46[i]); minSpeed = std::min(vehicleObj->speed, minSpeed); } const auto speedFactor = ((minSpeed.getRaw() / 2) * 180) / 256; // 0x0112C3AA const auto distanceFactor = std::clamp(averageTrackTileDistance * 2 / (speedFactor == 0 ? 1 : speedFactor), 1U, 256U); // 0x0112C3AC auto distanceFactor2 = distanceFactor * 4; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { distanceFactor2 *= 2; } distanceFactor2 /= thought.var_43; uint32_t estimatedNumUnits = 0; const auto cargoObj = ObjectManager::get<CargoObject>(thought.cargoType); for (auto i = 0U; i < thought.var_45; ++i) { bool cargoFound = false; auto* vehicleObj = ObjectManager::get<VehicleObject>(thought.var_46[i]); for (auto j = 0U; j < 2; ++j) { if (vehicleObj->compatibleCargoCategories[j] & (1U << thought.cargoType)) { estimatedNumUnits += vehicleObj->maxCargo[j]; cargoFound = true; break; } } if (cargoFound) { continue; } if (vehicleObj->hasFlags(VehicleObjectFlags::refittable)) { if (cargoObj->hasFlags(CargoObjectFlags::refit)) { const auto sourceCargoType = Numerics::bitScanForward(vehicleObj->compatibleCargoCategories[0]); estimatedNumUnits += Vehicles::getNumUnitsForCargo(vehicleObj->maxCargo[0], sourceCargoType, thought.cargoType); } } } const auto transferTimeFactor = (std::min<int32_t>((cargoObj->cargoTransferTime * estimatedNumUnits) / 256, 65535) / 192) * 4; const auto estimatedNumDays = distanceFactor + transferTimeFactor / 8; const auto estimatedPayment = CompanyManager::calculateDeliveredCargoPayment(thought.cargoType, estimatedNumUnits, averageTrackTileDistance, estimatedNumDays); const auto unkTimeFactor = 2920 / std::max<int32_t>(transferTimeFactor + distanceFactor2, 1); return estimatedPayment * unkTimeFactor; } // 0x00430D26 static void sub_430D26(Company& company) { company.var_25BE = AiThoughtType::null; auto& thought = company.aiThoughts[company.activeThoughtId]; company.activeThoughtRevenueEstimate = estimateThoughtRevenue(thought); company.var_4A5 = 11; } // 0x00430D54 static void sub_430D54(Company& company) { company.var_2582 = 0; company.var_4A5 = 12; } static constexpr std::array<uint8_t, 12> kIntelligenceToMoneyFactor = { 1, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, }; static bool sub_482533(Company& company, AiThought& thought) { auto unk = company.activeThoughtRevenueEstimate - thought.var_7C * 24; if (unk <= 0) { return true; } auto* competitorObj = ObjectManager::get<CompetitorObject>(company.competitorId); unk = unk * kIntelligenceToMoneyFactor[competitorObj->intelligence] / 2; if (unk < thought.var_76) { return true; } return !CompanyManager::ensureCompanyFunding(company.id(), thought.var_76); } // 0x00430D7B static void sub_430D7B(Company& company) { auto& thought = company.aiThoughts[company.activeThoughtId]; if (sub_482533(company, thought)) { state2ClearActiveThought(company); } else { company.var_4A4 = AiThinkState::unk3; company.var_4A5 = 0; // 0x00482578 company.var_259A = 0xFE; company.var_259B = 0xFE; company.var_259C = 0xFE; company.var_2596 = 0; thought.var_76 = 0; } } // 0x00430DAE static void sub_430DAE(Company& company) { company.var_4A4 = AiThinkState::unk0; } using AiThinkState2Function = void (*)(Company&); static constexpr std::array<AiThinkState2Function, 14> _funcs_4F94B0 = { sub_430A12, sub_430B5D, sub_430BAB, sub_430BDA, sub_430C06, sub_430C2D, sub_430C73, sub_430C9A, sub_430CBE, sub_430CEC, sub_430D26, sub_430D54, sub_430D7B, sub_430DAE, }; // 0x004309FD static void aiThinkState2(Company& company) { company.var_85F6++; _funcs_4F94B0[company.var_4A5](company); } // 0x004834C0, 0x0048352E, 0x00493594 template<typename Filter> static uint8_t sub_4834C0(const AiThought& thought, Filter&& bridgeFilter) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return 0; } sfl::static_vector<uint8_t, 8> bridges{}; if (thought.trackObjId & (1U << 7)) { const uint8_t roadObjId = thought.trackObjId & ~(1U << 7); bridges = getAvailableCompatibleBridges(roadObjId, TransportMode::road); } else { bridges = getAvailableCompatibleBridges(thought.trackObjId, TransportMode::rail); } const auto chosenBridge = [&bridges, &bridgeFilter]() { Speed16 maxSpeed = kSpeedZero; uint8_t bestBridge = 0xFFU; for (auto bridgeObjId : bridges) { auto* bridgeObj = ObjectManager::get<BridgeObject>(bridgeObjId); if (!bridgeFilter(*bridgeObj)) { continue; } auto speed = bridgeObj->maxSpeed; if (bridgeObj->maxSpeed == kSpeed16Null) { speed = Speed16(0x7FFF); } if (maxSpeed < speed) { maxSpeed = speed; bestBridge = bridgeObjId; } } return bestBridge; }(); return chosenBridge; } // 0x00482D07 static bool sub_482D07_air(Company& company, AiThought& thought, uint8_t aiStationIdx) { // 0x00112C3C0 = bridgeHeight StationId foundStation = StationId::null; for (auto& station : StationManager::stations()) { if (station.owner != company.id()) { continue; } if ((station.flags & StationFlags::transportModeAir) == StationFlags::none) { continue; } auto& aiStation = thought.stations[aiStationIdx]; const auto distance = Math::Vector::manhattanDistance2D(aiStation.pos, World::Pos2{ station.x, station.y }); if (distance >= 512) { continue; } const auto cargoType = thought.cargoType; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { if (aiStationIdx == 0) { if (station.cargoStats[cargoType].quantity != 0) { // 0x00482DA2 foundStation = station.id(); break; } } else { if (station.cargoStats[cargoType].isAccepted()) { // 0x00482DA2 foundStation = station.id(); break; } } } else { if (station.cargoStats[cargoType].isAccepted() && station.cargoStats[cargoType].quantity != 0) { // 0x00482DA2 foundStation = station.id(); break; } } } if (foundStation != StationId::null) { // 0x00482DA2 for (auto& otherThought : company.aiThoughts) { if (otherThought.type == AiThoughtType::null) { continue; } if (!thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::airBased)) { continue; } for (auto i = 0U; i < otherThought.numStations; ++i) { auto& otherAiStation = otherThought.stations[i]; if (otherAiStation.id != foundStation) { continue; } if (!otherAiStation.hasFlags(AiThoughtStationFlags::operational)) { continue; } // 0x00482E00 auto& aiStation = thought.stations[aiStationIdx]; aiStation.id = foundStation; aiStation.pos = otherAiStation.pos; aiStation.baseZ = otherAiStation.baseZ; aiStation.rotation = otherAiStation.rotation; aiStation.var_02 &= ~AiThoughtStationFlags::aiAllocated; aiStation.var_02 |= AiThoughtStationFlags::operational; return false; } } } // 0x00482E3C const auto randVal = gPrng1().randNext(); const auto randTileX = (randVal & 0x1F) - 15; const auto randTileY = ((randVal >> 5) & 0x1F) - 15; const auto randTileOffset = World::TilePos2(randTileX, randTileY); auto& aiStation = thought.stations[aiStationIdx]; const auto newAirportTilePos = World::toTileSpace(aiStation.pos) + randTileOffset; auto* airportObj = ObjectManager::get<AirportObject>(thought.stationObjId); const auto [minPos, maxPos] = airportObj->getAirportExtents(newAirportTilePos, aiStation.rotation); // 0x00482F21 auto maxHeight = -1; for (auto& tilePos : getClampedRange(minPos, maxPos)) { auto tile = TileManager::get(tilePos); auto* elSurface = tile.surface(); auto height = elSurface->baseHeight(); if (elSurface->water()) { height = elSurface->waterHeight(); } maxHeight = std::max<int>(maxHeight, height); } // 0x00482FA4 if (!World::validCoords(maxPos)) { return true; } const bool shouldCreateAirport = [&thought, aiStationIdx, minLoc = minPos, maxLoc = maxPos]() { const auto [acceptedCargo, producedCargo] = calcAcceptedCargoAi(minLoc, maxLoc); if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { if (aiStationIdx == 0) { if (!(producedCargo & (1U << thought.cargoType))) { return false; } } else { if (!(acceptedCargo & (1U << thought.cargoType))) { return false; } } } else { if (!(producedCargo & (1U << thought.cargoType))) { return false; } if (!(acceptedCargo & (1U << thought.cargoType))) { return false; } } return true; }(); if (!shouldCreateAirport) { return true; } GameCommands::AirportPlacementArgs args{}; args.pos = Pos3(World::toWorldSpace(newAirportTilePos), maxHeight); args.rotation = aiStation.rotation; args.type = thought.stationObjId; const auto res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { return true; } aiStation.pos = args.pos; aiStation.baseZ = args.pos.z / World::kSmallZStep; aiStation.var_02 |= AiThoughtStationFlags::aiAllocated; return false; } // TODO: Don't do this. Original logic isn't great // Where: // - Q is the port origin // - P is the port // - X represents the border offsets // - Y represents the border offsets that shouldn't be checked but are (see TODO) // // Y X X Y // X Q P X // X P P X // Y X X Y // Note: Order important! constexpr std::array<World::TilePos2, 12> kPortBorderOffsetsAi = { World::TilePos2{ -1, -1 }, World::TilePos2{ 0, -1 }, World::TilePos2{ 1, -1 }, World::TilePos2{ 2, -1 }, World::TilePos2{ -1, 0 }, World::TilePos2{ 2, 0 }, World::TilePos2{ -1, 1 }, World::TilePos2{ 2, 1 }, World::TilePos2{ -1, 2 }, World::TilePos2{ 0, 2 }, World::TilePos2{ 1, 2 }, World::TilePos2{ 2, 2 }, }; // 0x00483088 static bool sub_483088_water(Company& company, AiThought& thought, uint8_t aiStationIdx) { // 0x00112C3C0 = bridgeHeight // Mostly the same as air StationId foundStation = StationId::null; for (auto& station : StationManager::stations()) { if (station.owner != company.id()) { continue; } // Different flag to air if ((station.flags & StationFlags::transportModeWater) == StationFlags::none) { continue; } auto& aiStation = thought.stations[aiStationIdx]; const auto distance = Math::Vector::manhattanDistance2D(aiStation.pos, World::Pos2{ station.x, station.y }); // Different constant to air if (distance >= 448) { continue; } // Same as air const auto cargoType = thought.cargoType; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { if (aiStationIdx == 0) { if (station.cargoStats[cargoType].quantity != 0) { // 0x00483123 foundStation = station.id(); break; } } else { if (station.cargoStats[cargoType].isAccepted()) { // 0x00483123 foundStation = station.id(); break; } } } else { if (station.cargoStats[cargoType].isAccepted() && station.cargoStats[cargoType].quantity != 0) { // 0x00483123 foundStation = station.id(); break; } } } // Mostly the same as air if (foundStation != StationId::null) { // 0x00483123 for (auto& otherThought : company.aiThoughts) { if (otherThought.type == AiThoughtType::null) { continue; } // Different flag to air if (!thoughtTypeHasFlags(otherThought.type, ThoughtTypeFlags::waterBased)) { continue; } for (auto i = 0U; i < otherThought.numStations; ++i) { auto& otherAiStation = otherThought.stations[i]; if (otherAiStation.id != foundStation) { continue; } if (!otherAiStation.hasFlags(AiThoughtStationFlags::operational)) { continue; } // 0x00483181 auto& aiStation = thought.stations[aiStationIdx]; aiStation.id = foundStation; aiStation.pos = otherAiStation.pos; aiStation.baseZ = otherAiStation.baseZ; aiStation.rotation = otherAiStation.rotation; aiStation.var_02 &= ~AiThoughtStationFlags::aiAllocated; aiStation.var_02 |= AiThoughtStationFlags::operational; return false; } } } // 0x004831BD const auto randVal = gPrng1().randNext(); // Different contants to air const auto randTileX = (randVal & 0xF) - 7; const auto randTileY = ((randVal >> 4) & 0xF) - 7; const auto randTileOffset = World::TilePos2(randTileX, randTileY); auto& aiStation = thought.stations[aiStationIdx]; const auto newPortTilePos = World::toTileSpace(aiStation.pos) + randTileOffset; // Different to air for a while const auto minPos = newPortTilePos; const auto maxPos = newPortTilePos + TilePos2(1, 1); auto directionLand = 0xFFU; auto directionWaterIndustry = 0xFFU; auto height = -1; for (auto& offset : kPortBorderOffsetsAi) { const auto borderPos = offset + newPortTilePos; if (!World::validCoords(borderPos)) { continue; } auto tile = TileManager::get(borderPos); { auto* elSurface = tile.surface(); if (elSurface->water()) { height = elSurface->waterHeight(); if (height - (4 * World::kSmallZStep) != elSurface->baseHeight() || !elSurface->isSlopeDoubleHeight()) { // TODO: Use kRotationToBuildingFront instead of this broken logic // (then we don't even need calculateYaw0FromVector) const auto diffWorld = toWorldSpace(offset) - World::Pos2(16, 16); // This gets the direction of this water from a point not at the origin which is // not a good idea. The -16, -16 should really be removed. Only here to match vanilla directionLand = (Vehicles::calculateYaw0FromVector(diffWorld.x, diffWorld.y) >> 4) ^ (1U << 1); } } } bool passedSurface = false; for (auto& el : tile) { if (el.as<SurfaceElement>()) { passedSurface = true; continue; } if (!passedSurface) { continue; } auto* elIndustry = el.as<World::IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->isGhost()) { continue; } auto* industry = elIndustry->industry(); auto* industryObj = ObjectManager::get<IndustryObject>(industry->objectId); if (industryObj->hasFlags(IndustryObjectFlags::builtOnWater)) { const auto diff = borderPos - minPos - World::TilePos2(1, 1); const auto diffWorld = toWorldSpace(diff); directionWaterIndustry = Vehicles::calculateYaw0FromVector(diffWorld.x, diffWorld.y) >> 4; break; } } } if (!World::validCoords(maxPos) || height == -1) { return true; } const auto direction = directionWaterIndustry == 0xFFU ? directionLand : directionWaterIndustry; if (direction == 0xFFU) { return true; } // Same as air const bool shouldCreatePort = [&thought, aiStationIdx, minPos, maxPos]() { const auto [acceptedCargo, producedCargo] = calcAcceptedCargoAi(minPos, maxPos); if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { if (aiStationIdx == 0) { if (!(producedCargo & (1U << thought.cargoType))) { return false; } } else { if (!(acceptedCargo & (1U << thought.cargoType))) { return false; } } } else { if (!(producedCargo & (1U << thought.cargoType))) { return false; } if (!(acceptedCargo & (1U << thought.cargoType))) { return false; } } return true; }(); if (!shouldCreatePort) { return true; } GameCommands::PortPlacementArgs args{}; args.pos = Pos3(World::toWorldSpace(newPortTilePos), height); args.rotation = direction; args.type = thought.stationObjId; const auto res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { return true; } aiStation.pos = args.pos; aiStation.baseZ = args.pos.z / World::kSmallZStep; aiStation.var_02 |= AiThoughtStationFlags::aiAllocated; aiStation.rotation = direction; return false; } // 0x00482A00 static bool sub_482A00_road(Company& company, AiThought& thought, uint8_t aiStationIdx, const World::Pos3 newStationPos) { auto& aiStation = thought.stations[aiStationIdx]; GameCommands::AiRoadAndStationPlacementArgs args{}; args.pos = newStationPos; args.rotation = aiStation.rotation; args.roadObjectId = thought.trackObjId & ~(1U << 7); args.stationObjectId = thought.stationObjId; args.stationLength = thought.stationLength; if (aiStation.var_9 != 0xFFU) { args.unk1 |= (1U << 1); } if (aiStation.var_A != 0xFFU) { args.unk1 |= (1U << 0); } args.bridge = company.var_259A; auto* roadObj = ObjectManager::get<RoadObject>(args.roadObjectId); for (auto i = 0U; i < 2; ++i) { if (roadObj->mods[i] != 0xFFU && (thought.mods & (1U << roadObj->mods[i]))) { args.mods |= (1U << i); } } auto* stationObj = ObjectManager::get<RoadStationObject>(args.stationObjectId); bool doBasicPlacement = false; if (stationObj->hasFlags(RoadStationFlags::roadEnd)) { doBasicPlacement = true; } bool isTram = false; if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { isTram = true; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { doBasicPlacement = true; } } if (doBasicPlacement) { const auto res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { return true; } aiStation.pos = args.pos; aiStation.baseZ = args.pos.z / World::kSmallZStep; aiStation.var_02 |= AiThoughtStationFlags::aiAllocated; return false; } bool hasPlaced = false; auto tile = TileManager::get(newStationPos); for (auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } if (elRoad->roadId() != 0) { continue; } if (isTram) { args.rotation = elRoad->rotation(); const auto res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { continue; } hasPlaced = true; break; } else { // We are doing this as its used outside of this loop args.pos.z = elRoad->baseHeight(); args.rotation = elRoad->rotation(); GameCommands::RoadStationPlacementArgs args2{}; args2.index = 0; args2.pos = args.pos; args2.roadId = 0; args2.roadObjectId = elRoad->roadObjectId(); args2.rotation = args.rotation; args2.type = args.stationObjectId; const auto res = GameCommands::doCommand(args2, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { continue; } hasPlaced = true; break; } } if (!hasPlaced) { return true; } // 0x00482BA3 aiStation.pos = args.pos; aiStation.baseZ = args.pos.z / World::kSmallZStep; aiStation.rotation = args.rotation; aiStation.var_02 |= AiThoughtStationFlags::aiAllocated; if (aiStationIdx > 1) { return false; } auto otherAiStationIdx = aiStationIdx == 0 ? 1 : 0; auto& otherAiStation = thought.stations[otherAiStationIdx]; const auto dx = Math::Vector::manhattanDistance2D(aiStation.pos + kRotationOffset[aiStation.rotation], otherAiStation.pos); const auto ax = Math::Vector::manhattanDistance2D(aiStation.pos - kRotationOffset[aiStation.rotation], otherAiStation.pos); if (ax < dx) { if (aiStation.var_9 == 0xFFU || aiStation.var_9 == aiStationIdx) { std::swap(aiStation.var_9, aiStation.var_A); std::swap(aiStation.var_B, aiStation.var_C); } } else { if (aiStation.var_A == 0xFFU || aiStation.var_A == aiStationIdx) { std::swap(aiStation.var_9, aiStation.var_A); std::swap(aiStation.var_B, aiStation.var_C); } } return false; } // 0x00482914 static bool sub_482914_rail(Company& company, AiThought& thought, uint8_t aiStationIdx, const World::Pos3 newStationPos) { auto& aiStation = thought.stations[aiStationIdx]; GameCommands::AiTrackAndStationPlacementArgs args{}; args.pos = newStationPos; args.rotation = aiStation.rotation; args.trackObjectId = thought.trackObjId; args.stationObjectId = thought.stationObjId; args.stationLength = thought.stationLength; if (aiStation.var_9 != 0xFFU) { args.unk1 |= (1U << 1); } if (aiStation.var_A != 0xFFU) { args.unk1 |= (1U << 0); } args.bridge = company.var_259A; auto* trackObj = ObjectManager::get<TrackObject>(thought.trackObjId); for (auto i = 0U; i < 4; ++i) { if (trackObj->mods[i] != 0xFFU && (thought.mods & (1U << trackObj->mods[i]))) { args.mods |= (1U << i); } } const auto res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res == GameCommands::FAILURE) { return true; } aiStation.pos = args.pos; aiStation.baseZ = args.pos.z / World::kSmallZStep; aiStation.var_02 |= AiThoughtStationFlags::aiAllocated; return false; } // 0x00482691 static bool sub_482691_trackAndRoad(Company& company, AiThought& thought, uint8_t aiStationIdx, uint16_t bridgeHeight) { const auto randVal = gPrng1().randNext(); // Different constants to air const auto randTileX = (randVal & 0x7) - 3; const auto randTileY = ((randVal >> 3) & 0x7) - 3; const auto randTileOffset = World::TilePos2(randTileX, randTileY); auto& aiStation = thought.stations[aiStationIdx]; const auto randStationTilePos = World::toTileSpace(aiStation.pos) + randTileOffset; const auto length = thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::railBased) ? thought.stationLength : 1; const auto newStationTilePos = randStationTilePos - toTileSpace(kRotationOffset[aiStation.rotation]) * (length / 2); auto checkLength = length; auto minPos = newStationTilePos; if (!(thought.trackObjId & (1U << 7))) { if (aiStation.var_9 != 0xFFU) { minPos -= toTileSpace(kRotationOffset[aiStation.rotation]) * 2; checkLength += 2; } if (aiStation.var_A != 0xFFU) { minPos += toTileSpace(kRotationOffset[aiStation.rotation]) * 2; checkLength += 2; } } auto maxPos = minPos + toTileSpace(kRotationOffset[aiStation.rotation]) * (checkLength - 1); if (minPos.x > maxPos.x) { std::swap(minPos.x, maxPos.x); } if (minPos.y > maxPos.y) { std::swap(minPos.y, maxPos.y); } auto maxBaseZ = -1; auto tunnelBaseZ = std::numeric_limits<int32_t>::max(); for (auto& tilePos : getClampedRange(minPos, maxPos)) { auto tile = TileManager::get(tilePos); auto* elSurface = tile.surface(); tunnelBaseZ = std::min<int32_t>(tunnelBaseZ, elSurface->baseZ()); auto baseZ = World::TileManager::getSurfaceCornerHeight(*elSurface); auto waterBaseZ = (elSurface->water() + 1) * kMicroToSmallZStep; maxBaseZ = std::max<int32_t>(maxBaseZ, baseZ); maxBaseZ = std::max(maxBaseZ, waterBaseZ); } auto maxHeight = maxBaseZ * kSmallZStep + bridgeHeight; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk9)) { maxHeight = tunnelBaseZ * kSmallZStep - 32 - bridgeHeight; } // 0x0048282E auto stationMin = newStationTilePos; auto stationMax = stationMin; if (length != 1) { stationMax += toTileSpace(kRotationOffset[aiStation.rotation]) * (length - 1); } if (stationMin.x > stationMax.x) { std::swap(stationMin.x, stationMax.x); } if (stationMin.y > stationMax.y) { std::swap(stationMin.y, stationMax.y); } if (!World::validCoords(stationMax)) { return true; } const bool shouldCreateStation = [&thought, aiStationIdx, stationMin, stationMax]() { const auto [acceptedCargo, producedCargo] = calcAcceptedCargoAi(stationMin, stationMax); if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6) || aiStationIdx >= 2) { if (!(producedCargo & (1U << thought.cargoType))) { return false; } return true; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk7)) { if (aiStationIdx == 0) { if (!(producedCargo & (1U << thought.cargoType))) { return false; } } else { if (!(acceptedCargo & (1U << thought.cargoType))) { return false; } } } else { if (!(producedCargo & (1U << thought.cargoType))) { return false; } if (!(acceptedCargo & (1U << thought.cargoType))) { return false; } } return true; }(); if (!shouldCreateStation) { return true; } if (thought.trackObjId & (1U << 7)) { return sub_482A00_road(company, thought, aiStationIdx, Pos3(World::toWorldSpace(newStationTilePos), maxHeight)); } else { return sub_482914_rail(company, thought, aiStationIdx, Pos3(World::toWorldSpace(newStationTilePos), maxHeight)); } } // 0x00482662 static bool sub_482662(Company& company, AiThought& thought, uint8_t station, uint16_t bridgeHeight) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased)) { return sub_482D07_air(company, thought, station); } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::waterBased)) { return sub_483088_water(company, thought, station); } return sub_482691_trackAndRoad(company, thought, station, bridgeHeight); } // 0x0048259F static uint8_t sub_48259F(Company& company, AiThought& thought) { if (company.var_259A == 254) { company.var_259A = sub_4834C0(thought, [](const BridgeObject& bridgeObj) { if (bridgeObj.maxHeight < 4) { return false; } if ((bridgeObj.disabledTrackCfg & (Track::CommonTraitFlags::slope | Track::CommonTraitFlags::steepSlope | Track::CommonTraitFlags::verySmallCurve | Track::CommonTraitFlags::smallCurve | Track::CommonTraitFlags::curve | Track::CommonTraitFlags::largeCurve | Track::CommonTraitFlags::sBendCurve | Track::CommonTraitFlags::unk12)) != Track::CommonTraitFlags::none) { return false; } return true; }); return 0; } if (company.var_259B == 254) { company.var_259B = sub_4834C0(thought, [](const BridgeObject& bridgeObj) { if (bridgeObj.maxHeight < 8) { return false; } return true; }); return 0; } if (company.var_259C == 254) { company.var_259C = sub_4834C0(thought, [](const BridgeObject& bridgeObj) { if (bridgeObj.maxHeight < 8) { return false; } if ((bridgeObj.disabledTrackCfg & (Track::CommonTraitFlags::verySmallCurve | Track::CommonTraitFlags::smallCurve | Track::CommonTraitFlags::curve | Track::CommonTraitFlags::largeCurve | Track::CommonTraitFlags::sBendCurve)) != Track::CommonTraitFlags::none) { return false; } return true; }); return 0; } const auto chosenStation = [&thought]() { for (auto i = 0U; i < thought.numStations; ++i) { auto& aiStation = thought.stations[i]; if (!aiStation.hasFlags(AiThoughtStationFlags::aiAllocated | AiThoughtStationFlags::operational)) { return i; } } return 0xFFU; }(); if (chosenStation == 0xFFU) { return 2; } for (auto i = 0U; i < 3; ++i) { auto bridgeHeight = 0U; if (company.var_2596 >= 200) { bridgeHeight = 32; } else if (company.var_2596 >= 100) { bridgeHeight = 16; } if (!sub_482662(company, thought, chosenStation, bridgeHeight)) { company.var_2596 = 0; return 0; } company.var_2596++; if (company.var_2596 >= 400) { return 1; } } return 0; } // 0x0048377C static void sub_48377C(Company& company, AiThought& thought) { company.var_85C2 = 0xFFU; company.var_85C3 = 0; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk17)) { company.var_85C3 |= (1U << 3); } if (thought.hasPurchaseFlags(AiPurchaseFlags::unk0)) { company.var_85C3 |= (1U << 2); } if (thought.hasPurchaseFlags(AiPurchaseFlags::unk1)) { company.var_85C3 |= (1U << 4); } } // 0x00430DDF static void sub_430DDF(Company& company, AiThought& thought) { if ((company.challengeFlags & CompanyFlags::unk1) != CompanyFlags::none) { company.var_4A4 = AiThinkState::unk6; company.var_4A5 = 3; } else { switch (sub_48259F(company, thought)) { case 1: company.var_4A4 = AiThinkState::unk6; company.var_4A5 = 3; break; case 2: company.var_4A5 = 1; sub_48377C(company, thought); break; default: break; } } } // 0x004837C2 static bool sub_4837C2(Company& company, AiThought& thought) { company.var_85C3 &= ~((1U << 0) | (1U << 1)); if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return true; } auto findRequiredAiStation = [&thought, &company]() -> int8_t { for (auto i = 0U; i < thought.numStations; ++i) { const auto& aiStation = thought.stations[i]; if (aiStation.var_9 != 0xFFU) { if (!(aiStation.var_B & ((1U << 2) | (1U << 1)))) { return i; } if (aiStation.var_B & (1U << 0)) { if (!(aiStation.var_B & ((1U << 4) | (1U << 3)))) { return i; } } } if (aiStation.var_A != 0xFFU) { if (!(aiStation.var_C & ((1U << 2) | (1U << 1)))) { company.var_85C3 |= 1U << 0; return i; } if (aiStation.var_C & (1U << 0)) { if (!(aiStation.var_C & ((1U << 4) | (1U << 3)))) { company.var_85C3 |= 1U << 0; return i; } } } } return -1; }(); if (findRequiredAiStation == -1) { return true; } { company.var_85C2 = findRequiredAiStation; const auto& aiStation = thought.stations[findRequiredAiStation]; auto pos = aiStation.pos; auto rotation = aiStation.rotation; if (company.var_85C3 & (1U << 0)) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::railBased)) { const auto stationEndDiff = kRotationOffset[rotation] * (thought.stationLength - 1); pos += stationEndDiff; } rotation ^= (1U << 1); } rotation ^= (1U << 1); company.var_85C4 = pos; company.var_85C8 = aiStation.baseZ; company.var_85CE = rotation; company.var_85D0 = pos; company.var_85D4 = aiStation.baseZ; company.var_85D5 = rotation; } { const auto aiStationIndex = (company.var_85C3 & (1U << 0)) ? thought.stations[findRequiredAiStation].var_A : thought.stations[findRequiredAiStation].var_9; const auto& aiStation = thought.stations[aiStationIndex]; if (aiStation.var_9 != company.var_85C2) { company.var_85C3 |= (1U << 1); } auto pos = aiStation.pos; auto rotation = aiStation.rotation; if (company.var_85C3 & (1U << 1)) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::railBased)) { const auto stationEndDiff = kRotationOffset[rotation] * (thought.stationLength - 1); pos += stationEndDiff; } rotation ^= (1U << 1); } rotation ^= (1U << 1); company.var_85C9 = pos; company.var_85CD = aiStation.baseZ; company.var_85CF = rotation; company.var_85D7 = pos; company.var_85DB = aiStation.baseZ; company.var_85DC = rotation; } company.var_85F0 = 0; company.var_85EE = 0; company.var_85EF = 0; company.var_85DE = 0; company.var_85E2 = 0; company.var_85E8 = 0; const auto distance = std::max<uint16_t>(256, Math::Vector::distance3D(World::Pos3(company.var_85C4, company.var_85C8 * World::kSmallZStep), World::Pos3(company.var_85C9, company.var_85CD * World::kSmallZStep))); company.var_85EA = distance / 2 + distance * 2; // TODO: When diverging just set this all to a fixed value rather than only first entry for (auto& htEntry : company.var_25C0) { htEntry.var_00 = 0xFFFFU; } company.var_25C0_length = 0; return false; } // 0x00486324 static bool sub_486324(Company& company, AiThought& thought) { // Likely this is asking if the track/road should try place a signal if (thought.trackObjId & (1U << 7)) { return false; } if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return false; } if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk17 | ThoughtTypeFlags::unk6)) { return false; } if (thought.signalObjId == 0xFFU) { return true; } company.var_85C2 = 0; return false; } // 0x00430E21 static void sub_430E21(Company& company, AiThought& thought) { if ((company.challengeFlags & CompanyFlags::unk1) != CompanyFlags::none) { company.var_4A4 = AiThinkState::unk6; company.var_4A5 = 2; company.var_85C4 = World::Pos2(0, 0); return; } if (company.var_85C2 != 0xFFU) { if (aiPathfind(company, thought)) { company.var_4A4 = AiThinkState::unk6; company.var_4A5 = 2; company.var_85C4 = World::Pos2(0, 0); } } else { if (sub_4837C2(company, thought)) { company.var_4A5 = 2; if (sub_486324(company, thought)) { company.var_4A4 = AiThinkState::unk6; company.var_4A5 = 2; company.var_85C4 = World::Pos2(0, 0); } } } } // 0x00486498 // Will keep placing signals (one sided) until either: // * Reaches a station // * More than 1 track connection static void placeAiAllocatedSignalsEvenlySpaced(const World::Pos3 startPos, const uint16_t startTad, const uint8_t trackObjId, const uint16_t minSignalDistance, const uint8_t signalType, const uint8_t startSignalSide) { auto getNextTrack = [trackObjId](const World::Pos3 pos, const uint16_t tad) { const auto trackEnd = Track::getTrackConnectionEnd(pos, tad & Track::AdditionalTaDFlags::basicTaDMask); const auto tc = Track::getTrackConnectionsAi(trackEnd.nextPos, trackEnd.nextRotation, GameCommands::getUpdatingCompanyId(), trackObjId, 0, 0); return std::make_pair(trackEnd.nextPos, tc); }; auto shouldContinue = [](const Track::TrackConnections& tc) { return tc.connections.size() == 1 && tc.stationId == StationId::null; }; // We start with a large number to force a signal placement as soon as possible from the // start position auto distanceFromSignal = 3200; for (auto nextTrack = getNextTrack(startPos, startTad); shouldContinue(nextTrack.second); nextTrack = getNextTrack(nextTrack.first, nextTrack.second.connections[0])) { // Not const as when reversed need to get to the reverse start auto pos = nextTrack.first; // Not const as we might need to toggle the reverse bit auto tad = nextTrack.second.connections[0] & Track::AdditionalTaDFlags::basicTaDMask; const auto trackId = tad >> 3; const auto rotation = tad & 0x3; const auto lengthCopy = distanceFromSignal; distanceFromSignal += TrackData::getTrackMiscData(trackId).unkWeighting; if (lengthCopy < minSignalDistance) { continue; } uint8_t signalSide = startSignalSide; if (tad & (1U << 2)) { auto& trackSize = TrackData::getUnkTrack(tad); pos += trackSize.pos; if (trackSize.rotationEnd < 12) { pos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } tad ^= (1U << 2); // Reverse signalSide = signalSide & (1U << 0) ? (1U << 1) : (1U << 0); } GameCommands::SignalPlacementArgs args{}; args.pos = pos; args.pos.z += TrackData::getTrackPiece(trackId)[0].z; args.index = 0; args.rotation = rotation; args.trackId = trackId; args.trackObjType = trackObjId; args.sides = signalSide << 14; args.type = signalType; const auto res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::apply | GameCommands::Flags::noPayment); if (res != GameCommands::FAILURE) { distanceFromSignal = 0; } } } // 0x0048635F // returns: // true, all signals placed // false, further spans between stations to look at static bool tryPlaceAiAllocatedSignalsBetweenStations(Company& company, AiThought& thought) { if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased)) { return true; } if (thought.trackObjId & (1U << 7)) { return true; } // 0x0112C519 const uint8_t trackObjId = thought.trackObjId; const uint8_t signalType = thought.signalObjId; // At least the length of the station (which is also the max length of the vehicles) const uint16_t minSignalSpacing = thought.stationLength * 32; if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk6)) { // 0x0048639B if (company.var_85C2 >= thought.numStations) { return true; } const auto& aiStation = thought.stations[company.var_85C2]; const auto stationEnd = World::Pos3( aiStation.pos + World::Pos3{ kRotationOffset[aiStation.rotation], 0 } * (thought.stationLength - 1), aiStation.baseZ * World::kSmallZStep); const uint8_t signalSide = (1U << 0); const auto tad = 0 | aiStation.rotation; company.var_85C2++; placeAiAllocatedSignalsEvenlySpaced(stationEnd, tad, trackObjId, minSignalSpacing, signalType, signalSide); return false; } else if (thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::unk17)) { if (company.var_85C2 >= 2) { return true; } // 0x0048640F const uint8_t signalSide = company.var_85C2 & 1 ? (1U << 0) : (1U << 1); const auto& aiStation = thought.stations[0]; const auto trackEnd = Track::getTrackConnectionEnd(World::Pos3(aiStation.pos, aiStation.baseZ * World::kSmallZStep), aiStation.rotation ^ (1U << 1)); const auto tc = Track::getTrackConnectionsAi(trackEnd.nextPos, trackEnd.nextRotation, GameCommands::getUpdatingCompanyId(), trackObjId, 0, 0); if (tc.connections.size() != 2) { return false; } const auto tad = tc.connections[company.var_85C2] & Track::AdditionalTaDFlags::basicTaDMask; company.var_85C2++; placeAiAllocatedSignalsEvenlySpaced(trackEnd.nextPos, tad, trackObjId, minSignalSpacing, signalType, signalSide); return false; } return true; } // 0x00430EB5 static void sub_430EB5(Company& company, AiThought& thought) { // place signal aiAllocations if ((company.challengeFlags & CompanyFlags::unk1) != CompanyFlags::none) { company.var_4A4 = AiThinkState::unk6; company.var_4A5 = 2; company.var_85C4 = World::Pos2{ 0, 0 }; return; } if (tryPlaceAiAllocatedSignalsBetweenStations(company, thought)) { company.var_4A5 = 3; } } struct NearbyTrackResults { uint32_t numElements; // ebx ignores unowned aiallocated uint32_t numOwnedAiAllocatedElements; // edx }; // 0x004A874D static NearbyTrackResults nearbyTrackElementsStats(World::TilePos2 middlePos) { const auto p1 = middlePos - World::TilePos2(7, 7); const auto p2 = middlePos + World::TilePos2(7, 7); NearbyTrackResults res{}; for (const auto& tilePos : getClampedRange(p1, p2)) { auto tile = TileManager::get(tilePos); bool hasPassedSurface = false; for (auto& el : tile) { auto* elSurface = el.as<SurfaceElement>(); if (elSurface != nullptr) { hasPassedSurface = true; continue; } if (!hasPassedSurface) { continue; } auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->isGhost()) { continue; } if (!elTrack->hasBridge()) { continue; } if (elTrack->isAiAllocated()) { if (elTrack->owner() != GameCommands::getUpdatingCompanyId()) { continue; } res.numOwnedAiAllocatedElements++; } res.numElements++; } } return res; } // 0x004865B4 static uint8_t sub_4865B4(AiThought& thought) { if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::airBased | ThoughtTypeFlags::waterBased | ThoughtTypeFlags::unk6)) { const auto stationDist = Math::Vector::distance2D(thought.stations[0].pos, thought.stations[1].pos); if (stationDist < 224) { return 1; } } if (!thoughtTypeHasFlags(thought.type, ThoughtTypeFlags::railBased)) { return 2; } for (auto i = 0U; i < 2; ++i) { auto [numElements, numOwnedAiAllocated] = nearbyTrackElementsStats(toTileSpace(thought.stations[i].pos)); if (nu ``` > [truncated] --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyAi/CompanyAi.h ```h #pragma once #include "Economy/Currency.h" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/World.hpp> namespace OpenLoco { enum class AiThinkState : uint8_t { unk0, unk1, unk2, unk3, unk4, unk5, unk6, unk7, unk8, unk9, endCompany, }; enum class AiPlaceVehicleState : uint8_t { begin, resetList, place, restart, }; enum class AiThoughtType : uint8_t { unk0, unk1, unk2, unk3, unk4, unk5, unk6, unk7, unk8, unk9, unk10, unk11, unk12, unk13, unk14, unk15, unk16, unk17, unk18, unk19, null = 0xFF }; constexpr auto kAiThoughtTypeCount = 20U; enum class AiThoughtStationFlags : uint8_t { none = 0U, aiAllocated = 1U << 0, operational = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(AiThoughtStationFlags); enum class AiPurchaseFlags : uint8_t { none = 0, unk0 = 1U << 0, unk1 = 1U << 1, unk2 = 1U << 2, requiresMods = 1U << 3, // can be track or road mods unk4 = 1U << 4, }; OPENLOCO_ENABLE_ENUM_OPERATORS(AiPurchaseFlags); constexpr auto kMaxAiThoughts = 60U; constexpr auto kAiThoughtIdNull = 0xFFU; #pragma pack(push, 1) struct AiThought { struct Station { StationId id; // 0x0 AiThoughtStationFlags var_02; // 0x2 flags? uint8_t rotation; // 0x3 World::Pos2 pos; // 0x4 uint8_t baseZ; // 0x8 uint8_t var_9; // 0x9 aiStationIndex uint8_t var_A; // 0xA aiStationIndex uint8_t var_B; // 0xB uint8_t var_C; // 0xC uint8_t pad_D[0xE - 0xD]; constexpr bool hasFlags(AiThoughtStationFlags flags) const { return (var_02 & flags) != AiThoughtStationFlags::none; } }; static_assert(sizeof(Station) == 0xE); AiThoughtType type; // 0x00 0x4A8 uint8_t destinationA; // 0x01 0x4A9 either a TownId or IndustryId uint8_t destinationB; // 0x02 0x4AA either a TownId or IndustryId uint8_t numStations; // 0x03 0x4AB size of stations uint8_t stationLength; // 0x04 0x4AC station length uint8_t pad_05; Station stations[4]; // 0x06 0x4AE Will lists stations created that vehicles will route to uint8_t trackObjId; // 0x3E 0x4E6 track or road (with high bit set) uint8_t rackRailType; // 0x3F 0x4E7 Is 0xFFU for no rack rail uint16_t mods; // 0x40 0x4E8 track or road uint8_t cargoType; // 0x42 0x4EA uint8_t var_43; // 0x4EB uint8_t numVehicles; // 0x44 0x4EC size of var_66 uint8_t var_45; // 0x4ED size of var_46 uint16_t var_46[16]; // 0x4EF array of uint16_t object id EntityId vehicles[8]; // 0x66 0x50E see also numVehicles for current size currency32_t var_76; // 0x51E uint8_t pad_7A[0x7C - 0x7A]; currency32_t var_7C; // 0x524 currency32_t var_80; // 0x528 currency32_t var_84; // 0x52C uint8_t var_88; // 0x530 uint8_t stationObjId; // 0x89 0x531 Could be either Airport/Dock/TrainStation/RoadStation uint8_t signalObjId; // 0x8A 0x532 Can be 0xFFU for n AiPurchaseFlags purchaseFlags; // 0x8B 0x533 constexpr bool hasPurchaseFlags(AiPurchaseFlags flags) const { return (purchaseFlags & flags) != AiPurchaseFlags::none; } // Converts the TownId or IndustryId of destinationA into the center position of the destination. World::Pos2 getDestinationPositionA() const; // Converts the TownId or IndustryId of destinationB into the center position of the destination. World::Pos2 getDestinationPositionB() const; }; #pragma pack(pop) static_assert(sizeof(AiThought) == 0x8C); void aiThink(CompanyId id); void setAiObservation(CompanyId id); void removeEntityFromThought(AiThought& thought, EntityId id); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyAi/CompanyAiPathfinding.cpp ```cpp #include "CompanyAiPathfinding.h" #include "CompanyAi.h" #include "Economy/Economy.h" #include "GameCommands/CompanyAi/AiTrackReplacement.h" #include "GameCommands/Road/CreateRoad.h" #include "GameCommands/Road/RemoveRoad.h" #include "GameCommands/Track/CreateTrack.h" #include "GameCommands/Track/RemoveTrack.h" #include "GameState.h" #include "Map/BuildingElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/Tile.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Objects/BridgeObject.h" #include "Objects/BuildingObject.h" #include "Objects/LevelCrossingObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/TreeObject.h" #include "World/Company.h" #include "World/Station.h" #include <OpenLoco/Interop/Interop.hpp> namespace OpenLoco::CompanyAi { using ValidTrackRoadIds = sfl::static_vector<uint8_t, 64>; static Interop::loco_global<uint8_t, 0x0112C518> _pathFindUndoCount112C518; // company 0x85EE static Interop::loco_global<int32_t, 0x0112C398> _pathFindTotalTrackRoadWeighting; // company 0x85DE static Interop::loco_global<uint8_t, 0x0112C519> _trackRoadObjType112C519; static Interop::loco_global<World::Pos2, 0x0112C3C2> _unk1Pos112C3C2; static Interop::loco_global<World::SmallZ, 0x0112C515> _unk1PosBaseZ112C515; static Interop::loco_global<uint8_t, 0x0112C516> _unk1Rot112C516; static Interop::loco_global<World::Pos2, 0x0112C3C6> _unk2Pos112C3C6; static Interop::loco_global<World::SmallZ, 0x0112C517> _unk2PosBaseZ112C517; static Interop::loco_global<World::Pos2, 0x0112C3CC> _unk3Pos112C3CC; static Interop::loco_global<World::SmallZ, 0x0112C59C> _unk3PosBaseZ112C59C; static Interop::loco_global<uint32_t, 0x0112C364> _unk112C364; static Interop::loco_global<uint32_t, 0x0112C36C> _unk112C36C; static Interop::loco_global<uint32_t, 0x0112C35C> _unk112C35C; static Interop::loco_global<uint32_t, 0x0112C34C> _unk112C34C; // currency_32t static Interop::loco_global<uint8_t, 0x0112C59E> _unk3Rot112C59E; static Interop::loco_global<uint32_t, 0x0112C388> _createTrackRoadCommandMods; static Interop::loco_global<uint32_t, 0x0112C38C> _createTrackRoadCommandRackRail; static Interop::loco_global<Company*, 0x0112C390> _unk112C390; static Interop::loco_global<uint32_t, 0x0112C358> _maxTrackRoadWeightingLimit; // Limits the extent of the track/road placement search static Interop::loco_global<uint32_t, 0x0112C374> _createTrackRoadCommandAiUnkFlags; static Interop::loco_global<uint32_t, 0x0112C378> _trackRoadPlacementCurrentWeighting; static Interop::loco_global<uint32_t, 0x0112C37C> _trackRoadPlacementBridgeWeighting; static Interop::loco_global<uint32_t, 0x0112C380> _numBuildingRequiredDestroyed112C380; static Interop::loco_global<uint8_t, 0x0112C59B> _queryTrackRoadPlacementFlags; static Interop::loco_global<uint8_t, 0x0112C59F> _createTrackRoadCommandBridge0; static Interop::loco_global<uint8_t, 0x0112C5A0> _createTrackRoadCommandBridge1; static Interop::loco_global<uint8_t, 0x0112C5A1> _createTrackRoadCommandBridge2; static Interop::loco_global<uint16_t, 0x0112C4D4> _unkTad112C4D4; static Interop::loco_global<uint16_t, 0x0112C3CA> _unkTad112C3CA; static Interop::loco_global<uint16_t, 0x0112C3D0> _queryTrackRoadPlacementMinScore; static Interop::loco_global<uint16_t, 0x0112C3D2> _queryTrackRoadPlacementMinWeighting; static Interop::loco_global<uint8_t, 0x01136073> _byte_1136073; static Interop::loco_global<World::MicroZ, 0x01136074> _byte_1136074; static Interop::loco_global<uint8_t, 0x01136075> _byte_1136075; // bridgeType of any overlapping track static Interop::loco_global<uint8_t, 0x0112C2E9> _alternateTrackObjectId; // set from GameCommands::createRoad // 0x00483A7E static ValidTrackRoadIds sub_483A7E(const Company& company, const AiThought& thought) { // 0x0112C384 bool allowSteepSlopes = false; _trackRoadObjType112C519 = thought.trackObjId; const bool isRoad = thought.trackObjId & (1U << 7); uint32_t unkMods = 0U; uint32_t unkRackRail = 0U; if (isRoad) { // 0x00483B38 allowSteepSlopes = true; auto* roadObj = ObjectManager::get<RoadObject>(thought.trackObjId & ~(1U << 7)); for (auto i = 0U; i < std::size(roadObj->mods); ++i) { if (roadObj->mods[i] == 0xFFU) { continue; } if (thought.mods & (1U << roadObj->mods[i])) { unkMods |= (1U << (16 + i)); } if (thought.rackRailType == roadObj->mods[i]) { unkRackRail |= (1U << (16 + i)); } } } else { // 0x00483A98 allowSteepSlopes = thought.hasPurchaseFlags(AiPurchaseFlags::unk0); auto* trackObj = ObjectManager::get<TrackObject>(thought.trackObjId); for (auto i = 0U; i < std::size(trackObj->mods); ++i) { if (trackObj->mods[i] == 0xFFU) { continue; } if (thought.mods & (1U << trackObj->mods[i])) { unkMods |= (1U << (16 + i)); } if (thought.rackRailType == trackObj->mods[i]) { unkRackRail |= (1U << (16 + i)); } } } _createTrackRoadCommandMods = unkMods; _createTrackRoadCommandRackRail = unkRackRail; _createTrackRoadCommandAiUnkFlags = 1U << 22; if (company.var_85C3 & (1U << 3)) { // 0x00483BAF if (_unk2PosBaseZ112C517 == _unk3PosBaseZ112C59C) { const auto diff = *_unk2Pos112C3C6 - *_unk3Pos112C3CC; const auto absDiff = World::Pos2(std::abs(diff.x), std::abs(diff.y)); if (absDiff.x <= 3 * World::kTileSize && absDiff.y <= 3 * World::kTileSize) { _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags & ~(1U << 22); } } if (_unk2PosBaseZ112C517 == _unk1PosBaseZ112C515) { const auto diff = *_unk2Pos112C3C6 - *_unk1Pos112C3C2; const auto absDiff = World::Pos2(std::abs(diff.x), std::abs(diff.y)); if (absDiff.x <= 3 * World::kTileSize && absDiff.y <= 3 * World::kTileSize) { _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags & ~(1U << 22); } } } if (isRoad) { _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags & ~(1U << 22); auto* roadObj = ObjectManager::get<RoadObject>(thought.trackObjId & ~(1U << 7)); _createTrackRoadCommandAiUnkFlags |= (1U << 21); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags & ~(1U << 21); _createTrackRoadCommandAiUnkFlags |= (1U << 20); } } _createTrackRoadCommandBridge0 = company.var_259A; _createTrackRoadCommandBridge1 = company.var_259B; _createTrackRoadCommandBridge2 = company.var_259C; if (isRoad) { // 0x00483DAA auto* roadObj = ObjectManager::get<RoadObject>(thought.trackObjId & ~(1U << 7)); ValidTrackRoadIds validRoadIds; validRoadIds.push_back(0U); // straight using enum World::Track::RoadTraitFlags; if (roadObj->hasTraitFlags(turnaround)) { validRoadIds.push_back(9U); // turnaround } if (roadObj->hasTraitFlags(smallCurve)) { validRoadIds.push_back(3U); // leftCurveSmall validRoadIds.push_back(4U); // rightCurveSmall } if (roadObj->hasTraitFlags(verySmallCurve)) { validRoadIds.push_back(1U); // leftCurveVerySmall validRoadIds.push_back(2U); // rightCurveVerySmall } if (roadObj->hasTraitFlags(slope)) { validRoadIds.push_back(5U); // straightSlopeUp validRoadIds.push_back(6U); // straightSlopeDown if (roadObj->hasTraitFlags(steepSlope) && allowSteepSlopes) { validRoadIds.push_back(7U); // straightSteepSlopeUp validRoadIds.push_back(8U); // straightSteepSlopeDown } } return validRoadIds; } else { // 0x00483CB6 auto* trackObj = ObjectManager::get<TrackObject>(thought.trackObjId); ValidTrackRoadIds validTrackIds; validTrackIds.push_back(0U); // straight using enum World::Track::TrackTraitFlags; if (trackObj->hasTraitFlags(diagonal)) { validTrackIds.push_back(1U); // diagonal } if (trackObj->hasTraitFlags(sBend)) { validTrackIds.push_back(12U); // sBendLeft validTrackIds.push_back(13U); // sBendRight } if (trackObj->hasTraitFlags(largeCurve)) { validTrackIds.push_back(8U); // leftCurveLarge validTrackIds.push_back(9U); // rightCurveLarge validTrackIds.push_back(10U); // diagonalLeftCurveLarge validTrackIds.push_back(11U); // diagonalRightCurveLarge } if (trackObj->hasTraitFlags(normalCurve)) { validTrackIds.push_back(6U); // leftCurve validTrackIds.push_back(7U); // rightCurve } if (trackObj->hasTraitFlags(smallCurve)) { validTrackIds.push_back(4U); // leftCurveSmall validTrackIds.push_back(5U); // rightCurveSmall if (trackObj->hasTraitFlags(slopedCurve)) { validTrackIds.push_back(18U); // leftCurveSmallSlopeUp validTrackIds.push_back(19U); // rightCurveSmallSlopeUp validTrackIds.push_back(20U); // leftCurveSmallSlopeDown validTrackIds.push_back(21U); // rightCurveSmallSlopeDown if (trackObj->hasTraitFlags(steepSlope) && allowSteepSlopes) { validTrackIds.push_back(22U); // leftCurveSmallSteepSlopeUp validTrackIds.push_back(23U); // rightCurveSmallSteepSlopeUp validTrackIds.push_back(24U); // leftCurveSmallSteepSlopeDown validTrackIds.push_back(25U); // rightCurveSmallSteepSlopeDown } } } if (trackObj->hasTraitFlags(verySmallCurve)) { validTrackIds.push_back(2U); // leftCurveVerySmall validTrackIds.push_back(3U); // rightCurveVerySmall } if (trackObj->hasTraitFlags(slope)) { validTrackIds.push_back(14U); // straightSlopeUp validTrackIds.push_back(15U); // straightSlopeDown if (trackObj->hasTraitFlags(steepSlope) && allowSteepSlopes) { validTrackIds.push_back(16U); // straightSteepSlopeUp validTrackIds.push_back(17U); // straightSteepSlopeDown } } return validTrackIds; } } // 0x00483EF2 static bool sub_483EF2(const Company& company) { const auto& road0Size = World::TrackData::getUnkRoad(company.var_85D5); const auto connectPos0 = World::Pos3(company.var_85D0, company.var_85D4 * World::kSmallZStep) + road0Size.pos - World::Pos3(World::kRotationOffset[road0Size.rotationEnd], 0); const auto rotationConnect0 = road0Size.rotationEnd ^ (1U << 1); const auto& road1Size = World::TrackData::getUnkRoad(company.var_85DC); const auto connectPos1 = World::Pos3(company.var_85D7, company.var_85DB * World::kSmallZStep) + road1Size.pos; const auto rotationConnect1 = road1Size.rotationEnd; return connectPos0 == connectPos1 && rotationConnect0 == rotationConnect1; } // 0x00483E2D static bool sub_483E2D(const Company& company) { const auto& track0Size = World::TrackData::getUnkTrack(company.var_85D5); auto connectPos0 = World::Pos3(company.var_85D0, company.var_85D4 * World::kSmallZStep) + track0Size.pos; if (track0Size.rotationEnd < 12) { connectPos0 -= World::Pos3(World::kRotationOffset[track0Size.rotationEnd], 0); } const auto rotationConnect0 = track0Size.rotationEnd ^ (1U << 1); const auto& track1Size = World::TrackData::getUnkTrack(company.var_85DC); const auto connectPos1 = World::Pos3(company.var_85D7, company.var_85DB * World::kSmallZStep) + track1Size.pos; const auto rotationConnect1 = track1Size.rotationEnd; return connectPos0 == connectPos1 && rotationConnect0 == rotationConnect1; } // 0x00483E20 static bool sub_483E20(const Company& company) { const bool isRoad = _trackRoadObjType112C519 & (1U << 7); if (isRoad) { return sub_483EF2(company); } else { return sub_483E2D(company); } } struct QueryTrackRoadPlacementResult { uint8_t flags; // 0x0112C59B uint16_t minScore; // 0x0112C3D0 if score is 0 has made to destination, if score is 0xFFFF no track placement possible, else min score after max weighting limit reached uint16_t minWeighting; // 0x0112C3D2 only the min weighting if score is 0 otherwise 0xFFFF }; struct QueryTrackRoadPlacementState { uint32_t numBuildingsRequiredDestroyed; // 0x0112C380 uint32_t currentWeighting; // 0x0112C378 uint32_t bridgeWeighting; // 0x0112C37C }; // 0x004854B2 // pos : ax, cx, dl // tad : bp // unkFlag : ebp & (1U << 31) // company : _unk112C390 // // return : _queryTrackRoadPlacementFlags, _queryTrackRoadPlacementMinScore, _queryTrackRoadPlacementMinWeighting static void queryTrackPlacementScoreRecurse(Company& company, const World::Pos3 pos, const uint16_t tad, const bool unkFlag, const ValidTrackRoadIds& validTrackIds, QueryTrackRoadPlacementResult& totalResult, QueryTrackRoadPlacementState& state) { // bl const auto direction = tad & 0x3; // dh const auto trackId = (tad >> 3) & 0x3F; const auto entry = Company::Unk25C0HashTableEntry(pos, trackId, direction); if (company.hashTableContains(entry)) { return; } _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags | (1U << 22); if (company.var_85C3 & (1U << 3)) { { const auto diffZ = std::abs(_unk3PosBaseZ112C59C - (pos.z / World::kSmallZStep)); if (diffZ <= 4) { const auto diffX = std::abs(_unk3Pos112C3CC->x - pos.x); const auto diffY = std::abs(_unk3Pos112C3CC->y - pos.y); if (diffX <= 3 * World::kTileSize && diffY <= 3 * World::kTileSize) { _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags & ~(1U << 22); } } } { const auto diffZ = std::abs(_unk1PosBaseZ112C515 - (pos.z / World::kSmallZStep)); if (diffZ <= 4) { const auto diffX = std::abs(_unk1Pos112C3C2->x - pos.x); const auto diffY = std::abs(_unk1Pos112C3C2->y - pos.y); if (diffX <= 3 * World::kTileSize && diffY <= 3 * World::kTileSize) { _createTrackRoadCommandAiUnkFlags = *_createTrackRoadCommandAiUnkFlags & ~(1U << 22); } } } } // 0x004855F9 { using enum World::Track::CommonTraitFlags; if (!(_createTrackRoadCommandAiUnkFlags & (1U << 22)) && (World::TrackData::getTrackMiscData(trackId).flags & (slope | steepSlope)) != none) { return; } } GameCommands::TrackPlacementArgs args; args.rotation = direction; if (unkFlag) { args.rotation += 12; } args.trackId = trackId; args.trackObjectId = _trackRoadObjType112C519; args.bridge = _createTrackRoadCommandBridge0; args.pos = pos; args.mods = 0; args.unk = false; args.unkFlags = *_createTrackRoadCommandAiUnkFlags >> 20; { auto regs = static_cast<Interop::registers>(args); regs.bl = GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment; GameCommands::createTrack(regs); if (static_cast<uint32_t>(regs.ebx) == GameCommands::FAILURE) { return; } } totalResult.flags |= (1U << 0); state.currentWeighting += World::TrackData::getTrackMiscData(trackId).unkWeighting; // Place track attempt required a bridge if (_byte_1136073 & (1U << 0)) { // _byte_1136074 is the bridge height const auto unkFactor = (_byte_1136074 * World::TrackData::getTrackMiscData(trackId).unkWeighting) / 2; state.bridgeWeighting += unkFactor; } // Place track attempt requires removing a building if (_byte_1136073 & (1U << 4)) { state.numBuildingsRequiredDestroyed++; } // 0x004856AB const auto& trackSize = World::TrackData::getUnkTrack(tad); const auto nextPos = pos + trackSize.pos; const auto nextRotation = trackSize.rotationEnd & 0x3U; const auto newUnkFlag = trackSize.rotationEnd >= 12; { const auto diffZ = std::abs(_unk3PosBaseZ112C59C - (nextPos.z / World::kSmallZStep)); const auto diffX = std::abs(_unk3Pos112C3CC->x - nextPos.x) / 8; const auto diffY = std::abs(_unk3Pos112C3CC->y - nextPos.y) / 8; const auto squareHypot = diffX * diffX + diffY * diffY + diffZ * diffZ; const auto distScore = Math::Vector::fastSquareRoot(squareHypot); if (distScore == 0) { if (newUnkFlag) { return; } if ((nextRotation ^ (1U << 1)) != (_unkTad112C4D4 & 0x3U)) { return; } totalResult.minScore = 0; if ((state.currentWeighting & 0xFFFFU) < totalResult.minWeighting) { totalResult.minWeighting = state.currentWeighting & 0xFFFFU; } return; } if (_maxTrackRoadWeightingLimit <= state.currentWeighting) { const auto newScore = state.bridgeWeighting / 32 + distScore * 4 + state.numBuildingsRequiredDestroyed; totalResult.minScore = std::min<uint16_t>(newScore, totalResult.minScore); } else { for (auto newTrackId : validTrackIds) { const auto newTad = (newTrackId << 3) | nextRotation; const auto rotBegin = World::TrackData::getUnkTrack(newTad).rotationBegin; if (newUnkFlag) { if (rotBegin < 12) { continue; } } else { if (rotBegin >= 12) { continue; } } // Make a copy of the state as each track needs to be evaluated independently auto tempState = state; queryTrackPlacementScoreRecurse(company, nextPos, newTad, newUnkFlag, validTrackIds, totalResult, tempState); } } } } static QueryTrackRoadPlacementResult queryTrackPlacementScore(Company& company, const World::Pos3 pos, const uint16_t tad, const bool unkFlag, const ValidTrackRoadIds& validTrackIds) { QueryTrackRoadPlacementResult result{}; result.flags = 1U << 7; result.minScore = 0xFFFFU; result.minWeighting = 0xFFFFU; QueryTrackRoadPlacementState state{}; state.numBuildingsRequiredDestroyed = 0U; state.currentWeighting = 0U; state.bridgeWeighting = 0U; queryTrackPlacementScoreRecurse(company, pos, tad, unkFlag, validTrackIds, result, state); return result; } // 0x00485849 // pos : ax, cx, dl // tad : bp // company : _unk112C390 // // return : _queryTrackRoadPlacementFlags, _queryTrackRoadPlacementMinScore, _queryTrackRoadPlacementMinWeighting static void queryRoadPlacementScoreRecurse(Company& company, const World::Pos3 pos, const uint16_t tad, const ValidTrackRoadIds& validRoadIds, QueryTrackRoadPlacementResult& totalResult, QueryTrackRoadPlacementState& state) { // bl const auto direction = tad & 0x3; // dh const auto roadId = (tad >> 3) & 0xF; const auto entry = Company::Unk25C0HashTableEntry(pos, roadId, direction); if (company.hashTableContains(entry)) { return; } GameCommands::RoadPlacementArgs args; args.rotation = direction; args.roadId = roadId; args.roadObjectId = _trackRoadObjType112C519 & ~(1U << 7); args.bridge = _createTrackRoadCommandBridge0; args.pos = pos; args.mods = 0; args.unkFlags = *_createTrackRoadCommandAiUnkFlags >> 16; { auto regs = static_cast<Interop::registers>(args); regs.bl = GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment; GameCommands::createRoad(regs); if (static_cast<uint32_t>(regs.ebx) == GameCommands::FAILURE) { if ((_createTrackRoadCommandAiUnkFlags & (1U << 20)) && _alternateTrackObjectId != 0xFFU) { args.roadObjectId = _alternateTrackObjectId; } if (_byte_1136075 != 0xFFU) { args.bridge = _byte_1136075; } regs = static_cast<Interop::registers>(args); regs.bl = GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment; GameCommands::createRoad(regs); if (static_cast<uint32_t>(regs.ebx) == GameCommands::FAILURE) { return; } } } totalResult.flags |= (1U << 0); auto placementWeighting = World::TrackData::getRoadMiscData(roadId).unkWeighting; // Place road attempt overlayed an existing road if (_byte_1136073 & (1U << 5)) { placementWeighting -= placementWeighting / 4; } state.currentWeighting += placementWeighting; // Place road attempt required a bridge if (_byte_1136073 & (1U << 0)) { // _byte_1136074 is the bridge height const auto unkFactor = (_byte_1136074 * placementWeighting) / 2; state.bridgeWeighting += unkFactor; } // Place road attempt requires removing a building if (_byte_1136073 & (1U << 4)) { state.numBuildingsRequiredDestroyed++; } // 0x00485A01 const auto& roadSize = World::TrackData::getUnkRoad(tad); const auto nextPos = pos + roadSize.pos; const auto nextRotation = roadSize.rotationEnd & 0x3U; { const auto diffZ = std::abs(_unk3PosBaseZ112C59C - (nextPos.z / World::kSmallZStep)); const auto diffX = std::abs(_unk3Pos112C3CC->x - nextPos.x) / 8; const auto diffY = std::abs(_unk3Pos112C3CC->y - nextPos.y) / 8; const auto squareHypot = diffX * diffX + diffY * diffY + diffZ * diffZ; const auto distScore = Math::Vector::fastSquareRoot(squareHypot); if (distScore == 0) { if ((nextRotation ^ (1U << 1)) != (_unkTad112C4D4 & 0x3U)) { return; } totalResult.minScore = 0; if ((state.currentWeighting & 0xFFFFU) < totalResult.minWeighting) { totalResult.minWeighting = state.currentWeighting & 0xFFFFU; } return; } if (_maxTrackRoadWeightingLimit <= state.currentWeighting) { const auto newScore = state.bridgeWeighting / 32 + distScore * 4 + state.numBuildingsRequiredDestroyed; totalResult.minScore = std::min<uint16_t>(newScore, totalResult.minScore); } else { for (const auto newRoadId : validRoadIds) { const auto newTad = (newRoadId << 3) | nextRotation; // Make a copy of the state as each track needs to be evaluated independently auto tempState = state; queryRoadPlacementScoreRecurse(company, nextPos, newTad, validRoadIds, totalResult, tempState); } } } } static QueryTrackRoadPlacementResult queryRoadPlacementScore(Company& company, const World::Pos3 pos, const uint16_t tad, const ValidTrackRoadIds& validRoadIds) { QueryTrackRoadPlacementResult result{}; result.flags = 1U << 7; result.minScore = 0xFFFFU; result.minWeighting = 0xFFFFU; QueryTrackRoadPlacementState state{}; state.numBuildingsRequiredDestroyed = 0U; state.currentWeighting = 0U; state.bridgeWeighting = 0U; queryRoadPlacementScoreRecurse(company, pos, tad, validRoadIds, result, state); return result; } // 0x00484B5C static void pathFindTrackUndoSection(Company& company) { if (_pathFindTotalTrackRoadWeighting <= 0) { _pathFindUndoCount112C518 = 0; return; } const auto trackId = (_unkTad112C3CA >> 3) & 0x3F; _pathFindTotalTrackRoadWeighting -= static_cast<int32_t>(World::TrackData::getTrackMiscData(trackId).unkWeighting); _pathFindUndoCount112C518--; const auto rotation = (_unkTad112C3CA & 0x3U); auto& trackPiece0 = World::TrackData::getTrackPiece(trackId)[0]; const auto pos = World::Pos3(_unk2Pos112C3C6, (_unk2PosBaseZ112C517 * World::kSmallZStep) + trackPiece0.z); const auto hasAiAllocatedElTrack = [&pos, rotation, trackId]() { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseZ() != pos.z / World::kSmallZStep) { continue; } if (elTrack->rotation() != rotation) { continue; } if (!elTrack->isAiAllocated()) { continue; } if (elTrack->hasStationElement()) { continue; } if (elTrack->trackId() != trackId) { continue; } if (elTrack->sequenceIndex() != 0) { continue; } if (elTrack->trackObjectId() != _trackRoadObjType112C519) { continue; } return true; } return false; }(); if (!hasAiAllocatedElTrack) { company.var_85F0 = 0xF000U; return; } GameCommands::TrackRemovalArgs args; args.pos = pos; args.rotation = rotation; args.trackId = trackId; args.index = 0U; args.trackObjectId = _trackRoadObjType112C519; GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); // No check of failure! auto nextPos = World::Pos3(_unk2Pos112C3C6, _unk2PosBaseZ112C517 * World::kSmallZStep); const auto rot = World::TrackData::getUnkTrack(_unkTad112C3CA & 0x3FFU).rotationBegin; if (rot < 12) { nextPos -= World::Pos3(World::kRotationOffset[rot], 0); } const auto nextRot = World::kReverseRotation[rot]; const auto tc = World::Track::getTrackConnectionsAi(nextPos, nextRot, company.id(), _trackRoadObjType112C519, 0, 0); if (tc.connections.empty()) { company.var_85F0 = 0xF000U; return; } { auto newTad = tc.connections[0] & 0x1FFU; auto newPos = nextPos + World::TrackData::getUnkTrack(newTad).pos; const auto rotEnd = World::TrackData::getUnkTrack(newTad).rotationEnd; if (rotEnd < 12) { newPos -= World::Pos3(World::kRotationOffset[rotEnd], 0); } // Normalise the rotation (remove the reverse bit and reverse the rotation if required) newTad ^= (1U << 2); if (newTad & (1U << 2)) { newTad &= 0x3; newTad ^= (1U << 1); } _unkTad112C3CA = newTad; _unk2Pos112C3C6 = newPos; _unk2PosBaseZ112C517 = newPos.z / World::kSmallZStep; } } // 0x00484655 static void pathFindTrackSection(Company& company, const ValidTrackRoadIds& validTrackIds) { if (_pathFindUndoCount112C518 == 0) { // 0x00484662 if (_pathFindTotalTrackRoadWeighting >= static_cast<int32_t>(company.var_85EA)) { company.var_85F0 = 0xF000U; return; } // 0x00484813 _maxTrackRoadWeightingLimit = (company.var_85C3 & ((1U << 4) | (1U << 2))) ? 138 : 224; { auto pos = World::Pos3(_unk3Pos112C3CC, _unk3PosBaseZ112C59C * World::kSmallZStep); auto tad = _unkTad112C4D4 & 0x3FFU; auto& trackSize = World::TrackData::getUnkTrack(tad); pos += trackSize.pos; auto rotation = trackSize.rotationEnd; if (rotation < 12) { pos -= World::Pos3(World::kRotationOffset[rotation], 0); } rotation ^= (1U << 1); _unk3Pos112C3CC = pos; _unk3PosBaseZ112C59C = pos.z / World::kSmallZStep; _unk3Rot112C59E = rotation; } auto pos = World::Pos3(_unk2Pos112C3C6, _unk2PosBaseZ112C517 * World::kSmallZStep); auto tad = _unkTad112C3CA & 0x3FFU; auto& trackSize = World::TrackData::getUnkTrack(tad); pos += trackSize.pos; auto rotation = trackSize.rotationEnd; bool diagFlag = rotation >= 12; rotation &= 0x3U; tad &= 0x3FCU; tad |= rotation; // 0x0112C55B, 0x0112C3D4, 0x00112C454 sfl::static_vector<std::pair<uint8_t, QueryTrackRoadPlacementResult>, 64> placementResults; for (const auto trackId : validTrackIds) { const auto rotationBegin = World::TrackData::getUnkTrack(trackId << 3).rotationBegin; if (diagFlag) { if (rotationBegin < 12) { continue; } } else { if (rotationBegin >= 12) { continue; } } const auto newTad = (trackId << 3) | rotation; placementResults.push_back(std::make_pair(trackId, queryTrackPlacementScore(company, pos, newTad, diagFlag, validTrackIds))); } // 0x00484813 uint16_t bestMinScore = 0xFFFFU; uint16_t bestMinWeighting = 0xFFFFU; // edi uint8_t bestTrackId = 0xFFU; for (auto& [trackId, result] : placementResults) { if ((result.flags & ((1U << 0) | (1U << 7))) != ((1U << 0) | (1U << 7))) { continue; } if (bestMinScore < result.minScore) { continue; } else if (bestMinScore == result.minScore && bestMinWeighting <= result.minWeighting) { continue; } bestMinScore = result.minScore; bestMinWeighting = result.minWeighting; bestTrackId = trackId; } if (bestMinScore != 0xFFFFU) { // 0x00484927 GameCommands::TrackPlacementArgs args; args.trackId = bestTrackId; args.pos = pos; args.rotation = trackSize.rotationEnd; args.trackObjectId = _trackRoadObjType112C519; args.bridge = _createTrackRoadCommandBridge0; if (_createTrackRoadCommandAiUnkFlags & (1U << 22)) { args.bridge = _createTrackRoadCommandBridge1; if (args.trackId != 0) { args.bridge = _createTrackRoadCommandBridge0; } } args.unkFlags = *_createTrackRoadCommandAiUnkFlags >> 20; args.mods = _createTrackRoadCommandMods >> 16; if ((World::TrackData::getTrackMiscData(args.trackId).flags & World::Track::CommonTraitFlags::steepSlope) != World::Track::CommonTraitFlags::none) { args.mods |= _createTrackRoadCommandRackRail >> 16; } args.unk = false; auto argsNoBridge = args; argsNoBridge.bridge = 0xFFU; // no bridge auto res = GameCommands::doCommand(argsNoBridge, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { // Try with bridge res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { // 0x00484AB6 const auto entry = Company::Unk25C0HashTableEntry(args.pos, args.trackId, args.rotation & 0x3); company.addHashTableEntry(entry); _pathFindUndoCount112C518 = 15; return; } } // 0x00484A05 if (_pathFindTotalTrackRoadWeighting == 0) { company.var_85E6 = (bestTrackId << 3) | (args.rotation & 0x3U); } _unk2Pos112C3C6 = pos; _unk2PosBaseZ112C517 = pos.z / World::kSmallZStep; _unkTad112C3CA = (bestTrackId << 3) | (args.rotation & 0x3U); _pathFindTotalTrackRoadWeighting += static_cast<int32_t>(World::TrackData::getTrackMiscData(bestTrackId).unkWeighting); return; } else { // ax, cx, dl auto pos2 = World::Pos3(_unk2Pos112C3C6, _unk2PosBaseZ112C517 * World::kSmallZStep); // dh auto trackIdStart = (_unkTad112C3CA >> 3) & 0x3F; auto rot = _unkTad112C3CA & 0x3U; const auto entry = Company::Unk25C0HashTableEntry(pos2, trackIdStart, rot); company.addHashTableEntry(entry); _pathFindUndoCount112C518 = 1; return; } } else { pathFindTrackUndoSection(company); } } // 0x00485283 static void pathFindRoadUndoSection(Company& company) { if (_pathFindTotalTrackRoadWeighting <= 0) { _pathFindUndoCount112C518 = 0; return; } const auto roadId = (_unkTad112C3CA >> 3) & 0xF; _pathFindTotalTrackRoadWeighting -= static_cast<int32_t>(World::TrackData::getRoadMiscData(roadId).unkWeighting); _pathFindUndoCount112C518--; const auto rotation = (_unkTad112C3CA & 0x3U); auto& roadPiece0 = World::TrackData::getRoadPiece(roadId)[0]; const auto pos = World::Pos3(_unk2Pos112C3C6, (_unk2PosBaseZ112C517 * World::kSmallZStep) + roadPiece0.z); const auto aiAllocatedElRoad = [&pos, rotation, roadId, companyId = company.id()]() -> World::RoadElement* { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseZ() != pos.z / World::kSmallZStep) { continue; } if (elRoad->rotation() != rotation) { continue; } if (!elRoad->isAiAllocated()) { continue; } if (elRoad->hasStationElement()) { continue; } if (elRoad->roadId() != roadId) { continue; } if (elRoad->sequenceIndex() != 0) { continue; } if (elRoad->owner() != companyId) { continue; } return elRoad; } return nullptr; }(); if (aiAllocatedElRoad == nullptr) { company.var_85F0 = 0xF000U; return; } GameCommands::RoadRemovalArgs args; args.pos = pos; args.rotation = rotation; args.roadId = roadId; args.sequenceIndex = 0U; args.objectId = aiAllocatedElRoad->roadObjectId(); GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); // No check of failure! auto nextPos = World::Pos3(_unk2Pos112C3C6, _unk2PosBaseZ112C517 * World::kSmallZStep); const auto rot = World::TrackData::getUnkRoad(_unkTad112C3CA & 0x3FFU).rotationBegin; nextPos -= World::Pos3(World::kRotationOffset[rot], 0); const auto nextRot = World::kReverseRotation[rot]; auto roadObjId = _trackRoadObjType112C519 & ~(1U << 7); auto* roadObj = ObjectManager::get<RoadObject>(roadObjId); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { roadObjId = 0xFFU; } const auto rc = World::Track::getRoadConnectionsAiAllocated(nextPos, nextRot, company.id(), roadObjId, 0, 0); { auto newTad = rc.connections.empty() ? (nextRot | (0U << 3)) : rc.connections[0] & 0x1FFU; auto newPos = nextPos + World::TrackData::getUnkRoad(newTad).pos; const auto rotEnd = World::TrackData::getUnkRoad(newTad).rotationEnd; newPos -= World::Pos3(World::kRotationOffset[rotEnd], 0); // Normalise the rotation (remove the reverse bit and reverse the rotation if required) newTad ^= (1U << 2); if (newTad & (1U << 2)) { newTad &= 0x3; newTad ^= (1U << 1); } _unkTad112C3CA = newTad; _unk2Pos112C3C6 = newPos; _unk2PosBaseZ112C517 = newPos.z / World::kSmallZStep; } } // 0x00484D76 static void pathFindRoadSection(Company& company, const ValidTrackRoadIds& validRoadIds) { if (_pathFindUndoCount112C518 == 0) { // 0x00484D83 if (_pathFindTotalTrackRoadWeighting >= static_cast<int32_t>(company.var_85EA)) { company.var_85F0 = 0xF000U; return; } // 0x00484D9A _maxTrackRoadWeightingLimit = 138; { auto pos = World::Pos3(_unk3Pos112C3CC, _unk3PosBaseZ112C59C * World::kSmallZStep); auto tad = _unkTad112C4D4 & 0x3FFU; const auto& roadSize = World::TrackData::getUnkRoad(tad); pos += roadSize.pos; auto rotation = roadSize.rotationEnd; pos -= World::Pos3(World::kRotationOffset[rotation], 0); rotation ^= (1U << 1); _unk3Pos112C3CC = pos; _unk3PosBaseZ112C59C = pos.z / World::kSmallZStep; _unk3Rot112C59E = rotation; } auto pos = World::Pos3(_unk2Pos112C3C6, _unk2PosBaseZ112C517 * World::kSmallZStep); auto tad = _unkTad112C3CA & 0x3FFU; auto& roadSize = World::TrackData::getUnkRoad(tad); pos += roadSize.pos; auto rotation = roadSize.rotationEnd & 0x3U; tad &= 0x3FCU; tad |= rotation; // 0x0112C55B, 0x0112C3D4, 0x00112C454 sfl::static_vector<std::pair<uint8_t, QueryTrackRoadPlacementResult>, 64> placementResults; for (const auto roadId : validRoadIds) { const auto newTad = (roadId << 3) | rotation; placementResults.push_back(std::make_pair(roadId, queryRoadPlacementScore(company, pos, newTad, validRoadIds))); } // 0x00484EF0 uint16_t bestMinScore = 0xFFFFU; uint16_t bestMinWeighting = 0xFFFFU; // edi uint8_t bestRoadId = 0xFFU; for (auto& [roadId, result] : placementResults) { if ((result.flags & ((1U << 0) | (1U << 7))) != ((1U << 0) | (1U << 7))) { continue; } if (bestMinScore < result.minScore) { continue; } else if (bestMinScore == result.minScore && bestMinWeighting <= result.minWeighting) { continue; } bestMinScore = result.minScore; bestMinWeighting = result.minWeighting; bestRoadId = roadId; } if (bestMinScore != 0xFFFFU) { // 0x00485004 GameCommands::RoadPlacementArgs args; args.roadId = bestRoadId; args.pos = pos; args.rotation = roadSize.rotationEnd; args.roadObjectId = _trackRoadObjType112C519 & ~(1U << 7); args.bridge = _createTrackRoadCommandBridge1; if (args.roadId != 0) { args.bridge = _createTrackRoadCommandBridge0; } args.unkFlags = *_createTrackRoadCommandAiUnkFlags >> 16; args.mods = _createTrackRoadCommandMods >> 16; if ((World::TrackData::getRoadMiscData(args.roadId).flags & World::Track::CommonTraitFlags::steepSlope) != World::Track::CommonTraitFlags::none) { args.mods |= _createTrackRoadCommandRackRail >> 16; } auto argsNoBridge = args; argsNoBridge.bridge = 0xFFU; // no bridge auto res = GameCommands::doCommand(argsNoBridge, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { // Try with bridge res = GameCommands::doCommand(args, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { auto argsUnk = args; argsUnk.bridge = 0xFFU; if (_byte_1136075 != 0xFFU) { argsUnk.bridge = _byte_1136075; } if (_createTrackRoadCommandAiUnkFlags & (1U << 20) && _alternateTrackObjectId != 0xFFU) { argsUnk.roadObjectId = _alternateTrackObjectId; } res = GameCommands::doCommand(argsUnk, GameCommands::Flags::aiAllocated | GameCommands::Flags::noPayment | GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { // 0x004851DD const auto entry = Company::Unk25C0HashTableEntry(args.pos, args.roadId, args.rotation & 0x3); company.addHashTableEntry(entry); _pathFindUndoCount112C518 = 15; return; } } } // 0x0048512C if (_pathFindTotalTrackRoadWeighting == 0) { company.var_85E6 = (bestRoadId << 3) | (args.rotation & 0x3U); } _unk2Pos112C3C6 = pos; _unk2PosBaseZ112C517 = pos.z / World::kSmallZStep; _unkTad112C3CA = (bestRoadId << 3) | (args.rotation & 0x3U); _pathFindTotalTrackRoadWeighting += static_cast<int32_t>(World::TrackData::getRoadMiscData(bestRoadId).unkWeighting); return; } else { // ax, cx, dl auto pos2 = World::Pos3(_unk2Pos112C3C6, _unk2PosBaseZ112C517 * World::kSmallZStep); // dh auto roadIdStart = (_unkTad112C3CA >> 3) & 0xF; auto rot = _unkTad112C3CA & 0x3U; const auto entry = Company::Unk25C0HashTableEntry(pos2, roadIdStart, rot); company.addHashTableEntry(entry); _pathFindUndoCount112C518 = 1; return; } } else { pathFindRoadUndoSection(company); } } // 0x00484648 // company : _unk112C390 static void sub_484648(Company& company, const ValidTrackRoadIds& validTrackRoadIds) { if (_trackRoadObjType112C519 & (1U << 7)) { pathFindRoadSection(company, validTrackRoadIds); } else { pathFindTrackSection(company, validTrackRoadIds); } } namespace RoadReplacePrice { static const World::RoadElement* getRoadElement(const World::Pos3 pos, const uint8_t rotation, const uint8_t roadId, const uint8_t sequenceIndex, const CompanyId companyId) { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->sequenceIndex() != sequenceIndex) { continue; } if (elRoad->owner() != companyId) { continue; } if (!elRoad->isAiAllocated()) { continue; } if (elRoad->roadId() != roadId) { continue; } return elRoad; } return nullptr; } // 0x0047C159 static World::TileClearance::ClearFuncResult clearFunction( World::TileElement& el, currency32_t& totalCost, bool& hasLevelCrossing) { switch (el.type()) { case World::ElementType::track: { hasLevelCrossing = true; return World::TileClearance::ClearFuncResult::noCollision; } case World::ElementType::station: { auto* elStation = el.as<World::StationElement>(); if (elStation->stationType() == StationType::roadStation) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; } case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } auto* buildingObj = ObjectManager::get<BuildingObject>(elBuilding->objectId()); totalCost += Economy::getInflationAdjustedCost(buildingObj->clearCostFactor, buildingObj->clearCostIndex, 8); return World::TileClearance::ClearFuncResult::noCollision; } case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } auto* treeObj = ObjectManager::get<TreeObject>(elTree->treeObjectId()); totalCost += Economy::getInflationAdjustedCost(treeObj->clearCostFactor, treeObj->costIndex, 12); return World::TileClearance::ClearFuncResult::noCollision; } case World::ElementType::road: return World::TileClearance::ClearFuncResult::noCollision; case World::ElementType::signal: case World::ElementType::surface: case World::ElementType::wall: case World::ElementType::industry: return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::collision; } // 0x0047BD6D // pos: ax, cx, di // rotation: bh // index: dh // roadId: dl // roadObjId: bp (unused) static currency32_t aiRoadReplacementCost(const World::Pos3 pos, uint8_t rotation, uint8_t index, uint8_t roadId, CompanyId companyId) { auto* elRoadSeq = getRoadElement(pos, rotation, roadId, index, companyId); if (elRoadSeq == nullptr) { return 0; } bool isOnWater = World::TileManager::get(pos).surface()->water() != 0; auto* roadObj = ObjectManager::get<RoadObject>(elRoadSeq->roadObjectId()); currency32_t totalCost = 0; const auto roadIdCostFactor = World::TrackData::getRoadMiscData(roadId).costFactor; { const auto roadBaseCost = Economy::getInflationAdjustedCost(roadObj->buildCostFactor, roadObj->costIndex, 10); const auto cost = (roadBaseCost * roadIdCostFactor) / 256; totalCost += cost; } if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { for (auto i = 0U; i < 2; ++i) { if (elRoadSeq->hasMod(i)) { auto* extraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); const auto roadExtraBaseCost = Economy::getInflationAdjustedCost(extraObj->buildCostFactor, extraObj->costIndex, 10); const auto cost = (roadExtraBaseCost * roadIdCostFactor) / 256; totalCost += cost; } } } const auto& roadPieces = World::TrackData::getRoadPiece(roadId); const auto& roadPieceSeq = roadPieces[index]; const auto roadLoc0 = pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPieceSeq.x, roadPieceSeq.y }, rotation), roadPieceSeq.z }; bool hasBridge = false; uint8_t bridgeType = 0xFFU; for (auto& piece : roadPieces) { const auto roadLoc = roadLoc0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto* elRoad = getRoadElement(roadLoc, rotation, roadId, piece.index, companyId); if (elRoad == nullptr) { continue; } if (elRoad->hasBridge()) { hasBridge = true; bridgeType = elRoad->bridge(); } bool hasLevelCrossing = false; // As all level crossings will be new its always going to be currentDefaultLevelCrossingType const auto levelCrossingObjId = getGameState().currentDefaultLevelCrossingType; auto clearFunc = [&totalCost, &hasLevelCrossing](World::TileElement& el) { return clearFunction(el, totalCost, hasLevelCrossing); }; World::TileClearance::applyClearAtStandardHeight(roadLoc, elRoad->baseZ(), elRoad->clearZ(), World::QuarterTile(elRoad->occupiedQuarter(), 0), clearFunc); if (hasLevelCrossing) { auto* levelCrossingObj = ObjectManager::get<LevelCrossingObject>(levelCrossingObjId); totalCost += Economy::getInflationAdjustedCost(levelCrossingObj->costFactor, levelCrossingObj->costIndex, 10); } } if (hasBridge) { auto* bridgeObj = ObjectManager::get<BridgeObject>(bridgeType); // TODO: When we diverge reactivate this code see track version of function const auto heightCost = 0 * bridgeObj->heightCostFactor; // Why 0 probably a bug const auto bridgeBaseCost = Economy::getInflationAdjustedCost(bridgeObj->baseCostFactor + heightCost, bridgeObj->costIndex, 10); auto cost = (bridgeBaseCost * roadIdCostFactor) / 256; if (isOnWater) { cost *= 2; } totalCost += cost; } // TODO: When we diverge reactivate this code see track version of function // if (0) // Likely another bug //{ // const auto tunnelBaseCost = Economy::getInflationAdjustedCost(roadObj->tunnelCostFactor, 2, 8); // auto cost = (tunnelBaseCost * roadIdCostFactor) / 256; // totalCost += cost; // } return totalCost; } } // 0x0047B336 // pos: ax, cx, di // rotation: bh // sequenceIndex: dh // roadId: dl // roadObjId : bp (unused) static bool sub_47B336(World::Pos3 pos, uint8_t rotation, uint8_t sequenceIndex, uint8_t roadId, CompanyId companyId) { const auto traitFlags = World::TrackData::getRoadMiscData(roadId).flags; using enum World::Track::CommonTraitFlags; // 0x1136088 const bool allowWaterBridge = (traitFlags & (slope | steepSlope | verySmallCurve)) != none; { auto elRoad = [pos, rotation, sequenceIndex, roadId, companyId]() -> const World::RoadElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->sequenceIndex() != sequenceIndex) { continue; } if (elRoad->owner() != companyId) { continue; } if (!elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } if (elRoad->roadId() != roadId) { continue; } return elRoad; } return nullptr; }(); if (elRoad == nullptr) { return false; } if (!elRoad->hasBridge()) { return false; } } auto& roadPieces = World::TrackData::getRoadPiece(roadId); auto& roadPiece = roadPieces[sequenceIndex]; const auto roadPos0 = pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece.x, roadPiece.y }, rotation), roadPiece.z }; for (auto& piece : roadPieces) { const auto roadPos = roadPos0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto tile = World::TileManager::get(roadPos); auto* elSurface = tile.surface(); // ah const auto bridgeZ = roadPos.z / World::kSmallZStep - elSurface->baseZ(); if (elSurface->water() != 0) { // 0x0047B57B if (allowWaterBridge) { if (bridgeZ > 16) { continue; } return false; } else { if (roadId != 0) { return false; } bool passedSurface = false; bool shouldContinue = false; for (auto& el : tile) { if (el.type() == World::ElementType::surface) { passedSurface = true; } if (!passedSurface) { continue; } if (roadPos.z <= el.baseHeight()) { return false; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { if (elTrack->trackId() != 0) { continue; } if (elTrack->rotation() == rotation || (elTrack->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { if (elRoad->roadId() != 0) { continue; } if (elRoad->rotation() == rotation || (elRoad->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } } } if (shouldContinue) { continue; } return false; } } else { // 0x0047B4DD bool passedSurface = false; bool shouldContinue = false; bool shouldReturn = false; // May be overridden by a shouldContinue for (auto& el : tile) { if (el.type() == World::ElementType::surface) { passedSurface = true; } if (!passedSurface) { continue; } if (roadPos.z <= el.baseHeight()) { break; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { if (roadId != 0) { return false; } if (elTrack->trackId() != 0) { shouldReturn = true; continue; } if (elTrack->rotation() == rotation || (elTrack->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } shouldReturn = true; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { if (roadId != 0) { return false; } if (elRoad->roadId() != 0) { shouldReturn = true; continue; } if (elRoad->rotation() == rotation || (elRoad->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } shouldReturn = true; } } if (shouldContinue) { continue; } if (shouldReturn) { return false; } if (bridgeZ > 16) { return false; } if (elSurface->slope() != 0) { return false; } } } return true; } // 0x004A80E1 // pos: ax, cx, di // rotation: bh // sequenceIndex: dh // trackId: dl // trackObjId : bp static bool sub_4A80E1(World::Pos3 pos, uint8_t rotation, uint8_t sequenceIndex, uint8_t trackId, uint8_t trackObjId) { const auto traitFlags = World::TrackData::getTrackMiscData(trackId).flags; using enum World::Track::CommonTraitFlags; // 0x1136088 const bool allowWaterBridge = (traitFlags & (slope | steepSlope | verySmallCurve)) != none; { auto elTrack = [pos, rotation, sequenceIndex, trackId, trackObjId]() -> const World::TrackElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->sequenceIndex() != sequenceIndex) { continue; } if (elTrack->trackObjectId() != trackObjId) { continue; } if (!elTrack->isAiAllocated() || elTrack->isGhost()) { continue; } if (elTrack->trackId() != trackId) { continue; } return elTrack; } return nullptr; }(); if (elTrack == nullptr) { return false; } if (!elTrack->hasBridge()) { return false; } } auto& trackPieces = World::TrackData::getTrackPiece(trackId); auto& trackPiece = trackPieces[sequenceIndex]; const auto trackPos0 = pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, rotation), trackPiece.z }; for (auto& piece : trackPieces) { const auto trackPos = trackPos0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto tile = World::TileManager::get(trackPos); auto* elSurface = tile.surface(); // ah const auto bridgeZ = trackPos.z / World::kSmallZStep - elSurface->baseZ(); if (elSurface->water() != 0) { // 0x004A8326 if (allowWaterBridge) { if (bridgeZ > 16) { continue; } return false; } else { if (trackId != 0) { return false; } bool passedSurface = false; bool shouldContinue = false; for (auto& el : tile) { if (el.type() == World::ElementType::surface) { passedSurface = true; continue; } if (!passedSurface) { continue; } if (trackPos.z <= el.baseHeight()) { return false; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { if (elTrack->trackId() != 0) { continue; } if (elTrack->rotation() == rotation || (elTrack->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { if (elRoad->roadId() != 0) { continue; } if (elRoad->rotation() == rotation || (elRoad->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } } } if (shouldContinue) { continue; } return false; } } else { // 0x004A8288 bool passedSurface = false; bool shouldContinue = false; bool shouldReturn = false; // May be overridden by a shouldContinue for (auto& el : tile) { if (el.type() == World::ElementType::surface) { passedSurface = true; continue; } if (!passedSurface) { continue; } if (trackPos.z <= el.baseHeight()) { break; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { if (trackId != 0) { return false; } if (elTrack->trackId() != 0) { shouldReturn = true; continue; } if (elTrack->rotation() == rotation || (elTrack->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } shouldReturn = true; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { if (trackId != 0) { return false; } if (elRoad->roadId() != 0) { shouldReturn = true; continue; } if (elRoad->rotation() == rotation || (elRoad->rotation() ^ (1U << 1)) == rotation) { shouldContinue = true; break; } shouldReturn = true; } } if (shouldContinue) { continue; } if (shouldReturn) { return false; } if (bridgeZ > 16) { return false; } if (elSurface->slope() != 0) { return false; } } } return true; } // 0x004A7E86 // pos: ax, cx, di // rotation: bh // sequenceIndex: dh // trackId: dl // trackObjId : bp static bool sub_4A7E86(World::Pos3 pos, uint8_t rotation, uint8_t sequenceIndex, uint8_t trackId, uint8_t trackObjId) { auto getElTrack = [rotation, trackId, trackObjId](World::Pos3 pos, uint8_t sequenceIndex) -> const World::TrackElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->sequenceIndex() != sequenceIndex) { continue; } if (elTrack->trackObjectId() != trackObjId) { continue; } if (!elTrack->isAiAllocated() || elTrack->isGhost()) { continue; } if (elTrack->trackId() != trackId) { continue; } return elTrack; } return nullptr; }; auto* elTrackSeq = getElTrack(pos, sequenceIndex); if (elTrackSeq == nullptr) { return false; } auto& trackPieces = World::TrackData::getTrackPiece(trackId); auto& trackPiece = trackPieces[sequenceIndex]; const auto trackPos0 = pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, rotation), trackPiece.z }; for (auto& piece : trackPieces) { const auto trackPos = trackPos0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto tile = World::TileManager::get(trackPos); auto* elTrack = getElTrack(trackPos, piece.index); if (elTrack == nullptr) { continue; } for (auto& el : tile) { auto* elConnectTrack = el.as<World::TrackElement>(); if (elConnectTrack == nullptr) { continue; } if (elConnectTrack == elTrack) { continue; } if (elConnectTrack->baseHeight() != trackPos.z) { continue; } if (elConnectTrack->occupiedQuarter() == elTrack->occupiedQuarter()) { continue; } const auto connectFlags1 = piece.connectFlags[rotation]; auto& piece2 = World::TrackData::getTrackPiece(elConnectTrack->trackId())[elConnectTrack->sequenceIndex()]; const auto connectFlags2 = piece2.connectFlags[elConnectTrack->rotation()]; if ((connectFlags1 & connectFlags2) != 0) { return true; } } } return false; } // 0x0047B7CC // pos: ax, cx, di // rotation: bh // sequenceIndex: dh // roadId: dl // roadObjId : bp (unused) static bool sub_47B7CC(World::Pos3 pos, uint8_t rotation, uint8_t sequenceIndex, uint8_t roadId, CompanyId companyId) { auto getElRoad = [rotation, roadId, companyId](World::Pos3 pos, uint8_t sequenceIndex) -> const World::RoadElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->sequenceIndex() != sequenceIndex) { continue; } if (elRoad->owner() != companyId) { continue; } if (elRoad->roadId() != roadId) { continue; } if (!elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } return elRoad; } return nullptr; }; auto* elRoadSeq = getElRoad(pos, sequenceIndex); if (elRoadSeq == nullptr) { return false; } auto& roadPieces = World::TrackData::getRoadPiece(roadId); auto& roadPiece = roadPieces[sequenceIndex]; const auto roadPos0 = pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece.x, roadPiece.y }, rotation), roadPiece.z }; for (auto& piece : roadPieces) { const auto roadPos = roadPos0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto tile = World::TileManager::get(roadPos); auto* elRoad = getElRoad(roadPos, piece.index); if (elRoad == nullptr) { continue; } for (auto& el : tile) { auto* elConnectRoad = el.as<World::RoadElement>(); if (elConnectRoad == nullptr) { continue; } if (elConnectRoad == elRoad) { continue; } if (!elConnectRoad->isAiAllocated()) { continue; } if (elConnectRoad->baseHeight() != roadPos.z) { continue; } if (elConnectRoad->occupiedQuarter() == elRoad->occupiedQuarter()) { continue; } const auto connectFlags1 = piece.connectFlags[rotation]; auto& piece2 = World::TrackData::getRoadPiece(elConnectRoad->roadId())[elConnectRoad->sequenceIndex()]; const auto connectFlags2 = piece2.connectFlags[elConnectRoad->rotation()]; if ((connectFlags1 & connectFlags2) != 0) { return true; } } } return false; } // 0x0047B615 // pos: ax, cx, di // rotation: bh // sequenceIndex: dh // roadId: dl // roadObjId : bp (unused) static bool willRoadDestroyABuilding(World::Pos3 pos, uint8_t rotation, uint8_t sequenceIndex, uint8_t roadId, CompanyId companyId) { auto getElRoad = [rotation, roadId, companyId](World::Pos3 pos, uint8_t sequenceIndex) -> const World::RoadElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { if (el.baseHeight() != pos.z) { continue; } auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->sequenceIndex() != sequenceIndex) { continue; } if (elRoad->owner() != companyId) { continue; } if (elRoad->roadId() != roadId) { continue; } if (!elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } return elRoad; } return nullptr; }; auto* elRoadSeq = getElRoad(pos, sequenceIndex); if (elRoadSeq == nullptr) { return false; } auto& roadPieces = World::TrackData::getRoadPiece(roadId); auto& roadPiece = roadPieces[sequenceIndex]; const auto roadPos0 = pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece.x, roadPiece.y }, rotation), roadPiece.z }; for (auto& piece : roadPieces) { const auto roadPos = roadPos0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; auto tile = World::TileManager::get(roadPos); bool passedSurface = false; for (auto& el : tile) { if (el.type() == World::ElementType::surface) { passedSurface = true; continue; } if (!passedSurface) { continue; } auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { continue; } if (roadPos.z >= elBuilding->clearHeight()) { continue; } if (roadPos.z + 8 * World::kSmallZStep <= elBuilding->baseHeight()) { continue; } return true; } } return false; } // 0x00485B75 // startPos.x: 0x0112C3C6 // startPos.y: 0x0112C3C8 // startPos.z: 0x0112C517 * World::kSmallZStep // startTad: 0x0112C3CA // targetPos.x: 0x0112C3C2 // targetPos.y: 0x0112C3C4 // targetPos.z: 0x0112C515 * World::kSmallZStep // targetRot: 0x0112C516 // trackObjId: 0x0112C519 static uint32_t sub_485B75(const World::Pos3 startPos, const uint16_t startTad, const World::Pos3 targetPos, const uint8_t targetRot, const uint8_t trackObjId, const CompanyId companyId) { _unk112C36C = 0U; _unk112C35C = 0U; bool unk112C368 = false; _unk112C34C = 0U; uint32_t unk112C360 = _pathFindTotalTrackRoadWeighting; World::Pos3 pos = startPos; uint16_t tad = startTad; for (auto i = 0U; i < 400; ++i) { if (pos == targetPos) { // 0x00485DBD const auto posA = startPos + World::TrackData::getUnkTrack(startTad).pos; const auto posB = targetPos + World::Pos3(World::kRotationOffset[targetRot], 0); _unk112C364 = Math::Vector::distance3D(posA, posB); return unk112C368 ? (1U << 1) : 0U; } const uint8_t trackId = (tad >> 3U) & 0x3F; const uint8_t rotation = tad & 0x3U; const auto unkWeighting = World::TrackData::getTrackMiscData(trackId).unkWeighting; _unk112C36C += unkWeighting; unk112C360 -= unkWeighting; auto posAdjusted = pos; posAdjusted.z += World::TrackData::getTrackPiece(trackId)[0].z; { GameCommands::AiTrackReplacementArgs args{}; args.pos = posAdjusted; args.rotation = tad & 0x3U; args.sequenceIndex = 0; args.trackId = trackId; args.trackObjectId = trackObjId; auto regs(static_cast<Interop::registers>(args)); regs.bl = 0; GameCommands::aiTrackReplacement(regs); if (static_cast<uint32_t>(regs.ebx) != GameCommands::FAILURE) { _unk112C34C += static_cast<uint32_t>(regs.ebx); } } if (sub_4A80E1(posAdjusted, rotation, 0, trackId, trackObjId)) { _unk112C35C += unkWeighting; } if (_unk112C36C > 128 && unk112C360 > 64) { if (sub_4A7E86(posAdjusted, rotation, 0, trackId, trackObjId)) { unk112C368 = true; } } const auto rotationBegin = World::TrackData::getUnkTrack(tad).rotationBegin; auto nextPos = pos; if (rotationBegin < 12) { nextPos -= World::Pos3(World::kRotationOffset[rotationBegin], 0); } const auto nextRot = World::kReverseRotation[rotationBegin]; const auto tc = World::Track::getTrackConnectionsAi(nextPos, nextRot, companyId, trackObjId, 0, 0); if (tc.connections.empty() || tc.connections.size() > 1) { return 1; } tad = tc.connections[0] & World::Track::AdditionalTaDFlags::basicTaDMask; const auto& trackSize = World::TrackData::getUnkTrack(tad); pos = nextPos + trackSize.pos; if (trackSize.rotationEnd < 12) { pos -= World::Pos3(World::kRotationOffset[trackSize.rotationEnd], 0); } tad ^= (1U << 2); if (tad & (1U << 2)) { // Odd? what is this doing tad = (tad & 0x3) | (0U << 3); } } return 1; } // 0x00485E6A // startPos.x: 0x0112C3C6 // startPos.y: 0x0112C3C8 // startPos.z: 0x0112C517 * World::kSmallZStep // startTad: 0x0112C3CA // targetPos.x: 0x0112C3C2 // targetPos.y: 0x0112C3C4 // targetPos.z: 0x0112C515 * World::kSmallZStep // targetRot: 0x0112C516 // roadObjId: 0x0112C519 static uint32_t sub_485E6A(const World::Pos3 startPos, const uint16_t startTad, const World::Pos3 targetPos, const uint8_t targetRot, const uint8_t roadObjId, const CompanyId companyId) { _unk112C36C = 0U; _unk112C35C = 0U; bool unk112C368 = false; _unk112C34C = 0U; World::Pos3 pos = startPos; uint16_t tad = startTad; bool targetReached = false; for (auto i = 0U; i < 400; ++i) { if (pos == targetPos) { targetReached = true; break; } const uint8_t roadId = (tad >> 3U) & 0xF; const uint8_t rotation = tad & 0x3U; const auto unkWeighting = World::TrackData::getRoadMiscData(roadId).unkWeighting; _unk112C36C += unkWeighting; auto posAdjusted = pos; posAdjusted.z += World::TrackData::getRoadPiece(roadId)[0].z; _unk112C34C += static_cast<uint32_t>(RoadReplacePrice::aiRoadReplacementCost(posAdjusted, rotation, 0, roadId, companyId)); if (sub_47B336(posAdjusted, rotation, 0, roadId, companyId)) { _unk112C35C += unkWeighting; } if (willRoadDestroyABuilding(posAdjusted, rotation, 0, roadId, companyId)) { _unk112C35C += unkWeighting; } if (sub_47B7CC(posAdjusted, rotation, 0, roadId, companyId)) { unk112C368 = true; } const auto rotationBegin = World::TrackData::getUnkRoad(tad).rotationBegin; const auto nextPos = pos - World::Pos3(World::kRotationOffset[rotationBegin], 0); const auto nextRot = World::kReverseRotation[rotationBegin]; uint8_t matchRoadObjId = roadObjId; auto* roadObj = ObjectManager::get<RoadObject>(roadObjId); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { matchRoadObjId = 0xFFU; // any road object } const auto rc = World::Track::getRoadConnectionsAiAllocated(nextPos, nextRot, companyId, matchRoadObjId, 0, 0); if (rc.connections.size() > 1) { return 1; } if (rc.connections.empty()) { if (nextPos == targetPos) { targetReached = true; } break; } tad = rc.connections[0] & World::Track::AdditionalTaDFlags::basicTaDMask; const auto& roadSize = World::TrackData::getUnkRoad(tad); pos = nextPos + roadSize.pos - World::Pos3(World::kRotationOffset[roadSize.rotationEnd], 0); tad ^= (1U << 2); if (tad & (1U << 2)) { // Odd? what is this doing tad = (tad & 0x3) | (0U << 3); } } if (targetReached) { // 0x004860F4 const auto posA = startPos + World::TrackData::getUnkRoad(startTad).pos; const auto posB = targetPos + World::Pos3(World::kRotationOffset[targetRot], 0); _unk112C364 = Math::Vector::distance3D(posA, posB); return unk112C368 ? (1U << 1) : 0U; } else { return 1; } } // 0x00485B68 static uint32_t sub_485B68() { const auto startPos = World::Pos3{ _unk2Pos112C3C6->x, _unk2Pos112C3C6->y, _unk2PosBaseZ112C517 * World::kSmallZStep }; const auto startTad = *_unkTad112C3CA; const auto targetPos = World::Pos3{ _unk1Pos112C3C2->x, _unk1Pos112C3C2->y, _unk1PosBaseZ112C515 * World::kSmallZStep }; const auto targetRot = *_unk1Rot112C516; const auto companyId = GameCommands::getUpdatingCompanyId(); const auto trackRoadObjId = *_trackRoadObjType112C519; if (trackRoadObjId & (1U << 7)) { const auto roadObjId = trackRoadObjId & ~(1U << 7); return sub_485E6A(startPos, startTad, targetPos, targetRot, roadObjId, companyId); } else { const auto trackObjId = trackRoadObjId; return sub_485B75(startPos, startTad, targetPos, targetRot, trackObjId, companyId); } } // 0x004845FF static void aiPathfindNextState(Company& company) { company.var_85E8++; company.var_85F0 = 0; company.var_85EE = 0; company.var_85EF = 0; // TODO: When diverging just set this all to a fixed value rather than only first entry for (auto& htEntry : company.var_25C0) { htEntry.var_00 = 0xFFFFU; } company.var_25C0_length = 0; } // 0x00484508 static bool evaluatePathfound(Company& company, AiThought& thought) { const auto flags = sub_485B68(); if (flags & (1U << 0)) { return true; } if (flags & (1U << 1)) { // 0x004845FF aiPathfindNextState(company); return false; } else { const auto weighting = std::max<uint32_t>(_unk112C364, 256); // 1.75 x weighting const auto adjustedWeighting = weighting + weighting / 2 + weighting / 4; if (adjustedWeighting < _unk112C36C) { // 0x004845FF aiPathfindNextState(company); return false; } if (_unk112C35C * 5 >= _unk112C36C) { // 0x004845FF aiPathfindNextState(company); return false; } auto& aiStation = thought.stations[company.var_85C2]; uint8_t nextStationIdx = 0xFFU; if (company.var_85C3 & (1U << 0)) { nextStationIdx = aiStation.var_A; if (aiStation.var_C & ((1U << 2) | (1U << 1))) { aiStation.var_C |= (1U << 3); } else { aiStation.var_C |= (1U << 1); } } else { nextStationIdx = aiStation.var_9; if (aiStation.var_B & ((1U << 2) | (1U << 1))) { aiStation.var_B |= (1U << 3); } else { aiStation.var_B |= (1U << 1); } } auto& aiStation2 = thought.stations[nextStationIdx]; if (aiStation2.var_9 != company.var_85C2) { if (aiStation2.var_C & ((1U << 2) | (1U << 1))) { aiStation2.var_C |= (1U << 3); } else { aiStation2.var_C |= (1U << 1); } } else { if (aiStation2.var_B & ((1U << 2) | (1U << 1))) { aiStation2.var_B |= (1U << 3); } else { aiStation2.var_B |= (1U << 1); } } company.var_85C2 = 0xFFU; thought.var_76 += _unk112C34C; return false; } } // 0x00483FBA bool aiPathfind(Company& company, AiThought& thought) { switch (company.var_85E8) { case 0: { _unk1Pos112C3C2 = company.var_85C4; _unk1PosBaseZ112C515 = company.var_85C8; _unk1Rot112C516 = company.var_85CE; _unk2Pos112C3C6 = company.var_85D0; _unk2PosBaseZ112C517 = company.var_85D4; _unkTad112C3CA = company.var_85D5; _unk3Pos112C3CC = company.var_85D7; _unk3PosBaseZ112C59C = company.var_85DB; _unkTad112C4D4 = company.var_85DC; _pathFindTotalTrackRoadWeighting = company.var_85DE; _pathFindUndoCount112C518 = company.var_85EE; const auto validTrackRoadIds = sub_483A7E(company, thought); if (sub_483E20(company)) { // 0x00484508 return evaluatePathfound(company, thought); } else { // 0x004850A0 company.var_85F0++; if (company.var_85F0 > 384) { // 0x004845EF const auto flags = sub_485B68(); if (flags & (1U << 0)) { return true; } // 0x004845FF aiPathfindNextState(company); return false; } sub_484648(company, validTrackRoadIds); company.var_85DE = _pathFindTotalTrackRoadWeighting; company.var_85EE = _pathFindUndoCount112C518; company.var_85D0 = _unk2Pos112C3C6; company.var_85D4 = _unk2PosBaseZ112C517; company.var_85D5 = _unkTad112C3CA; return false; } } case 1: { _unk1Pos112C3C2 = company.var_85C4; _unk1PosBaseZ112C515 = company.var_85C8; _unk1Rot112C516 = company.var_85CE; _unk2Pos112C3C6 = company.var_85D0; _unk2PosBaseZ112C517 = company.var_85D4; _unkTad112C3CA = company.var_85D5; _unk3Pos112C3CC = company.var_85D7; _unk3PosBaseZ112C59C = company.var_85DB; _unkTad112C4D4 = company.var_85DC; _pathFindTotalTrackRoadWeighting = company.var_85DE; _pathFindUndoCount112C518 = company.var_85EE; const auto validTrackRoadIds = sub_483A7E(company, thought); if (_pathFindTotalTrackRoadWeighting == 0) { // 0x004845FF aiPathfindNextState(company); return false; } else { // 0x00484338 company.var_85F0++; if (company.var_85F0 > 384) { return true; } _pathFindUndoCount112C518 = 1; sub_484648(company, validTrackRoadIds); company.var_85DE = _pathFindTotalTrackRoadWeighting; company.var_85EE = _pathFindUndoCount112C518; company.var_85D0 = _unk2Pos112C3C6; company.var_85D4 = _unk2PosBaseZ112C517; company.var_85D5 = _unkTad112C3CA; return false; } } case 2: { // Different to case 0 and 1 _unk1Pos112C3C2 = company.var_85C9; _unk1PosBaseZ112C515 = company.var_85CD; _unk1Rot112C516 = company.var_85CF; _unk2Pos112C3C6 = company.var_85D7; _unk2PosBaseZ112C517 = company.var_85DB; _unkTad112C3CA = company.var_85DC; _unk3Pos112C3CC = company.var_85D0; _unk3PosBaseZ112C59C = company.var_85D4; _unkTad112C4D4 = company.var_85D5; _pathFindTotalTrackRoadWeighting = company.var_85E2; _pathFindUndoCount112C518 = company.var_85EF; const auto validTrackRoadIds = sub_483A7E(company, thought); if (sub_483E20(company)) { // 0x00484508 return evaluatePathfound(company, thought); } else { // 0x004841EE company.var_85F0++; if (company.var_85F0 > 384) { // 0x004845EF duplicate const auto flags = sub_485B68(); if (flags & (1U << 0)) { return true; } // 0x004845FF aiPathfindNextState(company); return false; } sub_484648(company, validTrackRoadIds); company.var_85E2 = _pathFindTotalTrackRoadWeighting; company.var_85EF = _pathFindUndoCount112C518; company.var_85D7 = _unk2Pos112C3C6; company.var_85DB = _unk2PosBaseZ112C517; company.var_85DC = _unkTad112C3CA; return false; } } case 3: return true; default: assert(false); return true; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyAi/CompanyAiPathfinding.h ```h #pragma once namespace OpenLoco { struct Company; struct AiThought; } namespace OpenLoco::CompanyAi { bool aiPathfind(Company& company, AiThought& thought); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyAi/CompanyAiPlaceVehicle.cpp ```cpp #include "CompanyAiPlaceVehicle.h" #include "Date.h" #include "GameCommands/Vehicles/VehicleChangeRunningMode.h" #include "GameCommands/Vehicles/VehiclePlace.h" #include "GameCommands/Vehicles/VehiclePlaceAir.h" #include "GameCommands/Vehicles/VehiclePlaceWater.h" #include "GameCommands/Vehicles/VehicleSell.h" #include "GameState.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Random.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "World/Company.h" #include "World/StationManager.h" namespace OpenLoco::CompanyAi { using namespace World; // 0x00431295 static void beginPlacement(Company& company) { company.var_4A6 = AiPlaceVehicleState::resetList; } // 0x0043129D static void resetPlacementList(Company& company) { company.var_4A6 = AiPlaceVehicleState::place; company.aiPlaceVehicleIndex = 0; } // 0x00497AC6 static void tryPlaceVehicleFailure(Company& company, Vehicles::VehicleHead& head) { if (head.hasBreakdownFlags(Vehicles::BreakdownFlags::brokenDown)) { return; } auto train = Vehicles::Vehicle(head); const auto firstCarAge = getCurrentDay() - train.cars.firstCar.front->creationDay; if (firstCarAge < 42) { return; } if (head.aiThoughtId == 0xFFU) { return; } auto& thought = company.aiThoughts[head.aiThoughtId]; removeEntityFromThought(thought, head.id); thought.var_43--; thought.purchaseFlags |= AiPurchaseFlags::unk4; GameCommands::VehicleSellArgs args{}; args.car = head.id; const auto oldUpdatingCompanyId = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(CompanyId::neutral); // Why? GameCommands::doCommand(args, GameCommands::Flags::apply); GameCommands::setUpdatingCompanyId(oldUpdatingCompanyId); } // 0x00487B77 static void tryPlaceVehicleSuccess(Vehicles::VehicleHead& head) { head.breakdownFlags |= Vehicles::BreakdownFlags::brokenDown; // Why? GameCommands::VehicleChangeRunningModeArgs args{}; args.head = head.id; args.mode = GameCommands::VehicleChangeRunningModeArgs::Mode::startVehicle; const auto oldUpdatingCompanyId = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(CompanyId::neutral); // Why? GameCommands::doCommand(args, GameCommands::Flags::apply); GameCommands::setUpdatingCompanyId(oldUpdatingCompanyId); } static std::optional<GameCommands::VehiclePlacementArgs> generateBackupRoadPlacement(const World::Pos2 pos, const uint8_t roadObjectId, const CompanyId companyId) { const auto randVal = gPrng1().randNext(); const auto randX = ((randVal & 0xFU) - 7) * 32; const auto randY = (((randVal >> 4) & 0xFU) - 7) * 32; const auto randPos = World::Pos2(pos.x + randX, pos.y + randY); if (!validCoords(randPos)) { return std::nullopt; } const auto tile = World::TileManager::get(randPos); for (const auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->sequenceIndex() != 0) { continue; } if (roadObjectId == 0xFFU) { if (!(getGameState().roadObjectIdIsNotTram & (1U << elRoad->roadObjectId()))) { continue; } } else { if (elRoad->roadObjectId() != roadObjectId) { continue; } if (elRoad->owner() != companyId) { continue; } } GameCommands::VehiclePlacementArgs args{}; args.convertGhost = false; args.pos = World::Pos3(randPos, elRoad->baseHeight() - World::TrackData::getRoadPiece(elRoad->roadId())[0].z); args.trackAndDirection = (elRoad->roadId() << 3) | elRoad->rotation(); args.trackProgress = 0; return args; } return std::nullopt; } // 0x0047C371 static uint8_t validateRoadPlacement(const World::Pos3 pos, const uint8_t roadObjectId, const uint16_t tad) { const auto rotation = tad & 0x3; const auto roadId = tad >> 3; World::Pos3 initialPos = pos; if (tad & (1U << 2)) { const auto& trackSize = World::TrackData::getUnkRoad(tad); initialPos += trackSize.pos; if (trackSize.rotationEnd < 12) { initialPos.x -= kRotationOffset[trackSize.rotationEnd].x; initialPos.y -= kRotationOffset[trackSize.rotationEnd].y; } } auto& roadPieces = World::TrackData::getRoadPiece(roadId); for (auto& piece : roadPieces) { const auto rotatedPiece = World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; const auto piecePos = initialPos + rotatedPiece; auto* elRoad = [piecePos, rotation, &piece, roadId, roadObjectId]() -> const World::RoadElement* { const auto tile = World::TileManager::get(piecePos); for (const auto& el : tile) { auto* elRoad = el.as<RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != piecePos.z) { continue; } if (elRoad->isGhost() || elRoad->isAiAllocated()) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->sequenceIndex() != piece.index) { continue; } if (elRoad->roadId() != roadId) { continue; } if (elRoad->roadObjectId() != roadObjectId) { if (!(getGameState().roadObjectIdIsNotTram & (1U << elRoad->roadObjectId()))) { continue; } } return elRoad; } return nullptr; }(); if (elRoad == nullptr) { return 2; } } return 0; } // 0x004A868A static std::optional<GameCommands::VehiclePlacementArgs> generateBackupTrackPlacement(const World::Pos2 pos, const uint8_t trackObjectId, const CompanyId companyId) { const auto randVal = gPrng1().randNext(); const auto randX = ((randVal & 0xFU) - 7) * 32; const auto randY = (((randVal >> 4) & 0xFU) - 7) * 32; const auto randPos = World::Pos2(pos.x + randX, pos.y + randY); if (!validCoords(randPos)) { return std::nullopt; } const auto tile = World::TileManager::get(randPos); for (const auto& el : tile) { auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->sequenceIndex() != 0) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if (elTrack->owner() != companyId) { continue; } GameCommands::VehiclePlacementArgs args{}; args.convertGhost = false; args.pos = World::Pos3(randPos, elTrack->baseHeight() - World::TrackData::getTrackPiece(elTrack->trackId())[0].z); args.trackAndDirection = (elTrack->trackId() << 3) | elTrack->rotation(); args.trackProgress = 0; return args; } return std::nullopt; } // 0x004A852B static uint8_t validateTrackPlacement(const World::Pos3 pos, const uint8_t trackObjectId, const uint16_t tad, const CompanyId companyId) { const auto rotation = tad & 0x3; const auto trackId = tad >> 3; World::Pos3 initialPos = pos; if (tad & (1U << 2)) { const auto& trackSize = World::TrackData::getUnkTrack(tad); initialPos += trackSize.pos; if (trackSize.rotationEnd < 12) { initialPos.x -= kRotationOffset[trackSize.rotationEnd].x; initialPos.y -= kRotationOffset[trackSize.rotationEnd].y; } } auto& trackPieces = World::TrackData::getTrackPiece(trackId); for (auto& piece : trackPieces) { const auto rotatedPiece = World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation), piece.z }; const auto piecePos = initialPos + rotatedPiece; auto* elTrack = [piecePos, rotation, &piece, trackId, trackObjectId, companyId]() -> const World::TrackElement* { const auto tile = World::TileManager::get(piecePos); for (const auto& el : tile) { auto* elTrack = el.as<TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != piecePos.z) { continue; } if (elTrack->isAiAllocated()) { continue; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->sequenceIndex() != piece.index) { continue; } if (elTrack->trackId() != trackId) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if (elTrack->owner() != companyId) { continue; } return elTrack; } return nullptr; }(); if (elTrack == nullptr) { return 2; } } return 0; } // 0x004878E3 // args is expected to not have head set yet static void tryPlaceSurfaceVehicle(Company& company, Vehicles::VehicleHead& head, GameCommands::VehiclePlacementArgs args) { args.head = head.id; const auto oldUpdatingCompanyId = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(CompanyId::neutral); // Why? const auto res = GameCommands::doCommand(args, GameCommands::Flags::apply); GameCommands::setUpdatingCompanyId(oldUpdatingCompanyId); if (res == GameCommands::FAILURE) { tryPlaceVehicleFailure(company, head); return; } tryPlaceVehicleSuccess(head); } // 0x00487A27 static void tryPlaceWaterVehicle(Company& company, Vehicles::VehicleHead& head, World::Pos3 pos) { auto* elStation = [&pos, &head]() -> const StationElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseHeight() != pos.z) { continue; } if (elStation->isAiAllocated() || elStation->isGhost()) { continue; } if (elStation->stationType() != StationType::docks) { continue; } if (elStation->owner() != head.owner) { continue; } if (elStation->isFlag6()) { continue; } return elStation; } return nullptr; }(); if (elStation == nullptr) { tryPlaceVehicleFailure(company, head); return; } GameCommands::VehicleWaterPlacementArgs args{}; args.head = head.id; args.pos = pos; args.convertGhost = false; const auto oldUpdatingCompanyId = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(CompanyId::neutral); // Why? const auto res = GameCommands::doCommand(args, GameCommands::Flags::apply); GameCommands::setUpdatingCompanyId(oldUpdatingCompanyId); if (res == GameCommands::FAILURE) { tryPlaceVehicleFailure(company, head); return; } tryPlaceVehicleSuccess(head); } // 0x00487926 static void tryPlaceAirVehicle(Company& company, Vehicles::VehicleHead& head, World::Pos3 pos) { auto* elStation = [&pos, &head]() -> const StationElement* { auto tile = World::TileManager::get(pos); for (const auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseHeight() != pos.z) { continue; } if (elStation->isAiAllocated() || elStation->isGhost()) { continue; } if (elStation->stationType() != StationType::airport) { continue; } if (elStation->owner() != head.owner) { continue; } return elStation; } return nullptr; }(); if (elStation == nullptr) { tryPlaceVehicleFailure(company, head); return; } auto* station = StationManager::get(elStation->stationId()); auto* airportObj = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementNodes = airportObj->getMovementNodes(); const auto movementEdges = airportObj->getMovementEdges(); for (auto nodeIndex = 0U; nodeIndex < airportObj->numMovementNodes; ++nodeIndex) { auto& node = movementNodes[nodeIndex]; if (!node.hasFlags(AirportMovementNodeFlags::terminal)) { continue; } const auto mustBeClearEdges = [nodeIndex, &airportObj, &movementEdges]() { for (auto edgeIndex = 0U; edgeIndex < airportObj->numMovementEdges; ++edgeIndex) { auto& edge = movementEdges[edgeIndex]; if (edge.nextNode == nodeIndex) { return edge.mustBeClearEdges; } } return 0U; }(); if (station->airportMovementOccupiedEdges & mustBeClearEdges) { continue; } GameCommands::VehicleAirPlacementArgs args{}; args.head = head.id; args.airportNode = nodeIndex; args.stationId = elStation->stationId(); args.convertGhost = false; const auto oldUpdatingCompanyId = GameCommands::getUpdatingCompanyId(); GameCommands::setUpdatingCompanyId(CompanyId::neutral); // Why? const auto res = GameCommands::doCommand(args, GameCommands::Flags::apply); GameCommands::setUpdatingCompanyId(oldUpdatingCompanyId); if (res == GameCommands::FAILURE) { tryPlaceVehicleFailure(company, head); } else { tryPlaceVehicleSuccess(head); } return; } tryPlaceVehicleFailure(company, head); } // 0x00487818 static void tryPlaceRoadVehicle(Company& company, Vehicles::VehicleHead& head, World::Pos3 pos) { if (validateRoadPlacement(pos, head.trackType, head.aiPlacementTaD) & (1U << 1)) { // 0x0048788E auto args = generateBackupRoadPlacement(pos, head.trackType, company.id()); if (args.has_value()) { tryPlaceSurfaceVehicle(company, head, args.value()); } return; } if (!head.hasBreakdownFlags(Vehicles::BreakdownFlags::brokenDown)) { auto train = Vehicles::Vehicle(head); const auto firstCarAge = getCurrentDay() - train.cars.firstCar.front->creationDay; if (firstCarAge >= 28 && head.aiThoughtId != 0xFFU) { // 0x0048788E auto args = generateBackupRoadPlacement(pos, head.trackType, company.id()); if (args.has_value()) { tryPlaceSurfaceVehicle(company, head, args.value()); } return; } } GameCommands::VehiclePlacementArgs args{}; args.convertGhost = false; args.pos = pos; args.trackAndDirection = head.aiPlacementTaD; args.trackProgress = 0; if (!head.hasBreakdownFlags(Vehicles::BreakdownFlags::brokenDown)) { if (head.trackType == 0xFFU) { head.aiPlacementTaD ^= (1U << 2); } } tryPlaceSurfaceVehicle(company, head, args); } // 0x00487807 static void tryPlaceTrackVehicle(Company& company, Vehicles::VehicleHead& head, World::Pos3 pos) { GameCommands::VehiclePlacementArgs args{}; args.convertGhost = false; args.pos = pos; args.trackAndDirection = head.aiPlacementTaD; args.trackProgress = 0; if (validateTrackPlacement(pos, head.trackType, head.aiPlacementTaD, company.id()) & (1U << 1)) { auto res = generateBackupTrackPlacement(pos, head.trackType, company.id()); if (!res.has_value()) { return; } args = res.value(); } tryPlaceSurfaceVehicle(company, head, args); } // 0x00487784 static bool tryPlaceVehicles(Company& company) { company.aiPlaceVehicleIndex++; auto* head = [&company]() -> Vehicles::VehicleHead* { auto i = company.aiPlaceVehicleIndex; for (auto* v : VehicleManager::VehicleList()) { if (v->owner != company.id()) { continue; } i--; if (i == 0) { return v; } } return nullptr; }(); if (head == nullptr) { return true; } if (head->tileX != -1) { return false; } if (!head->hasBreakdownFlags(Vehicles::BreakdownFlags::breakdownPending)) { return false; } const auto pos = World::Pos3(head->aiPlacementPos, head->aiPlacementBaseZ * World::kSmallZStep); if (head->mode == TransportMode::air) { tryPlaceAirVehicle(company, *head, pos); } else if (head->mode == TransportMode::water) { tryPlaceWaterVehicle(company, *head, pos); } else if (head->mode == TransportMode::road) { tryPlaceRoadVehicle(company, *head, pos); } else // head->mode == TransportMode::rail { tryPlaceTrackVehicle(company, *head, pos); } return false; } // 0x004312AF // Places all vehicles that are owned by the company // one vehicle a tick // transitions to next state after all vehicles processed static void placeVehicles(Company& company) { if (tryPlaceVehicles(company)) { company.var_4A6 = AiPlaceVehicleState::restart; } } // 0x004312BF static void restartPlacement(Company& company) { company.var_4A6 = AiPlaceVehicleState::begin; } void processVehiclePlaceStateMachine(Company& company) { // TODO: In the future we could cut // this FSM down into just two states // a reset and a placement state using enum AiPlaceVehicleState; switch (company.var_4A6) { case begin: beginPlacement(company); break; case resetList: resetPlacementList(company); break; case place: placeVehicles(company); break; case restart: restartPlacement(company); break; default: assert(false); return; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/World/CompanyAi/CompanyAiPlaceVehicle.h ```h #pragma once namespace OpenLoco { struct Company; } namespace OpenLoco::CompanyAi { void processVehiclePlaceStateMachine(Company& company); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Chart.cpp ```cpp #include "Chart.h" #include "Economy/Currency.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" namespace OpenLoco::Ui { // TODO: replace with templated functions static int64_t graphGetValueFromPointer(const std::byte* dataPtr, const uint8_t dataTypeSize) { switch (dataTypeSize) { case 2: return *reinterpret_cast<const int16_t*>(dataPtr); case 4: return *reinterpret_cast<const int32_t*>(dataPtr); case 6: return reinterpret_cast<const currency48_t*>(dataPtr)->asInt64(); default: return 0; } } // 0x004CF869 static int64_t graphGetMaxValue(const GraphSettings& gs) { int64_t maxValue = 0; for (auto lineIndex = 0U; lineIndex < gs.lineCount; lineIndex++) { auto dataIndex = 0U; std::byte* dataPtr = gs.yData[lineIndex]; if ((gs.flags & GraphFlags::dataFrontToBack) != GraphFlags::none) { dataIndex = gs.dataStart[lineIndex]; dataPtr = &dataPtr[gs.dataTypeSize * (gs.dataEnd - dataIndex)]; } while (dataIndex < gs.dataEnd) { // Data front-to-back? // NB: all charts except cargo delivery if ((gs.flags & GraphFlags::dataFrontToBack) != GraphFlags::none) { dataPtr -= gs.dataTypeSize; } int64_t value = graphGetValueFromPointer(dataPtr, gs.dataTypeSize); maxValue = std::max(maxValue, std::abs(value)); dataIndex++; // Data back-to-front? // NB: for cargo delivery chart if ((gs.flags & GraphFlags::dataFrontToBack) == GraphFlags::none) { dataPtr += gs.dataTypeSize; } } } return maxValue; } // 0x004CFA49 static void graphDrawAxesAndLabels(const GraphSettings& gs, Window& self, Gfx::DrawingContext& drawingCtx) { auto xAxisLabelValue = gs.xAxisRange; if ((gs.flags & GraphFlags::dataFrontToBack) != GraphFlags::none) { xAxisLabelValue -= (gs.dataEnd - 1) * gs.xAxisStepSize; } // 0x004CFA74 for (auto xTickPos = 0U; xTickPos < gs.dataEnd; xTickPos++) { auto remainder = xAxisLabelValue % gs.xAxisLabelIncrement; // Draw vertical lines for each of the data points { auto xPos = xTickPos * gs.xAxisTickIncrement + gs.left + gs.xOffset; auto height = gs.canvasHeight + (remainder == 0 ? 3 : 0); auto colour = self.getColour(WindowColour::secondary).c(); auto paletteIndex = Colours::getShade(colour, remainder == 0 ? 6 : 4); drawingCtx.drawRect(xPos, gs.top, 1, height, paletteIndex, Gfx::RectFlags::none); } // No remainder means we get to draw a label on the horizontal axis, too if (remainder == 0) { int16_t xPos = xTickPos * gs.xAxisTickIncrement + gs.left + gs.xOffset; int16_t yPos = gs.canvasBottom + 5; auto tr = Gfx::TextRenderer(drawingCtx); auto formatArgs = FormatArguments{}; formatArgs.push(gs.xLabel); formatArgs.push(xAxisLabelValue); tr.drawStringCentred({ xPos, yPos }, Colour::black, StringIds::graph_label_format, formatArgs); } xAxisLabelValue += gs.xAxisStepSize; } // 0x004CFB5C auto yAxisPos = 0; while (true) { // Draw horizontal lines for each of the vertical axis labels { auto colour = self.getColour(WindowColour::secondary).c(); auto paletteIndex = Colours::getShade(colour, 6); auto xPos = gs.left + gs.xOffset - 2; auto width = gs.width - gs.xOffset + 3; auto yPos = -yAxisPos + gs.canvasHeight + gs.top; if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { yPos -= gs.canvasHeight / 2; } drawingCtx.drawRect(xPos, yPos, width, 1, paletteIndex, Gfx::RectFlags::none); // Draw negative counterpart? if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { yPos = yAxisPos + gs.top + gs.canvasHeight / 2; drawingCtx.drawRect(xPos, yPos, width, 1, paletteIndex, Gfx::RectFlags::none); } } // Draw the value label as well { int16_t xPos = gs.left + gs.xOffset - 3; // int16_t width = gs.xOffset - 3; // set but not used int16_t yPos = -yAxisPos + gs.canvasHeight + gs.top - 5; if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { yPos -= gs.canvasHeight / 2; } int64_t yAxisLabelValue = static_cast<int64_t>(yAxisPos) << gs.numValueShifts; auto tr = Gfx::TextRenderer(drawingCtx); auto formatArgs = FormatArguments{}; formatArgs.push(gs.yLabel); formatArgs.push<currency48_t>(yAxisLabelValue); tr.drawStringRight({ xPos, yPos }, Colour::black, StringIds::graph_label_format, formatArgs); // Draw negative counterpart? if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { yPos = yAxisPos + gs.top + gs.canvasHeight / 2 - 5; formatArgs = FormatArguments{}; formatArgs.push(gs.yLabel); formatArgs.push<currency48_t>(-yAxisLabelValue); tr.drawStringRight({ xPos, yPos }, Colour::black, StringIds::graph_label_format, formatArgs); } } // 0x004CFD36 yAxisPos += gs.yAxisLabelIncrement; auto quadrantHeight = yAxisPos; if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { quadrantHeight *= 2; } if (quadrantHeight >= gs.canvasHeight) { break; } } // 0x004CFD59 after loop, which is back in drawGraph } // 0x004CFD87 static void drawGraphLineSegments(const GraphSettings& gs, const uint8_t lineIndex, Gfx::DrawingContext& drawingCtx, GraphPointFlags pointFlag) { auto previousPos = Ui::Point(-1, 0); auto dataIndex = 0U; std::byte* dataPtr = gs.yData[lineIndex]; if ((gs.flags & GraphFlags::dataFrontToBack) != GraphFlags::none) { dataIndex = gs.dataStart[lineIndex]; dataPtr = &dataPtr[gs.dataTypeSize * (gs.dataEnd - dataIndex)]; } while (dataIndex < gs.dataEnd) { if ((gs.flags & GraphFlags::dataFrontToBack) != GraphFlags::none) { dataPtr -= gs.dataTypeSize; } int64_t value = graphGetValueFromPointer(dataPtr, gs.dataTypeSize); value >>= gs.numValueShifts; int16_t xPos = gs.canvasLeft + dataIndex * gs.xAxisTickIncrement; int16_t yPos = gs.height - value - gs.yOffset; if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { yPos -= gs.canvasHeight / 2; } yPos += gs.top; if (pointFlag == GraphPointFlags::drawLines) { auto colour = gs.lineColour[lineIndex]; drawingCtx.drawRect(xPos, yPos, 1, 1, colour, Gfx::RectFlags::none); auto targetPos = Ui::Point(xPos, yPos); if (previousPos.x != -1) { drawingCtx.drawLine(previousPos, targetPos, colour); } previousPos = targetPos; } else if (pointFlag == GraphPointFlags::drawPoints) { auto colour = gs.lineColour[lineIndex]; drawingCtx.drawRect(xPos, yPos, 2, 2, colour, Gfx::RectFlags::none); } dataIndex++; if ((gs.flags & GraphFlags::dataFrontToBack) == GraphFlags::none) { dataPtr += gs.dataTypeSize; } } } // 0x004CF824 void drawGraph(GraphSettings& gs, Window& self, Gfx::DrawingContext& drawingCtx) { gs.canvasLeft = gs.xOffset + gs.left; gs.canvasHeight = gs.height - gs.yOffset; gs.canvasBottom = gs.top + gs.height - gs.yOffset; int64_t maxValue = graphGetMaxValue(gs); // 0x004CFA02 auto height = gs.canvasHeight; if ((gs.flags & GraphFlags::showNegativeValues) != GraphFlags::none) { height >>= 1; } // We work out the number of shifts required to bring a 64bit value // into something that is within the height range gs.numValueShifts = 0; for (auto adjustedMaxValue = maxValue; adjustedMaxValue > height; adjustedMaxValue >>= 1) { gs.numValueShifts++; } if ((gs.flags & GraphFlags::hideAxesAndLabels) == GraphFlags::none) { graphDrawAxesAndLabels(gs, self, drawingCtx); } // 0x004CFD59 for (auto j = 0; j < 2; j++) { auto pointFlag = GraphPointFlags(1U << j); if ((gs.pointFlags & pointFlag) == GraphPointFlags::none) { continue; } for (auto i = 0U; i < gs.lineCount; i++) { if ((gs.linesToExclude & (1U << i)) != 0) { continue; } drawGraphLineSegments(gs, i, drawingCtx, pointFlag); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Chart.h ```h #pragma once #include "Graphics/Colour.h" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <cstddef> namespace OpenLoco::Gfx { class DrawingContext; } namespace OpenLoco::Ui { struct Window; enum class GraphFlags : uint8_t { none = 0U, showNegativeValues = 1U << 0, dataFrontToBack = 1U << 1, hideAxesAndLabels = 1U << 2, }; OPENLOCO_ENABLE_ENUM_OPERATORS(GraphFlags); enum class GraphPointFlags : uint8_t { none = 0U, drawLines = 1U << 0, drawPoints = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(GraphPointFlags); constexpr auto kMaxLines = 32; struct GraphSettings { uint16_t left; // 0x0113DC7A uint16_t top; // 0x0113DC7C uint16_t width; // 0x0113DC7E uint16_t height; // 0x0113DC80 uint16_t yOffset; // 0x0113DC82 uint16_t xOffset; // 0x0113DC84 uint32_t yAxisLabelIncrement; // 0x0113DC86 uint16_t lineCount; // 0x0113DC8A std::byte* yData[kMaxLines]; // 0x0113DC8C uint32_t dataTypeSize; // 0x0113DD0C uint16_t dataStart[kMaxLines]; // 0x0113DD10 uint32_t linesToExclude; // 0x0113DD50 PaletteIndex_t lineColour[kMaxLines]; // 0x0113DD54 uint16_t dataEnd; // 0x0113DD74 StringId xLabel; // 0x0113DD76 uint32_t xAxisRange; // 0x0113DD78 uint32_t xAxisStepSize; // 0x0113DD7C uint16_t xAxisTickIncrement; // 0x0113DD80 uint16_t xAxisLabelIncrement; // 0x0113DD82 StringId yLabel; // 0x0113DD84 uint32_t dword_113DD86; // 0x0113DD86 -- always 0 uint32_t yAxisStepSize; // 0x0113DD8A GraphFlags flags; // 0x0113DD8E uint16_t canvasLeft; // 0x0113DD92 uint16_t canvasBottom; // 0x0113DD94 uint16_t canvasHeight; // 0x0113DD96 uint8_t numValueShifts; // 0x0113DD98 -- factors of two GraphPointFlags pointFlags; // 0x0113DD99 uint16_t itemId[kMaxLines]; // 0x0113DD9A }; void drawGraph(GraphSettings& gs, Window& self, Gfx::DrawingContext& drawingCtx); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Cursor.cpp ```cpp #include "Cursor.h" #include <cassert> #include <cstdint> #include <cstdio> #include <string_view> namespace OpenLoco::Ui { Cursor Cursor::blank = Cursor( 0, 0, " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "); Cursor Cursor::upArrow = Cursor( 16, 0, " X " " X.X " " X...X " " X.....X " " X.......X " " X.........X " " XXXX...XXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " XXXXX " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "); Cursor Cursor::upDownArrow = Cursor( 16, 16, " " " X " " X.X " " X.X.X " " X.X X.X " " X.X X.X " " X.XXX XXX.X " " X....X X....X " " XXX.XXX.XXX " " X.....X " " XXXXX " " " " " " X " " X.X " " X...X " " X.X " " X " " " " " " XXXXX " " X.....X " " X.XXX.X " " XXX.X X.XXX " " X....X X....X " " X.XXX XXX.X " " X.X X.X " " X.X X.X " " X.X.X " " X.X " " X " " "); Cursor Cursor::busy = Cursor( 16, 17, " " " " " " " " " " " " " " " " " " " " " " " XXX " " XXXXX...X " " XXXXXX....XX.X " " X.....XXX.XX...X " " XXXXXXXXX.X X.XX XXX " " X......XX.X X....X " " XXXX.XX.XXX XXXX " " XXXXXXXX X.XX.....X " " X........XX.X XXXXX " " X........X.XXXX " " XXXX...X......X " " X...X XXXXXX " " X...X " " X...XXXX " " X........X " " X........X " " XXXXXXXX " " " " " " " " "); Cursor Cursor::diagonalArrows = Cursor( 7, 7, "....... " ".XXXX. " ".XXX. " ".XXX. " ".X..X. " ".. .X. " ". .X. " " .X. " " .X. . " " .X. .. " " .X..X. " " .XXX. " " .XXX. " " .XXXX. " " ....... " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "); Cursor Cursor::picker = Cursor( 15, 31, " XXXXX " " X....XX " " X..XX..XX " " X.XXXX.XX " " X.XXXX.XX " " X..XX..XX " " X....XX " " XXXXXXX " " XXXXXXX " " X.XXX..XX " " X..X...XX " " X....X...XX " " X...XX...XX " " X...X X...XX " " X...X X...XX " " X...X X...XX " " X..X X..XX " " X...X X...XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " X...X X...XX " " X..X X..XX " " X..X X..XX " " X..X X..XX " " XX.X X.XXX " " XXX XXXX "); Cursor Cursor::plantTree = Cursor( 6, 31, " " " XXX " " XX...X XXX " " X......XX...X " " XXX...........XX " " XXX.X...........X " " XXX............X " " XXX............X " " XXX.....X.......X " " XXXX.X.........X " " XXXXXXXX..X....X " " XXXX.XX.XXX......X " " XXX.X.XXX...X.....X " " XXXX.X...X....X...X " " XXXXX.X.X....X...XX " " XXXXXXXXXX.....X.XX " " XXXXXX.XXX.X...XX " " XXXXX XXXXXXXXXXX.XX " " X...X XXXXX.XXXXX " " X...X XXX.X " " X...X XX.X " " X...X XX.X " " X...X X..X " " X...X X..X " " X...X X...X " "XXXXX...XXXXX XX.....X " " X.........X XX........XX " " X.......X X.....X..XX..X " " X.....X XXX.X X.X XX " " X...X X X " " X.X " " X "); Cursor Cursor::placeFountain = Cursor( 6, 31, " . . " " . . . ." " . . . . " " . . . . " " . . . ." " . . . " " . . " " . " " . . " " . " " X " " XXX " " X.X " " XXXX.XXXX " " XX...X.XX..XX " " X....X.XXXXX..X " " X.....XXXXX...X " " XXXXX XXX.........XXX " " X...X X..XXXXXXXXX.XX " " X...X X.......XXXXX " " X...X XXX...XXXXX " " X...X XXXXXXX " " X...X X.XXX " " X...X X..XX " " X...X X..XX " "XXXXX...XXXXX X..XXXX " " X.........X X..XXX.XX " " X.......X X.......XXX " " X.....X XX.....XX.X " " X...X XXXXXXXXX " " X.X XXXXX " " X "); Cursor Cursor::placeStatue = Cursor( 6, 31, " " " " " X X " " XXX XX XX " " X.X X..X XX " " X.X X..X XX " " X.XX X.XX X.X " " X..X.X XX.X " " X....X..X " " X......X " " X....X " " X....X " " X..X " " X...X " " X...X " " X.X " " X.X " " XXXXX X...X " " X...X X..X " " X...X X.X " " X...X XX.X " " X...X X..X " " X...X XXXXXXX " " X...X X.....X " " X...X X.....X " "XXXXX...XXXXX X.....X " " X.........X X.....X " " X.......X X.....X " " X.....X XXXXXXXXX " " X...X X.........X " " X.X XXXXXXXXXXX " " X "); Cursor Cursor::placeBench = Cursor( 6, 31, " " " " " XX " " X.XX " " X...XX " " X.....XX " " XX......XX " " X.XX......XX " " X.X XX......XX " " XX.X XX......XX " " XX..XX XX......X " " XX......XX XX....X " " XXXX......XX XX..X " " X.X XX......XX XXX " " X.X XXX......XX X.X " " X XX......XX X.X " " XXXX......XX.X " " XXXXX X.X XX......XX " " X...X X.X XX..XXXX " " X...X X XXX X.X " " X...X XXX X.X " " X...X X.X X " " X...X X.X " " X...X X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::crosshair = Cursor( 14, 16, " " " " " " " " " " " X " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " X " " " " XXXXXXX X XXXXXXX " " X.......X X.X X.......X " " XXXXXXX X XXXXXXX " " " " X " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " X " " " " " " " " "); Cursor Cursor::placeTrashBin = Cursor( 6, 31, " " " " " " " " " " " " " XXX " " X X " " XXXXX " " XX....XXX " " X........XX " " X..X.X.XXXXXX " " X..........XX " " XXXXXXXXXXXXX " " X.......XXX " " X.X......XX " " X.X.X....XX " " XXXXX X.X.X.....X " " X...X X.X.X...X.X " " X...X X.X.X...X.X " " X...X X.X.X.X.X.X " " X...X X.X.X.X.X.X " " X...X X.X.X.X.X.X " " X...X X.X.X.X.X.X " " X...X X.X.X.X.X.X " "XXXXX...XXXXX X.X.X.X.X.X " " X.........X X.X.X.X.X.X " " X.......X XXXXXXXXXXX " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeLantern = Cursor( 6, 31, " XXX " " X...X " " X.....X " " XXXXXXXXX " " XXXX..X " " XX....X " " XX....X " " XX..X " " XXXXX " " XXX " " X.X " " X X.X X " " XXXXX.XXXXX " " X X.X X " " X.X " " X.X " " X.X " " XXXXX X.X " " X...X X.X " " X...X X.X " " X...X X.X " " X...X X.X " " X...X X.X " " X...X XXX " " X...X XXX " "XXXXX...XXXXX XX..X " " X.........X XX....X " " X.......X XX....X " " X.....X XXX...X " " X...X XXXXX.X " " X.X XXXXXXXXX " " X "); Cursor Cursor::placeFence = Cursor( 6, 31, " " " XX " " X.XX " " X..XXX XX " " X....XXX.XX " " X.....X.XX XX " " X.XX....XXX X.XX " " X.XXXX....XXX.XX XX " " X.XX X.....X.XX X.XX " " X.XX X.XX.....XX X.XX XX " " XX.XX X.XXXX.....XX.XX X.XX " " XXXXX X.XX X.X.....XX X.XX " " XXXX X.XX X.XXX....XX X.XX " " XXXX.XX X.XX XX....XX.XX " " XXXXX X.XX X.X.....XX " " XXXX X.XX X.XXX....XX " " XXXX.XX X.XX XX..XX " " XXXXX XXXXX X.XX X.XXX " " X...X XXXX X.XX X.XX " " X...X XXXX.XX X.XX " " X...X XXXXX X.XX " " X...X XXXX X.XX " " X...X XXXX.XX " " X...X XXXX " " X...X XX " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeFlowers = Cursor( 6, 31, " X " " X.X " " X...X " " XX X...X XX " " X..X X.X.X X..X " " X...X X.X.X X...X " " X...X X.X.X X...X " " X.X.X XXX X.X.X " " X.XX XXX XX.X " " XXXX...XXXX " " XXXXX X..X..X XXXXX " " X.....XX.X...XXXX.....X " " X...XXX.XX...X..XXXXX...X" " X.....XX..X...XXX.....X " " XXXXX X...X.X XXXXX " " XXXXX..XXXX " " X.XX XXX XX.X " " XXXXX X.X.X XXX X.X.X " " X...X X...X X.X.X X...X " " X...X X..X X.X.X X..X " " X...X XX X...X XX XX " " X...X XX X...X XX..X " " X...X X..XX X...X X....X " " X...X X....X X.X X.....X " " X...X X.....X XXX X..X..X " "XXXXX...XXXXX.X.X XXX X..X...X " " X.........X...X.XX.X X.X...X " " X.......X X...XXX.XX.X...X " " X.....X XX..X..X.X..XX " " X...X XX......XX " " X.X XXXXXX " " X "); Cursor Cursor::placePath = Cursor( 6, 31, " " " " " " " " " " " XX " " XX..XX " " XX....X.XX " " XX..X..X....XX " " XX.X...X..X...X.XX " " XX...X...XXX.X..X...XX " " XXXX..XXX.....X.X...X.XX " " XXXX...X..XXXXXXXXX...XX " " XXXX..XX...X.....X..X.XX " " XXXX.....X.....X..X...XX " " XXXX..X.X...X.X.XXXX..X" " XXXX...X.X...X....XXX" " XXXXX XXXX..X.X..X..XXXX " " X...X XXXX...X..XXXX " " X...X XXXX..XXXX " " X...X XXXXXX " " X...X XX " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::landTool = Cursor( 6, 31, " " " XX " " X..X " " X.X..X " " X.X X..X " " X.X X.XX" " X.X X.XX " " X..XX.XX " " X.....XX " " X...XXXX " " X...XX " " XX X.X.X " " X..XX...XX " " X..XX...XX " " X.X.X...XX " " X...X...XX " " X..X...XXXX " " XXXXXX...X.XXXX..X " " X...XX...XXXXX...X " " X...XX....XX..X.X " " X...X X........X " " X...X X......X " " X...X X...XX " " X...X XXX " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::waterTool = Cursor( 6, 31, " " " " " " " " " " " " " " " X X X X " " X X X X " " X.X X.X X.X X.X " " XX...XXX...XXX...XXX...XX " "X...X.....X.....X.....X...X " " XXX XXXXX XXXXX XXXXX XXX " " " " X X X X " " X X X X " " X.X X.X X.X X.X " " X...XXX...XXX...XXX...X " " XXXXX.X.....X.....X.....X..X" " X...XX XXXXX XXXXX XXXXX XX " " X...X " " X...X X X " " X...X X X " " X...X X.X X.X " " X...X XX...XXX...XX " "XXXXX...XXXXX...X.....X...X " " X.........X XXX XXXXX XXX " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeHome = Cursor( 6, 31, " " " " " X XXXXXX " " X.X X....X " " X...X XXXX " " X..X..XX..X " " X...XX..X..X " " X.....XX....X " " X...XXXXXX...X " " X.........XX..X " " X....XXXXXXXXX..X " " X.............XX..X " " X...XXXXXXXXXXXXXX..X " " XXXX.............XXXXXX " " X...............X " " X...............X " " X...XXXX.XXXXXX.X " " X...X X.X X.X " " XXXXX X...X X.X X.X " " X...X X...X X.X X.X " " X...X X...X X.XXXXXX.X " " X...X X...X X........X " " X...X X...X X........X " " X...X XXXXXXXXXXXXXXXXX " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeVolcano = Cursor( 6, 31, " X X X " " X X " " X " " X X " " XXXX XX " " XXXXXXXXXXX " " X.XXXX....X " " XX.......XXXX " " XXX.XX..XXX..X " " X.XX.X.X...X..X " " X......X...XXX..X " " XX....X.......X.X..XXX " " X.....XX......X.XXXX...X " " XX.....XX........X.X.X.X..XX " " X...XXXX....X......XXX.XXXXXXX" " XXXXX X.XXXXXX...XXXXXXX XX " " X XXXX XX.XX XX " " X X " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::footsteps = Cursor( 6, 31, " " " XXX " " X...X " " X....X " " X....X " " X...X " " XXX X " " XX.X " " X..X " " XX " " " " XXX XXX " " X...X X...X " " X....X X....X " " X....X X....X " " X...X X...X " " XXX X XXX X " " XX.X XX.X " " XXXXX X..X X..X " " X...X XX XX " " X...X " " X...X XXX " " X...X X...X " " X...X X....X " " X...X X....X " "XXXXX...XXXXX X...X " " X.........X XXX X " " X.......X XX.X " " X.....X X..X " " X...X XX " " X.X " " X "); Cursor Cursor::brush = Cursor( 7, 30, " " " XXX " " XXXXXX " " XXXXX.X " " XXXXX.XX " " XXXXX..X " " XX XXXXX..XX " " XXXX X..X..XX " " XXXXXX X....XXX " " XX.XXXXXXX....XX " " XXXX.XXXX.....XX " " XXXXXX.XXX...XX " " XXXXXXXX.XX...X " " XX.XXXXXX.XXXXX " " XXXXXXXXX.XXXXX " " XX.XXXXXX.XXXXX " " XX.XXXXXX.XXXXX " " XXXXX XXXXXXXXX.XXXX " " X...X XX.X..XXX.XXX " " X...X XX.....XXXX " " X...X XX.....XX " " X...X XX...XX " " X...X XX.XX " " X...X X.X " " XXXXX...XXXXX X " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X " " "); Cursor Cursor::placeBanner = Cursor( 6, 31, " X X " " X.X X.X " "X...X X...X " " X.X X.X " " XXXXXXXXXXXXXXXXXXXXXXXXXXXXX " " X.XX.....................XX.X " " X.X X...................X X.X " " X.X X...................X X.X " " X.X X...................X X.X " " X.XXX....................XX.X " " X.XXXXXXXXXXXXXXXXXXXXXXXXX.X " " X.X X.X " " X.X X.X " " X.X X.X " " X.X X.X " " X.X X.X " " X.X X.X " " X.XXXXXX X.X " "XX.XX...X X.X " " X.XX...X X X XX.X X" " X.XX...X X.X " "XX.XX...X X.X " " X.XX...X X X XXX.X " " X...X " " X...X XX X X " "XXXXX...XXXXX XXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::openHand = Cursor( 15, 17, " XX X " " X..X XXX " " X..X X..X " " XX X...X X..X " " X..X X...X X..X XX " " X...X X....XX...XX..X " " X....X X...XX...XX...X " " XX...X X...XX....XX..X " " X....X X....X....XX..X " " XX....XX....X....X...X " " X.....X....X....X...X " " XX....XX........X...X " " X.....X.............X " " XX..................X " " XX.................X " " X.................X " " XX................X " " XX................X " " X................X " " X................X " " X...............X " " X...............X " " X................X " " X................X " " XXXXXX.................X " " X........................X " " X.X......................X " " X..X.....................X " " XXXX....XXXX.............X " " XXXXXX XX............X " " XX.........XX " " XXXXXXXXXX "); Cursor Cursor::dragHand = Cursor( 15, 17, " " " XXXX XXX " " X....XX...X " " X.....XX...XX " " X.....X....XXX " " XXX X......X....X.X " " X...XX XX....XX...X..X " " X.....XX XX...XX....X..X " " XX......X X....X....X..X " " XX......XX....X....X...X " " XX......X....X....X...X " " XX.....XX........X...X " " X.....X.............X " " XX..................X " " XX.................X " " X.................X " " XX................X " " XX................X " " X................X " " X................X " " XXX X...............X " " X...X X...............X " " X....XX................X " " X.X....................X " " X.X....................X " " X......................X " " X......................X " " XXX...................X " " XXXXXXX.............X " " XX............X " " XX.........XX " " XXXXXXXXXX "); Cursor Cursor::placeTrain = Cursor( 6, 31, " " " " " " " XXX XXXXXXX " " XX.XX XX XXXXXXX " " X.X X..X XXXX X " " XXXXXXXXXXXXX..X X " " X.XX..X..X..X..XXXXXX " " XXXX..X..X..X..X....X " " XXXX..X..X..X..X.XX.X " " XXXXXXXXXXXXXXXX....X " " XXXXXXXXXXXXXXXXX....X " " XXX.X.XX.X.XX.XXXXXXXX " " X.XX...XX...XX...XX.X " " XX XXX XXX XXX X " " " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeTrainAlt = Cursor( 25, 31, " " " " " " " XXXXXXX XXX " " XXXXXXX XX XX.XX " " X XXXX X..X X.X " " X X..XXXXXXXXXXXXX " " XXXXXX..X..X..X..XX.X " " X....X..X..X..X..XXXX " " X.XX.X..X..X..X..XXXX " " X....XXXXXXXXXXXXXXXX " " X....XXXXXXXXXXXXXXXXX " " XXXXXXXX.XX.X.XX.X.XXX " " X.XX...XX...XX...XX.X " " X XXX XXX XXX XX " " " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " XXXXX...XXXXX" " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeBus = Cursor( 6, 31, " " " " " XXXXXXXXXXXXXXXXXXXXX " " X.....................X " " X.XXX.XXX.XXX.XXX.XXX.X " " X.XXX.XXX.XXX.XXX.XXX.X " " X.XX..XX..XX..XX..XX..X " " X....................X " " X....................X " " XXXXX.XXX.XXX.XXX.XXX.X " " XXX.X.XXX.XXX.XXX.XXX.X " " XXX.X.XX..XX..XX..XX..X " " X.X.XXX..........XX...X " " X.X.X..X........X..X..X " " XXXX..XXXXXXXXXX..XXX " " XX XX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeBusAlt = Cursor( 25, 31, " " " " " XXXXXXXXXXXXXXXXXXXXX " " X.....................X " " X.XXX.XXX.XXX.XXX.XXX.X " " X.XXX.XXX.XXX.XXX.XXX.X " " X..XX..XX..XX..XX..XX.X " " X....................X " " X....................X " " X.XXX.XXX.XXX.XXX.XXXXX " " X.XXX.XXX.XXX.XXX.X.XXX " " X..XX..XX..XX..XX.X.XXX " " X...XX..........XXX.X.X " " X..X..X........X..X.X.X " " XXX..XXXXXXXXXX..XXXX " " XX XX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " XXXXX...XXXXX" " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeTruck = Cursor( 6, 31, " " " " " XXXXXXXXXXXXX " " X.............X " " X X.XX..XX..XX..X " " XXXXX.X...X...X...X " " X....X.X...X...X...X " " XXX..X.X...X...X...X " " XXXXXX..X.X...X...X...X " " X........X.XX..XX..XX..X " " X........X.............X " " X..XX....XXXXXXXXXXXX.X " " X.XX.X..X...X XX.XX X " " XXX.X.XXXXXXX X.X.X X " " XX.X XX.X " " XX XX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeTruckAlt = Cursor( 25, 31, " " " " " XXXXXXXXXXXXX " " X.............X " " X..XX..XX..XX.X X " " X...X...X...X.XXXXX " " X...X...X...X.X....X " " X...X...X...X.X..XXX " " X...X...X...X.X..XXXXXX " " X..XX..XX..XX.X........X " " X.............X........X " " X.XXXXXXXXXXXX....XX..X " " X XX.XX X...X..X.XX.X " " X X.X.X XXXXXXX.X.XXX " " X.XX X.XX " " XX XX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " XXXXX...XXXXX" " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeTram = Cursor( 6, 31, " XX " " X..X " " X.XX.X " " X.X X.X " " X.XX.X " " X..X " " XXXXXXXXXXXXXXXXXXX " " X...................X " " XXXXXXXXXXXXXXXXXXXXX " " XXX.X.XXX.XXX.XXX.X.XXX " " X.X.X.X.X.X.X.X.X.X.X.X " " XXX.X.XXX.XXX.XXX.X.XXX " " X...X.............X...X " " X...X.............X...X " " XXXXXXXXXXXXXXXXXXXXX " " XX XX XX XX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeTramAlt = Cursor( 25, 31, " XX " " X..X " " X.XX.X " " X.X X.X " " X.XX.X " " X..X " " XXXXXXXXXXXXXXXXXXX " " X...................X " " XXXXXXXXXXXXXXXXXXXXX " " XXX.X.XXX.XXX.XXX.X.XXX " " X.X.X.X.X.X.X.X.X.X.X.X " " XXX.X.XXX.XXX.XXX.X.XXX " " X...X.............X...X " " X...X.............X...X " " XXXXXXXXXXXXXXXXXXXXX " " XX XX XX XX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " XXXXX...XXXXX" " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placePlane = Cursor( 6, 31, " XXXXX" " X..X.X" " X...X.X" " X...X.X " " X....X.X " " X.....X.X " " XXXXXXXXXXXXXXXXXX.....X.X " " XXX.....................XXX " " XX..........................X " "XX.X.X.X.X.X.X.X.X.X.X.X....X " "XX.........................X " "XX........XXXXXXXX........X " " XX......X........XX...XXX " " XXXXXX..XXXXXX...XXX " " XXX.X....XXX " " X.X.....XXX " " X.X....XX " " XXXXX XXXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeShip = Cursor( 6, 31, " X " " X " " X X " " X X " " X X " " X XXXX X " " XXX XXXX X " " X...X X..X X " " X....XXXXXXXXXX X " " X..............X X " "XXXXXXX......XX.XX.XX..XXXXXX " "X............................X " " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" " XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" " XX....X..X.X..XXXX.XX..XXX.XXX" " XXXXXXXXXXXXXXXXXXXXXXXXXXXX " " " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::inwardArrows = Cursor( 14, 16, " " " " " " " " " " " X " " X.X " " X.X " " XXX.XXX " " X.......X " " X.....X " " X...X " " X X.X X " " X.X X X.X " " X..X X..X " " XXX...X X X...XXX " " X.......X X.X X.......X " " XXX...X X X...XXX " " X..X X..X " " X.X X X.X " " X X.X X " " X...X " " X.....X " " X.......X " " XXX.XXX " " X.X " " X.X " " X " " " " " " " " "); Cursor Cursor::placeTown = Cursor( 6, 31, " XXXXXXXXXXXX " " X..........XX " " XXXXX.X.XX.X.X " " XXXXXXXXXXXX..X " " X..........XX..X " " X.XX.XX.XX.X.X.X " " X.X..X..X..X..XX " " X..........X.X.X " " X.XX.XX.XX.X.X.X " " X.X..XX.XX.X...X " " XXX X..........X.X.X " " X...X X.XX.XX.XX.XXXXXXX " " X.....X X.X..XX.XX.X.....XX " " X.XXX.X X..........XXXXXXX.X" "XXXX.X...XXXX.XX.XX.XX.X.X.X.XXX" "X...........X.XX.X..XX.X.....X.X" "X.X.XXXXX.X.X..........X.X.X.X.X" "X...........X.XX.XX.XX.X.X.X.X.X" "X.X..XXX..X.X.X..XX.X..X.....X.X" "X....XX.....X..........X.X.X.X.X" "X.X..XX...X.X.XX.XX.XX.X.X.X.X.X" "X...XXXXX...X.X..XX.XX.X.....X.X" "X...X...XX..X....XX....X.X.X.X.X" "XXXXX...XXXXXXXXXXXXXXXXXXXXXXXX" " X...XX " "XXXXX...XXXXX X XXXXXXXXXXXXXXX " " X.........XX " " X.......XX XX X XXXXX XX " " X.....XX " " X...XX XXXX " " X.XX " " XX "); Cursor Cursor::placeBuilding = Cursor( 6, 31, " " " " " " " XXXXXXXXXXXX " " X..........XX " " XXXXX.X.XX.X.X " " XXXXXXXXXXXX..X " " X..........XX..X " " X.XX.XX.XX.X.X.X " " X.X..X..X..X..XX " " X..........X.X.X " " X.XX.XX.XX.X.X.X " " X.X..XX.XX.X...X " " X..........X.X.X " " X.XX.XX.XX.X.X.X " " X.XX.X..XX.X...X " " X..........X.X.X " " X.XX.XX.XX.X.X.X " " X.X..XX.X..X...X " " X..........X.X.X " " X.XX.XX.XX.X.X.X " " XXXXX X.X..XX.XX.X...X " " X...X X....XX....X.X.X " " X...X XXXXXXXXXXXXXXXX " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeFactory = Cursor( 6, 31, " XX XX " " XX.X XX.X " " XX.X XX.X " " XX XXXX XXXX " " XX.X XX.X XX.X " " XX.X XXXX XXXX " " XXXX XX.X XX.X " " XX.X XX.X XX.X " " XX XXXX XXXX XX.X " " XX..X XX.X XX..XXX.X " " XX..XX.X XX.XX..XX.XX.X " " XX..XXXXX.X XXX..XXXXX.X.X " " XX..XXX...XX.XXX..XXX...XX.XX " " X.XXX....X.XX...XXX..X...XX.X " " XXX...XX....XXXXX.XX...X..XXX " " X...X........XX......X.....XX " " X.XX.XX.XX.XX.X.XX.XX.XX.XX.X " " X.XX.XX.XX.XX.X.XX.XX.XX.XX.X " " X.XX.XX.XX.XX.X.XX.XX.XX.XX.X " " X.XX.XX.XX.XX.X.XX.XX.XX.XX.X " " XX.....X......X.........X...X " " X.XXXXXX..X.XXX..XX...X....XX " " X.X...XX......X.........XX..X " " XXX...XXXXXXXXXXXXXXXXXXXXXXX " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::bulldozerTool = Cursor( 6, 31, " XXX " " XX...X " " XX....X " " X..XX.X " " X..X X XXXXXXX " " XXX X.......X " " XX X.X X.XXX.X.X " " X.X XXX.XXXXXXXX.XXX.X.X " " X.X X...........X.XXX.X.X " " X.X X.XXXXXX....X.XXX.X.X " " X.X X.XX.X......X.......X " " X.XXXXXXXXXXX..XXXX......X " " X.X..........X...........X " " X.X....XXXXXXXXXXX.XX.XXX " " X.XXXXX..X..X..X..X..X..XX " " X.X X.XX.XX.XX.XX.XX.XX.X " " X.X X.XX.XX.XX.XX.XX.XX.X " " XX.X X..X..X..X..X..X..X " "X..X XXXXXXXXXXXXXXXXX " " XX XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeSignal = Cursor( 6, 31, " X " " X.X " " X.X " " X.X " " X.X " " XXX " " XXXXXXXXXXXXXXX " " X...X.....XX..X " " X..XXX....XX.X " " X...X.....XX..X " " XXXXXXXXXXXXXXX " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " X.X " " XXXXX X.X " " X...X X.X " " X...X X.X " " X...X X.X " " X...X XX.XX " " X...X XXXXX " "XXXXX...XXXXX XXX.X " " X.........X XXXXX " " X.......X XXX.X " " X.....X XXX.X " " X...X XXXXX " " X.X XXX " " X "); Cursor Cursor::placeHQ = Cursor( 6, 31, " XXXXX " " X.....X " " XXX.....XXX " " XX..XX...XX..XX " " X..X..X...X..X..X " " X.X..XXX...XXX..X.X " " X...XXX XXX XXX...X " " X...XX XX...X " " X.XX.X X.XX.X " " X...XX XX...X " " XXXXX XXXXX " " X...X X...X " " XXXXXXXX XXXXXXXX" " X......X X......X" " XXXXXX XXXXXX " " X...XXXXXXXXXXXXXXX...X " " X...X X X X X X X X...X " " X...X X X X X X X X...X " " X...X X X X X X X X...X " " XXXXX " " X...X " " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); Cursor Cursor::placeStation = Cursor( 6, 31, " XXXXXXX " " XXX.......XXX " " XX...XXXXXXX...XX " " X..XXXXXX.XXXXXX..X " " X.XXX.X X.X.X X.XXX.X " " X.XX X.X X.X X.X XX.X" " XXXXXXXXXXXXXXXXXXXXXXX" " X.....................X" " X.X.X.X.X.X.X.X.X.X.X.X" " XXXXXXXXXXXXXXXXXXXXXXX" " XXX XXX" " X.X X.X" " X.X X.X" " X.X X.X" " X.X X.X" " X.X X.X" " XXXXX XXXXX" " X....X X....X" " XXXXXX XXXXXX" " XXXXXX...X X...X" " X...XXXXXX XXXXX" " X...X " " X...X " " X...X " " X...X " "XXXXX...XXXXX " " X.........X " " X.......X " " X.....X " " X...X " " X.X " " X "); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Cursor.h ```h #pragma once #include <cassert> #include <cstdint> #include <cstdio> #include <string_view> namespace OpenLoco::Ui { constexpr char rawTransparent = ' '; constexpr char rawWhite = '.'; constexpr char rawBlack = 'X'; constexpr uint16_t cursorDimSize = 32; constexpr uint16_t rawCursorSize = cursorDimSize * cursorDimSize; constexpr uint16_t encodedCursorSize = rawCursorSize / 8; class Cursor { public: int x; int y; uint8_t data[encodedCursorSize]{}; uint8_t mask[encodedCursorSize]{}; static Cursor blank; static Cursor upArrow; static Cursor upDownArrow; static Cursor busy; static Cursor diagonalArrows; static Cursor picker; // 124 static Cursor plantTree; // 131 static Cursor placeFountain; // 127 static Cursor placeStatue; // 128 static Cursor placeBench; // 129 static Cursor crosshair; // 130 static Cursor placeTrashBin; // 132 static Cursor placeLantern; // 133 static Cursor placeFence; // 138 static Cursor placeFlowers; // 137 static Cursor placePath; // 139 static Cursor landTool; // 141 static Cursor waterTool; // 142 static Cursor placeHome; // 143 static Cursor placeVolcano; // 144 static Cursor footsteps; // 145 static Cursor brush; // 158 static Cursor placeBanner; // 159 static Cursor openHand; // 161 static Cursor dragHand; // 160 static Cursor placeTrain; // 163 static Cursor placeTrainAlt; // 162 static Cursor placeBus; // 173 static Cursor placeBusAlt; // 172 static Cursor placeTruck; // 178 static Cursor placeTruckAlt; // 177 static Cursor placeTram; // 175 static Cursor placeTramAlt; // 176 static Cursor placePlane; // 180 static Cursor placeShip; // 179 static Cursor inwardArrows; static Cursor placeTown; // 169 static Cursor placeBuilding; // 168 static Cursor placeFactory; // 170 static Cursor bulldozerTool; // 184 static Cursor placeSignal; // 185 static Cursor placeHQ; // 186 static Cursor placeStation; // 189 public: constexpr Cursor(int x, int y, std::string_view bitmap); }; constexpr Cursor::Cursor(int x, int y, std::string_view bitmap) : x(x) , y(y) { assert(bitmap.length() == rawCursorSize); this->x = x; this->y = y; uint8_t curBit{}; uint16_t curPixel{}; uint8_t dataByte{}, maskByte{}; for (char rawPixel : bitmap) { // Default is transparent uint8_t dataBit = 0; uint8_t maskBit = 0; switch (rawPixel) { case rawBlack: dataBit = 1; maskBit = 1; break; case rawWhite: dataBit = 0; maskBit = 1; break; } dataByte |= (dataBit << (7 - curBit)); maskByte |= (maskBit << (7 - curBit)); // Save dataBit once 8 chars have been processed. curBit = (curBit + 1) % 8; if (curBit == 0) { this->data[curPixel] = dataByte; this->mask[curPixel] = maskByte; dataByte = 0; maskByte = 0; curPixel++; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Dropdown.cpp ```cpp #include "Dropdown.h" #include "Engine/Limits.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Logging.h" #include "Objects/CompetitorObject.h" #include "Objects/ObjectManager.h" #include "Ui/Widgets/Wt3Widget.h" #include "Widget.h" #include "Window.h" #include "World/CompanyManager.h" #include <OpenLoco/Core/Exception.hpp> #include <cassert> #include <cstdarg> #include <limits> using namespace OpenLoco::Interop; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Ui::Dropdown { static constexpr int kBytesPerItem = 8; // 0x00504619 static constexpr Colour kDropdownColourTable[31] = { Colour::grey, // 0x01 Colour::grey, // 0x01 Colour::white, // 0x02 Colour::mutedPurple, // 0x04 Colour::mutedPurple, // 0x04 Colour::purple, // 0x05 Colour::blue, // 0x07 Colour::blue, // 0x07 Colour::mutedDarkTeal, // 0x08 Colour::mutedDarkTeal, // 0x08 Colour::green, // 0x0D Colour::mutedSeaGreen, // 0x0B Colour::mutedGrassGreen, // 0x0C Colour::green, // 0x0D Colour::mutedAvocadoGreen, // 0x0E Colour::mutedOliveGreen, // 0x0F Colour::yellow, // 0x10 Colour::yellow, // 0x10 Colour::orange, // 0x12 Colour::amber, // 0x13 Colour::orange, // 0x12 Colour::mutedDarkYellow, // 0x15 Colour::mutedDarkYellow, // 0x15 Colour::brown, // 0x17 Colour::mutedOrange, // 0x18 Colour::mutedDarkRed, // 0x19 Colour::red, // 0x1B Colour::red, // 0x1B Colour::pink, // 0x1D Colour::pink, // 0x1D Colour::mutedRed // 0x1E }; // 0x005046FA static constexpr std::uint8_t kAppropriateImageDropdownItemsPerRow[33] = { 1, 1, 1, 1, 2, 2, 3, 3, 4, 3, 5, 4, 4, 5, 5, 5, 4, 5, 6, 5, 5, 7, 4, 5, 6, 5, 6, 6, 6, 6, 6, 8, 8 }; static char _byte_112CC04[512]; static uint8_t _windowDropdownOnpaintCellX; static uint8_t _windowDropdownOnpaintCellY; static uint16_t _dropdownItemCount; static uint32_t _dropdownDisabledItems; static uint32_t _dropdownItemHeight; static uint32_t _dropdownItemWidth; static uint32_t _dropdownColumnCount; static uint32_t _dropdownRowCount; static Flags _dropdownFlags; static int16_t _dropdownHighlightedIndex; static uint32_t _dropdownSelection; static StringId _dropdownItemFormats[40]; static std::byte _dropdownItemArgs[40][kBytesPerItem]; static std::byte _dropdownItemArgs2[40][kBytesPerItem]; static uint8_t _menuOptions[40]; static std::vector<std::optional<DropdownItemId>> _dropdownIds; static bool _dropdownUseDefault; void addSeparator(size_t index) { add(index, 0); } void add(size_t index, StringId title) { assert(index < std::numeric_limits<uint8_t>::max()); _dropdownItemFormats[index] = title; } void add(size_t index, StringId title, std::initializer_list<format_arg> l) { assert(index < std::numeric_limits<uint8_t>::max()); _dropdownItemFormats[index] = title; std::byte* args = _dropdownItemArgs[index]; for (auto arg : l) { switch (arg.type) { case format_arg_type::u16: { uint16_t* ptr = (uint16_t*)args; *ptr = arg.u16; args += 2; break; } case format_arg_type::u32: { uint32_t* ptr = (uint32_t*)args; *ptr = arg.u32; args += 4; break; } case format_arg_type::ptr: { uintptr_t* ptr = (uintptr_t*)args; *ptr = arg.ptr; args += 4; break; } default: Logging::error("Unknown format: {}", static_cast<int>(arg.type)); break; } } } void add(size_t index, StringId title, const FormatArguments& fArgs) { add(index, title); std::byte* args = _dropdownItemArgs[index]; int32_t copyLength = std::min(fArgs.getLength(), sizeof(_dropdownItemArgs[index])); memcpy(args, fArgs.getBufferStart(), copyLength); copyLength = std::min(fArgs.getLength() - sizeof(_dropdownItemArgs[index]), sizeof(_dropdownItemArgs2[index])); if (copyLength > 0) { args = _dropdownItemArgs2[index]; memcpy(args, reinterpret_cast<const std::byte*>(&fArgs) + sizeof(_dropdownItemArgs[index]), copyLength); } } void add(size_t index, StringId title, format_arg l) { assert(index < std::numeric_limits<uint8_t>::max()); add(static_cast<uint8_t>(index), title, { l }); } int16_t getHighlightedItem() { return _dropdownHighlightedIndex; } void setItemDisabled(size_t index) { assert(index < std::numeric_limits<uint8_t>::max()); _dropdownDisabledItems |= (1U << static_cast<uint8_t>(index)); } void setHighlightedItem(size_t index) { // Ensure that a valid item index is passed, or -1 to disable. assert(index < std::numeric_limits<uint8_t>::max() || index == std::numeric_limits<size_t>::max()); _dropdownHighlightedIndex = static_cast<uint8_t>(index); } void setItemSelected(size_t index) { assert(index < std::numeric_limits<uint8_t>::max()); _dropdownSelection |= (1U << static_cast<uint8_t>(index)); } namespace common { enum widx { frame = 0, }; static auto widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 1, 1 }, WindowColour::primary) ); static WindowEventList events; // 0x004CD015 static void onUpdate(Window& self) { self.invalidate(); } static void dropdownFormatArgsToFormatArgs(uint8_t itemIndex, FormatArguments& args) { args.push(*reinterpret_cast<uint32_t*>(&_dropdownItemArgs[itemIndex][0])); args.push(*reinterpret_cast<uint32_t*>(&_dropdownItemArgs[itemIndex][4])); args.push(*reinterpret_cast<uint32_t*>(&_dropdownItemArgs2[itemIndex][0])); args.push(*reinterpret_cast<uint32_t*>(&_dropdownItemArgs2[itemIndex][4])); } // 0x00494BF6 static void sub_494BF6([[maybe_unused]] Window* self, Gfx::DrawingContext& drawingCtx, StringId stringId, int16_t x, int16_t y, int16_t width, AdvancedColour colour, FormatArguments args) { StringManager::formatString(_byte_112CC04, stringId, args); auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(Gfx::Font::medium_bold); tr.clipString(width, _byte_112CC04); tr.setCurrentFont(Gfx::Font::m1); tr.drawString(Point(x, y), colour, _byte_112CC04); } // 0x004CD00E static void draw([[maybe_unused]] Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); _windowDropdownOnpaintCellX = 0; _windowDropdownOnpaintCellY = 0; for (auto itemCount = 0; itemCount < _dropdownItemCount; itemCount++) { if (_dropdownItemFormats[itemCount] != StringIds::empty) { if (itemCount == _dropdownHighlightedIndex) { auto x = _windowDropdownOnpaintCellX * _dropdownItemWidth + self.x + 2; auto y = _windowDropdownOnpaintCellY * _dropdownItemHeight + self.y + 2; drawingCtx.drawRect(x, y, _dropdownItemWidth, _dropdownItemHeight, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); } auto args = FormatArguments(); dropdownFormatArgsToFormatArgs(itemCount, args); auto dropdownItemFormat = _dropdownItemFormats[itemCount]; if (dropdownItemFormat != (StringId)-2) { if (dropdownItemFormat != StringIds::null) { if (itemCount < 32) { if (_dropdownSelection & (1 << itemCount)) { dropdownItemFormat++; } } auto colour = self.getColour(WindowColour::primary).opaque(); if (itemCount == _dropdownHighlightedIndex) { colour = Colour::white; } if ((_dropdownDisabledItems & (1 << itemCount))) { if (itemCount < 32) { colour = self.getColour(WindowColour::primary).opaque().inset(); } } auto x = _windowDropdownOnpaintCellX * _dropdownItemWidth + self.x + 2; auto y = _windowDropdownOnpaintCellY * _dropdownItemHeight + self.y + 1; auto width = self.width - 5; sub_494BF6(&self, drawingCtx, dropdownItemFormat, x, y, width, colour, args); } } if (dropdownItemFormat == (StringId)-2 || dropdownItemFormat == StringIds::null) { auto x = _windowDropdownOnpaintCellX * _dropdownItemWidth + self.x + 2; auto y = _windowDropdownOnpaintCellY * _dropdownItemHeight + self.y + 2; auto imageId = *(uint32_t*)&args; if (dropdownItemFormat == (StringId)-2 && itemCount == _dropdownHighlightedIndex) { imageId++; } drawingCtx.drawImage(x, y, imageId); } } else { auto x = _windowDropdownOnpaintCellX * _dropdownItemWidth + self.x + 2; auto y = _windowDropdownOnpaintCellY * _dropdownItemHeight + self.y + 1 + _dropdownItemHeight / 2; if (!self.getColour(WindowColour::primary).isTranslucent()) { drawingCtx.drawRect(x, y, _dropdownItemWidth - 1, 1, Colours::getShade(self.getColour(WindowColour::primary).c(), 3), Gfx::RectFlags::none); drawingCtx.drawRect(x, y + 1, _dropdownItemWidth - 1, 1, Colours::getShade(self.getColour(WindowColour::primary).c(), 7), Gfx::RectFlags::none); } else { uint32_t colour = enumValue(Colours::getTranslucent(self.getColour(WindowColour::primary).c())); colour++; // Gets ExtColour::translucentXXX2 highlight drawingCtx.drawRect(x, y, _dropdownItemWidth - 1, 1, colour, Gfx::RectFlags::transparent); colour++; // Gets ExtColour::translucentXXX0 shadow drawingCtx.drawRect(x, y + 1, _dropdownItemWidth - 1, 1, colour, Gfx::RectFlags::transparent); } } _windowDropdownOnpaintCellX++; if (_windowDropdownOnpaintCellX >= _dropdownColumnCount) { _windowDropdownOnpaintCellX = 0; _windowDropdownOnpaintCellY++; } } } static void initEvents() { events.onUpdate = onUpdate; events.draw = draw; } // 0x004CCF1E static void open(Ui::Point32 origin, Ui::Size32 size, AdvancedColour colour) { auto window = WindowManager::createWindow(WindowType::dropdown, origin, size, WindowFlags::stickToFront, common::events); window->setWidgets(common::widgets); if (colour.isTranslucent()) { window->flags |= WindowFlags::transparent; } common::initEvents(); window->widgets[0].windowColour = WindowColour::primary; window->setColour(WindowColour::primary, colour); _dropdownHighlightedIndex = -1; _dropdownDisabledItems = 0; _dropdownSelection = 0; Input::state(Input::State::dropdownActive); } // 0x004CC807 based on static void setColourAndInputFlags(AdvancedColour& colour, uint8_t& flags) { if (colour.isTranslucent()) { colour = kDropdownColourTable[enumValue(colour.c())]; colour = colour.translucent(); } Input::resetFlag(Input::Flags::flag1); Input::resetFlag(Input::Flags::flag2); if (flags & (1 << 7)) { Input::setFlag(Input::Flags::flag1); } flags &= ~(1 << 7); } // 0x004CCAB2 static void showText(int16_t x, int16_t y, int16_t width, int16_t height, uint8_t itemHeight, AdvancedColour colour, size_t count, uint8_t flags) { _dropdownColumnCount = 1; _dropdownItemWidth = 0; _dropdownItemHeight = 10; if (flags & (1 << 6)) { _dropdownItemHeight = itemHeight; } flags &= ~(1 << 6); uint16_t maxStringWidth = 0; for (uint8_t itemCount = 0; itemCount < count; itemCount++) { auto args = FormatArguments(); dropdownFormatArgsToFormatArgs(itemCount, args); StringManager::formatString(_byte_112CC04, _dropdownItemFormats[itemCount], args); auto stringWidth = Gfx::TextRenderer::getMaxStringWidth(Gfx::Font::medium_bold, _byte_112CC04); maxStringWidth = std::max(maxStringWidth, stringWidth); } maxStringWidth += 3; _dropdownItemWidth = maxStringWidth; _dropdownItemCount = static_cast<uint16_t>(count); _dropdownRowCount = static_cast<uint32_t>(count); uint16_t dropdownHeight = _dropdownItemHeight * static_cast<uint16_t>(count) + 3; widgets[0].bottom = dropdownHeight; dropdownHeight++; Ui::Size32 size = { static_cast<int32_t>(_dropdownItemWidth), dropdownHeight }; Ui::Point32 origin = { x, y }; origin.y += height; if ((size.height + origin.y) > Ui::height() || origin.y < 0) { origin.y -= (height + size.height); auto dropdownBottom = origin.y; if (origin.y >= 0) { dropdownBottom = origin.y + size.height; } if (origin.y < 0 || dropdownBottom > Ui::height()) { origin.x += width; origin.x += maxStringWidth; if (origin.x > Ui::width()) { origin.x = x; origin.x -= (maxStringWidth + 4); } origin.y = 0; } } size.width = maxStringWidth + 3; widgets[0].right = size.width; size.width++; if (origin.x < 0) { origin.x = 0; } origin.x += size.width; if (origin.x > Ui::width()) { origin.x = Ui::width(); } origin.x -= size.width; open(origin, size, colour); } } /** * 0x004CC807 * * @param x * @param y * @param width * @param height * @param colour * @param count * @param itemHeight * @param flags * Custom Dropdown height if flags & (1<<6) is true */ void show(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t itemHeight, uint8_t flags) { assert(count < std::numeric_limits<uint8_t>::max()); common::setColourAndInputFlags(colour, flags); WindowManager::close(WindowType::dropdown, 0); _dropdownFlags = Flags::none; _dropdownColumnCount = 1; _dropdownItemWidth = 0; _dropdownItemWidth = width; _dropdownItemHeight = 10; if (flags & (1 << 6)) { _dropdownItemHeight = itemHeight; } flags &= ~(1 << 6); _dropdownItemCount = static_cast<uint16_t>(count); _dropdownRowCount = 0; _dropdownRowCount = count; int16_t dropdownHeight = (static_cast<int16_t>(count) * _dropdownItemHeight) + 3; common::widgets[0].bottom = dropdownHeight; dropdownHeight++; Ui::Size32 size = { width, height }; Ui::Point32 origin = { x, y }; origin.y += height; size.height = dropdownHeight; if ((size.height + origin.y) > Ui::height() || origin.y < 0) { origin.y -= (height + dropdownHeight); auto dropdownBottom = origin.y; if (origin.y >= 0) { dropdownBottom = origin.y + dropdownHeight; } if (origin.y < 0 || dropdownBottom > Ui::height()) { origin.x += width + 3; origin.y = 0; } } size.width = width + 3; common::widgets[0].right = size.width; size.width++; if (origin.x < 0) { origin.x = 0; } origin.x += size.width; if (origin.x > Ui::width()) { origin.x = Ui::width(); } origin.x -= size.width; common::open(origin, size, colour); for (auto i = 0; i < _dropdownItemCount; i++) { _dropdownItemFormats[i] = StringIds::empty; } } /** * 0x004CC807 * * @param x * @param y * @param width * @param height * @param colour * @param count * @param flags */ void show(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t flags) { show(x, y, width, height, colour, count, 0, flags & ~(1 << 6)); } /** * 0x004CCDE7 * * @param x * @param y * @param width * @param height * @param heightOffset * @param colour * @param columnCount * @param count * @param flags */ void showImage(int16_t x, int16_t y, int16_t width, int16_t height, int16_t heightOffset, AdvancedColour colour, uint8_t columnCount, uint8_t count, uint8_t flags) { assert(count < std::numeric_limits<uint8_t>::max()); assert(count < std::size(kAppropriateImageDropdownItemsPerRow)); common::setColourAndInputFlags(colour, flags); WindowManager::close(WindowType::dropdown, 0); _dropdownFlags = Flags::none; WindowManager::close(WindowType::dropdown, 0); _dropdownFlags = Flags::none; _dropdownItemHeight = height; _dropdownItemWidth = width; _dropdownItemCount = count; _dropdownColumnCount = columnCount; _dropdownRowCount = _dropdownItemCount / _dropdownColumnCount + ((_dropdownItemCount % _dropdownColumnCount) ? 1 : 0); uint16_t dropdownWidth = _dropdownItemWidth * _dropdownColumnCount + 3; common::widgets[0].right = dropdownWidth; uint16_t dropdownHeight = _dropdownItemHeight * _dropdownRowCount + 3; common::widgets[0].bottom = dropdownHeight; dropdownHeight++; Ui::Size32 size = { dropdownWidth, dropdownHeight }; Ui::Point32 origin = { x, y }; origin.y += heightOffset; size.height = dropdownHeight; if ((size.height + origin.y) > Ui::height() || origin.y < 0) { origin.y -= (heightOffset + dropdownHeight); auto dropdownBottom = origin.y; if (origin.y >= 0) { dropdownBottom = origin.y + dropdownHeight; } if (origin.y < 0 || dropdownBottom > Ui::height()) { origin.x += common::widgets[0].right; origin.y = 0; } } size.width = common::widgets[0].right + 1; if (origin.x < 0) { origin.x = 0; } origin.x += size.width; if (origin.x > Ui::width()) { origin.x = Ui::width(); } origin.x -= size.width; common::open(origin, size, colour); for (auto i = 0; i < _dropdownItemCount; i++) { _dropdownItemFormats[i] = StringIds::empty; } } // 0x004CC989 void showBelow(Window* window, WidgetIndex_t widgetIndex, size_t count, int8_t itemHeight, uint8_t flags) { assert(count < std::numeric_limits<uint8_t>::max()); WindowManager::close(WindowType::dropdown, 0); _dropdownFlags = Flags::none; if (Input::state() != Input::State::widgetPressed || Input::hasFlag(Input::Flags::widgetPressed)) { _dropdownFlags = _dropdownFlags | Flags::unk1; } if (Input::getPressedWindowType() != WindowType::undefined) { WindowManager::invalidateWidget(Input::getPressedWindowType(), Input::getPressedWindowNumber(), Input::getPressedWidgetIndex()); } Input::setPressedWidgetIndex(widgetIndex); Input::setPressedWindowType(window->type); Input::setPressedWindowNumber(window->number); WindowManager::invalidateWidget(window->type, window->number, widgetIndex); auto widget = window->widgets[widgetIndex]; auto colour = window->getColour(widget.windowColour).translucent(); auto x = widget.left + window->x; auto y = widget.top + window->y; if (colour.isTranslucent()) { colour = kDropdownColourTable[enumValue(colour.c())]; colour = colour.translucent(); } Input::resetFlag(Input::Flags::flag1); Input::resetFlag(Input::Flags::flag2); if (flags & (1 << 7)) { Input::setFlag(Input::Flags::flag1); } flags &= ~(1 << 7); common::showText(x, y, widget.width(), widget.height(), itemHeight, colour, count, flags); } // 0x004CC989 void showBelow(Window* window, WidgetIndex_t widgetIndex, size_t count, uint8_t flags) { showBelow(window, widgetIndex, count, 0, flags & ~(1 << 6)); } /** * 0x004CCA6D * x @<cx> * y @<dx> * width @<bp> * height @<di> * colour @<al> * itemHeight @ <ah> * count @<bl> * flags @<bh> * Custom Dropdown height if flags & (1<<6) is true */ void showText(int16_t x, int16_t y, int16_t width, int16_t height, uint8_t itemHeight, AdvancedColour colour, size_t count, uint8_t flags) { assert(count < std::numeric_limits<uint8_t>::max()); common::setColourAndInputFlags(colour, flags); WindowManager::close(WindowType::dropdown, 0); _dropdownFlags = Flags::none; common::showText(x, y, width, height, itemHeight, colour, count, flags); } // 0x004CCA6D void showText(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t flags) { showText(x, y, width, height, 0, colour, count, flags & ~(1 << 6)); } /** * 0x004CCC7C * x @<cx> * y @<dx> * width @<bp> * height @<di> * colour @<al> * count @<bl> * flags @<bh> */ void showText2(int16_t x, int16_t y, int16_t width, int16_t height, uint8_t itemHeight, AdvancedColour colour, size_t count, uint8_t flags) { assert(count < std::numeric_limits<uint8_t>::max()); common::setColourAndInputFlags(colour, flags); WindowManager::close(WindowType::dropdown, 0); _dropdownFlags = Flags::none; _dropdownColumnCount = 1; _dropdownItemWidth = width; _dropdownItemHeight = 10; if (flags & (1 << 6)) { _dropdownItemHeight = itemHeight; } flags &= ~(1 << 6); _dropdownItemCount = static_cast<uint16_t>(count); _dropdownRowCount = static_cast<uint32_t>(count); uint16_t dropdownHeight = static_cast<uint16_t>(count) * _dropdownItemHeight + 3; common::widgets[0].bottom = dropdownHeight; dropdownHeight++; Ui::Size32 size = { static_cast<uint16_t>(width), static_cast<uint16_t>(height) }; Ui::Point32 origin = { x, y }; origin.y += height; size.height = dropdownHeight; if ((size.height + origin.y) > Ui::height() || origin.y < 0) { origin.y -= (height + dropdownHeight); auto dropdownBottom = origin.y; if (origin.y >= 0) { dropdownBottom = origin.y + dropdownHeight; } if (origin.y < 0 || dropdownBottom > Ui::height()) { origin.x += width + 3; origin.y = 0; } } size.width = width + 3; common::widgets[0].right = size.width; size.width++; if (origin.x < 0) { origin.x = 0; } origin.x += size.width; if (origin.x > Ui::width()) { origin.x = Ui::width(); } origin.x -= size.width; common::open(origin, size, colour); } void showText2(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t flags) { showText2(x, y, width, height, 0, colour, count, flags & ~(1 << 6)); } /** * 0x004CCF8C * window @ <esi> * widget @ <edi> * availableColours @<ebp> * dropdownColour @<al> * selectedColour @<ah> */ void showColour(const Window* window, const Widget* widget, uint32_t availableColours, Colour selectedColour, AdvancedColour dropdownColour) { uint8_t count = 0; for (uint8_t i = 0; i < 32; i++) { if (availableColours & (1 << i)) { count++; } } const uint8_t columnCount = getItemsPerRow(count); const uint8_t flags = 0x80; const uint8_t itemWidth = 16; const uint8_t itemHeight = 16; const int16_t x = window->x + widget->left; const int16_t y = window->y + widget->top; const int16_t heightOffset = widget->height() + 1; showImage(x, y, itemWidth, itemHeight, heightOffset, dropdownColour, columnCount, count, flags); uint8_t currentIndex = 0; for (uint8_t i = 0; i < 32; i++) { if (!(availableColours & (1 << i))) { continue; } const auto colour = static_cast<Colour>(i); if (colour == selectedColour) { Dropdown::setHighlightedItem(currentIndex); } auto args = FormatArguments(); args.push(Gfx::recolour(ImageIds::colour_swatch_recolourable_raised, colour)); args.push<uint16_t>(i); Dropdown::add(currentIndex, 0xFFFE, args); currentIndex++; } } // 0x004CF3CC void forceCloseCompanySelect() { if (hasFlags(Flags::unk1)) { WindowManager::close(WindowType::dropdown); } } // 0x004CF2B3 void populateCompanySelect(Window* window, Widget* widget) { std::array<bool, 16> companyOrdered = {}; CompanyId companyId = CompanyId::null; size_t index = 0; for (; index < Limits::kMaxCompanies; index++) { int16_t maxPerformanceIndex = -1; for (const auto& company : CompanyManager::companies()) { if (companyOrdered[enumValue(company.id())] & 1) { continue; } if (maxPerformanceIndex < company.performanceIndex) { maxPerformanceIndex = company.performanceIndex; companyId = company.id(); } } if (maxPerformanceIndex == -1) { break; } companyOrdered[enumValue(companyId)] |= 1; _dropdownItemFormats[index] = StringIds::dropdown_company_select; _menuOptions[index] = enumValue(companyId); auto company = CompanyManager::get(companyId); auto competitorObj = ObjectManager::get<CompetitorObject>(company->competitorId); auto ownerEmotion = company->ownerEmotion; auto imageId = competitorObj->images[enumValue(ownerEmotion)]; imageId = Gfx::recolour(imageId, company->mainColours.primary); add(index, StringIds::dropdown_company_select, { imageId, company->name }); } auto x = widget->left + window->x; auto y = widget->top + window->y; auto colour = window->getColour(widget->windowColour).translucent(); showText(x, y, widget->width(), widget->height(), 25, colour, index, (1 << 6)); size_t highlightedIndex = 0; while (enumValue(window->owner) != _menuOptions[highlightedIndex]) { highlightedIndex++; if (highlightedIndex > Limits::kMaxCompanies) { highlightedIndex = std::numeric_limits<size_t>::max(); break; } } setHighlightedItem(highlightedIndex); _dropdownFlags = _dropdownFlags | Flags::unk2; } // 0x004CF284 CompanyId getCompanyIdFromSelection(int16_t itemIndex) { if (itemIndex == -1) { itemIndex = _dropdownHighlightedIndex; } auto companyId = static_cast<CompanyId>(_menuOptions[itemIndex]); auto company = CompanyManager::get(companyId); if (company->empty()) { companyId = CompanyId::null; } return companyId; } uint16_t getItemArgument(const uint8_t index, const uint8_t argument) { return reinterpret_cast<uint16_t*>(_dropdownItemArgs[index])[argument]; } uint16_t getItemsPerRow(uint8_t itemCount) { return kAppropriateImageDropdownItemsPerRow[itemCount]; } Builder& Builder::below(Window& window, WidgetIndex_t widgetIndex) { _window = &window; _widgetIndex = widgetIndex; return *this; } Builder& Builder::item(DropdownItemId id, StringId text) { _items.emplace_back(id, text); return *this; } Builder& Builder::separator() { _items.emplace_back(std::nullopt, StringIds::empty); return *this; } Builder& Builder::highlight(DropdownItemId id) { _highlightedId = id; return *this; } void Builder::show() { if (_window == nullptr) { throw Exception::InvalidArgument("Window and widget index not set"); } _dropdownIds.clear(); size_t index{}; std::optional<size_t> highlightedIndex; for (const auto& item : _items) { auto& id = std::get<0>(item); if (id) { auto& text = std::get<1>(item); Dropdown::add(index, text); if (id == _highlightedId) { highlightedIndex = index; } } else { Dropdown::addSeparator(index); } _dropdownIds.push_back(id); index++; } showBelow(_window, _widgetIndex, _items.size(), 0); if (highlightedIndex) { Dropdown::setHighlightedItem(*highlightedIndex); _dropdownUseDefault = true; } else { _dropdownUseDefault = false; } } Builder create() { return Builder(); } std::optional<DropdownItemId> getSelectedItem(int32_t index) { if (index == -1 && _dropdownUseDefault) { index = Dropdown::getHighlightedItem(); } if (index >= 0 && static_cast<size_t>(index) < _dropdownIds.size()) { return _dropdownIds[index]; } return std::nullopt; } std::optional<int> dropdownIndexFromPoint(Ui::Window* window, int x, int y) { // Check whether x and y are over a list item int left = x - window->x; if (left < 0) { return std::nullopt; } if (left >= window->width) { return std::nullopt; } // 2px of padding on the top of the list? int top = y - window->y - 2; if (top < 0) { return std::nullopt; } unsigned int itemY = top / _dropdownItemHeight; if (itemY >= _dropdownItemCount) { return std::nullopt; } left -= 2; if (left < 0) { return std::nullopt; } unsigned int itemX = left / _dropdownItemWidth; if (itemX >= _dropdownColumnCount) { return std::nullopt; } if (itemY >= _dropdownRowCount) { return std::nullopt; } int item = itemY * _dropdownColumnCount + itemX; if (item >= _dropdownItemCount) { return std::nullopt; } if (item < 32 && (_dropdownDisabledItems & (1ULL << item)) != 0) { return std::nullopt; } if (_dropdownItemFormats[item] == 0) { return std::nullopt; } return item; } bool hasFlags(Flags flags) { return (_dropdownFlags & flags) != Flags::none; } void setMenuOption(size_t index, uint8_t value) { assert(index < std::size(_menuOptions)); _menuOptions[index] = value; } uint8_t getMenuOption(size_t index) { assert(index < std::size(_menuOptions)); return _menuOptions[index]; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Dropdown.h ```h #pragma once #include "Graphics/Colour.h" #include "Localisation/StringManager.h" #include "Window.h" #include "World/Company.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <cstdlib> #include <optional> enum format_arg_type { u16, u32, ptr, }; struct format_arg { format_arg_type type; union { uint16_t u16; uint32_t u32; uintptr_t ptr; }; format_arg(uint16_t value) { type = format_arg_type::u16; u16 = value; } format_arg(uint32_t value) { type = format_arg_type::u32; u32 = value; } format_arg(char* value) { type = format_arg_type::ptr; ptr = (uintptr_t)value; } format_arg(const char* value) { type = format_arg_type::ptr; ptr = (uintptr_t)value; } }; namespace OpenLoco { class FormatArguments; } namespace OpenLoco::Ui::Dropdown { enum class Flags : uint16_t { none = 0, unk1 = 1U << 0, unk2 = 1U << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(Flags); void addSeparator(size_t index); void add(size_t index, StringId title); void add(size_t index, StringId title, std::initializer_list<format_arg> l); void add(size_t index, StringId title, format_arg l); void add(size_t index, StringId title, const FormatArguments& fArgs); int16_t getHighlightedItem(); void setItemDisabled(size_t index); void setHighlightedItem(size_t index); void setItemSelected(size_t index); void show(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t itemHeight, uint8_t flags); void show(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t flags); void showImage(int16_t x, int16_t y, int16_t width, int16_t height, int16_t heightOffset, AdvancedColour colour, uint8_t columnCount, uint8_t count, uint8_t flags = 0); void showBelow(Window* window, WidgetIndex_t widgetIndex, size_t count, uint8_t flags); void showBelow(Window* window, WidgetIndex_t widgetIndex, size_t count, int8_t itemHeight, uint8_t flags); void showText(int16_t x, int16_t y, int16_t width, int16_t height, uint8_t itemHeight, AdvancedColour colour, size_t count, uint8_t flags); void showText(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t flags); void showText2(int16_t x, int16_t y, int16_t width, int16_t height, uint8_t itemHeight, AdvancedColour colour, size_t count, uint8_t flags); void showText2(int16_t x, int16_t y, int16_t width, int16_t height, AdvancedColour colour, size_t count, uint8_t flags); void showColour(const Window* window, const Widget* widget, uint32_t availableColours, Colour selectedColour, AdvancedColour dropdownColour); void forceCloseCompanySelect(); void populateCompanySelect(Window* window, Widget* widget); CompanyId getCompanyIdFromSelection(int16_t itemIndex); uint16_t getItemArgument(const uint8_t index, const uint8_t argument); uint16_t getItemsPerRow(uint8_t itemCount); using DropdownItemId = int32_t; class Builder { private: Window* _window{}; WidgetIndex_t _widgetIndex{}; std::vector<std::tuple<std::optional<DropdownItemId>, StringId>> _items; std::optional<DropdownItemId> _highlightedId; public: Builder& below(Window& window, WidgetIndex_t widgetIndex); Builder& item(DropdownItemId id, StringId text); Builder& separator(); Builder& highlight(DropdownItemId id); void show(); template<typename T> Builder& item(T id, StringId text) { item(static_cast<int32_t>(id), text); return *this; } template<typename T> Builder& highlight(T id) { highlight(static_cast<int32_t>(id)); return *this; } }; Builder create(); std::optional<DropdownItemId> getSelectedItem(int32_t index); template<typename T> std::optional<T> getSelectedItem(int32_t index) { auto result = getSelectedItem(index); if (result) { return static_cast<T>(*result); } return std::nullopt; } std::optional<int> dropdownIndexFromPoint(Ui::Window* window, int x, int y); bool hasFlags(Flags flags); void setMenuOption(size_t index, uint8_t value); uint8_t getMenuOption(size_t index); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/LastMapWindowAttributes.cpp ```cpp #include "Ui/LastMapWindowAttributes.h" #include "GameState.h" namespace OpenLoco::Ui { LastMapWindowAttributes& getLastMapWindowAttributes() { return getGameState().lastMapWindowAttributes; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/LastMapWindowAttributes.h ```h #pragma once #include "Window.h" #include <cstdint> namespace OpenLoco::Ui { #pragma pack(push, 1) struct LastMapWindowAttributes { Ui::WindowFlags flags; // 0x00526284 Ui::Size size; // 0x00526288 uint16_t var88A; // 0x0052628C uint16_t var88C; // 0x0052628E }; #pragma pack(pop) static_assert(sizeof(LastMapWindowAttributes) == 0x0C); LastMapWindowAttributes& getLastMapWindowAttributes(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ProgressBar.cpp ```cpp #include "ProgressBar.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringManager.h" #include "SceneManager.h" #include "WindowManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::ProgressBar { static bool _isInternalWindow = false; void begin(std::string_view caption) { _isInternalWindow = true; Windows::ProgressBar::open(caption); } // 0x004CF5C5 void begin(StringId captionStringId) { char _captionBuffer[256] = {}; if (captionStringId != StringIds::null) { auto args = FormatArguments::common(); StringManager::formatString(_captionBuffer, std::size(_captionBuffer), captionStringId, args); } begin(_captionBuffer); } // 0x004CF621 // eax: value void setProgress(int32_t value) { if (_isInternalWindow) { Windows::ProgressBar::setProgress(value); } else { // Used to be the native progress bar assert(false); } } // 0x004CF60B void end() { if (_isInternalWindow) { Windows::ProgressBar::close(); } else { // Used to be the native progress bar assert(false); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ProgressBar.h ```h #pragma once #include "Localisation/StringManager.h" #include <cstdint> #include <string_view> namespace OpenLoco::Ui::ProgressBar { void begin(std::string_view string); void begin(StringId stringId); void setProgress(int32_t value); void end(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Screenshot.cpp ```cpp #include "Screenshot.h" #include "Entities/EntityManager.h" #include "Environment.h" #include "Graphics/Gfx.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/TileManager.h" #include "ScenarioOptions.h" #include "Ui.h" #include "WindowManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Platform/Platform.h> #include <cstdint> #include <fstream> #include <png.h> #include <string> #pragma warning(disable : 4611) // interaction between '_setjmp' and C++ object destruction is non-portable using namespace OpenLoco::Interop; using namespace OpenLoco::Ui; namespace OpenLoco::Ui { static loco_global<int8_t, 0x00508F16> _screenshotCountdown; static ScreenshotType _screenshotType = ScreenshotType::regular; void triggerScreenshotCountdown(int8_t numTicks, ScreenshotType type) { _screenshotCountdown = numTicks; _screenshotType = type; } static std::string saveScreenshot(); static std::string saveGiantScreenshot(); void handleScreenshotCountdown() { if (_screenshotCountdown != 0) { _screenshotCountdown--; if (_screenshotCountdown == 0) { try { std::string fileName; if (_screenshotType == ScreenshotType::giant) { fileName = saveGiantScreenshot(); } else { fileName = saveScreenshot(); } FormatArguments::common(fileName.c_str()); Windows::Error::openQuiet(StringIds::screenshot_saved_as, StringIds::null); } catch (const std::exception&) { Windows::Error::open(StringIds::screenshot_failed); } } } } static void pngWriteData(png_structp png_ptr, png_bytep data, png_size_t length) { auto ostream = static_cast<std::ostream*>(png_get_io_ptr(png_ptr)); ostream->write((const char*)data, length); } static void pngFlush(png_structp png_ptr) { auto ostream = static_cast<std::ostream*>(png_get_io_ptr(png_ptr)); ostream->flush(); } static void saveRenderTargetToPng(const Gfx::RenderTarget& rt, std::fstream& outputStream) { auto rgbaPalette = Gfx::getRgbaPalette(); png_structp pngPtr = nullptr; png_colorp palette = nullptr; try { pngPtr = png_create_write_struct(PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr); if (pngPtr == nullptr) { throw Exception::RuntimeError("png_create_write_struct failed."); } png_set_write_fn(pngPtr, &outputStream, pngWriteData, pngFlush); // Set error handler if (setjmp(png_jmpbuf(pngPtr))) { throw Exception::RuntimeError("PNG ERROR"); } auto infoPtr = png_create_info_struct(pngPtr); if (infoPtr == nullptr) { throw Exception::RuntimeError("png_create_info_struct failed."); } palette = (png_colorp)png_malloc(pngPtr, 246 * sizeof(png_color)); if (palette == nullptr) { throw Exception::RuntimeError("png_malloc failed."); } for (size_t i = 0; i < 246; i++) { palette[i].blue = rgbaPalette[i].b; palette[i].green = rgbaPalette[i].g; palette[i].red = rgbaPalette[i].r; } png_set_PLTE(pngPtr, infoPtr, palette, 246); png_byte transparentIndex = 0; png_set_tRNS(pngPtr, infoPtr, &transparentIndex, 1, nullptr); png_set_IHDR(pngPtr, infoPtr, rt.width, rt.height, 8, PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT); png_write_info(pngPtr, infoPtr); uint8_t* data = rt.bits; for (int y = 0; y < rt.height; y++) { png_write_row(pngPtr, data); data += rt.pitch + rt.width; } png_write_end(pngPtr, nullptr); png_destroy_info_struct(pngPtr, &infoPtr); png_free(pngPtr, palette); png_destroy_write_struct(&pngPtr, nullptr); } catch (const std::exception&) { png_free(pngPtr, palette); png_destroy_write_struct(&pngPtr, nullptr); throw; } } // 0x00452667 static std::string prepareSaveScreenshot(const Gfx::RenderTarget& rt) { auto screenshotsFolderPath = Environment::getPathNoWarning(Environment::PathId::screenshots); Environment::autoCreateDirectory(screenshotsFolderPath); std::string scenarioName = Scenario::getOptions().scenarioName; if (scenarioName.length() == 0) { scenarioName = StringManager::getString(StringIds::screenshot_filename_template); } std::string fileName = std::string(scenarioName) + ".png"; fs::path path; int16_t suffix; for (suffix = 1; suffix < std::numeric_limits<int16_t>().max(); suffix++) { if (!fs::exists(screenshotsFolderPath / fileName)) { path = screenshotsFolderPath / fileName; break; } fileName = std::string(scenarioName) + " (" + std::to_string(suffix) + ").png"; } if (path.empty()) { throw Exception::RuntimeError("Failed finding filename"); } std::fstream outputStream(path.c_str(), std::ios::out | std::ios::binary); saveRenderTargetToPng(rt, outputStream); return fileName; } static std::string saveScreenshot() { auto& drawingEngine = Gfx::getDrawingEngine(); auto& rt = drawingEngine.getScreenRT(); return prepareSaveScreenshot(rt); } static Ui::Viewport createGiantViewport(const uint16_t resolutionWidth, const uint16_t resolutionHeight, const uint8_t zoomLevel) { Ui::Viewport viewport{}; viewport.width = resolutionWidth; viewport.height = resolutionHeight; viewport.x = 0; viewport.y = 0; viewport.viewWidth = viewport.width << zoomLevel; viewport.viewHeight = viewport.height << zoomLevel; viewport.zoom = zoomLevel; viewport.pad_11 = 0; viewport.flags = ViewportFlags::none; const coord_t centreX = (World::kMapColumns / 2) * 32 + 16; const coord_t centreY = (World::kMapRows / 2) * 32 + 16; const coord_t z = World::TileManager::getHeight({ centreX, centreY }).landHeight; auto pos = viewport.centre2dCoordinates({ centreX, centreY, z }); viewport.viewX = pos.x; viewport.viewY = pos.y; return viewport; } static std::string saveGiantScreenshot() { const auto& main = WindowManager::getMainWindow(); const auto zoomLevel = main->viewports[0]->zoom; const uint16_t resolutionWidth = ((World::kMapColumns * 32 * 2) >> zoomLevel) + 8; const uint16_t resolutionHeight = ((World::kMapRows * 32 * 1) >> zoomLevel) + 128; Ui::Viewport viewport = createGiantViewport(resolutionWidth, resolutionHeight, zoomLevel); // Ensure sprites appear regardless of rotation EntityManager::resetSpatialIndex(); Gfx::RenderTarget rt{}; rt.bits = static_cast<uint8_t*>(malloc(resolutionWidth * resolutionHeight)); if (rt.bits == nullptr) { return {}; } rt.x = 0; rt.y = 0; rt.width = resolutionWidth; rt.height = resolutionHeight; rt.pitch = 0; rt.zoomLevel = 0; auto& drawingEngine = Gfx::getDrawingEngine(); auto& drawingCtx = drawingEngine.getDrawingContext(); drawingCtx.pushRenderTarget(rt); viewport.render(drawingCtx); drawingCtx.popRenderTarget(); auto fileName = prepareSaveScreenshot(rt); free(rt.bits); return fileName; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Screenshot.h ```h #pragma once #include <cstdint> namespace OpenLoco::Ui { enum class ScreenshotType : uint8_t { regular = 0, giant = 1, }; void triggerScreenshotCountdown(int8_t numTicks, ScreenshotType type); void handleScreenshotCountdown(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ScrollFlags.hpp ```hpp #pragma once #include <OpenLoco/Core/EnumFlags.hpp> #include <type_traits> namespace OpenLoco::Ui { enum class ScrollPart : int16_t { none = -1, view = 0, hscrollbarButtonLeft = 1, hscrollbarButtonRight = 2, hscrollbarTrackLeft = 3, hscrollbarTrackRight = 4, hscrollbarThumb = 5, vscrollbarButtonTop = 6, vscrollbarButtonBottom = 7, vscrollbarTrackTop = 8, vscrollbarTrackBottom = 9, vscrollbarThumb = 10, }; namespace Scrollbars { constexpr uint8_t none = 0; constexpr uint8_t horizontal = (1 << 0); constexpr uint8_t vertical = (1 << 1); constexpr uint8_t both = horizontal | vertical; } enum class ScrollFlags : uint16_t { none = 0U, hscrollbarVisible = 1U << 0, hscrollbarThumbPressed = 1U << 1, hscrollbarLeftPressed = 1U << 2, hscrollbarRightPressed = 1U << 3, vscrollbarVisible = 1U << 4, vscrollbarThumbPressed = 1U << 5, vscrollbarUpPressed = 1U << 6, vscrollbarDownPressed = 1U << 7, }; OPENLOCO_ENABLE_ENUM_OPERATORS(ScrollFlags); struct ScrollArea { ScrollFlags flags; // 0x00 int32_t contentOffsetX; // 0x02 int32_t contentWidth; // 0x04 int32_t hThumbLeft; // 0x06 int32_t hThumbRight; // 0x08 int32_t contentOffsetY; // 0x0A int32_t contentHeight; // 0x0C int32_t vThumbTop; // 0x0E int32_t vThumbBottom; // 0x10 constexpr bool hasFlags(ScrollFlags flagsToTest) const { return (flags & flagsToTest) != ScrollFlags::none; } }; }; ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ScrollView.cpp ```cpp #include "ScrollView.h" #include "Input.h" #include "ToolTip.h" #include "Ui.h" #include "Widget.h" #include "WindowManager.h" #include <cmath> namespace OpenLoco::Ui::ScrollView { Ui::ScrollPart _currentScrollArea = ScrollPart::view; // 0x00523396 size_t _currentScrollIndex = 0; // 0x00523398 // 0x004C87E1 // regs.bp: deltaX static void horizontalFollow(Ui::Window& window, Ui::Widget* const widget, const WidgetIndex_t widgetIndex, const size_t scrollIndex, const int16_t deltaX) { ScrollArea& scrollArea = window.scrollAreas[scrollIndex]; scrollArea.flags |= ScrollFlags::hscrollbarThumbPressed; uint16_t trackWidth = widget->width() - (kThumbSize * 2); if (scrollArea.hasFlags(ScrollFlags::vscrollbarVisible)) { trackWidth -= kScrollbarSize; } if (trackWidth == 0) { return; } auto contentDeltaX = deltaX * scrollArea.contentWidth / trackWidth; int16_t newOffset = scrollArea.contentOffsetX + contentDeltaX; int frameWidth = widget->width() - (kScrollbarMargin * 2); if (scrollArea.hasFlags(ScrollFlags::vscrollbarVisible)) { frameWidth -= kScrollbarSize; } int16_t maxOffset = scrollArea.contentWidth - frameWidth; maxOffset = std::max<int16_t>(maxOffset, 0); scrollArea.contentOffsetX = std::clamp<int16_t>(newOffset, 0, maxOffset); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8898 // regs.bp: deltaY static void verticalFollow(Ui::Window& window, Ui::Widget* const widget, const WidgetIndex_t widgetIndex, const size_t scrollIndex, const int16_t deltaY) { ScrollArea& scrollArea = window.scrollAreas[scrollIndex]; scrollArea.flags |= ScrollFlags::vscrollbarThumbPressed; uint16_t trackHeight = widget->height() - (kThumbSize * 2); if (scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { trackHeight -= kScrollbarSize; } if (trackHeight == 0) { return; } auto contentDeltaY = deltaY * scrollArea.contentHeight / trackHeight; int16_t newOffset = scrollArea.contentOffsetY + contentDeltaY; int frameHeight = widget->height() - (kScrollbarMargin * 2); if (scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { frameHeight -= kScrollbarSize; } int16_t maxOffset = scrollArea.contentHeight - frameHeight; maxOffset = std::max<int16_t>(maxOffset, 0); scrollArea.contentOffsetY = std::clamp<int16_t>(newOffset, 0, maxOffset); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8CFD // regs.bp: deltaX void horizontalDragFollow(Ui::Window& window, Ui::Widget* const widget, const WidgetIndex_t dragWidgetIndex, const size_t dragScrollIndex, const int16_t deltaX) { ScrollArea& scrollArea = window.scrollAreas[dragScrollIndex]; if (!scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { return; } uint16_t trackWidth = widget->width() - 2 - kThumbSize - kThumbSize; if (scrollArea.hasFlags(ScrollFlags::vscrollbarVisible)) { trackWidth -= kScrollbarSize; } if (trackWidth == 0) { return; } auto contentDeltaX = deltaX * scrollArea.contentWidth / trackWidth; int16_t newOffset = scrollArea.contentOffsetX + contentDeltaX; int frameWidth = widget->width() - 2; if (scrollArea.hasFlags(ScrollFlags::vscrollbarVisible)) { frameWidth -= kScrollbarSize; } int16_t maxOffset = scrollArea.contentWidth - frameWidth; maxOffset = std::max<int16_t>(maxOffset, 0); scrollArea.contentOffsetX = std::clamp<int16_t>(newOffset, 0, maxOffset); ScrollView::updateThumbs(window, dragWidgetIndex); WindowManager::invalidateWidget(window.type, window.number, dragWidgetIndex); } // 0x004C8E2E // regs.bp: deltaY // possible extraction of common functionality in verticalDragFollow, horizontalDragFollow, verticalFollow, horizontalFollow void verticalDragFollow(Ui::Window& window, Ui::Widget* const widget, const WidgetIndex_t dragWidgetIndex, const size_t dragScrollIndex, const int16_t deltaY) { ScrollArea& scrollArea = window.scrollAreas[dragScrollIndex]; if (!scrollArea.hasFlags(ScrollFlags::vscrollbarVisible)) { return; } uint16_t trackHeight = widget->height() - 2 - kThumbSize - kThumbSize; if (scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { trackHeight -= kScrollbarSize; } if (trackHeight == 0) { return; } auto contentDeltaY = deltaY * scrollArea.contentHeight / trackHeight; int16_t newOffset = scrollArea.contentOffsetY + contentDeltaY; int frameHeight = widget->height() - 2; if (scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { frameHeight -= kScrollbarSize; } int16_t maxOffset = scrollArea.contentHeight - frameHeight; maxOffset = std::max<int16_t>(maxOffset, 0); scrollArea.contentOffsetY = std::clamp<int16_t>(newOffset, 0, maxOffset); ScrollView::updateThumbs(window, dragWidgetIndex); WindowManager::invalidateWidget(window.type, window.number, dragWidgetIndex); } // 0x004C8EF0 // Note: Original function returns a scrollAreaOffset not an index GetPartResult getPart(Ui::Window& window, Ui::Widget* widget, int16_t x, int16_t y) { GetPartResult res{ { x, y }, ScrollPart::none, 0 }; for (auto& widget2 : window.widgets) { if (widget == &widget2) { break; } if (widget2.type == WidgetType::scrollview) { res.index++; } } res.index = std::min<size_t>(res.index, Window::kMaxScrollAreas - 1); const auto& scroll = window.scrollAreas[res.index]; auto right = widget->right + window.x; auto left = widget->left + window.x; auto top = widget->top + window.y; auto bottom = widget->bottom + window.y; const bool needsHScroll = scroll.contentWidth > widget->width(); const bool needsVScroll = scroll.contentHeight > widget->height(); if (needsHScroll && scroll.hasFlags(ScrollFlags::hscrollbarVisible) && y >= (bottom - kScrollbarSize)) { if (x < left + kScrollbarSize) { res.area = ScrollPart::hscrollbarButtonLeft; return res; } // If vertical is also visible then there is a deadzone in the corner if (scroll.hasFlags(ScrollFlags::vscrollbarVisible)) { right -= kScrollbarSize; } // Within deadzone if (x >= right) { res.area = ScrollPart::none; return res; } if (x >= right - kThumbSize) { res.area = ScrollPart::hscrollbarButtonRight; return res; } if (x < scroll.hThumbLeft + left) { res.area = ScrollPart::hscrollbarTrackLeft; return res; } if (x > scroll.hThumbRight + left) { res.area = ScrollPart::hscrollbarTrackRight; return res; } res.area = ScrollPart::hscrollbarThumb; } else if (needsVScroll && scroll.hasFlags(ScrollFlags::vscrollbarVisible) && x >= (right - kScrollbarSize)) { if (y < top + kScrollbarSize) { res.area = ScrollPart::vscrollbarButtonTop; return res; } // If horizontal is also visible then there is a deadzone in the corner if (scroll.hasFlags(ScrollFlags::hscrollbarVisible)) { bottom -= kScrollbarSize; } // Within deadzone if (y >= bottom) { res.area = ScrollPart::none; return res; } if (y >= bottom - kThumbSize) { res.area = ScrollPart::vscrollbarButtonBottom; return res; } if (y < scroll.vThumbTop + top) { res.area = ScrollPart::vscrollbarTrackTop; return res; } if (y > scroll.vThumbBottom + top) { res.area = ScrollPart::vscrollbarTrackBottom; return res; } res.area = ScrollPart::vscrollbarThumb; } else { res.scrollviewLoc.x -= left + 1; res.scrollviewLoc.y -= top + 1; if (res.scrollviewLoc.x < 0 || res.scrollviewLoc.y < 0) { res.area = ScrollPart::none; return res; } res.scrollviewLoc.x += scroll.contentOffsetX; res.scrollviewLoc.y += scroll.contentOffsetY; res.area = ScrollPart::view; } return res; } static std::pair<uint16_t, uint16_t> calculateThumbSizeAndPosition(bool otherBarIsVisible, uint16_t widgetSize, uint16_t buttonSize, int32_t contentSize, int32_t contentOffset) { uint16_t scrollbarSize = widgetSize - (buttonSize * 2); if (otherBarIsVisible) { widgetSize -= kScrollbarSize; scrollbarSize -= kScrollbarSize; } // Thumb size uint16_t scrollThumbSize = std::max<uint16_t>(scrollbarSize * widgetSize / (float)contentSize, kMinThumbSize); // Thumb position auto scrollableDistance = scrollbarSize - scrollThumbSize; uint16_t thumbPosition = scrollableDistance * (contentOffset / (float)(contentSize - widgetSize)); auto scrollThumbStart = buttonSize + thumbPosition; auto scrollThumbEnd =