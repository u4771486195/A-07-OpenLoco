std::min(buttonSize + thumbPosition + scrollThumbSize, widgetSize - buttonSize - 1); return std::make_pair(scrollThumbStart, scrollThumbEnd); } // 0x004CA1ED void updateThumbs(Window& window, WidgetIndex_t widgetIndex) { const auto& widget = window.widgets[widgetIndex]; auto& scrollArea = window.scrollAreas[window.getScrollDataIndex(widgetIndex)]; // Horizontal scrollbar if (scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { std::tie(scrollArea.hThumbLeft, scrollArea.hThumbRight) = calculateThumbSizeAndPosition(scrollArea.hasFlags(ScrollFlags::vscrollbarVisible), widget.width(), kScrollButtonSize.width, scrollArea.contentWidth, scrollArea.contentOffsetX); } // Vertical scrollbar if (scrollArea.hasFlags(ScrollFlags::vscrollbarVisible)) { std::tie(scrollArea.vThumbTop, scrollArea.vThumbBottom) = calculateThumbSizeAndPosition(scrollArea.hasFlags(ScrollFlags::hscrollbarVisible), widget.height(), kScrollButtonSize.height, scrollArea.contentHeight, scrollArea.contentOffsetY); } } // 0x004C894F static void hButtonLeft(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { window.scrollAreas[scrollAreaIndex].flags |= ScrollFlags::hscrollbarLeftPressed; window.scrollAreas[scrollAreaIndex].contentOffsetX = std::max(window.scrollAreas[scrollAreaIndex].contentOffsetX - kButtonClickStep, 0); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C89AE static void hButtonRight(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { window.scrollAreas[scrollAreaIndex].flags |= ScrollFlags::hscrollbarRightPressed; int16_t trackWidth = window.widgets[widgetIndex].width() - 2; if (window.scrollAreas[scrollAreaIndex].hasFlags(ScrollFlags::vscrollbarVisible)) { trackWidth -= kScrollbarSize; } int16_t widgetContentWidth = std::max(window.scrollAreas[scrollAreaIndex].contentWidth - trackWidth, 0); window.scrollAreas[scrollAreaIndex].contentOffsetX = std::min<int16_t>(window.scrollAreas[scrollAreaIndex].contentOffsetX + kButtonClickStep, widgetContentWidth); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8A36 static void hTrackLeft(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { int16_t trackWidth = window.widgets[widgetIndex].width() - 2; if (window.scrollAreas[scrollAreaIndex].hasFlags(ScrollFlags::vscrollbarVisible)) { trackWidth -= kScrollbarSize; } window.scrollAreas[scrollAreaIndex].contentOffsetX = std::max(window.scrollAreas[scrollAreaIndex].contentOffsetX - trackWidth, 0); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8AA6 static void hTrackRight(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { int16_t trackWidth = window.widgets[widgetIndex].width() - 2; if (window.scrollAreas[scrollAreaIndex].hasFlags(ScrollFlags::vscrollbarVisible)) { trackWidth -= kScrollbarSize; } int16_t widgetContentWidth = std::max(window.scrollAreas[scrollAreaIndex].contentWidth - trackWidth, 0); window.scrollAreas[scrollAreaIndex].contentOffsetX = std::min<int16_t>(window.scrollAreas[scrollAreaIndex].contentOffsetX + trackWidth, widgetContentWidth); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } void verticalNudgeUp(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { window.scrollAreas[scrollAreaIndex].contentOffsetY = std::max(window.scrollAreas[scrollAreaIndex].contentOffsetY - kButtonClickStep, 0); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8B26 static void vButtonTop(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { window.scrollAreas[scrollAreaIndex].flags |= ScrollFlags::vscrollbarUpPressed; verticalNudgeUp(window, scrollAreaIndex, widgetIndex); } void verticalNudgeDown(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { int16_t trackHeight = window.widgets[widgetIndex].height() - 2; if (window.scrollAreas[scrollAreaIndex].hasFlags(ScrollFlags::hscrollbarVisible)) { trackHeight -= kScrollbarSize; } int16_t widgetContentHeight = std::max(window.scrollAreas[scrollAreaIndex].contentHeight - trackHeight, 0); window.scrollAreas[scrollAreaIndex].contentOffsetY = std::min<int16_t>(window.scrollAreas[scrollAreaIndex].contentOffsetY + kButtonClickStep, widgetContentHeight); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8B85 static void vButtonBottom(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { window.scrollAreas[scrollAreaIndex].flags |= ScrollFlags::vscrollbarDownPressed; verticalNudgeDown(window, scrollAreaIndex, widgetIndex); } // 0x004C8C0D static void vTrackTop(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { int16_t trackHeight = window.widgets[widgetIndex].height() - 2; if (window.scrollAreas[scrollAreaIndex].hasFlags(ScrollFlags::hscrollbarVisible)) { trackHeight -= kScrollbarSize; } window.scrollAreas[scrollAreaIndex].contentOffsetY = std::max(window.scrollAreas[scrollAreaIndex].contentOffsetY - trackHeight, 0); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8C7D static void vTrackBottom(Ui::Window& window, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex) { int16_t trackHeight = window.widgets[widgetIndex].height() - 2; if (window.scrollAreas[scrollAreaIndex].hasFlags(ScrollFlags::hscrollbarVisible)) { trackHeight -= kScrollbarSize; } int16_t widgetContentHeight = std::max(window.scrollAreas[scrollAreaIndex].contentHeight - trackHeight, 0); window.scrollAreas[scrollAreaIndex].contentOffsetY = std::min<int16_t>(window.scrollAreas[scrollAreaIndex].contentOffsetY + trackHeight, widgetContentHeight); ScrollView::updateThumbs(window, widgetIndex); WindowManager::invalidateWidget(window.type, window.number, widgetIndex); } // 0x004C8689 void scrollLeftBegin(const int16_t x, const int16_t y, Ui::Window& window, Ui::Widget* const widget, const WidgetIndex_t widgetIndex) { auto res = getPart(window, widget, x, y); _currentScrollArea = res.area; _currentScrollIndex = res.index; // Not implemented for any window // window->call_22() switch (res.area) { case Ui::ScrollPart::view: window.callScrollMouseDown(res.scrollviewLoc.x, res.scrollviewLoc.y, static_cast<uint8_t>(res.index)); break; case Ui::ScrollPart::hscrollbarButtonLeft: hButtonLeft(window, res.index, widgetIndex); break; case Ui::ScrollPart::hscrollbarButtonRight: hButtonRight(window, res.index, widgetIndex); break; case Ui::ScrollPart::hscrollbarTrackLeft: hTrackLeft(window, res.index, widgetIndex); break; case Ui::ScrollPart::hscrollbarTrackRight: hTrackRight(window, res.index, widgetIndex); break; case Ui::ScrollPart::vscrollbarButtonTop: vButtonTop(window, res.index, widgetIndex); break; case Ui::ScrollPart::vscrollbarButtonBottom: vButtonBottom(window, res.index, widgetIndex); break; case Ui::ScrollPart::vscrollbarTrackTop: vTrackTop(window, res.index, widgetIndex); break; case Ui::ScrollPart::vscrollbarTrackBottom: vTrackBottom(window, res.index, widgetIndex); break; default: break; } } // Based on 0x004C8689 void scrollModalRight(const int16_t x, const int16_t y, Ui::Window& window, Ui::Widget* const widget, [[maybe_unused]] const WidgetIndex_t widgetIndex) { auto res = getPart(window, widget, x, y); _currentScrollArea = res.area; _currentScrollIndex = res.index; if (res.area == Ui::ScrollPart::view) { window.callScrollMouseDown(res.scrollviewLoc.x, res.scrollviewLoc.y, static_cast<uint8_t>(res.index)); } } // 0x004C72ED void clearPressedButtons(const WindowType type, const WindowNumber_t number, const WidgetIndex_t widgetIndex) { auto window = WindowManager::find(type, number); if (window == nullptr) { return; } constexpr ScrollFlags horizontalFlags = ScrollFlags::hscrollbarThumbPressed | ScrollFlags::hscrollbarLeftPressed | ScrollFlags::hscrollbarRightPressed; constexpr ScrollFlags verticalFlags = ScrollFlags::vscrollbarThumbPressed | ScrollFlags::vscrollbarUpPressed | ScrollFlags::vscrollbarDownPressed; window->scrollAreas[_currentScrollIndex].flags &= ~(verticalFlags | horizontalFlags); WindowManager::invalidateWidget(type, number, widgetIndex); } // 0x004C7236 void scrollLeftContinue(const int16_t x, const int16_t y, Ui::Window& window, Ui::Widget* const widget, const WidgetIndex_t widgetIndex) { if (_currentScrollArea == ScrollPart::hscrollbarThumb) { auto toolTipLoc = Ui::ToolTip::getTooltipMouseLocation(); int16_t deltaX = x - toolTipLoc.x; toolTipLoc.x = x; Ui::ToolTip::setTooltipMouseLocation(toolTipLoc); ScrollView::horizontalFollow(window, widget, widgetIndex, _currentScrollIndex, deltaX); } else if (_currentScrollArea == ScrollPart::vscrollbarThumb) { auto toolTipLoc = Ui::ToolTip::getTooltipMouseLocation(); int16_t deltaY = y - toolTipLoc.y; toolTipLoc.y = y; Ui::ToolTip::setTooltipMouseLocation(toolTipLoc); ScrollView::verticalFollow(window, widget, widgetIndex, _currentScrollIndex, deltaY); } else { auto res = getPart(window, widget, x, y); if (res.area != _currentScrollArea) { clearPressedButtons(window.type, window.number, widgetIndex); return; } switch (res.area) { case ScrollPart::view: // 0x004C729A window.callScrollMouseDrag(res.scrollviewLoc.x, res.scrollviewLoc.y, static_cast<uint8_t>(res.index)); break; case ScrollPart::hscrollbarButtonLeft: hButtonLeft(window, res.index, widgetIndex); break; case ScrollPart::hscrollbarButtonRight: hButtonRight(window, res.index, widgetIndex); break; case ScrollPart::hscrollbarTrackLeft: case ScrollPart::hscrollbarTrackRight: break; case ScrollPart::vscrollbarButtonTop: vButtonTop(window, res.index, widgetIndex); break; case ScrollPart::vscrollbarButtonBottom: vButtonBottom(window, res.index, widgetIndex); break; case ScrollPart::vscrollbarTrackTop: case ScrollPart::vscrollbarTrackBottom: break; default: break; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ScrollView.h ```h #pragma once #include "Window.h" namespace OpenLoco::Ui::ScrollView { // For horizontal scrollbars its N wide, for vertical its N tall static constexpr uint8_t kScrollbarSize = 11; static constexpr auto kScrollButtonSize = Ui::Size(kScrollbarSize, kScrollbarSize); static constexpr auto kScrollbarMargin = 1; static constexpr uint8_t kThumbSize = kScrollbarSize - kScrollbarMargin; static constexpr uint8_t kMinThumbSize = kThumbSize * 2; static constexpr uint8_t kButtonClickStep = 3; struct GetPartResult { Ui::Point scrollviewLoc; ScrollPart area; size_t index; }; GetPartResult getPart(Ui::Window& window, Ui::Widget* widget, int16_t x, int16_t y); void updateThumbs(Window& window, WidgetIndex_t widgetIndex); void scrollLeftBegin(const int16_t x, const int16_t y, Ui::Window& w, Ui::Widget* const widget, const WidgetIndex_t widgetIndex); void scrollLeftContinue(const int16_t x, const int16_t y, Ui::Window& w, Ui::Widget* const widget, const WidgetIndex_t widgetIndex); void scrollModalRight(const int16_t x, const int16_t y, Ui::Window& w, Ui::Widget* const widget, const WidgetIndex_t widgetIndex); void clearPressedButtons(const WindowType type, const WindowNumber_t number, const WidgetIndex_t widgetIndex); void horizontalDragFollow(Ui::Window& w, Ui::Widget* const widget, const WidgetIndex_t dragWidgetIndex, const size_t dragScrollIndex, const int16_t deltaX); void verticalDragFollow(Ui::Window& w, Ui::Widget* const widget, const WidgetIndex_t dragWidgetIndex, const size_t dragScrollIndex, const int16_t deltaY); void verticalNudgeUp(Ui::Window& w, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex); void verticalNudgeDown(Ui::Window& w, const size_t scrollAreaIndex, const WidgetIndex_t widgetIndex); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/TextInput.cpp ```cpp #include "Ui/TextInput.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Localisation/StringManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <SDL2/SDL.h> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::TextInput { // Common code from 0x0044685C, 0x004CE910 bool InputSession::handleInput(uint32_t charCode, uint32_t keyCode) { if ((charCode >= SDLK_SPACE && charCode < SDLK_DELETE) || (charCode >= 159 && charCode <= 255)) { if (inputLenLimit > 0 && buffer.length() == inputLenLimit) { // Limit reached but we need to consume this input. return true; } if (cursorPosition == buffer.length()) { buffer.append(1, (char)charCode); } else { buffer.insert(cursorPosition, 1, (char)charCode); } cursorPosition += 1; } else if (charCode == SDLK_BACKSPACE) { if (cursorPosition == 0) { // Cursor is at beginning. No change required, but consume input return true; } buffer.erase(cursorPosition - 1, 1); cursorPosition -= 1; } else if (keyCode == SDLK_DELETE) { if (cursorPosition == buffer.length()) { // Cursor is at end. No change required, but consume input return true; } buffer.erase(cursorPosition, 1); } else if (keyCode == SDLK_HOME) { cursorPosition = 0; } else if (keyCode == SDLK_END) { cursorPosition = buffer.length(); } else if (keyCode == SDLK_LEFT) { if (cursorPosition == 0) { // Cursor is at beginning. No change required, but consume input return true; } cursorPosition -= 1; } else if (keyCode == SDLK_RIGHT) { if (cursorPosition == buffer.length()) { // Cursor is at end. No change required, but consume input return true; } cursorPosition += 1; } cursorFrame = 0; return true; } bool InputSession::needsReoffsetting(int16_t containerWidth) { std::string cursorStr = buffer.substr(0, cursorPosition); const auto font = Gfx::Font::medium_bold; const auto stringWidth = Gfx::TextRenderer::getStringWidth(font, buffer.c_str()); const auto cursorX = Gfx::TextRenderer::getStringWidth(font, cursorStr.c_str()); const int x = xOffset + cursorX; if (x < textboxPadding) { return true; } if (x > containerWidth - textboxPadding) { return true; } if (xOffset + stringWidth < containerWidth - textboxPadding) { return true; } return false; } /** * 0x004CEB67 * * @param containerWidth @<edx> */ void InputSession::calculateTextOffset(int16_t containerWidth) { std::string cursorStr = buffer.substr(0, cursorPosition); const auto font = Gfx::Font::medium_bold; const auto stringWidth = Gfx::TextRenderer::getStringWidth(font, buffer.c_str()); const auto cursorX = Gfx::TextRenderer::getStringWidth(font, cursorStr.c_str()); const auto midX = containerWidth / 2; // Prefer to centre cursor xOffset = -1 * (cursorX - midX); // Make sure that text will always be at the left edge int16_t minOffset = textboxPadding; int16_t maxOffset = textboxPadding; if (stringWidth + textboxPadding * 2 > containerWidth) { // Make sure that the whole textbox is filled up minOffset = -stringWidth + containerWidth - textboxPadding; } xOffset = std::clamp<int16_t>(xOffset, minOffset, maxOffset); } void InputSession::clearInput() { buffer.clear(); cursorPosition = 0; cursorFrame = 0; xOffset = 0; } // 0x004CEBFB void InputSession::sanitizeInput() { buffer.erase( std::remove_if( buffer.begin(), buffer.end(), [](unsigned char chr) { if (chr < ' ') { return true; } else if (chr <= 'z') { return false; } else if (chr == 171) { return false; } else if (chr == 187) { return false; } else if (chr >= 191) { return false; } return true; }), buffer.end()); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/TextInput.h ```h #pragma once #include "Graphics/Gfx.h" #include <cstdint> #include <string> namespace OpenLoco::Ui::TextInput { constexpr int16_t textboxPadding = 4; struct InputSession { std::string buffer; // 0x011369A0 size_t cursorPosition; // 0x01136FA2 int16_t xOffset; // 0x01136FA4 uint8_t cursorFrame; // 0x011370A9 uint32_t inputLenLimit; InputSession() = default; InputSession(const std::string initialString, uint32_t inputSize) { buffer = initialString; cursorPosition = buffer.length(); cursorFrame = 0; xOffset = 0; inputLenLimit = inputSize; }; bool handleInput(uint32_t charCode, uint32_t keyCode); bool needsReoffsetting(int16_t containerWidth); void calculateTextOffset(int16_t containerWidth); void clearInput(); void sanitizeInput(); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ToolManager.cpp ```cpp #include "ToolManager.h" #include "GameState.h" #include "Input.h" #include "Map/MapSelection.h" #include "Ui/ToolManager.h" #include "Ui/WindowManager.h" using namespace OpenLoco::Ui; using namespace OpenLoco::World; namespace OpenLoco::ToolManager { static Ui::WindowNumber_t _toolWindowNumber = 0; // 0x00523390 static Ui::WindowType _toolWindowType = Ui::WindowType::main; // 0x00523392 static Ui::CursorId _toolWindowCursor = Ui::CursorId::pointer; // 0x00523393 static uint16_t _toolWidgetIndex = 0; // 0x00523394 Window* toolGetActiveWindow() { if (!Input::hasFlag(Input::Flags::toolActive)) { return nullptr; } return WindowManager::find(_toolWindowType, _toolWindowNumber); } bool isToolActive(Ui::WindowType type) { if (!Input::hasFlag(Input::Flags::toolActive)) { return false; } return _toolWindowType == type; } bool isToolActive(Ui::WindowType type, Ui::WindowNumber_t number) { if (!isToolActive(type)) { return false; } return _toolWindowNumber == number; } bool isToolActive(Ui::WindowType type, Ui::WindowNumber_t number, int16_t widgetIndex) { if (!isToolActive(type, number)) { return false; } return getToolWidgetIndex() == widgetIndex; } // 0x004CE367 // tool (al) // widgetIndex (dx) // w (esi) bool toolSet(const Ui::Window& w, int16_t widgetIndex, CursorId cursorId) { if (Input::hasFlag(Input::Flags::toolActive)) { if (w.type == _toolWindowType && w.number == _toolWindowNumber && widgetIndex == _toolWidgetIndex) { toolCancel(); return false; } else { toolCancel(); } } Input::setFlag(Input::Flags::toolActive); Input::resetFlag(Input::Flags::flag6); ToolManager::setToolCursor(cursorId); ToolManager::setToolWindowType(w.type); ToolManager::setToolWindowNumber(w.number); ToolManager::setToolWidgetIndex(widgetIndex); return true; } // 0x004CE3D6 void toolCancel() { if (Input::hasFlag(Input::Flags::toolActive)) { Input::resetFlag(Input::Flags::toolActive); World::mapInvalidateSelectionRect(); World::mapInvalidateMapSelectionFreeFormTiles(); resetMapSelectionFlag(MapSelectionFlags::enable | MapSelectionFlags::enableConstruct | MapSelectionFlags::enableConstructionArrow | MapSelectionFlags::unk_03 | MapSelectionFlags::unk_04); if (ToolManager::getToolWidgetIndex() >= 0) { // Invalidate tool widget Ui::WindowManager::invalidateWidget(ToolManager::getToolWindowType(), ToolManager::getToolWindowNumber(), ToolManager::getToolWidgetIndex()); // Abort tool event Window* w = Ui::WindowManager::find(ToolManager::getToolWindowType(), ToolManager::getToolWindowNumber()); if (w != nullptr) { // TODO: Handle widget ids properly for tools. w->callToolAbort(ToolManager::getToolWidgetIndex(), WidgetId::none); } } } } void toolCancel(Ui::WindowType type, Ui::WindowNumber_t number) { if (!isToolActive(type, number)) { return; } toolCancel(); } Ui::WindowNumber_t getToolWindowNumber() { return _toolWindowNumber; } void setToolWindowNumber(Ui::WindowNumber_t toolWindowNumber) { _toolWindowNumber = toolWindowNumber; } Ui::WindowType getToolWindowType() { return _toolWindowType; } void setToolWindowType(Ui::WindowType toolWindowType) { _toolWindowType = toolWindowType; } Ui::CursorId getToolCursor() { return _toolWindowCursor; } void setToolCursor(Ui::CursorId toolWindowCursor) { _toolWindowCursor = toolWindowCursor; } int16_t getToolWidgetIndex() { return _toolWidgetIndex; } void setToolWidgetIndex(uint16_t toolWidgetIndex) { _toolWidgetIndex = toolWidgetIndex; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ToolManager.h ```h #pragma once #include "Types.hpp" #include "Window.h" #include <cstdint> namespace OpenLoco::ToolManager { Ui::Window* toolGetActiveWindow(); bool isToolActive(Ui::WindowType); bool isToolActive(Ui::WindowType, Ui::WindowNumber_t); bool isToolActive(Ui::WindowType, Ui::WindowNumber_t, int16_t); bool toolSet(const Ui::Window& w, int16_t widgetIndex, Ui::CursorId cursorId); void toolCancel(); void toolCancel(Ui::WindowType, Ui::WindowNumber_t); Ui::WindowNumber_t getToolWindowNumber(); void setToolWindowNumber(Ui::WindowNumber_t toolWindowNumber); Ui::WindowType getToolWindowType(); void setToolWindowType(Ui::WindowType toolWindowType); Ui::CursorId getToolCursor(); void setToolCursor(Ui::CursorId toolWindowCursor); int16_t getToolWidgetIndex(); void setToolWidgetIndex(uint16_t toolWidgetIndex); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ToolTip.h ```h #pragma once #include "Ui/Window.h" #include <cstdint> namespace OpenLoco::Ui::ToolTip { void setWindowType(WindowType wndType); WindowType getWindowType(); void setWindowNumber(WindowNumber_t wndNumber); WindowNumber_t getWindowNumber(); void setWidgetIndex(WidgetIndex_t widx); WidgetIndex_t getWidgetIndex(); void setNotShownTicks(uint16_t ticks); uint16_t getNotShownTicks(); StringId getCurrentStringId(); void setCurrentStringId(StringId stringId); bool isTimeTooltip(); Ui::Point getTooltipMouseLocation(); void setTooltipMouseLocation(const Ui::Point& loc); uint16_t getTooltipTimeout(); void setTooltipTimeout(uint16_t tooltipTimeout); void set_52336E(bool value); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ViewportInteraction.cpp ```cpp #include "ViewportInteraction.h" #include "Config.h" #include "Entities/EntityManager.h" #include "GameCommands/Airports/RemoveAirport.h" #include "GameCommands/Buildings/RemoveBuilding.h" #include "GameCommands/Company/RemoveCompanyHeadquarters.h" #include "GameCommands/Docks/RemovePort.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/RemoveRoadMod.h" #include "GameCommands/Road/RemoveRoadStation.h" #include "GameCommands/Terraform/RemoveTree.h" #include "GameCommands/Terraform/RemoveWall.h" #include "GameCommands/Track/RemoveSignal.h" #include "GameCommands/Track/RemoveTrackMod.h" #include "GameCommands/Track/RemoveTrainStation.h" #include "Graphics/RenderTarget.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Map/WallElement.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/TreeObject.h" #include "Objects/WallObject.h" #include "Paint/Paint.h" #include "SceneManager.h" #include "Ui.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "ViewportManager.h" #include "Window.h" #include "WindowManager.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::Ui::ViewportInteraction { InteractionArg::InteractionArg(const Paint::PaintStruct& ps) : pos(ps.mapPos) , object(ps.entity) , type(ps.type) , modId(ps.modId) { } static bool getStationArguments(InteractionArg& interaction); static bool getStationArguments(StationId id); // 0x004CD95A static bool _track(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* track = tileElement->as<TrackElement>(); if (track == nullptr) { return false; } if (!track->hasStationElement()) { return false; } tileElement++; auto* station = tileElement->as<StationElement>(); if (station == nullptr) { return false; } if (station->isAiAllocated()) { return false; } interaction.type = InteractionItem::trainStation; interaction.object = station; return getStationArguments(interaction); } // 0x004CD974 static bool _road(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* road = tileElement->as<RoadElement>(); if (road == nullptr) { return false; } if (!road->hasStationElement()) { return false; } World::StationElement* station = nullptr; World::Tile tile{ World::toTileSpace(interaction.pos), tileElement }; for (auto& t : tile) { station = t.as<StationElement>(); if (station != nullptr) { break; } } if (station == nullptr) { return false; } interaction.object = station; interaction.type = InteractionItem::dock; if (station->isAiAllocated()) { return false; } interaction.type = InteractionItem::roadStation; return getStationArguments(interaction); } // 0x004CD99A static bool getStationArguments(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* station = tileElement->as<StationElement>(); if (station == nullptr) { return false; } if (station->isGhost()) { return false; } interaction.value = enumValue(station->stationId()); interaction.type = InteractionItem::stationLabel; return getStationArguments(station->stationId()); } static loco_global<StationId, 0x00F252A4> _hoveredStationId; // 0x004CD9B0 static bool getStationArguments(const StationId id) { _hoveredStationId = id; auto station = StationManager::get(id); World::setMapSelectionFlags(World::MapSelectionFlags::hoveringOverStation); ViewportManager::invalidate(station); Windows::MapToolTip::setOwner(station->owner); auto args = FormatArguments::mapToolTip(StringIds::stringid_stringid_wcolour3_stringid); args.push(station->name); args.push(station->town); args.push(getTransportIconsFromStationFlags(station->flags)); char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_338)); buffer = station->getStatusString(buffer); buffer = StringManager::formatString(buffer, StringIds::station_accepts); bool seperator = false; // First cargo item does not need a separator for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { auto& stats = station->cargoStats[cargoId]; if (!stats.isAccepted()) { continue; } if (seperator) { buffer = StringManager::formatString(buffer, StringIds::unit_separator); } buffer = StringManager::formatString(buffer, ObjectManager::get<CargoObject>(cargoId)->name); seperator = true; } args.push(StringIds::buffer_338); return true; } // 0x004CD7FB static bool getTownArguments(const TownId id) { auto town = TownManager::get(id); auto args = FormatArguments::mapToolTip(StringIds::wcolour3_stringid_2, town->name); // args + 4 empty args.skip(2); args.push(StringIds::town_size_and_population); args.push(town->getTownSizeString()); args.push(town->population); return true; } // 0x004CD8D5 static bool getIndustryArguments(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* industryTile = tileElement->as<IndustryElement>(); if (industryTile == nullptr) { return false; } if (industryTile->isGhost()) { return false; } interaction.value = enumValue(industryTile->industryId()); auto industry = industryTile->industry(); char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_338)); *buffer = 0; industry->getStatusString(buffer); auto args = FormatArguments::mapToolTip(); if (StringManager::locoStrlen(buffer) != 0) { args.push(StringIds::wcolour3_stringid_2); args.push(industry->name); args.push(industry->town); args.push(StringIds::buffer_338); } else { args.push(industry->name); args.push(industry->town); } return true; } // 0x004CDA7C static bool getVehicleArguments(const InteractionArg& interaction) { auto* entity = reinterpret_cast<EntityBase*>(interaction.object); auto vehicle = entity->asBase<Vehicles::VehicleBase>(); if (vehicle == nullptr) { return false; } auto head = EntityManager::get<Vehicles::VehicleHead>(vehicle->getHead()); if (head == nullptr) { return false; } auto company = CompanyManager::get(head->owner); Windows::MapToolTip::setOwner(head->owner); auto status = head->getStatus(); auto args = FormatArguments::mapToolTip(); if (status.status2 == StringIds::null) { args.push(StringIds::wcolour3_stringid); } else { args.push(StringIds::wcolour3_stringid_stringid); } args.push(CompanyManager::getControllingId() == head->owner ? StringIds::company_vehicle : StringIds::competitor_vehicle); args.push(company->name); // args + 6 is empty args.skip(2); args.push(head->name); args.push(head->ordinalNumber); args.push(status.status1); args.push(status.status1Args); // 32bit args.push(status.status2); args.push(status.status2Args); // 32bit return true; } // 0x004CD84A static bool getHeadquarterArguments(const InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* buildingTile = tileElement->as<BuildingElement>(); if (buildingTile == nullptr) { return false; } if (buildingTile->isGhost()) { return false; } const auto index = buildingTile->sequenceIndex(); const auto firstTile = interaction.pos - World::kOffsets[index]; const World::Pos3 pos = { firstTile.x, firstTile.y, buildingTile->baseZ() }; for (auto& company : CompanyManager::companies()) { if (company.headquartersX != pos.x || company.headquartersY != pos.y || company.headquartersZ != pos.z) { continue; } Windows::MapToolTip::setOwner(company.id()); auto args = FormatArguments::mapToolTip(StringIds::wcolour3_stringid_2, company.name); args.skip(2); args.push(StringIds::headquarters); return true; } return false; } static std::optional<uint32_t> vehicleDistanceFromLocation(const Vehicles::VehicleBase& component, const viewport_pos& targetPosition) { ViewportRect rect = { component.spriteLeft, component.spriteTop, component.spriteBottom, component.spriteRight }; if (rect.contains(targetPosition)) { uint32_t xDiff = std::abs(targetPosition.x - (component.spriteRight + component.spriteLeft) / 2); uint32_t yDiff = std::abs(targetPosition.y - (component.spriteTop + component.spriteBottom) / 2); return xDiff + yDiff; } return {}; } static void checkAndSetNearestVehicle(uint32_t& nearestDistance, Vehicles::VehicleBase*& nearestVehicle, Vehicles::VehicleBase& checkVehicle, const viewport_pos& targetPosition) { if (checkVehicle.spriteLeft != Location::null) { auto distanceRes = vehicleDistanceFromLocation(checkVehicle, targetPosition); if (distanceRes) { if (*distanceRes < nearestDistance) { nearestDistance = *distanceRes; nearestVehicle = &checkVehicle; } } } } // 0x004CD658 InteractionArg getItemLeft(int16_t tempX, int16_t tempY) { if (SceneManager::isTitleMode()) { return InteractionArg{}; } auto interactionsToInclude = ~(InteractionItemFlags::entity | InteractionItemFlags::townLabel | InteractionItemFlags::stationLabel); auto res = getMapCoordinatesFromPos(tempX, tempY, interactionsToInclude); auto interaction = res.first; if (interaction.type != InteractionItem::entity) { // clang-format off interactionsToInclude = ~(InteractionItemFlags::entity | InteractionItemFlags::track | InteractionItemFlags::roadAndTram | InteractionItemFlags::headquarterBuilding | InteractionItemFlags::station | InteractionItemFlags::townLabel | InteractionItemFlags::stationLabel | InteractionItemFlags::industry); // clang-format on res = getMapCoordinatesFromPos(tempX, tempY, interactionsToInclude); interaction = res.first; } // TODO: Rework so that getting the interaction arguments and getting the map tooltip format arguments are separated bool success = false; switch (interaction.type) { case InteractionItem::track: success = _track(interaction); break; case InteractionItem::road: success = _road(interaction); break; case InteractionItem::townLabel: success = getTownArguments(static_cast<TownId>(interaction.value)); break; case InteractionItem::stationLabel: success = getStationArguments(static_cast<StationId>(interaction.value)); break; case InteractionItem::trainStation: case InteractionItem::roadStation: case InteractionItem::airport: case InteractionItem::dock: success = getStationArguments(interaction); break; case InteractionItem::industry: success = getIndustryArguments(interaction); break; case InteractionItem::headquarterBuilding: success = getHeadquarterArguments(interaction); break; case InteractionItem::entity: success = getVehicleArguments(interaction); break; default: break; } if (success == true) { return interaction; } auto window = WindowManager::findAt(tempX, tempY); if (window == nullptr) { return InteractionArg{}; } auto viewport = window->viewports[0]; if (viewport == nullptr) { return InteractionArg{}; } if (viewport->zoom > Config::get().vehiclesMinScale) { return InteractionArg{}; } uint32_t nearestDistance = std::numeric_limits<uint32_t>().max(); Vehicles::VehicleBase* nearestVehicle = nullptr; auto targetPosition = viewport->screenToViewport({ tempX, tempY }); for (auto* v : VehicleManager::VehicleList()) { auto train = Vehicles::Vehicle(*v); checkAndSetNearestVehicle(nearestDistance, nearestVehicle, *train.veh2, targetPosition); train.cars.applyToComponents([&nearestDistance, &nearestVehicle, &targetPosition](auto& component) { checkAndSetNearestVehicle(nearestDistance, nearestVehicle, component, targetPosition); }); } if (nearestDistance <= 32 && nearestVehicle != nullptr) { interaction.type = InteractionItem::entity; interaction.object = reinterpret_cast<void*>(nearestVehicle); interaction.pos = nearestVehicle->position; getVehicleArguments(interaction); return interaction; } return InteractionArg{}; } // 0x004CE1D4 static bool rightOverTrack(InteractionArg& interaction) { interaction.type = InteractionItem::track; auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* track = tileElement->as<TrackElement>(); if (track == nullptr) { return false; } if (track->isGhost()) { return false; } if (Ui::Windows::MapToolTip::getTooltipTimeout() < 45) { return true; } auto* trackObj = ObjectManager::get<TrackObject>(track->trackObjectId()); if (track->owner() == CompanyManager::getControllingId()) { FormatArguments::mapToolTip(StringIds::stringid_right_click_to_modify, trackObj->name); } else { auto* company = CompanyManager::get(track->owner()); FormatArguments::mapToolTip(StringIds::string_owned_by_string, trackObj->name, company->name); Windows::MapToolTip::setOwner(track->owner()); } return true; } // 0x004CE18F static bool rightOverTrackExtra(InteractionArg& interaction) { if (!Windows::Construction::isOverheadTabOpen()) { return rightOverTrack(interaction); } auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* track = tileElement->as<TrackElement>(); if (track == nullptr) { return false; } if (track->isGhost()) { return false; } if (!track->hasMod(interaction.modId)) { return rightOverTrack(interaction); } auto* trackObj = ObjectManager::get<TrackObject>(track->trackObjectId()); auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[interaction.modId]); FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, trackExtraObj->name); return true; } // 0x004CDBEA static bool rightOverSignal(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* signal = tileElement->as<SignalElement>(); auto* track = tileElement->prev()->as<TrackElement>(); if (signal == nullptr || track == nullptr) { return false; } if (signal->isGhost()) { return false; } if (!Windows::Construction::isSignalTabOpen()) { interaction.object = track; return rightOverTrack(interaction); } if (track->owner() != CompanyManager::getControllingId()) { return false; } FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, StringIds::capt_signal); return true; } // 0x004CDD8C static bool rightOverTrainStation(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* elStation = tileElement->as<StationElement>(); auto* track = tileElement->prev()->as<TrackElement>(); if (elStation == nullptr || track == nullptr) { return false; } if (elStation->isGhost()) { return false; } if (!Windows::Construction::isStationTabOpen()) { interaction.object = track; return rightOverTrack(interaction); } if (track->owner() != CompanyManager::getControllingId()) { return false; } auto* station = StationManager::get(elStation->stationId()); FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, StringIds::string_station_platform, station->name, station->town); return true; } // 0x004CE2C1 static bool rightOverRoad(InteractionArg& interaction) { interaction.type = InteractionItem::road; auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* road = tileElement->as<RoadElement>(); if (road == nullptr) { return false; } if (road->isGhost()) { return false; } if (Ui::Windows::MapToolTip::getTooltipTimeout() < 45) { return true; } auto* roadObj = ObjectManager::get<RoadObject>(road->roadObjectId()); if (road->owner() == CompanyManager::getControllingId() || road->owner() == CompanyId::neutral) { FormatArguments::mapToolTip(StringIds::stringid_right_click_to_modify, roadObj->name); } else { auto* company = CompanyManager::get(road->owner()); FormatArguments::mapToolTip(StringIds::string_owned_by_string, roadObj->name, company->name); Windows::MapToolTip::setOwner(road->owner()); } return true; } // 0x004CE271 static bool rightOverRoadExtra(InteractionArg& interaction) { if (!Windows::Construction::isOverheadTabOpen()) { return rightOverRoad(interaction); } auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* road = tileElement->as<RoadElement>(); if (road == nullptr) { return false; } if (road->isGhost()) { return false; } if (!road->hasMod(interaction.modId)) { return rightOverRoad(interaction); } auto* roadObj = ObjectManager::get<RoadObject>(road->roadObjectId()); auto* roadExtraObj = ObjectManager::get<TrackExtraObject>(roadObj->mods[interaction.modId]); FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, roadExtraObj->name); return true; } // 0x004CDDF2 static bool rightOverRoadStation(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* elStation = tileElement->as<StationElement>(); auto* road = tileElement->prev()->as<RoadElement>(); if (elStation == nullptr || road == nullptr) { return false; } if (elStation->isGhost()) { return false; } if (!Windows::Construction::isStationTabOpen()) { interaction.object = road; return rightOverRoad(interaction); } auto* station = StationManager::get(elStation->stationId()); if (station == nullptr) { return false; } if (station->owner != CompanyManager::getControllingId()) { return false; } FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, StringIds::string_station_building_bus_stop, station->name, station->town); return true; } // 0x004CDC26 static bool rightOverAirport(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* elStation = tileElement->as<StationElement>(); if (elStation == nullptr) { return false; } if (elStation->isGhost()) { return false; } if (elStation->owner() != CompanyManager::getControllingId()) { return false; } auto* station = StationManager::get(elStation->stationId()); auto args = FormatArguments::mapToolTip(); if (Windows::Construction::isStationTabOpen()) { args.push(StringIds::stringid_right_click_to_remove); } else { args.push(StringIds::stringid_right_click_to_modify); } args.push(StringIds::quote_string_quote); args.push(station->name); args.push(station->town); return true; } // 0x004CDCD9 static bool rightOverDock(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* elStation = tileElement->as<StationElement>(); if (elStation == nullptr) { return false; } if (elStation->isGhost()) { return false; } if (elStation->owner() != CompanyManager::getControllingId()) { return false; } auto* station = StationManager::get(elStation->stationId()); auto args = FormatArguments::mapToolTip(); if (Windows::Construction::isStationTabOpen()) { args.push(StringIds::stringid_right_click_to_remove); } else { args.push(StringIds::stringid_right_click_to_modify); } args.push(StringIds::quote_string_quote2); args.push(station->name); args.push(station->town); return true; } // 0x004CDE58 static bool rightOverTree(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* tree = tileElement->as<TreeElement>(); if (tree == nullptr) { return false; } auto* treeObj = ObjectManager::get<TreeObject>(tree->treeObjectId()); FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, treeObj->name); return true; } // 0x004CE0D8 static bool rightOverWall(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* wall = tileElement->as<WallElement>(); if (wall == nullptr) { return false; } if (!SceneManager::isEditorMode()) { return false; } auto* wallObj = ObjectManager::get<WallObject>(wall->wallObjectId()); FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, wallObj->name); return true; } // 0x004CDE78 // Note: this is only when in a constructing mode static bool rightOverBuildingConstruct(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* building = tileElement->as<BuildingElement>(); if (building == nullptr) { return false; } const auto* buildingObj = building->getObject(); auto args = FormatArguments::mapToolTip(); if (SceneManager::isEditorMode() || SceneManager::isSandboxMode() || !buildingObj->hasFlags(BuildingObjectFlags::indestructible)) { args.push(StringIds::stringid_right_click_to_remove); } args.push(buildingObj->name); return true; } // 0x004CE107 static bool rightOverHeadquarters(InteractionArg& interaction) { auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* building = tileElement->as<BuildingElement>(); if (building == nullptr) { return false; } auto firstTile = interaction.pos - World::kOffsets[building->sequenceIndex()]; auto height = building->baseZ(); for (auto& company : CompanyManager::companies()) { if (company.headquartersX == firstTile.x && company.headquartersY == firstTile.y && company.headquartersZ == height) { FormatArguments::mapToolTip(StringIds::stringid_right_click_to_remove, StringIds::stringid_headquarters, company.name); return true; } } return false; } constexpr std::array<StringId, 7> quantityToString = { StringIds::quantity_eigth, StringIds::quantity_quarter, StringIds::quantity_three_eigths, StringIds::quantity_half, StringIds::quantity_five_eigths, StringIds::quantity_three_quarters, StringIds::quantity_seven_eigths, }; // 0x004CDEB8 // Note: this is only when in a none constructing mode static bool rightOverBuilding(InteractionArg& interaction) { interaction.type = InteractionItem::buildingInfo; if (Ui::Windows::MapToolTip::getTooltipTimeout() < 45) { return true; } auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); auto* building = tileElement->as<BuildingElement>(); if (building == nullptr) { return false; } const auto* buildingObj = building->getObject(); auto* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_338)); buffer = StringManager::formatString(buffer, buildingObj->name); if (!building->isConstructed()) { buffer = StringManager::formatString(buffer, StringIds::under_construction); } else { if (buildingObj->producedQuantity[0] != 0 || buildingObj->producedQuantity[1] != 0) { buffer = StringManager::formatString(buffer, StringIds::produces); bool requiresComma = false; for (auto i = 0; i < 2; ++i) { if (buildingObj->producedQuantity[i] != 0) { if (requiresComma) { buffer = StringManager::formatString(buffer, StringIds::comma); } requiresComma = true; auto* cargo = ObjectManager::get<CargoObject>(buildingObj->producedCargoType[i]); buffer = StringManager::formatString(buffer, cargo->name); } } } if (buildingObj->var_A6[0] != 0 || buildingObj->var_A6[1] != 0 || buildingObj->var_A8[0] != 0 || buildingObj->var_A8[1] != 0) { buffer = StringManager::formatString(buffer, StringIds::accepts); bool requiresComma = false; for (auto i = 0; i < 2; ++i) { if (buildingObj->var_A6[i] != 0) { if (requiresComma) { buffer = StringManager::formatString(buffer, StringIds::comma); } if (buildingObj->var_A6[i] < 8) { buffer = StringManager::formatString(buffer, quantityToString[buildingObj->var_A6[i]]); } requiresComma = true; auto* cargo = ObjectManager::get<CargoObject>(buildingObj->producedCargoType[i]); buffer = StringManager::formatString(buffer, cargo->name); } } for (auto i = 0; i < 2; ++i) { if (buildingObj->var_A8[i] != 0) { if (requiresComma) { buffer = StringManager::formatString(buffer, StringIds::comma); } if (buildingObj->var_A8[i] < 8) { buffer = StringManager::formatString(buffer, quantityToString[buildingObj->var_A8[i]]); } requiresComma = true; auto* cargo = ObjectManager::get<CargoObject>(buildingObj->requiredCargoType[i]); buffer = StringManager::formatString(buffer, cargo->name); } } } } FormatArguments::mapToolTip(StringIds::buffer_338); return true; } // 0x004CDB2B InteractionArg rightOver(int16_t x, int16_t y) { if (SceneManager::isTitleMode()) { return InteractionArg{}; } // Interaction types to exclude by default auto interactionsToExclude = InteractionItemFlags::none | InteractionItemFlags::surface | InteractionItemFlags::water; // TODO: Handle in the paint functions // Get the viewport and add extra flags for hidden scenery auto screenPos = Ui::Point(x, y); auto w = WindowManager::findAt(screenPos); if (w != nullptr) { for (auto vp : w->viewports) { if (vp != nullptr && vp->containsUi({ screenPos.x, screenPos.y })) { if (vp->hasFlags(ViewportFlags::seeThroughBuildings)) { interactionsToExclude |= InteractionItemFlags::building | InteractionItemFlags::headquarterBuilding | InteractionItemFlags::industry; } if (vp->hasFlags(ViewportFlags::seeThroughBridges)) { // Bridges can't be interacted with ever so no need to exclude anything additional } if (vp->hasFlags(ViewportFlags::seeThroughTrees)) { interactionsToExclude |= InteractionItemFlags::tree; } if (vp->hasFlags(ViewportFlags::seeThroughScenery)) { interactionsToExclude |= InteractionItemFlags::wall; } if (vp->hasFlags(ViewportFlags::seeThroughTracks)) { interactionsToExclude |= InteractionItemFlags::track | InteractionItemFlags::trackExtra | InteractionItemFlags::signal; } if (vp->hasFlags(ViewportFlags::seeThroughRoads)) { interactionsToExclude |= InteractionItemFlags::roadAndTram | InteractionItemFlags::roadAndTramExtra; } } } } bool hasInteraction = false; auto res = getMapCoordinatesFromPos(x, y, interactionsToExclude); auto& interaction = res.first; switch (interaction.type) { case InteractionItem::track: hasInteraction = rightOverTrack(interaction); break; case InteractionItem::entity: // No interaction break; case InteractionItem::trackExtra: hasInteraction = rightOverTrackExtra(interaction); break; case InteractionItem::signal: hasInteraction = rightOverSignal(interaction); break; case InteractionItem::trainStation: hasInteraction = rightOverTrainStation(interaction); break; case InteractionItem::roadStation: hasInteraction = rightOverRoadStation(interaction); break; case InteractionItem::airport: hasInteraction = rightOverAirport(interaction); break; case InteractionItem::dock: hasInteraction = rightOverDock(interaction); break; case InteractionItem::road: hasInteraction = rightOverRoad(interaction); break; case InteractionItem::roadExtra: hasInteraction = rightOverRoadExtra(interaction); break; default: if (!(Input::hasFlag(Input::Flags::toolActive) && Input::hasFlag(Input::Flags::flag6))) { if (WindowManager::find(WindowType::construction) == nullptr) { if (interaction.type == InteractionItem::building) { hasInteraction = rightOverBuilding(interaction); } break; } } // 0x4CDBC5 switch (interaction.type) { case InteractionItem::tree: hasInteraction = rightOverTree(interaction); break; case InteractionItem::wall: hasInteraction = rightOverWall(interaction); break; case InteractionItem::building: hasInteraction = rightOverBuildingConstruct(interaction); break; case InteractionItem::headquarterBuilding: hasInteraction = rightOverHeadquarters(interaction); break; default: hasInteraction = true; break; } break; } return hasInteraction ? interaction : InteractionArg{}; } // 0x004A5AA1 static void rightReleasedSignal(World::SignalElement* signal, const bool isLeftSignal, const World::Pos2 pos) { auto* track = signal->prev()->as<World::TrackElement>(); if (track == nullptr) { return; } uint16_t unkFlags = 1 << 15; // right if (isLeftSignal) { unkFlags = 1 << 14; // left } // If in construction mode with both directions selection (actually does not single direction but this is what is implied) if (!ToolManager::isToolActive(WindowType::construction, 0, 11 /* Ui::Windows::Construction::Signal::widx::signal_direction */)) { if (signal->getLeft().hasSignal() && signal->getRight().hasSignal()) { unkFlags = (1 << 15) | (1 << 14); // both } } GameCommands::SignalRemovalArgs args; args.pos = Pos3(pos.x, pos.y, track->baseHeight()); args.rotation = track->rotation(); args.trackId = track->trackId(); args.index = track->sequenceIndex(); args.trackObjType = track->trackObjectId(); args.flags = unkFlags; auto* window = WindowManager::find(WindowType::construction); if (window != nullptr) { Ui::Windows::Construction::removeConstructionGhosts(); } GameCommands::setErrorTitle(StringIds::cant_remove_signal); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } // 0x004A5B66 static void rightReleasedTrainStation(World::StationElement* station, const World::Pos2 pos) { auto* track = station->prev()->as<World::TrackElement>(); if (track == nullptr) { return; } GameCommands::setErrorTitle(StringIds::cant_remove_station); GameCommands::TrainStationRemovalArgs args; args.pos = Pos3(pos.x, pos.y, track->baseHeight()); args.rotation = track->rotation(); args.trackId = track->trackId(); args.index = track->sequenceIndex(); args.type = track->trackObjectId(); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } // 0x004A5BDF static void rightReleasedRoadStation(World::StationElement* station, const World::Pos2 pos) { auto* road = station->prev()->as<RoadElement>(); if (road == nullptr) { return; } GameCommands::setErrorTitle(StringIds::cant_remove_station); GameCommands::RoadStationRemovalArgs args; args.pos = Pos3(pos.x, pos.y, road->baseHeight()); args.rotation = road->rotation(); args.roadId = road->roadId(); args.index = road->sequenceIndex(); args.roadObjectId = road->roadObjectId(); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } // 0x004A5C58 static void rightReleasedAirport(World::StationElement* station, const World::Pos2 pos) { if (!Ui::Windows::Construction::isStationTabOpen()) { Ui::Windows::Construction::openWithFlags(1ULL << 31); return; } GameCommands::setErrorTitle(StringIds::cant_remove_airport); GameCommands::AirportRemovalArgs args; args.pos = Pos3(pos.x, pos.y, station->baseHeight()); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } // 0x004A5CC5 static void rightReleasedDock(World::StationElement* station, const World::Pos2 pos) { if (!Ui::Windows::Construction::isStationTabOpen()) { Ui::Windows::Construction::openWithFlags(1ULL << 30); return; } GameCommands::setErrorTitle(StringIds::cant_remove_ship_port); GameCommands::PortRemovalArgs args; Pos2 firstTile = pos - World::kOffsets[station->sequenceIndex()]; args.pos = Pos3(firstTile.x, firstTile.y, station->baseHeight()); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } // 0x004BB116 static void rightReleasedTree(World::TreeElement* tree, const World::Pos2 pos) { GameCommands::setErrorTitle(StringIds::error_cant_remove_this); GameCommands::TreeRemovalArgs args; args.pos = Pos3(pos.x, pos.y, tree->baseHeight()); args.elementType = tree->rawData()[0]; args.type = tree->treeObjectId(); GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x0042D9BF static void rightReleasedBuilding(World::BuildingElement* building, const World::Pos2 pos) { GameCommands::setErrorTitle(StringIds::error_cant_remove_this); GameCommands::BuildingRemovalArgs args; Pos2 firstTile = pos - World::kOffsets[building->sequenceIndex()]; args.pos = Pos3(firstTile.x, firstTile.y, building->baseHeight()); GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x004C4809 static void rightReleasedWall(World::WallElement* wall, const World::Pos2 pos) { GameCommands::setErrorTitle(StringIds::error_cant_remove_this); GameCommands::WallRemovalArgs args; args.pos = Pos3(pos.x, pos.y, wall->baseHeight()); args.rotation = wall->rotation(); GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x0042F007 static void rightReleasedHeadquarter(World::BuildingElement* building, const World::Pos2 pos) { GameCommands::setErrorTitle(StringIds::error_cant_remove_this); GameCommands::HeadquarterRemovalArgs args; Pos2 firstTile = pos - World::kOffsets[building->sequenceIndex()]; args.pos = Pos3(firstTile.x, firstTile.y, building->baseHeight()); GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x004A1303 static void rightReleasedTrackExtra(TrackElement* track, const uint8_t bh, const Pos2 pos) { auto* window = WindowManager::find(WindowType::construction); if (window != nullptr) { Windows::Construction::removeConstructionGhosts(); } GameCommands::TrackModsRemovalArgs args{}; args.pos = World::Pos3(pos, track->baseHeight()); args.rotation = track->rotation(); args.trackId = track->trackId(); args.index = track->sequenceIndex(); args.trackObjType = track->trackObjectId(); args.type = 1U << bh; args.modSection = Windows::Construction::getLastSelectedTrackModSection(); auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjType); auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[bh]); auto fArgs = FormatArguments::common(); fArgs.skip(6); fArgs.push(trackExtraObj->name); GameCommands::setErrorTitle(StringIds::cant_remove_pop3_string); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } // 0x004A13C1 static void rightReleaseRoadExtra(RoadElement* road, const uint8_t bh, const Pos2 pos) { auto* window = WindowManager::find(WindowType::construction); if (window != nullptr) { Windows::Construction::removeConstructionGhosts(); } GameCommands::RoadModsRemovalArgs args{}; args.pos = World::Pos3(pos, road->baseHeight()); args.rotation = road->rotation(); args.roadId = road->roadId(); args.index = road->sequenceIndex(); args.roadObjType = road->roadObjectId(); args.type = 1U << bh; args.modSection = Windows::Construction::getLastSelectedTrackModSection(); auto* roadObj = ObjectManager::get<RoadObject>(args.roadObjType); auto* roadExtraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[bh]); auto fArgs = FormatArguments::common(); fArgs.skip(6); fArgs.push(roadExtraObj->name); GameCommands::setErrorTitle(StringIds::cant_remove_pop3_string); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } } void handleRightReleased(Window* window, int16_t xPos, int16_t yPos) { auto interaction = ViewportInteraction::rightOver(xPos, yPos); auto* tileElement = reinterpret_cast<World::TileElement*>(interaction.object); switch (interaction.type) { case InteractionItem::noInteraction: default: { auto item2 = ViewportInteraction::getItemLeft(xPos, yPos); switch (item2.type) { case InteractionItem::entity: { auto* entity = reinterpret_cast<EntityBase*>(item2.object); auto* veh = entity->asBase<Vehicles::VehicleBase>(); if (veh != nullptr) { auto* head = EntityManager::get<Vehicles::VehicleHead>(veh->getHead()); if (head != nullptr) { Ui::Windows::VehicleList::open(head->owner, head->vehicleType); } } break; } case InteractionItem::townLabel: Ui::Windows::TownList::open(); break; case InteractionItem::stationLabel: { auto station = StationManager::get(StationId(item2.value)); Ui::Windows::StationList::open(station->owner); break; } case InteractionItem::industry: Ui::Windows::IndustryList::open(); break; default: break; } break; } case InteractionItem::track: { auto* track = tileElement->as<TrackElement>(); if (track != nullptr) { if (track->owner() == CompanyManager::getControllingId()) { Ui::Windows::Construction::openAtTrack(*window, track, interaction.pos); } else { Ui::Windows::CompanyWindow::open(track->owner()); } } break; } case InteractionItem::road: { auto* road = tileElement->as<RoadElement>(); if (road != nullptr) { auto owner = road->owner(); auto roadObject = ObjectManager::get<RoadObject>(road->roadObjectId()); if (owner == CompanyManager::getControllingId() || owner == CompanyId::neutral || roadObject->hasFlags(RoadObjectFlags::unk_03)) { Ui::Windows::Construction::openAtRoad(*window, road, interaction.pos); } else { Ui::Windows::CompanyWindow::open(owner); } } break; } case InteractionItem::trackExtra: { auto* track = tileElement->as<TrackElement>(); if (track != nullptr) { rightReleasedTrackExtra(track, interaction.modId, interaction.pos); } break; } case InteractionItem::roadExtra: { auto* road = tileElement->as<RoadElement>(); if (road != nullptr) { rightReleaseRoadExtra(road, interaction.modId, interaction.pos); } break; } case InteractionItem::signal: { auto* signal = tileElement->as<SignalElement>(); if (signal != nullptr) { rightReleasedSignal(signal, interaction.modId != 0, interaction.pos); } break; } case InteractionItem::trainStation: { auto* station = tileElement->as<StationElement>(); if (station != nullptr) { rightReleasedTrainStation(station, interaction.pos); } break; } case InteractionItem::roadStation: { auto* station = tileElement->as<StationElement>(); if (station != nullptr) { rightReleasedRoadStation(station, interaction.pos); } break; } case InteractionItem::airport: { auto* station = tileElement->as<StationElement>(); if (station != nullptr) { rightReleasedAirport(station, interaction.pos); } break; } case InteractionItem::dock: { auto* station = tileElement->as<StationElement>(); if (station != nullptr) { rightReleasedDock(station, interaction.pos); } break; } case InteractionItem::tree: { auto* tree = tileElement->as<TreeElement>(); if (tree != nullptr) { rightReleasedTree(tree, interaction.pos); } break; } case InteractionItem::building: { auto* building = tileElement->as<BuildingElement>(); if (building != nullptr) { rightReleasedBuilding(building, interaction.pos); } break; } case InteractionItem::wall: { auto* wall = tileElement->as<WallElement>(); if (wall != nullptr) { rightReleasedWall(wall, interaction.pos); } break; } case InteractionItem::headquarterBuilding: { auto* building = tileElement->as<BuildingElement>(); if (building != nullptr) { rightReleasedHeadquarter(building, interaction.pos); } break; } } } // 0x00459E54 std::pair<ViewportInteraction::InteractionArg, Viewport*> getMapCoordinatesFromPos(int32_t screenX, int32_t screenY, InteractionItemFlags flags) { static loco_global<uint8_t, 0x0050BF68> _50BF68; // If in get map coords static loco_global<Gfx::RenderTarget, 0x00E0C3E4> _rt1; static loco_global<Gfx::RenderTarget, 0x00E0C3F4> _rt2; _50BF68 = 1; ViewportInteraction::InteractionArg interaction{}; Ui::Point screenPos = { static_cast<int16_t>(screenX), static_cast<int16_t>(screenY) }; auto w = WindowManager::findAt(screenPos); if (w == nullptr) { _50BF68 = 0; return std::make_pair(interaction, nullptr); } Viewport* chosenV = nullptr; for (auto vp : w->viewports) { if (vp == nullptr) { continue; } if (!vp->containsUi({ screenPos.x, screenPos.y })) { continue; } chosenV = vp; auto vpPos = vp->screenToViewport({ screenPos.x, screenPos.y }); _rt1->zoomLevel = vp->zoom; _rt1->x = (0xFFFF << vp->zoom) & vpPos.x; _rt1->y = (0xFFFF << vp->zoom) & vpPos.y; _rt2->x = _rt1->x; _rt2->y = _rt1->y; _rt2->width = 1; _rt2->height = 1; _rt2->zoomLevel = _rt1->zoomLevel; Paint::SessionOptions options{}; options.rotation = vp->getRotation(); options.viewFlags = vp->flags; // Todo: should this pass the cullHeight... auto session = Paint::PaintSession(_rt2, options); session.generate(); session.arrangeStructs(); interaction = session.getNormalInteractionInfo(flags); if (!vp->hasFlags(ViewportFlags::station_names_displayed)) { if (_rt2->zoomLevel <= Config::get().stationNamesMinScale) { auto stationInteraction = session.getStationNameInteractionInfo(flags); if (stationInteraction.type != InteractionItem::noInteraction) { interaction = stationInteraction; } } } if (!vp->hasFlags(ViewportFlags::town_names_displayed)) { auto townInteraction = session.getTownNameInteractionInfo(flags); if (townInteraction.type != InteractionItem::noInteraction) { interaction = townInteraction; } } break; } _50BF68 = 0; return std::make_pair(interaction, chosenV); } // 0x00460781 // regs.ax = screenCoords.x; // regs.bx = screenCoords.y; // returns // regs.edx = InteractionInfo.value (unsure if ever used) // regs.ax = mapX, 0x8000 - in case of failure // regs.bx = mapY // regs.ecx = closestEdge (unsure if ever used) std::optional<Pos2> getSurfaceOrWaterLocFromUi(const Point& screenCoords) { // TODO: modify getSurfaceOrWaterLocFromUi to return the viewport then can use viewports rotation auto [info, viewport] = getMapCoordinatesFromPos(screenCoords.x, screenCoords.y, ~(InteractionItemFlags::surface | InteractionItemFlags::water)); if (info.type == InteractionItem::noInteraction) { return {}; } int16_t waterHeight = 0; // E40130 if (info.type == InteractionItem::water) { auto* surface = static_cast<const SurfaceElement*>(info.object); waterHeight = surface->waterHeight(); } const auto minPosition = info.pos; // E40128/A const auto maxPosition = info.pos + Pos2{ 31, 31 }; // E4012C/E auto mapPos = info.pos + Pos2{ 16, 16 }; const auto initialVPPos = viewport->screenToViewport(screenCoords); for (int32_t i = 0; i < 5; i++) { int16_t z = waterHeight; if (info.type != InteractionItem::water) { z = TileManager::getHeight(mapPos).landHeight; } mapPos = viewportCoordToMapCoord(initialVPPos.x, initialVPPos.y, z, viewport->getRotation()); mapPos.x = std::clamp(mapPos.x, minPosition.x, maxPosition.x); mapPos.y = std::clamp(mapPos.y, minPosition.y, maxPosition.y); } // Determine to which edge the cursor is closest [[maybe_unused]] uint32_t closestEdge = World::getSideFromPos(mapPos); // ecx return { Pos2(mapPos.x & 0xFFE0, mapPos.y & 0xFFE0) }; } // 0x0045F1A7 std::optional<std::pair<Pos2, Viewport*>> getSurfaceLocFromUi(const Point& screenCoords) { auto [info, viewport] = getMapCoordinatesFromPos(screenCoords.x, screenCoords.y, ~InteractionItemFlags::surface); if (info.type == InteractionItem::noInteraction) { return {}; } const auto minPosition = info.pos; // E40128/A const auto maxPosition = info.pos + Pos2{ 31, 31 }; // E4012C/E auto mapPos = info.pos + Pos2{ 16, 16 }; const auto initialVPPos = viewport->screenToViewport(screenCoords); for (int32_t i = 0; i < 5; i++) { const auto z = TileManager::getHeight(mapPos); mapPos = viewportCoordToMapCoord(initialVPPos.x, initialVPPos.y, z.landHeight, viewport->getRotation()); mapPos.x = std::clamp(mapPos.x, minPosition.x, maxPosition.x); mapPos.y = std::clamp(mapPos.y, minPosition.y, maxPosition.y); } return { std::make_pair(mapPos, viewport) }; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/ViewportInteraction.h ```h #pragma once #include "Graphics/Gfx.h" #include "Location.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/World.hpp> #include <optional> using namespace OpenLoco::World; namespace OpenLoco::Paint { struct PaintStruct; } namespace OpenLoco::Ui { struct Viewport; struct Window; } namespace OpenLoco::Ui::ViewportInteraction { enum class InteractionItem : uint8_t { noInteraction = 0, surface = 1, industryTree = 2, entity = 3, track = 4, trackExtra = 5, signal = 6, trainStation = 7, roadStation = 8, airport = 9, dock = 10, water = 11, tree = 12, wall = 13, townLabel = 14, stationLabel = 15, road = 16, roadExtra = 17, bridge = 18, building = 19, industry = 20, headquarterBuilding = 21, buildingInfo = 22, }; enum class InteractionItemFlags : uint32_t // Bridge missing? { none = 0U, surface = (1U << 0), entity = (1U << 1), track = (1U << 2), water = (1U << 3), tree = (1U << 4), roadAndTram = (1U << 5), roadAndTramExtra = (1U << 6), signal = (1U << 7), wall = (1U << 8), headquarterBuilding = (1U << 9), station = (1U << 11), townLabel = (1U << 12), stationLabel = (1U << 13), trackExtra = (1U << 14), building = (1U << 15), industry = (1U << 16), }; OPENLOCO_ENABLE_ENUM_OPERATORS(InteractionItemFlags); struct InteractionArg { World::Pos2 pos; union { uint32_t value; void* object; }; InteractionItem type; uint8_t modId; // used for track mods and to indicate left/right signals InteractionArg() = default; constexpr InteractionArg(const World::Pos2& _pos, uint32_t _value, InteractionItem _type, uint8_t _unkBh) : pos(_pos) , value(_value) , type(_type) , modId(_unkBh) { } InteractionArg(const Paint::PaintStruct& ps); }; static constexpr auto kNoInteractionArg = InteractionArg({ 0, 0 }, 0, InteractionItem::noInteraction, 0); InteractionArg getItemLeft(int16_t tempX, int16_t tempY); InteractionArg rightOver(int16_t x, int16_t y); void handleRightReleased(Window* window, int16_t xPos, int16_t yPos); std::pair<ViewportInteraction::InteractionArg, Ui::Viewport*> getMapCoordinatesFromPos(int32_t screenX, int32_t screenY, InteractionItemFlags flags); std::optional<World::Pos2> getSurfaceOrWaterLocFromUi(const Point& screenCoords); std::optional<std::pair<World::Pos2, Ui::Viewport*>> getSurfaceLocFromUi(const Point& screenCoords); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widget.cpp ```cpp #include "Widget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Ui/ScrollView.h" #include "Window.h" #include <OpenLoco/Interop/Interop.hpp> #include <cassert> using namespace OpenLoco::Interop; namespace OpenLoco::Ui { int16_t Widget::midX() const { return (this->left + this->right) / 2; } int16_t Widget::midY() const { return (this->top + this->bottom) / 2; } uint16_t Widget::width() const { return (this->right - this->left) + 1; } uint16_t Widget::height() const { return (this->bottom - this->top) + 1; } void Widget::draw( Gfx::DrawingContext& drawingCtx, Window* window, const uint64_t pressedWidgets, const uint64_t toolWidgets, const uint64_t hoveredWidgets, uint8_t scrollviewIndex) { if (hidden || type == WidgetType::empty) { // Nothing to do here. return; } const auto& rt = drawingCtx.currentRenderTarget(); if (!window->hasFlags(WindowFlags::noBackground)) { // Check if widget is outside the draw region if (window->x + left >= rt.x + rt.width && window->x + right < rt.x) { if (window->y + top >= rt.y + rt.height && window->y + bottom < rt.y) { return; } } } Gfx::RectInsetFlags widgetFlags = Gfx::RectInsetFlags::none; if (windowColour == WindowColour::primary && window->hasFlags(WindowFlags::flag_11)) { widgetFlags = Gfx::RectInsetFlags::colourLight; } const auto widgetIndex = this - &window->widgets[0]; WidgetState widgetState{}; widgetState.window = window; widgetState.flags = widgetFlags; widgetState.colour = window->getColour(windowColour); widgetState.disabled = disabled || ((window->disabledWidgets & (1ULL << widgetIndex)) != 0); widgetState.activated = activated || ((window->activatedWidgets & (1ULL << widgetIndex)) != 0); widgetState.activated |= (pressedWidgets & (1ULL << widgetIndex)) != 0; widgetState.activated |= (toolWidgets & (1ULL << widgetIndex)) != 0; widgetState.hovered = (hoveredWidgets & (1ULL << widgetIndex)) != 0; widgetState.scrollviewIndex = scrollviewIndex; // With the only exception of WidgetType::empty everything else should implement it. assert(events.draw != nullptr); if (events.draw != nullptr) { events.draw(drawingCtx, *this, widgetState); return; } } // 0x004CF194 void Widget::drawTab(Window& w, Gfx::DrawingContext& drawingCtx, uint32_t imageId, WidgetIndex_t index) { auto& widget = w.widgets[index]; Ui::Point pos = {}; pos.x = widget.left + w.x; pos.y = widget.top + w.y; if (w.isDisabled(index)) { return; // 0x8000 } bool isActivated = false; if (w.isActivated(index)) { isActivated = true; } else if (Input::state() == Input::State::widgetPressed) { isActivated = Input::isPressed(w.type, w.number, index); } if (imageId == kContentNull) { return; } if (isActivated) { if (imageId != kContentUnk) { drawingCtx.drawImage(pos.x, pos.y, imageId); } } else { if (imageId != kContentUnk) { drawingCtx.drawImage(pos.x, pos.y + 1, imageId); } drawingCtx.drawImage(pos.x, pos.y, Gfx::recolourTranslucent(ImageIds::tab, ExtColour::unk33)); drawingCtx.drawRect(pos.x, pos.y + 26, 31, 1, Colours::getShade(w.getColour(WindowColour::secondary).c(), 7), Gfx::RectFlags::none); } } void Widget::leftAlignTabs(Window& window, uint8_t firstTabIndex, uint8_t lastTabIndex, uint16_t tabWidth) { auto xPos = window.widgets[firstTabIndex].left; for (auto i = firstTabIndex; i <= lastTabIndex; i++) { if (window.isDisabled(i)) { window.widgets[i].hidden = true; } else { window.widgets[i].hidden = false; window.widgets[i].left = xPos; window.widgets[i].right = xPos + tabWidth; xPos = window.widgets[i].right + 1; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widget.h ```h #pragma once #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include <array> #include <cstdint> namespace OpenLoco::Gfx { enum class RectInsetFlags : uint8_t; class DrawingContext; } namespace OpenLoco::Ui { using WidgetIndex_t = int16_t; constexpr WidgetIndex_t kWidgetIndexNull = -1; namespace Detail { // TODO: Move this to a more appropriate location. static constexpr uint64_t getHashFNV1a(const char* s, size_t) { // FNV-1a hash constexpr auto kPrime = 0x00000100000001B3ULL; constexpr auto kOffsetBasis = 0xCBF29CE484222325ULL; auto res = kOffsetBasis; for (size_t i = 0; s[i] != '\0'; i++) { res ^= s[i]; res *= kPrime; } return res; } } class WidgetId { public: enum class ValueType : uint64_t { none = 0, }; private: ValueType _value{}; public: static constexpr auto none = ValueType::none; constexpr WidgetId() = default; constexpr WidgetId(ValueType value) : _value{ value } { } template<size_t TSize> constexpr WidgetId(const char (&str)[TSize]) : _value{ static_cast<ValueType>(Detail::getHashFNV1a(str, TSize)) } { } constexpr WidgetId(const char* str) : _value{ static_cast<ValueType>(Detail::getHashFNV1a(str, 0)) } { } constexpr auto operator<=>(const WidgetId&) const = default; // This makes switch statements work. constexpr operator uint64_t() const { return static_cast<uint64_t>(_value); } }; struct Window; enum class WindowColour : uint8_t; enum class ContentAlign : uint8_t { left = 0, center, right, }; enum class WidgetType : uint8_t { empty = 0, panel, newsPanel, frame, wt_3, slider, wt_6, toolbarTab, tab, buttonWithImage, buttonWithColour, button, label, buttonTableHeader, groupbox, textbox, combobox, viewport, caption, scrollview, checkbox, }; struct WidgetState { Window* window{}; Gfx::RectInsetFlags flags{}; AdvancedColour colour{}; bool disabled{}; bool activated{}; bool hovered{}; int scrollviewIndex{}; }; struct Widget; struct WidgetEventsList { void (*draw)(Gfx::DrawingContext&, const Widget&, const WidgetState&) = nullptr; }; struct Widget { // Indicates that the imageId has a colour set and not to replace it with the window colour // This reuses the ImageIdFlags::translucent flag for use in widget draw // Flag *MUST* be removed before passing to drawingCtx.drawImage functions static constexpr uint32_t kImageIdColourSet = (1U << 30); static constexpr uint32_t kContentNull = 0xFFFFFFFFU; static constexpr uint32_t kContentUnk = 0xFFFFFFFEU; constexpr Widget(WidgetId widgetId, Ui::Point32 origin, Ui::Size32 size, WidgetType widgetType, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : id{ widgetId } , content{ content } , left{ static_cast<int16_t>(origin.x) } , right{ static_cast<int16_t>(origin.x + size.width - 1) } , top{ static_cast<int16_t>(origin.y) } , bottom{ static_cast<int16_t>(origin.y + size.height - 1) } , tooltip{ tooltip } , type{ widgetType } , windowColour{ colour } { } constexpr Widget(WidgetId widgetId, Ui::Point32 origin, Ui::Size32 size, WidgetType widgetType, WindowColour colour, StringId content, StringId tooltip = StringIds::null) : id{ widgetId } , text{ content } , left{ static_cast<int16_t>(origin.x) } , right{ static_cast<int16_t>(origin.x + size.width - 1) } , top{ static_cast<int16_t>(origin.y) } , bottom{ static_cast<int16_t>(origin.y + size.height - 1) } , tooltip{ tooltip } , type{ widgetType } , windowColour{ colour } { } constexpr Widget() = default; WidgetId id{ WidgetId::none }; FormatArgumentsBuffer textArgs; WidgetEventsList events; union { uint32_t image{ ImageIds::null }; StringId text; uint32_t content; }; int16_t left{}; int16_t right{}; int16_t top{}; int16_t bottom{}; Gfx::Font font{ Gfx::Font::medium_bold }; StringId tooltip{ StringIds::null }; WidgetType type{}; ContentAlign contentAlign{ ContentAlign::left }; WindowColour windowColour{}; int16_t midX() const; int16_t midY() const; uint16_t width() const; uint16_t height() const; // Custom widget attributes. uint32_t styleData{}; // Widget state. bool disabled : 1 {}; bool activated : 1 {}; bool hidden : 1 {}; // TODO: Remove this once position is a member. Ui::Point position() const { return { static_cast<int16_t>(left), static_cast<int16_t>(top) }; } // TODO: Remove this once size is a member. Ui::Size size() const { return { width(), height() }; } // TODO: Make tabs actual widgets. static void drawTab(Window& w, Gfx::DrawingContext& drawingCtx, uint32_t imageId, WidgetIndex_t index); // typical tab width, to be used in most (all?) cases static constexpr uint16_t kDefaultTabWidth = 30; static void leftAlignTabs(Window& window, uint8_t firstTabIndex, uint8_t lastTabIndex, uint16_t tabWidth = kDefaultTabWidth); void draw(Gfx::DrawingContext& drawingCtx, Window* window, const uint64_t pressedWidgets, const uint64_t toolWidgets, const uint64_t hoveredWidgets, uint8_t scrollviewIndex); }; constexpr Widget makeWidget(Ui::Point32 origin, Ui::Size32 size, WidgetType type, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) { Widget out{ WidgetId::none, origin, size, type, colour, content, tooltip }; return out; } namespace Detail { template<typename T, typename Enable = void> struct WidgetsCount { static constexpr size_t count = 0; }; template<typename T> struct WidgetsCount<T, std::enable_if_t<std::is_base_of_v<Widget, T>>> { static constexpr size_t count = 1; }; template<typename T, std::size_t N> struct WidgetsCount<std::array<T, N>, std::enable_if_t<std::is_base_of_v<Widget, T>>> { static constexpr size_t count = N; }; template<typename T> struct IsWidgetsArray : std::false_type { }; template<std::size_t N> struct IsWidgetsArray<std::array<Widget, N>> : std::true_type { }; } template<typename... TArgs> constexpr auto makeWidgets(TArgs&&... args) { constexpr auto totalCount = [&]() { size_t count = 0; ((count += Detail::WidgetsCount<std::decay_t<decltype(args)>>::count), ...); return count; }(); std::array<Widget, totalCount> res{}; size_t index = 0; const auto append = [&](auto&& val) { if constexpr (Detail::IsWidgetsArray<std::decay_t<decltype(val)>>::value) { for (auto&& widget : val) { res[index] = std::move(widget); index++; } } else { res[index] = std::move(val); index++; } }; ((append(args)), ...); return res; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Window.cpp ```cpp #include "Window.h" #include "Config.h" #include "Entities/EntityManager.h" #include "Graphics/Colour.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Logging.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "Ui.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "ViewportManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Engine/Ui/Rect.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <cassert> #include <cinttypes> using namespace OpenLoco; using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::Ui { Window::Window(Ui::Point32 position, Ui::Size32 size) : x(static_cast<int16_t>(position.x)) , y(static_cast<int16_t>(position.y)) , width(static_cast<uint16_t>(size.width)) , height(static_cast<uint16_t>(size.height)) , minWidth(static_cast<uint16_t>(size.width)) , maxWidth(static_cast<uint16_t>(size.width)) , minHeight(static_cast<uint16_t>(size.height)) , maxHeight(static_cast<uint16_t>(size.height)) { } bool Window::canResize() { return this->hasFlags(WindowFlags::resizable) && (this->minWidth != this->maxWidth || this->minHeight != this->maxHeight); } void Window::capSize(int32_t newMinWidth, int32_t newMinHeight, int32_t newMaxWidth, int32_t newMaxHeight) { auto w = this->width; auto h = this->height; auto shouldInvalidateBefore = false; auto shouldInvalidateAfter = false; if (w < newMinWidth) { w = newMinWidth; shouldInvalidateAfter = true; } if (h < newMinHeight) { h = newMinHeight; shouldInvalidateAfter = true; } if (w > newMaxWidth) { shouldInvalidateBefore = true; w = newMaxWidth; } if (h > newMaxHeight) { shouldInvalidateBefore = true; h = newMaxHeight; } if (shouldInvalidateBefore) { invalidate(); } this->width = w; this->height = h; this->minWidth = newMinWidth; this->minHeight = newMinHeight; this->maxWidth = newMaxWidth; this->maxHeight = newMaxHeight; if (shouldInvalidateAfter) { invalidate(); } } bool Window::isEnabled(WidgetIndex_t widgetIndex) { return (this->disabledWidgets & (1ULL << widgetIndex)) == 0; } bool Window::isDisabled(WidgetIndex_t widgetIndex) { return (this->disabledWidgets & (1ULL << widgetIndex)) != 0; } bool Window::isActivated(WidgetIndex_t index) { return (this->activatedWidgets & (1ULL << index)) != 0; } bool Window::isHoldable(WidgetIndex_t index) { return (this->holdableWidgets & (1ULL << index)) != 0; } // 0x0045FCE6 // Input: // regs.ax: x // regs.bx: y // regs.bp: z // Output: // {x: regs.ax, y: regs.bx} std::optional<World::Pos2> screenGetMapXyWithZ(const Point& mouse, const int16_t z) { Window* w = WindowManager::findAt(mouse.x, mouse.y); if (w == nullptr) { return std::nullopt; } Viewport* vp = w->viewports[0]; if (vp == nullptr) { return std::nullopt; } if (vp->containsUi(mouse)) { viewport_pos vpos = vp->screenToViewport(mouse); World::Pos2 position = viewportCoordToMapCoord(vpos.x, vpos.y, z, WindowManager::getCurrentRotation()); if (World::validCoords(position)) { return position; } } return std::nullopt; } // 0x0045FD41 // Input: // regs.ax: x // regs.bx: y // regs.bp: z // regs.edx: rotation // Output: // {x: regs.ax, y: regs.bx} // Note: in the original code: regs.dx: x/2 (probably not used anywhere) World::Pos2 viewportCoordToMapCoord(int16_t x, int16_t y, int16_t z, int32_t rotation) { constexpr uint8_t inverseRotationMapping[4] = { 0, 3, 2, 1 }; const auto result = World::Pos2(y - (x >> 1) + z, y + (x >> 1) + z); return Math::Vector::rotate(result, inverseRotationMapping[rotation]); } // 0x004C641F // regs.dl: underground // regs.esi: w // regs.edi: vp static void viewportSetUndergroundFlag(bool underground, Ui::Window* w, Ui::Viewport* vp) { if (w->type == WindowType::main) { return; } bool shouldInvalidate; if (!underground) { shouldInvalidate = !vp->hasFlags(ViewportFlags::underground_view); vp->flags &= ~ViewportFlags::underground_view; } else { shouldInvalidate = vp->hasFlags(ViewportFlags::underground_view); vp->flags |= ViewportFlags::underground_view; } if (shouldInvalidate) { w->invalidate(); } } void Window::viewportSetUndergroundFlag(bool underground, Ui::Viewport* vp) { Ui::viewportSetUndergroundFlag(underground, this, vp); } // 0x004C68E4 static void viewportMove(int16_t x, int16_t y, Ui::Window* w, Ui::Viewport* vp) { int origX = vp->viewX >> vp->zoom; int origY = vp->viewY >> vp->zoom; int newX = x >> vp->zoom; int newY = y >> vp->zoom; int diffX = origX - newX; int diffY = origY - newY; vp->viewX = x; vp->viewY = y; // If no change in viewing area if (diffX == 0 && diffY == 0) { return; } if (vp->hasFlags(ViewportFlags::seeThroughTracks | ViewportFlags::seeThroughScenery | ViewportFlags::seeThroughRoads | ViewportFlags::seeThroughBuildings | ViewportFlags::seeThroughTrees | ViewportFlags::seeThroughBridges) || w->hasFlags(WindowFlags::flag_8)) { auto rect = Ui::Rect(vp->x, vp->y, vp->width, vp->height); Gfx::render(rect); return; } uint8_t zoom = (1 << vp->zoom); Viewport backup = *vp; if (vp->x < 0) { vp->width += vp->x; vp->viewWidth += vp->x * zoom; vp->viewX -= vp->x * zoom; vp->x = 0; } int32_t eax = vp->x + vp->width - Ui::width(); if (eax > 0) { vp->width -= eax; vp->viewWidth -= eax * zoom; } if (vp->width <= 0) { *vp = backup; return; } if (vp->y < 0) { vp->height += vp->y; vp->viewHeight += vp->y * zoom; vp->viewY -= vp->y * zoom; vp->y = 0; } eax = vp->y + vp->height - Ui::height(); if (eax > 0) { vp->height -= eax; vp->viewHeight -= eax * zoom; } if (vp->height <= 0) { *vp = backup; return; } WindowManager::viewportShiftPixels(w, vp, diffX, diffY); *vp = backup; } // 0x004C6456 void Window::viewportsUpdatePosition() { for (int i = 0; i < 2; i++) { Viewport* viewport = this->viewports[i]; ViewportConfig* config = &this->viewportConfigurations[i]; if (viewport == nullptr) { continue; } viewport_pos centre; if (config->viewportTargetSprite != EntityId::null) { auto entity = EntityManager::get<EntityBase>(config->viewportTargetSprite); int z = (TileManager::getHeight(entity->position).landHeight) - 16; bool underground = (entity->position.z < z); viewportSetUndergroundFlag(underground, viewport); centre = viewport->centre2dCoordinates(entity->position + Pos3{ 0, 0, 12 }); } else { int16_t midX = config->savedViewX + (viewport->viewWidth / 2); int16_t midY = config->savedViewY + (viewport->viewHeight / 2); World::Pos2 mapCoord = viewportCoordToMapCoord(midX, midY, 128, viewport->getRotation()); viewportSetUndergroundFlag(false, viewport); bool atMapEdge = false; if (mapCoord.x < -256) { mapCoord.x = -256; atMapEdge = true; } if (mapCoord.y < -256) { mapCoord.y = -256; atMapEdge = true; } if (mapCoord.x > 0x30FE) { mapCoord.x = 0x30FE; atMapEdge = true; } if (mapCoord.y > 0x30FE) { mapCoord.y = 0x30FE; atMapEdge = true; } if (atMapEdge) { auto coord_2d = gameToScreen({ mapCoord.x, mapCoord.y, 128 }, viewport->getRotation()); config->savedViewX = coord_2d.x - viewport->viewWidth / 2; config->savedViewY = coord_2d.y - viewport->viewHeight / 2; } centre.x = config->savedViewX; centre.y = config->savedViewY; if (this->hasFlags(WindowFlags::scrollingToLocation)) { bool flippedX = false; centre.x -= viewport->viewX; if (centre.x < 0) { centre.x = -centre.x; flippedX = true; } bool flippedY = false; centre.y -= viewport->viewY; if (centre.y < 0) { centre.y = -centre.y; flippedY = true; } centre.x = (centre.x + 7) / 8; // ceil(centreX / 8.0); centre.y = (centre.y + 7) / 8; // ceil(centreX / 8.0); if (centre.x == 0 && centre.y == 0) { this->flags &= ~WindowFlags::scrollingToLocation; } if (flippedX) { centre.x = -centre.x; } if (flippedY) { centre.y = -centre.y; } centre.x += viewport->viewX; centre.y += viewport->viewY; } } viewportMove(centre.x, centre.y, this, viewport); } } // 0x004C99B9 void Window::invalidatePressedImageButtons() { WidgetIndex_t pressedWidgetIndex = kWidgetIndexNull; if (Input::isPressed(type, number) || Input::isDropdownActive(type, number)) { pressedWidgetIndex = Input::getPressedWidgetIndex(); } int16_t toolWidgetIndex = -1; if (ToolManager::isToolActive(type, number)) { toolWidgetIndex = ToolManager::getToolWidgetIndex(); } WidgetIndex_t widx{}; for (auto& widget : widgets) { const bool activated = isActivated(widx); // This might be the remap flag, not entirely sure. const bool hasBit31 = (widget.content & (1U << 31)) != 0; if ((widget.type == WidgetType::slider || widget.type == WidgetType::wt_3) && hasBit31) { if (activated || pressedWidgetIndex == widx || toolWidgetIndex == widx) { Gfx::invalidateRegion( x + widget.left, y + widget.top, x + widget.right + 1, y + widget.bottom + 1); } } widx++; } } // 0x004CA4BD // input: regs.esi - window (this) void Window::invalidate() { Gfx::invalidateRegion(x, y, x + width, y + height); } // 0x004CA115 void Window::updateScrollWidgets() { uint32_t s = 0; WidgetIndex_t widx = -1; for (auto& widget : widgets) { widx++; if (widget.type != WidgetType::scrollview) { continue; } int32_t scrollWidth = 0, scrollHeight = 0; this->callGetScrollSize(s, scrollWidth, scrollHeight); bool invalidate = false; if (widget.content & Scrollbars::horizontal) { if (this->scrollAreas[s].contentWidth != scrollWidth + 1) { this->scrollAreas[s].contentWidth = scrollWidth + 1; invalidate = true; } } if (widget.content & Scrollbars::vertical) { if (this->scrollAreas[s].contentHeight != scrollHeight + 1) { this->scrollAreas[s].contentHeight = scrollHeight + 1; invalidate = true; } } if (invalidate) { Ui::ScrollView::updateThumbs(*this, widx); this->invalidate(); } s++; } } // 0x004CA17F void Window::initScrollWidgets() { uint32_t s = 0; WidgetIndex_t widx = -1; for (auto& widget : widgets) { widx++; if (widget.type != WidgetType::scrollview) { continue; } this->scrollAreas[s].flags = ScrollFlags::none; int32_t scrollWidth = 0, scrollHeight = 0; this->callGetScrollSize(s, scrollWidth, scrollHeight); this->scrollAreas[s].contentOffsetX = 0; this->scrollAreas[s].contentWidth = scrollWidth + 1; this->scrollAreas[s].contentOffsetY = 0; this->scrollAreas[s].contentHeight = scrollHeight + 1; if (widget.content & Scrollbars::horizontal) { this->scrollAreas[s].flags |= Ui::ScrollFlags::hscrollbarVisible; } if (widget.content & Scrollbars::vertical) { this->scrollAreas[s].flags |= Ui::ScrollFlags::vscrollbarVisible; } Ui::ScrollView::updateThumbs(*this, widx); s++; } } int8_t Window::getScrollDataIndex(WidgetIndex_t targetIndex) { if (widgets[targetIndex].type != WidgetType::scrollview) { assert(false); return -1; } auto widgetIndex = 0; auto scrollIndex = 0; for (auto& widget : widgets) { widgetIndex++; if (widgetIndex == targetIndex) { return scrollIndex; } if (widget.type == WidgetType::scrollview) { scrollIndex++; } } assert(false); return -2; } // 0x004CC7CB void Window::setDisabledWidgetsAndInvalidate(uint32_t _disabledWidgets) { const auto oldDisabled = disabledWidgets; if (oldDisabled == _disabledWidgets) { return; } disabledWidgets = _disabledWidgets; auto changedWidgets = oldDisabled ^ _disabledWidgets; for (auto widx = Numerics::bitScanForward(changedWidgets); widx != -1; widx = Numerics::bitScanForward(changedWidgets)) { changedWidgets &= ~(1ULL << widx); WindowManager::invalidateWidget(type, number, widx); } } // 0x004C6801 void Window::moveWindowToLocation(viewport_pos pos) { if (this->viewportConfigurations->viewportTargetSprite != EntityId::null) { return; } if (this->hasFlags(WindowFlags::viewportNoScrolling)) { return; } this->viewportConfigurations->savedViewX = pos.x; this->viewportConfigurations->savedViewY = pos.y; this->flags |= WindowFlags::scrollingToLocation; } // 0x004C6827 void Window::viewportCentreOnTile(const World::Pos3& loc) { auto viewport = this->viewports[0]; if (viewport == nullptr) { return; } auto tileHeight = TileManager::getHeight(loc).landHeight; tileHeight -= 16; if (loc.z < tileHeight) { if (!viewport->hasFlags(ViewportFlags::underground_view)) { this->invalidate(); } viewport->flags |= ViewportFlags::underground_view; } else { if (viewport->hasFlags(ViewportFlags::underground_view)) { this->invalidate(); } viewport->flags &= ~ViewportFlags::underground_view; } auto pos = gameToScreen(loc, WindowManager::getCurrentRotation()); pos.x -= viewport->viewWidth / 2; pos.y -= viewport->viewHeight / 2; moveWindowToLocation(pos); } // Centres the main viewport on this window's saved view. void Window::viewportCentreMain() const { if (viewports[0] == nullptr || savedView.isEmpty()) { return; } auto main = WindowManager::getMainWindow(); // Unfocus the viewport. Ui::Windows::Main::viewportFocusOnEntity(*main, EntityId::null); // Centre viewport on tile/entity. if (savedView.isEntityView()) { auto entity = EntityManager::get<EntityBase>(savedView.entityId); main->viewportCentreOnTile(entity->position); } else { main->viewportCentreOnTile(savedView.getPos()); } } void Window::viewportZoomSet(int8_t zoomLevel, bool toCursor) { Viewport* v = this->viewports[0]; ViewportConfig* vc = &this->viewportConfigurations[0]; zoomLevel = std::clamp<int8_t>(zoomLevel, 0, 3); if (v->zoom == zoomLevel) { return; } const auto previousZoomLevel = v->zoom; // Zoom in while (v->zoom > zoomLevel) { v->zoom--; vc->savedViewX += v->viewWidth / 4; vc->savedViewY += v->viewHeight / 4; v->viewWidth /= 2; v->viewHeight /= 2; } // Zoom out while (v->zoom < zoomLevel) { v->zoom++; vc->savedViewX -= v->viewWidth / 2; vc->savedViewY -= v->viewHeight / 2; v->viewWidth *= 2; v->viewHeight *= 2; } if (toCursor && Config::get().zoomToCursor) { const auto mouseCoords = Ui::getCursorPosScaled() - Point32(v->x, v->y); const int32_t diffX = mouseCoords.x - ((v->viewWidth >> zoomLevel) / 2); const int32_t diffY = mouseCoords.y - ((v->viewHeight >> zoomLevel) / 2); if (previousZoomLevel > zoomLevel) { vc->savedViewX += diffX << zoomLevel; vc->savedViewY += diffY << zoomLevel; } else { vc->savedViewX -= diffX << previousZoomLevel; vc->savedViewY -= diffY << previousZoomLevel; } } v->viewX = vc->savedViewX; v->viewY = vc->savedViewY; this->invalidate(); } // 0x0045EFDB void Window::viewportZoomIn(bool toCursor) { if (this->viewports[0] == nullptr) { return; } this->viewportZoomSet(this->viewports[0]->zoom - 1, toCursor); } // 0x0045F015 void Window::viewportZoomOut(bool toCursor) { if (this->viewports[0] == nullptr) { return; } this->viewportZoomSet(this->viewports[0]->zoom + 1, toCursor); } // 0x0045F04F void Window::viewportRotateRight() { viewportRotate(true); } // 0x0045F0ED void Window::viewportRotateLeft() { viewportRotate(false); } void Window::viewportRotate(bool directionRight) { auto* viewport = viewports[0]; if (viewport == nullptr) { return; } const auto uiCentre = viewport->getUiCentre(); auto res = ViewportInteraction::getSurfaceLocFromUi(uiCentre); World::Pos3 target = [&]() { if (!res.has_value() || res->second != viewport) { const auto centre = viewport->getCentreMapPosition(); const auto height = World::TileManager::getHeight(centre).landHeight; return World::Pos3{ centre, height }; } else { auto height = World::TileManager::getHeight(res->first); return World::Pos3{ res->first.x, res->first.y, height.landHeight }; } }(); viewport->setRotation((viewport->getRotation() + (directionRight ? 1 : -1)) & 3); const auto newCentre = viewport->centre2dCoordinates(target); viewportConfigurations->savedViewX = newCentre.x; viewportConfigurations->savedViewY = newCentre.y; viewport->viewX = newCentre.x; viewport->viewY = newCentre.y; invalidate(); WindowManager::callViewportRotateEventOnAllWindows(); EntityManager::updateSpatialIndex(); } void Window::viewportRemove(const uint8_t viewportId) { if (auto* vp = viewports[viewportId]; vp != nullptr) { ViewportManager::destroy(vp); viewports[viewportId] = nullptr; } } // 0x004421FB void Window::viewportFromSavedView(const SavedViewSimple& newSavedView) { auto viewport = viewports[0]; if (viewport != nullptr) { auto& config = viewportConfigurations[0]; config.viewportTargetSprite = EntityId::null; config.savedViewX = newSavedView.viewX; config.savedViewY = newSavedView.viewY; auto zoom = static_cast<int32_t>(newSavedView.zoomLevel) - viewport->zoom; if (zoom != 0) { if (zoom < 0) { zoom = -zoom; viewport->viewWidth >>= zoom; viewport->viewHeight >>= zoom; } else { viewport->viewWidth <<= zoom; viewport->viewHeight <<= zoom; } } viewport->zoom = zoom; viewport->setRotation(newSavedView.rotation); config.savedViewX -= viewport->viewWidth / 2; config.savedViewY -= viewport->viewHeight / 2; } } bool Window::move(int16_t dx, int16_t dy) { if (dx == 0 && dy == 0) { return false; } this->invalidate(); this->x += dx; this->y += dy; if (this->viewports[0] != nullptr) { this->viewports[0]->x += dx; this->viewports[0]->y += dy; } if (this->viewports[1] != nullptr) { this->viewports[1]->x += dx; this->viewports[1]->y += dy; } this->invalidate(); return true; } // 0x004CD320 void Window::moveInsideScreenEdges() { Ui::Point offset = { 0, 0 }; const int16_t xOvershoot = this->x + this->width - Ui::width(); // Over the edge on the right? if (xOvershoot > 0) { offset.x -= xOvershoot; } // If not, on the left? if (this->x < 0) { offset.x -= this->x; } const int16_t yOvershoot = this->y + this->height - (Ui::height() - 27); // Over the edge at the bottom? if (yOvershoot > 0) { offset.y -= yOvershoot; } // Maybe at the top? if (this->y - 28 < 0) { offset.y -= this->y - 28; } if (offset == Ui::Point(0, 0)) { return; } this->invalidate(); this->x += offset.x; this->y += offset.y; this->invalidate(); if (this->viewports[0] != nullptr) { this->viewports[0]->x += offset.x; this->viewports[0]->y += offset.y; } if (this->viewports[1] != nullptr) { this->viewports[1]->x += offset.x; this->viewports[1]->y += offset.y; } } bool Window::moveToCentre() { int16_t dx = ((Ui::width() - this->width) / 2); int16_t dy = ((Ui::height() - this->height) / 2); dx = dx - this->x; dy = dy - this->y; return this->move(dx, dy); } // 0x004C9513 WidgetIndex_t Window::findWidgetAt(int16_t xPos, int16_t yPos) { this->callPrepareDraw(); WidgetIndex_t activeWidget = kWidgetIndexNull; WidgetIndex_t widgetIndex = kWidgetIndexNull; for (auto& widget : widgets) { widgetIndex++; if (widget.type == WidgetType::empty || widget.hidden) { continue; } if (xPos < this->x + widget.left) { continue; } if (xPos > this->x + widget.right) { continue; } if (yPos < this->y + widget.top) { continue; } if (yPos > this->y + widget.bottom) { continue; } activeWidget = widgetIndex; } if (activeWidget == kWidgetIndexNull) { return kWidgetIndexNull; } if (this->widgets[activeWidget].type == WidgetType::combobox) { activeWidget++; } return activeWidget; } void Window::callClose() { if (eventHandlers->onClose == nullptr) { return; } eventHandlers->onClose(*this); } void Window::callOnPeriodicUpdate() { if (eventHandlers->onPeriodicUpdate == nullptr) { return; } eventHandlers->onPeriodicUpdate(*this); } void Window::callUpdate() { if (eventHandlers->onUpdate == nullptr) { return; } eventHandlers->onUpdate(*this); } void Window::call_8() { if (eventHandlers->event_08 == nullptr) { return; } eventHandlers->event_08(*this); } void Window::call_9() { if (eventHandlers->event_09 == nullptr) { return; } eventHandlers->event_09(*this); } void Window::callToolUpdate(WidgetIndex_t widgetIndex, const WidgetId id, int16_t xPos, int16_t yPos) { if (eventHandlers->onToolUpdate == nullptr) { return; } eventHandlers->onToolUpdate(*this, widgetIndex, id, xPos, yPos); } void Window::callToolDown(WidgetIndex_t widgetIndex, const WidgetId id, int16_t xPos, int16_t yPos) { if (eventHandlers->onToolDown == nullptr) { return; } eventHandlers->onToolDown(*this, widgetIndex, id, xPos, yPos); } void Window::callToolDrag(const WidgetIndex_t widgetIndex, const WidgetId id, const int16_t xPos, const int16_t yPos) { if (eventHandlers->toolDrag == nullptr) { return; } eventHandlers->toolDrag(*this, widgetIndex, id, xPos, yPos); } void Window::callToolUp(const WidgetIndex_t widgetIndex, const WidgetId id, const int16_t xPos, const int16_t yPos) { if (eventHandlers->toolUp == nullptr) { return; } eventHandlers->toolUp(*this, widgetIndex, id, xPos, yPos); } void Window::callToolAbort(WidgetIndex_t widgetIndex, const WidgetId id) { if (eventHandlers->onToolAbort == nullptr) { return; } eventHandlers->onToolAbort(*this, widgetIndex, id); } Ui::CursorId Window::callToolCursor(int16_t xPos, int16_t yPos, Ui::CursorId fallback, bool* out) { if (eventHandlers->toolCursor == nullptr) { return fallback; } return eventHandlers->toolCursor(*this, xPos, yPos, fallback, *out); } Ui::CursorId Window::callCursor(WidgetIndex_t widgetIdx, const WidgetId id, int16_t xPos, int16_t yPos, Ui::CursorId fallback) { if (eventHandlers->cursor == nullptr) { return fallback; } return eventHandlers->cursor(*this, widgetIdx, id, xPos, yPos, fallback); } void Window::callOnMouseUp(WidgetIndex_t widgetIndex, const WidgetId id) { if (eventHandlers->onMouseUp == nullptr) { return; } eventHandlers->onMouseUp(*this, widgetIndex, id); } Ui::Window* Window::callOnResize() { if (eventHandlers->onResize == nullptr) { return this; } eventHandlers->onResize(*this); return this; } void Window::callOnMouseHover(WidgetIndex_t widgetIndex, const WidgetId id) { if (eventHandlers->onMouseHover == nullptr) { return; } eventHandlers->onMouseHover(*this, widgetIndex, id); } void Window::callOnMouseDown(WidgetIndex_t widgetIndex, const WidgetId id) { if (eventHandlers->onMouseDown == nullptr) { return; } eventHandlers->onMouseDown(*this, widgetIndex, id); } void Window::callOnDropdown(WidgetIndex_t widgetIndex, const WidgetId id, int16_t itemIndex) { if (eventHandlers->onDropdown == nullptr) { return; } eventHandlers->onDropdown(*this, widgetIndex, id, itemIndex); } void Window::callGetScrollSize(uint32_t scrollIndex, int32_t& scrollWidth, int32_t& scrollHeight) { if (eventHandlers->getScrollSize == nullptr) { return; } eventHandlers->getScrollSize(*this, scrollIndex, scrollWidth, scrollHeight); } void Window::callScrollMouseDown(int16_t xPos, int16_t yPos, uint8_t scrollIndex) { if (eventHandlers->scrollMouseDown == nullptr) { return; } this->eventHandlers->scrollMouseDown(*this, xPos, yPos, scrollIndex); } void Window::callScrollMouseDrag(int16_t xPos, int16_t yPos, uint8_t scrollIndex) { if (eventHandlers->scrollMouseDrag == nullptr) { return; } this->eventHandlers->scrollMouseDrag(*this, xPos, yPos, scrollIndex); } void Window::callScrollMouseOver(int16_t xPos, int16_t yPos, uint8_t scrollIndex) { if (eventHandlers->scrollMouseOver == nullptr) { return; } this->eventHandlers->scrollMouseOver(*this, xPos, yPos, scrollIndex); } void Window::callTextInput(WidgetIndex_t caller, const WidgetId id, const char* buffer) { if (eventHandlers->textInput == nullptr) { return; } this->eventHandlers->textInput(*this, caller, id, buffer); } void Window::callViewportRotate() { if (eventHandlers->viewportRotate == nullptr) { return; } this->eventHandlers->viewportRotate(*this); } std::optional<FormatArguments> Window::callTooltip(WidgetIndex_t widgetIndex, const WidgetId id) { // We only return std::nullopt when required by the tooltip function if (eventHandlers->tooltip == nullptr) { return FormatArguments(); } return eventHandlers->tooltip(*this, widgetIndex, id); } void Window::callOnMove(int16_t xPos, int16_t yPos) { if (eventHandlers->onMove == nullptr) { return; } this->eventHandlers->onMove(*this, xPos, yPos); } void Window::callPrepareDraw() { if (eventHandlers->prepareDraw == nullptr) { return; } eventHandlers->prepareDraw(*this); } void Window::callDraw(Gfx::DrawingContext& ctx) { if (eventHandlers->draw == nullptr) { return; } eventHandlers->draw(*this, ctx); } void Window::callDrawScroll(Gfx::DrawingContext& drawingCtx, uint32_t scrollIndex) { if (eventHandlers->drawScroll == nullptr) { return; } eventHandlers->drawScroll(*this, drawingCtx, scrollIndex); } bool Window::callKeyUp(uint32_t charCode, uint32_t keyCode) { if (eventHandlers->keyUp == nullptr) { return false; } return eventHandlers->keyUp(*this, charCode, keyCode); } // 0x004CA4DF void Window::draw(Gfx::DrawingContext& drawingCtx) { if (this->hasFlags(WindowFlags::transparent) && !this->hasFlags(WindowFlags::noBackground)) { drawingCtx.fillRect(this->x, this->y, this->x + this->width - 1, this->y + this->height - 1, enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); } uint64_t pressedWidget = 0; if (Input::state() == Input::State::dropdownActive || Input::state() == Input::State::widgetPressed) { if (Input::isPressed(type, number)) { const WidgetIndex_t widgetIndex = Input::getPressedWidgetIndex(); pressedWidget = 1ULL << widgetIndex; } } uint64_t tool_widget = 0; if (ToolManager::isToolActive(this->type, this->number)) { tool_widget = 1ULL << ToolManager::getToolWidgetIndex(); } uint64_t hovered_widget = 0; if (Input::isHovering(this->type, this->number)) { hovered_widget = 1ULL << Input::getHoveredWidgetIndex(); } uint8_t scrollviewIndex = 0; for (auto& widget : widgets) { widget.draw(drawingCtx, this, pressedWidget, tool_widget, hovered_widget, scrollviewIndex); // FIXME: This is ugly and error prone, put the ScrollArea data in the widget, // previously it was passed as reference to draw where it incremented it. if (widget.type == WidgetType::scrollview) { scrollviewIndex++; } } if (this->hasFlags(WindowFlags::whiteBorderMask)) { drawingCtx.fillRectInset( this->x, this->y, this->x + this->width - 1, this->y + this->height - 1, Colour::white, Gfx::RectInsetFlags::fillNone); } } WidgetIndex_t Window::firstActivatedWidgetInRange(WidgetIndex_t minIndex, WidgetIndex_t maxIndex) { WidgetIndex_t activeIndex = kWidgetIndexNull; for (WidgetIndex_t i = minIndex; i <= maxIndex; i++) { if (this->isActivated(i)) { activeIndex = i; break; } } return activeIndex; } WidgetIndex_t Window::prevAvailableWidgetInRange(WidgetIndex_t minIndex, WidgetIndex_t maxIndex) { WidgetIndex_t activeIndex = firstActivatedWidgetInRange(minIndex, maxIndex); if (activeIndex == -1) { return activeIndex; } // Offset, wrapping around if needed. activeIndex -= 1; if (activeIndex < minIndex) { activeIndex = maxIndex; } for (WidgetIndex_t i = activeIndex; i >= minIndex; i--) { if (this->isDisabled(i) || this->widgets[i].type == WidgetType::empty || this->widgets[i].hidden) { // Wrap around (while compensating for next iteration) if (i == minIndex) { i = maxIndex + 1; } continue; } return i; } return -1; } WidgetIndex_t Window::nextAvailableWidgetInRange(WidgetIndex_t minIndex, WidgetIndex_t maxIndex) { WidgetIndex_t activeIndex = firstActivatedWidgetInRange(minIndex, maxIndex); if (activeIndex == kWidgetIndexNull) { return activeIndex; } // Offset, wrapping around if needed. activeIndex += 1; if (activeIndex > maxIndex) { activeIndex = minIndex; } for (WidgetIndex_t i = activeIndex; i <= maxIndex; i++) { if (this->isDisabled(i) || this->widgets[i].type == WidgetType::empty || this->widgets[i].hidden) { // Wrap around (while compensating for next iteration) if (i == maxIndex) { i = minIndex - 1; } continue; } return i; } return -1; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Window.h ```h #pragma once #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Map/Tile.h" #include "Objects/Object.h" #include "Types.hpp" #include "Ui.h" #include "Ui/ScrollFlags.hpp" #include "Ui/Widget.h" #include "Ui/WindowType.h" #include "Viewport.hpp" #include "World/Company.h" #include "ZoomLevel.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <algorithm> #include <optional> #include <sfl/small_vector.hpp> namespace OpenLoco::Gfx { class DrawingContext; } namespace OpenLoco::Ui { using WindowNumber_t = uint16_t; struct Window; struct Viewport; enum class WindowColour : uint8_t { primary, secondary, tertiary, quaternary, count }; enum class WindowFlags : uint32_t { none = 0U, stickToBack = 1U << 0, stickToFront = 1U << 1, viewportNoScrolling = 1U << 2, scrollingToLocation = 1U << 3, transparent = 1U << 4, noBackground = 1U << 5, flag_6 = 1U << 6, flag_7 = 1U << 7, flag_8 = 1U << 8, resizable = 1U << 9, noAutoClose = 1U << 10, flag_11 = 1U << 11, flag_12 = 1U << 12, openQuietly = 1U << 13, notScrollView = 1U << 14, flag_15 = 1U << 15, flag_16 = 1U << 16, whiteBorderOne = 1U << 17, whiteBorderMask = whiteBorderOne | (1U << 18), flag_19 = 1U << 19, flag_31 = 1U << 31, }; OPENLOCO_ENABLE_ENUM_OPERATORS(WindowFlags); struct WindowEventList { void (*onClose)(Window&) = nullptr; void (*onMouseUp)(Window&, WidgetIndex_t, WidgetId) = nullptr; void (*onResize)(Window&) = nullptr; void (*onMouseHover)(Window&, WidgetIndex_t, WidgetId) = nullptr; void (*onMouseDown)(Window&, WidgetIndex_t, WidgetId) = nullptr; void (*onDropdown)(Window&, WidgetIndex_t, WidgetId, int16_t) = nullptr; void (*onPeriodicUpdate)(Window&) = nullptr; void (*onUpdate)(Window&) = nullptr; void (*event_08)(Window&) = nullptr; void (*event_09)(Window&) = nullptr; void (*onToolUpdate)(Window&, const WidgetIndex_t, WidgetId, const int16_t, const int16_t) = nullptr; void (*onToolDown)(Window&, const WidgetIndex_t, WidgetId, const int16_t, const int16_t) = nullptr; void (*toolDrag)(Window&, const WidgetIndex_t, WidgetId, const int16_t, const int16_t) = nullptr; void (*toolUp)(Window&, const WidgetIndex_t, WidgetId, const int16_t, const int16_t) = nullptr; void (*onToolAbort)(Window&, const WidgetIndex_t, WidgetId) = nullptr; Ui::CursorId (*toolCursor)(Window&, const int16_t x, const int16_t y, const Ui::CursorId, bool&) = nullptr; void (*getScrollSize)(Window&, uint32_t scrollIndex, int32_t& scrollWidth, int32_t& scrollHeight) = nullptr; void (*scrollMouseDown)(Ui::Window&, int16_t x, int16_t y, uint8_t scrollIndex) = nullptr; void (*scrollMouseDrag)(Ui::Window&, int16_t x, int16_t y, uint8_t scrollIndex) = nullptr; void (*scrollMouseOver)(Ui::Window& window, int16_t x, int16_t y, uint8_t scrollIndex) = nullptr; void (*textInput)(Window&, WidgetIndex_t, WidgetId, const char*) = nullptr; void (*viewportRotate)(Window&) = nullptr; uint32_t event_22{}; std::optional<FormatArguments> (*tooltip)(Window&, WidgetIndex_t, WidgetId) = nullptr; Ui::CursorId (*cursor)(Window&, WidgetIndex_t, WidgetId, int16_t, int16_t, Ui::CursorId) = nullptr; void (*onMove)(Window&, const int16_t x, const int16_t y) = nullptr; void (*prepareDraw)(Window&) = nullptr; void (*draw)(Window&, Gfx::DrawingContext&) = nullptr; void (*drawScroll)(Window&, Gfx::DrawingContext&, const uint32_t scrollIndex) = nullptr; bool (*keyUp)(Window&, uint32_t charCode, uint32_t keyCode) = nullptr; }; struct SavedViewSimple { coord_t viewX; coord_t viewY; ZoomLevel zoomLevel; int8_t rotation; }; struct SavedView { coord_t mapX{ -1 }; coord_t mapY{ -1 }; EntityId entityId{ EntityId::null }; uint16_t flags{}; ZoomLevel zoomLevel{}; int8_t rotation{}; int16_t surfaceZ{}; constexpr SavedView() = default; constexpr SavedView(coord_t mapX, coord_t mapY, ZoomLevel zoomLevel, int8_t rotation, coord_t surfaceZ) : mapX(mapX) , mapY(mapY) , zoomLevel(zoomLevel) , rotation(rotation) , surfaceZ(surfaceZ) {}; constexpr SavedView(EntityId entityId, uint16_t flags, ZoomLevel zoomLevel, int8_t rotation, coord_t surfaceZ) : entityId(entityId) , flags(flags) , zoomLevel(zoomLevel) , rotation(rotation) , surfaceZ(surfaceZ) {}; constexpr bool isEmpty() const { return mapX == -1 && mapY == -1 && entityId == EntityId::null; } constexpr bool isEntityView() const { return (flags & (1 << 15)) != 0; } constexpr World::Pos3 getPos() const { if (isEntityView()) { return {}; } return { mapX, mapY, surfaceZ }; } constexpr void clear() { mapX = -1; mapY = -1; entityId = EntityId::null; } auto operator<=>(const SavedView& other) const = default; }; struct Window { static constexpr size_t kMaxScrollAreas = 2; sfl::small_vector<Widget, 16> widgets; const WindowEventList* eventHandlers; uint64_t disabledWidgets = 0; uint64_t activatedWidgets = 0; uint64_t holdableWidgets = 0; union { std::byte* object; struct { int16_t var_85A; int16_t var_85C; }; uintptr_t info; }; Ui::Viewport* viewports[2] = { nullptr, nullptr }; SavedView savedView; int16_t expandContentCounter = 0; // Used to delay content expand when hovering over expandable scroll content bool showTownNames = false; // Map window only WindowFlags flags; WindowNumber_t number = 0; int16_t x; int16_t y; uint16_t width; uint16_t height; uint16_t minWidth; uint16_t maxWidth; uint16_t minHeight; uint16_t maxHeight; ScrollArea scrollAreas[kMaxScrollAreas]; int16_t rowInfo[1000]; uint16_t rowCount; uint16_t var_83C; uint16_t rowHeight; int16_t rowHover = -1; union { int16_t orderTableIndex = -1; int16_t selectedTileIndex; }; uint16_t sortMode; uint16_t var_846 = 0; uint16_t var_850 = 0; uint16_t var_852 = 0; uint16_t var_854 = 0; // used to limit updates union { uint16_t filterLevel; // ObjectSelectionWindow uint16_t numTicksVisible; // TimePanel }; uint16_t var_858 = 0; uint16_t currentTab = 0; uint16_t frameNo = 0; uint16_t currentSecondaryTab = 0; int16_t var_88A; int16_t var_88C; ViewportConfig viewportConfigurations[2]; WindowType type; CompanyId owner = CompanyId::null; uint8_t var_885 = 0xFF; AdvancedColour colours[enumValue(WindowColour::count)]; Window(Ui::Point32 position, Ui::Size32 size); // TODO: Remove this once position is a member. constexpr Ui::Point position() const { return { x, y }; } // TODO: Remove this once size is a member. constexpr Ui::Size size() const { return { width, height }; } void setWidgets(std::span<const Widget> newWidgets) { widgets.clear(); widgets.insert(widgets.end(), newWidgets.begin(), newWidgets.end()); } constexpr bool setSize(Ui::Size32 minSize, Ui::Size32 maxSize) { bool hasResized = false; minWidth = minSize.width; minHeight = minSize.height; maxWidth = maxSize.width; maxHeight = maxSize.height; if (width < minWidth) { width = minWidth; invalidate(); hasResized = true; } else if (width > maxWidth) { width = maxWidth; invalidate(); hasResized = true; } if (height < minHeight) { height = minHeight; invalidate(); hasResized = true; } else if (height > maxHeight) { height = maxHeight; invalidate(); hasResized = true; } return hasResized; } constexpr void setSize(Ui::Size32 size) { setSize(size, size); } constexpr AdvancedColour getColour(WindowColour index) const { if (index >= WindowColour::primary && index < WindowColour::count) { return colours[enumValue(index)]; } return colours[enumValue(WindowColour::primary)]; } constexpr void setColour(WindowColour index, AdvancedColour colour) { if (index >= WindowColour::primary && index < WindowColour::count) { colours[enumValue(index)] = colour; } } constexpr bool hasFlags(WindowFlags flagsToTest) const { return (flags & flagsToTest) != WindowFlags::none; } bool isVisible() { return true; } bool isTranslucent() { return this->hasFlags(WindowFlags::transparent); } bool isEnabled(WidgetIndex_t widgetIndex); bool isDisabled(WidgetIndex_t widgetIndex); bool isActivated(WidgetIndex_t index); bool isHoldable(WidgetIndex_t index); bool canResize(); void capSize(int32_t minWidth, int32_t minHeight, int32_t maxWidth, int32_t maxHeight); void viewportsUpdatePosition(); void invalidatePressedImageButtons(); void invalidate(); void updateScrollWidgets(); void initScrollWidgets(); int8_t getScrollDataIndex(WidgetIndex_t index); void setDisabledWidgetsAndInvalidate(uint32_t _disabledWidgets); void viewportCentreMain() const; void viewportSetUndergroundFlag(bool underground, Ui::Viewport* vp); void viewportGetMapCoordsByCursor(int16_t* mapX, int16_t* mapY, int16_t* offsetX, int16_t* offsetY); void moveWindowToLocation(viewport_pos pos); void viewportCentreOnTile(const World::Pos3& loc); void viewportCentreTileAroundCursor(int16_t mapX, int16_t mapY, int16_t offsetX, int16_t offsetY); void viewportZoomSet(int8_t zoomLevel, bool toCursor); void viewportZoomIn(bool toCursor); void viewportZoomOut(bool toCursor); void viewportRotateRight(); void viewportRotateLeft(); void viewportRotate(bool directionRight); void viewportRemove(const uint8_t viewportId); void viewportFromSavedView(const SavedViewSimple& savedView); bool move(int16_t dx, int16_t dy); void moveInsideScreenEdges(); bool moveToCentre(); WidgetIndex_t findWidgetAt(int16_t xPos, int16_t yPos); void draw(Gfx::DrawingContext& drawingCtx); void callClose(); // 0 void callOnMouseUp(WidgetIndex_t widgetIndex, WidgetId id); // 1 Ui::Window* callOnResize(); // 2 void callOnMouseHover(WidgetIndex_t widgetIndex, WidgetId id); // 3 void callOnMouseDown(WidgetIndex_t widgetIndex, WidgetId id); // 4 void callOnDropdown(WidgetIndex_t widgetIndex, WidgetId id, int16_t itemIndex); // 5 void callOnPeriodicUpdate(); // 6 void callUpdate(); // 7 void call_8(); // 8 void call_9(); // 9 void callToolUpdate(WidgetIndex_t widgetIndex, WidgetId id, int16_t xPos, int16_t yPos); // 10 void callToolDown(WidgetIndex_t widgetIndex, WidgetId id, int16_t xPos, int16_t yPos); // 11 void callToolDrag(WidgetIndex_t widgetIndex, WidgetId id, const int16_t xPos, const int16_t yPos); // 12 void callToolUp(WidgetIndex_t widgetIndex, WidgetId id, const int16_t xPos, const int16_t yPos); // 13 void callToolAbort(WidgetIndex_t widgetIndex, WidgetId id); // 14 Ui::CursorId callToolCursor(int16_t xPos, int16_t yPos, Ui::CursorId fallback, bool* out); // 15 void callGetScrollSize(uint32_t scrollIndex, int32_t& scrollWidth, int32_t& scrollHeight); // 16 void callScrollMouseDown(int16_t x, int16_t y, uint8_t scrollIndex); // 17 void callScrollMouseDrag(int16_t x, int16_t y, uint8_t scrollIndex); // 18 void callScrollMouseOver(int16_t x, int16_t y, uint8_t scrollIndex); // 19 void callTextInput(WidgetIndex_t caller, WidgetId id, const char* buffer); // 20 void callViewportRotate(); // 21 std::optional<FormatArguments> callTooltip(WidgetIndex_t widgetIndex, WidgetId id); // 23 Ui::CursorId callCursor(WidgetIndex_t widgetIdx, WidgetId id, int16_t xPos, int16_t yPos, Ui::CursorId fallback); // 24 void callOnMove(int16_t xPos, int16_t yPos); // 25 void callPrepareDraw(); // 26 void callDraw(Gfx::DrawingContext& ctx); // 27 void callDrawScroll(Gfx::DrawingContext& drawingCtx, uint32_t scrollIndex); // 28 bool callKeyUp(uint32_t charCode, uint32_t keyCode); // 29 WidgetIndex_t firstActivatedWidgetInRange(WidgetIndex_t minIndex, WidgetIndex_t maxIndex); WidgetIndex_t prevAvailableWidgetInRange(WidgetIndex_t minIndex, WidgetIndex_t maxIndex); WidgetIndex_t nextAvailableWidgetInRange(WidgetIndex_t minIndex, WidgetIndex_t maxIndex); }; World::Pos2 viewportCoordToMapCoord(int16_t x, int16_t y, int16_t z, int32_t rotation); std::optional<World::Pos2> screenGetMapXyWithZ(const Point& mouse, const int16_t z); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/WindowManager.cpp ```cpp #include "WindowManager.h" #include "Audio/Audio.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Intro.h" #include "Logging.h" #include "Map/MapSelection.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "MultiPlayer.h" #include "OpenLoco.h" #include "SceneManager.h" #include "ScrollView.h" #include "ToolTip.h" #include "Tutorial.h" #include "Ui.h" #include "Ui/ToolManager.h" #include "Ui/Windows/Construction/Construction.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" #include "Widget.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <algorithm> #include <array> #include <cinttypes> #include <memory> #include <sfl/static_vector.hpp> namespace OpenLoco::Ui::WindowManager { static constexpr size_t kMaxWindows = 64; static uint16_t _thousandthTickCounter; // 0x0052334E static WindowType _currentModalType = WindowType::undefined; // 0x005233B6 static int32_t _currentRotation; // 0x00E3F0B8 static sfl::static_vector<Window, kMaxWindows> _windows; static std::array<AdvancedColour, enumValue(WindowColour::count)> _windowColours; static void viewportRedrawAfterShift(Window* window, Viewport* viewport, int16_t x, int16_t y); void init() { _windows.clear(); } Window* get(size_t index) { return &_windows[index]; } size_t indexOf(const Window& pWindow) { return &pWindow - _windows.data(); } size_t count() { return _windows.size(); } void setWindowColours(WindowColour slot, AdvancedColour colour) { const auto index = static_cast<size_t>(slot); assert(index < _windowColours.size()); _windowColours[index] = colour; } AdvancedColour getWindowColour(WindowColour slot) { const auto index = static_cast<size_t>(slot); assert(index < _windowColours.size()); return _windowColours[index]; } WindowType getCurrentModalType() { return _currentModalType; } void setCurrentModalType(WindowType type) { _currentModalType = type; } void resetThousandthTickCounter() { _thousandthTickCounter = 0; } void updateViewports() { for (auto&& w : _windows) { w.viewportsUpdatePosition(); } } // 0x004C6118 void update() { uint16_t timeSinceLastTick = getTimeSinceLastTick(); ToolTip::setNotShownTicks(ToolTip::getNotShownTicks() + timeSinceLastTick); // 1000 tick update _thousandthTickCounter += timeSinceLastTick; if (_thousandthTickCounter >= 1000) { _thousandthTickCounter = 0; std::for_each(_windows.rbegin(), _windows.rend(), [](Ui::Window& w) { w.callOnPeriodicUpdate(); }); } // Border flash invalidation std::for_each(_windows.rbegin(), _windows.rend(), [](Ui::Window& w) { if (w.hasFlags(WindowFlags::whiteBorderMask)) { // TODO: Replace with countdown // Countdown is stuffed into WindowFlags extract it out and decrement by 1 const auto newCount = enumValue(w.flags & WindowFlags::whiteBorderMask) - enumValue(WindowFlags::whiteBorderOne); // Stuff the new count back into the WindowFlags w.flags &= ~WindowFlags::whiteBorderMask; w.flags |= static_cast<WindowFlags>(newCount); if (!w.hasFlags(WindowFlags::whiteBorderMask)) { w.invalidate(); } } }); } // 0x00439BA5 void updateDaily() { if (find(WindowType::tooltip) && ToolTip::isTimeTooltip()) { Windows::ToolTip::closeAndReset(); } } // 0x004CE438 Window* getMainWindow() { return find(WindowType::main); } Viewport* getMainViewport() { auto mainWindow = getMainWindow(); if (mainWindow != nullptr) { return mainWindow->viewports[0]; } return nullptr; } template<typename TPred> static Window* findImpl(TPred pred) { auto it = std::find_if(_windows.begin(), _windows.end(), pred); if (it != _windows.end()) { return &(*it); } return nullptr; } // 0x004C9B56 Window* find(WindowType type) { return findImpl([type](auto&& w) { return w.type == type; }); } // 0x004C9B56 Window* find(WindowType type, WindowNumber_t number) { return findImpl([type, number](auto&& w) { return w.type == type && w.number == number; }); } // 0x004C9A95 Window* findAt(int16_t x, int16_t y) { for (auto it = _windows.rbegin(); it != _windows.rend(); ++it) { auto& w = *it; if (x < w.x) { continue; } if (x >= (w.x + w.width)) { continue; } if (y < w.y) { continue; } if (y >= (w.y + w.height)) { continue; } if (w.hasFlags(WindowFlags::flag_7)) { continue; } if (w.hasFlags(WindowFlags::noBackground)) { auto index = w.findWidgetAt(x, y); if (index == kWidgetIndexNull) { continue; } } if (w.callOnResize() == nullptr) { return findAt(x, y); } return &w; } return nullptr; } Window* findAt(Ui::Point point) { return findAt(point.x, point.y); } // 0x004C9AFA Window* findAtAlt(int16_t x, int16_t y) { for (auto it = _windows.rbegin(); it != _windows.rend(); ++it) { auto& w = *it; if (x < w.x) { continue; } if (x >= (w.x + w.width)) { continue; } if (y < w.y) { continue; } if (y >= (w.y + w.height)) { continue; } if (w.hasFlags(WindowFlags::noBackground)) { auto index = w.findWidgetAt(x, y); if (index == kWidgetIndexNull) { continue; } } if (w.callOnResize() == nullptr) { return findAt(x, y); } return &w; } return nullptr; } // 0x004CB966 void invalidate(WindowType type) { for (auto& w : _windows) { if (w.type != type) { continue; } w.invalidate(); } } // 0x004CB966 void invalidate(WindowType type, WindowNumber_t number) { for (auto& w : _windows) { if (w.type != type) { continue; } if (w.number != number) { continue; } w.invalidate(); } } // 0x004CB966 void invalidateWidget(WindowType type, WindowNumber_t number, WidgetIndex_t widgetIndex) { for (auto&& w : _windows) { if (w.type != type) { continue; } if (w.number != number) { continue; } auto widget = w.widgets[widgetIndex]; if (widget.left != -2) { Gfx::invalidateRegion( w.x + widget.left, w.y + widget.top, w.x + widget.right + 1, w.y + widget.bottom + 1); } } } // 0x004C9984 void invalidateAllWindowsAfterInput() { std::for_each(_windows.rbegin(), _windows.rend(), [](Ui::Window& w) { w.updateScrollWidgets(); w.invalidatePressedImageButtons(); w.callOnResize(); }); } // 0x004CC692 void close(WindowType type) { bool repeat = true; while (repeat) { repeat = false; for (auto&& w : _windows) { if (w.type != type) { continue; } close(&w); repeat = true; break; } } } // 0x004CC692 void close(WindowType type, WindowNumber_t id) { auto window = find(type, id); if (window != nullptr) { close(window); } } // 0x004CC750 // TODO: hook Window* bringToFront(Window& w) { if (w.hasFlags(WindowFlags::stickToBack | WindowFlags::stickToFront)) { return &w; } Window* frontMostWnd = nullptr; for (auto i = count(); i != 0; --i) { if (!_windows[i - 1].hasFlags(WindowFlags::stickToBack)) { frontMostWnd = &_windows[i - 1]; break; } } Window* window = &w; if (frontMostWnd != nullptr && frontMostWnd != &_windows[0] && frontMostWnd != window) { std::swap(*frontMostWnd, w); window = frontMostWnd; window->invalidate(); } const auto right = window->x + window->width; // If window is almost off-screen to the left if (right < 20) { const auto shiftRight = 20 - window->x; window->x = 20; for (auto* vp : window->viewports) { if (vp != nullptr) { vp->x += shiftRight; } } window->invalidate(); } return window; } // 0x004CD3A9 Window* bringToFront(WindowType type, WindowNumber_t id) { auto window = find(type, id); if (window == nullptr) { return nullptr; } window->flags |= WindowFlags::whiteBorderMask; window->invalidate(); return bringToFront(*window); } /** * 0x004C9BEA * * @param x @<dx> * @param y @<ax> * @param width @<bx> * @param height @<cx> */ static bool windowFitsWithinSpace(Ui::Point32 position, Ui::Size32 size) { if (position.x < 0) { return false; } if (position.y < 28) { return false; } if (position.x + size.width > Ui::width()) { return false; } if (position.y + size.height > Ui::width()) { return false; } for (const auto& w : _windows) { if (w.hasFlags(WindowFlags::stickToBack)) { continue; } if (position.x + size.width <= w.x) { continue; } if (position.x > w.x + w.width) { continue; } if (position.y + size.height <= w.y) { continue; } if (position.y >= w.y + w.height) { continue; } return false; } return true; } // 0x004C9F27 static Window* createWindowOnScreen( WindowType type, Ui::Point32 origin, Ui::Size32 size, Ui::WindowFlags flags, const WindowEventList& events) { origin.x = std::clamp<decltype(origin.x)>(origin.x, 0, std::max(0, Ui::width() - size.width)); origin.y = std::clamp<decltype(origin.y)>(origin.y, 28, std::max(28, Ui::height() - size.height)); return createWindow(type, origin, size, flags, events); } // 0x004C9BA2 static bool windowFitsOnScreen(Ui::Point32 origin, Ui::Size32 size) { if (origin.x < -(size.width / 4)) { return false; } if (origin.x > Ui::width() - (size.width / 2)) { return false; } if (origin.y < 28) { return false; } if (origin.y > Ui::height() - (size.height / 4)) { return false; } return windowFitsWithinSpace(origin, size); } /** * 0x004C9C68 * * @param type @<cl> * @param size.width @<bx> * @param size.height @<ebx> * @param flags @<ecx << 8> * @param events @<edx> * @return */ Window* createWindow( WindowType type, Ui::Size32 size, Ui::WindowFlags flags, const WindowEventList& events) { Ui::Point32 position{}; position.x = 0; // dx position.y = 30; // ax if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = Ui::width() - size.width; position.y = 30; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = 0; position.y = Ui::height() - size.height - 29; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = Ui::width() - size.width; position.y = Ui::height() - size.height - 29; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } for (const auto& w : _windows) { if (w.hasFlags(WindowFlags::stickToBack)) { continue; } position.x = w.x + w.width + 2; position.y = w.y; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x - size.width - 2; position.y = w.y; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x; position.y = w.y + w.height + 2; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x; position.y = w.y - size.height - 2; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x + w.width + 2; position.y = w.y + w.height - size.height; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x - size.width - 2; position.y = w.y + w.height - size.height; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x + w.width - size.width; position.y = w.y - size.height - 2; if (windowFitsWithinSpace(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } } for (const auto& w : _windows) { if (w.hasFlags(WindowFlags::stickToBack)) { continue; } position.x = w.x + w.width + 2; position.y = w.y; if (windowFitsOnScreen(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x - size.width - 2; position.y = w.y; if (windowFitsOnScreen(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x; position.y = w.y + w.height + 2; if (windowFitsOnScreen(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } position.x = w.x; position.y = w.y - size.height - 2; if (windowFitsOnScreen(position, size)) { return createWindowOnScreen(type, position, size, flags, events); } } position.x = 0; position.y = 30; bool loop; do { loop = false; for (const auto& w : _windows) { if (w.x == position.x && w.y == position.y) { position.x += 5; position.y += 5; // restart loop loop = true; break; } } } while (loop); return createWindowOnScreen(type, position, size, flags, events); } /** * 0x004C9F5D * * @param type @<cl> * @param origin @<eax> * @param size @<ebx> * @param flags @<ecx << 8> * @param events @<edx> * @return */ Window* createWindow( WindowType type, Ui::Point32 origin, Ui::Size32 size, WindowFlags flags, const WindowEventList& events) { if (count() == kMaxWindows) { for (auto& w : _windows) { if (w.hasFlags(WindowFlags::stickToBack)) { continue; } if (w.hasFlags(WindowFlags::stickToFront)) { continue; } if (w.hasFlags(WindowFlags::noAutoClose)) { continue; } close(&w); return createWindow(type, origin, size, flags, events); } } bool stickToBack = (flags & WindowFlags::stickToBack) != WindowFlags::none; bool stickToFront = (flags & WindowFlags::stickToFront) != WindowFlags::none; bool hasFlag12 = (flags & WindowFlags::flag_12) != WindowFlags::none; bool shouldOpenQuietly = (flags & WindowFlags::openQuietly) != WindowFlags::none; // Find right position to insert new window size_t dstIndex = 0; if (stickToBack) { for (size_t i = 0; i < count(); i++) { if (_windows[i].hasFlags(WindowFlags::stickToBack)) { dstIndex = i; } } } else if (stickToFront) { dstIndex = count(); } else { for (int i = (int)count(); i > 0; i--) { if (!_windows[i - 1].hasFlags(WindowFlags::stickToFront)) { dstIndex = i; break; } } } auto window = Ui::Window(origin, size); window.type = type; window.flags = flags; if (hasFlag12 || (!stickToBack && !stickToFront && !shouldOpenQuietly)) { window.flags |= WindowFlags::whiteBorderMask; Audio::playSound(Audio::SoundId::openWindow, origin.x + size.width / 2); } window.eventHandlers = &events; _windows.insert(_windows.begin() + dstIndex, window); auto* newWindow = &_windows[dstIndex]; newWindow->invalidate(); return newWindow; } Window* createWindowCentred(WindowType type, Ui::Size32 size, WindowFlags flags, const WindowEventList& events) { auto x = (Ui::width() / 2) - (size.width / 2); auto y = std::max(28, (Ui::height() / 2) - (size.height / 2)); return createWindow(type, { x, y }, size, flags, events); } // 0x004C5FC8 static void drawSingle(Gfx::DrawingContext& drawingCtx, Window* w, int32_t left, int32_t top, int32_t right, int32_t bottom) { // Copy rt so we can crop it Gfx::RenderTarget rt = drawingCtx.currentRenderTarget(); // Clamp left to 0 int32_t overflow = left - rt.x; if (overflow > 0) { rt.x += overflow; rt.width -= overflow; if (rt.width <= 0) { return; } rt.pitch += overflow; rt.bits += overflow; } // Clamp width to right overflow = rt.x + rt.width - right; if (overflow > 0) { rt.width -= overflow; if (rt.width <= 0) { return; } rt.pitch += overflow; } // Clamp top to 0 overflow = top - rt.y; if (overflow > 0) { rt.y += overflow; rt.height -= overflow; if (rt.height <= 0) { return; } rt.bits += (rt.width + rt.pitch) * overflow; } // Clamp height to bottom overflow = rt.y + rt.height - bottom; if (overflow > 0) { rt.height -= overflow; if (rt.height <= 0) { return; } } if (SceneManager::isProgressBarActive() && w->type != WindowType::progressBar) { return; } // Company colour if (w->owner != CompanyId::null) { w->setColour(WindowColour::primary, static_cast<Colour>(CompanyManager::getCompanyColour(w->owner))); } // Text colouring setWindowColours(WindowColour::primary, w->getColour(WindowColour::primary).opaque()); setWindowColours(WindowColour::secondary, w->getColour(WindowColour::secondary).opaque()); setWindowColours(WindowColour::tertiary, w->getColour(WindowColour::tertiary).opaque()); setWindowColours(WindowColour::quaternary, w->getColour(WindowColour::quaternary).opaque()); drawingCtx.pushRenderTarget(rt); w->callPrepareDraw(); w->callDraw(drawingCtx); drawingCtx.popRenderTarget(); } // 0x004CD3D0 void dispatchUpdateAll() { GameCommands::setUpdatingCompanyId(CompanyManager::getControllingId()); std::for_each(_windows.rbegin(), _windows.rend(), [](auto& w) { w.callUpdate(); }); Ui::Windows::TextInput::sub_4CE6FF(); Ui::Windows::MapToolTip::open(); } // 0x004CC6EA void close(Window* window) { if (window == nullptr) { return; } // Make a copy of the window class and number in case // the window order is changed by the close event. auto type = window->type; uint16_t number = window->number; window->callClose(); // Lookup the actual window again as it may have been changed. window = find(type, number); if (window == nullptr) { return; } window->viewportRemove(0); window->viewportRemove(1); window->invalidate(); const auto index = indexOf(*window); _windows.erase(_windows.begin() + index); } void callEvent8OnAllWindows() { std::for_each(_windows.rbegin(), _windows.rend(), [](auto& w) { w.call_8(); }); } void callEvent9OnAllWindows() { std::for_each(_windows.rbegin(), _windows.rend(), [](auto& w) { w.call_9(); }); } // 0x0045F18B void callViewportRotateEventOnAllWindows() { std::for_each(_windows.rbegin(), _windows.rend(), [](auto& w) { w.callViewportRotate(); }); } bool callKeyUpEventBackToFront(uint32_t charCode, uint32_t keyCode) { for (auto it = _windows.rbegin(); it != _windows.rend(); it++) { auto& w = *it; if (w.callKeyUp(charCode, keyCode)) { return true; } } return false; } // 0x004CD296 void relocateWindows() { int16_t newLocation = 8; for (auto& w : _windows) { // Work out if the window requires moving bool extendsX = (w.x + 10) >= Ui::width(); bool extendsY = (w.y + 10) >= Ui::height(); if (w.hasFlags(WindowFlags::stickToBack) || w.hasFlags(WindowFlags::stickToFront)) { // toolbars are 27px high extendsY = (w.y + 10 - 27) >= Ui::height(); } if (extendsX || extendsY) { // Calculate the new locations int16_t oldX = w.x; int16_t oldY = w.y; w.x = newLocation; w.y = newLocation + 28; // Move the next new location so windows are not directly on top newLocation += 8; // Adjust the viewports if required. if (w.viewports[0] != nullptr) { w.viewports[0]->x -= oldX - w.x; w.viewports[0]->y -= oldY - w.y; } if (w.viewports[1] != nullptr) { w.viewports[1]->x -= oldX - w.x; w.viewports[1]->y -= oldY - w.y; } } } } // 0x004CEE0B void moveOtherWindowsDown(const Window& self) { int left = self.x; int right = self.x + self.width; int top = self.y; int bottom = self.y + self.height; for (auto& w : _windows) { if (&w == &self) { continue; } if (w.hasFlags(WindowFlags::stickToBack)) { continue; } if (w.hasFlags(WindowFlags::stickToFront)) { continue; } if (w.x >= right) { continue; } if (w.x + w.width <= left) { continue; } if (w.y >= bottom) { continue; } if (w.y + w.height <= top) { continue; } w.invalidate(); if (bottom < Ui::height() - 80) { int dY = bottom + 3 - w.y; w.y += dY; w.invalidate(); if (w.viewports[0] != nullptr) { w.viewports[0]->y += dY; } if (w.viewports[1] != nullptr) { w.viewports[1]->y += dY; } } } } // 0x004B93A5 void invalidateOrderPageByVehicleNumber(WindowNumber_t number) { for (auto& w : _windows) { if (w.type != WindowType::vehicle) { continue; } if (w.number != number) { continue; } if (w.currentTab != 4) { continue; } w.invalidate(); } } // 0x004A0AB0 void closeConstructionWindows() { close(WindowType::construction); close(WindowType::companyFaceSelection); ToolManager::toolCancel(); Windows::Construction::_ghostVisibilityFlags = Windows::Construction::GhostVisibilityFlags::none; } // 0x004BF089 void closeTopmost() { close(WindowType::dropdown, 0); for (auto it = _windows.rbegin(); it != _windows.rend(); it++) { auto& w = *it; if (w.hasFlags(WindowFlags::stickToBack)) { continue; } if (w.hasFlags(WindowFlags::stickToFront)) { continue; } close(&w); break; } } static void windowScrollWheelInput(Ui::Window& window, WidgetIndex_t widgetIndex, int wheel) { int scrollIndex = window.getScrollDataIndex(widgetIndex); ScrollArea* scroll = &window.scrollAreas[scrollIndex]; Ui::Widget* widget = &window.widgets[widgetIndex]; if (window.scrollAreas[scrollIndex].hasFlags(ScrollFlags::vscrollbarVisible)) { int size = widget->bottom - widget->top - 1; if (scroll->hasFlags(ScrollFlags::hscrollbarVisible)) { size -= 11; } size = std::max(0, scroll->contentHeight - size); scroll->contentOffsetY = std::clamp(scroll->contentOffsetY + wheel, 0, size); } else if (window.scrollAreas[scrollIndex].hasFlags(ScrollFlags::hscrollbarVisible)) { int size = widget->right - widget->left - 1; if (scroll->hasFlags(ScrollFlags::vscrollbarVisible)) { size -= 11; } size = std::max(0, scroll->contentWidth - size); scroll->contentOffsetX = std::clamp(scroll->contentOffsetX + wheel, 0, size); } Ui::ScrollView::updateThumbs(window, widgetIndex); invalidateWidget(window.type, window.number, widgetIndex); } static bool isStepperGroup(Window& w, WidgetIndex_t index, WidgetType buttonType) { const auto& widgets = w.widgets; if (widgets[index].type != WidgetType::textbox && widgets[index].type != WidgetType::wt_3) { return false; } if (static_cast<size_t>(index + 2) >= widgets.size()) { return false; } if (widgets[index + 1].type != buttonType) { return false; } if (widgets[index + 2].type != buttonType) { return false; } return true; } static std::optional<WidgetIndex_t> getStepperGroupWidgetIndex(Window& w, WidgetIndex_t startIndex) { // We only iterate 3 times as we might be at the textbox or one of the buttons. for (WidgetIndex_t index = 0; index < 3; index++) { const auto reverseIndex = startIndex - index; if (reverseIndex < 0) { break; } if (isStepperGroup(w, reverseIndex, WidgetType::toolbarTab)) { return reverseIndex; } if (isStepperGroup(w, reverseIndex, WidgetType::button)) { return reverseIndex; } } return std::nullopt; } // Allow mouse wheel scrolling to manipulate stepper widgets and tool sizes static bool stepperWheelInput(Window& w, WidgetIndex_t widgetIndex, int32_t wheel) { const auto stepperGroupIndex = getStepperGroupWidgetIndex(w, widgetIndex); if (!stepperGroupIndex.has_value()) { return false; } const auto entryWidgetType = w.widgets[*stepperGroupIndex].type; if (entryWidgetType == WidgetType::wt_3) { auto expectedContent1 = Gfx::recolour(ImageIds::decrease_tool_area, Colour::white); auto expectedContent2 = Gfx::recolour(ImageIds::increase_tool_area, Colour::white); auto button1Image = w.widgets[*stepperGroupIndex + 1].image; auto button2Image = w.widgets[*stepperGroupIndex + 2].image; if (button1Image != expectedContent1 || button2Image != expectedContent2) { return false; } } else if (entryWidgetType == WidgetType::textbox) { auto button1StringId = w.widgets[*stepperGroupIndex + 1].text; auto button2StringId = w.widgets[*stepperGroupIndex + 2].text; if (button1StringId != StringIds::stepper_minus || button2StringId != StringIds::stepper_plus) { return false; } } const auto targetWidgetIndex = wheel < 0 ? *stepperGroupIndex + 2 : *stepperGroupIndex + 1; if (w.isDisabled(targetWidgetIndex)) { return false; } w.callOnMouseDown(targetWidgetIndex, w.widgets[targetWidgetIndex].id); return true; } // 0x004C628E static bool windowWheelInput(Window& window, int wheel) { WidgetIndex_t widgetIndex = kWidgetIndexNull; int scrollIndex = -1; for (auto& widget : window.widgets) { widgetIndex++; if (widget.type != WidgetType::scrollview) { continue; } scrollIndex++; constexpr ScrollFlags scrollbarFlags = ScrollFlags::hscrollbarVisible | ScrollFlags::vscrollbarVisible; if (window.scrollAreas[scrollIndex].hasFlags(scrollbarFlags)) { windowScrollWheelInput(window, widgetIndex, wheel); return true; } } return false; } void wheelInput(int wheel) { const Ui::Point cursorPosition = Input::getMouseLocation(); auto window = findAt(cursorPosition); if (window != nullptr) { if (window->type == WindowType::main) { if (SceneManager::isTitleMode()) { return; } if (wheel > 0) { window->viewportZoomOut(true); } else if (wheel < 0) { window->viewportZoomIn(true); } TownManager::updateLabels(); StationManager::updateLabels(); return; } else { auto widgetIndex = window->findWidgetAt(cursorPosition.x, cursorPosition.y); if (widgetIndex != kWidgetIndexNull) { if (window->widgets[widgetIndex].type == WidgetType::scrollview) { auto scrollIndex = window->getScrollDataIndex(widgetIndex); constexpr ScrollFlags scrollbarFlags = ScrollFlags::hscrollbarVisible | ScrollFlags::vscrollbarVisible; if (window->scrollAreas[scrollIndex].hasFlags(scrollbarFlags)) { windowScrollWheelInput(*window, widgetIndex, wheel); return; } } if (stepperWheelInput(*window, widgetIndex, wheel)) { return; } if (windowWheelInput(*window, wheel)) { return; } } } } for (auto it = _windows.rbegin(); it != _windows.rend(); it++) { auto& w = *it; if (windowWheelInput(w, wheel)) { return; } } } bool isInFront(Ui::Window* window) { const auto index = indexOf(*window) + 1; for (auto it = _windows.begin() + index; it != _windows.end(); it++) { auto& w = *it; if (w.hasFlags(WindowFlags::stickToFront)) { continue; } return false; } return true; } bool isInFrontAlt(Ui::Window* window) { const auto index = indexOf(*window) + 1; for (auto it = _windows.begin() + index; it != _windows.end(); it++) { auto& w = *it; if (w.hasFlags(WindowFlags::stickToFront)) { continue; } if (w.type == WindowType::buildVehicle) { continue; } return false; } return true; } // 0x0046960C Ui::Window* findWindowShowing(const viewport_pos& position) { for (auto it = _windows.rbegin(); it != _windows.rend(); it++) { auto& w = *it; if (w.viewports[0] == nullptr) { continue; } auto viewport = w.viewports[0]; if (viewport->zoom != 0) { continue; } if (!viewport->contains(position)) { continue; } return &w; } return nullptr; } /** * 0x004C6A40 * * @param window @<edi> * @param viewport @<esi> */ void viewportShiftPixels(Ui::Window* window, Ui::Viewport* viewport, int16_t dX, int16_t dY) { const auto index = indexOf(*window); for (auto it = _windows.begin() + index; it != _windows.end(); it++) { auto& w = *it; if (!w.isTranslucent()) { continue; } if (viewport == w.viewports[0]) { continue; } if (viewport == w.viewports[1]) { continue; } if (viewport->x + viewport->width <= w.x) { continue; } if (w.x + w.width <= viewport->x) { continue; } if (viewport->y + viewport->height <= w.y) { continue; } if (w.y + w.height <= viewport->y) { continue; } int16_t left, top, right, bottom, cx; left = w.x; top = w.y; right = w.x + w.width; bottom = w.y + w.height; // TODO: replace these with min/max cx = viewport->x; if (left < cx) { left = cx; } cx = viewport->x + viewport->width; if (right > cx) { right = cx; } cx = viewport->y; if (top < cx) { top = cx; } cx = viewport->y + viewport->height; if (bottom > cx) { bottom = cx; } if (left < right && top < bottom) { Gfx::render(left, top, right, bottom); } } viewportRedrawAfterShift(window, viewport, dX, dY); } /** * 0x004C6B09 * * @param edi @<edi> * @param x @<dx> * @param y @<bp> * @param viewport @<esi> */ void viewportRedrawAfterShift(Window* window, Viewport* viewport, int16_t x, int16_t y) { while (window != nullptr) { // skip current window and non-intersecting windows if (viewport == window->viewports[0] || viewport == window->viewports[1] || viewport->x + viewport->width <= window->x || viewport->x >= window->x + window->width || viewport->y + viewport->height <= window->y || viewport->y >= window->y + window->height) { size_t nextWindowIndex = WindowManager::indexOf(*window) + 1; window = nextWindowIndex >= count() ? nullptr : WindowManager::get(nextWindowIndex); continue; } // save viewport Ui::Viewport viewCopy = *viewport; if (viewport->x < window->x) { viewport->width = window->x - viewport->x; viewport->viewWidth = viewport->width << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); viewport->x += viewport->width; viewport->viewX += viewport->width << viewport->zoom; viewport->width = viewCopy.width - viewport->width; viewport->viewWidth = viewport->width << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); } else if (viewport->x + viewport->width > window->x + window->width) { viewport->width = window->x + window->width - viewport->x; viewport->viewWidth = viewport->width << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); viewport->x += viewport->width; viewport->viewX += viewport->width << viewport->zoom; viewport->width = viewCopy.width - viewport->width; viewport->viewWidth = viewport->width << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); } else if (viewport->y < window->y) { viewport->height = window->y - viewport->y; viewport->viewHeight = viewport->height << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); viewport->y += viewport->height; viewport->viewY += viewport->height << viewport->zoom; viewport->height = viewCopy.height - viewport->height; viewport->viewHeight = viewport->height << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); } else if (viewport->y + viewport->height > window->y + window->height) { viewport->height = window->y + window->height - viewport->y; viewport->viewHeight = viewport->height << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); viewport->y += viewport->height; viewport->viewY += viewport->height << viewport->zoom; viewport->height = viewCopy.height - viewport->height; viewport->viewHeight = viewport->height << viewport->zoom; viewportRedrawAfterShift(window, viewport, x, y); } // restore viewport *viewport = viewCopy; return; } int16_t left = viewport->x; int16_t top = viewport->y; int16_t right = left + viewport->width; int16_t bottom = top + viewport->height; // if moved more than the viewport size if (std::abs(x) >= viewport->width || std::abs(y) >= viewport->height) { // redraw whole viewport Gfx::render(left, top, right, bottom); } else { // update whole block Gfx::movePixelsOnScreen(left, top, viewport->width, viewport->height, x, y); if (x > 0) { // draw left int16_t _right = left + x; Gfx::render(left, top, _right, bottom); left += x; } else if (x < 0) { // draw right int16_t _left = right + x; Gfx::render(_left, top, right, bottom); right += x; } if (y > 0) { // draw top bottom = top + y; Gfx::render(left, top, right, bottom); } else if (y < 0) { // draw bottom top = bottom + y; Gfx::render(left, top, right, bottom); } } } /** * 0x004A0A18 * * @param visibility @<al> */ void viewportSetVisibility(ViewportVisibility visibility) { auto window = WindowManager::getMainWindow(); if (window == nullptr) { return; } auto viewport = window->viewports[0]; bool flagsChanged = false; switch (visibility) { case ViewportVisibility::undergroundView: { if (!viewport->hasFlags(ViewportFlags::underground_view)) { viewport->flags |= (ViewportFlags::underground_view); flagsChanged = true; } break; } case ViewportVisibility::heightMarksOnTrack: { if (!viewport->hasFlags(ViewportFlags::height_marks_on_tracks_roads)) { viewport->flags |= (ViewportFlags::height_marks_on_tracks_roads); flagsChanged = true; } break; } case ViewportVisibility::overgroundView: { if (viewport->hasFlags(ViewportFlags::underground_view)) { viewport->flags &= ~(ViewportFlags::underground_view); flagsChanged = true; } break; } default: { if (viewport->hasFlags(ViewportFlags::underground_view)) { viewport->flags &= ~(ViewportFlags::underground_view); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::flag_7)) { viewport->flags &= ~(ViewportFlags::flag_7); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::flag_8)) { viewport->flags &= ~(ViewportFlags::flag_8); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::seeThroughTrees)) { viewport->flags &= ~(ViewportFlags::seeThroughTrees); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::seeThroughBuildings)) { viewport->flags &= ~(ViewportFlags::seeThroughBuildings); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::seeThroughBridges)) { viewport->flags &= ~(ViewportFlags::seeThroughBridges); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::seeThroughRoads)) { viewport->flags &= ~(ViewportFlags::seeThroughRoads); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::seeThroughScenery)) { viewport->flags &= ~(ViewportFlags::seeThroughScenery); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::seeThroughTracks)) { viewport->flags &= ~(ViewportFlags::seeThroughTracks); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::height_marks_on_land)) { viewport->flags &= ~(ViewportFlags::height_marks_on_land); flagsChanged = true; } if (viewport->hasFlags(ViewportFlags::height_marks_on_tracks_roads)) { viewport->flags &= ~(ViewportFlags::height_marks_on_tracks_roads); flagsChanged = true; } break; } } if (flagsChanged) { window->invalidate(); } } // 0x004CF456 void closeAllFloatingWindows() { close(WindowType::dropdown, 0); bool changed = true; while (changed) { changed = false; for (auto it = _windows.rbegin(); it != _windows.rend(); it++) { auto& w = *it; if (w.hasFlags(WindowFlags::stickToBack)) { continue; } if (w.hasFlags(WindowFlags::stickToFront)) { continue; } close(&w); // restart loop changed = true; break; } } } int32_t getCurrentRotation() { return _currentRotation; } void setCurrentRotation(int32_t value) { _currentRotation = value; } // 0x0052622E uint16_t getVehiclePreviewRotationFrame() { return getGameState().vehiclePreviewRotationFrame; } void setVehiclePreviewRotationFrame(uint16_t vehiclePreviewRotationFrame) { getGameState().vehiclePreviewRotationFrame = vehiclePreviewRotationFrame; } uint8_t getVehiclePreviewRotationFrameYaw() { return getVehiclePreviewRotationFrame() & 0x3F; } uint8_t getVehiclePreviewRotationFrameRoll() { return ((getVehiclePreviewRotationFrame() + 2) / 4) & 0x3F; } static void windowDraw(Gfx::DrawingContext& ctx, Ui::Window* w, Rect rect); static void windowDraw(Gfx::DrawingContext& ctx, Ui::Window* w, int16_t left, int16_t top, int16_t right, int16_t bottom); static bool windowDrawSplit(Gfx::DrawingContext& ctx, Ui::Window* w, int16_t left, int16_t top, int16_t right, int16_t bottom); /** * 0x004C5EA9 * * @param w * @param left @<ax> * @param top @<bx> * @param right @<dx> * @param bottom @<bp> */ static void windowDraw(Gfx::DrawingContext& ctx, Ui::Window* w, int16_t left, int16_t top, int16_t right, int16_t bottom) { if (!w->isVisible()) { return; } // Split window into only the regions that require drawing if (windowDrawSplit(ctx, w, left, top, right, bottom)) { return; } // Clamp region left = std::max(left, w->x); top = std::max(top, w->y); right = std::min<int16_t>(right, w->x + w->width); bottom = std::min<int16_t>(bottom, w->y + w->height); if (left >= right) { return; } if (top >= bottom) { return; } // Draw the window in this region drawSingle(ctx, w, left, top, right, bottom); for (uint32_t index = indexOf(*w) + 1; index < count(); index++) { auto* v = get(index); // Don't draw overlapping opaque windows, they won't have changed if (!v->hasFlags(WindowFlags::transparent)) { continue; } drawSingle(ctx, v, left, top, right, bottom); } } static void windowDraw(Gfx::DrawingContext& ctx, Window* w, Rect rect) { windowDraw(ctx, w, rect.left(), rect.top(), rect.right(), rect.bottom()); } /** * 0x004C5EA9 * * @param rt * @param w @<esi> * @param left @<ax> * @param top @<bx> * @param right @<dx> * @param bottom @<bp> * @return */ static bool windowDrawSplit(Gfx::DrawingContext& ctx, Ui::Window* w, int16_t left, int16_t top, int16_t right, int16_t bottom) { // Divide the draws up for only the visible regions of the window recursively for (size_t index = indexOf(*w) + 1; index < count(); index++) { auto topwindow = get(index); // Check if this window overlaps w if (topwindow->x >= right || topwindow->y >= bottom) { continue; } if (topwindow->x + topwindow->width <= left || topwindow->y + topwindow->height <= top) { continue; } if (topwindow->isTranslucent()) { continue; } // A window overlaps w, split up the draw into two regions where the window starts to overlap if (topwindow->x > left) { // Split draw at topwindow.left windowDraw(ctx, w, left, top, topwindow->x, bottom); windowDraw(ctx, w, topwindow->x, top, right, bottom); } else if (topwindow->x + topwindow->width < right) { // Split draw at topwindow.right windowDraw(ctx, w, left, top, topwindow->x + topwindow->width, bottom); windowDraw(ctx, w, topwindow->x + topwindow->width, top, right, bottom); } else if (topwindow->y > top) { // Split draw at topwindow.top windowDraw(ctx, w, left, top, right, topwindow->y); windowDraw(ctx, w, left, topwindow->y, right, bottom); } else if (topwindow->y + topwindow->height < bottom) { // Split draw at topwindow.bottom windowDraw(ctx, w, left, top, right, topwindow->y + topwindow->height); windowDraw(ctx, w, left, topwindow->y + topwindow->height, right, bottom); } // Drawing for this region should be done now, exit return true; } // No windows overlap return false; } void render(Gfx::DrawingContext& drawingCtx, const Rect& rect) { for (auto& w : _windows) { if (w.isTranslucent()) { continue; } if (rect.right() <= w.x || rect.bottom() <= w.y) { continue; } if (rect.left() >= w.x + w.width || rect.top() >= w.y + w.height) { continue; } windowDraw(drawingCtx, &w, rect); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/WindowManager.h ```h #pragma once #include "Localisation/StringManager.h" #include "Window.h" #include <Map/Track/TrackModSection.h> #include <OpenLoco/Engine/World.hpp> #include <cstddef> #include <functional> #include <string_view> namespace OpenLoco { enum class LoadOrQuitMode : uint16_t; enum class ObjectType : uint8_t; } namespace OpenLoco::Gfx { struct RenderTarget; } namespace OpenLoco::Ui { struct Viewport; struct Window; } namespace OpenLoco::World { struct TrackElement; struct RoadElement; struct TreeElement; } namespace OpenLoco::Ui::WindowManager { enum class ViewportVisibility { reset, undergroundView, heightMarksOnTrack, overgroundView, }; void init(); void setWindowColours(WindowColour slot, AdvancedColour colour); AdvancedColour getWindowColour(WindowColour slot); WindowType getCurrentModalType(); void setCurrentModalType(WindowType type); void resetThousandthTickCounter(); Window* get(size_t index); size_t indexOf(const Window& pWindow); size_t count(); void updateViewports(); void update(); void updateDaily(); Window* getMainWindow(); Viewport* getMainViewport(); Window* find(WindowType type); Window* find(WindowType type, WindowNumber_t number); Window* findAt(int16_t x, int16_t y); Window* findAt(Ui::Point point); Window* findAtAlt(int16_t x, int16_t y); Window* bringToFront(Window& window); Window* bringToFront(WindowType type, WindowNumber_t id = 0); void invalidate(WindowType type); void invalidate(WindowType type, WindowNumber_t number); void invalidateWidget(WindowType type, WindowNumber_t number, WidgetIndex_t widgetIndex); void invalidateAllWindowsAfterInput(); void close(WindowType type); void close(WindowType type, WindowNumber_t id); void close(Window* window); Window* createWindow(WindowType type, Ui::Size32 size, WindowFlags flags, const WindowEventList& events); Window* createWindow(WindowType type, Ui::Point32 origin, Ui::Size32 size, WindowFlags flags, const WindowEventList& events); Window* createWindowCentred(WindowType type, Ui::Size32 size, WindowFlags flags, const WindowEventList& events); Window* createWindow(WindowType type, Ui::Size32 size, WindowFlags flags, const WindowEventList& events); void dispatchUpdateAll(); void callEvent8OnAllWindows(); void callEvent9OnAllWindows(); void callViewportRotateEventOnAllWindows(); bool callKeyUpEventBackToFront(uint32_t charCode, uint32_t keyCode); void relocateWindows(); void moveOtherWindowsDown(const Window& self); void invalidateOrderPageByVehicleNumber(WindowNumber_t number); void closeConstructionWindows(); void closeTopmost(); void wheelInput(int wheel); bool isInFront(Ui::Window* w); bool isInFrontAlt(Ui::Window* w); Ui::Window* findWindowShowing(const viewport_pos& position); void closeAllFloatingWindows(); int32_t getCurrentRotation(); void setCurrentRotation(int32_t value); void viewportShiftPixels(Ui::Window* window, Ui::Viewport* viewport, int16_t dX, int16_t dY); void viewportSetVisibility(ViewportVisibility flags); // 0x0052622E uint16_t getVehiclePreviewRotationFrame(); void setVehiclePreviewRotationFrame(uint16_t); uint8_t getVehiclePreviewRotationFrameYaw(); uint8_t getVehiclePreviewRotationFrameRoll(); void render(Gfx::DrawingContext& ctx, const Rect& rect); } namespace OpenLoco::Vehicles { struct VehicleBase; struct Car; } namespace OpenLoco::Ui::Windows { namespace About { void open(); } namespace AboutMusic { void open(); } namespace BuildVehicle { Window* openByVehicleId(EntityId vehicleId); Window* openByType(VehicleType vehicleType); Window* openByVehicleObjectId(uint16_t vehicleObjectId); void sub_4B92A5(Ui::Window* window); } namespace Cheats { Window* open(); } namespace CompanyFaceSelection { void open(const CompanyId id, const WindowType callingWindowType); } namespace CompanyList { void openPerformanceIndexes(); Window* open(); void removeCompany(CompanyId id); } namespace CompanyWindow { Window* open(CompanyId companyId); Window* openAndSetName(); Window* openChallenge(CompanyId companyId); Window* openFinances(CompanyId companyId); bool rotate(Window& self); } namespace Construction { Window* openWithFlags(uint32_t flags); Window* openAtTrack(const Window& main, World::TrackElement* track, const World::Pos2 pos); Window* openAtRoad(const Window& main, World::RoadElement* track, const World::Pos2 pos); void updateAvailableRoadAndRailOptions(); void updateAvailableAirportAndDockOptions(); void sub_4A6FAC(); bool isStationTabOpen(); bool isOverheadTabOpen(); bool isSignalTabOpen(); bool rotate(Window& self); void removeConstructionGhosts(); uint16_t getLastSelectedMods(); World::Track::ModSection getLastSelectedTrackModSection(); } namespace DragVehiclePart { void open(Vehicles::Car& car); } namespace EditKeyboardShortcut { Window* open(uint8_t shortcutIndex); } namespace Error { void open(StringId title, StringId message = StringIds::null); void openQuiet(StringId title, StringId message = StringIds::null); void openWithCompetitor(StringId title, StringId message, CompanyId competitorId); } namespace Industry { Window* open(IndustryId id); } namespace IndustryList { Window* open(); void reset(); void removeIndustry(const IndustryId id); } namespace KeyboardShortcuts { Window* open(); } namespace LandscapeGeneration { Window* open(); } namespace Main { void open(); void showGridlines(); void hideGridlines(); void showDirectionArrows(); void hideDirectionArrows(); void viewportFocusOnEntity(Window& main, EntityId targetEntity); bool viewportIsFocusedOnEntity(const Window& main, EntityId targetEntity); bool viewportIsFocusedOnAnyEntity(const Window& main); void viewportUnfocusFromEntity(Window& main); } namespace MapToolTip { void open(); void setOwner(CompanyId company); uint16_t getTooltipTimeout(); void reset(); } namespace MapWindow { void open(); void centerOnViewPoint(); } namespace MessageWindow { void open(); } namespace MusicSelection { Window* open(); } namespace NetworkStatus { using CloseCallback = std::function<void()>; Window* open(std::string_view text, CloseCallback cbClose); void setText(std::string_view text); void setText(std::string_view text, CloseCallback cbClose); void close(); } namespace NewsWindow { void open(MessageId messageIndex); void openLastMessage(); void close(Ui::Window* window); } namespace ObjectLoadError { Window* open(const std::vector<ObjectHeader>& list); } namespace ObjectSelectionWindow { Window* open(); Window& openInTab(ObjectType objectType); bool tryCloseWindow(); } namespace Options { Window* open(); Window* openMusicSettings(); constexpr uint8_t kTabOffsetMusic = 2; } namespace PlayerInfoPanel { Window* open(); void invalidateFrame(); } namespace ProgressBar { Window* open(std::string_view captionString); void setProgress(uint8_t value); void close(); } namespace PromptBrowse { enum browse_type : uint8_t { load = 1, save = 2 }; std::optional<std::string> open(browse_type type, std::string_view path, const char* filter, StringId titleId); } namespace PromptOkCancel { bool open(StringId captionId, StringId descriptionId, FormatArguments& descriptionArgs, StringId okButtonStringId); } namespace PromptSaveWindow { Window* open(LoadOrQuitMode savePromptType); } namespace ScenarioOptions { Window* open(); } namespace ScenarioSelect { Window* open(); } namespace Station { Window* open(StationId id); void reset(); void showStationCatchment(StationId id); void sub_491BC6(); namespace VehiclesStopping { void removeTrainFromList(Window& self, EntityId head); } } namespace StationList { Window* open(CompanyId companyId); Window* open(CompanyId companyId, uint8_t type); void removeStationFromList(const StationId stationId); } namespace Terraform { Window* open(); void openClearArea(); void openAdjustLand(); void openAdjustWater(); void openPlantTrees(); void openBuildWalls(); bool rotate(Window&); void setAdjustLandToolSize(uint8_t size); void setAdjustWaterToolSize(uint8_t size); void setClearAreaToolSize(uint8_t size); void setLastPlacedTree(World::TreeElement* elTree); void resetLastSelections(); } namespace TextInput { void openTextInput(Ui::Window* w, StringId title, StringId message, StringId value, int callingWidget, const void* valueArgs, uint32_t inputSize = StringManager::kUserStringSize - 1); void sub_4CE6C9(WindowType type, WindowNumber_t number); void cancel(); void sub_4CE6FF(); } namespace TileInspector { Window* open(); } namespace TimePanel { Window* open(); void invalidateFrame(); void beginSendChatMessage(Window& self); } namespace TitleExit { Window* open(); } namespace TitleLogo { Window* open(); } namespace TitleMenu { Window* open(); void beginSendChatMessage(Window& self); } namespace TitleOptions { Window* open(); } namespace TitleVersion { Window* open(); } namespace ToolbarBottom::Editor { void open(); } namespace ToolbarTop::Game { void open(); } namespace ToolbarTop::Editor { void open(); } namespace ToolTip { void open(Ui::Window* window, int32_t widgetIndex, int16_t x, int16_t y); void update(Ui::Window* window, int32_t widgetIndex, StringId stringId, int16_t x, int16_t y); void closeAndReset(); } namespace Town { Window* open(uint16_t townId); } namespace TownList { Window* open(); void removeTown(TownId); void reset(); bool rotate(Window& self); } namespace Tutorial { Window* open(); } namespace Vehicle { namespace Main { Window* open(const Vehicles::VehicleBase* vehicle); } namespace Details { Window* open(const Vehicles::VehicleBase* vehicle); void scrollDrag(const Ui::Point& pos); void scrollDragEnd(const Ui::Point& pos); } bool rotate(); bool cancelVehicleTools(); } namespace VehicleList { Window* open(CompanyId companyId, VehicleType type); void removeTrainFromList(Window& self, EntityId head); } namespace Debug { Window* open(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/WindowType.h ```h #pragma once #include <cstdint> namespace OpenLoco::Ui { enum class WindowType : uint8_t { main = 0, topToolbar = 1, playerInfoToolbar = 2, timeToolbar = 3, editorToolbar = 4, tooltip = 6, dropdown = 7, about = 9, // The Atari credits window is no longer used aboutAtari = 10, aboutMusic = 11, error = 12, construction = 13, saveGamePrompt = 14, terraform = 15, titleMenu = 16, titleExit = 17, scenarioSelect = 18, keyboardShortcuts = 19, editKeyboardShortcut = 20, map = 21, title_logo = 22, vehicle = 23, station = 24, dragVehiclePart = 25, company = 26, vehicleList = 27, buildVehicle = 28, stationList = 29, mapTooltip = 30, objectSelection = 31, townList = 32, town = 33, industry = 34, industryList = 35, news = 36, messages = 37, multiplayer = 39, options = 40, musicSelection = 41, companyFaceSelection = 42, landscapeGeneration = 43, // 44 was landscapeGenerationConfirm, which is no longer used scenarioOptions = 45, progressBar = 47, companyList = 48, tutorial = 49, confirmDisplayModePrompt = 50, textInput = 51, fileBrowserPrompt = 52, previewImage = 53, confirmationPrompt = 54, openLocoVersion = 55, titleOptions = 56, tileInspector = 57, cheats = 58, networkStatus = 59, objectLoadError = 60, debug = 61, undefined = 255 }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/About.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::About { static constexpr Ui::Size32 kWindowSize = { 400, 260 }; namespace widx { enum { frame, title, close, panel, music_acknowledgements_btn, }; } static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, kWindowSize, WindowColour::primary), Widgets::Caption({ 1, 1 }, { kWindowSize.width - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::about_locomotion_caption), Widgets::ImageButton({ kWindowSize.width - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { kWindowSize.width, 245 }, WindowColour::secondary), Widgets::Button({ 100, 234 }, { kWindowSize.width / 2, 12 }, WindowColour::secondary, StringIds::music_acknowledgements_btn), Widgets::Label({ 10, 25 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_69), Widgets::Label({ 10, 35 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_70), Widgets::Label({ 10, 114 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_71), Widgets::Label({ 10, 124 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_72), Widgets::Label({ 10, 134 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_73), Widgets::Label({ 10, 144 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_74), Widgets::Label({ 10, 157 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_75), Widgets::Label({ 10, 182 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_76), Widgets::Label({ 10, 192 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::about_locomotion_77), Widgets::Label({ 10, 217 }, { kWindowSize.width - 20, 10 }, WindowColour::secondary, ContentAlign::center, StringIds::licenced_to_atari_inc) ); static const WindowEventList& getEvents(); // 0x0043B26C void open() { if (WindowManager::bringToFront(WindowType::about) != nullptr) { return; } auto window = WindowManager::createWindowCentred( WindowType::about, kWindowSize, WindowFlags::none, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); const auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowOptionsColour); } // 0x0043B4AF static void onMouseUp(Ui::Window& window, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close: WindowManager::close(window.type); break; case widx::music_acknowledgements_btn: AboutMusic::open(); break; } } // 0x0043B2E4 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { // Draw widgets. window.draw(drawingCtx); // Chris Sawyer logo drawingCtx.drawImage(window.x + 92, window.y + 52, ImageIds::chris_sawyer_logo_small); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/AboutMusic.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::AboutMusic { static constexpr Ui::Size32 kWindowSize = { 500, 312 }; static constexpr uint8_t kRowHeight = 10; // CJK: 12 constexpr uint16_t numSongs = 31; namespace Widx { enum { frame, title, close, panel, scrollview, }; } static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, kWindowSize, WindowColour::primary), Widgets::Caption({ 1, 1 }, { kWindowSize.width - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::music_acknowledgements_caption), Widgets::ImageButton({ kWindowSize.width - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { kWindowSize.width, 297 }, WindowColour::secondary), Widgets::ScrollView({ 4, 18 }, { kWindowSize.width - 8, 289 }, WindowColour::secondary, Ui::Scrollbars::vertical)); static const WindowEventList& getEvents(); // 0x0043B4AF void open() { if (WindowManager::bringToFront(WindowType::aboutMusic) != nullptr) { return; } auto window = WindowManager::createWindowCentred( WindowType::aboutMusic, kWindowSize, WindowFlags::none, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); const auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowOptionsColour); } // 0x0043BFB0 static void onMouseUp(Ui::Window& window, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::close: WindowManager::close(window.type); break; } } // 0x0043BFBB static void getScrollSize(Ui::Window&, uint32_t, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = numSongs * (kRowHeight * 3 + 4); } // 0x0043BFC0 static std::optional<FormatArguments> tooltip(Ui::Window&, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_credits_list); return args; } // 0x0043B8B8 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { // Draw widgets. window.draw(drawingCtx); } // 0x0043B8BE static void drawScroll(Ui::Window&, Gfx::DrawingContext& drawingCtx, const uint32_t) { static const std::pair<StringId, StringId> stringsToDraw[numSongs] = { { StringIds::locomotion_title, StringIds::locomotion_title_credit }, { StringIds::long_dusty_road, StringIds::long_dusty_road_credit }, { StringIds::flying_high, StringIds::flying_high_credit }, { StringIds::gettin_on_the_gas, StringIds::gettin_on_the_gas_credit }, { StringIds::jumpin_the_rails, StringIds::jumpin_the_rails_credit }, { StringIds::smooth_running, StringIds::smooth_running_credit }, { StringIds::traffic_jam, StringIds::traffic_jam_credit }, { StringIds::never_stop_til_you_get_there, StringIds::never_stop_til_you_get_there_credit }, { StringIds::soaring_away, StringIds::soaring_away_credit }, { StringIds::techno_torture, StringIds::techno_torture_credit }, { StringIds::everlasting_high_rise, StringIds::everlasting_high_rise_credit }, { StringIds::solace, StringIds::solace_credit }, { StringIds::chrysanthemum, StringIds::chrysanthemum_credit }, { StringIds::eugenia, StringIds::eugenia_credit }, { StringIds::the_ragtime_dance, StringIds::the_ragtime_dance_credit }, { StringIds::easy_winners, StringIds::easy_winners_credit }, { StringIds::setting_off, StringIds::setting_off_credit }, { StringIds::a_travellers_seranade, StringIds::a_travellers_seranade_credit }, { StringIds::latino_trip, StringIds::latino_trip_credit }, { StringIds::a_good_head_of_steam, StringIds::a_good_head_of_steam_credit }, { StringIds::hop_to_the_bop, StringIds::hop_to_the_bop_credit }, { StringIds::the_city_lights, StringIds::the_city_lights_credit }, { StringIds::steamin_down_town, StringIds::steamin_down_town_credit }, { StringIds::bright_expectations, StringIds::bright_expectations_credit }, { StringIds::mo_station, StringIds::mo_station_credit }, { StringIds::far_out, StringIds::far_out_credit }, { StringIds::running_on_time, StringIds::running_on_time_credit }, { StringIds::get_me_to_gladstone_bay, StringIds::get_me_to_gladstone_bay_credit }, { StringIds::chuggin_along, StringIds::chuggin_along_credit }, { StringIds::dont_lose_your_rag, StringIds::dont_lose_your_rag_credit }, { StringIds::sandy_track_blues, StringIds::sandy_track_blues_credit }, }; auto point = Point(240, 2); const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); for (const auto& songStrings : stringsToDraw) { if (point.y + (kRowHeight * 3 + 4) < rt.y) { point.y += kRowHeight * 3 + 4; continue; } else if (point.y > rt.y + rt.height) { break; } // Song name tr.drawStringCentred(point, Colour::black, songStrings.first); point.y += kRowHeight; // Credit line tr.drawStringCentred(point, Colour::black, songStrings.second); point.y += kRowHeight; // Show CS' copyright after every two lines. tr.drawStringCentred(point, Colour::black, StringIds::music_copyright); point.y += kRowHeight + 4; } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .getScrollSize = getScrollSize, .tooltip = tooltip, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/BuildVehicle.cpp ```cpp #include "Config.h" #include "Date.h" #include "Economy/Economy.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Vehicles/CreateVehicle.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/CargoObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/VehicleObject.h" #include "OpenLoco.h" #include "Ui/Dropdown.h" #include "Ui/ScrollView.h" #include "Ui/TextInput.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TextBoxWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include "World/CompanyManager.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Trigonometry.hpp> #include <algorithm> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::BuildVehicle { static constexpr Ui::Size32 kWindowSize = { 400, 305 }; enum widx { frame = 0, caption = 1, close_button = 2, panel = 3, tab_build_new_trains, tab_build_new_buses, tab_build_new_trucks, tab_build_new_trams, tab_build_new_aircraft, tab_build_new_ships, tab_track_type_0, tab_track_type_1, tab_track_type_2, tab_track_type_3, tab_track_type_4, tab_track_type_5, tab_track_type_6, tab_track_type_7, scrollview_vehicle_selection, scrollview_vehicle_preview, searchBox, searchClearButton, filterLabel, filterDropdown, cargoLabel, cargoDropdown }; enum scrollIdx { vehicle_selection, vehicle_preview }; static constexpr uint32_t kTrainTabImages[16]{ InterfaceSkin::ImageIds::build_vehicle_train_frame_0, InterfaceSkin::ImageIds::build_vehicle_train_frame_1, InterfaceSkin::ImageIds::build_vehicle_train_frame_2, InterfaceSkin::ImageIds::build_vehicle_train_frame_3, InterfaceSkin::ImageIds::build_vehicle_train_frame_4, InterfaceSkin::ImageIds::build_vehicle_train_frame_5, InterfaceSkin::ImageIds::build_vehicle_train_frame_6, InterfaceSkin::ImageIds::build_vehicle_train_frame_7, InterfaceSkin::ImageIds::build_vehicle_train_frame_8, InterfaceSkin::ImageIds::build_vehicle_train_frame_9, InterfaceSkin::ImageIds::build_vehicle_train_frame_10, InterfaceSkin::ImageIds::build_vehicle_train_frame_11, InterfaceSkin::ImageIds::build_vehicle_train_frame_12, InterfaceSkin::ImageIds::build_vehicle_train_frame_13, InterfaceSkin::ImageIds::build_vehicle_train_frame_14, InterfaceSkin::ImageIds::build_vehicle_train_frame_15, }; static constexpr uint32_t kAircraftTabImages[16]{ InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_0, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_1, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_2, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_3, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_4, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_5, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_6, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_7, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_8, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_9, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_10, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_11, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_12, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_13, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_14, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_15, }; static constexpr uint32_t kBusTabImages[16]{ InterfaceSkin::ImageIds::build_vehicle_bus_frame_0, InterfaceSkin::ImageIds::build_vehicle_bus_frame_1, InterfaceSkin::ImageIds::build_vehicle_bus_frame_2, InterfaceSkin::ImageIds::build_vehicle_bus_frame_3, InterfaceSkin::ImageIds::build_vehicle_bus_frame_4, InterfaceSkin::ImageIds::build_vehicle_bus_frame_5, InterfaceSkin::ImageIds::build_vehicle_bus_frame_6, InterfaceSkin::ImageIds::build_vehicle_bus_frame_7, InterfaceSkin::ImageIds::build_vehicle_bus_frame_8, InterfaceSkin::ImageIds::build_vehicle_bus_frame_9, InterfaceSkin::ImageIds::build_vehicle_bus_frame_10, InterfaceSkin::ImageIds::build_vehicle_bus_frame_11, InterfaceSkin::ImageIds::build_vehicle_bus_frame_12, InterfaceSkin::ImageIds::build_vehicle_bus_frame_13, InterfaceSkin::ImageIds::build_vehicle_bus_frame_14, InterfaceSkin::ImageIds::build_vehicle_bus_frame_15, }; static constexpr uint32_t kTramTabImages[16]{ InterfaceSkin::ImageIds::build_vehicle_tram_frame_0, InterfaceSkin::ImageIds::build_vehicle_tram_frame_1, InterfaceSkin::ImageIds::build_vehicle_tram_frame_2, InterfaceSkin::ImageIds::build_vehicle_tram_frame_3, InterfaceSkin::ImageIds::build_vehicle_tram_frame_4, InterfaceSkin::ImageIds::build_vehicle_tram_frame_5, InterfaceSkin::ImageIds::build_vehicle_tram_frame_6, InterfaceSkin::ImageIds::build_vehicle_tram_frame_7, InterfaceSkin::ImageIds::build_vehicle_tram_frame_8, InterfaceSkin::ImageIds::build_vehicle_tram_frame_9, InterfaceSkin::ImageIds::build_vehicle_tram_frame_10, InterfaceSkin::ImageIds::build_vehicle_tram_frame_11, InterfaceSkin::ImageIds::build_vehicle_tram_frame_12, InterfaceSkin::ImageIds::build_vehicle_tram_frame_13, InterfaceSkin::ImageIds::build_vehicle_tram_frame_14, InterfaceSkin::ImageIds::build_vehicle_tram_frame_15, }; static constexpr uint32_t kTruckTabImages[16]{ InterfaceSkin::ImageIds::build_vehicle_truck_frame_0, InterfaceSkin::ImageIds::build_vehicle_truck_frame_1, InterfaceSkin::ImageIds::build_vehicle_truck_frame_2, InterfaceSkin::ImageIds::build_vehicle_truck_frame_3, InterfaceSkin::ImageIds::build_vehicle_truck_frame_4, InterfaceSkin::ImageIds::build_vehicle_truck_frame_5, InterfaceSkin::ImageIds::build_vehicle_truck_frame_6, InterfaceSkin::ImageIds::build_vehicle_truck_frame_7, InterfaceSkin::ImageIds::build_vehicle_truck_frame_8, InterfaceSkin::ImageIds::build_vehicle_truck_frame_9, InterfaceSkin::ImageIds::build_vehicle_truck_frame_10, InterfaceSkin::ImageIds::build_vehicle_truck_frame_11, InterfaceSkin::ImageIds::build_vehicle_truck_frame_12, InterfaceSkin::ImageIds::build_vehicle_truck_frame_13, InterfaceSkin::ImageIds::build_vehicle_truck_frame_14, InterfaceSkin::ImageIds::build_vehicle_truck_frame_15, }; static constexpr uint32_t kShipTabImages[16]{ InterfaceSkin::ImageIds::build_vehicle_ship_frame_0, InterfaceSkin::ImageIds::build_vehicle_ship_frame_1, InterfaceSkin::ImageIds::build_vehicle_ship_frame_2, InterfaceSkin::ImageIds::build_vehicle_ship_frame_3, InterfaceSkin::ImageIds::build_vehicle_ship_frame_4, InterfaceSkin::ImageIds::build_vehicle_ship_frame_5, InterfaceSkin::ImageIds::build_vehicle_ship_frame_6, InterfaceSkin::ImageIds::build_vehicle_ship_frame_7, InterfaceSkin::ImageIds::build_vehicle_ship_frame_8, InterfaceSkin::ImageIds::build_vehicle_ship_frame_9, InterfaceSkin::ImageIds::build_vehicle_ship_frame_10, InterfaceSkin::ImageIds::build_vehicle_ship_frame_11, InterfaceSkin::ImageIds::build_vehicle_ship_frame_12, InterfaceSkin::ImageIds::build_vehicle_ship_frame_13, InterfaceSkin::ImageIds::build_vehicle_ship_frame_14, InterfaceSkin::ImageIds::build_vehicle_ship_frame_15, }; struct TabDetails { VehicleType type; widx widgetIndex; const uint32_t* imageIds; }; static TabDetails _transportTypeTabInformation[] = { { VehicleType::train, tab_build_new_trains, kTrainTabImages }, { VehicleType::bus, tab_build_new_buses, kBusTabImages }, { VehicleType::truck, tab_build_new_trucks, kTruckTabImages }, { VehicleType::tram, tab_build_new_trams, kTramTabImages }, { VehicleType::aircraft, tab_build_new_aircraft, kAircraftTabImages }, { VehicleType::ship, tab_build_new_ships, kShipTabImages } }; // 0x5231D0 static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 380, 233 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 378, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary), Widgets::ImageButton({ 365, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 380, 192 }, WindowColour::secondary), // Primary tabs Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_new_train_vehicles), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_new_buses), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_new_trucks), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_new_trams), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_new_aircraft), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_new_ships), // Secondary tabs Widgets::Tab({ 5, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 36, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 67, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 98, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 129, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 160, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 191, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), Widgets::Tab({ 222, 43 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicles_for), // Scroll and preview areas Widgets::ScrollView({ 3, 102 }, { 374, 146 }, WindowColour::secondary, Scrollbars::vertical), Widgets::ScrollView({ 250, 44 }, { 180, 66 }, WindowColour::secondary, Scrollbars::none), // Filter options // NB: deliberately defined after scrollview definitions to keep enums the same as original // TODO: can be moved after drawVehicleOverview has been implemented Widgets::TextBox({ 4, 72 }, { 246, 14 }, WindowColour::secondary), Widgets::Button({ 50, 72 }, { 38, 14 }, WindowColour::secondary, StringIds::clearInput), Widgets::dropdownWidgets({ 3, 87 }, { 90, 12 }, WindowColour::secondary, StringIds::filterComponents), Widgets::dropdownWidgets({ 48, 87 }, { 90, 12 }, WindowColour::secondary, StringIds::filterCargoSupported) ); static constexpr uint32_t widxToTrackTypeTab(WidgetIndex_t widgetIndex) { return widgetIndex - widx::tab_track_type_0; } enum class VehicleFilterFlags : uint8_t { none = 0, powered = 1 << 0, unpowered = 1 << 1, locked = 1 << 2, unlocked = 1 << 3, }; OPENLOCO_ENABLE_ENUM_OPERATORS(VehicleFilterFlags); constexpr VehicleFilterFlags kMaskPoweredUnpowered = VehicleFilterFlags::powered | VehicleFilterFlags::unpowered; constexpr VehicleFilterFlags kMaskLockedUnlocked = VehicleFilterFlags::locked | VehicleFilterFlags::unlocked; enum class VehicleSortBy : uint8_t { designYear = 0, name = 1, }; static bool _lastDisplayLockedVehiclesState; static uint16_t _lastRefreshYear; static VehicleFilterFlags _vehicleFilterFlags = kMaskPoweredUnpowered | kMaskLockedUnlocked; static VehicleSortBy _vehicleSortBy = VehicleSortBy::designYear; static uint8_t _cargoSupportedFilter = 0xFF; static uint32_t _numTrackTypeTabs; // 0x011364EC static int16_t _numAvailableVehicles; // 0x01136268 // Array of types if 0xFF then no type, flag (1<<7) as well static uint8_t _trackTypesForTab[widxToTrackTypeTab(widx::tab_track_type_7) + 1]; // 0x011364F0 static uint16_t _availableVehicles[ObjectManager::getMaxObjects(ObjectType::vehicle)]; // 0x0113626A static int32_t _buildTargetVehicle; // 0x011364E8; -1 for no target VehicleHead static loco_global<EntityId, 0x0113642A> _113642A; // used by several windows/game commands/company ai static constexpr std::array<uint16_t, 6> kScrollRowHeight = { { 22, 22, 22, 22, 42, 30 } }; static Ui::TextInput::InputSession inputSession; static void setDisabledTransportTabs(Ui::Window* window); static void setTrackTypeTabs(Ui::Window* window); static void resetTrackTypeTabSelection(Ui::Window* window); static void setTopToolbarLastTrack(uint8_t trackType, bool isRoad); static void drawTransportTypeTabs(Ui::Window& window, Gfx::DrawingContext& drawingCtx); static void drawTrackTypeTabs(Ui::Window& window, Gfx::DrawingContext& drawingCtx); static const WindowEventList& getEvents(); // 0x4C1C64 static Window* create(CompanyId company) { auto window = WindowManager::createWindow(WindowType::buildVehicle, kWindowSize, WindowFlags::flag_11, getEvents()); window->setWidgets(_widgets); window->number = enumValue(company); window->owner = CompanyManager::getControllingId(); window->frameNo = 0; auto skin = OpenLoco::ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::secondary, skin->windowPlayerColor); } setDisabledTransportTabs(window); return window; } // 0x004C1AF7 static Window* open(uint32_t vehicleId, bool isTabId) { auto window = WindowManager::bringToFront(WindowType::buildVehicle, enumValue(CompanyManager::getControllingId())); if (window) { WidgetIndex_t tab = widx::tab_build_new_trains; if (!isTabId) { auto veh = EntityManager::get<Vehicles::VehicleHead>(EntityId(vehicleId)); if (veh == nullptr) { return nullptr; } tab += static_cast<uint8_t>(veh->vehicleType); } else { // Not a vehicle but a type tab += vehicleId; } window->callOnMouseUp(tab, window->widgets[tab].id); if (isTabId) { _buildTargetVehicle = -1; } else { _buildTargetVehicle = vehicleId; } } else { window = create(CompanyManager::getControllingId()); window->width = kWindowSize.width; window->height = kWindowSize.height; _buildTargetVehicle = -1; if (!isTabId) { _buildTargetVehicle = vehicleId; auto veh = EntityManager::get<Vehicles::VehicleHead>(EntityId(vehicleId)); if (veh == nullptr) { WindowManager::close(window); return nullptr; } window->currentTab = static_cast<uint8_t>(veh->vehicleType); } else { window->currentTab = vehicleId; } window->rowHeight = kScrollRowHeight[window->currentTab]; window->rowCount = 0; window->var_83C = 0; window->rowHover = -1; window->invalidate(); window->setWidgets(_widgets); window->holdableWidgets = 0; window->eventHandlers = &getEvents(); window->activatedWidgets = 0; setDisabledTransportTabs(window); setTrackTypeTabs(window); resetTrackTypeTabSelection(window); sub_4B92A5(window); window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); inputSession = Ui::TextInput::InputSession(); inputSession.calculateTextOffset(_widgets[widx::searchBox].width()); } if (_buildTargetVehicle == -1) { return window; } auto veh = EntityManager::get<Vehicles::VehicleBase>(EntityId(_buildTargetVehicle)); if (veh == nullptr) { return window; } auto targetTrackType = veh->getTrackType(); if (veh->getTransportMode() != TransportMode::rail) { targetTrackType |= (1 << 7); if (targetTrackType == 0xFF) { targetTrackType = getGameState().lastTrackTypeOption; } } WidgetIndex_t widgetIndex = widx::tab_track_type_0; for (uint32_t trackTypeTab = 0; trackTypeTab < _numTrackTypeTabs; trackTypeTab++) { if (targetTrackType == _trackTypesForTab[trackTypeTab]) { widgetIndex = widx::tab_track_type_0 + trackTypeTab; break; } } window->callOnMouseUp(widgetIndex, window->widgets[widgetIndex].id); return window; } Window* openByVehicleId(EntityId vehicleId) { return open(enumValue(vehicleId), false); } Window* openByType(VehicleType vehicleType) { return open(enumValue(vehicleType), true); } Window* openByVehicleObjectId(uint16_t vehicleObjectId) { auto* vehicleObj = ObjectManager::get<VehicleObject>(vehicleObjectId); auto window = openByType(vehicleObj->type); window->rowHover = vehicleObjectId; if (vehicleObj->mode == TransportMode::rail || vehicleObj->mode == TransportMode::road) { if (vehicleObj->trackType != 0xFF) { for (uint8_t i = 0; i < _numTrackTypeTabs && i < std::size(_trackTypesForTab); ++i) { if (vehicleObj->trackType == _trackTypesForTab[i]) { window->currentSecondaryTab = i; return window; } } } } auto rowHover = window->rowHover; sub_4B92A5(window); window->rowHover = rowHover; return window; } static bool contains(const std::string_view& a, const std::string_view& b) { return std::search(a.begin(), a.end(), b.begin(), b.end(), [](char a, char b) { return tolower(a) == tolower(b); }) != a.end(); } /* 0x4B9165 * Works out which vehicles are able to be built for this vehicle_type or vehicle */ static void generateBuildableVehiclesArray(VehicleType vehicleType, uint8_t trackType, Vehicles::VehicleBase* vehicle) { // Limit to available track types? if (trackType != 0xFF && (trackType & (1 << 7))) { auto trackIdx = trackType & ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(trackIdx); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { trackType = 0xFE; } } // Limit to what's available for a particular company? auto companyId = CompanyManager::getControllingId(); if (vehicle != nullptr) { companyId = vehicle->owner; } struct BuildableVehicle { uint16_t vehicleIndex; StringId name; bool isPowered; uint16_t designed; }; _numAvailableVehicles = 0; std::vector<BuildableVehicle> buildableVehicles; const bool showUnpoweredVehicles = (_vehicleFilterFlags & VehicleFilterFlags::unpowered) != VehicleFilterFlags::none; const bool showPoweredVehicles = (_vehicleFilterFlags & VehicleFilterFlags::powered) != VehicleFilterFlags::none; const bool showUnlockedVehicles = (_vehicleFilterFlags & VehicleFilterFlags::unlocked) != VehicleFilterFlags::none; const bool showLockedVehicles = (_vehicleFilterFlags & VehicleFilterFlags::locked) != VehicleFilterFlags::none && Config::get().displayLockedVehicles; for (uint16_t vehicleObjIndex = 0; vehicleObjIndex < ObjectManager::getMaxObjects(ObjectType::vehicle); ++vehicleObjIndex) { auto vehicleObj = ObjectManager::get<VehicleObject>(vehicleObjIndex); if (vehicleObj == nullptr) { continue; } if (vehicle && vehicle->isVehicleHead()) { auto* const head = vehicle->asVehicleHead(); if (!head->isVehicleTypeCompatible(vehicleObjIndex)) { continue; } } if (vehicleObj->type != vehicleType) { continue; } const auto* company = CompanyManager::get(companyId); if (!((showUnlockedVehicles && company->isVehicleIndexUnlocked(vehicleObjIndex)) || (showLockedVehicles && !company->isVehicleIndexUnlocked(vehicleObjIndex)))) { continue; } std::string_view pattern = inputSession.buffer; if (!pattern.empty()) { const std::string_view name = StringManager::getString(vehicleObj->name); if (!contains(name, pattern)) { continue; } } if (trackType != 0xFF) { uint8_t sanitisedTrackType = trackType; if (trackType & (1 << 7)) { if (vehicleObj->mode != TransportMode::road) { continue; } if (trackType == 0xFE) { sanitisedTrackType = 0xFF; } else { sanitisedTrackType = trackType & ~(1 << 7); } } else { if (vehicleObj->mode != TransportMode::rail) { continue; } } if (sanitisedTrackType != vehicleObj->trackType) { continue; } } if (_cargoSupportedFilter != 0xFF && _cargoSupportedFilter != 0xFE) { auto usableCargoTypes = vehicleObj->compatibleCargoCategories[0] | vehicleObj->compatibleCargoCategories[1]; if ((usableCargoTypes & (1 << _cargoSupportedFilter)) == 0) { continue; } } const bool isPowered = vehicleObj->power > 0; if (!((isPowered && showPoweredVehicles) || (!isPowered && showUnpoweredVehicles))) { continue; } const bool isCargoless = vehicleObj->compatibleCargoCategories[0] == 0 && vehicleObj->compatibleCargoCategories[1] == 0; if (_cargoSupportedFilter == 0xFE && !isCargoless) { continue; } buildableVehicles.push_back({ vehicleObjIndex, vehicleObj->name, isPowered, vehicleObj->designed }); } // Sort by name or design year if (_vehicleSortBy == VehicleSortBy::name) { std::sort(buildableVehicles.begin(), buildableVehicles.end(), [](const BuildableVehicle& item1, const BuildableVehicle& item2) { const std::string_view str1 = StringManager::getString(item1.name); const std::string_view str2 = StringManager::getString(item2.name); return str1 < str2; }); } else if (_vehicleSortBy == VehicleSortBy::designYear) { std::sort(buildableVehicles.begin(), buildableVehicles.end(), [](const BuildableVehicle& item1, const BuildableVehicle& item2) { return item1.designed < item2.designed; }); } // Group powered vehicles, if were not leaving (un)powered out if ((_vehicleFilterFlags & kMaskPoweredUnpowered) == kMaskPoweredUnpowered) { std::stable_sort(buildableVehicles.begin(), buildableVehicles.end(), [](const BuildableVehicle& item1, const BuildableVehicle& item2) { return item1.isPowered > item2.isPowered; }); } // Assign available vehicle positions for (size_t i = 0; i < buildableVehicles.size(); ++i) { _availableVehicles[i] = buildableVehicles[i].vehicleIndex; } _numAvailableVehicles = static_cast<int16_t>(buildableVehicles.size()); _lastRefreshYear = getCurrentYear(); _lastDisplayLockedVehiclesState = Config::get().displayLockedVehicles; } static Ui::Window* getTopEditingVehicleWindow() { for (auto i = (int32_t)WindowManager::count() - 1; i >= 0; i--) { auto w = WindowManager::get(i); if (w->type != WindowType::vehicle) { continue; } if (w->currentTab != 1) { continue; } auto vehicle = EntityManager::get<Vehicles::VehicleBase>(EntityId(w->number)); if (vehicle == nullptr) { continue; } if (vehicle->owner != CompanyManager::getControllingId()) { continue; } return w; } return nullptr; } /** * 0x004B92A5 * * @param window @<esi> */ void sub_4B92A5(Ui::Window* window) { auto w = getTopEditingVehicleWindow(); int32_t vehicleId = -1; if (w != nullptr) { vehicleId = w->number; } if (_buildTargetVehicle != vehicleId) { _buildTargetVehicle = vehicleId; window->var_83C = 0; window->invalidate(); } VehicleType vehicleType = _transportTypeTabInformation[window->currentTab].type; uint8_t trackType = _trackTypesForTab[window->currentSecondaryTab]; Vehicles::VehicleBase* veh = nullptr; if (_buildTargetVehicle != -1) { veh = EntityManager::get<Vehicles::VehicleBase>(EntityId(_buildTargetVehicle)); } generateBuildableVehiclesArray(vehicleType, trackType, veh); int numRows = _numAvailableVehicles; uint16_t* src = _availableVehicles; int16_t* dest = window->rowInfo; window->var_83C = numRows; window->rowCount = 0; while (numRows != 0) { *dest = *src; dest++; src++; numRows--; } window->rowHover = -1; window->invalidate(); } // 0x4C3576 static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close_button: WindowManager::close(&window); break; case widx::tab_build_new_trains: case widx::tab_build_new_buses: case widx::tab_build_new_trucks: case widx::tab_build_new_trams: case widx::tab_build_new_aircraft: case widx::tab_build_new_ships: { if (Input::hasFlag(Input::Flags::toolActive)) { ToolManager::toolCancel(window.type, window.number); } auto newTab = widgetIndex - widx::tab_build_new_trains; window.currentTab = newTab; window.rowHeight = kScrollRowHeight[newTab]; window.frameNo = 0; window.currentSecondaryTab = 0; if (newTab != enumValue(getGameState().lastBuildVehiclesOption)) { getGameState().lastBuildVehiclesOption = static_cast<VehicleType>(newTab); WindowManager::invalidate(WindowType::topToolbar, 0); } auto curViewport = window.viewports[0]; window.viewports[0] = nullptr; if (curViewport != nullptr) { curViewport->width = 0; } window.holdableWidgets = 0; window.eventHandlers = &getEvents(); window.setWidgets(_widgets); setDisabledTransportTabs(&window); window.invalidate(); _buildTargetVehicle = -1; setTrackTypeTabs(&window); resetTrackTypeTabSelection(&window); window.rowCount = 0; window.var_83C = 0; window.rowHover = -1; sub_4B92A5(&window); window.callOnResize(); window.callOnPeriodicUpdate(); window.callPrepareDraw(); window.initScrollWidgets(); window.invalidate(); window.moveInsideScreenEdges(); break; } case widx::tab_track_type_0: case widx::tab_track_type_1: case widx::tab_track_type_2: case widx::tab_track_type_3: case widx::tab_track_type_4: case widx::tab_track_type_5: case widx::tab_track_type_6: case widx::tab_track_type_7: { auto tab = widxToTrackTypeTab(widgetIndex); if (window.currentSecondaryTab == tab) { break; } window.currentSecondaryTab = tab; setTopToolbarLastTrack(_trackTypesForTab[tab] & ~(1 << 7), _trackTypesForTab[tab] & (1 << 7)); _buildTargetVehicle = -1; window.rowCount = 0; window.var_83C = 0; window.rowHover = -1; sub_4B92A5(&window); window.callOnResize(); window.callOnPeriodicUpdate(); window.callPrepareDraw(); window.initScrollWidgets(); window.invalidate(); break; } case widx::searchClearButton: { inputSession.clearInput(); sub_4B92A5(&window); window.initScrollWidgets(); window.invalidate(); break; } } } static void onMouseDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::filterDropdown) { auto& dropdown = self.widgets[widx::filterLabel]; auto numItems = Config::get().displayLockedVehicles ? 7 : 5; Dropdown::showText(self.x + dropdown.left, self.y + dropdown.top, dropdown.width() - 4, dropdown.height(), self.getColour(WindowColour::secondary), numItems, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::sortByDesignYear); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::sortByName); Dropdown::add(2, 0); Dropdown::add(3, StringIds::dropdown_without_checkmark, StringIds::componentUnpowered); Dropdown::add(4, StringIds::dropdown_without_checkmark, StringIds::componentPowered); if (Config::get().displayLockedVehicles) { Dropdown::add(5, StringIds::dropdown_without_checkmark, StringIds::componentUnlocked); Dropdown::add(6, StringIds::dropdown_without_checkmark, StringIds::componentLocked); } // Mark current sort order Dropdown::setItemSelected(enumValue(_vehicleSortBy)); // Show unpowered vehicles? if ((_vehicleFilterFlags & VehicleFilterFlags::unpowered) != VehicleFilterFlags::none) { Dropdown::setItemSelected(3); } // Show powered vehicles? if ((_vehicleFilterFlags & VehicleFilterFlags::powered) != VehicleFilterFlags::none) { Dropdown::setItemSelected(4); } // Show unlocked vehicles? if ((_vehicleFilterFlags & VehicleFilterFlags::unlocked) != VehicleFilterFlags::none) { Dropdown::setItemSelected(5); } // Show locked vehicles? if ((_vehicleFilterFlags & VehicleFilterFlags::locked) != VehicleFilterFlags::none) { Dropdown::setItemSelected(6); } } else if (widgetIndex == widx::cargoDropdown) { auto index = 0U; auto selectedIndex = -1; Dropdown::add(index++, StringIds::dropdown_stringid, StringIds::allCargoTypes); if (_cargoSupportedFilter == 0xFF) { selectedIndex = 0; } Dropdown::add(index++, StringIds::dropdown_stringid, StringIds::filterCargoless); if (_cargoSupportedFilter == 0xFE) { selectedIndex = 1; } for (uint16_t cargoId = 0; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoId) { auto cargoObj = ObjectManager::get<CargoObject>(cargoId); if (cargoObj == nullptr) { continue; } FormatArguments args{}; args.push(cargoObj->name); args.push(cargoObj->unitInlineSprite); args.push(cargoId); Dropdown::add(index, StringIds::supportsCargoIdSprite, args); if (_cargoSupportedFilter == cargoId) { selectedIndex = index; } index++; } Widget dropdown = self.widgets[widx::cargoLabel]; Dropdown::showText(self.x + dropdown.left, self.y + dropdown.top, dropdown.width() - 4, dropdown.height(), self.getColour(WindowColour::secondary), index, 0x80); if (selectedIndex != -1) { Dropdown::setItemSelected(selectedIndex); } } } static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (itemIndex < 0) { return; } if (widgetIndex == widx::filterDropdown) { if (itemIndex == 0) { _vehicleSortBy = VehicleSortBy::designYear; } else if (itemIndex == 1) { _vehicleSortBy = VehicleSortBy::name; } else if (itemIndex == 3) { _vehicleFilterFlags ^= VehicleFilterFlags::unpowered; } else if (itemIndex == 4) { _vehicleFilterFlags ^= VehicleFilterFlags::powered; } else if (itemIndex == 5) { _vehicleFilterFlags ^= VehicleFilterFlags::unlocked; } else if (itemIndex == 6) { _vehicleFilterFlags ^= VehicleFilterFlags::locked; } } else if (widgetIndex == widx::cargoDropdown) { if (itemIndex >= 2) { _cargoSupportedFilter = Dropdown::getItemArgument(itemIndex, 3); } else if (itemIndex == 0) { _cargoSupportedFilter = 0xFF; } else if (itemIndex == 1) { _cargoSupportedFilter = 0xFE; } } sub_4B92A5(&self); self.invalidate(); } // 0x4C3929 static void onResize(Window& window) { window.flags |= WindowFlags::resizable; auto minWidth = std::max<uint16_t>(_numTrackTypeTabs * 31 + 195, 380); window.setSize({ minWidth, 233 }, { 520, 600 }); auto& scrollArea = window.scrollAreas[scrollIdx::vehicle_selection]; auto& scrollWidget = window.widgets[widx::scrollview_vehicle_selection]; auto scrollPosition = std::max(0, scrollArea.contentHeight - scrollWidget.bottom + scrollWidget.top); if (scrollPosition < scrollArea.contentOffsetY) { scrollArea.contentOffsetY = scrollPosition; Ui::ScrollView::updateThumbs(window, widx::scrollview_vehicle_selection); } if (window.rowHover != -1) { return; } if (window.var_83C == 0) { return; } window.rowHover = window.rowInfo[0]; window.invalidate(); } // 0x4C377B, 0x4C3923 static void onUpdate(Window& window) { // Is the linked vehicle still available? const bool linkedVehicleAvailable = window.number && WindowManager::find(WindowType::vehicle, window.number); // Do we need to refresh the component list? if (!linkedVehicleAvailable || _lastRefreshYear != getCurrentYear() || _lastDisplayLockedVehiclesState != Config::get().displayLockedVehicles) { sub_4B92A5(&window); } window.frameNo++; window.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::buildVehicle, window.number, widx::tab_build_new_trains + window.currentTab); WindowManager::invalidateWidget(WindowType::buildVehicle, window.number, widx::tab_track_type_0 + (window.currentSecondaryTab & 0xFF)); WindowManager::invalidateWidget(WindowType::buildVehicle, window.number, widx::scrollview_vehicle_preview); inputSession.cursorFrame++; if ((inputSession.cursorFrame % 16) == 0) { WindowManager::invalidateWidget(WindowType::buildVehicle, window.number, widx::searchBox); } } // 0x4C37B9 static void getScrollSize(Ui::Window& window, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = window.var_83C * window.rowHeight; } // 0x4C384B static void onScrollMouseDown(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, uint8_t scroll_index) { if (scroll_index != scrollIdx::vehicle_selection) { return; } auto scrollItem = y / window.rowHeight; if (scrollItem >= window.var_83C) { return; } auto pan = window.width / 2 + window.x; Audio::playSound(Audio::SoundId::clickDown, pan); auto item = window.rowInfo[scrollItem]; auto vehicleObj = ObjectManager::get<VehicleObject>(item); auto args = FormatArguments::common(); // Skip 5 * 2 bytes args.skip(10); args.push(vehicleObj->name); GameCommands::setErrorTitle(StringIds::cant_build_pop_5_string_id); if (_buildTargetVehicle != -1) { auto vehicle = EntityManager::get<Vehicles::VehicleHead>(EntityId(_buildTargetVehicle)); if (vehicle != nullptr) { args.push(vehicle->name); args.push(vehicle->ordinalNumber); GameCommands::setErrorTitle(StringIds::cant_add_pop_5_string_id_string_id); } } GameCommands::VehicleCreateArgs gcArgs{}; gcArgs.vehicleId = EntityId(_buildTargetVehicle); gcArgs.vehicleType = item; if (GameCommands::doCommand(gcArgs, GameCommands::Flags::apply) == GameCommands::FAILURE) { return; } if (_buildTargetVehicle == -1) { auto vehicle = EntityManager::get<Vehicles::VehicleBase>(_113642A); Vehicle::Details::open(vehicle); } sub_4B92A5(&window); } // 0x4C3802 static void onScrollMouseOver(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, uint8_t scroll_index) { if (scroll_index != scrollIdx::vehicle_selection) { return; } auto scrollItem = y / window.rowHeight; int16_t item = -1; if (scrollItem < window.var_83C) { item = window.rowInfo[scrollItem]; } if (item != -1 && item != window.rowHover) { window.rowHover = item; window.invalidate(); } } // 0x4C370C static std::optional<FormatArguments> tooltip(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; if (widgetIndex < widx::tab_track_type_0 || widgetIndex >= widx::scrollview_vehicle_selection) { args.push(StringIds::tooltip_scroll_new_vehicle_list); } else { auto trackTypeTab = widxToTrackTypeTab(widgetIndex); auto type = _trackTypesForTab[trackTypeTab]; if (type == 0xFF) { if (_transportTypeTabInformation[window.currentTab].type == VehicleType::aircraft) { args.push(StringIds::airport); } else { args.push(StringIds::docks); } } else { bool is_road = type & (1 << 7); type &= ~(1 << 7); if (is_road) { auto roadObj = ObjectManager::get<RoadObject>(type); args.push(roadObj->name); } else { auto trackObj = ObjectManager::get<TrackObject>(type); args.push(trackObj->name); } } } return args; } // 0x4C37CB static Ui::CursorId cursor(Window& window, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, Ui::CursorId fallback) { if (widgetIdx != widx::scrollview_vehicle_selection) { return fallback; } auto scrollItem = yPos / window.rowHeight; if (scrollItem >= window.var_83C) { return fallback; } if (window.rowInfo[scrollItem] == -1) { return fallback; } return CursorId::handPointer; } // 0x4C2E5C static void prepareDraw(Ui::Window& window) { setDisabledTransportTabs(&window); // Mask off all the tabs auto activeWidgets = window.activatedWidgets & ((1 << frame) | (1 << caption) | (1 << close_button) | (1 << panel) | (1 << scrollview_vehicle_selection) | (1 << scrollview_vehicle_preview)); // Only activate the singular tabs activeWidgets |= 1ULL << _transportTypeTabInformation[window.currentTab].widgetIndex; activeWidgets |= 1ULL << (window.currentSecondaryTab + widx::tab_track_type_0); window.activatedWidgets = activeWidgets; window.widgets[widx::caption].text = window.currentTab + StringIds::build_trains; auto width = window.width; auto height = window.height; window.widgets[widx::frame].right = width - 1; window.widgets[widx::frame].bottom = height - 1; window.widgets[widx::panel].right = width - 1; window.widgets[widx::panel].bottom = height - 1; window.widgets[widx::caption].right = width - 2; window.widgets[widx::close_button].left = width - 15; window.widgets[widx::close_button].right = width - 3; window.widgets[widx::scrollview_vehicle_preview].right = width - 4; window.widgets[widx::scrollview_vehicle_preview].left = width - 184; auto& selectionList = window.widgets[widx::scrollview_vehicle_selection]; selectionList.right = width - 187; selectionList.bottom = height - 14; window.widgets[widx::searchClearButton].right = selectionList.right; window.widgets[widx::searchClearButton].left = selectionList.right - 40; window.widgets[widx::searchBox].right = selectionList.right - 42; window.widgets[widx::cargoLabel].right = selectionList.right; window.widgets[widx::cargoLabel].left = selectionList.right - (selectionList.width() / 2); window.widgets[widx::cargoDropdown].right = selectionList.right; window.widgets[widx::cargoDropdown].left = selectionList.right - 12; if (_cargoSupportedFilter == 0xFF) { window.widgets[widx::cargoLabel].text = StringIds::filterCargoSupported; } else if (_cargoSupportedFilter == 0xFE) { window.widgets[widx::cargoLabel].text = StringIds::filterCargoless; } else { window.widgets[widx::cargoLabel].text = StringIds::empty; } window.widgets[widx::filterLabel].right = window.widgets[widx::cargoLabel].left - 1; window.widgets[widx::filterDropdown].right = window.widgets[widx::cargoLabel].left - 2; window.widgets[widx::filterDropdown].left = window.widgets[widx::filterDropdown].right - 11; Widget::leftAlignTabs(window, widx::tab_build_new_trains, widx::tab_build_new_ships); } static void drawSearchBox(Window& self, Gfx::DrawingContext& drawingCtx) { char* textBuffer = (char*)StringManager::getString(StringIds::buffer_2039); strncpy(textBuffer, inputSession.buffer.c_str(), 256); auto& widget = _widgets[widx::searchBox]; auto clipped = Gfx::clipRenderTarget(drawingCtx.currentRenderTarget(), Ui::Rect(self.x + widget.left, widget.top + 1 + self.y, widget.width() - 2, widget.height() - 2)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); auto tr = Gfx::TextRenderer(drawingCtx); // Draw search box input buffer FormatArguments args{}; args.push(StringIds::buffer_2039); Ui::Point position = { inputSession.xOffset, 1 }; tr.drawStringLeft(position, Colour::black, StringIds::black_stringid, args); // Draw search box cursor, blinking if (Input::isFocused(self.type, self.number, widx::searchBox) && (inputSession.cursorFrame % 32) < 16) { // We draw the string again to figure out where the cursor should go; position.x will be adjusted textBuffer[inputSession.cursorPosition] = '\0'; position = { inputSession.xOffset, 1 }; position = tr.drawStringLeft(position, Colour::black, StringIds::black_stringid, args); drawingCtx.fillRect(position.x, position.y, position.x, position.y + 9, Colours::getShade(self.getColour(WindowColour::secondary).c(), 9), Gfx::RectFlags::none); } drawingCtx.popRenderTarget(); } // 0x4C2F23 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); drawTransportTypeTabs(self, drawingCtx); drawTrackTypeTabs(self, drawingCtx); drawSearchBox(self, drawingCtx); { auto bottomLeftMessage = StringIds::select_new_vehicle; FormatArguments args{}; if (_buildTargetVehicle != -1) { auto vehicle = EntityManager::get<Vehicles::VehicleHead>(EntityId(_buildTargetVehicle)); if (vehicle != nullptr) { args.push(vehicle->name); args.push(vehicle->ordinalNumber); bottomLeftMessage = StringIds::select_vehicle_to_add_to_string_id; } } auto point = Point(self.x + 2, self.y + self.height - 13); tr.drawStringLeftClipped(point, self.width - 186, Colour::black, bottomLeftMessage, args); } if (_cargoSupportedFilter != 0xFF && _cargoSupportedFilter != 0xFE) { auto cargoObj = ObjectManager::get<CargoObject>(_cargoSupportedFilter); FormatArguments args{}; args.push(StringIds::cargoIdSprite); args.push(cargoObj->name); args.push(cargoObj->unitInlineSprite); auto& widget = self.widgets[widx::cargoLabel]; auto point = Point(self.x + widget.left + 2, self.y + widget.top); tr.drawStringLeftClipped(point, widget.width() - 15, Colour::black, StringIds::wcolour2_stringid, args); } if (self.rowHover == -1) { return; } auto vehicleObj = ObjectManager::get<VehicleObject>(self.rowHover); auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); { auto cost = Economy::getInflationAdjustedCost(vehicleObj->costFactor, vehicleObj->costIndex, 6); FormatArguments args{}; args.push(cost); buffer = StringManager::formatString(buffer, StringIds::stats_cost, args); } { auto runningCost = Economy::getInflationAdjustedCost(vehicleObj->runCostFactor, vehicleObj->runCostIndex, 10); FormatArguments args{}; args.push(runningCost); buffer = StringManager::formatString(buffer, StringIds::stats_running_cost, args); } if (vehicleObj->designed != 0) { FormatArguments args{}; args.push(vehicleObj->designed); const auto* company = CompanyManager::get(CompanyManager::getControllingId()); auto unlocked = company->isVehicleIndexUnlocked(self.rowHover); buffer = StringManager::formatString( buffer, unlocked ? StringIds::stats_designed : StringIds::stats_proposed_design, args); } if (vehicleObj->obsolete != 0 && vehicleObj->obsolete != std::numeric_limits<uint16_t>::max()) { FormatArguments args{}; args.push(vehicleObj->obsolete); buffer = StringManager::formatString(buffer, StringIds::stats_obsolete, args); } if (vehicleObj->mode == TransportMode::rail || vehicleObj->mode == TransportMode::road) { buffer = StringManager::formatString(buffer, StringIds::stats_requires); auto trackName = StringIds::road; if (vehicleObj->mode == TransportMode::road) { if (vehicleObj->trackType != 0xFF) { trackName = ObjectManager::get<RoadObject>(vehicleObj->trackType)->name; } } else { trackName = ObjectManager::get<TrackObject>(vehicleObj->trackType)->name; } buffer = StringManager::formatString(buffer, trackName); for (auto i = 0; i < vehicleObj->numTrackExtras; ++i) { strcpy(buffer, " + "); buffer += 3; if (vehicleObj->mode == TransportMode::road) { auto roadExtraObj = ObjectManager::get<RoadExtraObject>(vehicleObj->requiredTrackExtras[i]); buffer = StringManager::formatString(buffer, roadExtraObj->name); } else { auto trackExtraObj = ObjectManager::get<TrackExtraObject>(vehicleObj->requiredTrackExtras[i]); buffer = StringManager::formatString(buffer, trackExtraObj->name); } } if (vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { auto trackExtraObj = ObjectManager::get<TrackExtraObject>(vehicleObj->rackRailType); FormatArguments args{}; args.push(trackExtraObj->name); buffer = StringManager::formatString(buffer, StringIds::stats_string_steep_slope, args); } } if (vehicleObj->power != 0) { if (vehicleObj->mode == TransportMode::rail || vehicleObj->mode == TransportMode::road) { FormatArguments args{}; args.push(vehicleObj->power); buffer = StringManager::formatString(buffer, StringIds::stats_power, args); } } { FormatArguments args{}; args.push<uint32_t>(StringManager::internalLengthToComma1DP(vehicleObj->getLength())); buffer = StringManager::formatString(buffer, StringIds::stats_length, args); } { FormatArguments args{}; args.push(vehicleObj->weight); buffer = StringManager::formatString(buffer, StringIds::stats_weight, args); } { FormatArguments args{}; args.push(vehicleObj->speed.getRaw()); buffer = StringManager::formatString(buffer, StringIds::stats_max_speed, args); } if (vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { auto trackExtraObj = ObjectManager::get<TrackExtraObject>(vehicleObj->rackRailType); FormatArguments args{}; args.push(vehicleObj->rackSpeed); args.push(trackExtraObj->name); buffer = StringManager::formatString(buffer, StringIds::stats_velocity_on_string, args); } vehicleObj->getCargoString(buffer); auto x = self.widgets[widx::scrollview_vehicle_selection].right + self.x + 2; auto y = self.widgets[widx::scrollview_vehicle_preview].bottom + self.y + 2; tr.drawStringLeftWrapped(Point(x, y), 180, Colour::black, StringIds::buffer_1250); } // 0x4C3307 static void drawScroll(Ui::Window& window, Gfx::DrawingContext& drawingCtx, const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); switch (scrollIndex) { case scrollIdx::vehicle_selection: { auto colour = Colours::getShade(window.getColour(WindowColour::secondary).c(), 4); drawingCtx.clear(colour * 0x01010101); if (window.var_83C == 0) { auto defaultMessage = StringIds::no_vehicles_available; FormatArguments args{}; if (_buildTargetVehicle != -1) { auto vehicle = EntityManager::get<Vehicles::VehicleHead>(EntityId(_buildTargetVehicle)); if (vehicle != nullptr) { defaultMessage = StringIds::no_compatible_vehicles_available; args.push(vehicle->name); args.push(vehicle->ordinalNumber); } } auto widget = window.widgets[widx::scrollview_vehicle_selection]; auto width = widget.right - widget.left - 17; auto point = Point(3, (window.rowHeight - 10) / 2); tr.drawStringLeftWrapped(point, width, Colour::black, defaultMessage, args); } else { int16_t y = 0; for (auto i = 0; i < window.var_83C; ++i, y += window.rowHeight) { if (y + window.rowHeight + 30 <= rt.y) { continue; } if (y >= rt.y + rt.height + 30) { break; } auto vehicleType = window.rowInfo[i]; if (vehicleType == -1) { continue; } const auto* company = CompanyManager::get(CompanyManager::getControllingId()); auto rowIsALockedVehicle = !company->isVehicleIndexUnlocked(vehicleType) && !Config::get().buildLockedVehicles; auto colouredString = StringIds::black_stringid; const auto lockedHoverRowColour = PaletteIndex::mutedDarkRed3; constexpr auto normalHoverRowColour = enumValue(ExtColour::unk30); const auto lockedRowColour = PaletteIndex::mutedDarkRed5; if (window.rowHover == vehicleType) { if (rowIsALockedVehicle) { drawingCtx.fillRect(0, y, window.width, y + window.rowHeight - 1, lockedHoverRowColour, Gfx::RectFlags::crossHatching); } else { drawingCtx.fillRect(0, y, window.width, y + window.rowHeight - 1, normalHoverRowColour, Gfx::RectFlags::transparent); } colouredString = StringIds::wcolour2_stringid; } else { if (rowIsALockedVehicle) { drawingCtx.fillRect(0, y, window.width, y + window.rowHeight - 1, lockedRowColour, Gfx::RectFlags::crossHatching); } } int16_t half = (window.rowHeight - 22) / 2; auto x = drawVehicleInline(drawingCtx, vehicleType, CompanyManager::getControllingId(), { 0, static_cast<int16_t>(y + half) }); auto vehicleObj = ObjectManager::get<VehicleObject>(vehicleType); FormatArguments args{}; args.push(vehicleObj->name); half = (window.rowHeight - 10) / 2; auto point = Point(x + 3, y + half); tr.drawStringLeft(point, Colour::black, colouredString, args); } } break; } case scrollIdx::vehicle_preview: { auto colour = Colours::getShade(window.getColour(WindowColour::secondary).c(), 0); // Gfx::clear needs the colour copied to each byte of eax drawingCtx.clear(colour * 0x01010101); if (window.rowHover == -1) { break; } uint8_t yaw = Ui::WindowManager::getVehiclePreviewRotationFrameYaw(); uint8_t roll = Ui::WindowManager::getVehiclePreviewRotationFrameRoll(); drawVehicleOverview(drawingCtx, { 90, 37 }, window.rowHover, yaw, roll, CompanyManager::getControllingId()); auto vehicleObj = ObjectManager::get<VehicleObject>(window.rowHover); auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); buffer = StringManager::formatString(buffer, vehicleObj->name); auto usableCargoTypes = vehicleObj->compatibleCargoCategories[0] | vehicleObj->compatibleCargoCategories[1]; for (auto cargoTypes = Numerics::bitScanForward(usableCargoTypes); cargoTypes != -1; cargoTypes = Numerics::bitScanForward(usableCargoTypes)) { usableCargoTypes &= ~(1 << cargoTypes); auto cargoObj = ObjectManager::get<CargoObject>(cargoTypes); *buffer++ = ' '; *buffer++ = ControlCodes::inlineSpriteStr; *(reinterpret_cast<uint32_t*>(buffer)) = cargoObj->unitInlineSprite; buffer += 4; } *buffer++ = '\0'; FormatArguments args{}; args.push(StringIds::buffer_1250); tr.drawStringCentredClipped(Point(89, 52), 177, Colour::darkOrange, StringIds::wcolour2_stringid, args); break; } } } // 0x4C28D2 static void setDisabledTransportTabs(Ui::Window* window) { auto availableVehicles = CompanyManager::get(CompanyId(window->number))->availableVehicles; // By shifting by 4 the available_vehicles flags align with the tabs flags auto disabledTabs = (availableVehicles << 4) ^ ((1 << widx::tab_build_new_trains) | (1 << widx::tab_build_new_buses) | (1 << widx::tab_build_new_trucks) | (1 << widx::tab_build_new_trams) | (1 << widx::tab_build_new_aircraft) | (1 << widx::tab_build_new_ships)); window->disabledWidgets = disabledTabs; } // 0x4C2D8A static void setTrackTypeTabs(Ui::Window* window) { VehicleType currentTransportTabType = _transportTypeTabInformation[window->currentTab].type; generateBuildableVehiclesArray(currentTransportTabType, 0xFF, nullptr); auto railTrackTypes = 0; auto roadTrackTypes = 0; for (auto i = 0; i < _numAvailableVehicles; i++) { auto vehicleObj = ObjectManager::get<VehicleObject>(_availableVehicles[i]); if (vehicleObj && vehicleObj->mode == TransportMode::rail) { railTrackTypes |= (1 << vehicleObj->trackType); } else if (vehicleObj && vehicleObj->mode == TransportMode::road) { auto trackType = vehicleObj->trackType; if (trackType == 0xFF) { trackType = getGameState().lastTrackTypeOption; } roadTrackTypes |= (1 << trackType); } else { // Reset the tabs _trackTypesForTab[0] = 0xFF; _numTrackTypeTabs = 1; window->widgets[tab_track_type_0].hidden = false; for (WidgetIndex_t j = tab_track_type_1; j <= tab_track_type_7; ++j) { window->widgets[j].hidden = true; } return; } } WidgetIndex_t trackTypeTab = tab_track_type_0; auto trackType = 0; for (trackType = Numerics::bitScanForward(railTrackTypes); trackType != -1 && trackTypeTab <= tab_track_type_7; trackType = Numerics::bitScanForward(railTrackTypes)) { railTrackTypes &= ~(1 << trackType); window->widgets[trackTypeTab].hidden = false; _trackTypesForTab[widxToTrackTypeTab(trackTypeTab)] = trackType; trackTypeTab++; } if (trackType == -1 && trackTypeTab <= tab_track_type_7) { for (trackType = Numerics::bitScanForward(roadTrackTypes); trackType != -1 && trackTypeTab <= tab_track_type_7; trackType = Numerics::bitScanForward(roadTrackTypes)) { roadTrackTypes &= ~(1 << trackType); window->widgets[trackTypeTab].hidden = false; _trackTypesForTab[widxToTrackTypeTab(trackTypeTab)] = trackType | (1 << 7); trackTypeTab++; } } _numTrackTypeTabs = widxToTrackTypeTab(trackTypeTab); for (; trackTypeTab <= tab_track_type_7; ++trackTypeTab) { window->widgets[trackTypeTab].hidden = true; } } // 0x4C1CBE // if previous track tab on previous transport type tab is also compatible keeps it on that track type static void resetTrackTypeTabSelection(Ui::Window* window) { auto transportType = _transportTypeTabInformation[window->currentTab].type; if (transportType == VehicleType::aircraft || transportType == VehicleType::ship) { window->currentSecondaryTab = 0; return; } bool found = false; uint32_t trackTab = 0; for (; trackTab < _numTrackTypeTabs; trackTab++) { if (getGameState().lastRailroadOption == _trackTypesForTab[trackTab]) { found = true; break; } if (getGameState().lastRoadOption == _trackTypesForTab[trackTab]) { found = true; break; } } trackTab = found ? trackTab : 0; window->currentSecondaryTab = trackTab; bool isRoad = _trackTypesForTab[trackTab] & (1 << 7); uint8_t trackType = _trackTypesForTab[trackTab] & ~(1 << 7); setTopToolbarLastTrack(trackType, isRoad); } // 0x4A3A06 static void setTopToolbarLastTrack(uint8_t trackType, bool isRoad) { bool setRail = false; if (isRoad) { auto road_obj = ObjectManager::get<RoadObject>(trackType); if (road_obj && road_obj->hasFlags(RoadObjectFlags::unk_01)) { setRail = true; } } else { auto rail_obj = ObjectManager::get<TrackObject>(trackType); if (rail_obj && !rail_obj->hasFlags(TrackObjectFlags::unk_02)) { setRail = true; } } if (setRail) { getGameState().lastRailroadOption = trackType | (isRoad ? (1 << 7) : 0); } else { getGameState().lastRoadOption = trackType | (isRoad ? (1 << 7) : 0); } // The window number doesn't really matter as there is only one top toolbar WindowManager::invalidate(WindowType::topToolbar, 0); } // 0x4C2BFD static void drawTransportTypeTabs(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); auto companyColour = CompanyManager::getCompanyColour(CompanyId(window.number)); for (const auto& tab : _transportTypeTabInformation) { auto frameNo = 0; if (_transportTypeTabInformation[window.currentTab].type == tab.type) { frameNo = (window.frameNo / 2) & 0xF; } uint32_t image = Gfx::recolour(skin->img + tab.imageIds[frameNo], companyColour); Widget::drawTab(window, drawingCtx, image, tab.widgetIndex); } } // 0x4C28F1 static void drawTrackTypeTabs(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); auto companyColour = CompanyManager::getCompanyColour(CompanyId(window.number)); auto left = window.x; auto top = window.y + 69; auto right = left + window.width - 187; auto bottom = top; drawingCtx.fillRect(left, top, right, bottom, Colours::getShade(window.getColour(WindowColour::secondary).c(), 7), Gfx::RectFlags::none); left = window.x + window.width - 187; top = window.y + 41; right = left; bottom = top + 27; drawingCtx.fillRect(left, top, right, bottom, Colours::getShade(window.getColour(WindowColour::secondary).c(), 7), Gfx::RectFlags::none); for (uint32_t tab = 0; tab < _numTrackTypeTabs; ++tab) { const auto widget = window.widgets[tab + widx::tab_track_type_0]; if (window.currentSecondaryTab == tab) { left = widget.left + window.x + 1; top = widget.top + window.y + 26; right = left + 29; bottom = top; drawingCtx.fillRect(left, top, right, bottom, Colours::getShade(window.getColour(WindowColour::secondary).c(), 5), Gfx::RectFlags::none); } auto img = 0; auto type = _trackTypesForTab[tab]; if (type == 0xFF) { if (window.currentTab == (widx::tab_build_new_aircraft - widx::tab_build_new_trains)) { img = skin->img + InterfaceSkin::ImageIds::toolbar_menu_airport; } else { img = skin->img + InterfaceSkin::ImageIds::toolbar_menu_ship_port; } // Original saved the company colour in the img but didn't set the recolour flag } else if (type & (1 << 7)) // is_road { type &= ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(type); img = roadObj->image; if (window.currentSecondaryTab == tab) { img += (window.frameNo / 4) & 0x1F; } img = Gfx::recolour(img, companyColour); } else { auto trackObj = ObjectManager::get<TrackObject>(type); img = trackObj->image + TrackObj::ImageIds::kUiPreviewImage0; if (window.currentSecondaryTab == tab) { // TODO: Use array from Construction/Common.cpp img += (window.frameNo / 4) & 0xF; } img = Gfx::recolour(img, companyColour); } Widget::drawTab(window, drawingCtx, img, tab + widx::tab_track_type_0); } } static bool keyUp(Window& w, uint32_t charCode, uint32_t keyCode) { if (!Input::isFocused(w.type, w.number, widx::searchBox)) { return false; } if (!inputSession.handleInput(charCode, keyCode)) { return false; } int containerWidth = _widgets[widx::searchBox].width() - 2; if (inputSession.needsReoffsetting(containerWidth)) { inputSession.calculateTextOffset(containerWidth); } inputSession.cursorFrame = 0; sub_4B92A5(&w); w.initScrollWidgets(); w.invalidate(); return true; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, .keyUp = keyUp, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Cheats.cpp ```cpp #include "Config.h" #include "Date.h" #include "GameCommands/Cheats/Cheat.h" #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Scenario.h" #include "Ui/Dropdown.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/GroupBoxWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/StepperWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TextBoxWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Math/Bound.hpp> using OpenLoco::GameCommands::CheatCommand; namespace OpenLoco::Ui::Windows::Cheats { namespace Common { namespace Widx { enum { frame, title, close_button, panel, tab_finances, tab_companies, tab_vehicles, tab_towns, }; // this should be 1 more than the number of widgets defined above in commonWidgets constexpr uint32_t nextWidx = 8; } static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, frameHeight - 41 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab)); } static void drawTabs(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Finances tab { static constexpr uint32_t financesTabImageIds[] = { InterfaceSkin::ImageIds::tab_finances_frame0, InterfaceSkin::ImageIds::tab_finances_frame1, InterfaceSkin::ImageIds::tab_finances_frame2, InterfaceSkin::ImageIds::tab_finances_frame3, InterfaceSkin::ImageIds::tab_finances_frame4, InterfaceSkin::ImageIds::tab_finances_frame5, InterfaceSkin::ImageIds::tab_finances_frame6, InterfaceSkin::ImageIds::tab_finances_frame7, InterfaceSkin::ImageIds::tab_finances_frame8, InterfaceSkin::ImageIds::tab_finances_frame9, InterfaceSkin::ImageIds::tab_finances_frame10, InterfaceSkin::ImageIds::tab_finances_frame11, InterfaceSkin::ImageIds::tab_finances_frame12, InterfaceSkin::ImageIds::tab_finances_frame13, InterfaceSkin::ImageIds::tab_finances_frame14, InterfaceSkin::ImageIds::tab_finances_frame15, }; uint32_t imageId = skin->img; if (self.currentTab == Widx::tab_finances - Widx::tab_finances) { imageId += financesTabImageIds[(self.frameNo / 2) % std::size(financesTabImageIds)]; } else { imageId += financesTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, Widx::tab_finances); } // Companies tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::tab_company; Widget::drawTab(self, drawingCtx, imageId, Widx::tab_companies); } // Vehicles tab { static constexpr uint32_t vehiclesTabImageIds[] = { InterfaceSkin::ImageIds::vehicle_train_frame_0, InterfaceSkin::ImageIds::vehicle_train_frame_1, InterfaceSkin::ImageIds::vehicle_train_frame_2, InterfaceSkin::ImageIds::vehicle_train_frame_3, InterfaceSkin::ImageIds::vehicle_train_frame_4, InterfaceSkin::ImageIds::vehicle_train_frame_5, InterfaceSkin::ImageIds::vehicle_train_frame_6, InterfaceSkin::ImageIds::vehicle_train_frame_7, }; uint32_t imageId = skin->img; if (self.currentTab == Widx::tab_vehicles - Widx::tab_finances) { imageId += vehiclesTabImageIds[(self.frameNo / 2) % std::size(vehiclesTabImageIds)]; } else { imageId += vehiclesTabImageIds[0]; } auto companyId = CompanyManager::getControllingId(); auto companyColour = CompanyManager::getCompanyColour(companyId); imageId = Gfx::recolour(imageId, companyColour); Widget::drawTab(self, drawingCtx, imageId, Widx::tab_vehicles); } // Towns tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::toolbar_menu_towns; Widget::drawTab(self, drawingCtx, imageId, Widx::tab_towns); } } static void switchTab(Window& self, WidgetIndex_t widgetIndex); } namespace Finances { static constexpr Ui::Size32 kWindowSize = { 250, 210 }; namespace Widx { enum { cash_step_group = Common::Widx::nextWidx, cash_step_label, cash_step_value, cash_step_decrease, cash_step_increase, cash_step_apply, loan_group, loan_label, loan_value, loan_clear, time_group, year_label, year_step_value, year_step_decrease, year_step_increase, month_label, month_step_value, month_step_decrease, month_step_increase, day_label, day_step_value, day_step_decrease, day_step_increase, date_change_apply, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize.width, kWindowSize.height, StringIds::financial_cheats), // money Widgets::GroupBox({ 4, 48 }, { kWindowSize.width - 8, 33 }, WindowColour::secondary, StringIds::cheat_increase_funds), Widgets::Label({ 10, 62 }, { 70, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::cheat_amount), Widgets::stepperWidgets({ 80, 62 }, { 95, 12 }, WindowColour::secondary, StringIds::cheat_loan_value), Widgets::Button({ 180, 62 }, { 60, 12 }, WindowColour::secondary, StringIds::cheat_add), // loan Widgets::GroupBox({ 4, 86 }, { kWindowSize.width - 8, 33 }, WindowColour::secondary, StringIds::cheat_clear_loan), Widgets::Label({ 10, 100 }, { 70, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::company_current_loan), Widgets::TextBox({ 80, 100 }, { 95, 12 }, WindowColour::secondary, StringIds::cheat_loan_value), Widgets::Button({ 180, 100 }, { 60, 12 }, WindowColour::secondary, StringIds::cheat_clear), // date/time Widgets::GroupBox({ 4, 124 }, { kWindowSize.width - 8, 80 }, WindowColour::secondary, StringIds::cheat_date_change_apply), Widgets::Label({ 10, 138 }, { 70, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::cheat_year), Widgets::stepperWidgets({ 80, 138 }, { 95, 12 }, WindowColour::secondary, StringIds::cheat_year_value), Widgets::Label({ 10, 154 }, { 70, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::cheat_month), Widgets::stepperWidgets({ 80, 154 }, { 95, 12 }, WindowColour::secondary, StringIds::black_stringid), Widgets::Label({ 10, 170 }, { 70, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::cheat_day), Widgets::stepperWidgets({ 80, 170 }, { 95, 12 }, WindowColour::secondary, StringIds::cheat_day_value), Widgets::Button({ 10, 186 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_date_change_apply) ); const uint64_t holdableWidgets = (1 << Widx::cash_step_decrease) | (1 << Widx::cash_step_increase) | (1 << Widx::year_step_decrease) | (1 << Widx::year_step_increase) | (1 << Widx::month_step_decrease) | (1 << Widx::month_step_increase) | (1 << Widx::day_step_decrease) | (1 << Widx::day_step_increase); static currency32_t _cashIncreaseStep = 10'000; static Date _date; static void prepareDraw(Window& self) { self.activatedWidgets = (1 << Common::Widx::tab_finances); // Add cash step label and value { auto& widget = self.widgets[Widx::cash_step_value]; FormatArguments args{ widget.textArgs }; args.push(_cashIncreaseStep); } // Loan label and value { auto& widget = self.widgets[Widx::loan_value]; FormatArguments args{ widget.textArgs }; auto company = CompanyManager::getPlayerCompany(); args.push(company->currentLoan); } // Add year label and value { auto& widget = self.widgets[Widx::year_step_value]; FormatArguments args{ widget.textArgs }; args.push(_date.year); } // Add month label and value { auto& widget = self.widgets[Widx::month_step_value]; FormatArguments args{ widget.textArgs }; args.push(StringManager::monthToString(_date.month).second); } // Add day label and value { auto& widget = self.widgets[Widx::day_step_value]; FormatArguments args{ widget.textArgs }; args.push(_date.day + 1); // +1 since days in game are 0-based, but IRL they are 1-based } } static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets and tabs. self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::Widx::close_button: WindowManager::close(self.type); break; case Common::Widx::tab_finances: case Common::Widx::tab_companies: case Common::Widx::tab_vehicles: case Common::Widx::tab_towns: Common::switchTab(self, widgetIndex); break; case Widx::cash_step_apply: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::addCash; args.param1 = _cashIncreaseStep; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::playerInfoToolbar); break; } case Widx::loan_clear: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::clearLoan; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidateWidget(self.type, self.number, Widx::loan_value); break; } case Widx::date_change_apply: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::modifyDate; args.param1 = _date.year; args.param2 = enumValue(_date.month); args.param3 = _date.day + 1; // +1 days again GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::timeToolbar); break; } } } static int32_t clampDayToMonth(const Date& date) { return std::max<int32_t>(0, std::min<int32_t>(getMonthTotalDay(date.year, date.month) - 1, date.day)); } static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { currency32_t cashStepSize{}; int32_t timeStepSize{}; uint16_t clickRepeatTicks = Input::getClickRepeatTicks(); if (clickRepeatTicks < 100) { cashStepSize = 1'000; timeStepSize = 1; } else if (clickRepeatTicks < 200) { cashStepSize = 10'000; timeStepSize = 10; } else if (clickRepeatTicks < 300) { cashStepSize = 100'000; timeStepSize = 100; } else { cashStepSize = 1'000'000; timeStepSize = 1'000; } switch (widgetIndex) { case Widx::cash_step_decrease: _cashIncreaseStep = std::max<currency32_t>(_cashIncreaseStep - cashStepSize, 0); WindowManager::invalidateWidget(self.type, self.number, Widx::cash_step_value); break; case Widx::cash_step_increase: _cashIncreaseStep = std::max<currency32_t>(_cashIncreaseStep + cashStepSize, 0); WindowManager::invalidateWidget(self.type, self.number, Widx::cash_step_value); break; case Widx::year_step_decrease: _date.year = std::max<int32_t>(OpenLoco::Scenario::kMinYear, _date.year - timeStepSize); break; case Widx::year_step_increase: _date.year = Math::Bound::add(_date.year, timeStepSize); break; case Widx::month_step_decrease: _date.month = static_cast<MonthId>(std::max<int8_t>(0, (static_cast<int8_t>(_date.month) - timeStepSize))); break; case Widx::month_step_increase: _date.month = static_cast<MonthId>(std::min<int8_t>(11, (static_cast<int8_t>(_date.month) + timeStepSize))); break; case Widx::day_step_decrease: _date.day = std::max<int32_t>(0, _date.day - timeStepSize); break; case Widx::day_step_increase: _date.day = std::min<int32_t>(getMonthTotalDay(_date.year, _date.month) - 1, _date.day + timeStepSize); break; } _date.day = clampDayToMonth(_date); WindowManager::invalidate(WindowType::cheats); } static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(self.type, self.number, Common::Widx::tab_finances); } static void initDate() { _date = getCurrentDate(); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Companies { static constexpr Ui::Size32 kWindowSize = { 250, 188 }; namespace Widx { enum { target_company_group = Common::Widx::nextWidx, target_company_dropdown, target_company_dropdown_btn, select_cheat_group, switch_company_button, acquire_company_assets_button, toggle_bankruptcy_button, toggle_jail_status_button, complete_challenge_button, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize.width, kWindowSize.height, StringIds::company_cheats), Widgets::GroupBox({ 4, 48 }, { kWindowSize.width - 8, 33 }, WindowColour::secondary, StringIds::cheat_select_target_company), Widgets::dropdownWidgets({ 10, 62 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::black_stringid), Widgets::GroupBox({ 4, 86 }, { kWindowSize.width - 8, 96 }, WindowColour::secondary, StringIds::cheat_select_cheat_to_apply), Widgets::Button({ 10, 100 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_switch_to_company), Widgets::Button({ 10, 116 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_acquire_company_assets), Widgets::Button({ 10, 132 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_toggle_bankruptcy), Widgets::Button({ 10, 148 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_toggle_jail_status), Widgets::Button({ 10, 164 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::completeChallenge) ); static CompanyId _targetCompanyId{}; static void prepareDraw(Window& self) { self.activatedWidgets = (1 << Common::Widx::tab_companies); if (_targetCompanyId == CompanyManager::getControllingId()) { self.disabledWidgets |= (1 << Widx::switch_company_button) | (1 << Widx::acquire_company_assets_button); } else { self.disabledWidgets &= ~((1 << Widx::switch_company_button) | (1 << Widx::acquire_company_assets_button)); } if (!CompanyManager::isPlayerCompany(_targetCompanyId)) { self.disabledWidgets |= (1 << Widx::complete_challenge_button); } else { self.disabledWidgets &= ~(1 << Widx::complete_challenge_button); } // Current company name auto& widget = self.widgets[Widx::target_company_dropdown]; auto args = FormatArguments(widget.textArgs); auto company = CompanyManager::get(_targetCompanyId); args.push(company->name); } static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets and tabs. self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::Widx::close_button: WindowManager::close(self.type); break; case Common::Widx::tab_finances: case Common::Widx::tab_companies: case Common::Widx::tab_vehicles: case Common::Widx::tab_towns: Common::switchTab(self, widgetIndex); break; case Widx::acquire_company_assets_button: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::acquireAssets; args.param1 = enumValue(_targetCompanyId); GameCommands::doCommand(args, GameCommands::Flags::apply); Gfx::invalidateScreen(); return; } case Widx::switch_company_button: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::switchCompany; args.param1 = enumValue(_targetCompanyId); GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::playerInfoToolbar); return; } case Widx::toggle_bankruptcy_button: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::toggleBankruptcy; args.param1 = enumValue(_targetCompanyId); GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::playerInfoToolbar); return; } case Widx::toggle_jail_status_button: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::toggleJail; args.param1 = enumValue(_targetCompanyId); GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::playerInfoToolbar); return; } case Widx::complete_challenge_button: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::completeChallenge; args.param1 = enumValue(_targetCompanyId); GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::playerInfoToolbar); return; } } } static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == Widx::target_company_dropdown_btn) { Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex - 1]); } } static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (itemIndex == -1) { return; } if (widgetIndex == Widx::target_company_dropdown_btn) { _targetCompanyId = Dropdown::getCompanyIdFromSelection(itemIndex); self.invalidate(); } } static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(self.type, self.number, Common::Widx::tab_finances); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Vehicles { static constexpr Ui::Size32 kWindowSize = { 250, 152 }; namespace Widx { enum { reliability_group = Common::Widx::nextWidx, reliablity_all_to_zero, reliablity_all_to_hundred, vehicle_locked_group, checkbox_display_locked_vehicles, checkbox_build_locked_vehicles, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize.width, kWindowSize.height, StringIds::vehicle_cheats), Widgets::GroupBox({ 4, 48 }, { kWindowSize.width - 8, 49 }, WindowColour::secondary, StringIds::cheat_set_vehicle_reliability), Widgets::Button({ 10, 62 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_reliability_zero), Widgets::Button({ 10, 78 }, { kWindowSize.width - 20, 12 }, WindowColour::secondary, StringIds::cheat_reliability_hundred), Widgets::GroupBox({ 4, 102 }, { kWindowSize.width - 8, 45 }, WindowColour::secondary, StringIds::cheat_build_vehicle_window), Widgets::Checkbox({ 10, 116 }, { 200, 12 }, WindowColour::secondary, StringIds::display_locked_vehicles, StringIds::tooltip_display_locked_vehicles), Widgets::Checkbox({ 25, 130 }, { 200, 12 }, WindowColour::secondary, StringIds::allow_building_locked_vehicles, StringIds::tooltip_build_locked_vehicles) ); static void prepareDraw(Window& self) { self.activatedWidgets = (1 << Common::Widx::tab_vehicles); if (Config::get().displayLockedVehicles) { self.activatedWidgets |= (1 << Widx::checkbox_display_locked_vehicles); self.disabledWidgets &= ~(1 << Widx::checkbox_build_locked_vehicles); } else { self.activatedWidgets &= ~(1 << Widx::checkbox_display_locked_vehicles); self.disabledWidgets |= (1 << Widx::checkbox_build_locked_vehicles); } if (Config::get().buildLockedVehicles) { self.activatedWidgets |= (1 << Widx::checkbox_build_locked_vehicles); } else { self.activatedWidgets &= ~(1 << Widx::checkbox_build_locked_vehicles); } } static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets and tabs. self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::Widx::close_button: WindowManager::close(self.type); break; case Common::Widx::tab_finances: case Common::Widx::tab_companies: case Common::Widx::tab_vehicles: case Common::Widx::tab_towns: Common::switchTab(self, widgetIndex); break; case Widx::reliablity_all_to_zero: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::vehicleReliability; args.param1 = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::vehicle); WindowManager::invalidate(WindowType::vehicleList); return; } case Widx::reliablity_all_to_hundred: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::vehicleReliability; args.param1 = 100; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::vehicle); WindowManager::invalidate(WindowType::vehicleList); return; } case Widx::checkbox_display_locked_vehicles: { Config::get().displayLockedVehicles = !Config::get().displayLockedVehicles; // if we don't want to display locked vehicles, there is no reason to allow building them if (Config::get().displayLockedVehicles) { self.disabledWidgets &= ~(1 << Widx::checkbox_build_locked_vehicles); } else { Config::get().buildLockedVehicles = false; self.disabledWidgets |= (1 << Widx::checkbox_build_locked_vehicles); } WindowManager::invalidateWidget(self.type, self.number, Widx::checkbox_build_locked_vehicles); WindowManager::invalidateWidget(self.type, self.number, Widx::checkbox_display_locked_vehicles); WindowManager::invalidate(WindowType::buildVehicle); break; } case Widx::checkbox_build_locked_vehicles: { if (Config::get().displayLockedVehicles) { Config::get().buildLockedVehicles = !Config::get().buildLockedVehicles; WindowManager::invalidateWidget(self.type, self.number, Widx::checkbox_build_locked_vehicles); WindowManager::invalidate(WindowType::buildVehicle); } break; } } } static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(self.type, self.number, Common::Widx::tab_vehicles); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Towns { static constexpr Ui::Size32 kWindowSize = { 250, 103 }; namespace Widx { enum { ratings_group = Common::Widx::nextWidx, ratings_all_min_10pct, ratings_all_plus_10pct, ratings_all_to_min, ratings_all_to_max, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize.width, kWindowSize.height, StringIds::town_cheats), Widgets::GroupBox({ 4, 48 }, { kWindowSize.width - 8, 49 }, WindowColour::secondary, StringIds::cheat_set_ratings), Widgets::Button({ 10, 62 }, { (kWindowSize.width - 26) / 2, 12 }, WindowColour::secondary, StringIds::cheat_ratings_min_10pct), Widgets::Button({ 3 + (kWindowSize.width / 2), 62 }, { (kWindowSize.width - 26) / 2, 12 }, WindowColour::secondary, StringIds::cheat_ratings_plus_10pct), Widgets::Button({ 10, 78 }, { (kWindowSize.width - 26) / 2, 12 }, WindowColour::secondary, StringIds::cheat_ratings_to_min), Widgets::Button({ 3 + (kWindowSize.width / 2), 78 }, { (kWindowSize.width - 26) / 2, 12 }, WindowColour::secondary, StringIds::cheat_ratings_to_max) ); static void prepareDraw(Window& self) { self.activatedWidgets = (1 << Common::Widx::tab_towns); } static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets and tabs. self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::Widx::close_button: WindowManager::close(self.type); break; case Common::Widx::tab_finances: case Common::Widx::tab_companies: case Common::Widx::tab_vehicles: case Common::Widx::tab_towns: Common::switchTab(self, widgetIndex); break; case Widx::ratings_all_min_10pct: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::companyRatings; args.param1 = false; args.param2 = -10; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::town); return; } case Widx::ratings_all_plus_10pct: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::companyRatings; args.param1 = false; args.param2 = 10; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::town); return; } case Widx::ratings_all_to_min: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::companyRatings; args.param1 = true; args.param2 = -1; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::town); return; } case Widx::ratings_all_to_max: { GameCommands::GenericCheatArgs args{}; args.subcommand = CheatCommand::companyRatings; args.param1 = true; args.param2 = 1; GameCommands::doCommand(args, GameCommands::Flags::apply); WindowManager::invalidate(WindowType::town); return; } } } static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(self.type, self.number, Common::Widx::tab_towns); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } Window* open() { auto window = WindowManager::bringToFront(WindowType::cheats); if (window != nullptr) { return window; } window = WindowManager::createWindow( WindowType::cheats, Finances::kWindowSize, WindowFlags::none, Finances::getEvents()); Finances::initDate(); window->setWidgets(Finances::_widgets); window->currentTab = Common::Widx::tab_finances - Common::Widx::tab_finances; window->holdableWidgets = Finances::holdableWidgets; window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); return window; } namespace Common { struct TabInformation { std::span<const Widget> widgets; WidgetIndex_t widgetIndex; const WindowEventList& events; const uint64_t* holdableWidgets; Ui::Size32 kWindowSize; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { Finances::_widgets, Widx::tab_finances, Finances::getEvents(), &Finances::holdableWidgets, Finances::kWindowSize }, { Companies::_widgets, Widx::tab_companies, Companies::getEvents(), nullptr, Companies::kWindowSize }, { Vehicles::_widgets, Widx::tab_vehicles, Vehicles::getEvents(), nullptr, Vehicles::kWindowSize }, { Towns::_widgets, Widx::tab_towns, Towns::getEvents(), nullptr, Towns::kWindowSize }, }; // clang-format on static void switchTab(Window& self, WidgetIndex_t widgetIndex) { self.currentTab = widgetIndex - Widx::tab_finances; self.frameNo = 0; auto tabInfo = tabInformationByTabOffset[self.currentTab]; self.holdableWidgets = tabInfo.holdableWidgets != nullptr ? *tabInfo.holdableWidgets : 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.disabledWidgets = 0; self.invalidate(); self.setSize(tabInfo.kWindowSize); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/CompanyFaceSelection.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "GameCommands/Company/ChangeCompanyFace.h" #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <optional> #include <ranges> namespace OpenLoco::Ui::Windows::CompanyFaceSelection { // Count was previously 0x112C1C1 static std::vector<ObjectManager::ObjIndexPair> _competitorList; static WindowType _callingWindowType; static constexpr Ui::Size32 kWindowSize = { 400, 272 }; static constexpr int16_t kRowHeight = 10; enum widx { frame, caption, close_button, panel, scrollview, face_frame }; // 0x509680 static constexpr auto widgets = makeWidgets( Widgets::Frame({ 0, 0 }, kWindowSize, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 398, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, StringIds::company_face_selection_title), Widgets::ImageButton({ 385, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 400, 257 }, WindowColour::secondary), Widgets::ScrollView({ 4, 19 }, { 188, 248 }, WindowColour::secondary, Scrollbars::vertical, StringIds::tooltip_company_face_selection), Widgets::Tab({ 265, 23 }, { 66, 66 }, WindowColour::secondary) ); static const WindowEventList& getEvents(); static std::vector<uint32_t> _inUseCompetitors; static void populateCompetitorList() { _competitorList = ObjectManager::getAvailableObjects(ObjectType::competitor); } // 0x00434F52 void open(const CompanyId id, const WindowType callingWindowType) { auto* self = WindowManager::bringToFront(WindowType::companyFaceSelection, 0); populateCompetitorList(); if (self != nullptr) { self->owner = id; self->invalidate(); } else { self = WindowManager::createWindow(WindowType::companyFaceSelection, kWindowSize, WindowFlags::none, getEvents()); self->setWidgets(widgets); self->initScrollWidgets(); self->owner = id; const auto* skin = ObjectManager::get<InterfaceSkinObject>(); self->setColour(WindowColour::secondary, skin->windowPlayerColor); self->rowCount = static_cast<uint16_t>(_competitorList.size()); self->rowHover = -1; self->object = nullptr; } // How will we be using the selected face? _callingWindowType = callingWindowType; // Make window blocking while open WindowManager::setCurrentModalType(WindowType::companyFaceSelection); // Enumerate competitors that are in use if we are applying the selection in-game if (_callingWindowType == WindowType::company) { _inUseCompetitors = CompanyManager::findAllOtherInUseCompetitors(id); } else { _inUseCompetitors.clear(); } } // 0x004352A4 static void onClose([[maybe_unused]] Window& self) { ObjectManager::freeTemporaryObject(); WindowManager::setCurrentModalType(WindowType::undefined); if (_callingWindowType == WindowType::options) { auto& config = Config::get(); if (config.preferredOwnerFace == kEmptyObjectHeader) { config.usePreferredOwnerFace = false; Config::write(); } WindowManager::invalidate(WindowType::options); } _competitorList.clear(); } // 0x435299 static void onMouseUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close_button: WindowManager::close(&self); break; } } // 0x4352BB static void getScrollSize([[maybe_unused]] Window& self, [[maybe_unused]] const uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = _competitorList.size() * kRowHeight; } static bool isInUseCompetitor(const uint32_t objIndex) { return std::find(_inUseCompetitors.begin(), _inUseCompetitors.end(), objIndex) != _inUseCompetitors.end(); } static ObjectManager::ObjIndexPair getObjectFromSelection(const int16_t y) { const int16_t rowIndex = y / kRowHeight; if (rowIndex < 0 || static_cast<uint16_t>(rowIndex) >= _competitorList.size()) { return { ObjectManager::kNullObjectIndex, ObjectManager::ObjectIndexEntry{} }; } if (isInUseCompetitor(_competitorList[rowIndex].index)) { return { ObjectManager::kNullObjectIndex, ObjectManager::ObjectIndexEntry{} }; } return _competitorList[rowIndex]; } // 0x00435314 static void scrollMouseDown(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scroll_index) { const auto objRow = getObjectFromSelection(y); if (objRow.index == ObjectManager::kNullObjectIndex) { return; } self.invalidate(); auto mousePos = Input::getMouseLocation(); Audio::playSound(Audio::SoundId::clickDown, mousePos.x); if (_callingWindowType == WindowType::company) { GameCommands::setErrorTitle(StringIds::cant_select_face); GameCommands::ChangeCompanyFaceArgs args{}; args.companyId = self.owner; args.objHeader = objRow.object._header; const auto result = GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE; if (result) { WindowManager::close(&self); } } else if (_callingWindowType == WindowType::options) { auto& config = Config::get(); config.preferredOwnerFace = objRow.object._header; Config::write(); WindowManager::close(&self); } } // 0x004352C7 static void scrollMouseOver(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scroll_index) { auto objRow = getObjectFromSelection(y); if (self.rowHover == objRow.index) { return; } self.rowHover = objRow.index; ObjectManager::freeTemporaryObject(); if (objRow.index != ObjectManager::kNullObjectIndex) { self.object = reinterpret_cast<std::byte*>(&objRow.object._header); ObjectManager::loadTemporaryObject(objRow.object._header); } else { self.object = nullptr; } self.invalidate(); } // 0x4352B1 static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, const WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_list); return args; } // 0x434FE8 static void prepareDraw(Window& self) { if (_callingWindowType == WindowType::company) { self.widgets[widx::caption].text = StringIds::company_face_selection_title; const auto company = CompanyManager::get(self.owner); auto args = FormatArguments(self.widgets[widx::caption].textArgs); args.push(company->name); } else { self.widgets[widx::caption].text = StringIds::selectPreferredCompanyOwnerFace; } } // 0x435003 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); if (self.rowHover == -1) { return; } auto tr = Gfx::TextRenderer(drawingCtx); { const auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 0); const auto l = self.x + 1 + self.widgets[widx::face_frame].left; const auto t = self.y + 1 + self.widgets[widx::face_frame].top; const auto r = self.x - 1 + self.widgets[widx::face_frame].right; const auto b = self.y - 1 + self.widgets[widx::face_frame].bottom; drawingCtx.fillRect(l, t, r, b, colour, Gfx::RectFlags::none); const CompetitorObject* competitor = reinterpret_cast<CompetitorObject*>(ObjectManager::getTemporaryObject()); uint32_t img = Gfx::recolour(competitor->images[0] + 1, Colour::black); drawingCtx.drawImage(l, t, img); } { const auto x = self.x + self.widgets[widx::face_frame].midX(); const auto y = self.y + self.widgets[widx::face_frame].bottom + 3; const auto width = self.width - self.widgets[widx::scrollview].right - 6; auto str = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); *str++ = ControlCodes::windowColour2; strcpy(str, ObjectManager::getObjectInIndex(self.rowHover)._name.c_str()); tr.drawStringCentredClipped(Point(x, y), width, Colour::black, StringIds::buffer_2039); } // There was code for displaying competitor stats if window opened with none // playing company. But that ability is disabled from the company window. } // 0x00435152 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); auto index = 0; for (const auto& object : _competitorList) { const int16_t y = index * kRowHeight; uint8_t inlineColour = ControlCodes::Colour::black; if (y + kRowHeight < rt.y) { index++; continue; } else if (y > rt.y + rt.height) { break; } if (object.index == self.rowHover) { inlineColour = ControlCodes::windowColour2; drawingCtx.fillRect(0, y, self.width, y + 9, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); } // copy name as we need to modify it std::string name = object.object._name; name.insert(0, 1, inlineColour); tr.setCurrentFont(Gfx::Font::medium_bold); AdvancedColour stringColour = Colour::black; if (isInUseCompetitor(object.index)) { tr.setCurrentFont(Gfx::Font::m1); stringColour = self.getColour(WindowColour::secondary).opaque().inset(); } tr.drawString(Point(0, y - 1), stringColour, const_cast<char*>(name.c_str())); index++; } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/CompanyList.cpp ```cpp #include "Date.h" #include "Economy/Economy.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/CargoObject.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Chart.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include "World/Company.h" #include "World/CompanyManager.h" #include "World/CompanyRecords.h" #include <OpenLoco/Core/Numerics.hpp> using namespace OpenLoco::Literals; namespace OpenLoco::Ui::Windows::CompanyList { static uint16_t _hoverItemTicks; // 0x009C68C7 static GraphSettings _graphSettings; // 0x0113DC7A static constexpr auto kLegendMargin = 6; static constexpr auto kLegendWidth = 100; static constexpr auto kWindowPadding = 4; namespace Common { static constexpr Ui::Size32 kMaxWindowSize = { 800, 940 }; // NB: frame background is only 800px :( static constexpr Ui::Size32 kMinWindowSize = { 300, 272 }; enum widx { frame, caption, close_button, panel, tab_company_list, tab_performance, tab_cargo_units, tab_cargo_distance, tab_values, tab_payment_rates, tab_speed_records, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 231 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_compare_companies), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_company_performance), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_cargo_graphs), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_cargo_distance_graphs), Widgets::Tab({ 127, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_company_values), Widgets::Tab({ 158, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_cargo_payment_rates), Widgets::Tab({ 189, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_speed_records)); } static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id); static void onUpdate(Window& self); static void prepareDraw(Window& self); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void refreshCompanyList(Window& self); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); static void drawGraphAndLegend(Window& self, Gfx::DrawingContext& drawingCtx); } namespace CompanyList { static constexpr Ui::Size32 kWindowSize = { 640, 272 }; static constexpr uint8_t kRowHeight = 25; enum widx { sort_name = 11, sort_status, sort_performance, sort_value, scrollview, status_bar, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(640, 272, StringIds::title_company_list), Widgets::TableHeader({ 4, 43 }, { 175, 12 }, WindowColour::secondary, ImageIds::null, StringIds::tooltip_sort_company_name), Widgets::TableHeader({ 179, 43 }, { 210, 12 }, WindowColour::secondary, ImageIds::null, StringIds::tooltip_sort_company_status), Widgets::TableHeader({ 389, 43 }, { 145, 12 }, WindowColour::secondary, ImageIds::null, StringIds::tooltip_sort_company_performance), Widgets::TableHeader({ 534, 43 }, { 100, 12 }, WindowColour::secondary, ImageIds::null, StringIds::tooltip_sort_company_value), Widgets::ScrollView({ 3, 56 }, { 634, 201 }, WindowColour::secondary, Scrollbars::vertical), Widgets::Label({ 3, kWindowSize.height - 17 }, { kWindowSize.width, 10 }, WindowColour::secondary, ContentAlign::left, StringIds::black_stringid) ); enum SortMode : uint16_t { Name, Status, Performance, Value, }; // 0x004360A2 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_company_list: case Common::widx::tab_performance: case Common::widx::tab_cargo_units: case Common::widx::tab_cargo_distance: case Common::widx::tab_values: case Common::widx::tab_payment_rates: case Common::widx::tab_speed_records: Common::switchTab(self, widgetIndex); break; case sort_name: case sort_status: case sort_performance: case sort_value: { auto sortMode = widgetIndex - widx::sort_name; if (self.sortMode == sortMode) { return; } self.sortMode = sortMode; self.invalidate(); self.var_83C = 0; self.rowHover = -1; Common::refreshCompanyList(self); break; } } } // 0x004363CB static void onResize(Window& self) { self.setSize(Common::kMinWindowSize, Common::kMaxWindowSize); } // 0x00437BA0 static bool orderByName(const OpenLoco::Company& lhs, const OpenLoco::Company& rhs) { char lhsString[256] = { 0 }; StringManager::formatString(lhsString, lhs.name); char rhsString[256] = { 0 }; StringManager::formatString(rhsString, rhs.name); return strcmp(lhsString, rhsString) < 0; } // 0x00437BE1 static bool orderByStatus(const OpenLoco::Company& lhs, const OpenLoco::Company& rhs) { char lhsString[256] = { 0 }; { FormatArguments args{}; auto statusString = CompanyManager::getOwnerStatus(lhs.id(), args); StringManager::formatString(lhsString, statusString, args); } char rhsString[256] = { 0 }; { FormatArguments args{}; auto statusString = CompanyManager::getOwnerStatus(rhs.id(), args); StringManager::formatString(rhsString, statusString, args); } return strcmp(lhsString, rhsString) < 0; } // 0x00437C53 static bool orderByPerformance(const OpenLoco::Company& lhs, const OpenLoco::Company& rhs) { auto lhsPerformance = lhs.performanceIndex; auto rhsPerformance = rhs.performanceIndex; return rhsPerformance < lhsPerformance; } // 0x00437C67 static bool orderByValue(const OpenLoco::Company& lhs, const OpenLoco::Company& rhs) { return rhs.companyValueHistory[0] < lhs.companyValueHistory[0]; } // 0x00437BA0, 0x00437BE1, 0x00437C53, 0x00437C67 static bool getOrder(const SortMode mode, OpenLoco::Company& lhs, OpenLoco::Company& rhs) { switch (mode) { case SortMode::Name: return orderByName(lhs, rhs); case SortMode::Status: return orderByStatus(lhs, rhs); case SortMode::Performance: return orderByPerformance(lhs, rhs); case SortMode::Value: return orderByValue(lhs, rhs); } return false; } // 0x00437AE2 static void updateCompanyList(Window& self) { CompanyId chosenCompany = CompanyId::null; for (auto& company : CompanyManager::companies()) { if ((company.challengeFlags & CompanyFlags::sorted) != CompanyFlags::none) { continue; } if (chosenCompany == CompanyId::null) { chosenCompany = company.id(); continue; } if (getOrder(SortMode(self.sortMode), company, *CompanyManager::get(chosenCompany))) { chosenCompany = company.id(); } } if (chosenCompany != CompanyId::null) { bool shouldInvalidate = false; CompanyManager::get(chosenCompany)->challengeFlags |= CompanyFlags::sorted; if (chosenCompany != CompanyId(self.rowInfo[self.rowCount])) { self.rowInfo[self.rowCount] = enumValue(chosenCompany); shouldInvalidate = true; } self.rowCount++; if (self.rowCount > self.var_83C) { self.var_83C = self.rowCount; shouldInvalidate = true; } if (shouldInvalidate) { self.invalidate(); } } else { if (self.var_83C != self.rowCount) { self.var_83C = self.rowCount; self.invalidate(); } Common::refreshCompanyList(self); } } // 0x004362C0 static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::companyList, self.number, self.currentTab + Common::widx::tab_company_list); _hoverItemTicks++; // Add three companies every tick. updateCompanyList(self); updateCompanyList(self); updateCompanyList(self); } // 0x004362F7 static void event_08(Window& self) { self.flags |= WindowFlags::notScrollView; } // 0x004362FF static void event_09(Window& self) { if (!self.hasFlags(WindowFlags::notScrollView)) { return; } if (self.rowHover == -1) { return; } self.rowHover = -1; self.invalidate(); } // 0x00436321 static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = self.var_83C * kRowHeight; } // 0x004363A0 static void onScrollMouseDown(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentRow = y / kRowHeight; if (currentRow > self.var_83C) { return; } CompanyId currentCompany = CompanyId(self.rowInfo[currentRow]); if (currentCompany == CompanyId::null) { return; } CompanyWindow::open(currentCompany); } // 0x00436361 static void onScrollMouseOver(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { self.flags &= ~(WindowFlags::notScrollView); uint16_t currentRow = y / kRowHeight; int16_t currentCompany = -1; if (currentRow < self.var_83C) { currentCompany = self.rowInfo[currentRow]; } if (self.rowHover == currentCompany) { return; } self.rowHover = currentCompany; self.invalidate(); } // 0x004362B6 static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_company_list); return args; } // 0x0043632C static Ui::CursorId cursor(Window& self, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, Ui::CursorId fallback) { if (widgetIdx != widx::scrollview) { return fallback; } uint16_t currentIndex = yPos / kRowHeight; if (currentIndex < self.var_83C && self.rowInfo[currentIndex] != -1) { return CursorId::handPointer; } return fallback; } // 0x00435D07 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; // Reposition header buttons self.widgets[widx::sort_name].right = std::min(178, self.width - 8); self.widgets[widx::sort_status].left = std::min(179, self.width - 8); self.widgets[widx::sort_status].right = std::min(388, self.width - 8); self.widgets[widx::sort_performance].left = std::min(389, self.width - 8); self.widgets[widx::sort_performance].right = std::min(533, self.width - 8); self.widgets[widx::sort_value].left = std::min(534, self.width - 8); self.widgets[widx::sort_value].right = std::min(633, self.width - 8); // Set header button captions self.widgets[widx::sort_name].text = self.sortMode == SortMode::Name ? StringIds::table_header_company_name_desc : StringIds::table_header_company_name; self.widgets[widx::sort_status].text = self.sortMode == SortMode::Status ? StringIds::table_header_company_status_desc : StringIds::table_header_company_status; self.widgets[widx::sort_performance].text = self.sortMode == SortMode::Performance ? StringIds::table_header_company_performance_desc : StringIds::table_header_company_performance; self.widgets[widx::sort_value].text = self.sortMode == SortMode::Value ? StringIds::table_header_company_value_desc : StringIds::table_header_company_value; // Reposition status bar auto& widget = self.widgets[widx::status_bar]; widget.top = self.height - 13; widget.bottom = self.height - 3; // Set status bar text FormatArguments args{ widget.textArgs }; args.push(self.var_83C == 1 ? StringIds::company_singular : StringIds::companies_plural); args.push(self.var_83C); } // 0x00435E56 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } // 0x00435EA7 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 3); drawingCtx.clearSingle(colour); auto yBottom = 0; for (auto i = 0; i < self.var_83C; i++, yBottom += 25) { auto yTop = yBottom + 25; if (yTop <= rt.y) { continue; } yTop = rt.y + rt.height; if (yBottom >= yTop) { break; } auto rowItem = self.rowInfo[i]; if (rowItem == -1) { continue; } auto stringId = StringIds::black_stringid; if (rowItem == self.rowHover) { drawingCtx.drawRect(0, yBottom, self.width, 24, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); stringId = StringIds::wcolour2_stringid; } auto company = CompanyManager::get(CompanyId(rowItem)); auto competitorObj = ObjectManager::get<CompetitorObject>(company->competitorId); auto imageId = Gfx::recolour(competitorObj->images[enumValue(company->ownerEmotion)], company->mainColours.primary); { FormatArguments args{}; args.push(StringIds::table_item_company); args.push(imageId); args.push(company->name); auto point = Point(0, yBottom - 1); tr.drawStringLeftClipped(point, 173, Colour::black, stringId, args); } { FormatArguments args{}; args.skip(sizeof(StringId)); StringId ownerStatus = CompanyManager::getOwnerStatus(company->id(), args); args.rewind(); args.push(ownerStatus); auto point = Point(175, yBottom + 7); tr.drawStringLeftClipped(point, 208, Colour::black, stringId, args); } auto performanceStringId = StringIds::performance_index; if ((company->challengeFlags & CompanyFlags::increasedPerformance) != CompanyFlags::none && (company->challengeFlags & CompanyFlags::decreasedPerformance) != CompanyFlags::none) { performanceStringId = StringIds::performance_index_decrease; if ((company->challengeFlags & CompanyFlags::increasedPerformance) != CompanyFlags::none) { performanceStringId = StringIds::performance_index_increase; } } { FormatArguments args{}; args.push(performanceStringId); formatPerformanceIndex(company->performanceIndex, args); auto point = Point(385, yBottom - 1); tr.drawStringLeftClipped(point, 143, Colour::black, stringId, args); } { FormatArguments args{}; args.push(StringIds::company_value_currency); args.push(company->companyValueHistory[0]); auto point = Point(530, yBottom - 1); tr.drawStringLeftClipped(point, 98, Colour::black, stringId, args); } } } // 0x00436198 static void tabReset(Window& self) { self.minWidth = Common::kMinWindowSize.width; self.minHeight = Common::kMinWindowSize.height; self.maxWidth = Common::kMaxWindowSize.width; self.maxHeight = Common::kMaxWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; self.var_83C = 0; self.rowHover = -1; Common::refreshCompanyList(self); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x00435BC8 Window* open() { auto window = WindowManager::bringToFront(WindowType::companyList); if (window != nullptr) { if (ToolManager::isToolActive(ToolManager::getToolWindowType(), ToolManager::getToolWindowNumber())) { ToolManager::toolCancel(); window = WindowManager::bringToFront(WindowType::companyList); } } if (window == nullptr) { static constexpr Ui::Size32 kWindowSize = { 640, 272 }; window = WindowManager::createWindow(WindowType::companyList, kWindowSize, WindowFlags::none, CompanyList::getEvents()); window->frameNo = 0; window->savedView.clear(); window->flags |= WindowFlags::resizable; window->sortMode = 2; window->var_83C = 0; window->rowHover = -1; Common::refreshCompanyList(*window); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); window->var_854 = 0; } window->currentTab = 0; window->minWidth = Common::kMinWindowSize.width; window->minHeight = Common::kMinWindowSize.height; window->maxWidth = Common::kMaxWindowSize.width; window->maxHeight = Common::kMaxWindowSize.height; window->invalidate(); window->setWidgets(CompanyList::widgets); window->holdableWidgets = 0; window->eventHandlers = &CompanyList::getEvents(); window->activatedWidgets = 0; window->initScrollWidgets(); return window; } void removeCompany(CompanyId id) { auto* w = WindowManager::find(WindowType::companyList); if (w != nullptr) { for (auto i = 0; i < w->var_83C; i++) { if (static_cast<CompanyId>(w->rowInfo[i]) == id) { w->rowInfo[i] = -1; } } } WindowManager::invalidate(WindowType::companyList); } // 0x00435C69 void openPerformanceIndexes() { auto window = open(); window->callOnMouseUp(Common::widx::tab_performance, window->widgets[Common::widx::tab_performance].id); } namespace CompanyPerformance { static constexpr Ui::Size32 kWindowSize = { 635, 322 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(635, 322, StringIds::title_company_performance) ); // 0x004366D7 static void onResize(Window& self) { self.setSize(kWindowSize, Common::kMaxWindowSize); } // 0x00436490 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); _graphSettings.left = self.x + 4; _graphSettings.top = self.y + self.widgets[Common::widx::panel].top + 4; _graphSettings.width = self.width - kLegendWidth - kLegendMargin - 2 * kWindowPadding; _graphSettings.height = self.height - self.widgets[Common::widx::panel].top - 2 * kWindowPadding; _graphSettings.yOffset = 17; _graphSettings.xOffset = 40; _graphSettings.yAxisLabelIncrement = 20; _graphSettings.linesToExclude = 0; uint16_t maxHistorySize = 1; for (auto& company : CompanyManager::companies()) { if (maxHistorySize < company.historySize) { maxHistorySize = company.historySize; } } uint8_t count = 0; for (auto& company : CompanyManager::companies()) { auto companyId = company.id(); auto companyColour = CompanyManager::getCompanyColour(companyId); _graphSettings.yData[count] = reinterpret_cast<std::byte*>(&company.performanceIndexHistory[0]); _graphSettings.dataStart[count] = maxHistorySize - company.historySize; _graphSettings.lineColour[count] = Colours::getShade(companyColour, 6); _graphSettings.itemId[count] = enumValue(companyId); count++; } _graphSettings.lineCount = count; _graphSettings.dataEnd = maxHistorySize; _graphSettings.dataTypeSize = 2; _graphSettings.xLabel = StringIds::rawdate_short; _graphSettings.yLabel = StringIds::percentage_one_decimal_place; _graphSettings.xAxisTickIncrement = (_graphSettings.width - _graphSettings.xOffset) / 120; _graphSettings.xAxisLabelIncrement = 12; _graphSettings.dword_113DD86 = 0; _graphSettings.yAxisStepSize = 100; _graphSettings.flags = GraphFlags::dataFrontToBack; Common::drawGraphAndLegend(self, drawingCtx); } // 0x004361D8 static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .prepareDraw = Common::prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CargoUnits { static constexpr Ui::Size32 kWindowSize = { 640, 272 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(635, 322, StringIds::title_company_cargo_units) ); // 0x004369FB static void onResize(Window& self) { self.setSize(kWindowSize, Common::kMaxWindowSize); } // 0x004367B4 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); _graphSettings.left = self.x + 4; _graphSettings.top = self.y + self.widgets[Common::widx::panel].top + 4; _graphSettings.width = self.width - kLegendWidth - kLegendMargin - 2 * kWindowPadding; _graphSettings.height = self.height - self.widgets[Common::widx::panel].top - 2 * kWindowPadding; _graphSettings.yOffset = 17; _graphSettings.xOffset = 45; _graphSettings.yAxisLabelIncrement = 25; _graphSettings.linesToExclude = 0; uint16_t maxHistorySize = 1; for (auto& company : CompanyManager::companies()) { if (maxHistorySize < company.historySize) { maxHistorySize = company.historySize; } } uint8_t count = 0; for (auto& company : CompanyManager::companies()) { auto companyId = company.id(); auto companyColour = CompanyManager::getCompanyColour(companyId); _graphSettings.yData[count] = reinterpret_cast<std::byte*>(&company.cargoUnitsDeliveredHistory[0]); _graphSettings.dataStart[count] = maxHistorySize - company.historySize; _graphSettings.lineColour[count] = Colours::getShade(companyColour, 6); _graphSettings.itemId[count] = enumValue(companyId); count++; } _graphSettings.lineCount = count; _graphSettings.dataEnd = maxHistorySize; _graphSettings.dataTypeSize = 4; _graphSettings.xLabel = StringIds::rawdate_short; _graphSettings.yLabel = StringIds::cargo_units_delivered; _graphSettings.xAxisTickIncrement = (_graphSettings.width - _graphSettings.xOffset) / 120; _graphSettings.xAxisLabelIncrement = 12; _graphSettings.dword_113DD86 = 0; _graphSettings.yAxisStepSize = 1000; _graphSettings.flags = GraphFlags::dataFrontToBack; Common::drawGraphAndLegend(self, drawingCtx); } // 0x00436201 static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .prepareDraw = Common::prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CargoDistance { static constexpr Ui::Size32 kWindowSize = { 660, 272 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(635, 322, StringIds::title_cargo_distance_graphs) ); // 0x00436D1F static void onResize(Window& self) { self.setSize(kWindowSize, Common::kMaxWindowSize); } // 0x00436AD8 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); _graphSettings.left = self.x + 4; _graphSettings.top = self.y + self.widgets[Common::widx::panel].top + 4; _graphSettings.width = self.width - kLegendWidth - kLegendMargin - 2 * kWindowPadding; _graphSettings.height = self.height - self.widgets[Common::widx::panel].top - 2 * kWindowPadding; _graphSettings.yOffset = 17; _graphSettings.xOffset = 65; _graphSettings.yAxisLabelIncrement = 25; _graphSettings.linesToExclude = 0; uint16_t maxHistorySize = 1; for (auto& company : CompanyManager::companies()) { if (maxHistorySize < company.historySize) { maxHistorySize = company.historySize; } } uint8_t count = 0; for (auto& company : CompanyManager::companies()) { auto companyId = company.id(); auto companyColour = CompanyManager::getCompanyColour(companyId); _graphSettings.yData[count] = reinterpret_cast<std::byte*>(&company.cargoUnitsDistanceHistory[0]); _graphSettings.dataStart[count] = maxHistorySize - company.historySize; _graphSettings.lineColour[count] = Colours::getShade(companyColour, 6); _graphSettings.itemId[count] = enumValue(companyId); count++; } _graphSettings.lineCount = count; _graphSettings.dataEnd = maxHistorySize; _graphSettings.dataTypeSize = 4; _graphSettings.xLabel = StringIds::rawdate_short; _graphSettings.yLabel = StringIds::cargo_units_delivered; _graphSettings.xAxisTickIncrement = (_graphSettings.width - _graphSettings.xOffset) / 120; _graphSettings.xAxisLabelIncrement = 12; _graphSettings.dword_113DD86 = 0; _graphSettings.yAxisStepSize = 1000; _graphSettings.flags = GraphFlags::dataFrontToBack; Common::drawGraphAndLegend(self, drawingCtx); } // 0x00436227 static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .prepareDraw = Common::prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CompanyValues { static constexpr Ui::Size32 kWindowSize = { 685, 322 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(685, 322, StringIds::title_company_values) ); // 0x00437043 static void onResize(Window& self) { self.setSize(kWindowSize, Common::kMaxWindowSize); } // 0x00436DFC static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); _graphSettings.left = self.x + 4; _graphSettings.top = self.y + self.widgets[Common::widx::panel].top + 4; _graphSettings.width = self.width - kLegendWidth - kLegendMargin - 2 * kWindowPadding; _graphSettings.height = self.height - self.widgets[Common::widx::panel].top - 2 * kWindowPadding; _graphSettings.yOffset = 17; _graphSettings.xOffset = 90; _graphSettings.yAxisLabelIncrement = 25; _graphSettings.linesToExclude = 0; uint16_t maxHistorySize = 1; for (auto& company : CompanyManager::companies()) { if (maxHistorySize < company.historySize) { maxHistorySize = company.historySize; } } uint8_t count = 0; for (auto& company : CompanyManager::companies()) { auto companyId = company.id(); auto companyColour = CompanyManager::getCompanyColour(companyId); _graphSettings.yData[count] = reinterpret_cast<std::byte*>(&company.companyValueHistory[0]); _graphSettings.dataStart[count] = maxHistorySize - company.historySize; _graphSettings.lineColour[count] = Colours::getShade(companyColour, 6); _graphSettings.itemId[count] = enumValue(companyId); count++; } _graphSettings.lineCount = count; _graphSettings.dataEnd = maxHistorySize; _graphSettings.dataTypeSize = 6; _graphSettings.xLabel = StringIds::rawdate_short; _graphSettings.yLabel = StringIds::small_company_value_currency; _graphSettings.xAxisTickIncrement = (_graphSettings.width - _graphSettings.xOffset) / 120; _graphSettings.xAxisLabelIncrement = 12; _graphSettings.dword_113DD86 = 0; _graphSettings.yAxisStepSize = 10000; _graphSettings.flags = GraphFlags::dataFrontToBack; Common::drawGraphAndLegend(self, drawingCtx); } // 0x0043624D static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .prepareDraw = Common::prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CargoPaymentRates { static constexpr Ui::Size32 kWindowSize = { 495, 342 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(495, 342, StringIds::title_cargo_payment_rates) ); // 0x0043737D static void onResize(Window& self) { self.setSize(kWindowSize, Common::kMaxWindowSize); } // 0x004F9442 static constexpr Colour _cargoLineColour[32] = { Colour::red, Colour::mutedPurple, Colour::yellow, Colour::blue, Colour::orange, Colour::green, Colour::mutedDarkRed, Colour::mutedDarkTeal, Colour::mutedDarkYellow, Colour::black, Colour::white, Colour::mutedDarkPurple, Colour::purple, Colour::darkBlue, Colour::mutedTeal, Colour::darkGreen, Colour::mutedSeaGreen, Colour::mutedGrassGreen, Colour::mutedAvocadoGreen, Colour::mutedOliveGreen, Colour::darkYellow, Colour::amber, Colour::grey, Colour::darkOrange, Colour::mutedYellow, Colour::brown, Colour::mutedOrange, Colour::darkRed, Colour::darkPink, Colour::pink, Colour::mutedRed, Colour::grey, }; // 0x00437949 static void drawGraphLegend(Window* self, Gfx::DrawingContext& drawingCtx, int16_t x, int16_t y) { auto tr = Gfx::TextRenderer(drawingCtx); auto cargoCount = 0; for (uint8_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::cargo); i++) { auto cargo = ObjectManager::get<CargoObject>(i); if (cargo == nullptr) { continue; } auto colour = _cargoLineColour[i]; auto palette = Colours::getShade(colour, 6); auto stringId = StringIds::small_black_string; if (self->var_854 & (1 << cargoCount)) { stringId = StringIds::small_white_string; } if (!(self->var_854 & (1 << cargoCount)) || !(_hoverItemTicks & (1 << 2))) { drawingCtx.fillRect(x, y + 3, x + 4, y + 7, palette, Gfx::RectFlags::none); } auto args = FormatArguments(); args.push(cargo->name); auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; cargoCount++; } } // 0x00437120 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); _graphSettings.left = self.x + 4; _graphSettings.top = self.y + self.widgets[Common::widx::panel].top + 14; _graphSettings.width = self.width - kLegendWidth - kLegendMargin - 2 * kWindowPadding; _graphSettings.height = self.height - self.widgets[Common::widx::panel].top - 20 - 2 * kWindowPadding; _graphSettings.yOffset = 17; _graphSettings.xOffset = 80; _graphSettings.yAxisLabelIncrement = 25; _graphSettings.linesToExclude = 0; auto count = 0; for (uint8_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::cargo); i++) { auto cargo = ObjectManager::get<CargoObject>(i); if (cargo == nullptr) { continue; } auto colour = _cargoLineColour[i]; auto deliveredCargoPayment = Economy::getDeliveryCargoPaymentsTable(i); _graphSettings.yData[count] = reinterpret_cast<std::byte*>(deliveredCargoPayment.data()); _graphSettings.dataStart[count] = 0; _graphSettings.lineColour[count] = Colours::getShade(colour, 6); _graphSettings.itemId[count] = i; count++; } _graphSettings.lineCount = count; _graphSettings.dataEnd = static_cast<uint16_t>(std::size(Economy::getDeliveryCargoPaymentsTable(0))); _graphSettings.dataTypeSize = 4; _graphSettings.xLabel = StringIds::cargo_delivered_days; _graphSettings.yLabel = StringIds::cargo_delivered_currency; _graphSettings.xAxisTickIncrement = (_graphSettings.width - _graphSettings.xOffset) / 60; _graphSettings.xAxisLabelIncrement = 20; _graphSettings.dword_113DD86 = 0; _graphSettings.yAxisStepSize = 0; _graphSettings.flags = GraphFlags::none; _graphSettings.xAxisRange = 2; _graphSettings.xAxisStepSize = 2; _graphSettings.pointFlags = GraphPointFlags::drawLines; Ui::drawGraph(_graphSettings, self, drawingCtx); if (self.var_854 != 0) { auto i = 0; while (Numerics::bitScanForward(self.var_854) != _graphSettings.itemId[i]) { i++; } // Exclude all lines except highlighted data _graphSettings.linesToExclude = 0xFFFFFFFF & ~(1 << i); if (_hoverItemTicks & 4) { _graphSettings.lineColour[i] = PaletteIndex::black0; } _graphSettings.flags |= GraphFlags::hideAxesAndLabels; Ui::drawGraph(_graphSettings, self, drawingCtx); } { auto x = self.width + self.x - kLegendWidth - kWindowPadding; auto y = self.y + 52; drawGraphLegend(&self, drawingCtx, x, y); } auto canvasMidX = _graphSettings.xOffset + (_graphSettings.width - _graphSettings.xOffset) / 2; // Chart title { auto point = Point(self.x + canvasMidX, self.widgets[Common::widx::panel].top + self.y + 1); FormatArguments args{}; args.push<uint16_t>(100); args.push<uint16_t>(10); tr.drawStringCentred(point, Colour::black, StringIds::cargo_deliver_graph_title, args); } // X axis label ("Transit time") { auto point = Point(self.x + canvasMidX, self.height + self.y - 13); tr.drawStringCentred(point, Colour::black, StringIds::cargo_transit_time); } } // 0x004379F2 static void setLegendHover(Window* self, int16_t x, int16_t y) { uint32_t selectedCargo = 0; if (!Input::hasFlag(Input::Flags::rightMousePressed)) { const auto location = Input::getMouseLocation2(); auto* frontWindow = WindowManager::findAt(location); const auto xDiff = location.x - x; const auto yDiff = location.y - y; if (frontWindow != nullptr && frontWindow == self && xDiff <= kLegendWidth && xDiff >= 0 && yDiff < 320 && yDiff >= 0) { auto listY = yDiff; uint8_t cargoItem = 0; for (; cargoItem < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoItem) { auto* cargoObj = ObjectManager::get<CargoObject>(cargoItem); if (cargoObj == nullptr) { continue; } listY -= 10; if (listY <= 0) { selectedCargo = 1ULL << cargoItem; break; } } } } if (self->var_854 != selectedCargo) { // TODO: var_854 is 16 bits but selectedCargo is 32 bits. Only the first 15 cargo types can be selected. self->var_854 = selectedCargo; self->invalidate(); } if (self->var_854 != 0) { self->invalidate(); } } // 0x00436273 static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; Economy::buildDeliveredCargoPaymentsTable(); } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .prepareDraw = Common::prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CompanySpeedRecords { static constexpr Ui::Size32 kWindowSize = { 495, 169 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(495, 169, StringIds::title_speed_records) ); // 0x00437591 static void onResize(Window& self) { self.setSize(kWindowSize, kWindowSize); } // 0x0043745A static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto y = self.y + 47; for (auto i = 0; i < 3; i++) { auto recordSpeed = CompanyManager::getRecords().speed[i]; if (recordSpeed == 0_mph) { continue; } { FormatArguments args{}; args.push(recordSpeed); const StringId string[] = { StringIds::land_speed_record, StringIds::air_speed_record, StringIds::water_speed_record, }; auto point = Point(self.x + 4, y); tr.drawStringLeft(point, Colour::black, string[i], args); } y += 11; auto companyId = CompanyManager::getRecords().company[i]; if (companyId != CompanyId::null) { auto company = CompanyManager::get(companyId); auto competitorObj = ObjectManager::get<CompetitorObject>(company->competitorId); auto imageId = competitorObj->images[enumValue(company->ownerEmotion)]; imageId = Gfx::recolour(imageId, company->mainColours.primary); auto x = self.x + 4; drawingCtx.drawImage(x, y, imageId); y += 7; auto point = Point(self.x + 33, y); FormatArguments args{}; args.push(company->name); args.push<uint16_t>(0); args.push(CompanyManager::getRecords().date[i]); tr.drawStringLeft(point, Colour::black, StringIds::record_date_achieved, args); y += 17; } y += 5; } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .prepareDraw = Common::prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { CompanyList::widgets, widx::tab_company_list, CompanyList::getEvents() }, { CompanyPerformance::widgets, widx::tab_performance, CompanyPerformance::getEvents() }, { CargoUnits::widgets, widx::tab_cargo_units, CargoUnits::getEvents() }, { CargoDistance::widgets, widx::tab_cargo_distance, CargoDistance::getEvents() }, { CompanyValues::widgets, widx::tab_values, CompanyValues::getEvents() }, { CargoPaymentRates::widgets, widx::tab_payment_rates, CargoPaymentRates::getEvents() }, { CompanySpeedRecords::widgets, widx::tab_speed_records, CompanySpeedRecords::getEvents() }, }; // clang-format on // 0x0043667B static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_company_list: case Common::widx::tab_performance: case Common::widx::tab_cargo_units: case Common::widx::tab_cargo_distance: case Common::widx::tab_values: case Common::widx::tab_payment_rates: case Common::widx::tab_speed_records: Common::switchTab(self, widgetIndex); break; } } // 0x004378BA static void setLegendHover(Window* self, int16_t x, int16_t y) { uint32_t selectedCompany = 0; if (!Input::hasFlag(Input::Flags::rightMousePressed)) { const auto location = Input::getMouseLocation2(); auto* frontWindow = WindowManager::findAt(location); const auto xDiff = location.x - x; const auto yDiff = location.y - y; if (frontWindow != nullptr && frontWindow == self && xDiff <= kLegendWidth && xDiff >= 0 && yDiff < 150 && yDiff >= 0) { auto listY = yDiff; for (auto& company : CompanyManager::companies()) { listY -= 10; if (listY <= 0) { selectedCompany = 1ULL << enumValue(company.id()); break; } } } } if (self->var_854 != selectedCompany) { self->var_854 = selectedCompany; self->invalidate(); } if (self->var_854 != 0) { self->invalidate(); } } // 0x00437570 static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::companyList, self.number, self.currentTab + Common::widx::tab_company_list); auto legendX = self.x + self.width - kWindowPadding - kLegendWidth; auto legendY = self.y + 52; switch (self.currentTab + widx::tab_company_list) { case widx::tab_cargo_distance: case widx::tab_cargo_units: case widx::tab_performance: case widx::tab_values: { _hoverItemTicks++; setLegendHover(&self, legendX, legendY); break; } case widx::tab_payment_rates: { _hoverItemTicks++; CargoPaymentRates::setLegendHover(&self, legendX, legendY); break; } case widx::tab_speed_records: break; } } // 0x00436419 static void prepareDraw(Window& self) { // Activate the current tab self.activatedWidgets &= ~((1ULL << tab_cargo_distance) | (1ULL << tab_cargo_units) | (1ULL << tab_company_list) | (1ULL << tab_payment_rates) | (1ULL << tab_performance) | (1ULL << tab_speed_records) | (1ULL << tab_values)); self.activatedWidgets |= (1ULL << Common::tabInformationByTabOffset[self.currentTab].widgetIndex); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; } // 0x004360FA static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_company_list; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.viewportRemove(0); const auto& tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_company_list]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.invalidate(); switch (widgetIndex) { case widx::tab_company_list: CompanyList::tabReset(self); break; case widx::tab_performance: CompanyPerformance::tabReset(self); break; case widx::tab_cargo_units: CargoUnits::tabReset(self); break; case widx::tab_cargo_distance: CargoDistance::tabReset(self); break; case widx::tab_values: CompanyValues::tabReset(self); break; case widx::tab_payment_rates: CargoPaymentRates::tabReset(self); break; } self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x00437637 static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); auto skin = ObjectManager::get<InterfaceSkinObject>(); // Company List Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::tab_companies; Widget::drawTab(self, drawingCtx, imageId, widx::tab_company_list); } // Performance Index Tab { static constexpr uint32_t performanceImageIds[] = { InterfaceSkin::ImageIds::tab_performance_index_frame0, InterfaceSkin::ImageIds::tab_performance_index_frame1, InterfaceSkin::ImageIds::tab_performance_index_frame2, InterfaceSkin::ImageIds::tab_performance_index_frame3, InterfaceSkin::ImageIds::tab_performance_index_frame4, InterfaceSkin::ImageIds::tab_performance_index_frame5, InterfaceSkin::ImageIds::tab_performance_index_frame6, InterfaceSkin::ImageIds::tab_performance_index_frame7, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_performance - widx::tab_company_list) { imageId += performanceImageIds[(self.frameNo / 4) % std::size(performanceImageIds)]; } else { imageId += performanceImageIds[0]; } imageId = Gfx::recolour(imageId, self.getColour(WindowColour::secondary).c()); Widget::drawTab(self, drawingCtx, imageId, widx::tab_performance); } // Cargo Unit Tab { static constexpr uint32_t cargoUnitsImageIds[] = { InterfaceSkin::ImageIds::tab_cargo_units_frame0, InterfaceSkin::ImageIds::tab_cargo_units_frame1, InterfaceSkin::ImageIds::tab_cargo_units_frame2, InterfaceSkin::ImageIds::tab_cargo_units_frame3, InterfaceSkin::ImageIds::tab_cargo_units_frame4, InterfaceSkin::ImageIds::tab_cargo_units_frame5, InterfaceSkin::ImageIds::tab_cargo_units_frame6, InterfaceSkin::ImageIds::tab_cargo_units_frame7, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_cargo_units - widx::tab_company_list) { imageId += cargoUnitsImageIds[(self.frameNo / 4) % std::size(cargoUnitsImageIds)]; } else { imageId += cargoUnitsImageIds[0]; } imageId = Gfx::recolour(imageId, self.getColour(WindowColour::secondary).c()); Widget::drawTab(self, drawingCtx, imageId, widx::tab_cargo_units); } // Cargo Distance Tab { static constexpr uint32_t cargoDistanceImageIds[] = { InterfaceSkin::ImageIds::tab_cargo_distance_frame0, InterfaceSkin::ImageIds::tab_cargo_distance_frame1, InterfaceSkin::ImageIds::tab_cargo_distance_frame2, InterfaceSkin::ImageIds::tab_cargo_distance_frame3, InterfaceSkin::ImageIds::tab_cargo_distance_frame4, InterfaceSkin::ImageIds::tab_cargo_distance_frame5, InterfaceSkin::ImageIds::tab_cargo_distance_frame6, InterfaceSkin::ImageIds::tab_cargo_distance_frame7, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_cargo_distance - widx::tab_company_list) { imageId += cargoDistanceImageIds[(self.frameNo / 4) % std::size(cargoDistanceImageIds)]; } else { imageId += cargoDistanceImageIds[0]; } imageId = Gfx::recolour(imageId, self.getColour(WindowColour::secondary).c()); Widget::drawTab(self, drawingCtx, imageId, widx::tab_cargo_distance); } // Company Values Tab { static constexpr uint32_t companyValuesImageIds[] = { InterfaceSkin::ImageIds::tab_production_frame0, InterfaceSkin::ImageIds::tab_production_frame1, InterfaceSkin::ImageIds::tab_production_frame2, InterfaceSkin::ImageIds::tab_production_frame3, InterfaceSkin::ImageIds::tab_production_frame4, InterfaceSkin::ImageIds::tab_production_frame5, InterfaceSkin::ImageIds::tab_production_frame6, InterfaceSkin::ImageIds::tab_production_frame7, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_values - widx::tab_company_list) { imageId += companyValuesImageIds[(self.frameNo / 4) % std::size(companyValuesImageIds)]; } else { imageId += companyValuesImageIds[0]; } imageId = Gfx::recolour(imageId, self.getColour(WindowColour::secondary).c()); Widget::drawTab(self, drawingCtx, imageId, widx::tab_values); if (!(self.isDisabled(widx::tab_values))) { auto& widget = self.widgets[widx::tab_values]; auto point = Point(widget.left + self.x + 28, widget.top + self.y + 14 + 1); tr.drawStringRight(point, Colour::black, StringIds::currency_symbol); } } // Payment Rates Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::tab_cargo_payment_rates; Widget::drawTab(self, drawingCtx, imageId, widx::tab_payment_rates); if (!(self.isDisabled(widx::tab_payment_rates))) { auto& widget = self.widgets[widx::tab_payment_rates]; auto point = Point(widget.left + self.x + 28, widget.top + self.y + 14 + 1); tr.drawStringRight(point, Colour::black, StringIds::currency_symbol); } } // Speed Records Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::tab_awards; imageId = Gfx::recolour(imageId, self.getColour(WindowColour::secondary).c()); Widget::drawTab(self, drawingCtx, imageId, widx::tab_speed_records); } } // 0x00437AB6 static void refreshCompanyList(Window& self) { self.rowCount = 0; for (auto& company : CompanyManager::companies()) { company.challengeFlags &= ~CompanyFlags::sorted; } } // 0x00437810 static void drawGraphLegend(Window& self, Gfx::DrawingContext& drawingCtx, int16_t x, int16_t y) { auto tr = Gfx::TextRenderer(drawingCtx); auto companyCount = 0; for (auto& company : CompanyManager::companies()) { auto companyColour = CompanyManager::getCompanyColour(company.id()); auto colour = Colours::getShade(companyColour, 6); auto stringId = StringIds::small_black_string; if (self.var_854 & (1 << companyCount)) { stringId = StringIds::small_white_string; } if (!(self.var_854 & (1 << companyCount)) || !(_hoverItemTicks & (1 << 2))) { drawingCtx.fillRect(x, y + 3, x + 4, y + 7, colour, Gfx::RectFlags::none); } FormatArguments args{}; args.push(company.name); auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; companyCount++; } } // 0x004365E4 static void drawGraphAndLegend(Window& self, Gfx::DrawingContext& drawingCtx) { auto totalMonths = (getCurrentYear() * 12) + static_cast<uint16_t>(getCurrentMonth()); _graphSettings.xAxisRange = totalMonths; _graphSettings.xAxisStepSize = 1; _graphSettings.pointFlags = GraphPointFlags::drawLines; Ui::drawGraph(_graphSettings, self, drawingCtx); if (self.var_854 != 0) { auto i = 0; auto bitScan = Numerics::bitScanForward(self.var_854); while (bitScan != _graphSettings.itemId[i] && bitScan != -1) { i++; } // Exclude all except highlighted data _graphSettings.linesToExclude = 0xFFFFFFFF & ~(1 << i); if (_hoverItemTicks & (1 << 2)) { _graphSettings.lineColour[i] = 10; } _graphSettings.flags |= GraphFlags::hideAxesAndLabels; Ui::drawGraph(_graphSettings, self, drawingCtx); } auto x = self.width + self.x - kLegendWidth - kWindowPadding; auto y = self.y + 52; Common::drawGraphLegend(self, drawingCtx, x, y); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/CompanyWindow.cpp ```cpp #include "Config.h" #include "Date.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/Company/BuildCompanyHeadquarters.h" #include "GameCommands/Company/ChangeCompanyColour.h" #include "GameCommands/Company/ChangeLoan.h" #include "GameCommands/Company/RemoveCompanyHeadquarters.h" #include "GameCommands/Company/RenameCompanyName.h" #include "GameCommands/Company/RenameCompanyOwner.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/MapSelection.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Scenario.h" #include "ScenarioObjective.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/ColourButtonWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/StepperWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" #include "World/Company.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <cmath> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::CompanyWindow { namespace Common { enum widx { frame, caption, close_button, panel, tab_status, tab_details, tab_colour_scheme, tab_finances, tab_cargo_delivered, tab_challenge, company_select, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 120 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_owner_and_status), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_headquarters_and_details), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_colour_scheme), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_finances), Widgets::Tab({ 127, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_cargo_delivered), Widgets::Tab({ 158, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_challenge_for_this_game), Widgets::ImageButton({ 0, 14 }, { 26, 26 }, WindowColour::primary, ImageIds::null, StringIds::tooltip_select_company)); } // 0x004343FC static void disableChallengeTab(Window* self) { self->disabledWidgets = 0; if (CompanyId(self->number) != CompanyManager::getControllingId()) { self->disabledWidgets |= (1 << widx::tab_challenge); } } // 0x00431E9B static void enableRenameByCaption(Window* self) { if (SceneManager::isEditorMode() || CompanyId(self->number) == CompanyManager::getControllingId()) { self->disabledWidgets &= ~(1ULL << caption); } else { self->disabledWidgets |= (1ULL << caption); } } // Defined at the bottom of this file. static void renameCompanyPrompt(Window* self, WidgetIndex_t widgetIndex); static void renameCompany(Window* self, const char* input); static void switchCompany(Window* self, int16_t itemIndex); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void switchTabWidgets(Window* self); static void drawCompanySelect(const Window* const self, Gfx::DrawingContext& drawingCtx); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); } namespace Status { static constexpr Ui::Size32 kWindowSize = { 270, 182 }; enum widx { unk_11 = 11, viewport, centre_on_viewport, face, change_owner_name, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(270, 182, StringIds::title_company), Widgets::Label({ 3, 160 }, { 242, 21 }, WindowColour::secondary, ContentAlign::center), Widgets::Viewport({ 3, 44 }, { 96, 120 }, WindowColour::secondary, Widget::kContentUnk), Widgets::ImageButton({ 0, 0 }, { 24, 24 }, WindowColour::secondary, ImageIds::centre_viewport, StringIds::move_main_view_to_show_this), Widgets::ImageButton({ 178, 57 }, { 66, 66 }, WindowColour::secondary, Widget::kContentNull), Widgets::ImageButton({ 154, 124 }, { 112, 22 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_change_owner_name) ); // 0x00431EBB static void prepareDraw(Window& self) { Common::switchTabWidgets(&self); // Set company name in title. auto company = CompanyManager::get(CompanyId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(company->name); self.disabledWidgets &= ~((1 << widx::centre_on_viewport) | (1 << widx::face)); // No centring on a viewport that doesn't exist. if (self.viewports[0] == nullptr) { self.disabledWidgets |= (1 << widx::centre_on_viewport); } // No changing other player's faces, unless we're editing a scenario. if (CompanyId(self.number) != CompanyManager::getControllingId() && !SceneManager::isEditorMode()) { self.disabledWidgets |= (1 << widx::face); } self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[widx::viewport].right = self.width - 119; self.widgets[widx::viewport].bottom = self.height - 14; self.widgets[widx::unk_11].top = self.height - 12; self.widgets[widx::unk_11].bottom = self.height - 3; self.widgets[widx::unk_11].right = self.width - 14; self.widgets[widx::change_owner_name].right = self.width - 4; self.widgets[widx::change_owner_name].left = self.width - 116; self.widgets[widx::face].right = self.width - 28; self.widgets[widx::face].left = self.width - 93; self.widgets[Common::widx::company_select].right = self.width - 3; self.widgets[Common::widx::company_select].left = self.width - 28; self.widgets[widx::change_owner_name].hidden = CompanyId(self.number) != CompanyManager::getControllingId(); self.widgets[widx::centre_on_viewport].right = self.widgets[widx::viewport].right - 1; self.widgets[widx::centre_on_viewport].bottom = self.widgets[widx::viewport].bottom - 1; self.widgets[widx::centre_on_viewport].left = self.widgets[widx::viewport].right - 24; self.widgets[widx::centre_on_viewport].top = self.widgets[widx::viewport].bottom - 24; Widget::leftAlignTabs(self, Common::widx::tab_status, Common::widx::tab_challenge); } // 0x00432055 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); Common::drawCompanySelect(&self, drawingCtx); const auto company = CompanyManager::get(CompanyId(self.number)); const auto competitor = ObjectManager::get<CompetitorObject>(company->competitorId); // Draw 'owner' label { auto& widget = self.widgets[widx::face]; auto point = Point(self.x + (widget.left + widget.right) / 2, self.y + widget.top - 12); tr.drawStringCentred( point, Colour::black, StringIds::window_owner); } // Draw company owner image. { const uint32_t image = Gfx::recolour(competitor->images[enumValue(company->ownerEmotion)] + 1, company->mainColours.primary); const uint16_t x = self.x + self.widgets[widx::face].left + 1; const uint16_t y = self.y + self.widgets[widx::face].top + 1; drawingCtx.drawImage(x, y, image); } // If the owner's been naughty, draw some jail bars over them. if (company->jailStatus != 0) { const uint32_t image = ImageIds::owner_jailed; const uint16_t x = self.x + self.widgets[widx::face].left + 1; const uint16_t y = self.y + self.widgets[widx::face].top + 1; drawingCtx.drawImage(x, y, image); } // Draw owner name { FormatArguments args{}; args.push(company->ownerName); auto& widget = self.widgets[widx::change_owner_name]; auto origin = Ui::Point(self.x + (widget.left + widget.right) / 2, self.y + widget.top + 5); tr.drawStringCentredWrapped( origin, widget.right - widget.left, Colour::black, StringIds::black_stringid, args); } // Draw owner status { // TODO: df fix this // Until format arguments can allow pushing to the front we will have to call twice once for the status FormatArguments args{}; StringId status = CompanyManager::getOwnerStatus(CompanyId(self.number), args); args = FormatArguments{}; args.push(status); // and once for the args CompanyManager::getOwnerStatus(CompanyId(self.number), args); auto& widget = self.widgets[widx::unk_11]; auto point = Point(self.x + widget.left - 1, self.y + widget.top - 1); tr.drawStringLeftClipped( point, widget.right - widget.left, Colour::black, StringIds::black_stringid, args); } } // 0x00432244 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameCompanyPrompt(&self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_status: case Common::widx::tab_details: case Common::widx::tab_colour_scheme: case Common::widx::tab_finances: case Common::widx::tab_cargo_delivered: case Common::widx::tab_challenge: Common::switchTab(self, widgetIndex); break; case widx::centre_on_viewport: self.viewportCentreMain(); break; case widx::face: CompanyFaceSelection::open(CompanyId(self.number), self.type); break; case widx::change_owner_name: { auto company = CompanyManager::get(CompanyId(self.number)); TextInput::openTextInput(&self, StringIds::title_name_owner, StringIds::prompt_enter_new_name_for_owner, company->ownerName, widgetIndex, nullptr); break; } } } // 0x00432283 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == Common::widx::company_select) { Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex]); } } // 0x0043228E static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == Common::widx::company_select) { Common::switchCompany(&self, itemIndex); } } // 0x004325DF static void renameCompanyOwnerName(Window* self, const char* input) { if (strlen(input) == 0) { return; } GameCommands::setErrorTitle(StringIds::cannot_change_owner_name); bool success = false; { GameCommands::ChangeCompanyOwnerNameArgs args{}; args.companyId = CompanyId(self->number); args.bufferIndex = 1; std::memcpy(args.newName, input, 36); GameCommands::doCommand(args, GameCommands::Flags::apply); args.bufferIndex = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.bufferIndex = 0; success = GameCommands::doCommand(args, GameCommands::Flags::apply); } // No need to propagate the name if it could not be set. if (!success) { return; } // Only name company after owner if this is a new company. const auto& company = CompanyManager::get(CompanyId(self->number)); if (company->name != StringIds::new_company) { return; } // Temporarily store the new name in buffer string 2039. // TODO: replace with a fixed length! char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strcpy(buffer, input); FormatArguments args{}; args.push(StringIds::buffer_2039); // Add the ' Transport' suffix to the company name, and rename the company. StringManager::formatString(buffer, StringIds::company_owner_name_transport, args); Common::renameCompany(self, buffer); } // 0x004322F6 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget == Common::widx::caption) { Common::renameCompany(&self, input); } else if (callingWidget == widx::change_owner_name) { renameCompanyOwnerName(&self, input); } } // 0x0043270A static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidate(WindowType::company, self.number); } // 0x00432724 static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(Status::kWindowSize, { 640, 400 }); if (self.viewports[0] != nullptr) { Ui::Size proposedDims(self.width - 123, self.height - 59); auto& viewport = self.viewports[0]; if (proposedDims.width != viewport->width || proposedDims.height != viewport->height) { viewport->width = proposedDims.width; viewport->height = proposedDims.height; viewport->viewWidth = proposedDims.width << viewport->zoom; viewport->viewHeight = proposedDims.height << viewport->zoom; self.savedView.clear(); } } self.callViewportRotate(); } static void sub_434336(Window* self, const SavedView& view) { if (self->viewports[0] != nullptr) { return; } auto& widget = self->widgets[widx::viewport]; auto origin = Ui::Point(widget.left + self->x + 1, widget.top + self->y + 1); auto size = Ui::Size(widget.width() - 2, widget.height() - 2); if (view.isEntityView()) { ViewportManager::create(self, 0, origin, size, self->savedView.zoomLevel, view.entityId); } else { ViewportManager::create(self, 0, origin, size, self->savedView.zoomLevel, view.getPos()); } } static void sub_434223(Window* const self, const SavedView& view, const ViewportFlags vpFlags) { self->savedView = view; sub_434336(self, view); self->viewports[0]->flags |= vpFlags; self->invalidate(); } static void differentViewportSettings(Window* const self, const SavedView& view) { auto vpFlags = self->viewports[0]->flags; self->viewportRemove(0); sub_434223(self, view, vpFlags); } static void noViewportPresent(Window* const self, const SavedView& view) { ViewportFlags vpFlags = ViewportFlags::none; if (Config::get().gridlinesOnLandscape) { vpFlags |= ViewportFlags::gridlines_on_landscape; } sub_434223(self, view, vpFlags); } static void invalidViewport(Window* const self) { self->viewportRemove(0); self->invalidate(); } // 0x004327C8 static void viewportRotate(Window& self) { if (self.currentTab != 0) { return; } self.callPrepareDraw(); const auto& company = CompanyManager::get(CompanyId(self.number)); if (company->observationEntity == EntityId::null) { // Observing a certain location? if (company->observationX != -1) { auto tileZAndWater = World::TileManager::getHeight({ company->observationX, company->observationY }); coord_t tileZ = tileZAndWater.landHeight; coord_t waterZ = tileZAndWater.waterHeight; if (waterZ != 0) { tileZ = waterZ; } // loc_43410A int8_t rotation = static_cast<int8_t>(self.viewports[0]->getRotation()); SavedView view( company->observationX, company->observationY, ZoomLevel::half, rotation, static_cast<int16_t>(tileZ + 16)); view.flags |= (1 << 14); if (self.viewports[0] == nullptr) { noViewportPresent(&self, view); return; } if (self.savedView.isEntityView() || self.savedView.rotation != view.rotation || self.savedView.zoomLevel != view.zoomLevel) { if (self.savedView != view) { differentViewportSettings(&self, view); return; } return; } self.savedView = view; self.viewportCentreOnTile(view.getPos()); return; } // Not observing anything at all? else { invalidViewport(&self); } } else { // loc_434170 auto entity = EntityManager::get<OpenLoco::EntityBase>(company->observationEntity); auto* vehicle = entity->asBase<Vehicles::VehicleBase>(); if (vehicle == nullptr) { invalidViewport(&self); return; } if (!vehicle->isVehicleHead() || (vehicle->position.x == Location::null)) { invalidViewport(&self); return; } Vehicles::Vehicle train(vehicle->getHead()); int8_t rotation = static_cast<int8_t>(self.viewports[0]->getRotation()); SavedView view( train.cars.firstCar.body->id, 0xC000, ZoomLevel::full, rotation, 0); if (self.viewports[0] == nullptr) { noViewportPresent(&self, view); return; } if (self.savedView != view) { differentViewportSettings(&self, view); return; } } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .textInput = textInput, .viewportRotate = viewportRotate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x004347D0 static Window* create(CompanyId companyId) { const WindowFlags newFlags = WindowFlags::flag_8 | WindowFlags::flag_11; auto window = WindowManager::createWindow(WindowType::company, Status::kWindowSize, newFlags, Status::getEvents()); window->number = enumValue(companyId); window->owner = companyId; window->currentTab = 0; window->frameNo = 0; window->savedView.clear(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, skin->windowPlayerColor); window->flags |= WindowFlags::resizable; return window; } // 0x0043454F Window* open(CompanyId companyId) { auto window = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); window = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); } } if (window == nullptr) { window = create(companyId); } window->currentTab = 0; window->width = Status::kWindowSize.width; window->height = Status::kWindowSize.height; window->invalidate(); window->setWidgets(Status::widgets); window->holdableWidgets = 0; window->eventHandlers = &Status::getEvents(); window->activatedWidgets = 0; Common::disableChallengeTab(window); window->initScrollWidgets(); window->moveInsideScreenEdges(); return window; } // 0x00435ACC Window* openAndSetName() { CompanyId companyId = CompanyManager::getControllingId(); Window* self = open(companyId); // Allow setting company owner name if no preferred owner name has been set. if (!Config::get().usePreferredOwnerName) { Status::onMouseUp(*self, Status::widx::change_owner_name, WidgetId::none); } return self; } namespace Details { static constexpr Ui::Size32 kWindowSize = { 340, 194 }; static std::optional<GameCommands::HeadquarterPlacementArgs> _headquarterGhost; // New in OpenLoco; not to be confused with rotation of already-placed HQ ghost static uint8_t _headquarterConstructionRotation; enum widx { viewport = 11, build_hq, rotate_hq, centre_on_viewport, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(340, 194, StringIds::title_company_details), Widgets::Viewport({ 219, 54 }, { 96, 120 }, WindowColour::secondary, Widget::kContentUnk), Widgets::ImageButton({ 315, 92 }, { 24, 24 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_build_or_move_headquarters), Widgets::ImageButton({ 315, 92 + 26 }, { 24, 24 }, WindowColour::secondary, ImageIds::rotate_object, StringIds::rotate_object_90), Widgets::ImageButton({ 0, 0 }, { 24, 24 }, WindowColour::secondary, ImageIds::centre_viewport, StringIds::move_main_view_to_show_this) ); // 0x004327CF static void prepareDraw(Window& self) { Common::switchTabWidgets(&self); // Set company name. auto company = CompanyManager::get(CompanyId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(company->name); auto companyColour = CompanyManager::getCompanyColour(CompanyId(self.number)); auto skin = ObjectManager::get<InterfaceSkinObject>(); uint32_t image = skin->img + InterfaceSkin::ImageIds::build_headquarters; self.widgets[widx::build_hq].image = Gfx::recolour(image, companyColour) | Widget::kImageIdColourSet; self.disabledWidgets &= ~(1 << widx::centre_on_viewport); if (company->headquartersX == -1) { self.disabledWidgets |= (1 << widx::centre_on_viewport); } self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[widx::viewport].right = self.width - 26; self.widgets[widx::viewport].bottom = self.height - 14; self.widgets[Common::widx::company_select].right = self.width - 3; self.widgets[Common::widx::company_select].left = self.width - 28; self.widgets[widx::build_hq].hidden = CompanyId(self.number) != CompanyManager::getControllingId(); self.widgets[widx::rotate_hq].hidden = !ToolManager::isToolActive(self.type, self.number, build_hq); self.widgets[widx::centre_on_viewport].right = self.widgets[widx::viewport].right - 1; self.widgets[widx::centre_on_viewport].bottom = self.widgets[widx::viewport].bottom - 1; self.widgets[widx::centre_on_viewport].left = self.widgets[widx::viewport].right - 24; self.widgets[widx::centre_on_viewport].top = self.widgets[widx::viewport].bottom - 24; Widget::leftAlignTabs(self, Common::widx::tab_status, Common::widx::tab_challenge); } static void drawAIdetails(Gfx::DrawingContext& drawingCtx, const int32_t x, int32_t& y, const OpenLoco::Company& company) { auto tr = Gfx::TextRenderer(drawingCtx); const auto competitor = ObjectManager::get<CompetitorObject>(company.competitorId); { FormatArguments args{}; args.push<uint16_t>(competitor->intelligence); args.push(aiRatingToLevel(competitor->intelligence)); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, StringIds::company_details_intelligence, args); y += 10; } { FormatArguments args{}; args.push<uint16_t>(competitor->aggressiveness); args.push(aiRatingToLevel(competitor->aggressiveness)); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, StringIds::company_details_aggressiveness, args); y += 10; } { FormatArguments args{}; args.push<uint16_t>(competitor->competitiveness); args.push(aiRatingToLevel(competitor->competitiveness)); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, StringIds::company_details_competitiveness, args); y += 10; } } static std::array<StringId, 6> transportTypeCountString = { { StringIds::company_details_trains_count, StringIds::company_details_buses_count, StringIds::company_details_trucks_count, StringIds::company_details_trams_count, StringIds::company_details_aircraft_count, StringIds::company_details_ships_count, } }; // 0x00432919 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); Common::drawCompanySelect(&self, drawingCtx); auto company = CompanyManager::get(CompanyId(self.number)); auto x = self.x + 3; auto y = self.y + 48; { FormatArguments args{}; args.push(company->startedDate); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, StringIds::company_details_started, args); y += 10; } { FormatArguments args{}; formatPerformanceIndex(company->performanceIndex, args); StringId formatId = StringIds::company_details_performance; if ((company->challengeFlags & CompanyFlags::decreasedPerformance) != CompanyFlags::none) { formatId = StringIds::company_details_performance_decreasing; } else if ((company->challengeFlags & CompanyFlags::increasedPerformance) != CompanyFlags::none) { formatId = StringIds::company_details_performance_increasing; } auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, formatId, args); y += 25; } { FormatArguments args{}; args.push(company->ownerName); auto point = Point(x, y); tr.drawStringLeftClipped(point, 213, Colour::black, StringIds::owner_label, args); y += 10; } if (!CompanyManager::isPlayerCompany(CompanyId(self.number))) { drawAIdetails(drawingCtx, x + 5, y, *company); } y += 5; { for (auto i = 0; i < 6; ++i) { auto count = company->transportTypeCount[i]; if (count != 0) { FormatArguments args{}; args.push(count); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, transportTypeCountString[i], args); y += 10; } } } { auto& widget = self.widgets[widx::viewport]; auto point = Point(self.x + widget.midX(), self.y + widget.top - 12); tr.drawStringCentred(point, Colour::black, StringIds::wcolour2_headquarters); } if (company->headquartersX == -1) { auto& widget = self.widgets[widx::viewport]; auto loc = Point(self.x + widget.midX(), self.y + widget.midY() - 5); auto width = widget.width() - 2; tr.drawStringCentredWrapped(loc, width, Colour::black, StringIds::not_yet_constructed); } } // 0x00432BDD static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameCompanyPrompt(&self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_status: case Common::widx::tab_details: case Common::widx::tab_colour_scheme: case Common::widx::tab_finances: case Common::widx::tab_cargo_delivered: case Common::widx::tab_challenge: Common::switchTab(self, widgetIndex); break; case widx::centre_on_viewport: self.viewportCentreMain(); break; } } static void rotateHQGhost90Deg() { _headquarterConstructionRotation = (_headquarterConstructionRotation + 1) & 3; } // 0x00432C08 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::company_select: Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex]); break; case widx::build_hq: ToolManager::toolSet(self, widgetIndex, CursorId::placeHQ); Input::setFlag(Input::Flags::flag6); break; case widx::rotate_hq: rotateHQGhost90Deg(); break; } } // 0x00432C19 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == Common::widx::company_select) { Common::switchCompany(&self, itemIndex); } } static void onTabSwitch() { _headquarterConstructionRotation = (WindowManager::getCurrentRotation() + 2) & 3; } // 0x00432C24 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget == Common::widx::caption) { Common::renameCompany(&self, input); } } // 0x00434E94 static void removeHeadquarterGhost() { if (_headquarterGhost.has_value()) { auto flags = GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost; GameCommands::HeadquarterRemovalArgs args; args.pos = _headquarterGhost->pos; GameCommands::doCommand(args, flags); _headquarterGhost = std::nullopt; } } // 0x00434E3F static void placeHeadquarterGhost(const GameCommands::HeadquarterPlacementArgs& args) { removeHeadquarterGhost(); auto flags = GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost; if (GameCommands::doCommand(args, flags) != GameCommands::FAILURE) { _headquarterGhost = args; } } // 0x00434EC7 // input: // regs.ax = mouseX; // regs.bx = mouseY; // output (not verified): // regs.cx = tileX (tile coordinate) // regs.ax = tileY (tile coordinate) // regs.di = tileZ (height) // regs.bh = rotation and buildImmediately // regs.dx = dx - company index (value 1 in testing case) static std::optional<GameCommands::HeadquarterPlacementArgs> getHeadquarterPlacementArgsFromCursor(const int16_t mouseX, const int16_t mouseY) { auto pos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ mouseX, mouseY }); if (!pos) { return {}; } GameCommands::HeadquarterPlacementArgs args; args.type = CompanyManager::getHeadquarterBuildingType(); args.rotation = _headquarterConstructionRotation; auto tile = World::TileManager::get(*pos); const auto* surface = tile.surface(); if (surface == nullptr) { return {}; } auto z = surface->baseHeight(); // di if (surface->slope()) { z += 16; } args.pos = World::Pos3(pos->x, pos->y, z); if (SceneManager::isEditorMode()) { args.buildImmediately = true; // bh } return { args }; } // 0x00432CA1 static void onToolUpdate([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto placementArgs = getHeadquarterPlacementArgsFromCursor(x, y); if (!placementArgs) { removeHeadquarterGhost(); return; } // Always show buildings, not scaffolding, for ghost placements. placementArgs->buildImmediately = true; World::setMapSelectionFlags(World::MapSelectionFlags::enable); World::setMapSelectionCorner(MapSelectionType::full); // TODO: This selection may be incorrect if getHeadquarterBuildingType returns 0 auto posB = World::Pos2(placementArgs->pos) + World::Pos2(32, 32); World::setMapSelectionArea(placementArgs->pos, posB); World::mapInvalidateSelectionRect(); if (_headquarterGhost.has_value()) { if (_headquarterGhost.value().pos == placementArgs->pos && _headquarterGhost.value().rotation == placementArgs->rotation && _headquarterGhost.value().type == placementArgs->type) { return; } } removeHeadquarterGhost(); placeHeadquarterGhost(*placementArgs); } // 0x00432D45 // regs.esi = window* w; // regs.dx = widgetIndex; // regs.ax = mouseX; // regs.bx = mouseY; static void onToolDown([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t mouseX, const int16_t mouseY) { removeHeadquarterGhost(); auto placementArgs = getHeadquarterPlacementArgsFromCursor(mouseX, mouseY); if (!placementArgs) { return; } GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); uint8_t flags = GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing; auto commandResult = GameCommands::doCommand(*placementArgs, flags); if (commandResult != GameCommands::FAILURE) { ToolManager::toolCancel(); } } // 0x00432D7A static void onToolAbort([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { removeHeadquarterGhost(); Ui::Windows::Main::hideGridlines(); } static void onClose(Window& self) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } } // 0x0432D85 static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidate(WindowType::company, self.number); } // 0x00432D9F static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(kWindowSize); self.callViewportRotate(); } static void sub_434377(Window* self, const SavedView& view) { if (self->viewports[0] != nullptr) { return; } auto& widget = self->widgets[widx::viewport]; auto origin = Ui::Point(widget.left + self->x + 1, widget.top + self->y + 1); auto size = Ui::Size(widget.width() - 2, widget.height() - 2); ViewportManager::create(self, 0, origin, size, self->savedView.zoomLevel, view.getPos()); self->flags |= WindowFlags::viewportNoScrolling; self->invalidate(); } // 0x00432E08 static void viewportRotate(Window& self) { if (self.currentTab != Common::tab_details - Common::tab_status) { return; } self.callPrepareDraw(); auto company = CompanyManager::get(CompanyId(self.number)); if (company->headquartersX == -1) { // If headquarters not placed destroy the viewport self.viewportRemove(0); self.invalidate(); return; } int8_t rotation = static_cast<int8_t>(self.viewports[0]->getRotation()); World::Pos3 loc = { static_cast<coord_t>(company->headquartersX + 32), static_cast<coord_t>(company->headquartersY + 32), static_cast<coord_t>((company->headquartersZ + 8) * World::kSmallZStep) }; SavedView view{ loc.x, loc.y, ZoomLevel::full, rotation, loc.z }; view.flags |= (1 << 14); ViewportFlags vpFlags = ViewportFlags::none; if (self.viewports[0] == nullptr) { if (Config::get().gridlinesOnLandscape) { vpFlags |= ViewportFlags::gridlines_on_landscape; } } else if (self.savedView != view) { vpFlags = self.viewports[0]->flags; self.viewportRemove(0); } else { return; } self.savedView = view; sub_434377(&self, view); if (self.viewports[0] != nullptr) { self.viewports[0]->flags = vpFlags; self.invalidate(); } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .textInput = textInput, .viewportRotate = viewportRotate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } bool rotate(Window& self) { if (self.currentTab != Common::widx::tab_details - Common::widx::tab_status) { return false; } Details::rotateHQGhost90Deg(); return true; } namespace ColourScheme { static constexpr Ui::Size32 kWindowSize = { 265, 252 }; enum widx { check_steam_locomotives = 11, check_diesel_locomotives, check_electric_locomotives, check_multiple_units, check_passenger_vehicles, check_freight_vehicles, check_buses, check_trucks, check_aircraft, check_ships, main_colour_scheme, main_colour_steam_locomotives, main_colour_diesel_locomotives, main_colour_electric_locomotives, main_colour_multiple_units, main_colour_passenger_vehicles, main_colour_freight_vehicles, main_colour_buses, main_colour_trucks, main_colour_aircraft, main_colour_ships, secondary_colour_scheme, secondary_colour_steam_locomotives, secondary_colour_diesel_locomotives, secondary_colour_electric_locomotives, secondary_colour_multiple_units, secondary_colour_passenger_vehicles, secondary_colour_freight_vehicles, secondary_colour_buses, secondary_colour_trucks, secondary_colour_aircraft, secondary_colour_ships, }; // clang-format off constexpr uint64_t allMainColours = { (1ULL << widx::main_colour_scheme) | (1ULL << widx::main_colour_steam_locomotives) | (1ULL << widx::main_colour_diesel_locomotives) | (1ULL << widx::main_colour_electric_locomotives) | (1ULL << widx::main_colour_multiple_units) | (1ULL << widx::main_colour_passenger_vehicles) | (1ULL << widx::main_colour_freight_vehicles) | (1ULL << widx::main_colour_buses) | (1ULL << widx::main_colour_trucks) | (1ULL << widx::main_colour_aircraft) | (1ULL << widx::main_colour_ships) }; constexpr uint64_t allSecondaryColours = { (1ULL << widx::secondary_colour_scheme) | (1ULL << widx::secondary_colour_steam_locomotives) | (1ULL << widx::secondary_colour_diesel_locomotives) | (1ULL << widx::secondary_colour_electric_locomotives) | (1ULL << widx::secondary_colour_multiple_units) | (1ULL << widx::secondary_colour_passenger_vehicles) | (1ULL << widx::secondary_colour_freight_vehicles) | (1ULL << widx::secondary_colour_buses) | (1ULL << widx::secondary_colour_trucks) | (1ULL << widx::secondary_colour_aircraft) | (1ULL << widx::secondary_colour_ships) }; constexpr uint64_t allColourChecks = { (1ULL << widx::check_steam_locomotives) | (1ULL << widx::check_diesel_locomotives) | (1ULL << widx::check_electric_locomotives) | (1ULL << widx::check_multiple_units) | (1ULL << widx::check_passenger_vehicles) | (1ULL << widx::check_freight_vehicles) | (1ULL << widx::check_buses) | (1ULL << widx::check_trucks) | (1ULL << widx::check_aircraft) | (1ULL << widx::check_ships) }; // clang-format on static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(265, 252, StringIds::title_company_colour_scheme), Widgets::Checkbox({ 15, 81 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_steam_locomotives, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 98 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_diesel_locomotives, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 115 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_electric_locomotives, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 132 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_multiple_units, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 149 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_passenger_vehicles, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 166 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_freight_vehicles, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 183 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_buses, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 200 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_trucks, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 217 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_aircraft, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::Checkbox({ 15, 234 }, { 204, 12 }, WindowColour::secondary, StringIds::colour_ships, StringIds::tooltip_toggle_vehicle_colour_scheme), Widgets::ColourButton({ 221, 48 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 78 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 95 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 112 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 129 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 146 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 163 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 180 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 197 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 214 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 221, 231 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 239, 48 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 78 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 95 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 112 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 129 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 146 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 163 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 180 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 197 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 214 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ColourButton({ 239, 231 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour) ); // 0x00432E0F static void prepareDraw(Window& self) { Common::switchTabWidgets(&self); // Set company name. auto company = CompanyManager::get(CompanyId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(company->name); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[Common::widx::company_select].right = self.width - 3; self.widgets[Common::widx::company_select].left = self.width - 28; Widget::leftAlignTabs(self, Common::widx::tab_status, Common::widx::tab_challenge); // Set company's main colour self.widgets[widx::main_colour_scheme].image = Widget::kImageIdColourSet | Gfx::recolour(ImageIds::colour_swatch_recolourable, company->mainColours.primary); // Set company's secondary colour self.widgets[widx::secondary_colour_scheme].image = Widget::kImageIdColourSet | Gfx::recolour(ImageIds::colour_swatch_recolourable, company->mainColours.secondary); struct ColourSchemeTuple { WidgetIndex_t checkbox; WidgetIndex_t primary; WidgetIndex_t secondary; }; // clang-format off static constexpr ColourSchemeTuple tuples[] = { { widx::check_steam_locomotives, widx::main_colour_steam_locomotives, widx::secondary_colour_steam_locomotives }, { widx::check_diesel_locomotives, widx::main_colour_diesel_locomotives, widx::secondary_colour_diesel_locomotives }, { widx::check_electric_locomotives, widx::main_colour_electric_locomotives, widx::secondary_colour_electric_locomotives }, { widx::check_multiple_units, widx::main_colour_multiple_units, widx::secondary_colour_multiple_units }, { widx::check_passenger_vehicles, widx::main_colour_passenger_vehicles, widx::secondary_colour_passenger_vehicles }, { widx::check_freight_vehicles, widx::main_colour_freight_vehicles, widx::secondary_colour_freight_vehicles }, { widx::check_buses, widx::main_colour_buses, widx::secondary_colour_buses }, { widx::check_trucks, widx::main_colour_trucks, widx::secondary_colour_trucks }, { widx::check_aircraft, widx::main_colour_aircraft, widx::secondary_colour_aircraft }, { widx::check_ships, widx::main_colour_ships, widx::secondary_colour_ships }, }; // clang-format on for (uint8_t i = 0; i < static_cast<uint8_t>(std::size(tuples)); i++) { // customVehicleColoursSet appears to reserve its first bit for something else, so skip it. if ((company->customVehicleColoursSet & (1 << (i + 1))) != 0) { self.activatedWidgets |= (1ULL << tuples[i].checkbox); self.widgets[tuples[i].primary].image = (1ULL << 30) | Gfx::recolour(ImageIds::colour_swatch_recolourable, company->vehicleColours[i].primary); self.widgets[tuples[i].secondary].image = (1ULL << 30) | Gfx::recolour(ImageIds::colour_swatch_recolourable, company->vehicleColours[i].secondary); self.widgets[tuples[i].primary].hidden = false; self.widgets[tuples[i].secondary].hidden = false; } else { self.activatedWidgets &= ~(1ULL << tuples[i].checkbox); self.widgets[tuples[i].primary].hidden = true; self.widgets[tuples[i].secondary].hidden = true; } } if (CompanyId(self.number) == CompanyManager::getControllingId()) { self.disabledWidgets &= ~(allColourChecks | allMainColours | allSecondaryColours); } else { self.disabledWidgets |= (allColourChecks | allMainColours | allSecondaryColours); } } // 0x00432F9A static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); Common::drawCompanySelect(&self, drawingCtx); const auto& widget = self.widgets[widx::main_colour_scheme]; auto point = Point(self.x + 6, self.y + widget.top + 3); // 'Main colour scheme' tr.drawStringLeft( point, Colour::black, StringIds::main_colour_scheme); // 'Special colour schemes used for' point.y += 17; tr.drawStringLeft( point, Colour::black, StringIds::special_colour_schemes_used_for); } // 0x00433032 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameCompanyPrompt(&self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_status: case Common::widx::tab_details: case Common::widx::tab_colour_scheme: case Common::widx::tab_finances: case Common::widx::tab_cargo_delivered: case Common::widx::tab_challenge: Common::switchTab(self, widgetIndex); break; case widx::check_steam_locomotives: case widx::check_diesel_locomotives: case widx::check_electric_locomotives: case widx::check_multiple_units: case widx::check_passenger_vehicles: case widx::check_freight_vehicles: case widx::check_buses: case widx::check_trucks: case widx::check_aircraft: case widx::check_ships: // customVehicleColoursSet reserves first bit for main colour scheme even though it can't be changed, so skip it. const auto vehicleType = widgetIndex - widx::check_steam_locomotives + 1; const auto company = CompanyManager::get(CompanyId(self.number)); const auto newMode = (company->customVehicleColoursSet & (1 << vehicleType)) == 0 ? 1 : 0; GameCommands::setErrorTitle(StringIds::error_cant_change_colour_scheme); GameCommands::ChangeCompanyColourSchemeArgs args{}; args.value = newMode; args.colourType = vehicleType; args.setColourMode = 1; args.companyId = CompanyId(self.number); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } // 0x00433067 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::company_select: Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex]); break; case main_colour_scheme: case main_colour_steam_locomotives: case main_colour_diesel_locomotives: case main_colour_electric_locomotives: case main_colour_multiple_units: case main_colour_passenger_vehicles: case main_colour_freight_vehicles: case main_colour_buses: case main_colour_trucks: case main_colour_aircraft: case main_colour_ships: { auto* company = CompanyManager::get(CompanyId(self.number)); Colour selectedColour; if (widgetIndex != main_colour_scheme) { auto vehicleType = widgetIndex - main_colour_steam_locomotives; selectedColour = company->vehicleColours[vehicleType].primary; } else { selectedColour = company->mainColours.primary; } auto availableColours = 0x7FFFFFFF & ~(CompanyManager::competingColourMask(CompanyId(self.number))); Dropdown::showColour(&self, &self.widgets[widgetIndex], availableColours, selectedColour, self.getColour(WindowColour::secondary)); break; } case secondary_colour_scheme: case secondary_colour_steam_locomotives: case secondary_colour_diesel_locomotives: case secondary_colour_electric_locomotives: case secondary_colour_multiple_units: case secondary_colour_passenger_vehicles: case secondary_colour_freight_vehicles: case secondary_colour_buses: case secondary_colour_trucks: case secondary_colour_aircraft: case secondary_colour_ships: { auto* company = CompanyManager::get(CompanyId(self.number)); Colour selectedColour; if (widgetIndex != secondary_colour_scheme) { auto vehicleType = widgetIndex - secondary_colour_steam_locomotives; selectedColour = company->vehicleColours[vehicleType].secondary; } else { selectedColour = company->mainColours.secondary; } auto availableColours = 0x7FFFFFFF; Dropdown::showColour(&self, &self.widgets[widgetIndex], availableColours, selectedColour, self.getColour(WindowColour::secondary)); break; } } } // 0x00433092 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget == Common::widx::caption) { Common::renameCompany(&self, input); } } // 0x0043309D static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case Common::widx::company_select: Common::switchCompany(&self, itemIndex); break; case widx::main_colour_scheme: case widx::main_colour_steam_locomotives: case widx::main_colour_diesel_locomotives: case widx::main_colour_electric_locomotives: case widx::main_colour_multiple_units: case widx::main_colour_passenger_vehicles: case widx::main_colour_freight_vehicles: case widx::main_colour_buses: case widx::main_colour_trucks: case widx::main_colour_aircraft: case widx::main_colour_ships: { if (itemIndex == -1) { return; } GameCommands::setErrorTitle(StringIds::error_cant_change_colour_scheme); const int8_t colour = Dropdown::getItemArgument(itemIndex, 2); const auto vehicleType = widgetIndex - widx::main_colour_scheme; GameCommands::ChangeCompanyColourSchemeArgs args{}; args.isPrimary = false; args.value = colour; args.colourType = vehicleType; args.setColourMode = 0; args.companyId = CompanyId(self.number); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } case widx::secondary_colour_scheme: case widx::secondary_colour_steam_locomotives: case widx::secondary_colour_diesel_locomotives: case widx::secondary_colour_electric_locomotives: case widx::secondary_colour_multiple_units: case widx::secondary_colour_passenger_vehicles: case widx::secondary_colour_freight_vehicles: case widx::secondary_colour_buses: case widx::secondary_colour_trucks: case widx::secondary_colour_aircraft: case widx::secondary_colour_ships: { if (itemIndex == -1) { return; } GameCommands::setErrorTitle(StringIds::error_cant_change_colour_scheme); const int8_t colour = Dropdown::getItemArgument(itemIndex, 2); const auto vehicleType = widgetIndex - widx::secondary_colour_scheme; GameCommands::ChangeCompanyColourSchemeArgs args{}; args.isPrimary = true; args.value = colour; args.colourType = vehicleType; args.setColourMode = 0; args.companyId = CompanyId(self.number); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } } // 0x0043325F static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidate(WindowType::company, self.number); } // 0x00433279 static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(kWindowSize); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .textInput = textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Finances { static constexpr Ui::Size32 kWindowSize = { 636, 319 }; enum widx { scrollview = 11, currentLoan, loan_decrease, loan_increase, loan_autopay, }; constexpr uint16_t expenditureColumnWidth = 128; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(636, 319, StringIds::title_company_finances), Widgets::ScrollView({ 133, 45 }, { 499, 215 }, WindowColour::secondary, Scrollbars::horizontal), Widgets::stepperWidgets({ 87, 264 }, { 100, 12 }, WindowColour::secondary, StringIds::company_current_loan_value), Widgets::Checkbox({ 320, 264 }, { 204, 12 }, WindowColour::secondary, StringIds::loan_autopay, StringIds::tooltip_loan_autopay) // loan_autopay ); const uint64_t holdableWidgets = (1 << widx::loan_decrease) | (1 << widx::loan_increase); // 0x004332E4 static void prepareDraw(Window& self) { Common::switchTabWidgets(&self); auto company = CompanyManager::get(CompanyId(self.number)); // Set company name. { auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(company->name); } // Set current loan value. { auto args = FormatArguments(self.widgets[widx::currentLoan].textArgs); args.push(company->currentLoan); } self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[Common::widx::company_select].right = self.width - 3; self.widgets[Common::widx::company_select].left = self.width - 28; const auto isControllingCompany = company->id() == CompanyManager::getControllingId(); self.widgets[widx::currentLoan].hidden = !isControllingCompany; self.widgets[widx::loan_decrease].hidden = !isControllingCompany; self.widgets[widx::loan_increase].hidden = !isControllingCompany; self.widgets[widx::loan_autopay].hidden = !isControllingCompany; if (isControllingCompany) { if ((company->challengeFlags & CompanyFlags::autopayLoan) != CompanyFlags::none) { self.activatedWidgets |= (1ULL << Finances::widx::loan_autopay); } else { self.activatedWidgets &= ~(1ULL << Finances::widx::loan_autopay); } } Widget::leftAlignTabs(self, Common::widx::tab_status, Common::widx::tab_challenge); } // 0x004333D0 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); Common::drawCompanySelect(&self, drawingCtx); const auto company = CompanyManager::get(CompanyId(self.number)); // Draw 'expenditure/income' label { auto point = Point(self.x + 5, self.y + 47); tr.drawStringLeftUnderline( point, Colour::black, StringIds::expenditure_income); } const StringId ExpenditureLabels[] = { StringIds::train_income, StringIds::train_running_costs, StringIds::bus_income, StringIds::bus_running_costs, StringIds::truck_income, StringIds::truck_running_costs, StringIds::tram_income, StringIds::tram_running_costs, StringIds::aircraft_income, StringIds::aircraft_running_costs, StringIds::ship_income, StringIds::ship_running_costs, StringIds::construction, StringIds::vehicle_purchases, StringIds::vehicle_disposals, StringIds::loan_interest, StringIds::miscellaneous, }; uint16_t y = self.y + 62; for (uint8_t i = 0; i < static_cast<uint8_t>(std::size(ExpenditureLabels)); i++) { // Add zebra stripes to even labels. if (i % 2 == 0) { auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 6); drawingCtx.fillRect(self.x + 4, y, self.x + 129, y + 9, colour, Gfx::RectFlags::crossHatching); } FormatArguments args{}; args.push(ExpenditureLabels[i]); auto point = Point(self.x + 5, y - 1); tr.drawStringLeft( point, Colour::black, StringIds::wcolour2_stringid, args); y += 10; } // 'Current loan' label { auto point = Point(self.x + 7, self.y + self.widgets[widx::currentLoan].top); tr.drawStringLeft( point, Colour::black, StringIds::company_current_loan); } // '@ X% interest per' label { FormatArguments args{}; args.push<uint16_t>(getGameState().loanInterestRate); auto& widget = self.widgets[widx::currentLoan]; auto point = Point(self.x + widget.right + 3, self.y + widget.top + 1); tr.drawStringLeft( point, Colour::black, StringIds::interest_per_year, args); } // 'Cash' label with value { // Set cash value in format args. FormatArguments args{}; args.push(company->cash); auto cashFormat = StringIds::cash_positive; if ((company->challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { cashFormat = StringIds::cash_bankrupt; } else if (company->cash.var_04 < 0) { cashFormat = StringIds::cash_negative; } auto point = Point(self.x + 7, self.y + self.widgets[widx::currentLoan].top + 13); tr.drawStringLeft( point, Colour::black, cashFormat, args); } // 'Company value' label with value { // Set company value in format args. FormatArguments args{}; args.push(company->companyValueHistory[0]); auto point = Point(self.x + 7, self.y + self.widgets[widx::currentLoan].top + 26); tr.drawStringLeft( point, Colour::black, StringIds::company_value, args); } // 'Profit from vehicles' label with value { // Set company value in format args. FormatArguments args{}; args.push(company->vehicleProfit); auto point = Point(self.x + 7, self.y + self.widgets[widx::currentLoan].top + 39); tr.drawStringLeft( point, Colour::black, StringIds::profit_from_vehicles, args); } } static void drawFinanceYear(Gfx::DrawingContext& drawingCtx, int16_t x, int16_t& y, uint16_t columnYear, uint16_t currentYear) { auto tr = Gfx::TextRenderer(drawingCtx); FormatArguments args{}; args.push(StringIds::uint16_raw); args.push(columnYear); StringId format = StringIds::wcolour2_stringid; if (columnYear != currentYear) { format = StringIds::black_stringid; } auto point = Point(x, y); tr.drawStringRightUnderline( point, Colour::black, format, args); y += 14; } static currency48_t drawFinanceExpenditureColumn(Gfx::DrawingContext& drawingCtx, const int16_t x, int16_t& y, uint8_t columnIndex, Company& company) { auto tr = Gfx::TextRenderer(drawingCtx); currency48_t sum = 0; for (auto j = 0; j < ExpenditureType::Count; j++) { currency48_t expenditures = company.expenditures[columnIndex][j]; sum += expenditures; if (expenditures != 0) { FormatArguments args{}; args.push(StringIds::currency48); args.push(expenditures); auto point = Point(x, y); tr.drawStringRight( point, Colour::black, StringIds::black_stringid, args); } y += 10; } return sum; } static void drawFinanceSum(Gfx::DrawingContext& drawingCtx, int16_t x, int16_t& y, currency48_t sum) { auto tr = Gfx::TextRenderer(drawingCtx); auto mainFormat = StringIds::black_stringid; auto sumFormat = StringIds::plus_currency48; if (sum < 0) { mainFormat = StringIds::red_stringid; sumFormat = StringIds::currency48; } FormatArguments args{}; args.push(sumFormat); args.push(sum); y += 4; auto point = Point(x, y); tr.drawStringRight(point, Colour::black, mainFormat, args); drawingCtx.fillRect(x - expenditureColumnWidth + 10, y - 2, x, y - 2, PaletteIndex::black0, Gfx::RectFlags::none); } // 0x0043361E static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { int16_t y = 47 - self.widgets[widx::scrollview].top + 14; for (uint8_t i = 0; i < static_cast<uint8_t>(ExpenditureType::Count); i++) { // Add zebra stripes to even labels. if (i % 2 == 0) { auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 6); drawingCtx.fillRect(0, y, expenditureColumnWidth * 17, y + 9, colour, Gfx::RectFlags::crossHatching); } y += 10; } const auto company = CompanyManager::get(CompanyId(self.number)); uint32_t curYear = getCurrentYear(); uint8_t expenditureYears = std::min<uint8_t>(company->numExpenditureYears, kExpenditureHistoryCapacity); // Paint years on top of scroll area. int16_t x = 132 - self.widgets[widx::scrollview].left + expenditureColumnWidth; for (auto i = 0; i < expenditureYears; i++) { y = 46 - self.widgets[widx::scrollview].top; uint16_t columnYear = curYear - (expenditureYears - i) + 1; uint8_t columnIndex = expenditureYears - i - 1; drawFinanceYear(drawingCtx, x, y, columnYear, curYear); auto sum = drawFinanceExpenditureColumn(drawingCtx, x, y, columnIndex, *company); drawFinanceSum(drawingCtx, x, y, sum); x += expenditureColumnWidth; } } // 0x00433819 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameCompanyPrompt(&self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_status: case Common::widx::tab_details: case Common::widx::tab_colour_scheme: case Common::widx::tab_finances: case Common::widx::tab_cargo_delivered: case Common::widx::tab_challenge: Common::switchTab(self, widgetIndex); break; case widx::loan_autopay: { auto company = CompanyManager::get(CompanyId(self.number)); company->challengeFlags ^= CompanyFlags::autopayLoan; break; } } } static inline currency32_t calculateStepSize(uint16_t repeatTicks) { return 1000 * std::pow(10, repeatTicks / 100); } // 0x0043383E static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::company_select: Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex]); break; case widx::loan_decrease: { auto company = CompanyManager::get(CompanyId(self.number)); if (company->currentLoan == 0) { return; } GameCommands::ChangeLoanArgs args{}; args.newLoan = std::max<currency32_t>(0, company->currentLoan - calculateStepSize(Input::getClickRepeatTicks())); GameCommands::setErrorTitle(StringIds::cant_pay_back_loan); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } case widx::loan_increase: { GameCommands::ChangeLoanArgs args{}; args.newLoan = CompanyManager::get(CompanyId(self.number))->currentLoan + calculateStepSize(Input::getClickRepeatTicks()); GameCommands::setErrorTitle(StringIds::cant_borrow_any_more_money); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } } // 0x0043385D static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget == Common::widx::caption) { Common::renameCompany(&self, input); } } // 0x004C8DBF // For the finances the most recent data on the scroll view is the data // most off to the right of the scroll. This function moves to the last // page of data as far to the right of the scroll. static void scrollToLatestData(Window& self) { self.initScrollWidgets(); self.scrollAreas[0].contentOffsetX = 0x7FFF; self.scrollAreas[0].contentWidth = 0; self.updateScrollWidgets(); const Ui::Widget& widget = self.widgets[widx::scrollview]; const auto x = std::max<int16_t>(0, self.scrollAreas[0].contentOffsetX); auto widgetWidth = widget.width() - 2; if (self.scrollAreas[0].hasFlags(ScrollFlags::vscrollbarVisible)) { widgetWidth -= ScrollView::kScrollbarSize; } // This gets the offset of the last full page (widgetWidth) of the scroll view const auto newOffset = std::max(0, self.scrollAreas[0].contentWidth - widgetWidth); self.scrollAreas[0].contentOffsetX = std::min<int16_t>(x, newOffset); ScrollView::updateThumbs(self, widx::scrollview); } // 0x00433868 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == Common::widx::company_select) { Common::switchCompany(&self, itemIndex); scrollToLatestData(self); self.invalidate(); } } // 0x0043386F static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, int32_t& scrollWidth, [[maybe_unused]] int32_t& scrollHeight) { const auto& company = CompanyManager::get(CompanyId(self.number)); scrollWidth = company->numExpenditureYears * expenditureColumnWidth; } // 0x00433887 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_list); return args; } // 0x0043399D static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidate(WindowType::company, self.number); } // 0x004339B7 static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(kWindowSize); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .getScrollSize = getScrollSize, .textInput = textInput, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x004345EE Window* openFinances(CompanyId companyId) { auto window = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); window = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); } } if (window == nullptr) { window = create(companyId); } window->currentTab = Common::tab_finances - Common::tab_status; window->width = Finances::kWindowSize.width; window->height = Finances::kWindowSize.height; window->invalidate(); window->setWidgets(Finances::widgets); window->holdableWidgets = Finances::holdableWidgets; window->eventHandlers = &Finances::getEvents(); window->activatedWidgets = 0; Common::disableChallengeTab(window); window->initScrollWidgets(); window->moveInsideScreenEdges(); Finances::scrollToLatestData(*window); return window; } namespace CargoDelivered { static constexpr Ui::Size32 kWindowSize = { 240, 382 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(240, 382, StringIds::title_company_cargo_delivered) ); // 0x00433A22 static void prepareDraw(Window& self) { Common::switchTabWidgets(&self); // Set company name. auto company = CompanyManager::get(CompanyId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(company->name); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; Widget::leftAlignTabs(self, Common::widx::tab_status, Common::widx::tab_challenge); } // 0x00433ACD static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); uint16_t y = self.y + 47; // 'Cargo delivered' { auto point = Point(self.x + 5, y); tr.drawStringLeft(point, Colour::black, StringIds::cargo_delivered); } y += 10; uint8_t numPrinted = 0; const auto company = CompanyManager::get(CompanyId(self.number)); for (uint8_t i = 0; i < static_cast<uint8_t>(std::size(company->cargoDelivered)); i++) { auto cargo = ObjectManager::get<CargoObject>(i); if (cargo == nullptr || company->cargoDelivered[i] == 0) { continue; } FormatArguments args{}; if (company->cargoDelivered[i] == 1) { args.push(cargo->unitNameSingular); } else { args.push(cargo->unitNamePlural); } args.push(company->cargoDelivered[i]); auto point = Point(self.x + 10, y); tr.drawStringLeft(point, Colour::black, StringIds::black_stringid, args); numPrinted++; y += 10; } // No cargo delivered yet? if (numPrinted == 0) { auto point = Point(self.x + 10, y); tr.drawStringLeft(point, Colour::black, StringIds::cargo_delivered_none); } } // 0x00433BE6 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameCompanyPrompt(&self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_status: case Common::widx::tab_details: case Common::widx::tab_colour_scheme: case Common::widx::tab_finances: case Common::widx::tab_cargo_delivered: case Common::widx::tab_challenge: Common::switchTab(self, widgetIndex); break; } } // 0x00433C0B static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == Common::widx::company_select) { Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex]); } } // 0x00433C16 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget == Common::widx::caption) { Common::renameCompany(&self, input); } } // 0x00433C21 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == Common::widx::company_select) { Common::switchCompany(&self, itemIndex); } } // 0x00433C7D static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidate(WindowType::company, self.number); } // 0x00433C97 static void onResize(Window& self) { Common::enableRenameByCaption(&self); uint16_t cargoHeight = 0; const auto company = CompanyManager::get(CompanyId(self.number)); for (uint8_t i = 0; i < static_cast<uint8_t>(std::size(company->cargoDelivered)); i++) { auto cargo = ObjectManager::get<CargoObject>(i); if (cargo == nullptr || company->cargoDelivered[i] == 0) { continue; } cargoHeight += 10; } const uint16_t kWindowHeight = std::max<int16_t>(cargoHeight, 50) + 62; self.setSize({ kWindowSize.width, kWindowHeight }); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .textInput = textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Challenge { static constexpr Ui::Size32 kWindowSize = { 320, 182 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(320, 182, StringIds::title_company_challenge) ); // 0x00433D39 static void prepareDraw(Window& self) { Common::switchTabWidgets(&self); // Set company name. auto company = CompanyManager::get(CompanyId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(company->name); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[Common::widx::company_select].right = self.width - 3; self.widgets[Common::widx::company_select].left = self.width - 28; self.widgets[Common::widx::company_select].hidden = true; Widget::leftAlignTabs(self, Common::widx::tab_status, Common::widx::tab_challenge); } // 0x00433DEB static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); char* buffer_2039 = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); *buffer_2039++ = static_cast<char>(ControlCodes::Colour::black); char* scenarioDetailsString = getGameState().scenarioDetails; StringManager::locoStrcpy(buffer_2039, scenarioDetailsString); auto point = Point(self.x + 5, self.y + 47); // for example: "Provide the transport services on this little island" for "Boulder Breakers" scenario point = tr.drawStringLeftWrapped(point, self.width - 10, Colour::black, StringIds::buffer_2039); point.y += 5; tr.drawStringLeft(point, Colour::black, StringIds::challenge_label); point.y += 10; { FormatArguments args{}; Scenario::formatChallengeArguments(Scenario::getObjective(), Scenario::getObjectiveProgress(), args); point = tr.drawStringLeftWrapped(point, self.width - 10, Colour::black, StringIds::challenge_value, args); point.y += 5; } Company* playerCompany = CompanyManager::getPlayerCompany(); if ((playerCompany->challengeFlags & CompanyFlags::challengeCompleted) != CompanyFlags::none) { uint16_t years = Scenario::getObjectiveProgress().completedChallengeInMonths / 12; uint16_t months = Scenario::getObjectiveProgress().completedChallengeInMonths % 12; FormatArguments args{}; args.push(years); args.push(months); tr.drawStringLeftWrapped(point, self.width - 10, Colour::black, StringIds::success_you_completed_the_challenge_in_years_months, args); return; } if ((playerCompany->challengeFlags & CompanyFlags::challengeFailed) != CompanyFlags::none) { tr.drawStringLeftWrapped(point, self.width - 10, Colour::black, StringIds::failed_you_failed_to_complete_the_challenge); return; } if ((playerCompany->challengeFlags & CompanyFlags::challengeBeatenByOpponent) != CompanyFlags::none) { uint16_t years = Scenario::getObjectiveProgress().completedChallengeInMonths / 12; uint16_t months = Scenario::getObjectiveProgress().completedChallengeInMonths % 12; FormatArguments args{}; args.push(CompanyManager::getOpponent()->ownerName); args.skip(2); args.push(years); args.push(months); tr.drawStringLeftWrapped(point, self.width - 10, Colour::black, StringIds::beaten_by_other_player_completed_in_years_months, args); return; } { FormatArguments args{}; args.push<uint16_t>(playerCompany->challengeProgress); point = tr.drawStringLeftWrapped(point, self.width - 10, Colour::black, StringIds::progress_towards_completing_challenge_percent, args); } if ((Scenario::getObjective().flags & Scenario::ObjectiveFlags::withinTimeLimit) != Scenario::ObjectiveFlags::none) { // time limited challenge uint16_t monthsLeft = Scenario::getObjective().timeLimitYears * 12 - Scenario::getObjectiveProgress().monthsInChallenge; uint16_t years = monthsLeft / 12; uint16_t months = monthsLeft % 12; FormatArguments args{}; args.push(years); args.push(months); tr.drawStringLeftWrapped(point, self.width + 10, Colour::black, StringIds::time_remaining_years_months, args); return; } } // 0x00433FFE static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameCompanyPrompt(&self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_status: case Common::widx::tab_details: case Common::widx::tab_colour_scheme: case Common::widx::tab_finances: case Common::widx::tab_cargo_delivered: case Common::widx::tab_challenge: Common::switchTab(self, widgetIndex); break; } } // 0x00434023 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget == Common::widx::caption) { Common::renameCompany(&self, input); } } // 0x0043402E static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidate(WindowType::company, self.number); } // 0x00434048 static void onResize(Window& self) { self.setSize(kWindowSize); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .textInput = textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } // 00434731 Window* openChallenge(CompanyId companyId) { auto window = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); window = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); } } if (window == nullptr) { window = create(companyId); } window->currentTab = Common::tab_challenge - Common::tab_status; window->width = Challenge::kWindowSize.width; window->height = Challenge::kWindowSize.height; window->invalidate(); window->setWidgets(Challenge::widgets); window->holdableWidgets = 0; window->eventHandlers = &Challenge::getEvents(); window->activatedWidgets = 0; Common::disableChallengeTab(window); window->initScrollWidgets(); window->moveInsideScreenEdges(); return window; } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; const Ui::Size32* kWindowSize; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { Status::widgets, widx::tab_status, Status::getEvents(), &Status::kWindowSize }, { Details::widgets, widx::tab_details, Details::getEvents(), &Details::kWindowSize }, { ColourScheme::widgets, widx::tab_colour_scheme, ColourScheme::getEvents(), &ColourScheme::kWindowSize }, { Finances::widgets, widx::tab_finances, Finances::getEvents(), &Finances::kWindowSize }, { CargoDelivered::widgets, widx::tab_cargo_delivered, CargoDelivered::getEvents(), &CargoDelivered::kWindowSize }, { Challenge::widgets, widx::tab_challenge, Challenge::getEvents(), &Challenge::kWindowSize } }; // clang-format on static void switchCompany(Window* self, int16_t itemIndex) { if (itemIndex == -1) { return; } CompanyId companyId = Dropdown::getCompanyIdFromSelection(itemIndex); // Try to find an open company window for this company. auto companyWindow = WindowManager::bringToFront(WindowType::company, enumValue(companyId)); if (companyWindow != nullptr) { return; } // If not, we'll turn this window into a window for the company selected. auto company = CompanyManager::get(companyId); if (company->name == StringIds::empty) { return; } self->number = enumValue(companyId); self->owner = companyId; Common::disableChallengeTab(self); self->invalidate(); } static void switchTabWidgets(Window* self) { self->activatedWidgets = 0; static std::span<const Widget> widgetCollectionsByTabId[] = { Status::widgets, Details::widgets, ColourScheme::widgets, Finances::widgets, CargoDelivered::widgets, Challenge::widgets, }; auto newWidgets = widgetCollectionsByTabId[self->currentTab]; self->setWidgets(newWidgets); // self->initScrollWidgets(); static constexpr widx tabWidgetIdxByTabId[] = { tab_status, tab_details, tab_colour_scheme, tab_finances, tab_cargo_delivered, tab_challenge, }; self->activatedWidgets &= ~((1 << tab_status) | (1 << tab_details) | (1 << tab_colour_scheme) | (1 << tab_finances) | (1 << tab_cargo_delivered) | (1 << tab_challenge)); self->activatedWidgets |= (1ULL << tabWidgetIdxByTabId[self->currentTab]); } // 0x0043230B static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } TextInput::sub_4CE6C9(self.type, self.number); self.currentTab = widgetIndex - widx::tab_status; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.viewportRemove(0); auto tabIndex = widgetIndex - widx::tab_status; auto tabInfo = tabInformationByTabOffset[tabIndex]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); if (tabInfo.widgetIndex == widx::tab_finances) { self.holdableWidgets = Finances::holdableWidgets; } Common::disableChallengeTab(&self); self.invalidate(); self.setSize(*tabInfo.kWindowSize); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); if (tabInfo.widgetIndex == widx::tab_details) { Details::onTabSwitch(); } if (tabInfo.widgetIndex == widx::tab_finances) { Finances::scrollToLatestData(self); } } // 0x0043252E static void renameCompanyPrompt(Window* self, WidgetIndex_t widgetIndex) { auto company = CompanyManager::get(CompanyId(self->number)); TextInput::openTextInput(self, StringIds::title_name_company, StringIds::prompt_enter_new_company_name, company->name, widgetIndex, nullptr); } // 0x0043254F static void renameCompany(Window* self, const char* input) { if (strlen(input) == 0) { return; } GameCommands::setErrorTitle(StringIds::cannot_rename_this_company); GameCommands::ChangeCompanyNameArgs args{}; args.companyId = CompanyId(self->number); args.bufferIndex = 1; std::memcpy(args.buffer, input, 36); GameCommands::doCommand(args, GameCommands::Flags::apply); args.bufferIndex = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.bufferIndex = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); } static void drawCompanySelect(const Window* const self, Gfx::DrawingContext& drawingCtx) { const auto company = CompanyManager::get(CompanyId(self->number)); const auto competitor = ObjectManager::get<CompetitorObject>(company->competitorId); // Draw company owner face. const uint32_t image = Gfx::recolour(competitor->images[enumValue(company->ownerEmotion)], company->mainColours.primary); const uint16_t x = self->x + self->widgets[Common::widx::company_select].left + 1; const uint16_t y = self->y + self->widgets[Common::widx::company_select].top + 1; drawingCtx.drawImage(x, y, image); } // 0x00434413 void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Status tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::tab_company; Widget::drawTab(self, drawingCtx, imageId, widx::tab_status); } // Details tab { const uint32_t imageId = Gfx::recolour(skin->img + InterfaceSkin::ImageIds::tab_company_details, self.getColour(WindowColour::primary).c()); Widget::drawTab(self, drawingCtx, imageId, widx::tab_details); } // Colour scheme tab { static constexpr uint32_t colourSchemeTabImageIds[] = { InterfaceSkin::ImageIds::tab_colour_scheme_frame0, InterfaceSkin::ImageIds::tab_colour_scheme_frame1, InterfaceSkin::ImageIds::tab_colour_scheme_frame2, InterfaceSkin::ImageIds::tab_colour_scheme_frame3, InterfaceSkin::ImageIds::tab_colour_scheme_frame4, InterfaceSkin::ImageIds::tab_colour_scheme_frame5, InterfaceSkin::ImageIds::tab_colour_scheme_frame6, InterfaceSkin::ImageIds::tab_colour_scheme_frame7, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_colour_scheme - widx::tab_status) { imageId += colourSchemeTabImageIds[(self.frameNo / 4) % std::size(colourSchemeTabImageIds)]; } else { imageId += colourSchemeTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_colour_scheme); } // Finances tab { static constexpr uint32_t financesTabImageIds[] = { InterfaceSkin::ImageIds::tab_finances_frame0, InterfaceSkin::ImageIds::tab_finances_frame1, InterfaceSkin::ImageIds::tab_finances_frame2, InterfaceSkin::ImageIds::tab_finances_frame3, InterfaceSkin::ImageIds::tab_finances_frame4, InterfaceSkin::ImageIds::tab_finances_frame5, InterfaceSkin::ImageIds::tab_finances_frame6, InterfaceSkin::ImageIds::tab_finances_frame7, InterfaceSkin::ImageIds::tab_finances_frame8, InterfaceSkin::ImageIds::tab_finances_frame9, InterfaceSkin::ImageIds::tab_finances_frame10, InterfaceSkin::ImageIds::tab_finances_frame11, InterfaceSkin::ImageIds::tab_finances_frame12, InterfaceSkin::ImageIds::tab_finances_frame13, InterfaceSkin::ImageIds::tab_finances_frame14, InterfaceSkin::ImageIds::tab_finances_frame15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_finances - widx::tab_status) { imageId += financesTabImageIds[(self.frameNo / 2) % std::size(financesTabImageIds)]; } else { imageId += financesTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_finances); } // Cargo delivered tab { static constexpr uint32_t cargoDeliveredTabImageIds[] = { InterfaceSkin::ImageIds::tab_cargo_delivered_frame0, InterfaceSkin::ImageIds::tab_cargo_delivered_frame1, InterfaceSkin::ImageIds::tab_cargo_delivered_frame2, InterfaceSkin::ImageIds::tab_cargo_delivered_frame3, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_cargo_delivered - widx::tab_status) { imageId += cargoDeliveredTabImageIds[(self.frameNo / 4) % std::size(cargoDeliveredTabImageIds)]; } else { imageId += cargoDeliveredTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_cargo_delivered); } // Challenge tab { static constexpr uint32_t challengeTabImageIds[] = { InterfaceSkin::ImageIds::tab_cup_frame0, InterfaceSkin::ImageIds::tab_cup_frame1, InterfaceSkin::ImageIds::tab_cup_frame2, InterfaceSkin::ImageIds::tab_cup_frame3, InterfaceSkin::ImageIds::tab_cup_frame4, InterfaceSkin::ImageIds::tab_cup_frame5, InterfaceSkin::ImageIds::tab_cup_frame6, InterfaceSkin::ImageIds::tab_cup_frame7, InterfaceSkin::ImageIds::tab_cup_frame8, InterfaceSkin::ImageIds::tab_cup_frame9, InterfaceSkin::ImageIds::tab_cup_frame10, InterfaceSkin::ImageIds::tab_cup_frame11, InterfaceSkin::ImageIds::tab_cup_frame12, InterfaceSkin::ImageIds::tab_cup_frame13, InterfaceSkin::ImageIds::tab_cup_frame14, InterfaceSkin::ImageIds::tab_cup_frame15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_challenge - widx::tab_status) { imageId += challengeTabImageIds[(self.frameNo / 4) % std::size(challengeTabImageIds)]; } else { imageId += challengeTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_challenge); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/DebugWindow.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include <vector> namespace OpenLoco::Ui::Windows::Debug { static constexpr Ui::Size32 kWindowSize = { 400, 260 }; static constexpr int32_t kMargin = 2; static constexpr int32_t kTitlebarHeight = 13; static constexpr int32_t kLabelHeight = 12; static constexpr int32_t kButtonHeight = 12; static constexpr int32_t kRowSize = 24; static constexpr int32_t kTabWidth = 31; static constexpr int32_t kTabHeight = 27; namespace widx { constexpr auto frame = WidgetId("frame"); constexpr auto title = WidgetId("title"); constexpr auto close = WidgetId("close"); constexpr auto panel = WidgetId("panel"); constexpr auto button_1 = WidgetId("button_1"); constexpr auto button_2 = WidgetId("button_2"); constexpr auto label_1 = WidgetId("label_1"); constexpr auto label_2 = WidgetId("label_2"); constexpr auto label_3 = WidgetId("label_3"); constexpr auto tab_1 = WidgetId("tab_1"); constexpr auto tab_2 = WidgetId("tab_2"); constexpr auto tab_3 = WidgetId("tab_3"); constexpr auto checkbox_1 = WidgetId("checkbox_1"); constexpr auto checkbox_2 = WidgetId("checkbox_2"); constexpr auto checkbox_3 = WidgetId("checkbox_3"); constexpr auto checkbox_4 = WidgetId("checkbox_4"); // constexpr auto tab_4 = WidgetId("tab_4"); } static const WindowEventList& getEvents(); namespace { using namespace Widgets; static constexpr auto _widgets = makeWidgets( Frame(widx::frame, { 0, 0 }, kWindowSize, WindowColour::primary), Caption(widx::title, { 1, 1 }, { kWindowSize.width - 2, kTitlebarHeight }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::openloco), ImageButton(widx::close, { kWindowSize.width - 15, kMargin }, { 13, kTitlebarHeight }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Panel(widx::panel, { 0, kTitlebarHeight + kMargin }, { kWindowSize.width, 245 }, WindowColour::secondary), Button(widx::button_1, { kMargin, kTitlebarHeight + kMargin + (0 * (kRowSize + kMargin)) }, { kWindowSize.width / 2, kButtonHeight }, WindowColour::secondary, StringIds::openloco), ImageButton(widx::button_2, { kMargin, kTitlebarHeight + kMargin + (1 * (kRowSize + kMargin)) }, { 24, 24 }, WindowColour::secondary, ImageIds::red_flag, StringIds::tooltip_stop_start), Label(widx::label_1, { kMargin, kTitlebarHeight + kMargin + (2 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, ContentAlign::left, StringIds::openloco), Label(widx::label_2, { kMargin, kTitlebarHeight + kMargin + (3 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, ContentAlign::center, StringIds::openloco), Label(widx::label_3, { kMargin, kTitlebarHeight + kMargin + (4 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, ContentAlign::right, StringIds::openloco), Checkbox(widx::checkbox_1, { kMargin, kTitlebarHeight + kMargin + (5 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, StringIds::openloco), Checkbox(widx::checkbox_2, { kMargin, kTitlebarHeight + kMargin + (6 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, StringIds::openloco), Checkbox(widx::checkbox_3, { kMargin, kTitlebarHeight + kMargin + (7 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, StringIds::openloco), Checkbox(widx::checkbox_4, { kMargin, kTitlebarHeight + kMargin + (8 * (kRowSize + kMargin)) }, { kWindowSize.width - (kMargin * 2), kLabelHeight }, WindowColour::secondary, StringIds::openloco), Tab(widx::tab_1, { kMargin + ((kTabWidth + kMargin) * 0), kTitlebarHeight + kMargin + (9 * (kRowSize + kMargin)) }, { kTabWidth, kTabHeight }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_town), Tab(widx::tab_2, { kMargin + ((kTabWidth + kMargin) * 1), kTitlebarHeight + kMargin + (9 * (kRowSize + kMargin)) }, { kTabWidth, kTabHeight }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_population_graph), Tab(widx::tab_3, { kMargin + ((kTabWidth + kMargin) * 2), kTitlebarHeight + kMargin + (9 * (kRowSize + kMargin)) }, { kTabWidth, kTabHeight }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_town_ratings_each_company) // ); } // 0x0043B26C Window* open() { if (auto* wnd = WindowManager::bringToFront(WindowType::debug); wnd != nullptr) { return wnd; } auto window = WindowManager::createWindowCentred( WindowType::debug, kWindowSize, WindowFlags::none, getEvents()); window->setWidgets(_widgets); // window->disabledWidgets = 1U << widx::tab_3; window->initScrollWidgets(); auto getWidgetById = [&](Window& window, const WidgetId id) -> Widget& { for (auto& widget : window.widgets) { if (widget.id == id) { return widget; } } throw std::runtime_error("Widget not found"); }; auto& chkbox2 = getWidgetById(*window, widx::checkbox_2); chkbox2.activated = true; auto& chkbox3 = getWidgetById(*window, widx::checkbox_3); chkbox3.activated = false; chkbox3.disabled = true; auto& chkbox4 = getWidgetById(*window, widx::checkbox_4); chkbox4.activated = true; chkbox4.disabled = true; const auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowOptionsColour); return window; } // 0x0043B4AF static void onMouseUp(Ui::Window& window, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { const auto& widget = window.widgets[widgetIndex]; switch (widget.id) { case widx::close: WindowManager::close(window.type); break; } } // 0x0043B2E4 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { // Draw widgets. window.draw(drawingCtx); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/DragVehiclePart.cpp ```cpp #include "Graphics/DrawingContext.h" #include "Graphics/RenderTarget.h" #include "Input.h" #include "OpenLoco.h" #include "Ui/ToolTip.h" #include "Ui/Widget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::DragVehiclePart { enum widx { frame }; // 0x00522504 static constexpr auto widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 150, 60 }, WindowColour::primary) ); // TODO: make vehicles versions of these call into this global, ?make Entity::id instead? static loco_global<Vehicles::VehicleBogie*, 0x0113614E> _dragCarComponent; static loco_global<EntityId, 0x01136156> _dragVehicleHead; static const WindowEventList& getEvents(); // 0x004B3B7E void open(Vehicles::Car& car) { WindowManager::close(WindowType::dragVehiclePart); _dragCarComponent = car.front; _dragVehicleHead = car.front->head; WindowManager::invalidate(WindowType::vehicle, enumValue(car.front->head)); uint16_t width = getWidthVehicleInline(car); auto pos = Ui::ToolTip::getTooltipMouseLocation(); pos.y -= 30; pos.x -= width / 2; Ui::Size32 size = { width, 60 }; auto self = WindowManager::createWindow(WindowType::dragVehiclePart, { pos.x, pos.y }, size, WindowFlags::transparent | WindowFlags::stickToFront, getEvents()); self->setWidgets(widgets); self->widgets[widx::frame].right = width - 1; Input::windowPositionBegin(Ui::ToolTip::getTooltipMouseLocation().x, Ui::ToolTip::getTooltipMouseLocation().y, self, widx::frame); } // 0x004B62FE static Ui::CursorId cursor(Window& self, [[maybe_unused]] const WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y, [[maybe_unused]] const Ui::CursorId fallback) { self.height = 0; // Set to zero so that skipped in window find Vehicle::Details::scrollDrag(Input::getScrollLastLocation()); self.height = 60; return CursorId::dragHand; } // 0x004B6271 static void onMove(Window& self, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { const auto height = self.height; self.height = 0; // Set to zero so that skipped in window find Vehicle::Details::scrollDragEnd(Input::getScrollLastLocation()); // Reset the height so that invalidation works correctly self.height = height; WindowManager::close(&self); _dragCarComponent = nullptr; WindowManager::invalidate(WindowType::vehicle, enumValue(*_dragVehicleHead)); } // 0x004B6197 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(self.x, self.y, self.width, self.height)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); Vehicles::Vehicle train(_dragVehicleHead); for (auto& car : train.cars) { if (car.front == _dragCarComponent) { drawVehicleInline(drawingCtx, car, { 0, 19 }, VehicleInlineMode::basic, VehiclePartsToDraw::bogies); drawVehicleInline(drawingCtx, car, { 0, 19 }, VehicleInlineMode::basic, VehiclePartsToDraw::bodies); break; } } drawingCtx.popRenderTarget(); } } static constexpr WindowEventList kEvents = { .cursor = cursor, .onMove = onMove, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/EditKeyboardShortcut.cpp ```cpp #include "Config.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input/Shortcuts.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Engine/Input/ShortcutManager.h> #include <OpenLoco/Interop/Interop.hpp> #include <SDL2/SDL_keyboard.h> using namespace OpenLoco::Interop; using namespace OpenLoco::Input; namespace OpenLoco::Ui::Windows::EditKeyboardShortcut { static constexpr Ui::Size32 kWindowSize = { 280, 72 }; static uint8_t _editingShortcutIndex; static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, kWindowSize, WindowColour::primary), Widgets::Caption({ 1, 1 }, { kWindowSize.width - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::change_keyboard_shortcut), Widgets::ImageButton({ 265, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { kWindowSize.width, 57 }, WindowColour::secondary)); static const WindowEventList& getEvents(); namespace Widx { enum { frame, caption, close, panel, }; } // 0x004BF7B9 Window* open(const uint8_t shortcutIndex) { WindowManager::close(WindowType::editKeyboardShortcut); _editingShortcutIndex = shortcutIndex; auto window = WindowManager::createWindow(WindowType::editKeyboardShortcut, kWindowSize, WindowFlags::none, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); const auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowOptionsColour); return window; } static void editShortcut([[maybe_unused]] const uint32_t charCode, const uint32_t keyCode) { if (keyCode == SDLK_UP) { return; } if (keyCode == SDLK_DOWN) { return; } if (keyCode == SDLK_LEFT) { return; } if (keyCode == SDLK_RIGHT) { return; } if (keyCode == SDLK_NUMLOCKCLEAR) { return; } if (keyCode == SDLK_LGUI) { return; } if (keyCode == SDLK_RGUI) { return; } auto& cfg = Config::get(); // Unbind any shortcuts that may be using the current keycode. for (auto& [id, shortcut] : cfg.shortcuts) { if (shortcut.keyCode == keyCode && shortcut.modifiers == Input::getKeyModifier()) { shortcut.keyCode = 0xFFFFFFFF; shortcut.modifiers = KeyModifier::invalid; } } // Assign this keybinding to the shortcut we're currently rebinding. auto& shortcut = cfg.shortcuts.at(static_cast<Input::Shortcut>(_editingShortcutIndex)); shortcut.keyCode = keyCode; shortcut.modifiers = Input::getKeyModifier(); WindowManager::close(WindowType::editKeyboardShortcut); WindowManager::invalidate(WindowType::keyboardShortcuts); Config::write(); } // 0x004BE8DF static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); FormatArguments args{}; args.push(ShortcutManager::getName(static_cast<Shortcut>(_editingShortcutIndex))); auto point = Ui::Point(self.x + 140, self.y + 32); tr.drawStringCentredWrapped(point, 272, Colour::black, StringIds::change_keyboard_shortcut_desc, args); } // 0x004BE821 static void onMouseUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::close: WindowManager::close(&self); return; } } static bool onKeyUp([[maybe_unused]] Window& self, const uint32_t charCode, const uint32_t keyCode) { editShortcut(charCode, keyCode); return true; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .draw = draw, .keyUp = onKeyUp, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Error.cpp ```cpp #include "Audio/Audio.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringManager.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Widget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::Error { static loco_global<bool, 0x00508F09> _suppressErrorSound; static char _errorText[512]; // 0x009C64B3 static uint16_t _linebreakCount; // 0x009C66B3 static CompanyId _errorCompetitorId; // 0x009C68EC static constexpr auto kMinWidth = 70; static constexpr auto kMaxWidth = 250; static constexpr auto kPadding = 4; static constexpr auto kCompetitorSize = 64; namespace Common { static const WindowEventList& getEvents(); } namespace Error { enum widx { frame, }; static constexpr auto widgets = makeWidgets( Widgets::Panel({ 0, 0 }, { 200, 42 }, WindowColour::primary) ); } namespace ErrorCompetitor { enum widx { frame, innerFrame, }; static constexpr auto widgets = makeWidgets( Widgets::Panel({ 0, 0 }, { 250, 70 }, WindowColour::primary), Widgets::Wt3Widget({ 3, 3 }, { 64, 64 }, WindowColour::secondary) ); } static char* formatErrorString(StringId title, StringId message, FormatArguments args, char* buffer) { char* ptr = buffer; ptr[0] = ControlCodes::Colour::white; ptr++; if (title != StringIds::null) { ptr = StringManager::formatString(ptr, title, args); } if (message != StringIds::null) { if (title != StringIds::null) { *ptr = ControlCodes::newline; ptr++; } StringManager::formatString(ptr, message, args); } return ptr; } static void createErrorWindow(StringId title, StringId message) { WindowManager::close(WindowType::error); char* buffer = _errorText; auto args = FormatArguments::common(); buffer = formatErrorString(title, message, args, buffer); if (buffer != &_errorText[0]) { // How wide is the error string? uint16_t strWidth = Gfx::TextRenderer::getStringWidthNewLined(Gfx::Font::medium_bold, &_errorText[0]); strWidth = std::clamp<uint16_t>(strWidth, kMinWidth, kMaxWidth); // How many linebreaks? { uint16_t breakLineCount = 0; std::tie(strWidth, breakLineCount) = Gfx::TextRenderer::wrapString(Gfx::Font::medium_bold, &_errorText[0], strWidth + kPadding); _linebreakCount = breakLineCount; } // Calculate window dimensions uint16_t width = strWidth + 2 * kPadding; uint16_t height = (_linebreakCount + 1) * 10 + 2 * kPadding; // Add extra spacing for competitor image if (_errorCompetitorId != CompanyId::null) { width += kCompetitorSize + 22; height += kCompetitorSize - 22; } // Calculate frame size uint16_t frameWidth = width - 1; uint16_t frameHeight = height - 1; // Position error message around the cursor auto mousePos = Input::getMouseLocation(); Ui::Point32 windowPosition = Ui::Point32{ mousePos.x, mousePos.y } + Ui::Point32(-width / 2, 26); windowPosition.x = std::clamp<int32_t>(windowPosition.x, 0, Ui::width() - width - 40); windowPosition.y = std::clamp<int32_t>(windowPosition.y, 22, Ui::height() - height - 40); auto error = WindowManager::createWindow( WindowType::error, windowPosition, { width, height }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::flag_7, Common::getEvents()); if (_errorCompetitorId != CompanyId::null) { error->setWidgets(ErrorCompetitor::widgets); } else { error->setWidgets(Error::widgets); } error->setColour(WindowColour::primary, AdvancedColour(Colour::mutedDarkRed).translucent()); error->setColour(WindowColour::secondary, AdvancedColour(Colour::mutedDarkRed).translucent()); error->widgets[Error::widx::frame].right = frameWidth; error->widgets[Error::widx::frame].bottom = frameHeight; error->var_846 = 0; if (!_suppressErrorSound) { int32_t pan = (error->width / 2) + error->x; Audio::playSound(Audio::SoundId::error, pan); } } } // 0x00431A8A void open(StringId title, StringId message) { _errorCompetitorId = CompanyId::null; createErrorWindow(title, message); } void openQuiet(StringId title, StringId message) { _errorCompetitorId = CompanyId::null; _suppressErrorSound = true; createErrorWindow(title, message); _suppressErrorSound = false; } // 0x00431908 void openWithCompetitor(StringId title, StringId message, CompanyId competitorId) { _errorCompetitorId = competitorId; createErrorWindow(title, message); } namespace Common { // 0x00431C05 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); auto tr = Gfx::TextRenderer(drawingCtx); auto colour = AdvancedColour(Colour::white).translucent(); // self.colours[0]; if (_errorCompetitorId == CompanyId::null) { uint16_t xPos = self.x + self.width / 2; uint16_t yPos = self.y + kPadding; tr.drawStringCentredRaw(Point(xPos, yPos), _linebreakCount, colour, &_errorText[0]); } else { auto xPos = self.x + self.widgets[ErrorCompetitor::widx::innerFrame].left; auto yPos = self.y + self.widgets[ErrorCompetitor::widx::innerFrame].top; auto company = CompanyManager::get(_errorCompetitorId); auto companyObj = ObjectManager::get<CompetitorObject>(company->competitorId); auto imageId = companyObj->images[enumValue(company->ownerEmotion)]; imageId = Gfx::recolour(imageId, company->mainColours.primary); imageId++; drawingCtx.drawImage(xPos, yPos, imageId); if (company->jailStatus != 0) { drawingCtx.drawImage(xPos, yPos, ImageIds::owner_jailed); } auto point = Point(self.x + (self.width - kCompetitorSize) / 2 + kCompetitorSize + kPadding, self.y + 20); tr.drawStringCentredRaw(point, _linebreakCount, colour, &_errorText[0]); } } // 0x00431E1B static void onPeriodicUpdate(Ui::Window& self) { self.var_846++; if (self.var_846 >= 7) { WindowManager::close(&self); } } static constexpr WindowEventList kEvents = { .onPeriodicUpdate = onPeriodicUpdate, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/IndustryList.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "Economy/Economy.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Industries/CreateIndustry.h" #include "GameCommands/Industries/RemoveIndustry.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/MapSelection.h" #include "Map/TileManager.h" #include "Objects/CargoObject.h" #include "Objects/IndustryObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Random.h" #include "SceneManager.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include "World/IndustryManager.h" #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::IndustryList { static Core::Prng _placementPrng; // 0x00E0C394 static currency32_t _industryPlacementCost; // 0x00E0C39C static bool _industryGhostPlaced; // 0x00E0C3D9 static World::Pos2 _industryGhostPos; // 0x00E0C3C2 static uint8_t _industryGhostType; // 0x00E0C3DA static IndustryId _industryGhostId; // 0x00E0C3DB static loco_global<IndustryId, 0x00E0C3C9> _industryLastPlacedId; namespace Common { enum widx { frame, caption, close_button, panel, tab_industry_list, tab_new_industry, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 154 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_industries_list), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_fund_new_industries)); } static void refreshIndustryList(Window* self); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); static void prepareDraw(Window& self); static void switchTab(Window& self, WidgetIndex_t widgetIndex); } namespace IndustryList { static constexpr Ui::Size32 kWindowSize = { 759, 197 }; static constexpr Ui::Size kMaxDimensions = { 759, 900 }; static constexpr Ui::Size kMinDimensions = { 192, 100 }; static constexpr uint8_t kRowHeight = 10; enum widx { sort_industry_name = 6, sort_industry_status, sort_industry_production_transported, sort_industry_production_last_month, scrollview, status_bar, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(600, 197, StringIds::title_industries), Widgets::TableHeader({ 4, 44 }, { 199, 11 }, WindowColour::secondary, Widget::kContentNull, StringIds::sort_industry_name), Widgets::TableHeader({ 204, 44 }, { 204, 11 }, WindowColour::secondary, Widget::kContentNull, StringIds::sort_industry_status), Widgets::TableHeader({ 444, 44 }, { 159, 11 }, WindowColour::secondary, Widget::kContentNull, StringIds::sort_industry_production_transported), Widgets::TableHeader({ 603, 44 }, { 159, 11 }, WindowColour::secondary, Widget::kContentNull, StringIds::sort_industry_production_last_month), Widgets::ScrollView({ 3, 56 }, { 593, 125 }, WindowColour::secondary, Scrollbars::vertical), Widgets::Label({ 4, kWindowSize.height - 17 }, { kWindowSize.width, 10 }, WindowColour::secondary, ContentAlign::left, StringIds::black_stringid) ); enum SortMode : uint16_t { Name, Status, ProductionTransported, ProductionLastMonth, }; // 0x00457B94 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; // Reposition header buttons. self.widgets[widx::sort_industry_name].right = std::min(self.width - 4, 203); self.widgets[widx::sort_industry_status].left = std::min(self.width - 4, 204); self.widgets[widx::sort_industry_status].right = std::min(self.width - 4, 443); self.widgets[widx::sort_industry_production_transported].left = std::min(self.width - 4, 444); self.widgets[widx::sort_industry_production_transported].right = std::min(self.width - 4, 603); self.widgets[widx::sort_industry_production_last_month].left = std::min(self.width - 4, 603); self.widgets[widx::sort_industry_production_last_month].right = std::min(self.width - 4, 762); // Set header button captions. self.widgets[widx::sort_industry_name].text = self.sortMode == SortMode::Name ? StringIds::industry_table_header_desc : StringIds::industry_table_header; self.widgets[widx::sort_industry_status].text = self.sortMode == SortMode::Status ? StringIds::industry_table_header_status_desc : StringIds::industry_table_header_status; self.widgets[widx::sort_industry_production_transported].text = self.sortMode == SortMode::ProductionTransported ? StringIds::industry_table_header_production_desc : StringIds::industry_table_header_production; self.widgets[widx::sort_industry_production_last_month].text = self.sortMode == SortMode::ProductionLastMonth ? StringIds::industry_table_header_production_last_month_desc : StringIds::industry_table_header_production_last_month; if (SceneManager::isEditorMode() || SceneManager::isSandboxMode()) { self.widgets[Common::widx::tab_new_industry].tooltip = StringIds::tooltip_build_new_industries; } else { self.widgets[Common::widx::tab_new_industry].tooltip = StringIds::tooltip_fund_new_industries; } // Reposition status bar auto& widget = self.widgets[widx::status_bar]; widget.top = self.height - 12; widget.bottom = self.height - 2; // Set status bar text FormatArguments args{ widget.textArgs }; args.push(self.var_83C == 1 ? StringIds::status_num_industries_singular : StringIds::status_num_industries_plural); args.push(self.var_83C); } // 0x00457CD9 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } // 0x00457EC4 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_industry_list: case Common::widx::tab_new_industry: Common::switchTab(self, widgetIndex); break; case widx::sort_industry_name: case widx::sort_industry_status: case widx::sort_industry_production_transported: case widx::sort_industry_production_last_month: { auto sortMode = widgetIndex - widx::sort_industry_name; if (self.sortMode == sortMode) { return; } self.sortMode = sortMode; self.invalidate(); self.var_83C = 0; self.rowHover = -1; Common::refreshIndustryList(&self); break; } } } // 0x00458172 static void onScrollMouseDown(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentRow = y / kRowHeight; if (currentRow > self.var_83C) { return; } const auto currentIndustry = IndustryId(self.rowInfo[currentRow]); if (currentIndustry == IndustryId::null) { return; } Industry::open(currentIndustry); } // 0x00458140 static void onScrollMouseOver(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { self.flags &= ~(WindowFlags::notScrollView); uint16_t currentRow = y / kRowHeight; int16_t currentIndustry = -1; if (currentRow < self.var_83C) { currentIndustry = self.rowInfo[currentRow]; } self.rowHover = currentIndustry; self.invalidate(); } // 0x00457A52 static bool orderByName(const OpenLoco::Industry& lhs, const OpenLoco::Industry& rhs) { char lhsString[256] = { 0 }; { FormatArguments args{}; args.push(lhs.town); StringManager::formatString(lhsString, lhs.name, args); } char rhsString[256] = { 0 }; { FormatArguments args{}; args.push(rhs.town); StringManager::formatString(rhsString, rhs.name, args); } return strcmp(lhsString, rhsString) < 0; } // 0x00457A9F static bool orderByStatus(OpenLoco::Industry& lhs, OpenLoco::Industry& rhs) { char lhsString[256] = { 0 }; const char* lhsBuffer = StringManager::getString(StringIds::buffer_1250); lhs.getStatusString((char*)lhsBuffer); StringManager::formatString(lhsString, StringIds::buffer_1250); char rhsString[256] = { 0 }; const char* rhsBuffer = StringManager::getString(StringIds::buffer_1250); rhs.getStatusString((char*)rhsBuffer); StringManager::formatString(rhsString, StringIds::buffer_1250); return strcmp(lhsString, rhsString) < 0; } static uint8_t getAverageTransportedCargo(const OpenLoco::Industry& industry) { auto industryObj = ObjectManager::get<IndustryObject>(industry.objectId); uint8_t productionTransported = 0xFFU; if (industryObj->producesCargo()) { productionTransported = industry.producedCargoPercentTransportedPreviousMonth[0]; if (industryObj->producedCargoType[1] != 0xFF) { productionTransported = industry.producedCargoPercentTransportedPreviousMonth[1]; if (industryObj->producedCargoType[0] != 0xFF) { productionTransported += industry.producedCargoPercentTransportedPreviousMonth[0]; productionTransported /= 2; } } } return productionTransported; } // 0x00457AF3 static bool orderByProductionTransported(const OpenLoco::Industry& lhs, const OpenLoco::Industry& rhs) { auto lhsVar = getAverageTransportedCargo(lhs); auto rhsVar = getAverageTransportedCargo(rhs); return rhsVar < lhsVar; } static std::pair<uint32_t, StringId> getProductionLastMonth(const OpenLoco::Industry& industry) { auto industryObj = ObjectManager::get<IndustryObject>(industry.objectId); auto cargoProduction = std::numeric_limits<uint32_t>::max(); StringId unitType = StringIds::empty; if (industryObj->producesCargo()) { auto cargoNumber = 0; for (const auto& producedCargoType : industryObj->producedCargoType) { if (producedCargoType != kCargoTypeNull) { cargoProduction = industry.producedCargoQuantityPreviousMonth[cargoNumber]; auto cargoObj = ObjectManager::get<CargoObject>(producedCargoType); unitType = cargoProduction > 1 ? cargoObj->unitNamePlural : cargoObj->unitNameSingular; break; // Only support one cargo type for now - it seems most (all?) industries only have a single cargo type } cargoNumber++; } } return std::make_pair(cargoProduction, unitType); } static bool orderByProductionLastMonth(const OpenLoco::Industry& lhs, const OpenLoco::Industry& rhs) { return getProductionLastMonth(rhs).first < getProductionLastMonth(lhs).first; } // 0x00457A52, 0x00457A9F, 0x00457AF3 static bool getOrder(const SortMode mode, OpenLoco::Industry& lhs, OpenLoco::Industry& rhs) { switch (mode) { case SortMode::Name: return orderByName(lhs, rhs); case SortMode::Status: return orderByStatus(lhs, rhs); case SortMode::ProductionTransported: return orderByProductionTransported(lhs, rhs); case SortMode::ProductionLastMonth: return orderByProductionLastMonth(lhs, rhs); } return false; } // 0x00457991 static void updateIndustryList(Window* self) { auto chosenIndustry = IndustryId::null; for (auto& industry : IndustryManager::industries()) { if (industry.hasFlags(IndustryFlags::sorted)) { continue; } if (chosenIndustry == IndustryId::null) { chosenIndustry = industry.id(); continue; } if (getOrder(SortMode(self->sortMode), industry, *IndustryManager::get(chosenIndustry))) { chosenIndustry = industry.id(); } } if (chosenIndustry != IndustryId::null) { bool shouldInvalidate = false; IndustryManager::get(chosenIndustry)->flags |= IndustryFlags::sorted; auto ebp = self->rowCount; if (chosenIndustry != IndustryId(self->rowInfo[ebp])) { self->rowInfo[ebp] = enumValue(chosenIndustry); shouldInvalidate = true; } self->rowCount += 1; if (self->rowCount > self->var_83C) { self->var_83C = self->rowCount; shouldInvalidate = true; } if (shouldInvalidate) { self->invalidate(); } } else { if (self->var_83C != self->rowCount) { self->var_83C = self->rowCount; self->invalidate(); } Common::refreshIndustryList(self); } } // 0x004580AE static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::industryList, self.number, self.currentTab + Common::widx::tab_industry_list); // Add three industries every tick. updateIndustryList(&self); updateIndustryList(&self); updateIndustryList(&self); } // 0x00457EE8 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_industry_list); return args; } // 0x00458108 static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = kRowHeight * self.var_83C; } // 0x00457D2A static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 4); drawingCtx.clearSingle(shade); uint16_t yPos = 0; for (uint16_t i = 0; i < self.var_83C; i++) { IndustryId industryId = IndustryId(self.rowInfo[i]); // Skip items outside of view, or irrelevant to the current filter. if (yPos + kRowHeight < rt.y || yPos >= yPos + kRowHeight + rt.height || industryId == IndustryId::null) { yPos += kRowHeight; continue; } StringId text_colour_id = StringIds::black_stringid; // Highlight selection. if (industryId == IndustryId(self.rowHover)) { drawingCtx.drawRect(0, yPos, self.width, kRowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); text_colour_id = StringIds::wcolour2_stringid; } if (industryId == IndustryId::null) { continue; } auto industry = IndustryManager::get(industryId); // Industry Name { FormatArguments args{}; args.push(industry->name); args.push(industry->town); auto point = Point(0, yPos); tr.drawStringLeftClipped(point, 198, Colour::black, text_colour_id, args); } // Industry Status { const char* buffer = StringManager::getString(StringIds::buffer_1250); industry->getStatusString((char*)buffer); FormatArguments args{}; args.push(StringIds::buffer_1250); auto point = Point(200, yPos); tr.drawStringLeftClipped(point, 238, Colour::black, text_colour_id, args); } if (industry->canProduceCargo()) { // Industry Production Delivered { auto productionTransported = getAverageTransportedCargo(*industry); FormatArguments args{}; args.push<uint16_t>(productionTransported); auto point = Point(440, yPos); tr.drawStringLeftClipped(point, 138, Colour::black, StringIds::production_transported_percent, args); } // Industry Production Last Month { auto productionTransported = getProductionLastMonth(*industry); FormatArguments args{}; args.push(productionTransported.second); args.push<uint32_t>(productionTransported.first); auto point = Point(600, yPos); tr.drawStringLeftClipped(point, 138, Colour::black, StringIds::black_stringid, args); } } yPos += kRowHeight; } } // 0x00458113 static Ui::CursorId cursor(Window& self, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, Ui::CursorId fallback) { if (widgetIdx != widx::scrollview) { return fallback; } uint16_t currentIndex = yPos / kRowHeight; if (currentIndex < self.var_83C && self.rowInfo[currentIndex] != -1) { return CursorId::handPointer; } return fallback; } // 0x004580DE static void event_08(Window& self) { self.flags |= WindowFlags::notScrollView; } // 0x004580E6 static void event_09(Window& self) { if (!self.hasFlags(WindowFlags::notScrollView)) { return; } if (self.rowHover == -1) { return; } self.rowHover = -1; self.invalidate(); } // 0x00457FCA static void tabReset(Window& self) { self.invalidate(); self.minWidth = kMinDimensions.width; self.minHeight = kMinDimensions.height; self.maxWidth = kMaxDimensions.width; self.maxHeight = kMaxDimensions.height; self.width = kWindowSize.width; self.height = kWindowSize.height; self.var_83C = 0; self.rowHover = -1; Common::refreshIndustryList(&self); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onUpdate = onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x004577FF Window* open() { auto window = WindowManager::bringToFront(WindowType::industryList, 0); if (window != nullptr) { window->callOnMouseUp(Common::widx::tab_industry_list, window->widgets[Common::widx::tab_industry_list].id); } else { // 0x00457878 auto origin = Ui::Point32(Ui::width() - IndustryList::kWindowSize.width, 30); window = WindowManager::createWindow( WindowType::industryList, origin, IndustryList::kWindowSize, WindowFlags::flag_8, IndustryList::getEvents()); window->number = 0; window->currentTab = 0; window->frameNo = 0; window->sortMode = 0; window->var_83C = 0; window->rowHover = -1; Common::refreshIndustryList(window); WindowManager::moveOtherWindowsDown(*window); window->minWidth = IndustryList::kMinDimensions.width; window->minHeight = IndustryList::kMinDimensions.height; window->maxWidth = IndustryList::kMaxDimensions.width; window->maxHeight = IndustryList::kMaxDimensions.height; window->flags |= WindowFlags::resizable; auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); // 0x00457878 end window->width = IndustryList::kWindowSize.width; window->height = IndustryList::kWindowSize.height; window->invalidate(); window->setWidgets(IndustryList::widgets); window->activatedWidgets = 0; window->holdableWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); } return window; } void reset() { getGameState().lastIndustryOption = 0xFF; } // 0x0045792A void removeIndustry(const IndustryId id) { auto* wnd = WindowManager::find(WindowType::industryList); if (wnd == nullptr) { return; } if (wnd->currentTab != Common::widx::tab_industry_list - Common::widx::tab_industry_list) { return; } for (auto i = 0; i < wnd->var_83C; ++i) { if (static_cast<IndustryId>(wnd->rowInfo[i]) == id) { wnd->rowInfo[i] = enumValue(IndustryId::null); } } } namespace NewIndustries { static constexpr Ui::Size32 kWindowSize = { 578, 172 }; static constexpr uint8_t kRowHeight = 112; enum widx { scrollview = 6, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(577, 171, StringIds::title_fund_new_industries), Widgets::ScrollView({ 3, 45 }, { 549, 111 }, WindowColour::secondary, Scrollbars::vertical) ); // 0x0045819F static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; if (SceneManager::isEditorMode() || SceneManager::isSandboxMode()) { self.widgets[Common::widx::caption].text = StringIds::title_build_new_industries; self.widgets[Common::widx::tab_new_industry].tooltip = StringIds::tooltip_build_new_industries; } else { self.widgets[Common::widx::caption].text = StringIds::title_fund_new_industries; self.widgets[Common::widx::tab_new_industry].tooltip = StringIds::tooltip_fund_new_industries; } } // 0x0045826C static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); if (self.var_83C == 0) { auto point = Point(self.x + 3, self.y + self.height - 13); auto width = self.width - 19; tr.drawStringLeftClipped(point, width, Colour::black, StringIds::no_industry_available); return; } auto industryObjId = self.var_846; if (industryObjId == 0xFFFF) { industryObjId = self.rowHover; if (industryObjId == 0xFFFF) { return; } } auto industryObj = ObjectManager::get<IndustryObject>(industryObjId); auto industryCost = 0; if (self.var_846 == 0xFFFF) { industryCost = _industryPlacementCost; } if ((self.var_846 == 0xFFFF && _industryPlacementCost == static_cast<currency32_t>(0x80000000)) || self.var_846 != 0xFFFF) { industryCost = Economy::getInflationAdjustedCost(industryObj->costFactor, industryObj->costIndex, 3); } auto widthOffset = 0; if (!SceneManager::isEditorMode() && !SceneManager::isSandboxMode()) { FormatArguments args{}; args.push(industryCost); auto point = Point(self.x + 3 + self.width - 19, self.y + self.height - 13); widthOffset = 138; tr.drawStringRight(point, Colour::black, StringIds::build_cost, args); } { FormatArguments args{}; args.push(industryObj->name); auto point = Point(self.x + 3, self.y + self.height - 13); auto width = self.width - 19 - widthOffset; tr.drawStringLeftClipped(point, width, Colour::black, StringIds::black_stringid, args); } } // 0x0045843A static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_industry_list: case Common::widx::tab_new_industry: Common::switchTab(self, widgetIndex); break; } } static int getRowIndex(int16_t x, int16_t y) { return (x / 112) + (y / kRowHeight) * 5; } // 0x00458966 static void onScrollMouseDown(Ui::Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { auto index = getRowIndex(x, y); for (auto i = 0; i < self.var_83C; i++) { auto rowInfo = self.rowInfo[i]; index--; if (index < 0) { self.rowHover = rowInfo; getGameState().lastIndustryOption = rowInfo; int32_t pan = (self.width >> 1) + self.x; Audio::playSound(Audio::SoundId::clickDown, pan); self.expandContentCounter = -16; _industryPlacementCost = 0x80000000; self.invalidate(); break; } } } // 0x00458721 static void onScrollMouseOver(Ui::Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { auto index = getRowIndex(x, y); uint16_t rowInfo = 0xFFFF; auto i = 0; for (; i < self.var_83C; i++) { rowInfo = self.rowInfo[i]; index--; if (index < 0) { break; } } if (i >= self.var_83C) { rowInfo = 0xFFFF; } self.var_846 = rowInfo; self.invalidate(); auto string = StringIds::buffer_337; if (rowInfo == 0xFFFF) { string = StringIds::null; } if (StringManager::getString(StringIds::buffer_337)[0] != '\0') { if (string == self.widgets[widx::scrollview].tooltip) { if (rowInfo == self.var_85C) { return; } } } self.widgets[widx::scrollview].tooltip = string; self.var_85C = rowInfo; ToolTip::closeAndReset(); if (rowInfo == 0xFFFF) { return; } auto industryObj = ObjectManager::get<IndustryObject>(rowInfo); auto buffer = const_cast<char*>(StringManager::getString(string)); char* ptr = (char*)buffer; *ptr = '\0'; *ptr++ = ControlCodes::Font::regular; *ptr++ = ControlCodes::Colour::black; if (industryObj->producesCargo()) { ptr = StringManager::formatString(ptr, StringIds::industry_produces); ptr = industryObj->getProducedCargoString(ptr); if (industryObj->requiresCargo()) { ptr = StringManager::formatString(ptr, StringIds::cargo_comma); } } if (industryObj->requiresCargo()) { ptr = StringManager::formatString(ptr, StringIds::industry_requires); ptr = industryObj->getRequiredCargoString(ptr); } } // 0x004585B8 static void onUpdate(Window& self) { if (!Input::hasFlag(Input::Flags::rightMousePressed)) { auto cursor = Input::getMouseLocation(); auto xPos = cursor.x; auto yPos = cursor.y; Window* activeWindow = WindowManager::findAt(xPos, yPos); if (activeWindow == &self) { xPos -= self.x; xPos += 26; yPos -= self.y; if ((yPos < 42) || (xPos <= self.width)) { xPos = cursor.x; yPos = cursor.y; WidgetIndex_t activeWidget = self.findWidgetAt(xPos, yPos); if (activeWidget > Common::widx::panel) { self.expandContentCounter += 1; if (self.expandContentCounter >= 8) { auto y = std::min(self.scrollAreas[0].contentHeight - 1 + 60, 500); if (Ui::height() < 600) { y = std::min(y, 276); } self.minWidth = kWindowSize.width; self.minHeight = y; self.maxWidth = kWindowSize.width; self.maxHeight = y; } else { if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } } } else { self.expandContentCounter = 0; if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::industryList, self.number, self.currentTab + Common::widx::tab_industry_list); if (!ToolManager::isToolActive(self.type, self.number)) { WindowManager::close(&self); } } // 0x00458455 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_new_industry_list); return args; } // 0x004586EA static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = (4 + self.var_83C) / 5; if (scrollHeight == 0) { scrollHeight += 1; } scrollHeight *= kRowHeight; } // 0x00458352 static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 4); drawingCtx.clearSingle(shade); loco_global<uint16_t, 0x00E0C3C6> _word_E0C3C6; uint16_t xPos = 0; uint16_t yPos = 0; for (uint16_t i = 0; i < self.var_83C; i++) { if (yPos + kRowHeight < rt.y) { xPos += kRowHeight; if (xPos >= kRowHeight * 5) // full row { xPos = 0; yPos += kRowHeight; } continue; } else if (yPos > rt.y + rt.height) { break; } _word_E0C3C6 = 0xFFFF; if (self.rowInfo[i] != self.rowHover) { if (self.rowInfo[i] == self.var_846) { _word_E0C3C6 = AdvancedColour::translucentFlag; drawingCtx.drawRectInset(xPos, yPos, kRowHeight, kRowHeight, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::colourLight); } } else { _word_E0C3C6 = AdvancedColour::translucentFlag | AdvancedColour::outlineFlag; drawingCtx.drawRectInset(xPos, yPos, kRowHeight, kRowHeight, self.getColour(WindowColour::secondary), (Gfx::RectInsetFlags::colourLight | Gfx::RectInsetFlags::borderInset)); } auto industryObj = ObjectManager::get<IndustryObject>(self.rowInfo[i]); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(xPos + 1, yPos + 1, 110, 110)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); industryObj->drawIndustry(drawingCtx, 56, 96); drawingCtx.popRenderTarget(); } xPos += kRowHeight; if (xPos >= kRowHeight * 5) // full row { xPos = 0; yPos += kRowHeight; } } } // 0x00458708 static void event_08(Window& self) { if (self.var_846 != 0xFFFF) { self.var_846 = 0xFFFF; } self.invalidate(); } // 0x00458C09 static void removeIndustryGhost() { if (_industryGhostPlaced) { _industryGhostPlaced = false; GameCommands::IndustryRemovalArgs args; args.industryId = _industryGhostId; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } } // 0x00458BB5 static currency32_t placeIndustryGhost(const GameCommands::IndustryPlacementArgs& placementArgs) { auto res = GameCommands::doCommand(placementArgs, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res == GameCommands::FAILURE) { return res; } _industryGhostPos = placementArgs.pos; _industryGhostType = placementArgs.type; _industryGhostId = _industryLastPlacedId; _industryGhostPlaced = true; return res; } // 0x0045857B static std::optional<GameCommands::IndustryPlacementArgs> getIndustryPlacementArgsFromCursor(const int16_t x, const int16_t y) { auto* industryListWnd = WindowManager::find(WindowType::industryList); if (industryListWnd == nullptr) { return {}; } if (industryListWnd->currentTab != (Common::widx::tab_new_industry - Common::widx::tab_industry_list)) { return {}; } if (industryListWnd->rowHover == -1) { return {}; } const auto pos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); // ax,cx if (!pos) { return {}; } GameCommands::IndustryPlacementArgs args; args.pos = *pos; args.type = industryListWnd->rowHover; // dl args.srand0 = _placementPrng.srand_0(); args.srand1 = _placementPrng.srand_1(); if (SceneManager::isEditorMode()) { args.buildImmediately = true; // bh } return { args }; } // 0x0045848A static void onToolUpdate(Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t x, const int16_t y) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto placementArgs = getIndustryPlacementArgsFromCursor(x, y); if (!placementArgs) { removeIndustryGhost(); return; } // Always show buildings, not scaffolding, for ghost placements. placementArgs->buildImmediately = true; World::setMapSelectionFlags(World::MapSelectionFlags::enable); World::setMapSelectionCorner(MapSelectionType::full); World::setMapSelectionArea(placementArgs->pos, placementArgs->pos); World::mapInvalidateSelectionRect(); if (_industryGhostPlaced) { if (_industryGhostPos == placementArgs->pos && _industryGhostType == placementArgs->type) { return; } } removeIndustryGhost(); auto cost = placeIndustryGhost(*placementArgs); if (cost != _industryPlacementCost) { _industryPlacementCost = cost; self.invalidate(); } } // 0x0045851F static void onToolDown([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t x, const int16_t y) { removeIndustryGhost(); auto placementArgs = getIndustryPlacementArgsFromCursor(x, y); if (placementArgs) { GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } gPrng2().randNext(); _placementPrng = gPrng2(); } // 0x004585AD static void onToolAbort([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { removeIndustryGhost(); Ui::Windows::Main::hideGridlines(); } // 0x0045845F static void onClose(Window& self) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } } // 0x00458B51 static void updateActiveThumb(Window& self) { int32_t scrollWidth = 0, scrollHeight = 0; self.callGetScrollSize(0, scrollWidth, scrollHeight); self.scrollAreas[0].contentHeight = scrollHeight; auto i = 0; for (; i <= self.var_83C; i++) { if (self.rowInfo[i] == self.rowHover) { break; } } if (i >= self.var_83C) { i = 0; } i = (i / 5) * kRowHeight; self.scrollAreas[0].contentOffsetY = i; Ui::ScrollView::updateThumbs(self, widx::scrollview); } // 0x00458AAF static void updateBuildableIndustries(Window& self) { auto industryCount = 0; for (uint16_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::industry); i++) { auto industryObj = ObjectManager::get<IndustryObject>(i); if (industryObj == nullptr) { continue; } if (!SceneManager::isEditorMode() && !SceneManager::isSandboxMode()) { if (!industryObj->hasFlags(IndustryObjectFlags::canBeFoundedByPlayer)) { continue; } if (getCurrentYear() < industryObj->designedYear) { continue; } if (getCurrentYear() > industryObj->obsoleteYear) { continue; } } self.rowInfo[industryCount] = i; industryCount++; } self.var_83C = industryCount; auto rowHover = -1; auto lastIndustryOption = getGameState().lastIndustryOption; if (lastIndustryOption != 0xFF) { for (auto i = 0; i < self.var_83C; i++) { if (lastIndustryOption == self.rowInfo[i]) { rowHover = lastIndustryOption; break; } } } if (rowHover == -1 && self.var_83C != 0) { rowHover = self.rowInfo[0]; } self.rowHover = rowHover; updateActiveThumb(self); } // 0x00457FFE static void tabReset(Window& self) { self.minWidth = NewIndustries::kWindowSize.width; self.minHeight = NewIndustries::kWindowSize.height; self.maxWidth = NewIndustries::kWindowSize.width; self.maxHeight = NewIndustries::kWindowSize.height; ToolManager::toolSet(self, Common::widx::tab_new_industry, CursorId::placeFactory); Input::setFlag(Input::Flags::flag6); Ui::Windows::Main::showGridlines(); _industryGhostPlaced = false; _industryPlacementCost = 0x80000000; self.var_83C = 0; self.rowHover = -1; self.var_846 = 0xFFFFU; updateBuildableIndustries(self); gPrng2().randNext(); _placementPrng = gPrng2(); } // 0x004589E8 static void onResize(Window& self) { self.invalidate(); Ui::Size32 kMinWindowSize = { self.minWidth, self.minHeight }; Ui::Size32 kMaxWindowSize = { self.maxWidth, self.maxHeight }; bool hasResized = self.setSize(kMinWindowSize, kMaxWindowSize); if (hasResized) { updateActiveThumb(self); } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .event_08 = event_08, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; }; static TabInformation tabInformationByTabOffset[] = { { IndustryList::widgets, widx::tab_industry_list, IndustryList::getEvents() }, { NewIndustries::widgets, widx::tab_new_industry, NewIndustries::getEvents() }, }; // 0x00457B94 static void prepareDraw(Window& self) { // Activate the current tab.. self.activatedWidgets &= ~((1ULL << tab_industry_list) | (1ULL << tab_new_industry)); self.activatedWidgets |= (1ULL << tabInformationByTabOffset[self.currentTab].widgetIndex); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; } // 0x00457F27 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_industry_list; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.viewportRemove(0); const auto& tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_industry_list]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); if (self.currentTab == widx::tab_industry_list - widx::tab_industry_list) { IndustryList::tabReset(self); } if (self.currentTab == widx::tab_new_industry - widx::tab_industry_list) { NewIndustries::tabReset(self); } self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x00458A57 void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Industry List Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_industries; Widget::drawTab(self, drawingCtx, imageId, widx::tab_industry_list); } // Fund New Industries Tab { static constexpr uint32_t fundNewIndustriesImageIds[] = { InterfaceSkin::ImageIds::build_industry_frame_0, InterfaceSkin::ImageIds::build_industry_frame_1, InterfaceSkin::ImageIds::build_industry_frame_2, InterfaceSkin::ImageIds::build_industry_frame_3, InterfaceSkin::ImageIds::build_industry_frame_4, InterfaceSkin::ImageIds::build_industry_frame_5, InterfaceSkin::ImageIds::build_industry_frame_6, InterfaceSkin::ImageIds::build_industry_frame_7, InterfaceSkin::ImageIds::build_industry_frame_8, InterfaceSkin::ImageIds::build_industry_frame_9, InterfaceSkin::ImageIds::build_industry_frame_10, InterfaceSkin::ImageIds::build_industry_frame_11, InterfaceSkin::ImageIds::build_industry_frame_12, InterfaceSkin::ImageIds::build_industry_frame_13, InterfaceSkin::ImageIds::build_industry_frame_14, InterfaceSkin::ImageIds::build_industry_frame_15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_new_industry - widx::tab_industry_list) { imageId += fundNewIndustriesImageIds[(self.frameNo / 2) % std::size(fundNewIndustriesImageIds)]; } else { imageId += fundNewIndustriesImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_new_industry); } } // 0x00457964 static void refreshIndustryList(Window* window) { window->rowCount = 0; for (auto& industry : IndustryManager::industries()) { industry.flags &= ~IndustryFlags::sorted; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/IndustryWindow.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Industries/RemoveIndustry.h" #include "GameCommands/Industries/RenameIndustry.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/TileManager.h" #include "Objects/CargoObject.h" #include "Objects/IndustryObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "SceneManager.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include <OpenLoco/Engine/World.hpp> using namespace OpenLoco::GameCommands; namespace OpenLoco::Ui::Windows::Industry { namespace Common { enum widx { frame, caption, close_button, panel, tab_industry, tab_production, tab_production_2, tab_transported, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 95 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_industry), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_production_graph), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_production_graph), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_statistics)); } // Defined at the bottom of this file. static void prepareDraw(Window& self); static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input); static void update(Window& self); static void renameIndustryPrompt(Window& self, WidgetIndex_t widgetIndex); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); static void setDisabledWidgets(Window& self); static void draw(Window& self, Gfx::DrawingContext& drawingCtx); static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id); } namespace Industry { static constexpr Ui::Size32 kWindowSize = { 223, 137 }; static constexpr Ui::Size32 kMinWindowSize = { 192, 137 }; static constexpr Ui::Size32 kMaxWindowSize = { 600, 440 }; enum widx { viewport = 8, status_bar, centre_on_viewport, demolish_industry, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(223, 137, StringIds::title_town), Widgets::Viewport({ 3, 44 }, { 195, 80 }, WindowColour::secondary, Widget::kContentUnk), Widgets::Label({ 3, 115 }, { 195, 21 }, WindowColour::secondary, ContentAlign::center), Widgets::ImageButton({ 0, 0 }, { 24, 24 }, WindowColour::secondary, ImageIds::centre_viewport, StringIds::move_main_view_to_show_this), Widgets::ImageButton({ 198, 44 }, { 24, 24 }, WindowColour::secondary, ImageIds::rubbish_bin, StringIds::demolish_this_industry) ); // 0x00455ADD static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::viewport].right = self.width - 26; self.widgets[widx::viewport].bottom = self.height - 14; self.widgets[widx::status_bar].top = self.height - 12; self.widgets[widx::status_bar].bottom = self.height - 3; self.widgets[widx::status_bar].right = self.width - 14; self.widgets[widx::demolish_industry].right = self.width - 2; self.widgets[widx::demolish_industry].left = self.width - 25; if (SceneManager::isEditorMode() || SceneManager::isSandboxMode()) { self.widgets[widx::demolish_industry].hidden = false; } else { self.widgets[widx::demolish_industry].hidden = true; self.widgets[widx::viewport].right += 22; } self.widgets[widx::centre_on_viewport].right = self.widgets[widx::viewport].right - 1; self.widgets[widx::centre_on_viewport].bottom = self.widgets[widx::viewport].bottom - 1; self.widgets[widx::centre_on_viewport].left = self.widgets[widx::viewport].right - 24; self.widgets[widx::centre_on_viewport].top = self.widgets[widx::viewport].bottom - 24; Widget::leftAlignTabs(self, Common::widx::tab_industry, Common::widx::tab_transported); } // 0x00455C22 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); const char* buffer = StringManager::getString(StringIds::buffer_1250); auto industry = IndustryManager::get(IndustryId(self.number)); industry->getStatusString(const_cast<char*>(buffer)); FormatArguments args{}; args.push(StringIds::buffer_1250); auto widget = &self.widgets[widx::status_bar]; auto point = Point(self.x + widget->left - 1, self.y + widget->top - 1); auto width = widget->width(); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::black_stringid, args); } // 0x00455C86 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameIndustryPrompt(self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_industry: case Common::widx::tab_production: case Common::widx::tab_production_2: case Common::widx::tab_transported: Common::switchTab(self, widgetIndex); break; // 0x00455EA2 case widx::centre_on_viewport: self.viewportCentreMain(); break; // 0x00455E59 case widx::demolish_industry: { GameCommands::IndustryRemovalArgs args; args.industryId = static_cast<IndustryId>(self.number); bool success = GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE; if (!success) { break; } Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); break; } } } static void initViewport(Window& self); // 0x00455F1A static void onResize(Window& self) { self.setSize(kMinWindowSize, kMaxWindowSize); if (self.viewports[0] != nullptr) { uint16_t newWidth = self.width - 30; if (!SceneManager::isEditorMode() && !SceneManager::isSandboxMode()) { newWidth += 22; } uint16_t newHeight = self.height - 59; auto& viewport = self.viewports[0]; if (newWidth != viewport->width || newHeight != viewport->height) { viewport->width = newWidth; viewport->height = newHeight; viewport->viewWidth = newWidth << viewport->zoom; viewport->viewHeight = newHeight << viewport->zoom; self.savedView.clear(); } } initViewport(self); } // 0x00456C36 static void initViewport(Window& self) { if (self.currentTab != Common::widx::tab_industry - Common::widx::tab_industry) { return; } self.callPrepareDraw(); // Figure out the industry's position on the map. auto industry = IndustryManager::get(IndustryId(self.number)); int16_t tileZ = World::TileManager::getHeight({ industry->x, industry->y }).landHeight; // Compute views. SavedView view = { industry->x, industry->y, ZoomLevel::quarter, static_cast<int8_t>(self.viewports[0]->getRotation()), tileZ, }; // view.flags |= (1 << 14); ViewportFlags flags = ViewportFlags::none; if (self.viewports[0] != nullptr) { if (self.savedView == view) { return; } flags = self.viewports[0]->flags; self.viewportRemove(0); } else { if (Config::get().gridlinesOnLandscape) { flags |= ViewportFlags::gridlines_on_landscape; } } self.savedView = view; if (self.viewports[0] == nullptr) { auto widget = &self.widgets[widx::viewport]; auto tile = World::Pos3({ industry->x, industry->y, tileZ }); auto origin = Ui::Point(widget->left + self.x + 1, widget->top + self.y + 1); auto size = Ui::Size(widget->width() - 2, widget->height() - 2); ViewportManager::create(&self, 0, origin, size, self.savedView.zoomLevel, tile); self.invalidate(); self.flags |= WindowFlags::viewportNoScrolling; } if (self.viewports[0] != nullptr) { self.viewports[0]->flags = flags; self.invalidate(); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .viewportRotate = initViewport, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x00456D2D Window* open(IndustryId industryId) { auto window = WindowManager::bringToFront(WindowType::industry, enumValue(industryId)); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); } window = WindowManager::bringToFront(WindowType::industry, enumValue(industryId)); } if (window == nullptr) { // 0x00456DBC start const WindowFlags newFlags = WindowFlags::flag_8 | WindowFlags::resizable; window = WindowManager::createWindow(WindowType::industry, Industry::kWindowSize, newFlags, Industry::getEvents()); window->number = enumValue(industryId); window->minWidth = 192; window->minHeight = 137; window->maxWidth = 600; window->maxHeight = 440; auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); } // 0x00456DBC end window->savedView.clear(); } window->currentTab = Common::widx::tab_industry - Common::widx::tab_industry; window->invalidate(); window->setWidgets(Industry::widgets); window->holdableWidgets = 0; window->eventHandlers = &Industry::getEvents(); window->activatedWidgets = 0; Common::setDisabledWidgets(*window); window->initScrollWidgets(); Industry::initViewport(*window); return window; } namespace Production { static constexpr Ui::Size32 kMinWindowSize = { 299, 282 }; static constexpr Ui::Size32 kMaxWindowSize = { 299, 337 }; // 0x00455FD9 static void prepareDraw(Window& self) { Common::prepareDraw(self); Widget::leftAlignTabs(self, Common::widx::tab_industry, Common::widx::tab_transported); } // 0x0045654F static void onResize(Window& self) { { self.setSize(kMinWindowSize, kMaxWindowSize); } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Production2 { static constexpr Ui::Size32 kMinWindowSize = { 299, 282 }; static constexpr Ui::Size32 kMaxWindowSize = { 299, 337 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(222, 136, StringIds::title_industry_monthly_production) ); // 0x0045626F static void prepareDraw(Window& self) { Common::prepareDraw(self); Widget::leftAlignTabs(self, Common::widx::tab_industry, Common::widx::tab_transported); } // 0x004565FF static void onResize(Window& self) { { self.setSize(kMinWindowSize, kMaxWindowSize); } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Transported { static constexpr Ui::Size32 kWindowSize = { 300, 127 }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(300, 126, StringIds::title_statistics) ); // 0x00456665 static void prepareDraw(Window& self) { Common::prepareDraw(self); Widget::leftAlignTabs(self, Common::widx::tab_industry, Common::widx::tab_transported); } // 0x00456705 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto industry = IndustryManager::get(IndustryId(self.number)); const auto* industryObj = industry->getObject(); auto origin = Point(self.x + 3, self.y + 45); // Draw Last Months received cargo stats if (industry->canReceiveCargo()) { tr.drawStringLeft(origin, Colour::black, StringIds::received_cargo); origin.x += 4; origin.y += 10; auto cargoNumber = 0; for (const auto& receivedCargoType : industryObj->requiredCargoType) { if (receivedCargoType != kCargoTypeNull) { auto cargoObj = ObjectManager::get<CargoObject>(receivedCargoType); FormatArguments args{}; if (industry->receivedCargoQuantityPreviousMonth[cargoNumber] == 1) { args.push(cargoObj->unitNameSingular); } else { args.push(cargoObj->unitNamePlural); } args.push<uint32_t>(industry->receivedCargoQuantityPreviousMonth[cargoNumber]); origin = tr.drawStringLeftWrapped(origin, 290, Colour::black, StringIds::black_stringid, args); } cargoNumber++; } origin.y += 4; origin.x -= 4; } // Draw Last Months produced cargo stats if (industry->canProduceCargo()) { tr.drawStringLeft(origin, Colour::black, StringIds::produced_cargo); origin.y += 10; origin.x += 4; auto cargoNumber = 0; for (const auto& producedCargoType : industryObj->producedCargoType) { if (producedCargoType != kCargoTypeNull) { auto cargoObj = ObjectManager::get<CargoObject>(producedCargoType); FormatArguments args{}; if (industry->producedCargoQuantityPreviousMonth[cargoNumber] == 1) { args.push(cargoObj->unitNameSingular); } else { args.push(cargoObj->unitNamePlural); } args.push<uint32_t>(industry->producedCargoQuantityPreviousMonth[cargoNumber]); args.push<uint16_t>(industry->producedCargoPercentTransportedPreviousMonth[cargoNumber]); origin = tr.drawStringLeftWrapped(origin, 290, Colour::black, StringIds::transported_cargo, args); } cargoNumber++; } } } // 0x004569C2 static void onResize(Window& self) { { self.setSize(kWindowSize, kWindowSize); } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; }; static TabInformation tabInformationByTabOffset[] = { { Industry::widgets, widx::tab_industry, Industry::getEvents() }, { Production2::widgets, widx::tab_production, Production::getEvents() }, { Production2::widgets, widx::tab_production_2, Production2::getEvents() }, { Transported::widgets, widx::tab_transported, Transported::getEvents() } }; static void setDisabledWidgets(Window& self) { auto industryObj = ObjectManager::get<IndustryObject>(IndustryManager::get(IndustryId(self.number))->objectId); auto disabledWidgets = 0; if (industryObj->producedCargoType[0] == kCargoTypeNull) { disabledWidgets |= (1 << Common::widx::tab_production); } if (industryObj->producedCargoType[1] == kCargoTypeNull) { disabledWidgets |= (1 << Common::widx::tab_production_2); } self.disabledWidgets = disabledWidgets; } // 0x00456079 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); // Draw Units of Cargo sub title const auto industry = IndustryManager::get(IndustryId(self.number)); const auto industryObj = ObjectManager::get<IndustryObject>(industry->objectId); const auto cargoObj = ObjectManager::get<CargoObject>(industryObj->producedCargoType[0]); { FormatArguments args{}; args.push(cargoObj->unitsAndCargoName); auto point = Point(self.x + 2, self.y - 24 + 68); tr.drawStringLeft(point, Colour::black, StringIds::production_graph_label, args); } // Draw Y label and grid lines. const uint16_t graphBottom = self.y + self.height - 7; int32_t yTick = 0; for (int16_t yPos = graphBottom; yPos >= self.y + 68; yPos -= 20) { FormatArguments args{}; args.push(yTick); drawingCtx.drawRect(self.x + 41, yPos, 239, 1, Colours::getShade(self.getColour(WindowColour::secondary).c(), 4), Gfx::RectFlags::none); auto point = Point(self.x + 39, yPos - 6); tr.drawStringRight(point, Colour::black, StringIds::population_graph_people, args); yTick += 1000; } MonthId month = getCurrentMonth(); int16_t year = getCurrentYear(); int8_t yearSkip = 0; // This is either 0 or 1 depending on selected tab // used to select the correct history const uint8_t productionTabWidx = self.currentTab + widx::tab_industry; const uint8_t productionNum = productionTabWidx - widx::tab_production; for (uint8_t i = industry->producedCargoMonthlyHistorySize[productionNum] - 1; i > 0; i--) { const uint16_t xPos = self.x + 41 + i; const uint16_t yPos = self.y + 56; // Draw horizontal year and vertical grid lines. if (month == MonthId::january) { if (yearSkip == 0) { FormatArguments args{}; args.push(year); auto point = Point(xPos, yPos); tr.drawStringCentred(point, Colour::black, StringIds::population_graph_year, args); } drawingCtx.drawRect(xPos, yPos + 11, 1, self.height - 74, Colours::getShade(self.getColour(WindowColour::secondary).c(), 4), Gfx::RectFlags::none); } const auto history = productionTabWidx == widx::tab_production ? industry->producedCargoMonthlyHistory1 : industry->producedCargoMonthlyHistory2; // Draw production graph const uint16_t yPos1 = graphBottom - history[i]; const uint16_t yPos2 = graphBottom - history[i + 1]; // Do not draw current segment yet; it may be zeroed. if (i < industry->producedCargoMonthlyHistorySize[productionNum] - 1) { if (yPos1 <= graphBottom) { if (yPos2 <= graphBottom) { drawingCtx.drawLine(Ui::Point(xPos, yPos1), Ui::Point(xPos + 1, yPos2), Colours::getShade(self.getColour(WindowColour::secondary).c(), 7)); } } } if (month == MonthId::january) { month = MonthId::december; year--; yearSkip++; if (yearSkip >= 3) { yearSkip = 0; } } else { month = MonthId(static_cast<int8_t>(month) - 1); } } } // 0x004565B5, 0x00456505 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameIndustryPrompt(self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_industry: case Common::widx::tab_production: case Common::widx::tab_production_2: case Common::widx::tab_transported: Common::switchTab(self, widgetIndex); break; } } static void prepareDraw(Window& self) { // Activate the current tab. self.activatedWidgets &= ~((1ULL << widx::tab_industry) | (1ULL << widx::tab_production) | (1ULL << widx::tab_production_2) | (1ULL << widx::tab_transported)); widx widgetIndex = tabInformationByTabOffset[self.currentTab].widgetIndex; self.activatedWidgets |= (1ULL << widgetIndex); // Put industry name in place. auto industry = IndustryManager::get(IndustryId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(industry->name); args.push(industry->town); // Resize common widgets. self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; } // 0x00455CBC static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget != Common::widx::caption) { return; } if (strlen(input) == 0) { return; } GameCommands::setErrorTitle(StringIds::error_cant_rename_industry); GameCommands::RenameIndustryArgs args{}; args.industryId = IndustryId(self.number); args.nameBufferIndex = 1; std::memcpy(args.buffer, input, 36); GameCommands::doCommand(args, GameCommands::Flags::apply); args.nameBufferIndex = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.nameBufferIndex = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); } static void update(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidate(WindowType::industry, self.number); } // 0x00455D81 static void renameIndustryPrompt(Window& self, WidgetIndex_t widgetIndex) { auto industry = IndustryManager::get(IndustryId(self.number)); if (!SceneManager::isEditorMode() && !SceneManager::isSandboxMode()) { if (!industry->hasFlags(IndustryFlags::flag_04)) { return; } if (!CompanyManager::isPlayerCompany(industry->owner)) { return; } } auto args = FormatArguments::common(); args.push<int64_t>(0); args.push(industry->name); args.push(industry->town); TextInput::openTextInput(&self, StringIds::title_industry_name, StringIds::prompt_enter_new_industry_name, industry->name, widgetIndex, &industry->town); } // 0x00455CC7 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } TextInput::sub_4CE6C9(self.type, self.number); self.currentTab = widgetIndex - widx::tab_industry; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.var_85C = -1; self.viewportRemove(0); auto tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_industry]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); Common::setDisabledWidgets(self); self.invalidate(); self.setSize(Industry::kWindowSize); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } static void drawProductionTab(Window& self, Gfx::DrawingContext& drawingCtx, uint8_t productionTabNumber) { static constexpr uint32_t productionTabImageIds[] = { InterfaceSkin::ImageIds::tab_production_frame0, InterfaceSkin::ImageIds::tab_production_frame1, InterfaceSkin::ImageIds::tab_production_frame2, InterfaceSkin::ImageIds::tab_production_frame3, InterfaceSkin::ImageIds::tab_production_frame4, InterfaceSkin::ImageIds::tab_production_frame5, InterfaceSkin::ImageIds::tab_production_frame6, InterfaceSkin::ImageIds::tab_production_frame7, }; auto industry = IndustryManager::get(IndustryId(self.number)); auto industryObj = ObjectManager::get<IndustryObject>(industry->objectId); auto skin = ObjectManager::get<InterfaceSkinObject>(); static constexpr uint32_t productionTabIds[] = { widx::tab_production, widx::tab_production_2, }; auto tab = productionTabIds[productionTabNumber]; uint32_t imageId = 0xFFFFFFFF; auto widget = self.widgets[tab]; if (industryObj->producedCargoType[productionTabNumber] != kCargoTypeNull) { imageId = Gfx::recolour(skin->img, self.getColour(WindowColour::secondary).c()); if (self.currentTab == tab - widx::tab_industry) { imageId += productionTabImageIds[(self.frameNo / 4) % std::size(productionTabImageIds)]; } else { imageId += productionTabImageIds[0]; } auto xPos = widget.left + self.x; auto yPos = widget.top + self.y; drawingCtx.drawImage(xPos, yPos, imageId); auto caroObj = ObjectManager::get<CargoObject>(industryObj->producedCargoType[productionTabNumber]); drawingCtx.drawImage(xPos + 18, yPos + 14, caroObj->unitInlineSprite); Widget::drawTab(self, drawingCtx, Widget::kContentUnk, tab); } } // 0x00456A98 static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Industry tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_industries; Widget::drawTab(self, drawingCtx, imageId, widx::tab_industry); } // Production Tab { drawProductionTab(self, drawingCtx, 0); } // 2nd Production Tab { drawProductionTab(self, drawingCtx, 1); } // Transported Tab { static constexpr uint32_t transportedTabImageIds[] = { InterfaceSkin::ImageIds::tab_transported_frame0, InterfaceSkin::ImageIds::tab_transported_frame1, InterfaceSkin::ImageIds::tab_transported_frame2, InterfaceSkin::ImageIds::tab_transported_frame3, InterfaceSkin::ImageIds::tab_transported_frame4, InterfaceSkin::ImageIds::tab_transported_frame5, InterfaceSkin::ImageIds::tab_transported_frame6, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_transported - widx::tab_industry) { imageId += transportedTabImageIds[(self.frameNo / 4) % std::size(transportedTabImageIds)]; } else { imageId += transportedTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_transported); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/KeyboardShortcuts.cpp ```cpp #include "Config.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Engine/Input/ShortcutManager.h> #include <SDL2/SDL.h> #include <unordered_map> using namespace OpenLoco::Input; namespace OpenLoco::Ui::Windows::KeyboardShortcuts { static constexpr int kRowHeight = 10; // CJK: 13 static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 360, 238 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 358, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::keyboard_shortcuts), Widgets::ImageButton({ 345, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 360, 223 }, WindowColour::secondary), Widgets::ScrollView({ 4, 19 }, { 352, 202 }, WindowColour::secondary, Scrollbars::vertical, StringIds::keyboard_shortcut_list_tip), Widgets::Button({ 4, 223 }, { 150, 12 }, WindowColour::secondary, StringIds::reset_keys, StringIds::reset_keys_tip) ); namespace Widx { enum { frame, caption, close_button, panel, list, reset_keys_btn, }; } static void resetShortcuts(Window* self); static const WindowEventList& getEvents(); // 0x004BE6C7 Window* open() { Window* window; window = WindowManager::bringToFront(WindowType::keyboardShortcuts, 0); if (window != nullptr) { return window; } // 0x004BF833 (create_options_window) window = WindowManager::createWindowCentred(WindowType::keyboardShortcuts, { 360, 238 }, WindowFlags::none, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowOptionsColour); window->rowCount = static_cast<uint16_t>(ShortcutManager::getList().size()); window->rowHover = -1; return window; } // 0x004BE726 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets. self.draw(drawingCtx); } static void getBindingString(uint32_t keyCode, char* buffer, const size_t bufferLength) { static const std::unordered_map<uint32_t, StringId> keysToString = { { { SDLK_BACKSPACE, StringIds::keyboard_backspace }, { SDLK_TAB, StringIds::keyboard_tab }, { SDLK_RETURN, StringIds::keyboard_return }, { SDLK_PAUSE, StringIds::keyboard_pause }, { SDLK_CAPSLOCK, StringIds::keyboard_caps }, { SDLK_ESCAPE, StringIds::keyboard_escape }, { SDLK_SPACE, StringIds::keyboard_spacebar }, { SDLK_PAGEUP, StringIds::keyboard_pageup }, { SDLK_PAGEDOWN, StringIds::keyboard_pagedown }, { SDLK_END, StringIds::keyboard_end }, { SDLK_HOME, StringIds::keyboard_home }, { SDLK_LEFT, StringIds::keyboard_left }, { SDLK_UP, StringIds::keyboard_up }, { SDLK_RIGHT, StringIds::keyboard_right }, { SDLK_DOWN, StringIds::keyboard_down }, { SDLK_INSERT, StringIds::keyboard_insert }, { SDLK_DELETE, StringIds::keyboard_delete }, { SDLK_KP_1, StringIds::keyboard_numpad_1 }, { SDLK_KP_2, StringIds::keyboard_numpad_2 }, { SDLK_KP_3, StringIds::keyboard_numpad_3 }, { SDLK_KP_4, StringIds::keyboard_numpad_4 }, { SDLK_KP_5, StringIds::keyboard_numpad_5 }, { SDLK_KP_6, StringIds::keyboard_numpad_6 }, { SDLK_KP_7, StringIds::keyboard_numpad_7 }, { SDLK_KP_8, StringIds::keyboard_numpad_8 }, { SDLK_KP_9, StringIds::keyboard_numpad_9 }, { SDLK_KP_0, StringIds::keyboard_numpad_0 }, { SDLK_KP_DIVIDE, StringIds::keyboard_numpad_divide }, { SDLK_KP_ENTER, StringIds::keyboard_numpad_enter }, { SDLK_KP_MINUS, StringIds::keyboard_numpad_minus }, { SDLK_KP_MULTIPLY, StringIds::keyboard_numpad_multiply }, { SDLK_KP_PERIOD, StringIds::keyboard_numpad_period }, { SDLK_KP_PLUS, StringIds::keyboard_numpad_plus }, { SDLK_NUMLOCKCLEAR, StringIds::keyboard_numlock }, { SDLK_SCROLLLOCK, StringIds::keyboard_scroll }, } }; auto match = keysToString.find(keyCode); if (match != keysToString.end()) { StringManager::formatString(buffer, match->second); } else { const char* sdlBuffer = SDL_GetKeyName(keyCode); strncpy(buffer, sdlBuffer, bufferLength - 1); } } // 0x004BE72C static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto colour = self.getColour(WindowColour::secondary).c(); auto shade = Colours::getShade(colour, 4); drawingCtx.clearSingle(shade); const auto& shortcutDefs = ShortcutManager::getList(); const auto& shortcuts = Config::get().shortcuts; auto yPos = 0; for (auto i = 0; i < self.rowCount; i++) { if (yPos + kRowHeight < rt.y) { yPos += kRowHeight; continue; } else if (yPos > rt.y + rt.height) { break; } StringId format = StringIds::black_stringid; if (i == self.rowHover) { drawingCtx.drawRect(0, yPos, 800, kRowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); format = StringIds::wcolour2_stringid; } auto modifierStringId = StringIds::empty; auto baseStringId = StringIds::empty; char buffer[128]{}; const auto& def = shortcutDefs[i]; auto& shortcut = shortcuts.at(def.id); if (shortcut.keyCode != 0xFFFFFFFF && shortcut.modifiers != KeyModifier::invalid) { if ((shortcut.modifiers & KeyModifier::shift) == KeyModifier::shift) { modifierStringId = StringIds::keyboard_shortcut_modifier_shift; } else if ((shortcut.modifiers & KeyModifier::control) == KeyModifier::control) { modifierStringId = StringIds::keyboard_shortcut_modifier_ctrl; } baseStringId = StringIds::stringptr; getBindingString(shortcut.keyCode, buffer, std::size(buffer)); } FormatArguments formatter{}; formatter.push(StringIds::keyboard_shortcut_list_format); formatter.push(ShortcutManager::getName(static_cast<Shortcut>(i))); formatter.push(modifierStringId); formatter.push(baseStringId); formatter.push(buffer); auto point = Point(0, yPos - 1); tr.drawStringLeft(point, Colour::black, format, formatter); yPos += kRowHeight; } } // 0x004BE821 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::close_button: WindowManager::close(&self); return; case Widx::reset_keys_btn: resetShortcuts(&self); return; } } // 0x004BE832 static void resetShortcuts(Window* self) { Config::resetShortcuts(); self->invalidate(); } // 0x004BE844 static std::optional<FormatArguments> tooltip(Window&, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_list); return args; } // 0x004BE84E static void getScrollSize(Ui::Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = self.rowCount * kRowHeight; } // 0x004BE853 static void onScrollMouseOver(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto row = y / kRowHeight; if (row >= self.rowCount) { return; } if (row != self.rowHover) { self.rowHover = row; self.invalidate(); } } // 0x004BE87B static void onScrollMouseDown(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto row = y / kRowHeight; if (row >= self.rowCount) { return; } EditKeyboardShortcut::open(row); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/LandscapeGeneration.cpp ```cpp #include "Audio/Audio.h" #include "Game.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/Conversion.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/MapGenerator/MapGenerator.h" #include "Objects/HillShapesObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/WaterObject.h" #include "Scenario.h" #include "ScenarioOptions.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/GroupBoxWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/StepperWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include "World/IndustryManager.h" #include "World/TownManager.h" #include <OpenLoco/Diagnostics/Logging.h> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Diagnostics; using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::LandscapeGeneration { static constexpr Ui::Size32 kWindowSize = { 366, 217 }; static constexpr Ui::Size32 kLandTabSize = { 366, 252 }; static constexpr uint8_t kRowHeight = 22; // CJK: 22 static constexpr size_t kMaxLandObjects = ObjectManager::getMaxObjects(ObjectType::land); namespace Common { enum widx { frame = 0, caption = 1, close_button = 2, panel = 3, tab_options, tab_land, tab_water, tab_forests, tab_towns, tab_industries, generate_now, }; enum class ResetLandscapeMode { generate_now = 0, use_random_landscape = 1, }; static constexpr auto makeCommonWidgets(int32_t frame_height, StringId window_caption_id) { return makeWidgets( Widgets::Frame({ 0, 0 }, { 366, frame_height }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 364, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, window_caption_id), Widgets::ImageButton({ 351, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 366, 175 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_landscape_generation_options), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_landscape_generation_land), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_landscape_generation_water), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_landscape_generation_forests), Widgets::Tab({ 127, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_landscape_generation_towns), Widgets::Tab({ 158, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_landscape_generation_industries), Widgets::Button({ 196, frame_height - 17 }, { 160, 12 }, WindowColour::secondary, StringIds::button_generate_landscape, StringIds::tooltip_generate_random_landscape)); } // Defined at the bottom of this file. static void switchTabWidgets(Window* window); static void switchTab(Window& window, WidgetIndex_t widgetIndex); static void confirmResetLandscape(ResetLandscapeMode promptType) { if (Scenario::getOptions().madeAnyChanges) { // 'Are you sure?' confirmation prompt StringId titleId; FormatArguments args{}; if (promptType == ResetLandscapeMode::generate_now) { titleId = StringIds::title_generate_new_landscape; args.push(StringIds::prompt_confirm_generate_landscape); } else { titleId = StringIds::title_random_landscape_option; args.push(StringIds::prompt_confirm_random_landscape); } if (!Windows::PromptOkCancel::open(titleId, StringIds::stringid, args, StringIds::label_ok)) { return; } } // Reset the landscape if (promptType == ResetLandscapeMode::generate_now) { Scenario::generateLandscape(); } else { Scenario::eraseLandscape(); } } static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close_button: WindowManager::close(&self); break; case widx::tab_options: case widx::tab_land: case widx::tab_water: case widx::tab_forests: case widx::tab_towns: case widx::tab_industries: switchTab(self, widgetIndex); break; case widx::generate_now: confirmResetLandscape(ResetLandscapeMode::generate_now); break; } } // 0x0043ECA4 static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Options tab { static constexpr uint32_t optionTabImageIds[] = { InterfaceSkin::ImageIds::tab_cogs_frame0, InterfaceSkin::ImageIds::tab_cogs_frame1, InterfaceSkin::ImageIds::tab_cogs_frame2, InterfaceSkin::ImageIds::tab_cogs_frame3, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_options - widx::tab_options) { imageId += optionTabImageIds[(self.frameNo / 2) % std::size(optionTabImageIds)]; } else { imageId += optionTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_options); } // Land tab { auto land = ObjectManager::get<LandObject>(getGameState().lastLandOption); const uint32_t imageId = land->mapPixelImage + OpenLoco::Land::ImageIds::toolbar_terraform_land; Widget::drawTab(self, drawingCtx, imageId, widx::tab_land); } // Water tab { const auto waterObj = ObjectManager::get<WaterObject>(); uint32_t imageId = waterObj->image + OpenLoco::Water::ImageIds::kToolbarTerraformWater; if (self.currentTab == widx::tab_water - widx::tab_options) { imageId += (self.frameNo / 2) % 16; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_water); } // Forest tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::toolbar_menu_plant_trees; Widget::drawTab(self, drawingCtx, imageId, widx::tab_forests); } // Towns tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::toolbar_menu_towns; Widget::drawTab(self, drawingCtx, imageId, widx::tab_towns); } // Industries tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::toolbar_menu_industries; Widget::drawTab(self, drawingCtx, imageId, widx::tab_industries); } } static void draw(Window& window, Gfx::DrawingContext& drawingCtx) { window.draw(drawingCtx); drawTabs(window, drawingCtx); } static void prepareDraw(Window& window) { window.widgets[widx::frame].right = window.width - 1; window.widgets[widx::frame].bottom = window.height - 1; window.widgets[widx::panel].right = window.width - 1; window.widgets[widx::panel].bottom = window.height - 1; window.widgets[widx::caption].right = window.width - 2; window.widgets[widx::close_button].left = window.width - 15; window.widgets[widx::close_button].right = window.width - 3; auto& options = Scenario::getOptions(); if (options.generator == Scenario::LandGeneratorType::PngHeightMap) { if (World::MapGenerator::getPngHeightmapPath().empty()) { window.disabledWidgets |= (1 << widx::generate_now); } else { window.disabledWidgets &= ~(1 << widx::generate_now); } } else if ((options.scenarioFlags & Scenario::ScenarioFlags::landscapeGenerationDone) == Scenario::ScenarioFlags::none) { window.disabledWidgets |= (1 << widx::generate_now); } else { window.disabledWidgets &= ~(1 << widx::generate_now); } } static void update(Window& window) { window.frameNo++; window.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::landscapeGeneration, window.number, window.currentTab + widx::tab_options); } } namespace Options { enum widx { groupGeneral = Common::widx::generate_now + 1, start_year_label, start_year, start_year_down, start_year_up, heightMapBoxLabel, heightMapBox, heightMapDropdown, groupGenerator, hillObjectLabel, change_heightmap_btn, terrainSmoothingLabel, terrainSmoothingNum, terrainSmoothingNumDown, terrainSmoothingNumUp, generate_when_game_starts, heightmapFileLabel, browseHeightmapFile, }; // clang-format off const uint64_t holdable_widgets = (1 << widx::start_year_up) | (1 << widx::start_year_down) | (1 << widx::terrainSmoothingNumUp) | (1 << widx::terrainSmoothingNumDown); // clang-format on static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_landscape_generation_options), // General options Widgets::GroupBox({ 4, 50 }, { 358, 50 }, WindowColour::secondary, StringIds::landscapeOptionsGroupGeneral), Widgets::Label({ 10, 65 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::start_year), Widgets::stepperWidgets({ 256, 65 }, { 100, 12 }, WindowColour::secondary, StringIds::start_year_value), Widgets::Label({ 10, 81 }, { 160, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::height_map_source), Widgets::dropdownWidgets({ 176, 81 }, { 180, 12 }, WindowColour::secondary), // Generator options Widgets::GroupBox({ 4, 105 }, { 358, 50 }, WindowColour::secondary, StringIds::landscapeOptionsGroupGenerator), Widgets::Label({ 10, 120 }, { 260, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::landscapeOptionsCurrentHillObject), Widgets::Button({ 280, 120 }, { 75, 12 }, WindowColour::secondary, StringIds::change), Widgets::Label({ 10, 120 }, { 260, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::landscapeOptionsSmoothingPasses), Widgets::stepperWidgets({ 256, 120 }, { 100, 12 }, WindowColour::secondary, StringIds::uint16_raw), Widgets::Checkbox({ 10, 136 }, { 346, 12 }, WindowColour::secondary, StringIds::label_generate_random_landscape_when_game_starts, StringIds::tooltip_generate_random_landscape_when_game_starts), // PNG browser Widgets::Label({ 10, 120 }, { 260, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::currentHeightmapFile), Widgets::Button({ 280, 120 }, { 75, 12 }, WindowColour::secondary, StringIds::button_browse) ); static constexpr StringId generatorIds[] = { StringIds::generator_original, StringIds::generator_simplex, StringIds::generator_png_heightmap, }; // TODO: static memory for state is a bit hacky static std::string _pngFilename{}; // 0x0043DB76 static void prepareDraw(Window& self) { Common::prepareDraw(self); auto& options = Scenario::getOptions(); // Start year info { auto args = FormatArguments(self.widgets[widx::start_year].textArgs); args.push<uint16_t>(options.scenarioStartYear); } self.widgets[widx::heightMapBox].text = generatorIds[enumValue(options.generator)]; bool isOriginal = options.generator == Scenario::LandGeneratorType::Original; bool isSimplex = options.generator == Scenario::LandGeneratorType::Simplex; bool isPngFile = options.generator == Scenario::LandGeneratorType::PngHeightMap; // Hide widgets depending on active generator self.widgets[widx::hillObjectLabel].hidden = !isOriginal; self.widgets[widx::change_heightmap_btn].hidden = !isOriginal; self.widgets[widx::terrainSmoothingLabel].hidden = !isSimplex; self.widgets[widx::terrainSmoothingNum].hidden = !isSimplex; self.widgets[widx::terrainSmoothingNumUp].hidden = !isSimplex; self.widgets[widx::terrainSmoothingNumDown].hidden = !isSimplex; self.widgets[widx::heightmapFileLabel].hidden = !isPngFile; self.widgets[widx::browseHeightmapFile].hidden = !isPngFile; if (isOriginal) { // Prepare object name auto& widget = self.widgets[widx::hillObjectLabel]; FormatArguments args{ widget.textArgs }; auto* obj = ObjectManager::get<HillShapesObject>(); args.push(obj->name); self.disabledWidgets &= ~(1 << widx::change_heightmap_btn); self.disabledWidgets |= ((1 << widx::terrainSmoothingNum) | (1 << widx::terrainSmoothingNumUp) | (1 << widx::terrainSmoothingNumDown)); self.disabledWidgets |= (1 << widx::browseHeightmapFile); } else if (isSimplex) { // Prepare value auto& widget = self.widgets[widx::terrainSmoothingNum]; FormatArguments args{ widget.textArgs }; args.push<uint16_t>(options.numTerrainSmoothingPasses); self.disabledWidgets |= (1 << widx::change_heightmap_btn); self.disabledWidgets &= ~((1 << widx::terrainSmoothingNum) | (1 << widx::terrainSmoothingNumUp) | (1 << widx::terrainSmoothingNumDown)); self.disabledWidgets |= (1 << widx::browseHeightmapFile); } else if (isPngFile) { // Prepare filename label auto path = World::MapGenerator::getPngHeightmapPath(); auto filename = path.filename().make_preferred().u8string(); auto& widget = self.widgets[widx::heightmapFileLabel]; FormatArguments args{ widget.textArgs }; if (!filename.empty()) { _pngFilename = Localisation::convertUnicodeToLoco(filename); args.push(_pngFilename.c_str()); } else { args.push(StringManager::getString(StringIds::noneSelected)); } self.disabledWidgets |= (1 << widx::change_heightmap_btn); self.disabledWidgets |= ((1 << widx::terrainSmoothingNum) | (1 << widx::terrainSmoothingNumUp) | (1 << widx::terrainSmoothingNumDown)); self.disabledWidgets &= ~(1 << widx::browseHeightmapFile); self.activatedWidgets &= ~(1 << widx::generate_when_game_starts); self.disabledWidgets |= (1 << widx::generate_when_game_starts); } // Enable/disable the 'generate when game starts' checkbox if ((options.scenarioFlags & Scenario::ScenarioFlags::landscapeGenerationDone) == Scenario::ScenarioFlags::none) { self.activatedWidgets |= (1 << widx::generate_when_game_starts); self.disabledWidgets &= ~(1 << widx::generate_when_game_starts); } else { self.activatedWidgets &= ~(1 << widx::generate_when_game_starts); } } // 0x0043E1BA static void onDropdown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case widx::heightMapDropdown: if (itemIndex != -1) { Scenario::getOptions().generator = static_cast<Scenario::LandGeneratorType>(itemIndex); window.invalidate(); } break; } } // 0x0043DC83 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& options = Scenario::getOptions(); switch (widgetIndex) { case widx::start_year_up: if (options.scenarioStartYear + 1 <= Scenario::kMaxYear) { options.scenarioStartYear += 1; } window.invalidate(); break; case widx::start_year_down: if (options.scenarioStartYear - 1 >= Scenario::kMinYear) { options.scenarioStartYear -= 1; } window.invalidate(); break; case widx::terrainSmoothingNumUp: options.numTerrainSmoothingPasses = std::clamp(options.numTerrainSmoothingPasses + 1, 1, 5); window.invalidate(); break; case widx::terrainSmoothingNumDown: options.numTerrainSmoothingPasses = std::clamp(options.numTerrainSmoothingPasses - 1, 1, 5); window.invalidate(); break; case widx::heightMapDropdown: { Widget& target = window.widgets[widx::heightMapBox]; Dropdown::show(window.x + target.left, window.y + target.top, target.width() - 4, target.height(), window.getColour(WindowColour::secondary), std::size(generatorIds), 0x80); for (size_t i = 0; i < std::size(generatorIds); i++) { Dropdown::add(i, generatorIds[i]); } Dropdown::setHighlightedItem(static_cast<uint8_t>(options.generator)); break; } } } // 0x0043DC58 static void onMouseUp(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::generate_when_game_starts: if ((Scenario::getOptions().scenarioFlags & Scenario::ScenarioFlags::landscapeGenerationDone) == Scenario::ScenarioFlags::none) { Scenario::getOptions().scenarioFlags |= Scenario::ScenarioFlags::landscapeGenerationDone; Scenario::generateLandscape(); } else { WindowManager::closeConstructionWindows(); Common::confirmResetLandscape(Common::ResetLandscapeMode::use_random_landscape); } break; case widx::change_heightmap_btn: EditorController::goToPreviousStep(); ObjectSelectionWindow::openInTab(ObjectType::hillShapes); break; case widx::browseHeightmapFile: { if (auto res = Game::loadHeightmapOpen()) { World::MapGenerator::setPngHeightmapPath(fs::u8path(*res)); window.invalidate(); } break; } default: Common::onMouseUp(window, widgetIndex, id); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x0043DA43 Window* open() { auto window = WindowManager::bringToFront(WindowType::landscapeGeneration, 0); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); } window = WindowManager::bringToFront(WindowType::landscapeGeneration, 0); } // Start of 0x0043DAEA if (window == nullptr) { window = WindowManager::createWindowCentred(WindowType::landscapeGeneration, kWindowSize, WindowFlags::none, Options::getEvents()); window->setWidgets(Options::widgets); window->number = 0; window->currentTab = 0; window->frameNo = 0; window->rowHover = -1; auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowTerraFormColour); } // End of 0x0043DAEA window->width = kWindowSize.width; window->height = kWindowSize.height; window->invalidate(); window->activatedWidgets = 0; window->holdableWidgets = Options::holdable_widgets; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); return window; } namespace Land { enum widx { topography_style_label = Common::widx::generate_now + 1, topography_style, topography_style_btn, min_land_height_label, min_land_height, min_land_height_down, min_land_height_up, hill_density_label, hill_density, hill_density_down, hill_density_up, hillsEdgeOfMap, scrollview, }; const uint64_t holdable_widgets = (1 << widx::min_land_height_up) | (1 << widx::min_land_height_down) | (1 << widx::hill_density_up) | (1 << widx::hill_density_down); static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(252, StringIds::title_landscape_generation_land), Widgets::Label({ 10, 52 }, { 160, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::topography_style), Widgets::dropdownWidgets({ 176, 52 }, { 180, 12 }, WindowColour::secondary), Widgets::Label({ 10, 68 }, { 250, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::min_land_height), Widgets::stepperWidgets({ 256, 68 }, { 100, 12 }, WindowColour::secondary, StringIds::min_land_height_units), Widgets::Label({ 10, 84 }, { 250, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::hill_density), Widgets::stepperWidgets({ 256, 84 }, { 100, 12 }, WindowColour::secondary, StringIds::hill_density_percent), Widgets::Checkbox({ 10, 100 }, { 346, 12 }, WindowColour::secondary, StringIds::create_hills_right_up_to_edge_of_map), Widgets::ScrollView({ 4, 116 }, { 358, 112 }, WindowColour::secondary, Scrollbars::vertical) ); static constexpr StringId landDistributionLabelIds[] = { StringIds::land_distribution_everywhere, StringIds::land_distribution_nowhere, StringIds::land_distribution_far_from_water, StringIds::land_distribution_near_water, StringIds::land_distribution_on_mountains, StringIds::land_distribution_far_from_mountains, StringIds::land_distribution_in_small_random_areas, StringIds::land_distribution_in_large_random_areas, StringIds::land_distribution_around_cliffs, }; static constexpr auto kLandDropdownWidth = 190; static constexpr auto kLandDropdownLeft = 150; static constexpr auto kLandDropdownRight = kLandDropdownLeft + kLandDropdownWidth; // 0x0043E01C static void drawScroll(Ui::Window& window, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); uint16_t yPos = 0; for (uint16_t i = 0; i < kMaxLandObjects; i++) { if (yPos + kRowHeight < rt.y) { yPos += kRowHeight; continue; } else if (yPos > rt.y + rt.height) { break; } auto landObject = ObjectManager::get<LandObject>(i); if (landObject == nullptr) { continue; } // Draw tile icon. const uint32_t imageId = landObject->mapPixelImage + OpenLoco::Land::ImageIds::landscape_generator_tile_icon; drawingCtx.drawImage(2, yPos + 1, imageId); // Draw land description. { FormatArguments args{}; args.push(landObject->name); auto point = Point(24, yPos + 5); tr.drawStringLeftClipped(point, 121, Colour::black, StringIds::wcolour2_stringid, args); } // Draw rectangle. drawingCtx.fillRectInset(kLandDropdownLeft, yPos + 5, kLandDropdownRight, yPos + 16, window.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker); // Draw current distribution setting. { FormatArguments args{}; const StringId distributionId = landDistributionLabelIds[enumValue(Scenario::getOptions().landDistributionPatterns[i])]; args.push(distributionId); auto point = Point(kLandDropdownLeft + 1, yPos + 5); tr.drawStringLeftClipped(point, kLandDropdownWidth - 3, Colour::black, StringIds::black_stringid, args); } // Draw rectangle (knob). const Gfx::RectInsetFlags flags = window.rowHover == i ? Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker : Gfx::RectInsetFlags::none; drawingCtx.fillRectInset(kLandDropdownRight - 11, yPos + 6, kLandDropdownRight - 1, yPos + 15, window.getColour(WindowColour::secondary), flags); // Draw triangle (knob). { auto point = Point(kLandDropdownRight - 10, yPos + 6); tr.drawStringLeft(point, Colour::black, StringIds::dropdown); } yPos += kRowHeight; } } // 0x0043E2AC static void getScrollSize([[maybe_unused]] Ui::Window& window, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = 0; for (uint16_t i = 0; i < kMaxLandObjects; i++) { auto landObject = ObjectManager::get<LandObject>(i); if (landObject == nullptr) { continue; } scrollHeight += kRowHeight; } } static constexpr StringId topographyStyleIds[] = { StringIds::flat_land, StringIds::small_hills, StringIds::mountains, StringIds::half_mountains_half_hills, StringIds::half_mountains_half_flat, }; // 0x0043E1BA static void onDropdown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case widx::topography_style_btn: if (itemIndex != -1) { Scenario::getOptions().topographyStyle = static_cast<Scenario::TopographyStyle>(itemIndex); window.invalidate(); } break; case widx::scrollview: if (itemIndex != -1 && window.rowHover != -1) { Scenario::getOptions().landDistributionPatterns[window.rowHover] = static_cast<Scenario::LandDistributionPattern>(itemIndex); window.invalidate(); } break; } } // 0x0043E173 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& options = Scenario::getOptions(); switch (widgetIndex) { case widx::min_land_height_up: options.minLandHeight = std::min<int8_t>(options.minLandHeight + 1, Scenario::kMaxBaseLandHeight); break; case widx::min_land_height_down: options.minLandHeight = std::max<int8_t>(Scenario::kMinBaseLandHeight, options.minLandHeight - 1); break; case widx::topography_style_btn: { Widget& target = window.widgets[widx::topography_style]; Dropdown::show(window.x + target.left, window.y + target.top, target.width() - 4, target.height(), window.getColour(WindowColour::secondary), std::size(topographyStyleIds), 0x80); for (size_t i = 0; i < std::size(topographyStyleIds); i++) { Dropdown::add(i, topographyStyleIds[i]); } Dropdown::setHighlightedItem(static_cast<uint8_t>(options.topographyStyle)); break; } case widx::hill_density_up: options.hillDensity = std::min<int8_t>(options.hillDensity + 1, Scenario::kMaxHillDensity); break; case widx::hill_density_down: options.hillDensity = std::max<int8_t>(Scenario::kMinHillDensity, options.hillDensity - 1); break; default: // Nothing was changed, don't invalidate. return; } // After changing any of the options, invalidate the window. window.invalidate(); } // 0x0043E14E static void onMouseUp(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::hillsEdgeOfMap: Scenario::getOptions().scenarioFlags ^= Scenario::ScenarioFlags::hillsEdgeOfMap; window.invalidate(); break; default: Common::onMouseUp(window, widgetIndex, id); } } // 0x0043E421 static int16_t scrollPosToLandIndex(int16_t xPos, int16_t yPos) { if (xPos < kLandDropdownLeft || xPos > kLandDropdownRight) { return -1; } for (uint16_t i = 0; i < kMaxLandObjects; i++) { auto landObject = ObjectManager::get<LandObject>(i); if (landObject == nullptr) { continue; } yPos -= kRowHeight; if (yPos < 0) { return i; } } return -1; } // 0x0043E1CF static void scrollMouseDown(Window& window, int16_t xPos, int16_t yPos, [[maybe_unused]] uint8_t scrollIndex) { int16_t landIndex = scrollPosToLandIndex(xPos, yPos); if (landIndex == -1) { return; } window.rowHover = landIndex; Audio::playSound(Audio::SoundId::clickDown, window.widgets[widx::scrollview].right); const Widget& target = window.widgets[widx::scrollview]; const int16_t dropdownX = window.x + target.left + kLandDropdownLeft + 1; const int16_t dropdownY = window.y + target.top + 6 + landIndex * kRowHeight - window.scrollAreas[0].contentOffsetY; Dropdown::show(dropdownX, dropdownY, kLandDropdownWidth - 2, 12, window.getColour(WindowColour::secondary), std::size(landDistributionLabelIds), 0x80); for (size_t i = 0; i < std::size(landDistributionLabelIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, landDistributionLabelIds[i]); } Dropdown::setItemSelected(enumValue(Scenario::getOptions().landDistributionPatterns[landIndex])); } // 0x0043DEBF static void prepareDraw(Window& window) { Common::prepareDraw(window); auto& options = Scenario::getOptions(); { auto args = FormatArguments(window.widgets[widx::hill_density].textArgs); args.push<uint16_t>(options.hillDensity); } { auto args = FormatArguments(window.widgets[widx::min_land_height].textArgs); args.push<uint16_t>(options.minLandHeight); } window.widgets[widx::topography_style].text = topographyStyleIds[static_cast<uint8_t>(options.topographyStyle)]; if ((options.scenarioFlags & Scenario::ScenarioFlags::hillsEdgeOfMap) != Scenario::ScenarioFlags::none) { window.activatedWidgets |= (1 << widx::hillsEdgeOfMap); } else { window.activatedWidgets &= ~(1 << widx::hillsEdgeOfMap); } } // 0x0043E2A2 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_list); return args; } // 0x0043E3D9 static void update(Window& window) { Common::update(window); auto dropdown = WindowManager::find(WindowType::dropdown, 0); if (dropdown == nullptr && window.rowHover != -1) { window.rowHover = -1; window.invalidate(); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = update, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = Common::draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Water { enum widx { sea_level_label = Common::widx::generate_now + 1, sea_level, sea_level_down, sea_level_up, num_riverbeds_label, num_riverbeds, num_riverbeds_down, num_riverbeds_up, min_river_width_label, min_river_width, min_river_width_down, min_river_width_up, max_river_width_label, max_river_width, max_river_width_down, max_river_width_up, riverbank_width_label, riverbank_width, riverbank_width_down, riverbank_width_up, meander_rate_label, meander_rate, meander_rate_down, meander_rate_up, }; // clang-format off const uint64_t holdable_widgets = (1ULL << widx::sea_level_up) | (1ULL << widx::sea_level_down) | (1ULL << widx::num_riverbeds_down) | (1ULL << widx::num_riverbeds_up) | (1ULL << widx::min_river_width_down) | (1ULL << widx::min_river_width_up) | (1ULL << widx::max_river_width_down) | (1ULL << widx::max_river_width_up) | (1ULL << widx::riverbank_width_down) | (1ULL << widx::riverbank_width_up) | (1ULL << widx::meander_rate_down) | (1ULL << widx::meander_rate_up); // clang-format on static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_landscape_generation_water), Widgets::Label({ 10, 52 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::sea_level), Widgets::stepperWidgets({ 256, 52 }, { 100, 12 }, WindowColour::secondary, StringIds::sea_level_units), Widgets::Label({ 10, 68 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::number_riverbeds), Widgets::stepperWidgets({ 256, 68 }, { 100, 12 }, WindowColour::secondary, StringIds::uint16_raw), Widgets::Label({ 10, 84 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::minimum_river_width), Widgets::stepperWidgets({ 256, 84 }, { 100, 12 }, WindowColour::secondary, StringIds::min_land_height_units), Widgets::Label({ 10, 100 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::maximum_river_width), Widgets::stepperWidgets({ 256, 100 }, { 100, 12 }, WindowColour::secondary, StringIds::min_land_height_units), Widgets::Label({ 10, 116 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::riverbank_width), Widgets::stepperWidgets({ 256, 116 }, { 100, 12 }, WindowColour::secondary, StringIds::min_land_height_units), Widgets::Label({ 10, 132 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::meander_rate), Widgets::stepperWidgets({ 256, 132 }, { 100, 12 }, WindowColour::secondary, StringIds::min_land_height_units) ); // 0x0043E173 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& gameState = getGameState(); auto& options = Scenario::getOptions(); switch (widgetIndex) { case widx::sea_level_up: gameState.seaLevel = std::min<int8_t>(gameState.seaLevel + 1, Scenario::kMaxSeaLevel); break; case widx::sea_level_down: gameState.seaLevel = std::max<int8_t>(Scenario::kMinSeaLevel, gameState.seaLevel - 1); break; case widx::num_riverbeds_up: options.numRiverbeds = std::min<int8_t>(options.numRiverbeds + 1, Scenario::kMaxNumRiverbeds); break; case widx::num_riverbeds_down: options.numRiverbeds = std::max<int8_t>(Scenario::kMinNumRiverbeds, options.numRiverbeds - 1); break; case widx::min_river_width_up: options.minRiverWidth = std::min<int8_t>(options.minRiverWidth + 1, Scenario::kMaxMinRiverWidth); break; case widx::min_river_width_down: options.minRiverWidth = std::max<int8_t>(Scenario::kMinMinRiverWidth, options.minRiverWidth - 1); break; case widx::max_river_width_up: options.maxRiverWidth = std::min<int8_t>(options.maxRiverWidth + 1, Scenario::kMaxMaxRiverWidth); break; case widx::max_river_width_down: options.maxRiverWidth = std::max<int8_t>(Scenario::kMinMaxRiverWidth, options.maxRiverWidth - 1); break; case widx::riverbank_width_up: options.riverbankWidth = std::min<int8_t>(options.riverbankWidth + 1, Scenario::kMaxRiverbankWidth); break; case widx::riverbank_width_down: options.riverbankWidth = std::max<int8_t>(Scenario::kMinRiverbankWidth, options.riverbankWidth - 1); break; case widx::meander_rate_up: options.riverMeanderRate = std::min<int8_t>(options.riverMeanderRate + 1, Scenario::kMaxRiverMeanderRate); break; case widx::meander_rate_down: options.riverMeanderRate = std::max<int8_t>(Scenario::kMinRiverMeanderRate, options.riverMeanderRate - 1); break; default: // Nothing was changed, don't invalidate. return; } // After changing any of the options, invalidate the window. window.invalidate(); } // 0x0043DEBF static void prepareDraw(Window& window) { Common::prepareDraw(window); auto& gameState = getGameState(); auto& options = Scenario::getOptions(); { auto args = FormatArguments(window.widgets[widx::sea_level].textArgs); args.push(gameState.seaLevel); } { auto args = FormatArguments(window.widgets[widx::num_riverbeds].textArgs); args.push<uint16_t>(options.numRiverbeds); } { auto args = FormatArguments(window.widgets[widx::min_river_width].textArgs); args.push<uint16_t>(options.minRiverWidth); } { auto args = FormatArguments(window.widgets[widx::max_river_width].textArgs); args.push<uint16_t>(options.maxRiverWidth); } { auto args = FormatArguments(window.widgets[widx::riverbank_width].textArgs); args.push<uint16_t>(options.riverbankWidth); } { auto args = FormatArguments(window.widgets[widx::meander_rate].textArgs); args.push<uint16_t>(options.riverMeanderRate); } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onMouseDown = onMouseDown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Forests { enum widx { number_of_forests_label = Common::widx::generate_now + 1, number_of_forests, number_of_forests_down, number_of_forests_up, minForestRadiusLabel, minForestRadius, min_forest_radius_down, min_forest_radius_up, maxForestRadiusLabel, maxForestRadius, max_forest_radius_down, max_forest_radius_up, minForestDensityLabel, minForestDensity, min_forest_density_down, min_forest_density_up, maxForestDensityLabel, maxForestDensity, max_forest_density_down, max_forest_density_up, number_random_trees_label, number_random_trees, number_random_trees_down, number_random_trees_up, min_altitude_for_trees_label, min_altitude_for_trees, min_altitude_for_trees_down, min_altitude_for_trees_up, max_altitude_for_trees_label, max_altitude_for_trees, max_altitude_for_trees_down, max_altitude_for_trees_up, }; const uint64_t holdable_widgets = (1ULL << widx::number_of_forests_up) | (1ULL << widx::number_of_forests_down) | (1ULL << widx::min_forest_radius_up) | (1ULL << widx::min_forest_radius_down) | (1ULL << widx::max_forest_radius_up) | (1ULL << widx::max_forest_radius_down) | (1ULL << widx::min_forest_density_up) | (1ULL << widx::min_forest_density_down) | (1ULL << widx::max_forest_density_up) | (1 << widx::max_forest_density_down) | (1ULL << widx::number_random_trees_up) | (1ULL << widx::number_random_trees_down) | (1ULL << widx::min_altitude_for_trees_up) | (1ULL << widx::min_altitude_for_trees_down) | (1ULL << widx::max_altitude_for_trees_down) | (1ULL << widx::max_altitude_for_trees_up); static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_landscape_generation_forests), Widgets::Label({ 10, 52 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::number_of_forests), Widgets::stepperWidgets({ 256, 52 }, { 100, 12 }, WindowColour::secondary, StringIds::number_of_forests_value), Widgets::Label({ 10, 67 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::min_forest_radius), Widgets::stepperWidgets({ 256, 67 }, { 100, 12 }, WindowColour::secondary, StringIds::min_forest_radius_blocks), Widgets::Label({ 10, 82 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::max_forest_radius), Widgets::stepperWidgets({ 256, 82 }, { 100, 12 }, WindowColour::secondary, StringIds::max_forest_radius_blocks), Widgets::Label({ 10, 97 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::min_forest_density), Widgets::stepperWidgets({ 256, 97 }, { 100, 12 }, WindowColour::secondary, StringIds::min_forest_density_percent), Widgets::Label({ 10, 112 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::max_forest_density), Widgets::stepperWidgets({ 256, 112 }, { 100, 12 }, WindowColour::secondary, StringIds::max_forest_density_percent), Widgets::Label({ 10, 127 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::number_random_trees), Widgets::stepperWidgets({ 256, 127 }, { 100, 12 }, WindowColour::secondary, StringIds::number_random_trees_value), Widgets::Label({ 10, 142 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::min_altitude_for_trees), Widgets::stepperWidgets({ 256, 142 }, { 100, 12 }, WindowColour::secondary, StringIds::min_altitude_for_trees_height), Widgets::Label({ 10, 157 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::max_altitude_for_trees), Widgets::stepperWidgets({ 256, 157 }, { 100, 12 }, WindowColour::secondary, StringIds::max_altitude_for_trees_height) ); // 0x0043E670 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& options = Scenario::getOptions(); switch (widgetIndex) { case widx::number_of_forests_up: { options.numberOfForests = std::min<int16_t>(options.numberOfForests + 10, Scenario::kMaxNumForests); break; } case widx::number_of_forests_down: { options.numberOfForests = std::max<int16_t>(Scenario::kMinNumForests, options.numberOfForests - 10); break; } case widx::min_forest_radius_up: { options.minForestRadius = std::min<int16_t>(options.minForestRadius + 1, Scenario::kMaxForestRadius); if (options.minForestRadius > options.maxForestRadius) { options.maxForestRadius = options.minForestRadius; } break; } case widx::min_forest_radius_down: { options.minForestRadius = std::max<int8_t>(Scenario::kMinForestRadius, options.minForestRadius - 1); break; } case widx::max_forest_radius_up: { options.maxForestRadius = std::clamp<int8_t>(options.maxForestRadius + 1, Scenario::kMinForestRadius, Scenario::kMaxForestRadius); break; } case widx::max_forest_radius_down: { options.maxForestRadius = std::clamp<int8_t>(options.maxForestRadius - 1, Scenario::kMinForestRadius, Scenario::kMaxForestRadius); if (options.maxForestRadius < options.minForestRadius) { options.minForestRadius = options.maxForestRadius; } break; } case widx::min_forest_density_up: { options.minForestDensity = std::min<int8_t>(options.minForestDensity + 1, Scenario::kMaxForestDensity); if (options.minForestDensity > options.maxForestDensity) { options.maxForestDensity = options.minForestDensity; } break; } case widx::min_forest_density_down: { options.minForestDensity = std::max<int8_t>(Scenario::kMinForestDensity, options.minForestDensity - 1); break; } case widx::max_forest_density_up: { options.maxForestDensity = std::min<int8_t>(options.maxForestDensity + 1, Scenario::kMaxForestDensity); break; } case widx::max_forest_density_down: { options.maxForestDensity = std::max<int8_t>(Scenario::kMinForestDensity, options.maxForestDensity - 1); if (options.maxForestDensity < options.minForestDensity) { options.minForestDensity = options.maxForestDensity; } break; } case widx::number_random_trees_up: { options.numberRandomTrees = std::min<int16_t>(options.numberRandomTrees + 25, Scenario::kMaxNumTrees); break; } case widx::number_random_trees_down: { options.numberRandomTrees = std::max<int16_t>(Scenario::kMinNumTrees, options.numberRandomTrees - 25); break; } case widx::min_altitude_for_trees_up: { options.minAltitudeForTrees = std::min<int8_t>(options.minAltitudeForTrees + 1, Scenario::kMaxAltitudeTrees); if (options.minAltitudeForTrees > options.maxAltitudeForTrees) { options.maxAltitudeForTrees = options.minAltitudeForTrees; } break; } case widx::min_altitude_for_trees_down: { options.minAltitudeForTrees = std::max<int8_t>(Scenario::kMinAltitudeTrees, options.minAltitudeForTrees - 1); break; } case widx::max_altitude_for_trees_up: { options.maxAltitudeForTrees = std::min<int8_t>(options.maxAltitudeForTrees + 1, Scenario::kMaxAltitudeTrees); break; } case widx::max_altitude_for_trees_down: { options.maxAltitudeForTrees = std::max<int8_t>(Scenario::kMinAltitudeTrees, options.maxAltitudeForTrees - 1); if (options.maxAltitudeForTrees < options.minAltitudeForTrees) { options.minAltitudeForTrees = options.maxAltitudeForTrees; } break; } default: // Nothing was changed, don't invalidate. return; } // After changing any of the options, invalidate the window. window.invalidate(); } // 0x0043E44F static void prepareDraw(Window& window) { Common::prepareDraw(window); auto& options = Scenario::getOptions(); { auto args = FormatArguments(window.widgets[widx::number_of_forests].textArgs); args.push<uint16_t>(options.numberOfForests); } { auto args = FormatArguments(window.widgets[widx::maxForestDensity].textArgs); args.push<uint16_t>(options.maxForestDensity); } { auto args = FormatArguments(window.widgets[widx::minForestDensity].textArgs); args.push<uint16_t>(options.minForestDensity); } { auto args = FormatArguments(window.widgets[widx::minForestRadius].textArgs); args.push<uint16_t>(options.minForestRadius); } { auto args = FormatArguments(window.widgets[widx::maxForestRadius].textArgs); args.push<uint16_t>(options.maxForestRadius); } { auto args = FormatArguments(window.widgets[widx::minForestDensity].textArgs); args.push<uint16_t>(options.minForestDensity * 14); } { auto args = FormatArguments(window.widgets[widx::maxForestDensity].textArgs); args.push<uint16_t>(options.maxForestDensity * 14); } { auto args = FormatArguments(window.widgets[widx::number_random_trees].textArgs); args.push<uint16_t>(options.numberRandomTrees); } { auto args = FormatArguments(window.widgets[widx::min_altitude_for_trees].textArgs); args.push<uint16_t>(options.minAltitudeForTrees); } { auto args = FormatArguments(window.widgets[widx::max_altitude_for_trees].textArgs); args.push<uint16_t>(options.maxAltitudeForTrees); } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onMouseDown = onMouseDown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Towns { enum widx { number_of_towns_label = Common::widx::generate_now + 1, number_of_towns, number_of_towns_down, number_of_towns_up, max_town_size_label, max_town_size, max_town_size_btn, }; const uint64_t holdable_widgets = (1 << widx::number_of_towns_up) | (1 << widx::number_of_towns_down); static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_landscape_generation_towns), Widgets::Label({ 10, 52 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::number_of_towns), Widgets::stepperWidgets({ 256, 52 }, { 100, 12 }, WindowColour::secondary, StringIds::number_of_towns_value), Widgets::Label({ 10, 67 }, { 160, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::max_town_size), Widgets::dropdownWidgets({ 176, 67 }, { 180, 12 }, WindowColour::secondary) ); static constexpr StringId townSizeLabels[] = { StringIds::town_size_1, StringIds::town_size_2, StringIds::town_size_3, StringIds::town_size_4, StringIds::town_size_5, StringIds::town_size_6, StringIds::town_size_7, StringIds::town_size_8, }; // 0x0043EA28 static void onDropdown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::max_town_size_btn || itemIndex == -1) { return; } Scenario::getOptions().maxTownSize = itemIndex + 1; window.invalidate(); } // 0x0043EA0D static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& options = Scenario::getOptions(); switch (widgetIndex) { case widx::number_of_towns_up: { uint16_t newNumTowns = std::min<uint16_t>(options.numberOfTowns + 1, Limits::kMaxTowns); options.numberOfTowns = newNumTowns; window.invalidate(); break; } case widx::number_of_towns_down: { // Vanilla behaviour: Zero-town map generation is allowed in the scenario editor and // is checked on the editor stage progression for non-zero. It is required to be non-zero // for gameplay since industries must have at least one associated town. The user must // manually place at least one town if they generate a landscape with zero towns. if (options.numberOfTowns > 0) { uint16_t newNumTowns = std::max<uint16_t>(Limits::kMinTowns - 1, options.numberOfTowns - 1); options.numberOfTowns = newNumTowns; } window.invalidate(); break; } case widx::max_town_size_btn: { Widget& target = window.widgets[widx::max_town_size]; Dropdown::show(window.x + target.left, window.y + target.top, target.width() - 4, target.height(), window.getColour(WindowColour::secondary), std::size(townSizeLabels), 0x80); for (size_t i = 0; i < std::size(townSizeLabels); i++) { Dropdown::add(i, townSizeLabels[i]); } Dropdown::setHighlightedItem(options.maxTownSize - 1); break; } } } // 0x0043E90D static void prepareDraw(Window& window) { Common::prepareDraw(window); auto args = FormatArguments(window.widgets[widx::number_of_towns].textArgs); args.push<uint16_t>(Scenario::getOptions().numberOfTowns); window.widgets[widx::max_town_size].text = townSizeLabels[Scenario::getOptions().maxTownSize - 1]; } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Industries { enum widx { num_industries_label = Common::widx::generate_now + 1, num_industries, num_industries_btn, check_allow_industries_close_down, check_allow_industries_start_up, }; const uint64_t holdable_widgets = 0; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_landscape_generation_industries), Widgets::Label({ 10, 52 }, { 160, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::number_of_industries), Widgets::dropdownWidgets({ 176, 52 }, { 180, 12 }, WindowColour::secondary), Widgets::Checkbox({ 10, 68 }, { 346, 12 }, WindowColour::secondary, StringIds::allow_industries_to_close_down_during_game), Widgets::Checkbox({ 10, 83 }, { 346, 12 }, WindowColour::secondary, StringIds::allow_new_industries_to_start_up_during_game) ); static constexpr StringId numIndustriesLabels[] = { StringIds::industry_size_low, StringIds::industry_size_medium, StringIds::industry_size_high, }; // 0x0043EBF8 static void onDropdown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::num_industries_btn || itemIndex == -1) { return; } Scenario::getOptions().numberOfIndustries = itemIndex; window.invalidate(); } // 0x0043EBF1 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::num_industries_btn: { Widget& target = window.widgets[widx::num_industries]; Dropdown::show(window.x + target.left, window.y + target.top, target.width() - 4, target.height(), window.getColour(WindowColour::secondary), std::size(numIndustriesLabels), 0x80); for (size_t i = 0; i < std::size(numIndustriesLabels); i++) { Dropdown::add(i, numIndustriesLabels[i]); } Dropdown::setHighlightedItem(Scenario::getOptions().numberOfIndustries); break; } case widx::check_allow_industries_close_down: IndustryManager::setFlags(IndustryManager::getFlags() ^ IndustryManager::Flags::disallowIndustriesCloseDown); window.invalidate(); break; case widx::check_allow_industries_start_up: IndustryManager::setFlags(IndustryManager::getFlags() ^ IndustryManager::Flags::disallowIndustriesStartUp); window.invalidate(); break; } } // 0x0043EAEB static void prepareDraw(Window& window) { Common::prepareDraw(window); window.widgets[widx::num_industries].text = numIndustriesLabels[Scenario::getOptions().numberOfIndustries]; window.activatedWidgets &= ~((1 << widx::check_allow_industries_close_down) | (1 << widx::check_allow_industries_start_up)); if (!IndustryManager::hasFlags(IndustryManager::Flags::disallowIndustriesCloseDown)) { window.activatedWidgets |= 1 << widx::check_allow_industries_close_down; } if (!IndustryManager::hasFlags(IndustryManager::Flags::disallowIndustriesStartUp)) { window.activatedWidgets |= 1 << widx::check_allow_industries_start_up; } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } }; namespace Common { static void switchTabWidgets(Window* window) { window->activatedWidgets = 0; static std::span<const Widget> widgetCollectionsByTabId[] = { Options::widgets, Land::widgets, Water::widgets, Forests::widgets, Towns::widgets, Industries::widgets, }; auto newWidgets = widgetCollectionsByTabId[window->currentTab]; window->setWidgets(newWidgets); window->initScrollWidgets(); static constexpr widx tabWidgetIdxByTabId[] = { tab_options, tab_land, tab_water, tab_forests, tab_towns, tab_industries, }; window->activatedWidgets &= ~((1 << tab_options) | (1 << tab_land) | (1 << tab_water) | (1 << tab_forests) | (1 << tab_towns) | (1 << tab_industries)); window->activatedWidgets |= (1ULL << tabWidgetIdxByTabId[window->currentTab]); } // 0x0043DC98 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_options; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.disabledWidgets = 0; static const uint64_t* holdableWidgetsByTab[] = { &Options::holdable_widgets, &Land::holdable_widgets, &Water::holdable_widgets, &Forests::holdable_widgets, &Towns::holdable_widgets, &Industries::holdable_widgets, }; self.holdableWidgets = *holdableWidgetsByTab[self.currentTab]; static const WindowEventList* eventsByTab[] = { &Options::getEvents(), &Land::getEvents(), &Water::getEvents(), &Forests::getEvents(), &Towns::getEvents(), &Industries::getEvents(), }; self.eventHandlers = eventsByTab[self.currentTab]; switchTabWidgets(&self); self.invalidate(); const auto newSize = [widgetIndex]() { if (widgetIndex == widx::tab_land) { return kLandTabSize; } else { return kWindowSize; } }(); self.setSize(newSize); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Main.cpp ```cpp #include "Config.h" #include "Entities/EntityManager.h" #include "Graphics/Gfx.h" #include "Map/Tile.h" #include "Ui/Widget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" namespace OpenLoco::Ui::Windows::Main { namespace widx { enum { viewport }; } static constexpr auto _widgets = makeWidgets( Widgets::Viewport({ 0, 0 }, { 0, 0 }, WindowColour::primary, Widget::kContentUnk) ); static const WindowEventList& getEvents(); // 0x00438A6C, 0x0043CB9F void open() { const int32_t uiWidth = Ui::width(); const int32_t uiHeight = Ui::height(); auto window = WindowManager::createWindow( WindowType::main, { 0, 0 }, { uiWidth, uiHeight }, Ui::WindowFlags::stickToBack, getEvents()); window->setWidgets(_widgets); window->widgets[widx::viewport].bottom = uiHeight; window->widgets[widx::viewport].right = uiWidth; WindowManager::setCurrentRotation(0); ViewportManager::create( window, 0, { window->x, window->y }, { window->width, window->height }, ZoomLevel::full, { (World::kMapRows * World::kTileSize) / 2 - 1, (World::kMapRows * World::kTileSize) / 2 - 1, 480 }); } // 0x0043B2E4 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { window.draw(drawingCtx); } // 0x00468FD3 void showGridlines() { auto window = WindowManager::getMainWindow(); if (window == nullptr || window->viewports[0]->hasFlags(ViewportFlags::gridlines_on_landscape)) { return; } window->viewports[0]->flags |= ViewportFlags::gridlines_on_landscape; window->invalidate(); } // 0x00468FFE void hideGridlines() { if (!Config::get().gridlinesOnLandscape) { auto window = WindowManager::getMainWindow(); if (window == nullptr || !window->viewports[0]->hasFlags(ViewportFlags::gridlines_on_landscape)) { return; } window->viewports[0]->flags &= ~ViewportFlags::gridlines_on_landscape; window->invalidate(); } } // 0x004793C4 void showDirectionArrows() { auto mainWindow = WindowManager::getMainWindow(); if (mainWindow == nullptr || mainWindow->viewports[0]->hasFlags(ViewportFlags::one_way_direction_arrows)) { return; } mainWindow->viewports[0]->flags |= ViewportFlags::one_way_direction_arrows; mainWindow->invalidate(); } // 0x004793EF void hideDirectionArrows() { auto mainWindow = WindowManager::getMainWindow(); if (mainWindow == nullptr || !mainWindow->viewports[0]->hasFlags(ViewportFlags::one_way_direction_arrows)) { return; } mainWindow->viewports[0]->flags &= ~ViewportFlags::one_way_direction_arrows; mainWindow->invalidate(); } void viewportFocusOnEntity(Window& main, EntityId targetEntity) { if (main.viewports[0] == nullptr) { return; } main.viewportConfigurations[0].viewportTargetSprite = targetEntity; } bool viewportIsFocusedOnEntity(const Window& main, EntityId targetEntity) { if (targetEntity == EntityId::null || main.viewports[0] == nullptr) { return false; } return main.viewportConfigurations[0].viewportTargetSprite == targetEntity; } bool viewportIsFocusedOnAnyEntity(const Window& main) { if (main.viewports[0] == nullptr) { return false; } return main.viewportConfigurations[0].viewportTargetSprite != EntityId::null; } // Stop following the followed entity, leaving the viewport centred on it. void viewportUnfocusFromEntity(Window& main) { if (main.viewports[0] == nullptr) { return; } if (main.viewportConfigurations[0].viewportTargetSprite == EntityId::null) { return; } auto entity = EntityManager::get<EntityBase>(main.viewportConfigurations[0].viewportTargetSprite); main.viewportConfigurations[0].viewportTargetSprite = EntityId::null; main.viewportCentreOnTile(entity->position); } static constexpr WindowEventList kEvents = { .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/MapToolTip.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" namespace OpenLoco::Ui::Windows::MapToolTip { static CompanyId _mapTooltipOwner; // 0x0050A040 static uint16_t _mapTooltipTimeout; // 0x00523348 enum widx { text }; // 0x005234F4 static constexpr auto _widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 200, 30 }, WindowColour::primary) ); static const WindowEventList& getEvents(); // 0x004CEEA7 void open() { _mapTooltipTimeout++; auto cursor = Input::getMouseLocation(); static Ui::Point tooltipLocation = {}; if ((std::abs(tooltipLocation.x - cursor.x) > 5) || (std::abs(tooltipLocation.y - cursor.y) > 5) || Input::hasFlag(Input::Flags::rightMousePressed)) { _mapTooltipTimeout = 0; } tooltipLocation = cursor; auto args = FormatArguments::mapToolTip(); FormatArgumentsView argsWrap(args); auto firstArg = argsWrap.pop<StringId>(); if (_mapTooltipTimeout < 25 || firstArg == StringIds::null || Input::hasFlag(Input::Flags::rightMousePressed) || Input::hasKeyModifier(Input::KeyModifier::control) || Input::hasKeyModifier(Input::KeyModifier::shift) || WindowManager::find(WindowType::error) != nullptr) { WindowManager::close(WindowType::mapTooltip); return; } auto height = 55; auto maxY = Ui::height() - height; int16_t y = cursor.y + 15; // Normally, we'd display the tooltip 15 lower if (y > maxY) { // If y is too large, the tooltip could be forced below the cursor if we'd just clamped y, // so we'll subtract a bit more y -= height + 19; } auto width = 240; int16_t x = width <= Ui::width() ? std::clamp(cursor.x - (width / 2), 0, Ui::width() - width) : 0; auto* window = WindowManager::find(WindowType::mapTooltip); if (window != nullptr) { window->invalidate(); window->x = x; window->y = y; window->width = width; window->height = height; } else { window = WindowManager::createWindow(WindowType::mapTooltip, { x, y }, { width, height }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground, getEvents()); window->setWidgets(_widgets); auto* skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, skin->mapTooltipObjectColour); window->setColour(WindowColour::tertiary, skin->mapTooltipCargoColour); } } void setOwner(CompanyId company) { _mapTooltipOwner = company; } uint16_t getTooltipTimeout() { return _mapTooltipTimeout; } void reset() { setOwner(CompanyId::null); FormatArguments::mapToolTip(StringIds::null); } // 0x004CF13B static void update(Window& self) { self.invalidate(); } // 0x004CF010 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); auto args = FormatArguments::mapToolTip(); FormatArgumentsView argsWrap(args); auto firstArg = argsWrap.pop<StringId>(); if (firstArg == StringIds::null) { return; } if (_mapTooltipOwner == CompanyId::null || _mapTooltipOwner == CompanyManager::getControllingId()) { Ui::Point origin(self.x + self.width / 2, self.y + self.height / 2 - 5); tr.drawStringCentredWrapped(origin, self.width, Colour::black, StringIds::outlined_wcolour2_stringid, args); } else { Ui::Point origin(self.x + self.width / 2 + 13, self.y + self.height / 2 - 5); auto basePoint = tr.drawStringCentredWrapped(origin, self.width - 28, Colour::black, StringIds::outlined_wcolour2_stringid, args); auto left = basePoint.x - 28; auto top = self.y + self.height / 2 - 13; auto right = left + 25; auto bottom = top + 25; drawingCtx.fillRect(left, top, right, bottom, PaletteIndex::black0, Gfx::RectFlags::none); auto* company = CompanyManager::get(_mapTooltipOwner); auto* competitor = ObjectManager::get<CompetitorObject>(company->competitorId); auto imageId = Gfx::recolour(competitor->images[enumValue(company->ownerEmotion)], company->mainColours.primary); drawingCtx.drawImage(left + 1, top + 1, imageId); } } static constexpr WindowEventList kEvents = { .onUpdate = update, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/MapWindow.cpp ```cpp #include "Engine/Limits.h" #include "Entities/Entity.h" #include "Entities/EntityManager.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameStateFlags.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/IndustryElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Objects/IndustryObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/WaterObject.h" #include "SceneManager.h" #include "Types.hpp" #include "Ui/LastMapWindowAttributes.h" #include "Ui/ScrollView.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/Numerics.hpp> using namespace OpenLoco::Ui::WindowManager; using namespace OpenLoco::World; namespace OpenLoco::Ui::Windows::MapWindow { static constexpr uint16_t kMinimumWindowWidth = 229; // Chosen so that the map cannot be smaller than its key static constexpr uint16_t kMinimumWindowHeight = 176; // Chosen so that the minimum size makes the map square static constexpr int16_t kRenderedMapWidth = kMapColumns * 2; static constexpr int16_t kRenderedMapHeight = kRenderedMapWidth; static constexpr int32_t kRenderedMapSize = kRenderedMapWidth * kRenderedMapHeight; // 0x004FDC4C static std::array<Point, 4> kViewFrameOffsetsByRotation = { { { kMapColumns - 8, 0 }, { kRenderedMapWidth - 8, kMapRows }, { kMapColumns - 8, kRenderedMapHeight }, { -8, kMapRows }, } }; static constexpr std::array<PaletteIndex_t, 256> kFlashColours = []() { std::array<PaletteIndex_t, 256> colours; std::fill(colours.begin(), colours.end(), PaletteIndex::black0); std::fill(colours.begin() + 10, colours.begin() + 14, PaletteIndex::blackB); return colours; }(); // 0x004FDC5C static PaletteIndex_t* _mapPixels; // 0x00F253A8 static PaletteIndex_t* _mapAltPixels; static std::array<uint16_t, 6> _vehicleTypeCounts = {}; static uint32_t _flashingItems; // 0x00F253A4 static uint32_t _drawMapRowIndex; // 0x00F253AC static uint8_t _assignedIndustryColours[16]; // 0x00F253CE static uint8_t _routeToObjectIdMap[19]; // 0x00F253DF static uint8_t _routeColours[19]; // 0x00F253F2 static uint8_t _trackColours[8]; // 0x00F25404 static uint8_t _roadColours[8]; // 0x00F2540C enum widx { frame = 0, caption, closeButton, panel, tabOverall, tabVehicles, tabIndustries, tabRoutes, tabOwnership, scrollview, statusBar, }; static constexpr auto kWidgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 350, 272 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 348, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::title_map), Widgets::ImageButton({ 335, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 350, 230 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_map_overall), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_map_vehicles), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_map_industries), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_map_routes), Widgets::Tab({ 158, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_map_ownership), Widgets::ScrollView({ 3, 44 }, { 240, 215 }, WindowColour::secondary, Scrollbars::horizontal | Scrollbars::vertical), Widgets::Label({ 3, 250 }, { 322, 21 }, WindowColour::secondary, ContentAlign::center) ); static Pos2 mapWindowPosToLocation(Point pos) { pos.x = ((pos.x + 8) - kMapColumns) / 2; pos.y = ((pos.y + 8)) / 2; Pos2 location = { static_cast<coord_t>(pos.y - pos.x), static_cast<coord_t>(pos.x + pos.y) }; location.x *= kTileSize; location.y *= kTileSize; switch (getCurrentRotation()) { case 0: return location; case 1: return { static_cast<coord_t>(kMapWidth - 1 - location.y), location.x }; case 2: return { static_cast<coord_t>(kMapWidth - 1 - location.x), static_cast<coord_t>(kMapHeight - 1 - location.y) }; case 3: return { location.y, static_cast<coord_t>(kMapHeight - 1 - location.x) }; } return { 0, 0 }; // unreachable } static Point locationToMapWindowPos(Pos2 pos) { int32_t x = pos.x; int32_t y = pos.y; switch (getCurrentRotation()) { case 3: std::swap(x, y); x = kMapWidth - 1 - x; break; case 2: x = kMapWidth - 1 - x; y = kMapHeight - 1 - y; break; case 1: std::swap(x, y); y = kMapHeight - 1 - y; break; case 0: break; } x /= kTileSize; y /= kTileSize; return Point(-x + y + kMapColumns - 8, x + y - 8); } // 0x0046B8E6 static void onClose(Window& self) { Ui::getLastMapWindowAttributes().size = Ui::Size(self.width, self.height); Ui::getLastMapWindowAttributes().var88A = self.var_88A; Ui::getLastMapWindowAttributes().var88C = self.var_88C; Ui::getLastMapWindowAttributes().flags = self.flags | WindowFlags::flag_31; free(_mapPixels); } // 0x0046B8CF static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::closeButton: WindowManager::close(&self); break; case widx::tabOverall: case widx::tabVehicles: case widx::tabIndustries: case widx::tabRoutes: case widx::tabOwnership: case widx::scrollview: { auto tabIndex = widgetIndex - widx::tabOverall; if (tabIndex == self.currentTab) { return; } self.currentTab = tabIndex; self.frameNo = 0; self.var_854 = 0; break; } } } // 0x0046B9F7 static void onResize(Window& self) { self.flags |= WindowFlags::resizable; self.minWidth = kMinimumWindowWidth; self.maxWidth = 800; // NB: frame background is only 800px :( self.maxHeight = 800; Ui::Size32 kMinWindowSize = { self.minWidth, self.minHeight }; Ui::Size32 kMaxWindowSize = { self.maxWidth, self.maxHeight }; self.setSize(kMinWindowSize, kMaxWindowSize); } // 0x0046C5E5 static void setMapPixelsOverall(PaletteIndex_t* mapPtr, PaletteIndex_t* mapAltPtr, Pos2 pos, Pos2 delta) { for (auto rowCountLeft = kMapColumns; rowCountLeft > 0; rowCountLeft--) { // Coords shouldn't be at map edge if (!(pos.x > 0 && pos.y > 0 && pos.x < kMapWidth - kTileSize && pos.y < kMapHeight - kTileSize)) { pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; continue; } PaletteIndex_t colourFlash0{}, colourFlash1{}, colour0{}, colour1{}; auto tile = TileManager::get(pos); for (auto& el : tile) { switch (el.type()) { case ElementType::surface: { auto* surfaceEl = el.as<SurfaceElement>(); if (surfaceEl == nullptr) { continue; } if (surfaceEl->water() == 0) { const auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); const auto* landImage = Gfx::getG1Element(landObj->mapPixelImage); auto offset = surfaceEl->baseZ() / kMicroToSmallZStep * 2; colourFlash0 = landImage->offset[offset]; colourFlash1 = landImage->offset[offset + 1]; } else { const auto* waterObj = ObjectManager::get<WaterObject>(); const auto* waterImage = Gfx::getG1Element(waterObj->mapPixelImage); auto offset = (surfaceEl->water() * kMicroToSmallZStep - surfaceEl->baseZ()) / 2; colourFlash0 = waterImage->offset[offset - 2]; colourFlash1 = waterImage->offset[offset - 1]; } colour0 = colourFlash0; colour1 = colourFlash1; break; } case ElementType::track: if (!el.isGhost() && !el.isAiAllocated()) { auto* trackEl = el.as<TrackElement>(); if (trackEl == nullptr) { continue; } auto* trackObj = ObjectManager::get<TrackObject>(trackEl->trackObjectId()); if (trackObj->hasFlags(TrackObjectFlags::unk_02)) { colour0 = colourFlash0 = PaletteIndex::black2; if (_flashingItems & (1 << 2)) { colourFlash0 = kFlashColours[colourFlash0]; } } else { colour0 = colourFlash0 = PaletteIndex::black7; if (_flashingItems & (1 << 3)) { colourFlash0 = kFlashColours[colourFlash0]; } } colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::station: if (!el.isGhost() && !el.isAiAllocated()) { colour0 = colourFlash0 = PaletteIndex::orange8; if (_flashingItems & (1 << 4)) { colourFlash0 = kFlashColours[colourFlash0]; } colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::signal: break; case ElementType::building: if (!el.isGhost()) { colour0 = colourFlash0 = PaletteIndex::mutedDarkRed7; if (_flashingItems & (1 << 0)) { colourFlash0 = kFlashColours[colourFlash0]; } colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::tree: if (!el.isGhost()) { colour1 = colourFlash1 = PaletteIndex::green6; if (_flashingItems & (1 << 5)) { colourFlash1 = PaletteIndex::black0; } } break; case ElementType::wall: continue; case ElementType::road: if (!el.isGhost() && !el.isAiAllocated()) { auto* roadEl = el.as<RoadElement>(); if (roadEl == nullptr) { continue; } auto* roadObj = ObjectManager::get<RoadObject>(roadEl->roadObjectId()); if (roadObj->hasFlags(RoadObjectFlags::unk_01)) { colour0 = colourFlash0 = PaletteIndex::black7; if (_flashingItems & (1 << 3)) { colourFlash0 = kFlashColours[colourFlash0]; } } else { colour0 = colourFlash0 = PaletteIndex::black2; if (_flashingItems & (1 << 2)) { colourFlash0 = kFlashColours[colourFlash0]; } } colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::industry: if (!el.isGhost()) { colour0 = colourFlash0 = PaletteIndex::mutedPurple7; if (_flashingItems & (1 << 1)) { colourFlash0 = kFlashColours[colourFlash0]; } colourFlash1 = colourFlash0; colour1 = colour0; } break; }; } mapPtr[0] = colour0; mapPtr[1] = colour1; mapAltPtr[0] = colourFlash0; mapAltPtr[1] = colourFlash1; pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; } _drawMapRowIndex++; if (_drawMapRowIndex > kMapColumns) { _drawMapRowIndex = 0; } } // 0x0046C873 static void setMapPixelsVehicles(PaletteIndex_t* mapPtr, PaletteIndex_t* mapAltPtr, Pos2 pos, Pos2 delta) { for (auto rowCountLeft = kMapColumns; rowCountLeft > 0; rowCountLeft--) { // Coords shouldn't be at map edge if (!(pos.x > 0 && pos.y > 0 && pos.x < kMapWidth - kTileSize && pos.y < kMapHeight - kTileSize)) { pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; continue; } PaletteIndex_t colourFlash0{}, colourFlash1{}, colour0{}, colour1{}; auto tile = TileManager::get(pos); for (auto& el : tile) { switch (el.type()) { case ElementType::surface: { auto* surfaceEl = el.as<SurfaceElement>(); if (surfaceEl == nullptr) { continue; } if (surfaceEl->water() == 0) { const auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); const auto* landImage = Gfx::getG1Element(landObj->mapPixelImage); colourFlash0 = colourFlash1 = landImage->offset[0]; } else { const auto* waterObj = ObjectManager::get<WaterObject>(); const auto* waterImage = Gfx::getG1Element(waterObj->mapPixelImage); colourFlash0 = colourFlash1 = waterImage->offset[0]; } colour0 = colour1 = colourFlash0; break; } case ElementType::track: case ElementType::station: case ElementType::road: if (!el.isGhost() && !el.isAiAllocated()) { colour0 = colourFlash0 = PaletteIndex::black2; colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::building: case ElementType::industry: if (!el.isGhost()) { colour0 = colourFlash0 = PaletteIndex::mutedDarkRed2; colourFlash1 = colourFlash0; colour1 = colour0; } break; default: break; }; } mapPtr[0] = colour0; mapPtr[1] = colour1; mapAltPtr[0] = colourFlash0; mapAltPtr[1] = colourFlash1; pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; } _drawMapRowIndex++; if (_drawMapRowIndex > kMapColumns) { _drawMapRowIndex = 0; } } // 0x004FB464 // clang-format off static constexpr std::array<PaletteIndex_t, 31> kIndustryColours = { PaletteIndex::black0, PaletteIndex::black4, PaletteIndex::blackB, PaletteIndex::mutedOliveGreen9, PaletteIndex::mutedDarkYellow7, PaletteIndex::yellow7, PaletteIndex::yellowA, PaletteIndex::mutedDarkRed5, PaletteIndex::mutedDarkRed9, PaletteIndex::mutedGrassGreen5, PaletteIndex::mutedGrassGreenA, PaletteIndex::mutedAvocadoGreen6, PaletteIndex::green8, PaletteIndex::mutedOrange7, PaletteIndex::mutedPurple7, PaletteIndex::blue3, PaletteIndex::blue7, PaletteIndex::purple3, PaletteIndex::purple7, PaletteIndex::purple9, PaletteIndex::red6, PaletteIndex::orange6, PaletteIndex::orange9, PaletteIndex::mutedDarkTeal5, PaletteIndex::mutedDarkTeal8, PaletteIndex::pink6, PaletteIndex::pink9, PaletteIndex::brown5, PaletteIndex::brown8, PaletteIndex::mutedDarkYellow2, PaletteIndex::black8, }; // clang-format on // 0x0046C9A8 static void setMapPixelsIndustries(PaletteIndex_t* mapPtr, PaletteIndex_t* mapAltPtr, Pos2 pos, Pos2 delta) { for (auto rowCountLeft = kMapColumns; rowCountLeft > 0; rowCountLeft--) { // Coords shouldn't be at map edge if (!(pos.x > 0 && pos.y > 0 && pos.x < kMapWidth - kTileSize && pos.y < kMapHeight - kTileSize)) { pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; continue; } PaletteIndex_t colourFlash0{}, colourFlash1{}, colour0{}, colour1{}; auto tile = TileManager::get(pos); for (auto& el : tile) { switch (el.type()) { case ElementType::surface: { auto* surfaceEl = el.as<SurfaceElement>(); if (surfaceEl == nullptr) { continue; } if (surfaceEl->water() > 0) { const auto* waterObj = ObjectManager::get<WaterObject>(); const auto* waterImage = Gfx::getG1Element(waterObj->mapPixelImage); colour0 = colour1 = colourFlash0 = colourFlash1 = waterImage->offset[0]; } else { const auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); const auto* landImage = Gfx::getG1Element(landObj->mapPixelImage); colour0 = colour1 = colourFlash0 = colourFlash1 = landImage->offset[0]; } if (surfaceEl->isIndustrial()) { const auto* industry = IndustryManager::get(surfaceEl->industryId()); const auto colourIndex = _assignedIndustryColours[industry->objectId]; colour0 = colourFlash0 = kIndustryColours[colourIndex]; if (_flashingItems & (1 << industry->objectId)) { colourFlash0 = PaletteIndex::black0; } } break; } case ElementType::building: // Vanilla omitted the ghost check if (!el.isGhost()) { colour0 = colourFlash0 = PaletteIndex::mutedDarkRed2; colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::industry: { if (el.isGhost()) { continue; } auto* industryEl = el.as<IndustryElement>(); if (industryEl == nullptr) { continue; } const auto* industry = IndustryManager::get(industryEl->industryId()); const auto colourIndex = _assignedIndustryColours[industry->objectId]; colourFlash0 = colourFlash1 = colour0 = colour1 = kIndustryColours[colourIndex]; if (_flashingItems & (1 << industry->objectId)) { colourFlash0 = colourFlash1 = PaletteIndex::black0; } break; } case ElementType::track: case ElementType::station: case ElementType::road: { if (el.isGhost() || el.isAiAllocated()) { continue; } colour0 = colour1 = colourFlash1 = colourFlash0 = PaletteIndex::black2; break; } default: break; }; } mapPtr[0] = colour0; mapPtr[1] = colour1; mapAltPtr[0] = colourFlash0; mapAltPtr[1] = colourFlash1; pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; } _drawMapRowIndex++; if (_drawMapRowIndex > kMapColumns) { _drawMapRowIndex = 0; } } // 0x0046CB68 static void setMapPixelsRoutes(PaletteIndex_t* mapPtr, PaletteIndex_t* mapAltPtr, Pos2 pos, Pos2 delta) { for (auto rowCountLeft = kMapColumns; rowCountLeft > 0; rowCountLeft--) { // Coords shouldn't be at map edge if (!(pos.x > 0 && pos.y > 0 && pos.x < kMapWidth - kTileSize && pos.y < kMapHeight - kTileSize)) { pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; continue; } bool haveTrackOrRoad = false; // ch PaletteIndex_t colourFlash0{}, colourFlash1{}, colour0{}, colour1{}; auto tile = TileManager::get(pos); for (auto& el : tile) { switch (el.type()) { case ElementType::surface: { auto* surfaceEl = el.as<SurfaceElement>(); if (surfaceEl == nullptr) { continue; } uint8_t terrainColour0{}, terrainColour1{}; if (surfaceEl->water() == 0) { const auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); const auto* landImage = Gfx::getG1Element(landObj->mapPixelImage); terrainColour0 = landImage->offset[0]; terrainColour1 = landImage->offset[1]; } else { const auto* waterObj = ObjectManager::get<WaterObject>(); const auto* waterImage = Gfx::getG1Element(waterObj->mapPixelImage); terrainColour0 = waterImage->offset[0]; terrainColour1 = waterImage->offset[1]; } colour0 = colourFlash0 = terrainColour0; if (!haveTrackOrRoad) { colour1 = colourFlash1 = terrainColour1; } break; } case ElementType::building: case ElementType::industry: if (!el.isGhost()) { colour0 = colourFlash0 = PaletteIndex::mutedDarkRed2; colourFlash1 = colourFlash0; colour1 = colour0; } break; case ElementType::track: { if (el.isGhost() || el.isAiAllocated()) { continue; } auto* trackEl = el.as<TrackElement>(); if (trackEl == nullptr) { continue; } auto trackObjectId = trackEl->trackObjectId(); colourFlash0 = colour0 = _trackColours[trackObjectId]; auto firstFlashable = Numerics::bitScanForward(_flashingItems); if (firstFlashable != -1) { if (_routeToObjectIdMap[firstFlashable] == trackObjectId) { colourFlash0 = kFlashColours[colourFlash0]; } } colourFlash1 = colourFlash0; colour1 = colour0; haveTrackOrRoad = true; break; } case ElementType::station: { if (!el.isGhost() && !el.isAiAllocated()) { colour1 = colourFlash1 = colour0 = colourFlash0 = PaletteIndex::orange8; } break; } case ElementType::road: { if (el.isGhost() || el.isAiAllocated()) { continue; } auto* roadEl = el.as<RoadElement>(); if (roadEl == nullptr) { continue; } colourFlash0 = colour0 = _roadColours[roadEl->roadObjectId()]; auto firstFlashable = Numerics::bitScanForward(_flashingItems); if (firstFlashable != -1) { if (_routeToObjectIdMap[firstFlashable] == (roadEl->roadObjectId() | (1 << 7))) { colourFlash0 = kFlashColours[colourFlash0]; } } colour1 = colour0; colourFlash1 = colourFlash0; haveTrackOrRoad = true; break; } default: break; }; } mapPtr[0] = colour0; mapPtr[1] = colour1; mapAltPtr[0] = colourFlash0; mapAltPtr[1] = colourFlash1; pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; } _drawMapRowIndex++; if (_drawMapRowIndex > kMapColumns) { _drawMapRowIndex = 0; } } // 0x0046CD31 static void setMapPixelsOwnership(PaletteIndex_t* mapPtr, PaletteIndex_t* mapAltPtr, Pos2 pos, Pos2 delta) { for (auto rowCountLeft = kMapColumns; rowCountLeft > 0; rowCountLeft--) { // Coords shouldn't be at map edge if (!(pos.x > 0 && pos.y > 0 && pos.x < kMapWidth - kTileSize && pos.y < kMapHeight - kTileSize)) { pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; continue; } bool haveTrackOrRoad = false; // ch PaletteIndex_t colourFlash0{}, colourFlash1{}, colour0{}, colour1{}; auto tile = TileManager::get(pos); for (auto& el : tile) { switch (el.type()) { case ElementType::surface: { auto* surfaceEl = el.as<SurfaceElement>(); if (surfaceEl == nullptr) { continue; } uint8_t terrainColour0{}, terrainColour1{}; if (surfaceEl->water() == 0) { const auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); const auto* landImage = Gfx::getG1Element(landObj->mapPixelImage); terrainColour0 = landImage->offset[0]; terrainColour1 = landImage->offset[1]; } else { const auto* waterObj = ObjectManager::get<WaterObject>(); const auto* waterImage = Gfx::getG1Element(waterObj->mapPixelImage); terrainColour0 = waterImage->offset[0]; terrainColour1 = waterImage->offset[1]; } colour0 = colourFlash0 = terrainColour0; if (!haveTrackOrRoad) { colour1 = colourFlash1 = terrainColour1; } break; } case ElementType::track: case ElementType::station: case ElementType::road: { if (el.isGhost() || el.isAiAllocated()) { continue; } auto owner = CompanyId::null; if (auto* stationEl = el.as<StationElement>()) { auto station = StationManager::get(stationEl->stationId()); owner = station->owner; } else if (auto* trackEl = el.as<TrackElement>()) { owner = trackEl->owner(); } else if (auto* roadEl = el.as<RoadElement>()) { owner = roadEl->owner(); } if (owner != CompanyId::neutral) { auto companyColour = CompanyManager::getCompanyColour(owner); colourFlash1 = colourFlash0 = colour1 = colour0 = Colours::getShade(companyColour, 5); if (_flashingItems & (1 << enumValue(owner))) { colourFlash1 = colourFlash0 = kFlashColours[colour0]; } haveTrackOrRoad = true; break; } [[fallthrough]]; } case ElementType::building: case ElementType::industry: // Vanilla omitted the ghost check if (!el.isGhost()) { colour0 = colour1 = colourFlash1 = colourFlash0 = PaletteIndex::black1; } break; default: break; }; } mapPtr[0] = colour0; mapPtr[1] = colour1; mapAltPtr[0] = colourFlash0; mapAltPtr[1] = colourFlash1; pos += delta; mapPtr += kRenderedMapWidth + 1; mapAltPtr += kRenderedMapWidth + 1; } _drawMapRowIndex++; if (_drawMapRowIndex > kMapColumns) { _drawMapRowIndex = 0; } } // 0x0046C544 static void setMapPixels(const Window& self) { _flashingItems = self.var_854; auto offset = _drawMapRowIndex * (kRenderedMapWidth - 1) + (kMapRows - 1); auto* mapPtr = &_mapPixels[offset]; auto* mapAltPtr = &_mapAltPixels[offset]; Pos2 pos{}; Pos2 delta{}; switch (WindowManager::getCurrentRotation()) { case 0: pos = Pos2(_drawMapRowIndex * kTileSize, 0); delta = { 0, kTileSize }; break; case 1: pos = Pos2(kMapWidth - kTileSize, _drawMapRowIndex * kTileSize); delta = { -kTileSize, 0 }; break; case 2: pos = Pos2((kMapColumns - 1 - _drawMapRowIndex) * kTileSize, kMapWidth - kTileSize); delta = { 0, -kTileSize }; break; case 3: pos = Pos2(0, (kMapColumns - 1 - _drawMapRowIndex) * kTileSize); delta = { kTileSize, 0 }; break; } switch (self.currentTab) { case 0: setMapPixelsOverall(mapPtr, mapAltPtr, pos, delta); return; case 1: setMapPixelsVehicles(mapPtr, mapAltPtr, pos, delta); return; case 2: setMapPixelsIndustries(mapPtr, mapAltPtr, pos, delta); return; case 3: setMapPixelsRoutes(mapPtr, mapAltPtr, pos, delta); return; case 4: setMapPixelsOwnership(mapPtr, mapAltPtr, pos, delta); return; } } // 0x0046D34D based on static void setHoverItem(Window* self, int16_t y, int index) { uint32_t itemHover; if (y < 0) { itemHover = (1 << index); } else { itemHover = 0; } if (itemHover != self->var_854) { self->var_854 = itemHover; self->invalidate(); } if (self->var_854 != 0) { self->invalidate(); } } static uint8_t legendWidth = 100; static uint8_t legendItemHeight = 10; static constexpr uint8_t kOverallGraphKeySize = 6; static std::array<size_t, 5> legendLengths = { { kOverallGraphKeySize, std::size(_vehicleTypeCounts), ObjectManager::getMaxObjects(ObjectType::industry), 0, Limits::kMaxCompanies, } }; static void setHoverItemTab(Window* self, int16_t legendLeft, int16_t legendBottom) { if (Input::hasFlag(Input::Flags::rightMousePressed)) { return; } auto cursorPos = Input::getMouseLocation2(); auto window = WindowManager::findAt(cursorPos); if (window != self) { return; } cursorPos.x -= legendLeft; if (cursorPos.x < 0 || cursorPos.x > legendWidth) { setHoverItem(self, 0, 0); return; } cursorPos.y -= legendBottom; uint8_t i = 0; int16_t y = 0; if (self->currentTab == (widx::tabRoutes - widx::tabOverall)) { y = cursorPos.y; for (; _routeToObjectIdMap[i] != 0xFF; i++) { y -= legendItemHeight; if (y < 0) { break; } } } else if (cursorPos.y < static_cast<int16_t>(legendLengths[self->currentTab] * legendItemHeight)) { y = cursorPos.y; for (; i < legendLengths[self->currentTab]; i++) { if (self->currentTab == (widx::tabIndustries - widx::tabOverall)) { auto industryObj = ObjectManager::get<IndustryObject>(i); if (industryObj == nullptr) { continue; } } else if (self->currentTab == (widx::tabOwnership - widx::tabOverall)) { auto company = CompanyManager::get(CompanyId(i)); if (company->empty()) { continue; } } y -= legendItemHeight; if (y < 0) { break; } } } setHoverItem(self, y, i); } // 0x0046B69C static void clearMap() { std::fill(_mapPixels, _mapPixels + kRenderedMapSize * 2, PaletteIndex::black0); } // 0x00F2541D static uint16_t mapFrameNumber = 0; // 0x0046BA5B static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::map, self.number, self.currentTab + widx::tabOverall); mapFrameNumber++; if (getCurrentRotation() != self.var_846) { self.var_846 = getCurrentRotation(); clearMap(); } auto i = 80; while (i > 0) { setMapPixels(self); i--; } self.invalidate(); auto x = self.x + self.width - 104; auto y = self.y + 44; setHoverItemTab(&self, x, y); } // 0x0046B9E7 static void getScrollSize([[maybe_unused]] Window& self, [[maybe_unused]] uint32_t scrollIndex, int32_t& scrollWidth, int32_t& scrollHeight) { scrollWidth = kRenderedMapWidth; scrollHeight = kRenderedMapHeight; } // 0x0046B9D4 static void moveMainViewToMapView(Pos2 pos) { auto z = TileManager::getHeight(pos).landHeight; auto window = WindowManager::getMainWindow(); if (window == nullptr) { return; } window->viewportCentreOnTile({ static_cast<coord_t>(pos.x), static_cast<coord_t>(pos.y), static_cast<coord_t>(z) }); } // 0x0046B97C static void scrollMouseDown([[maybe_unused]] Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { auto pos = mapWindowPosToLocation({ x, y }); moveMainViewToMapView(pos); } // 0x0046B946 static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_map); return args; } // 0x0046B6BF static void prepareDraw(Window& self) { const StringId captionText[] = { StringIds::title_map, StringIds::title_map_vehicles, StringIds::title_map_industries, StringIds::title_map_routes, StringIds::title_map_companies, }; self.widgets[widx::caption].text = captionText[self.currentTab]; auto activatedWidgets = self.activatedWidgets; activatedWidgets &= ~((1ULL << widx::statusBar) | (1ULL << widx::scrollview) | (1ULL << widx::tabOwnership) | (1ULL << widx::tabRoutes) | (1ULL << widx::tabIndustries) | (1ULL << widx::tabVehicles) | (1ULL << widx::tabOverall)); auto currentWidget = self.currentTab + widx::tabOverall; activatedWidgets |= (1ULL << currentWidget); self.activatedWidgets = activatedWidgets; self.widgets[widx::frame].right = self.width - 1; self.widgets[widx::frame].bottom = self.height - 1; self.widgets[widx::panel].right = self.width - 1; self.widgets[widx::panel].bottom = self.height - 1; self.widgets[widx::caption].right = self.width - 2; self.widgets[widx::closeButton].left = self.width - 15; self.widgets[widx::closeButton].right = self.width - 3; self.widgets[widx::scrollview].bottom = self.height - 14; self.widgets[widx::scrollview].right = self.width - 108; self.widgets[widx::statusBar].top = self.height - 12; self.widgets[widx::statusBar].bottom = self.height - 3; self.widgets[widx::statusBar].right = self.width - 14; auto disabledWidgets = 0; if (SceneManager::isEditorMode()) { disabledWidgets |= (1 << widx::tabVehicles) | (1 << widx::tabRoutes) | (1 << widx::tabOwnership); } self.disabledWidgets = disabledWidgets; Widget::leftAlignTabs(self, widx::tabOverall, widx::tabOwnership); } // 0x0046D0E0 static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // tabOverall { // TODO: use same list as top toolbar and time panel static constexpr uint32_t kMapSpritesByRotation[] = { InterfaceSkin::ImageIds::toolbar_menu_map_north, InterfaceSkin::ImageIds::toolbar_menu_map_west, InterfaceSkin::ImageIds::toolbar_menu_map_south, InterfaceSkin::ImageIds::toolbar_menu_map_east, }; uint32_t mapSprite = skin->img + kMapSpritesByRotation[WindowManager::getCurrentRotation()]; Widget::drawTab(self, drawingCtx, mapSprite, widx::tabOverall); } // tabVehicles, { if (!(self.disabledWidgets & (1 << widx::tabVehicles))) { static constexpr uint32_t vehicleImageIds[] = { InterfaceSkin::ImageIds::vehicle_train_frame_0, InterfaceSkin::ImageIds::vehicle_train_frame_1, InterfaceSkin::ImageIds::vehicle_train_frame_2, InterfaceSkin::ImageIds::vehicle_train_frame_3, InterfaceSkin::ImageIds::vehicle_train_frame_4, InterfaceSkin::ImageIds::vehicle_train_frame_5, InterfaceSkin::ImageIds::vehicle_train_frame_6, InterfaceSkin::ImageIds::vehicle_train_frame_7, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tabVehicles - widx::tabOverall) { imageId += vehicleImageIds[(self.frameNo / 2) % std::size(vehicleImageIds)]; } else { imageId += vehicleImageIds[0]; } auto colour = Colour::black; if (!SceneManager::isEditorMode() && !SceneManager::isSandboxMode()) { auto company = CompanyManager::getPlayerCompany(); colour = company->mainColours.primary; } imageId = Gfx::recolour(imageId, colour); Widget::drawTab(self, drawingCtx, imageId, widx::tabVehicles); } } // tabIndustries, { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_industries; Widget::drawTab(self, drawingCtx, imageId, widx::tabIndustries); } // tabRoutes, { if (!(self.disabledWidgets & (1 << widx::tabRoutes))) { static constexpr uint32_t routeImageIds[] = { InterfaceSkin::ImageIds::tab_routes_frame_0, InterfaceSkin::ImageIds::tab_routes_frame_1, InterfaceSkin::ImageIds::tab_routes_frame_2, InterfaceSkin::ImageIds::tab_routes_frame_3, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tabRoutes - widx::tabOverall) { imageId += routeImageIds[(self.frameNo / 16) % std::size(routeImageIds)]; } else { imageId += routeImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tabRoutes); } } // tabOwnership, { if (!(self.disabledWidgets & (1 << widx::tabOwnership))) { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::tab_companies; Widget::drawTab(self, drawingCtx, imageId, widx::tabOwnership); } } } // 0x0046D273 static void drawGraphKeyOverall(Window* self, Gfx::DrawingContext& drawingCtx, uint16_t x, uint16_t& y) { static constexpr PaletteIndex_t overallColours[] = { PaletteIndex::mutedDarkRed7, PaletteIndex::mutedPurple7, PaletteIndex::black2, PaletteIndex::black7, PaletteIndex::orange8, PaletteIndex::green6, }; static constexpr StringId lineNames[] = { StringIds::map_key_towns, StringIds::map_key_industries, StringIds::map_key_roads, StringIds::map_key_railways, StringIds::map_key_stations, StringIds::map_key_vegetation, }; auto tr = Gfx::TextRenderer(drawingCtx); for (auto i = 0; i < kOverallGraphKeySize; i++) { auto colour = overallColours[i]; if (!(self->var_854 & (1 << i)) || !(mapFrameNumber & (1 << 2))) { drawingCtx.drawRect(x, y + 3, 5, 5, colour, Gfx::RectFlags::none); } FormatArguments args{}; args.push(lineNames[i]); auto stringId = StringIds::small_black_string; if (self->var_854 & (1 << i)) { stringId = StringIds::small_white_string; } auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; } } // 0x004FDD62 static constexpr PaletteIndex_t vehicleTypeColours[] = { PaletteIndex::red7, PaletteIndex::green9, PaletteIndex::purple8, PaletteIndex::orangeA, PaletteIndex::blackB, PaletteIndex::orange6, // changed from 136 to make ships more viewable on the map }; // 0x0046D379 static void drawGraphKeyVehicles(Window* self, Gfx::DrawingContext& drawingCtx, uint16_t x, uint16_t& y) { static constexpr StringId lineNames[] = { StringIds::forbid_trains, StringIds::forbid_buses, StringIds::forbid_trucks, StringIds::forbid_trams, StringIds::forbid_aircraft, StringIds::forbid_ships, }; auto tr = Gfx::TextRenderer(drawingCtx); for (uint8_t i = 0; i < std::size(_vehicleTypeCounts); i++) { if (!(self->var_854 & (1 << i)) || !(mapFrameNumber & (1 << 2))) { auto colour = vehicleTypeColours[i]; drawingCtx.drawRect(x, y + 3, 5, 5, colour, Gfx::RectFlags::none); } FormatArguments args{}; args.push(lineNames[i]); auto stringId = StringIds::small_black_string; if (self->var_854 & (1 << i)) { stringId = StringIds::small_white_string; } auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; } } // 0x0046D47F static void drawGraphKeyIndustries(Window* self, Gfx::DrawingContext& drawingCtx, uint16_t x, uint16_t& y) { auto tr = Gfx::TextRenderer(drawingCtx); for (uint8_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::industry); i++) { auto industry = ObjectManager::get<IndustryObject>(i); if (industry == nullptr) { continue; } if (!(self->var_854 & (1 << i)) || !(mapFrameNumber & (1 << 2))) { auto colour = kIndustryColours[_assignedIndustryColours[i]]; drawingCtx.drawRect(x, y + 3, 5, 5, colour, Gfx::RectFlags::none); } FormatArguments args{}; args.push(industry->name); auto stringId = StringIds::small_black_string; if (self->var_854 & (1 << i)) { stringId = StringIds::small_white_string; } auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; } } // 0x0046D5A4 static void drawGraphKeyRoutes(Window* self, Gfx::DrawingContext& drawingCtx, uint16_t x, uint16_t& y) { auto tr = Gfx::TextRenderer(drawingCtx); for (auto i = 0; _routeToObjectIdMap[i] != 0xFF; i++) { auto index = _routeToObjectIdMap[i]; auto colour = _routeColours[i]; if (!(self->var_854 & (1 << i)) || !(mapFrameNumber & (1 << 2))) { drawingCtx.drawRect(x, y + 3, 5, 5, colour, Gfx::RectFlags::none); } auto routeType = StringIds::map_routes_aircraft; if (index != 0xFE) { routeType = StringIds::map_routes_ships; if (index != 0xFD) { if (index & (1 << 7)) { auto roadObj = ObjectManager::get<RoadObject>(index & ~(1 << 7)); routeType = roadObj->name; } else { auto trackObj = ObjectManager::get<TrackObject>(index); routeType = trackObj->name; } } } FormatArguments args{}; args.push(routeType); auto stringId = StringIds::small_black_string; if (self->var_854 & (1 << i)) { stringId = StringIds::small_white_string; } auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; } } // 0x0046D6E1 static void drawGraphKeyCompanies(Window* self, Gfx::DrawingContext& drawingCtx, uint16_t x, uint16_t& y) { auto tr = Gfx::TextRenderer(drawingCtx); for (const auto& company : CompanyManager::companies()) { auto index = company.id(); auto colour = Colours::getShade(company.mainColours.primary, 6); if (!(self->var_854 & (1 << enumValue(index))) || !(mapFrameNumber & (1 << 2))) { drawingCtx.drawRect(x, y + 3, 5, 5, colour, Gfx::RectFlags::none); } FormatArguments args{}; args.push(company.name); auto stringId = StringIds::small_black_string; if (self->var_854 & (1 << enumValue(index))) { stringId = StringIds::small_white_string; } auto point = Point(x + 6, y); tr.drawStringLeftClipped(point, 94, Colour::black, stringId, args); y += 10; } } // 0x0046D81F static void formatVehicleString(Window* self, FormatArguments& args) { static constexpr StringId vehicleStringSingular[] = { StringIds::num_trains_singular, StringIds::num_buses_singular, StringIds::num_trucks_singular, StringIds::num_trams_singular, StringIds::num_aircrafts_singular, StringIds::num_ships_singular, }; static constexpr StringId vehicleStringPlural[] = { StringIds::num_trains_plural, StringIds::num_buses_plural, StringIds::num_trucks_plural, StringIds::num_trams_plural, StringIds::num_aircrafts_plural, StringIds::num_ships_plural, }; int16_t vehicleIndex = Numerics::bitScanForward(self->var_854); uint16_t totalVehicleCount = 0; auto stringId = StringIds::status_num_vehicles_plural; if (vehicleIndex == -1) { for (auto i = 0; i < 6; i++) { totalVehicleCount += _vehicleTypeCounts[i]; } if (totalVehicleCount == 1) { stringId = StringIds::status_num_vehicles_singular; } } else { totalVehicleCount = _vehicleTypeCounts[vehicleIndex]; stringId = vehicleStringPlural[vehicleIndex]; if (totalVehicleCount == 1) { stringId = vehicleStringSingular[vehicleIndex]; } } args.push(stringId); args.push(totalVehicleCount); } // 0x0046D87C static void formatIndustryString(Window* self, FormatArguments& args) { int16_t industryIndex = Numerics::bitScanForward(self->var_854); if (industryIndex == -1) { auto industries = IndustryManager::industries(); auto industryCount = std::distance(std::begin(industries), std::end(industries)); auto stringId = StringIds::status_num_industries_plural; if (industryCount == 1) { stringId = StringIds::status_num_industries_singular; } args.push(stringId); args.push(industryCount); } else { auto industryCount = 0; for (const auto& industry : IndustryManager::industries()) { if (industry.objectId == industryIndex) { industryCount++; } } auto industryObj = ObjectManager::get<IndustryObject>(industryIndex); auto stringId = industryObj->namePlural; if (industryCount == 1) { stringId = industryObj->nameSingular; } auto buffer = StringManager::getString(StringIds::buffer_1250); char* ptr = const_cast<char*>(buffer); auto argsBuf = FormatArgumentsBuffer{}; auto argsTmp = FormatArguments{ argsBuf }; argsTmp.push(industryCount); ptr = StringManager::formatString(ptr, stringId, argsTmp); *ptr++ = ' '; *ptr++ = '('; if (industryObj->requiresCargo()) { ptr = StringManager::formatString(ptr, StringIds::industry_require); ptr = industryObj->getRequiredCargoString(ptr); if (industryObj->producesCargo()) { ptr = StringManager::formatString(ptr, StringIds::cargo_to_produce); ptr = industryObj->getProducedCargoString(ptr); } } else if (industryObj->producesCargo()) { ptr = StringManager::formatString(ptr, StringIds::industry_produce); ptr = industryObj->getProducedCargoString(ptr); } *ptr++ = ')'; *ptr = '\0'; args.push(StringIds::buffer_1250); args.push(industryCount); } } // 0x0046B779 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); drawTabs(self, drawingCtx); { auto x = self.x + self.width - 104; uint16_t y = self.y + 44; switch (self.currentTab + widx::tabOverall) { case widx::tabOverall: drawGraphKeyOverall(&self, drawingCtx, x, y); break; case widx::tabVehicles: drawGraphKeyVehicles(&self, drawingCtx, x, y); break; case widx::tabIndustries: drawGraphKeyIndustries(&self, drawingCtx, x, y); break; case widx::tabRoutes: drawGraphKeyRoutes(&self, drawingCtx, x, y); break; case widx::tabOwnership: drawGraphKeyCompanies(&self, drawingCtx, x, y); break; } y -= self.y; y += 14; y = std::max(y, kMinimumWindowHeight); self.minHeight = y; } FormatArguments args{}; switch (self.currentTab + widx::tabOverall) { case widx::tabOverall: case widx::tabRoutes: case widx::tabOwnership: args.push(StringIds::empty); break; case widx::tabVehicles: formatVehicleString(&self, args); break; case widx::tabIndustries: formatIndustryString(&self, args); break; } auto& widget = self.widgets[widx::statusBar]; auto point = Point(self.x + widget.left - 1, self.y + widget.top - 1); auto width = widget.width(); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::black_stringid, args); } // 0x0046BF0F based on static void drawVehicleOnMap(Gfx::DrawingContext& drawingCtx, Vehicles::VehicleBase* vehicle, uint8_t colour) { if (vehicle->position.x == Location::null) { return; } auto trainPos = locationToMapWindowPos(vehicle->position); drawingCtx.fillRect(trainPos.x, trainPos.y, trainPos.x, trainPos.y, colour, Gfx::RectFlags::none); } // 0x0046C294 static std::pair<Point, Point> drawRouteLine(Gfx::DrawingContext& drawingCtx, Point startPos, Point endPos, Pos2 stationPos, uint8_t colour) { auto newStartPos = locationToMapWindowPos({ stationPos.x, stationPos.y }); if (endPos.x != Location::null) { drawingCtx.drawLine(endPos, newStartPos, colour); } endPos = newStartPos; if (startPos.x == Location::null) { startPos = newStartPos; } return std::make_pair(startPos, endPos); } static std::optional<uint8_t> getRouteColour(Vehicles::Vehicle train) { uint8_t colour; if (train.head->vehicleType == VehicleType::aircraft) { colour = 211; auto index = Numerics::bitScanForward(_flashingItems); if (index != -1) { if (_routeToObjectIdMap[index] == 0xFE) { if (mapFrameNumber & (1 << 2)) { colour = kFlashColours[colour]; } } } } else if (train.head->vehicleType == VehicleType::ship) { colour = 139; auto index = Numerics::bitScanForward(_flashingItems); if (index != -1) { if (_routeToObjectIdMap[index] == 0xFD) { if (mapFrameNumber & (1 << 2)) { colour = kFlashColours[colour]; } } } } else { return std::nullopt; } return colour; } // 0x0046C18D static void drawRoutesOnMap(Gfx::DrawingContext& drawingCtx, Vehicles::Vehicle train) { auto colour = getRouteColour(train); if (!colour) { return; } Point startPos = { Location::null, 0 }; Point endPos = { Location::null, 0 }; for (auto& order : Vehicles::OrderRingView(train.head->orderTableOffset)) { if (order.hasFlags(Vehicles::OrderFlags::HasStation)) { auto* stationOrder = static_cast<Vehicles::OrderStation*>(&order); auto station = StationManager::get(stationOrder->getStation()); Pos2 stationPos = { station->x, station->y }; auto routePos = drawRouteLine(drawingCtx, startPos, endPos, stationPos, *colour); startPos = routePos.first; endPos = routePos.second; } } if (startPos.x == Location::null || endPos.x == Location::null) { return; } drawingCtx.drawLine(startPos, endPos, *colour); } // 0x0046C426 static uint8_t getVehicleColour(WidgetIndex_t widgetIndex, Vehicles::Vehicle train, Vehicles::Car car) { auto colour = PaletteIndex::blackB; if (widgetIndex == widx::tabOwnership || widgetIndex == widx::tabVehicles) { auto companyId = car.front->owner; colour = Colours::getShade(CompanyManager::getCompanyColour(companyId), 7); if (widgetIndex == widx::tabVehicles) { auto index = enumValue(train.head->vehicleType); colour = vehicleTypeColours[index]; } // clang-format off auto vehicleType = train.head->vehicleType; if ((widgetIndex == widx::tabOwnership && _flashingItems & (1 << enumValue(companyId))) || (widgetIndex == widx::tabVehicles && _flashingItems & (1 << enumValue(vehicleType)))) { if (mapFrameNumber & (1 << 2)) { colour = kFlashColours[colour]; } } // clang-format on } return colour; } // 0x0046BFAD static void countVehiclesOnMap() { for (auto i = 0; i < 6; i++) { _vehicleTypeCounts[i] = 0; } for (auto* vehicle : VehicleManager::VehicleList()) { Vehicles::Vehicle train(*vehicle); if (train.head->has38Flags(Vehicles::Flags38::isGhost)) { continue; } if (train.head->position.x == Location::null) { continue; } auto vehicleType = train.head->vehicleType; _vehicleTypeCounts[static_cast<uint8_t>(vehicleType)] = _vehicleTypeCounts[static_cast<uint8_t>(vehicleType)] + 1; } } // 0x0046BE6E, 0x0046C35A static void drawVehiclesOnMap(Gfx::DrawingContext& drawingCtx, WidgetIndex_t widgetIndex) { for (auto* vehicle : VehicleManager::VehicleList()) { Vehicles::Vehicle train(*vehicle); if (train.head->has38Flags(Vehicles::Flags38::isGhost)) { continue; } if (train.head->position.x == Location::null) { continue; } for (auto& car : train.cars) { auto colour = getVehicleColour(widgetIndex, train, car); car.applyToComponents([&drawingCtx, colour](auto& component) { drawVehicleOnMap(drawingCtx, &component, colour); }); } if (widgetIndex == widx::tabRoutes) { drawRoutesOnMap(drawingCtx, train); } } } // 0x0046BE51, 0x0046BE34 static void drawRectOnMap(Gfx::DrawingContext& drawingCtx, int16_t left, int16_t top, int16_t right, int16_t bottom, uint8_t colour, Gfx::RectFlags flags) { if (left > right) { std::swap(left, right); } if (top > bottom) { std::swap(top, bottom); } drawingCtx.fillRect(left, top, right, bottom, colour, flags); } // 0x0046BE51 static void drawViewOnMap(Gfx::DrawingContext& drawingCtx, int16_t left, int16_t top, int16_t right, int16_t bottom) { left /= 32; top /= 16; right /= 32; bottom /= 16; left += kViewFrameOffsetsByRotation[getCurrentRotation()].x; top += kViewFrameOffsetsByRotation[getCurrentRotation()].y; right += kViewFrameOffsetsByRotation[getCurrentRotation()].x; bottom += kViewFrameOffsetsByRotation[getCurrentRotation()].y; const auto colour = PaletteIndex::black0; drawRectOnMap(drawingCtx, left, top, right, bottom, colour, Gfx::RectFlags::crossHatching); } // 0x0046BE34 static void drawViewCornersOnMap(Gfx::DrawingContext& drawingCtx, int16_t left, int16_t top, int16_t leftOffset, int16_t topOffset, int16_t rightOffset, int16_t bottomOffset) { left /= 32; top /= 16; left += kViewFrameOffsetsByRotation[getCurrentRotation()].x; top += kViewFrameOffsetsByRotation[getCurrentRotation()].y; auto right = left; auto bottom = top; left += leftOffset; top += topOffset; right += rightOffset; bottom += bottomOffset; const auto colour = PaletteIndex::black0; drawRectOnMap(drawingCtx, left, top, right, bottom, colour, Gfx::RectFlags::none); } // 0x0046BAD5 static void drawViewportPosition(Gfx::DrawingContext& drawingCtx) { auto window = WindowManager::getMainWindow(); if (window == nullptr) { return; } auto viewport = window->viewports[0]; if (viewport == nullptr) { return; } { auto left = viewport->viewX; auto top = viewport->viewY; auto right = viewport->viewX; auto bottom = viewport->viewY; right += viewport->viewWidth; drawViewOnMap(drawingCtx, left, top, right, bottom); } { auto left = viewport->viewX; auto top = viewport->viewY; top += viewport->viewHeight; auto right = viewport->viewX; auto bottom = viewport->viewY; right += viewport->viewWidth; bottom += viewport->viewHeight; drawViewOnMap(drawingCtx, left, top, right, bottom); } { auto left = viewport->viewX; auto top = viewport->viewY; auto right = viewport->viewX; auto bottom = viewport->viewY; bottom += viewport->viewHeight; drawViewOnMap(drawingCtx, left, top, right, bottom); } { auto left = viewport->viewX; auto top = viewport->viewY; left += viewport->viewWidth; auto right = viewport->viewX; auto bottom = viewport->viewY; right += viewport->viewWidth; bottom += viewport->viewHeight; drawViewOnMap(drawingCtx, left, top, right, bottom); } if (!(mapFrameNumber & (1 << 2))) { return; } if (_flashingItems != 0) { return; } uint8_t cornerSize = 5; { auto left = viewport->viewX; auto top = viewport->viewY; drawViewCornersOnMap(drawingCtx, left, top, 0, 0, cornerSize, 0); } { auto left = viewport->viewX; left += viewport->viewWidth; auto top = viewport->viewY; drawViewCornersOnMap(drawingCtx, left, top, -cornerSize, 0, 0, 0); } { auto left = viewport->viewX; auto top = viewport->viewY; drawViewCornersOnMap(drawingCtx, left, top, 0, 0, 0, cornerSize); } { auto left = viewport->viewX; auto top = viewport->viewY; top += viewport->viewHeight; drawViewCornersOnMap(drawingCtx, left, top, 0, -cornerSize, 0, 0); } { auto left = viewport->viewX; auto top = viewport->viewY; top += viewport->viewHeight; drawViewCornersOnMap(drawingCtx, left, top, 0, 0, cornerSize, 0); } { auto left = viewport->viewX; left += viewport->viewWidth; auto top = viewport->viewY; top += viewport->viewHeight; drawViewCornersOnMap(drawingCtx, left, top, -cornerSize, 0, 0, 0); } { auto left = viewport->viewX; left += viewport->viewWidth; auto top = viewport->viewY; drawViewCornersOnMap(drawingCtx, left, top, 0, 0, 0, cornerSize); } { auto left = viewport->viewX; left += viewport->viewWidth; auto top = viewport->viewY; top += viewport->viewHeight; drawViewCornersOnMap(drawingCtx, left, top, 0, -cornerSize, 0, 0); } } // 0x0046C481 static void drawTownNames(Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); for (const auto& town : TownManager::towns()) { auto townPos = locationToMapWindowPos({ town.x, town.y }); char townNameBuffer[512]{}; StringManager::formatString(townNameBuffer, town.name); tr.setCurrentFont(Gfx::Font::small); auto strWidth = tr.getStringWidth(townNameBuffer); strWidth /= 2; townPos.x -= strWidth; townPos.y -= 3; tr.setCurrentFont(Gfx::Font::small); tr.drawString(townPos, AdvancedColour(Colour::purple).outline(), townNameBuffer); } } // 0x0046B806 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { if (!Game::hasFlags(GameStateFlags::tileManagerLoaded)) { return; } drawingCtx.clearSingle(PaletteIndex::black0); auto* element = Gfx::getG1Element(0); auto backupElement = *element; auto* offset = _mapPixels; if (mapFrameNumber & (1 << 2)) { offset = _mapAltPixels; } Gfx::getG1Element(0)->offset = offset; Gfx::getG1Element(0)->width = kMapColumns * 2; Gfx::getG1Element(0)->height = kMapRows * 2; Gfx::getG1Element(0)->xOffset = -8; Gfx::getG1Element(0)->yOffset = -8; Gfx::getG1Element(0)->flags = Gfx::G1ElementFlags::none; drawingCtx.drawImage(0, 0, 0); *element = backupElement; if (self.currentTab + widx::tabOverall == widx::tabVehicles) { countVehiclesOnMap(); } drawVehiclesOnMap(drawingCtx, self.currentTab + widx::tabOverall); drawViewportPosition(drawingCtx); if (self.showTownNames) { drawTownNames(drawingCtx); } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseDrag = scrollMouseDown, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } // 0x0046D0C3 static uint32_t checkIndustryColours(PaletteIndex_t colour, uint32_t colourMask) { for (auto i = 0; i < 31; i++) { auto industryColour = kIndustryColours[i]; auto diff = industryColour - colour; if (industryColour < colour) { diff = -diff; } if (diff <= 2) { colourMask &= ~(1U << i); } } return colourMask; } // 0x0046CFF0 static void assignIndustryColours() { uint32_t availableColours = 0x7FFFFFFF; // First, assign water colour { auto waterObj = ObjectManager::get<WaterObject>(); auto waterPixel = Gfx::getG1Element(waterObj->mapPixelImage)->offset[0]; availableColours = checkIndustryColours(waterPixel, availableColours); waterPixel = Gfx::getG1Element(waterObj->mapPixelImage)->offset[1]; availableColours = checkIndustryColours(waterPixel, availableColours); } // Then, assign surface texture colours for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::land); i++) { auto landObj = ObjectManager::get<LandObject>(i); if (landObj == nullptr) { continue; } auto landPixel = Gfx::getG1Element(landObj->mapPixelImage)->offset[0]; availableColours = checkIndustryColours(landPixel, availableColours); landPixel = Gfx::getG1Element(landObj->mapPixelImage)->offset[1]; availableColours = checkIndustryColours(landPixel, availableColours); } availableColours = checkIndustryColours(PaletteIndex::mutedDarkRed2, availableColours); availableColours = checkIndustryColours(PaletteIndex::black2, availableColours); availableColours = checkIndustryColours(PaletteIndex::black0, availableColours); // Reset assigned industry colours for (auto i = 0U; i < std::size(_assignedIndustryColours); i++) { _assignedIndustryColours[i] = 0xFF; } // Assign preferred industry colours, if possible for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::industry); i++) { auto industryObj = ObjectManager::get<IndustryObject>(i); if (industryObj == nullptr) { continue; } // Preferred colour still available? auto preferredColour = enumValue(industryObj->mapColour); if (availableColours & (1U << preferredColour)) { _assignedIndustryColours[i] = preferredColour; availableColours &= ~(1U << preferredColour); } } // Assign alternative industry colours if needed for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::industry); i++) { auto industryObj = ObjectManager::get<IndustryObject>(i); if (industryObj == nullptr) { continue; } if (_assignedIndustryColours[i] != 0xFF) { continue; } auto freeColour = std::max(0, Numerics::bitScanForward(availableColours)); availableColours &= ~(1U << freeColour); _assignedIndustryColours[i] = freeColour; } } // 0x0046CED0 static void assignRouteColours() { uint32_t availableColours = 0x7FFFFFFF; // First, assign water colour { auto waterObj = ObjectManager::get<WaterObject>(); auto waterPixel = Gfx::getG1Element(waterObj->mapPixelImage)->offset[0]; availableColours = checkIndustryColours(waterPixel, availableColours); waterPixel = Gfx::getG1Element(waterObj->mapPixelImage)->offset[1]; availableColours = checkIndustryColours(waterPixel, availableColours); } // Then, assign surface texture colours for (auto i = 0U; i < ObjectManager::getMaxObjects(ObjectType::land); i++) { auto landObj = ObjectManager::get<LandObject>(i); if (landObj == nullptr) { continue; } auto landPixel = Gfx::getG1Element(landObj->mapPixelImage)->offset[0]; availableColours = checkIndustryColours(landPixel, availableColours); landPixel = Gfx::getG1Element(landObj->mapPixelImage)->offset[1]; availableColours = checkIndustryColours(landPixel, availableColours); } availableColours = checkIndustryColours(PaletteIndex::mutedDarkRed2, availableColours); availableColours = checkIndustryColours(PaletteIndex::orange8, availableColours); availableColours = checkIndustryColours(PaletteIndex::pink9, availableColours); availableColours = checkIndustryColours(PaletteIndex::blue9, availableColours); availableColours = checkIndustryColours(PaletteIndex::black0, availableColours); availableColours = checkIndustryColours(PaletteIndex::blackB, availableColours); auto availableTracks = companyGetAvailableRailTracks(CompanyManager::getControllingId()); auto availableRoads = companyGetAvailableRoads(CompanyManager::getControllingId()); auto i = 0U; auto assignColour = [&i, &availableColours](uint8_t id) { _routeToObjectIdMap[i] = id; auto freeColour = std::max(0, Numerics::bitScanForward(availableColours)); availableColours &= ~(1U << freeColour); auto colour = kIndustryColours[freeColour]; _routeColours[i] = colour; if (id & (1U << 7)) { _roadColours[id & ~(1U << 7)] = colour; } else { _trackColours[id] = colour; } i++; }; for (auto& track : availableTracks) { assignColour(track); } for (auto& road : availableRoads) { assignColour(road); } // Airplanes _routeToObjectIdMap[i] = 0xFE; // Ships _routeToObjectIdMap[i + 1] = 0xFD; // End list _routeToObjectIdMap[i + 2] = 0xFF; // Airplanes _routeColours[i] = 0xD3; // Ships _routeColours[i + 1] = 0x8B; } static const WindowEventList& getEvents(); // 0x0046B490 void open() { auto window = WindowManager::bringToFront(WindowType::map, 0); if (window != nullptr) { return; } auto ptr = malloc(kRenderedMapSize * 2); if (ptr == nullptr) { return; } _mapPixels = static_cast<PaletteIndex_t*>(ptr); _mapAltPixels = &_mapPixels[kRenderedMapSize]; Ui::Size32 size = { 350, 272 }; if (Ui::getLastMapWindowAttributes().flags != WindowFlags::none) { size = { Ui::getLastMapWindowAttributes().size.width, Ui::getLastMapWindowAttributes().size.height }; size.width = std::clamp<uint16_t>(size.width, 350, Ui::width()); size.height = std::clamp<uint16_t>(size.height, 272, Ui::height() - 56); } window = WindowManager::createWindow(WindowType::map, size, WindowFlags::none, getEvents()); window->setWidgets(kWidgets); window->initScrollWidgets(); window->frameNo = 0; if (Ui::getLastMapWindowAttributes().flags != WindowFlags::none) { window->var_88A = Ui::getLastMapWindowAttributes().var88A; window->var_88C = Ui::getLastMapWindowAttributes().var88C; window->flags |= (Ui::getLastMapWindowAttributes().flags & WindowFlags::flag_16); } auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowMapColour); window->var_846 = getCurrentRotation(); clearMap(); centerOnViewPoint(); window->currentTab = 0; window->showTownNames = true; window->var_854 = 0; assignIndustryColours(); assignRouteColours(); mapFrameNumber = 0; } // 0x0046B5C0 void centerOnViewPoint() { auto* mainWindow = WindowManager::getMainWindow(); if (mainWindow == nullptr) { return; } auto* viewport = mainWindow->viewports[0]; if (viewport == nullptr) { return; } auto* window = WindowManager::find(WindowType::map, 0); if (window == nullptr) { return; } // Ensure minimap/scroll widget has been resized window->callPrepareDraw(); const int16_t vpCentreX = ((viewport->viewWidth / 2) + viewport->viewX) / 32; const int16_t vpCentreY = ((viewport->viewHeight / 2) + viewport->viewY) / 16; auto& widget = window->widgets[widx::scrollview]; const int16_t miniMapWidth = widget.width() - ScrollView::kScrollbarSize; const int16_t miniMapHeight = widget.height() - ScrollView::kScrollbarSize; const int16_t visibleMapWidth = window->scrollAreas[0].contentWidth - miniMapWidth; const int16_t visibleMapHeight = window->scrollAreas[0].contentHeight - miniMapHeight; auto& offset = kViewFrameOffsetsByRotation[getCurrentRotation()]; int16_t centreX = std::max(vpCentreX + offset.x - (miniMapWidth / 2), 0); int16_t centreY = std::max(vpCentreY + offset.y - (miniMapHeight / 2), 0); if (visibleMapWidth < centreX) { centreX = std::max(centreX + (visibleMapWidth - centreX), 0); } if (visibleMapHeight < centreY) { centreY = std::max(centreY + (visibleMapHeight - centreY), 0); } window->scrollAreas[0].contentOffsetX = centreX; window->scrollAreas[0].contentOffsetY = centreY; Ui::ScrollView::updateThumbs(*window, widx::scrollview); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/MessageWindow.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Intro.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Message.h" #include "MessageManager.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui.h" #include "Ui/Dropdown.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" namespace OpenLoco::Ui::Windows::MessageWindow { namespace Common { enum widx { frame = 0, caption = 1, close_button = 2, panel = 3, tab_messages, tab_settings, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 366, 175 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_recent_messages), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_message_options)); } static void prepareDraw(Window& self); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void onUpdate(Window& self); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); } namespace Messages { static constexpr Ui::Size32 kMinWindowSize = { 366, 217 }; static constexpr Ui::Size32 kMaxWindowSize = { 366, 1200 }; static int8_t messageHeight = 39; enum widx { scrollview = 6, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(366, 217, StringIds::title_messages), Widgets::ScrollView({ 3, 45 }, { 360, 146 }, WindowColour::secondary, Scrollbars::vertical) ); // 0x0042A6F5 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_messages: case Common::widx::tab_settings: Common::switchTab(self, widgetIndex); break; } } // 0x0042A95A static void onResize(Window& self) { auto scrollview = self.widgets[widx::scrollview]; auto scrollarea = self.scrollAreas[0]; auto y = scrollarea.contentHeight - scrollview.height() - 1; y = std::max(0, y); if (y < scrollarea.contentOffsetY) { scrollarea.contentOffsetY = y; Ui::ScrollView::updateThumbs(self, widx::scrollview); self.invalidate(); } } // 0x0042A847 static void event_08(Window& self) { self.flags |= WindowFlags::notScrollView; } // 0x0042A84F static void event_09(Window& self) { if (!self.hasFlags(WindowFlags::notScrollView)) { return; } if (self.rowHover == -1) { return; } self.rowHover = -1; self.invalidate(); } // 0x0042A871 static void getScrollSize([[maybe_unused]] Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = MessageManager::getNumMessages() * messageHeight; } // 0x0042A8B9 static void scrollMouseDown(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { auto messageIndex = y / messageHeight; if (messageIndex >= MessageManager::getNumMessages()) { return; } if (MessageManager::getActiveIndex() != MessageId::null) { auto message = MessageManager::get(MessageManager::getActiveIndex()); if (message->isActive()) { // If the current active message was user selected then remove from queue of active messages if (message->isUserSelected()) { message->setActive(false); } } } MessageManager::setActiveIndex(MessageId::null); WindowManager::close(WindowType::news, 0); auto message = MessageManager::get(MessageId(messageIndex)); message->setUserSelected(); message->timeActive++; NewsWindow::open(MessageId(messageIndex)); int32_t pan = self.width / 2 + self.x; Audio::playSound(Audio::SoundId::clickDown, pan); } // 0x0042A87C static void scrollMouseOver(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { self.flags &= ~(WindowFlags::notScrollView); auto messageIndex = y / messageHeight; auto messageId = 0xFFFF; if (messageIndex < MessageManager::getNumMessages()) { messageId = messageIndex; } if (self.rowHover != messageId) { self.rowHover = messageId; self.invalidate(); } } // 0x0042A70C static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_message_list); return args; } // 0x0042A545 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; } // 0x0042A5CC static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } // 0x0042A5D7 static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 4); const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(colour); auto height = 0; for (auto i = 0; i < MessageManager::getNumMessages(); i++) { if (height + messageHeight <= rt.y) { height += messageHeight; continue; } else if (height >= rt.y + rt.height) { break; } auto message = MessageManager::get(MessageId(i)); char* buffer = message->messageString; auto str = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); const size_t bufferLength = 512; strncpy(str, buffer, bufferLength); auto stringId = StringIds::black_stringid; if (self.rowHover == i) { drawingCtx.drawRect(0, height, self.width, 38, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); stringId = StringIds::wcolour2_stringid; } { auto args = FormatArguments(); args.push(StringIds::tiny_font_date); args.push(message->date); auto point = Point(0, height); tr.drawStringLeft(point, Colour::black, stringId, args); } { auto args = FormatArguments(); args.push(StringIds::buffer_2039); auto width = self.widgets[widx::scrollview].width() - 14; auto point = Point(0, height + 6); tr.drawStringLeftWrapped(point, width, Colour::black, stringId, args); height += messageHeight; } } } // 0x0042A7B9 static void tabReset(Window& self) { self.minWidth = kMinWindowSize.width; self.minHeight = kMinWindowSize.height; self.maxWidth = kMaxWindowSize.width; self.maxHeight = kMaxWindowSize.height; self.width = kMinWindowSize.width; self.height = kMinWindowSize.height; self.rowHover = -1; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x0042A3FF void open() { auto window = WindowManager::bringToFront(WindowType::messages); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); window = WindowManager::bringToFront(WindowType::messages); } } if (window == nullptr) { int16_t y = 29; int16_t x = Ui::width() - 366; window = WindowManager::createWindow( WindowType::messages, { x, y }, { 366, 217 }, WindowFlags::flag_11, Messages::getEvents()); window->number = 0; window->currentTab = 0; window->frameNo = 0; window->rowHover = -1; window->disabledWidgets = 0; WindowManager::moveOtherWindowsDown(*window); window->minWidth = Messages::kMinWindowSize.width; window->minHeight = Messages::kMinWindowSize.height; window->maxWidth = Messages::kMaxWindowSize.width; window->maxHeight = Messages::kMaxWindowSize.height; window->flags |= WindowFlags::resizable; window->owner = CompanyManager::getControllingId(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, skin->windowPlayerColor); window->width = Messages::kMinWindowSize.width; window->height = Messages::kMinWindowSize.height; } window->currentTab = 0; window->invalidate(); window->setWidgets(Messages::widgets); window->holdableWidgets = 0; window->eventHandlers = &Messages::getEvents(); window->disabledWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); int32_t scrollWidth = 0, scrollHeight = 0; window->callGetScrollSize(0, scrollWidth, scrollHeight); scrollHeight -= window->widgets[Messages::widx::scrollview].height(); if (static_cast<int16_t>(scrollHeight) < 0) { scrollHeight = 0; } window->scrollAreas[0].contentOffsetY = scrollHeight; Ui::ScrollView::updateThumbs(*window, Messages::widx::scrollview); } namespace Settings { static constexpr Ui::Size32 kWindowSize = { 366, 155 }; static constexpr auto kNumWidgetsPerDropdown = 3; enum widx { company_major_news_label = 6, company_major_news, company_major_news_dropdown, competitor_major_news_label, competitor_major_news, competitor_major_news_dropdown, company_minor_news_label, company_minor_news, company_minor_news_dropdown, competitor_minor_news_label, competitor_minor_news, competitor_minor_news_dropdown, general_news_label, general_news, general_news_dropdown, advice_label, advice, advice_dropdown, playSoundEffects, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(366, 155, StringIds::title_messages), Widgets::Label({ 4, 47 }, { 230, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::company_major_news), Widgets::dropdownWidgets({ 236, 47 }, { 124, 12 }, WindowColour::secondary), Widgets::Label({ 4, 62 }, { 230, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::competitor_major_news), Widgets::dropdownWidgets({ 236, 62 }, { 124, 12 }, WindowColour::secondary), Widgets::Label({ 4, 77 }, { 230, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::company_minor_news), Widgets::dropdownWidgets({ 236, 77 }, { 124, 12 }, WindowColour::secondary), Widgets::Label({ 4, 92 }, { 230, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::competitor_minor_news), Widgets::dropdownWidgets({ 236, 92 }, { 124, 12 }, WindowColour::secondary), Widgets::Label({ 4, 107 }, { 230, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::general_news), Widgets::dropdownWidgets({ 236, 107 }, { 124, 12 }, WindowColour::secondary), Widgets::Label({ 4, 122 }, { 230, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::advice), Widgets::dropdownWidgets({ 236, 122 }, { 124, 12 }, WindowColour::secondary), Widgets::Checkbox({ 4, 137 }, { 346, 12 }, WindowColour::secondary, StringIds::playNewsSoundEffects, StringIds::playNewsSoundEffectsTip) ); // 0x0042AA84 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_messages: case Common::widx::tab_settings: Common::switchTab(self, widgetIndex); break; case widx::playSoundEffects: { Config::get().audio.playNewsSounds ^= 1; Config::write(); WindowManager::invalidateWidget(WindowType::messages, self.number, widgetIndex); break; } } } constexpr StringId kNewsDropdownStringIds[] = { StringIds::message_off, StringIds::message_ticker, StringIds::message_window, }; // 0x0042AA9F static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::company_major_news_dropdown: case widx::competitor_major_news_dropdown: case widx::company_minor_news_dropdown: case widx::competitor_minor_news_dropdown: case widx::general_news_dropdown: case widx::advice_dropdown: { auto wIndex = widgetIndex - 1; auto widget = self.widgets[wIndex]; auto xPos = widget.left + self.x; auto yPos = widget.top + self.y; auto width = widget.width() - 2; auto height = widget.height() + 2; auto flags = 1 << 7; Dropdown::show(xPos, yPos, width, height, self.getColour(WindowColour::secondary), 3, flags); for (auto i = 0U; i < std::size(kNewsDropdownStringIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, kNewsDropdownStringIds[i]); } auto ddIndex = wIndex - widx::company_major_news; auto currentItem = Config::get().newsSettings[ddIndex / kNumWidgetsPerDropdown]; Config::write(); Dropdown::setItemSelected(static_cast<size_t>(currentItem)); break; } } } // 0x0042AAAC static void onDropdown([[maybe_unused]] Window& self, Ui::WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case widx::company_major_news_dropdown: case widx::competitor_major_news_dropdown: case widx::company_minor_news_dropdown: case widx::competitor_minor_news_dropdown: case widx::general_news_dropdown: case widx::advice_dropdown: { if (itemIndex == -1) { return; } auto dropdownIndex = (widgetIndex - widx::company_major_news) / kNumWidgetsPerDropdown; auto newValue = static_cast<Config::NewsType>(itemIndex); if (newValue != Config::get().newsSettings[dropdownIndex]) { Config::get().newsSettings[dropdownIndex] = newValue; Config::write(); Gfx::invalidateScreen(); } break; } } } static void prepareDraw(Window& self) { Common::prepareDraw(self); if (Config::get().audio.playNewsSounds) { self.activatedWidgets |= (1 << widx::playSoundEffects); } else { self.activatedWidgets &= ~(1 << widx::playSoundEffects); } for (auto i = 0; i < 6; i++) { auto widgetIndex = widx::company_major_news + (kNumWidgetsPerDropdown * i); auto setting = static_cast<uint8_t>(Config::get().newsSettings[i]); self.widgets[widgetIndex].text = kNewsDropdownStringIds[setting]; } } // 0x0042AA02 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } // 0x0042A7E8 static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; }; static TabInformation tabInformationByTabOffset[] = { { Messages::widgets, widx::tab_messages, Messages::getEvents() }, { Settings::widgets, widx::tab_settings, Settings::getEvents() }, }; static void prepareDraw(Window& self) { // Activate the current tab.. self.activatedWidgets &= ~((1ULL << tab_messages) | (1ULL << tab_settings)); self.activatedWidgets |= (1ULL << tabInformationByTabOffset[self.currentTab].widgetIndex); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; } // 0x0042A716 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_messages; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.viewportRemove(0); const auto& tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_messages]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.disabledWidgets = 0; self.invalidate(); if (self.currentTab == widx::tab_messages - widx::tab_messages) { Messages::tabReset(self); } if (self.currentTab == widx::tab_settings - widx::tab_messages) { Settings::tabReset(self); } self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x0042AB92 static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Message Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::tab_messages; Widget::drawTab(self, drawingCtx, imageId, widx::tab_messages); } // Setting Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::tab_message_settings; Widget::drawTab(self, drawingCtx, imageId, widx::tab_settings); } } // 0x0042A826 and 0x0042AB6A static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::messages, self.number, self.currentTab + Common::widx::tab_messages); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/MusicSelection.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Jukebox.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::MusicSelection { static constexpr Ui::Size32 kWindowSize = { 360, 238 }; static constexpr uint8_t kRowHeight = 12; // CJK: 15 enum widx { frame, title, close, panel, scrollview, }; static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 360, 238 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 358, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::music_selection_title), Widgets::ImageButton({ 345, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 360, 223 }, WindowColour::secondary), Widgets::ScrollView({ 4, 19 }, { 352, 218 }, WindowColour::secondary, Scrollbars::vertical, StringIds::music_selection_tooltip) ); static const WindowEventList& getEvents(); // 0x004C1602 Window* open() { Window* window = WindowManager::bringToFront(WindowType::musicSelection, 0); if (window != nullptr) { return window; } window = WindowManager::createWindow( WindowType::musicSelection, kWindowSize, WindowFlags::none, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowOptionsColour); window->rowCount = Jukebox::kNumMusicTracks; window->rowHover = -1; return window; } // 0x004C165D static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { // Draw widgets. window.draw(drawingCtx); } // 0x004C1663 static void drawScroll(Ui::Window& window, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto shade = Colours::getShade(window.getColour(WindowColour::secondary).c(), 4); drawingCtx.clearSingle(shade); const auto& config = Config::get().audio; uint16_t y = 0; for (uint16_t row = 0; row < window.rowCount; row++) { auto musicTrack = row; // id of music track on this row if (y + kRowHeight < rt.y) { y += kRowHeight; continue; } else if (y > rt.y + rt.height) { break; } StringId textColour = StringIds::black_stringid; // Draw hovered track if (row == window.rowHover) { drawingCtx.drawRect(0, y, 800, kRowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); textColour = StringIds::wcolour2_stringid; } // Draw checkbox. drawingCtx.fillRectInset(2, y, 11, y + 10, window.getColour(WindowColour::secondary), Gfx::RectInsetFlags::colourLight | Gfx::RectInsetFlags::fillDarker | Gfx::RectInsetFlags::borderInset); // Draw checkmark if track is enabled. if (config.customJukebox[musicTrack]) { auto point = Point(2, y); auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(StringIds::checkmark); tr.drawStringLeft(point, window.getColour(WindowColour::secondary), StringIds::wcolour2_stringid, args); } // Draw track name. { auto point = Point(15, y); StringId musicTitle = Jukebox::getMusicInfo(musicTrack).titleId; auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(musicTitle); tr.drawStringLeft(point, window.getColour(WindowColour::secondary), textColour, args); } y += kRowHeight; } } // 0x004C176C static void getScrollSize([[maybe_unused]] Ui::Window& window, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = kRowHeight * Jukebox::kNumMusicTracks; } // 0x004C1757 static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close: WindowManager::close(window.type); break; } } // 0x004C1799 static void onScrollMouseDown(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentTrack = y / kRowHeight; if (currentTrack > window.rowCount) { return; } auto& config = Config::get().audio; // Toggle the track in question. config.customJukebox[currentTrack] ^= true; // Are any tracks enabled? bool anyEnabled = false; for (uint8_t i = 0; i < Jukebox::kNumMusicTracks; i++) { anyEnabled |= config.customJukebox[i]; } // Ensure at least this track is enabled. if (!anyEnabled) { config.customJukebox[currentTrack] = true; } Config::write(); Audio::revalidateCurrentTrack(); window.invalidate(); } // 0x004C1771 static void onScrollMouseOver(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentTrack = y / kRowHeight; if (currentTrack > window.rowCount || currentTrack == window.rowHover) { return; } window.rowHover = currentTrack; window.invalidate(); } // 0x004C17E3 static void onUpdate(Window& window) { auto optionsWindow = WindowManager::find(WindowType::options); if (optionsWindow == nullptr || optionsWindow->currentTab != Options::kTabOffsetMusic) { WindowManager::close(&window); return; } } // 0x004C1762 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_list); return args; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onUpdate = onUpdate, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/NetworkStatus.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/StringIds.h" #include "OpenLoco.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Window.h" #include "Ui/WindowManager.h" #include <string> #include <string_view> namespace OpenLoco::Ui::Windows::NetworkStatus { enum Widx { frame, caption, closeBtn, panel, }; static constexpr Ui::Size32 kWindowSize = { 441, 91 }; static constexpr auto widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 441, 91 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 439, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::empty), Widgets::ImageButton({ 426, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 441, 76 }, WindowColour::secondary) ); static std::string _text; static CloseCallback _cbClose; static const WindowEventList& getEvents(); Window* open(std::string_view text, CloseCallback cbClose) { _text = text; _cbClose = cbClose; auto window = WindowManager::createWindowCentred( WindowType::networkStatus, kWindowSize, WindowFlags::flag_11 | WindowFlags::stickToFront, getEvents()); window->setWidgets(widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, Colour::black); window->setColour(WindowColour::secondary, Colour::black); return window; } void setText(std::string_view text) { _text = text; WindowManager::invalidate(WindowType::networkStatus); } void setText(std::string_view text, CloseCallback cbClose) { _text = text; _cbClose = cbClose; WindowManager::invalidate(WindowType::networkStatus); } void close() { WindowManager::close(WindowType::networkStatus); Gfx::invalidateScreen(); } static void onClose([[maybe_unused]] Ui::Window& window) { if (_cbClose) { _cbClose(); } } static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::closeBtn: WindowManager::close(&window); break; } } static void prepareDraw([[maybe_unused]] Window& self) { StringManager::setString(StringIds::buffer_1250, _text.c_str()); } static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); auto origin = Point(self.x + (self.width / 2), self.y + (self.height / 2)); auto width = self.width; tr.drawStringCentredClipped(origin, width, Colour::black, StringIds::buffer_1250); } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ObjectLoadError.cpp ```cpp #include "Config.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include <fmt/format.h> namespace OpenLoco::Ui::Windows::ObjectLoadError { static constexpr Ui::Size32 kWindowSize = { 360, 238 }; static constexpr uint8_t kRowHeight = 12; // CJK: 15 static std::vector<ObjectHeader> _loadErrorObjectsList; enum Widx { frame, title, close, panel, nameHeader, typeHeader, checksumHeader, scrollview, }; static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 360, 238 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 358, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::objectErrorWindowTitle), Widgets::ImageButton({ 345, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 360, 223 }, WindowColour::secondary), Widgets::TableHeader({ 4, 43 }, { 100, 12 }, WindowColour::secondary, StringIds::tableHeaderObjectId), Widgets::TableHeader({ 104, 43 }, { 152, 12 }, WindowColour::secondary, StringIds::tableHeaderObjectType), Widgets::TableHeader({ 256, 43 }, { 100, 12 }, WindowColour::secondary, StringIds::tableHeaderObjectChecksum), Widgets::ScrollView({ 4, 57 }, { 352, 176 }, WindowColour::secondary, Scrollbars::vertical) ); static const WindowEventList& getEvents(); Window* open(const std::vector<ObjectHeader>& list) { _loadErrorObjectsList = list; std::sort(_loadErrorObjectsList.begin(), _loadErrorObjectsList.end(), [](const auto& lhs, const auto& rhs) { return lhs.getName() < rhs.getName(); }); Window* window = WindowManager::bringToFront(WindowType::objectLoadError); if (window != nullptr) { WindowManager::invalidate(WindowType::objectLoadError); return window; } window = WindowManager::createWindowCentred( WindowType::objectLoadError, kWindowSize, WindowFlags::stickToFront, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowOptionsColour); window->rowCount = static_cast<uint16_t>(_loadErrorObjectsList.size()); window->rowHover = -1; return window; } static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets self.draw(drawingCtx); // Draw explanatory text auto point = Point(self.x + 3, self.y + 19); auto tr = Gfx::TextRenderer(drawingCtx); tr.drawStringLeftWrapped(point, self.width - 6, self.getColour(WindowColour::secondary), StringIds::objectErrorExplanation); } static StringId objectTypeToString(ObjectType type) { switch (type) { case ObjectType::interfaceSkin: return StringIds::object_interface_styles; case ObjectType::sound: return StringIds::object_sounds; case ObjectType::currency: return StringIds::object_currency; case ObjectType::steam: return StringIds::object_animation_effects; case ObjectType::cliffEdge: return StringIds::object_cliffs; case ObjectType::water: return StringIds::object_water; case ObjectType::land: return StringIds::object_land; case ObjectType::townNames: return StringIds::object_town_names; case ObjectType::cargo: return StringIds::object_cargo; case ObjectType::wall: return StringIds::object_walls; case ObjectType::trackSignal: return StringIds::object_signals; case ObjectType::levelCrossing: return StringIds::object_level_crossing; case ObjectType::streetLight: return StringIds::object_street_lights; case ObjectType::tunnel: return StringIds::object_tunnels; case ObjectType::bridge: return StringIds::object_bridges; case ObjectType::trainStation: return StringIds::object_track_stations; case ObjectType::trackExtra: return StringIds::object_track_extras; case ObjectType::track: return StringIds::object_tracks; case ObjectType::roadStation: return StringIds::object_road_stations; case ObjectType::roadExtra: return StringIds::object_road_extras; case ObjectType::road: return StringIds::object_roads; case ObjectType::airport: return StringIds::object_airports; case ObjectType::dock: return StringIds::object_docks; case ObjectType::vehicle: return StringIds::object_vehicles; case ObjectType::tree: return StringIds::object_trees; case ObjectType::snow: return StringIds::object_snow; case ObjectType::climate: return StringIds::object_climate; case ObjectType::hillShapes: return StringIds::object_map_generation_data; case ObjectType::building: return StringIds::object_buildings; case ObjectType::scaffolding: return StringIds::object_scaffolding; case ObjectType::industry: return StringIds::object_industries; case ObjectType::region: return StringIds::object_world_region; case ObjectType::competitor: return StringIds::object_company_owners; case ObjectType::scenarioText: return StringIds::object_scenario_descriptions; default: return StringIds::empty; } } static void drawScroll(Ui::Window& window, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); const auto shade = Colours::getShade(window.getColour(WindowColour::secondary).c(), 4); drawingCtx.clearSingle(shade); // Acquire string buffer auto* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); uint16_t y = 0; auto namePos = Point(1, y); auto typePos = Point(window.widgets[Widx::typeHeader].left - 4, y); auto typeWidth = window.widgets[Widx::typeHeader].width() - 6; auto checksumPos = Point(window.widgets[Widx::checksumHeader].left - 4, y); for (uint16_t i = 0; i < window.rowCount; i++) { if (y + kRowHeight < rt.y) { y += kRowHeight; continue; } else if (y > rt.y + rt.height) { break; } StringId textColourId = StringIds::black_stringid; // Draw hover rectangle if (i == window.rowHover) { drawingCtx.drawRect(0, y, 800, kRowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); textColourId = StringIds::wcolour2_stringid; } auto& header = _loadErrorObjectsList[i]; FormatArguments args{}; args.push(StringIds::buffer_2039); // Copy object name to buffer std::memcpy(buffer, header.name, 8); buffer[8] = '\0'; // Draw object name namePos.y = y; tr.drawStringLeft(namePos, window.getColour(WindowColour::secondary), textColourId, args); // Copy object checksum to buffer const auto checksum = fmt::format("{:08X}", header.checksum); std::memcpy(buffer, checksum.c_str(), 8); buffer[8] = '\0'; // Draw object checksum checksumPos.y = y; tr.drawStringLeft(checksumPos, window.getColour(WindowColour::secondary), textColourId, args); // Prepare object type for drawing args.rewind(); args.push(objectTypeToString(header.getType())); // Draw object type typePos.y = y; tr.drawStringLeftWrapped(typePos, typeWidth, window.getColour(WindowColour::secondary), textColourId, args); y += kRowHeight; } } static void getScrollSize(Ui::Window& window, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = kRowHeight * window.rowCount; } static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::close: WindowManager::close(window.type); break; } } static void onScrollMouseOver(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentTrack = y / kRowHeight; if (currentTrack > window.rowCount || currentTrack == window.rowHover) { return; } window.rowHover = currentTrack; window.invalidate(); } static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_object_list); return args; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .getScrollSize = getScrollSize, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ObjectSelectionWindow.cpp ```cpp #include "Audio/Audio.h" #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Logging.h" #include "Objects/AirportObject.h" #include "Objects/BridgeObject.h" #include "Objects/BuildingObject.h" #include "Objects/CargoObject.h" #include "Objects/CliffEdgeObject.h" #include "Objects/CompetitorObject.h" #include "Objects/CurrencyObject.h" #include "Objects/DockObject.h" #include "Objects/HillShapesObject.h" #include "Objects/IndustryObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/LevelCrossingObject.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "Objects/RegionObject.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/ScaffoldingObject.h" #include "Objects/SnowObject.h" #include "Objects/StreetLightObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainSignalObject.h" #include "Objects/TrainStationObject.h" #include "Objects/TreeObject.h" #include "Objects/TunnelObject.h" #include "Objects/VehicleObject.h" #include "Objects/WallObject.h" #include "Objects/WaterObject.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/TextInput.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TextBoxWidget.h" #include "Ui/Window.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/FileSystem.hpp> #include <OpenLoco/Diagnostics/Logging.h> #include <array> #include <numeric> #include <ranges> #include <vector> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Ui::Windows::ObjectSelectionWindow { static constexpr int kRowHeight = 12; static constexpr Ui::Size32 kWindowSize = { 600, 398 }; enum class ObjectTabFlags : uint8_t { none = 0U, alwaysHidden = 1U << 0, advanced = 1U << 1, hideInGame = 1U << 2, hideInEditor = 1U << 3, showEvenIfSingular = 1U << 4, filterByVehicleType = 1U << 5, }; OPENLOCO_ENABLE_ENUM_OPERATORS(ObjectTabFlags); struct SubTabInfo { StringId name; ObjectType objectType; VehicleType vehicleType; uint32_t baseImage; uint8_t animationLength; uint8_t animationDivisor; ObjectTabFlags flags; }; struct MainTabInfo { StringId name; ObjectType objectType; uint32_t image; std::span<const SubTabInfo> subTabs; ObjectTabFlags flags; }; // clang-format off static constexpr std::array kWorldRegionSubTabs{ SubTabInfo{ StringIds::object_world_region, ObjectType::region, {}, ImageIds::tab_object_world, 1, 1, ObjectTabFlags::none }, SubTabInfo{ StringIds::object_currency, ObjectType::currency, {}, ImageIds::tab_object_currency, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_town_names, ObjectType::townNames, {}, ImageIds::tab_object_town_names, 1, 1, ObjectTabFlags::advanced }, }; static constexpr std::array kVehicleSubTabs{ SubTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, VehicleType::train, InterfaceSkin::ImageIds::tab_vehicle_train_frame0, 8, 1, ObjectTabFlags::none }, SubTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, VehicleType::bus, InterfaceSkin::ImageIds::tab_vehicle_bus_frame0, 8, 1, ObjectTabFlags::none }, SubTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, VehicleType::truck, InterfaceSkin::ImageIds::tab_vehicle_truck_frame0, 8, 1, ObjectTabFlags::none }, SubTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, VehicleType::tram, InterfaceSkin::ImageIds::tab_vehicle_tram_frame0, 8, 1, ObjectTabFlags::none }, SubTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, VehicleType::aircraft, InterfaceSkin::ImageIds::tab_vehicle_aircraft_frame0, 8, 2, ObjectTabFlags::none }, SubTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, VehicleType::ship, InterfaceSkin::ImageIds::tab_vehicle_ship_frame0, 8, 3, ObjectTabFlags::none }, }; static constexpr std::array kLandSubTabs{ SubTabInfo{ StringIds::object_land, ObjectType::land, {}, ImageIds::tab_object_landscape, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_trees, ObjectType::tree, {}, ImageIds::tab_object_trees, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_water, ObjectType::water, {}, ImageIds::tab_object_water, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_walls, ObjectType::wall, {}, ImageIds::tab_object_walls, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_map_generation_data, ObjectType::hillShapes, {}, ImageIds::tab_object_map, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_snow, ObjectType::snow, {}, ImageIds::tab_object_snow, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_climate, ObjectType::climate, {}, ImageIds::tab_object_climate, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_cliffs, ObjectType::cliffEdge, {}, ImageIds::tab_object_cliff, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::alwaysHidden }, }; static constexpr std::array kTrackSubTabs{ SubTabInfo{ StringIds::object_tracks, ObjectType::track, {}, ImageIds::tab_object_track, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_track_stations, ObjectType::trainStation, {}, ImageIds::tab_object_track_stations, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_track_extras, ObjectType::trackExtra, {}, ImageIds::tab_object_track_mods, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::showEvenIfSingular }, SubTabInfo{ StringIds::object_signals, ObjectType::trackSignal, {}, ImageIds::tab_object_signals, 1, 1, ObjectTabFlags::advanced }, }; static constexpr std::array kRoadSubTabs{ SubTabInfo{ StringIds::object_roads, ObjectType::road, {}, ImageIds::tab_object_road, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_road_stations, ObjectType::roadStation, {}, ImageIds::tab_object_road_stations, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_road_extras, ObjectType::roadExtra, {}, ImageIds::tab_object_road_mods, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::showEvenIfSingular }, SubTabInfo{ StringIds::object_level_crossing, ObjectType::levelCrossing, {}, ImageIds::tab_object_level_crossings, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_street_lights, ObjectType::streetLight, {}, ImageIds::tab_object_streetlights, 1, 1, ObjectTabFlags::advanced }, }; static constexpr std::array kBuildingSubTabs{ SubTabInfo{ StringIds::object_buildings, ObjectType::building, {}, ImageIds::tab_object_buildings, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_industries, ObjectType::industry, {}, ImageIds::tab_object_industries, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_scaffolding, ObjectType::scaffolding, {}, ImageIds::tab_object_construction, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_cargo, ObjectType::cargo, {}, ImageIds::tab_object_cargo, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::alwaysHidden }, }; static constexpr std::array kMiscSubTabs{ SubTabInfo{ StringIds::object_interface_styles, ObjectType::interfaceSkin, {}, ImageIds::tab_object_settings, 1, 1, ObjectTabFlags::advanced }, SubTabInfo{ StringIds::object_scenario_descriptions, ObjectType::scenarioText, {}, ImageIds::tab_object_scenarios, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::alwaysHidden }, SubTabInfo{ StringIds::object_animation_effects, ObjectType::steam, {}, ImageIds::tab_object_smoke, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::alwaysHidden }, SubTabInfo{ StringIds::object_sounds, ObjectType::sound, {}, ImageIds::tab_object_audio, 1, 1, ObjectTabFlags::advanced | ObjectTabFlags::alwaysHidden }, }; static constexpr std::array kMainTabInfo{ MainTabInfo{ StringIds::object_world_region, ObjectType::region, ImageIds::tab_object_world, kWorldRegionSubTabs, ObjectTabFlags::none }, MainTabInfo{ StringIds::object_vehicles, ObjectType::vehicle, ImageIds::tab_object_vehicles, kVehicleSubTabs, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_land, ObjectType::land, ImageIds::tab_object_landscape, kLandSubTabs, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_tracks, ObjectType::track, ImageIds::tab_object_track, kTrackSubTabs, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_roads, ObjectType::road, ImageIds::tab_object_road, kRoadSubTabs, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_airports, ObjectType::airport, ImageIds::tab_object_airports, {}, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_docks, ObjectType::dock, ImageIds::tab_object_docks, {}, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_buildings, ObjectType::building, ImageIds::tab_object_buildings, kBuildingSubTabs, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_bridges, ObjectType::bridge, ImageIds::tab_object_bridges, {}, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_tunnels, ObjectType::tunnel, ImageIds::tab_object_tunnels, {}, ObjectTabFlags::advanced | ObjectTabFlags::alwaysHidden }, MainTabInfo{ StringIds::object_interface_styles, ObjectType::interfaceSkin, ImageIds::tab_object_settings, kMiscSubTabs, ObjectTabFlags::advanced }, MainTabInfo{ StringIds::object_company_owners, ObjectType::competitor, ImageIds::tab_object_companies, {}, ObjectTabFlags::hideInEditor }, }; // clang-format on using TabPosition = uint8_t; // Used for TabObjectEntry::display enum class Visibility : uint8_t { hidden = 0, shown = 1, }; // Used for Window::filterLevel enum class FilterLevel : uint8_t { beginner = 0, advanced = 1, expert = 2, }; // Used for Window::var_858 enum class FilterFlags : uint8_t { none = 0, vanilla = 1 << 0, openLoco = 1 << 1, custom = 1 << 2, }; OPENLOCO_ENABLE_ENUM_OPERATORS(FilterFlags); struct TabObjectEntry { ObjectManager::ObjectIndexId index; ObjectManager::ObjectIndexEntry object; Visibility display; }; static loco_global<ObjectManager::SelectedObjectsFlags*, 0x50D144> _objectSelection; static std::span<ObjectManager::SelectedObjectsFlags> getSelectedObjectFlags() { return std::span<ObjectManager::SelectedObjectsFlags>(*_objectSelection, ObjectManager::getNumInstalledObjects()); } // _tabObjectCounts can be integrated after implementing sub_473A95 static loco_global<uint16_t[33], 0x00112C181> _tabObjectCounts; static std::vector<TabObjectEntry> _tabObjectList; static uint16_t _numVisibleObjectsListed; static bool _filterByVehicleType = false; static VehicleType _currentVehicleType; static Ui::TextInput::InputSession inputSession; static void assignTabPositions(Window* self); enum widx { frame, caption, closeButton, panel, primaryTab1, primaryTab2, primaryTab3, primaryTab4, primaryTab5, primaryTab6, primaryTab7, primaryTab8, primaryTab9, primaryTab10, primaryTab11, primaryTab12, filterLabel, filterDropdown, textInput, clearButton, secondaryTab1, secondaryTab2, secondaryTab3, secondaryTab4, secondaryTab5, secondaryTab6, secondaryTab7, secondaryTab8, scrollviewFrame, scrollview, objectImage, }; static constexpr uint8_t kMaxNumPrimaryTabs = 12; static constexpr uint8_t kMaxNumSecondaryTabs = 8; static constexpr auto widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 600, 398 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 598, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::title_object_selection), Widgets::ImageButton({ 585, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 42 }, { 600, 356 }, WindowColour::secondary), // Primary tab area Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 127, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 158, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 189, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 220, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 251, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 282, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 313, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 344, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), // Filter options Widgets::dropdownWidgets({ 492, 20 }, { 100, 12 }, WindowColour::primary, StringIds::empty), Widgets::TextBox({ 4, 45 }, { 246, 14 }, WindowColour::secondary), Widgets::Button({ 254, 45 }, { 38, 14 }, WindowColour::secondary, StringIds::clearInput), // Secondary tabs Widgets::Tab({ 3, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 34, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 65, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 96, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 127, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 158, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 189, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), Widgets::Tab({ 220, 62 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab), // Scroll and preview areas Widgets::Panel({ 3, 83 }, { 290, 303 }, WindowColour::secondary), Widgets::ScrollView({ 4, 85 }, { 288, 300 }, WindowColour::secondary, Scrollbars::vertical), Widgets::ImageButton({ 391, 45 }, { 114, 114 }, WindowColour::secondary) ); template<typename TTabInfo> static bool shouldShowTab(TTabInfo& tabInfo, FilterLevel filterLevel) { const ObjectTabFlags tabFlags = tabInfo.flags; if (filterLevel == FilterLevel::expert) { return true; } if ((tabFlags & ObjectTabFlags::alwaysHidden) != ObjectTabFlags::none) { return false; } // Skip all types that don't have any objects auto objectType = enumValue(tabInfo.objectType); if (_tabObjectCounts[objectType] == 0) { return false; } // Skip certain object types that only have one entry in game if ((tabFlags & ObjectTabFlags::showEvenIfSingular) == ObjectTabFlags::none && _tabObjectCounts[objectType] == 1) { return false; } // Hide advanced object types in beginner mode if (filterLevel == FilterLevel::beginner && (tabFlags & ObjectTabFlags::advanced) != ObjectTabFlags::none) { return false; } if (SceneManager::isEditorMode() && (tabFlags & ObjectTabFlags::hideInEditor) != ObjectTabFlags::none) { return false; } if (!SceneManager::isEditorMode() && (tabFlags & ObjectTabFlags::hideInGame) != ObjectTabFlags::none) { return false; } return true; } static bool shouldShowPrimaryTab(uint8_t index, FilterLevel filterLevel) { return shouldShowTab(kMainTabInfo[index], filterLevel); } static bool shouldShowSubTab(std::span<const SubTabInfo> subTabs, uint8_t index, FilterLevel filterLevel) { return shouldShowTab(subTabs[index], filterLevel); } // 0x00473154 static void assignTabPositions(Window* self) { auto xPos = 3; for (auto i = 0U; i < kMainTabInfo.size(); i++) { auto widgetIndex = widx::primaryTab1 + i; if (shouldShowPrimaryTab(i, FilterLevel(self->filterLevel))) { self->disabledWidgets &= ~(1ULL << widgetIndex); self->widgets[widgetIndex].hidden = false; self->widgets[widgetIndex].left = xPos; self->widgets[widgetIndex].right = xPos + 31; xPos = self->widgets[widgetIndex].right; } else { self->disabledWidgets |= (1ULL << widgetIndex); self->widgets[widgetIndex].hidden = true; } } } static bool contains(const std::string_view& a, const std::string_view& b) { return std::search(a.begin(), a.end(), b.begin(), b.end(), [](char a, char b) { return tolower(a) == tolower(b); }) != a.end(); } static std::optional<VehicleType> getVehicleTypeFromObject(TabObjectEntry& entry) { auto& displayData = entry.object._displayData; if (displayData.vehicleSubType == 0xFF) { Logging::info("Could not load determine vehicle type for object '{}', skipping", entry.object._header.getName()); return std::nullopt; } return static_cast<VehicleType>(displayData.vehicleSubType); } static void applyFilterToObjectList(FilterFlags filterFlags) { std::string_view pattern = inputSession.buffer; _numVisibleObjectsListed = 0; for (auto& entry : _tabObjectList) { // Apply vanilla/custom object filters const bool isVanillaObj = entry.object._header.isVanilla(); const bool isOpenLocoObj = entry.object._header.getSourceGame() == SourceGame::openLoco; const bool isCustomObj = !isVanillaObj && !isOpenLocoObj; if (isVanillaObj && (filterFlags & FilterFlags::vanilla) == FilterFlags::none) { entry.display = Visibility::hidden; continue; } if (isOpenLocoObj && (filterFlags & FilterFlags::openLoco) == FilterFlags::none) { entry.display = Visibility::hidden; continue; } if (isCustomObj && (filterFlags & FilterFlags::custom) == FilterFlags::none) { entry.display = Visibility::hidden; continue; } if (_filterByVehicleType) { auto vehicleType = getVehicleTypeFromObject(entry); if (vehicleType != _currentVehicleType) { entry.display = Visibility::hidden; continue; } } if (pattern.empty()) { entry.display = Visibility::shown; _numVisibleObjectsListed++; continue; } const std::string_view name = entry.object._name; const auto filename = fs::u8path(entry.object._filepath).filename().u8string(); const bool containsName = contains(name, pattern); const bool containsFileName = contains(filename, pattern); entry.display = containsName || containsFileName ? Visibility::shown : Visibility::hidden; if (entry.display == Visibility::shown) { _numVisibleObjectsListed++; } } } static void populateTabObjectList(ObjectType objectType, FilterFlags filterFlags) { _tabObjectList.clear(); const auto objects = ObjectManager::getAvailableObjects(objectType); _tabObjectList.reserve(objects.size()); for (auto& [index, object] : objects) { auto entry = TabObjectEntry{ index, object, Visibility::shown }; _tabObjectList.emplace_back(std::move(entry)); } applyFilterToObjectList(filterFlags); } // 0x00472BBC static ObjectManager::ObjIndexPair getFirstAvailableSelectedObject([[maybe_unused]] Window* self) { const auto selectionFlags = getSelectedObjectFlags(); for (auto& entry : _tabObjectList) { if ((selectionFlags[entry.index] & ObjectManager::SelectedObjectsFlags::selected) != ObjectManager::SelectedObjectsFlags::none) { return { static_cast<int16_t>(entry.index), entry.object }; } } if (_tabObjectList.size() > 0) { return { static_cast<int16_t>(_tabObjectList[0].index), _tabObjectList[0].object }; } return { ObjectManager::kNullObjectIndex, ObjectManager::ObjectIndexEntry{} }; } static const WindowEventList& getEvents(); // 0x00472A20 Ui::Window* open() { auto window = WindowManager::bringToFront(WindowType::objectSelection); if (window != nullptr) { return window; } ObjectManager::prepareSelectionList(true); window = WindowManager::createWindowCentred(WindowType::objectSelection, { kWindowSize }, WindowFlags::none, getEvents()); window->setWidgets(widgets); window->initScrollWidgets(); window->frameNo = 0; window->rowHover = -1; window->filterLevel = enumValue(SceneManager::isEditorMode() ? FilterLevel::beginner : FilterLevel::advanced); window->var_858 = enumValue(FilterFlags::vanilla | FilterFlags::openLoco | FilterFlags::custom); window->currentSecondaryTab = 0; window->object = nullptr; assignTabPositions(window); static_assert(kMainTabInfo[0].objectType == ObjectType::region); populateTabObjectList(ObjectType::region, FilterFlags(window->var_858)); ObjectManager::freeTemporaryObject(); auto objIndex = getFirstAvailableSelectedObject(window); if (objIndex.index != ObjectManager::kNullObjectIndex) { window->rowHover = objIndex.index; window->object = reinterpret_cast<std::byte*>(&objIndex.object._header); ObjectManager::loadTemporaryObject(objIndex.object._header); } auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); inputSession = Ui::TextInput::InputSession(); inputSession.calculateTextOffset(widgets[widx::textInput].width()); return window; } static void switchPrimaryTab(Window& self, uint8_t tabIndex); static void switchTabByObjectType(Window& self, ObjectType objectType); Window& openInTab(ObjectType objectType) { auto& window = *open(); window.filterLevel = enumValue(FilterLevel::advanced); assignTabPositions(&window); switchTabByObjectType(window, objectType); return window; } // 0x004733AC static void prepareDraw(Ui::Window& self) { self.activatedWidgets = (1 << widx::objectImage); self.widgets[widx::closeButton].hidden = false; if (SceneManager::isEditorMode()) { self.widgets[widx::closeButton].hidden = true; } self.activatedWidgets |= 1ULL << (widx::primaryTab1 + self.currentTab); const auto& currentTab = kMainTabInfo[self.currentTab]; const auto& subTabs = currentTab.subTabs; const bool showSecondaryTabs = !subTabs.empty() && FilterLevel(self.filterLevel) != FilterLevel::beginner; // Update page title auto args = FormatArguments(self.widgets[widx::caption].textArgs); if (showSecondaryTabs) { args.push(subTabs[self.currentSecondaryTab].name); } else { args.push(kMainTabInfo[self.currentTab].name); } // Toggle secondary tabs for (auto i = 0U; i < kMaxNumSecondaryTabs; i++) { const auto widgetIndex = i + widx::secondaryTab1; const bool subTabIsVisible = showSecondaryTabs && i < subTabs.size() && shouldShowSubTab(subTabs, i, FilterLevel(self.filterLevel)); if (subTabIsVisible) { self.disabledWidgets &= ~(1ULL << widgetIndex); } else { self.disabledWidgets |= (1ULL << widgetIndex); } if (self.currentSecondaryTab == i) { self.activatedWidgets |= 1ULL << widgetIndex; } else { self.activatedWidgets &= ~(1ULL << widgetIndex); } } Widget::leftAlignTabs(self, widx::secondaryTab1, widx::secondaryTab8, 30); if (showSecondaryTabs) { self.widgets[widx::scrollview].top = 62 + 28; self.widgets[widx::scrollviewFrame].hidden = false; self.widgets[widx::scrollviewFrame].top = self.widgets[widx::scrollview].top - 2; } else { self.widgets[widx::scrollview].top = 62; self.widgets[widx::scrollviewFrame].hidden = true; } } static loco_global<uint16_t[kMaxObjectTypes], 0x0112C1C5> _112C1C5; static loco_global<uint32_t, 0x0112C209> _112C209; // 0x0047328D static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { for (auto i = 0U; i < kMaxNumPrimaryTabs; i++) { auto widgetIndex = i + widx::primaryTab1; if (self.widgets[widgetIndex].hidden) { continue; } auto image = Gfx::recolour(kMainTabInfo[i].image, Colour::mutedSeaGreen); Widget::drawTab(self, drawingCtx, image, widgetIndex); } } static void drawSecondaryTabs(Window& self, Gfx::DrawingContext& drawingCtx) { const auto& currentTab = kMainTabInfo[self.currentTab]; const auto& subTabs = currentTab.subTabs; const bool showSecondaryTabs = !subTabs.empty(); if (!showSecondaryTabs) { return; } auto skin = ObjectManager::get<InterfaceSkinObject>(); for (auto i = 0U; i < subTabs.size(); i++) { auto widgetIndex = i + widx::secondaryTab1; if (self.widgets[widgetIndex].hidden) { continue; } auto& tabData = subTabs[i]; auto frame = 0; if (self.currentSecondaryTab == i) { frame = (self.frameNo >> tabData.animationDivisor) % tabData.animationLength; } auto baseImage = currentTab.objectType == ObjectType::vehicle ? skin->img : 0; auto image = Gfx::recolour(baseImage + tabData.baseImage + frame, CompanyManager::getCompanyColour(CompanyId::neutral)); Widget::drawTab(self, drawingCtx, image, widgetIndex); } } static constexpr Ui::Point kObjectPreviewOffset = { 56, 56 }; static constexpr Ui::Size kObjectPreviewSize = { 112, 112 }; static constexpr uint8_t kDescriptionRowHeight = 10; template<typename T> static void callDrawPreviewImage(Gfx::DrawingContext& drawingCtx, const Ui::Point& drawingOffset, const Object& objectPtr) { auto object = reinterpret_cast<const T*>(&objectPtr); object->drawPreviewImage(drawingCtx, drawingOffset.x, drawingOffset.y); } // 0x00473579 static void drawPreviewImage(const ObjectHeader& header, Gfx::DrawingContext& drawingCtx, int16_t x, int16_t y, const Object& objectPtr) { auto type = header.getType(); // Clip the draw area to simplify image draw Ui::Point drawAreaPos = Ui::Point{ x, y } - kObjectPreviewOffset; const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(drawAreaPos.x, drawAreaPos.y, kObjectPreviewSize.width, kObjectPreviewSize.height)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); switch (type) { case ObjectType::interfaceSkin: callDrawPreviewImage<InterfaceSkinObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::currency: callDrawPreviewImage<CurrencyObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::cliffEdge: callDrawPreviewImage<CliffEdgeObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::water: callDrawPreviewImage<WaterObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::land: callDrawPreviewImage<LandObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::wall: callDrawPreviewImage<WallObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::trackSignal: callDrawPreviewImage<TrainSignalObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::levelCrossing: callDrawPreviewImage<LevelCrossingObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::streetLight: callDrawPreviewImage<StreetLightObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::tunnel: callDrawPreviewImage<TunnelObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::bridge: callDrawPreviewImage<BridgeObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::trainStation: callDrawPreviewImage<TrainStationObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::trackExtra: callDrawPreviewImage<TrackExtraObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::track: callDrawPreviewImage<TrackObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::roadStation: callDrawPreviewImage<RoadStationObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::roadExtra: callDrawPreviewImage<RoadExtraObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::road: callDrawPreviewImage<RoadObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::airport: callDrawPreviewImage<AirportObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::dock: callDrawPreviewImage<DockObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::vehicle: callDrawPreviewImage<VehicleObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::tree: callDrawPreviewImage<TreeObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::snow: callDrawPreviewImage<SnowObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::hillShapes: callDrawPreviewImage<HillShapesObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::building: callDrawPreviewImage<BuildingObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::scaffolding: callDrawPreviewImage<ScaffoldingObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::industry: callDrawPreviewImage<IndustryObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::region: callDrawPreviewImage<RegionObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; case ObjectType::competitor: callDrawPreviewImage<CompetitorObject>(drawingCtx, kObjectPreviewOffset, objectPtr); break; default: // null break; } drawingCtx.popRenderTarget(); } template<typename T> static void callDrawDescription(Gfx::DrawingContext& drawingCtx, const int16_t x, const int16_t y, const int16_t width, const Object& objectPtr) { auto object = reinterpret_cast<const T*>(&objectPtr); object->drawDescription(drawingCtx, x, y, width); } static void drawDescription(const ObjectHeader& header, Window* self, Gfx::DrawingContext& drawingCtx, int16_t x, int16_t y, Object& objectPtr) { int16_t width = self->x + self->width - x; int16_t height = self->y + self->height - y; // Clip the draw area to simplify image draw const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); switch (header.getType()) { case ObjectType::levelCrossing: callDrawDescription<LevelCrossingObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::trainStation: callDrawDescription<TrainStationObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::roadStation: callDrawDescription<RoadStationObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::airport: callDrawDescription<AirportObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::dock: callDrawDescription<DockObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::vehicle: callDrawDescription<VehicleObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::building: callDrawDescription<BuildingObject>(drawingCtx, 0, 0, width, objectPtr); break; case ObjectType::competitor: callDrawDescription<CompetitorObject>(drawingCtx, 0, 0, width, objectPtr); break; default: // null break; } drawingCtx.popRenderTarget(); } static void drawDatDetails(const ObjectManager::ObjectIndexEntry& indexEntry, Window* self, Gfx::DrawingContext& drawingCtx, int16_t x, int16_t y) { int16_t width = self->x + self->width - x; int16_t height = self->y + self->height - y; // Clip the draw area to simplify image draw const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); auto tr = Gfx::TextRenderer(drawingCtx); // Draw object filename { auto filename = fs::u8path(indexEntry._filepath).filename().u8string(); auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); strncpy(buffer, filename.c_str(), filename.length() + 1); FormatArguments args{}; args.push<StringId>(StringIds::buffer_1250); auto point = Point(18, height - kDescriptionRowHeight * 3 - 4); tr.drawStringLeft(point, Colour::black, StringIds::object_selection_filename, args); } drawingCtx.popRenderTarget(); } static void drawSearchBox(Window& self, Gfx::DrawingContext& drawingCtx) { char* textBuffer = (char*)StringManager::getString(StringIds::buffer_2039); strncpy(textBuffer, inputSession.buffer.c_str(), 256); auto& widget = widgets[widx::textInput]; const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(widget.left + 1 + self.x, widget.top + 1 + self.y, widget.width() - 2, widget.height() - 2)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); FormatArguments args{}; args.push(StringIds::buffer_2039); auto tr = Gfx::TextRenderer(drawingCtx); // Draw search box input buffer Ui::Point position = { inputSession.xOffset, 1 }; tr.drawStringLeft(position, Colour::black, StringIds::black_stringid, args); // Draw search box cursor, blinking if (Input::isFocused(self.type, self.number, widx::textInput) && (inputSession.cursorFrame % 32) < 16) { // We draw the string again to figure out where the cursor should go; position.x will be adjusted textBuffer[inputSession.cursorPosition] = '\0'; position = { inputSession.xOffset, 1 }; position = tr.drawStringLeft(position, Colour::black, StringIds::black_stringid, args); drawingCtx.fillRect(position.x, position.y, position.x, position.y + 9, Colours::getShade(self.getColour(WindowColour::secondary).c(), 9), Gfx::RectFlags::none); } drawingCtx.popRenderTarget(); } // 0x004733F5 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.fillRectInset(self.x, self.y + 20, self.x + self.width - 1, self.y + 20 + 60, self.getColour(WindowColour::primary), Gfx::RectInsetFlags::none); self.draw(drawingCtx); drawTabs(self, drawingCtx); drawSecondaryTabs(self, drawingCtx); drawSearchBox(self, drawingCtx); { static constexpr std::array<StringId, 3> levelStringIds = { StringIds::objSelectionFilterBeginner, StringIds::objSelectionFilterAdvanced, StringIds::objSelectionFilterExpert, }; FormatArguments args{}; args.push(levelStringIds[self.filterLevel]); auto& widget = self.widgets[widx::filterLabel]; auto point = Point(self.x + widget.left, self.y + widget.top); // Draw current level on combobox tr.drawStringLeftClipped(point, widget.width() - 15, Colour::black, StringIds::wcolour2_stringid, args); } bool doDefault = true; if (self.object != nullptr) { auto& objectHeader = ObjectManager::getObjectInIndex(self.rowHover)._header; if (objectHeader.getType() != ObjectType::townNames && objectHeader.getType() != ObjectType::climate) { doDefault = false; } } if (doDefault) { auto widget = widgets[widx::objectImage]; auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 5); drawingCtx.drawRect(self.x + widget.left, self.y + widget.top, widget.width(), widget.height(), colour, Gfx::RectFlags::none); } else { auto widget = widgets[widx::objectImage]; auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 0); drawingCtx.drawRect(self.x + widget.left + 1, self.y + widget.top + 1, widget.width() - 2, widget.height() - 2, colour, Gfx::RectFlags::none); } ObjectType type{}; auto& currentTab = kMainTabInfo[self.currentTab]; if (!currentTab.subTabs.empty()) { type = currentTab.subTabs[self.currentSecondaryTab].objectType; } else { type = currentTab.objectType; } auto args = FormatArguments(); args.push(_112C1C5[enumValue(type)]); args.push(ObjectManager::getMaxObjects(type)); { auto point = Point(self.x + 3, self.y + self.height - 12); tr.drawStringLeft(point, Colour::black, StringIds::num_selected_num_max, args); } if (self.rowHover == -1) { return; } auto* temporaryObject = ObjectManager::getTemporaryObject(); if (temporaryObject == nullptr) { return; } { auto& objectHeader = ObjectManager::getObjectInIndex(self.rowHover)._header; drawPreviewImage( objectHeader, drawingCtx, widgets[widx::objectImage].midX() + 1 + self.x, widgets[widx::objectImage].midY() + 1 + self.y, *temporaryObject); } auto x = self.widgets[widx::objectImage].midX() + self.x; auto y = self.widgets[widx::objectImage].bottom + 3 + self.y; auto width = self.width - self.widgets[widx::scrollview].right - 6; { auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); *buffer++ = ControlCodes::windowColour2; strncpy(buffer, ObjectManager::getObjectInIndex(self.rowHover)._name.c_str(), 510); auto point = Point(x, y); tr.drawStringCentredClipped(point, width, Colour::black, StringIds::buffer_2039); } { auto& objHeader = ObjectManager::getObjectInIndex(self.rowHover)._header; drawDescription( objHeader, &self, drawingCtx, self.widgets[widx::scrollview].right + self.x + 4, y + kDescriptionRowHeight, *temporaryObject); } { drawDatDetails( ObjectManager::getObjectInIndex(self.rowHover), &self, drawingCtx, self.widgets[widx::scrollview].right + self.x + 4, y + kDescriptionRowHeight); } } // 0x0047361D static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, const uint32_t) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); if (ObjectManager::getNumInstalledObjects() == 0) { return; } const auto selectionFlags = getSelectedObjectFlags(); int y = 0; for (auto& entry : _tabObjectList) { if (entry.display == Visibility::hidden) { continue; } if (y + kRowHeight < rt.y) { y += kRowHeight; continue; } else if (y > rt.y + rt.height) { break; } Gfx::RectInsetFlags flags = Gfx::RectInsetFlags::colourLight | Gfx::RectInsetFlags::fillDarker | Gfx::RectInsetFlags::borderInset; drawingCtx.fillRectInset(2, y, 11, y + 10, self.getColour(WindowColour::secondary), flags); uint8_t textColour = ControlCodes::Colour::black; auto objectPtr = self.object; if (objectPtr != nullptr) { auto& hoverObject = ObjectManager::getObjectInIndex(self.rowHover)._header; if (entry.object._header == hoverObject) { drawingCtx.fillRect(0, y, self.width, y + kRowHeight - 1, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); textColour = ControlCodes::windowColour2; } } using namespace ObjectManager; if ((selectionFlags[entry.index] & SelectedObjectsFlags::selected) != SelectedObjectsFlags::none) { auto x = 2; tr.setCurrentFont(Gfx::Font::m2); if (textColour != ControlCodes::windowColour2) { tr.setCurrentFont(Gfx::Font::m1); } auto checkColour = self.getColour(WindowColour::secondary).opaque(); if ((selectionFlags[entry.index] & (SelectedObjectsFlags::inUse | SelectedObjectsFlags::requiredByAnother | SelectedObjectsFlags::alwaysRequired)) != ObjectManager::SelectedObjectsFlags::none) { checkColour = checkColour.inset(); } static constexpr char strCheckmark[] = "\xAC"; auto point = Point(x, y); tr.drawString(point, checkColour, strCheckmark); } char buffer[512]{}; buffer[0] = textColour; strncpy(&buffer[1], entry.object._name.c_str(), 510); tr.setCurrentFont(Gfx::Font::medium_bold); auto point = Point(15, y); tr.drawString(point, Colour::black, buffer); y += kRowHeight; } } static void switchTabByObjectType(Window& self, ObjectType objectType) { auto targetTab = 0; auto targetSubTab = 0; auto targetType = ObjectType::region; for (auto i = 0U; i < kMaxNumPrimaryTabs; i++) { if (!shouldShowPrimaryTab(i, FilterLevel(self.filterLevel))) { continue; } auto& mainTabInfo = kMainTabInfo[i]; if (objectType == mainTabInfo.objectType) { targetTab = i; targetType = objectType; break; } auto& subTabs = mainTabInfo.subTabs; if (subTabs.empty()) { continue; } for (auto j = 0U; j < subTabs.size(); j++) { if (!shouldShowTab(subTabs[j], FilterLevel(self.var_858))) { continue; } if (objectType == subTabs[j].objectType) { targetTab = i; targetSubTab = j; targetType = objectType; break; } } if (targetSubTab != 0) { break; } } self.currentTab = targetTab; self.currentSecondaryTab = targetSubTab; populateTabObjectList(targetType, FilterFlags(self.var_858)); } // 0x00473A13 bool tryCloseWindow() { const auto res = ObjectManager::validateObjectSelection(getSelectedObjectFlags()); if (!res.has_value()) { // All okay selection is good! auto* w = WindowManager::find(WindowType::objectSelection); if (w != nullptr) { WindowManager::close(w); } return true; } else { // Selection was bad so throw up an error message // and switch tabs to the bad type Windows::Error::open(StringIds::invalid_selection_of_objects, GameCommands::getErrorText()); auto* w = WindowManager::find(WindowType::objectSelection); if (w != nullptr) { // TODO: switch modes as needed? auto objectType = res.value(); switchTabByObjectType(*w, objectType); w->rowHover = -1; w->object = nullptr; w->scrollAreas[0].contentWidth = 0; ObjectManager::freeTemporaryObject(); w->invalidate(); auto objIndex = getFirstAvailableSelectedObject(w); if (objIndex.index != ObjectManager::kNullObjectIndex) { w->rowHover = objIndex.index; w->object = reinterpret_cast<std::byte*>(&objIndex.object._header); ObjectManager::loadTemporaryObject(objIndex.object._header); } } return false; } } static void switchPrimaryTab(Window& self, uint8_t tabIndex) { self.currentTab = tabIndex; self.currentSecondaryTab = 0; const auto& currentTab = kMainTabInfo[self.currentTab]; _filterByVehicleType = currentTab.objectType == ObjectType::vehicle; _currentVehicleType = VehicleType::train; auto objectType = kMainTabInfo[tabIndex].objectType; populateTabObjectList(objectType, FilterFlags(self.var_858)); self.rowHover = -1; self.object = nullptr; self.scrollAreas[0].contentWidth = 0; ObjectManager::freeTemporaryObject(); auto objIndex = getFirstAvailableSelectedObject(&self); if (objIndex.index != ObjectManager::kNullObjectIndex) { self.rowHover = objIndex.index; self.object = reinterpret_cast<std::byte*>(&objIndex.object._header); ObjectManager::loadTemporaryObject(objIndex.object._header); } applyFilterToObjectList(FilterFlags(self.var_858)); self.initScrollWidgets(); self.invalidate(); } // 0x004737BA static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::closeButton: tryCloseWindow(); break; case widx::primaryTab1: case widx::primaryTab2: case widx::primaryTab3: case widx::primaryTab4: case widx::primaryTab5: case widx::primaryTab6: case widx::primaryTab7: case widx::primaryTab8: case widx::primaryTab9: case widx::primaryTab10: case widx::primaryTab11: case widx::primaryTab12: { auto clickedTab = widgetIndex - widx::primaryTab1; switchPrimaryTab(self, clickedTab); break; } case widx::clearButton: { inputSession.clearInput(); applyFilterToObjectList(FilterFlags(self.var_858)); self.initScrollWidgets(); self.invalidate(); break; } case widx::secondaryTab1: case widx::secondaryTab2: case widx::secondaryTab3: case widx::secondaryTab4: case widx::secondaryTab5: case widx::secondaryTab6: case widx::secondaryTab7: case widx::secondaryTab8: { auto& subTabs = kMainTabInfo[self.currentTab].subTabs; auto previousSubType = subTabs[self.currentSecondaryTab].objectType; self.currentSecondaryTab = widgetIndex - widx::secondaryTab1; auto currentSubType = subTabs[self.currentSecondaryTab].objectType; _currentVehicleType = static_cast<VehicleType>(self.currentSecondaryTab); // Do we need to reload the object list? auto flags = FilterFlags(self.var_858); if (previousSubType != currentSubType) { populateTabObjectList(subTabs[self.currentSecondaryTab].objectType, flags); } applyFilterToObjectList(flags); self.initScrollWidgets(); self.invalidate(); } } } static void onMouseDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::filterDropdown) { auto& dropdown = self.widgets[widx::filterLabel]; Dropdown::show(self.x + dropdown.left, self.y + dropdown.top, dropdown.width() - 4, dropdown.height(), self.getColour(WindowColour::secondary), 7, 0); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::objSelectionFilterBeginner); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::objSelectionFilterAdvanced); Dropdown::add(2, StringIds::dropdown_stringid, StringIds::objSelectionFilterExpert); Dropdown::add(3, 0); Dropdown::add(4, StringIds::dropdown_without_checkmark, StringIds::objSelectionFilterVanilla); Dropdown::add(5, StringIds::dropdown_without_checkmark, StringIds::objSelectionFilterOpenLoco); Dropdown::add(6, StringIds::dropdown_without_checkmark, StringIds::objSelectionFilterCustom); // Mark current level Dropdown::setItemSelected(self.filterLevel); // Show vanilla objects? if ((FilterFlags(self.var_858) & FilterFlags::vanilla) != FilterFlags::none) { Dropdown::setItemSelected(4); } // Show OpenLoco objects? if ((FilterFlags(self.var_858) & FilterFlags::openLoco) != FilterFlags::none) { Dropdown::setItemSelected(5); } // Show custom objects? if ((FilterFlags(self.var_858) & FilterFlags::custom) != FilterFlags::none) { Dropdown::setItemSelected(6); } } } static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::filterDropdown) { return; } if (itemIndex < 0) { self.filterLevel = (self.filterLevel ^ 1) % 3; assignTabPositions(&self); } // Switch level? else if (itemIndex >= 0 && itemIndex <= 2) { // Keep track of currently selected object type auto& currentTab = kMainTabInfo[self.currentTab]; auto currentObjectType = currentTab.objectType; if (!currentTab.subTabs.empty()) { auto& currentSubType = currentTab.subTabs[self.currentSecondaryTab]; currentObjectType = currentSubType.objectType; } self.filterLevel = itemIndex; assignTabPositions(&self); // Switch back to previously selected object type, if possible switchTabByObjectType(self, currentObjectType); } else if (itemIndex == 4) // Toggle vanilla objects { self.var_858 = enumValue(FilterFlags(self.var_858) ^ FilterFlags::vanilla); auto objectType = kMainTabInfo[self.currentTab].objectType; populateTabObjectList(objectType, FilterFlags(self.var_858)); } else if (itemIndex == 5) // Toggle OpenLoco objects { self.var_858 = enumValue(FilterFlags(self.var_858) ^ FilterFlags::openLoco); auto objectType = kMainTabInfo[self.currentTab].objectType; populateTabObjectList(objectType, FilterFlags(self.var_858)); } else if (itemIndex == 6) // Toggle custom objects { self.var_858 = enumValue(FilterFlags(self.var_858) ^ FilterFlags::custom); auto objectType = kMainTabInfo[self.currentTab].objectType; populateTabObjectList(objectType, FilterFlags(self.var_858)); } self.invalidate(); } // 0x004738ED static void getScrollSize([[maybe_unused]] Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = _numVisibleObjectsListed * kRowHeight; } // 0x00473900 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_object_list); return args; } // 0x00472B54 static ObjectManager::ObjIndexPair getObjectFromSelection([[maybe_unused]] Window* self, int16_t& y) { for (auto& entry : _tabObjectList) { if (entry.display == Visibility::hidden) { continue; } y -= kRowHeight; if (y < 0) { return { static_cast<int16_t>(entry.index), entry.object }; } } return { ObjectManager::kNullObjectIndex, ObjectManager::ObjectIndexEntry{} }; } // 0x0047390A static void onScrollMouseOver(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto objIndex = getObjectFromSelection(&self, y); if (objIndex.index == self.rowHover || objIndex.index == ObjectManager::kNullObjectIndex) { return; } self.rowHover = objIndex.index; self.object = reinterpret_cast<std::byte*>(&objIndex.object._header); ObjectManager::freeTemporaryObject(); if (objIndex.index != ObjectManager::kNullObjectIndex) { ObjectManager::loadTemporaryObject(objIndex.object._header); } self.invalidate(); } // 0x00473948 static void onScrollMouseDown(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto objIndex = getObjectFromSelection(&self, y); auto index = objIndex.index; auto object = objIndex.object._header; if (index == ObjectManager::kNullObjectIndex) { return; } self.invalidate(); Audio::playSound(Audio::SoundId::clickDown, Input::getMouseLocation().x); auto type = objIndex.object._header.getType(); const auto selectionFlags = getSelectedObjectFlags(); if (ObjectManager::getMaxObjects(type) == 1) { if ((selectionFlags[index] & ObjectManager::SelectedObjectsFlags::selected) == ObjectManager::SelectedObjectsFlags::none) { auto [oldIndex, oldObject] = ObjectManager::getActiveObject(type, selectionFlags); if (oldIndex != ObjectManager ::kNullObjectIndex) { ObjectManager::ObjectSelectionMeta meta{}; std::copy(std::begin(_112C1C5), std::end(_112C1C5), std::begin(meta.numSelectedObjects)); meta.numImages = _112C209; ObjectManager::selectObjectFromIndex(ObjectManager::SelectObjectModes::defaultDeselect, oldObject._header, selectionFlags, meta); std::copy(std::begin(meta.numSelectedObjects), std::end(meta.numSelectedObjects), std::begin(_112C1C5)); _112C209 = meta.numImages; } } } auto mode = ObjectManager::SelectObjectModes::defaultDeselect; if ((selectionFlags[index] & ObjectManager::SelectedObjectsFlags::selected) == ObjectManager::SelectedObjectsFlags::none) { mode = ObjectManager::SelectObjectModes::defaultSelect; } ObjectManager::ObjectSelectionMeta meta{}; std::copy(std::begin(_112C1C5), std::end(_112C1C5), std::begin(meta.numSelectedObjects)); meta.numImages = _112C209; bool success = ObjectManager::selectObjectFromIndex(mode, object, selectionFlags, meta); std::copy(std::begin(meta.numSelectedObjects), std::end(meta.numSelectedObjects), std::begin(_112C1C5)); _112C209 = meta.numImages; if (success) { return; } auto errorTitle = StringIds::error_unable_to_select_object; if ((mode & ObjectManager::SelectObjectModes::select) == ObjectManager::SelectObjectModes::none) { errorTitle = StringIds::error_unable_to_deselect_object; } Ui::Windows::Error::open(errorTitle, GameCommands::getErrorText()); } // 0x004739DD static void onClose([[maybe_unused]] Window& self) { ObjectManager::unloadUnselectedSelectionListObjects(getSelectedObjectFlags()); ObjectManager::loadSelectionListObjects(getSelectedObjectFlags()); ObjectManager::reloadAll(); ObjectManager::freeTemporaryObject(); if (!SceneManager::isEditorMode()) { // Make new selection available in-game. ObjectManager::updateYearly2(); ObjectManager::updateTerraformObjects(); Gfx::loadCurrency(); Gfx::loadDefaultPalette(); Gfx::invalidateScreen(); CompanyManager::determineAvailableVehicles(); WindowManager::invalidate(WindowType::buildVehicle); } ObjectManager::freeSelectionList(); } // 0x00473A04 static void onUpdate(Window& self) { WindowManager::invalidateWidget(WindowType::objectSelection, self.number, widx::objectImage); inputSession.cursorFrame++; if ((inputSession.cursorFrame % 16) == 0) { WindowManager::invalidateWidget(WindowType::objectSelection, self.number, widx::textInput); } } static bool keyUp(Window& w, uint32_t charCode, uint32_t keyCode) { if (!Input::isFocused(w.type, w.number, widx::textInput)) { return false; } if (!inputSession.handleInput(charCode, keyCode)) { return false; } int containerWidth = widgets[widx::textInput].width() - 2; if (inputSession.needsReoffsetting(containerWidth)) { inputSession.calculateTextOffset(containerWidth); } inputSession.cursorFrame = 0; applyFilterToObjectList(FilterFlags(w.var_858)); w.initScrollWidgets(); w.invalidate(); return true; } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, .keyUp = keyUp, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Options.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "Environment.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Jukebox.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/LanguageFiles.h" #include "Localisation/Languages.h" #include "Localisation/StringIds.h" #include "Objects/CompetitorObject.h" #include "Objects/CurrencyObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "Scenario.h" #include "ScenarioManager.h" #include "ScenarioOptions.h" #include "SceneManager.h" #include "Ui.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/GroupBoxWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/SliderWidget.h" #include "Ui/Widgets/StepperWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <cassert> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::Options { static void tabOnMouseUp(Window* w, WidgetIndex_t wi); static void disableTabsByCurrentScene(Window& w); static void setPreferredCurrencyNameBuffer(); // Pointer to an array of SelectedObjectsFlags static loco_global<ObjectManager::SelectedObjectsFlags*, 0x011364A0> __11364A0; static loco_global<uint16_t, 0x0112C185> _112C185; // TODO: This shouldn't be required but its due to how the lifetime // of the string needs to exist beyond a prepare draw function and // into a draw function. Rework when custom formatter can store full // strings or widgets can store dynamically allocated strings. static std::string _chosenLanguage; struct AvailableCurrency { std::string name; ObjectHeader header; ObjectManager::ObjectIndexId index; }; // We need to keep a copy due to lifetimes static sfl::small_vector<AvailableCurrency, 10> _availableCurrencies; static std::span<ObjectManager::SelectedObjectsFlags> getLoadedSelectedObjectFlags() { return std::span<ObjectManager::SelectedObjectsFlags>(*__11364A0, ObjectManager::getNumInstalledObjects()); } static void populateAvailableCurrencies() { _availableCurrencies.clear(); for (auto& object : ObjectManager::getAvailableObjects(ObjectType::currency)) { _availableCurrencies.push_back(AvailableCurrency{ object.object._name, object.object._header, object.index }); } } namespace Common { namespace Widx { enum { frame = 0, caption = 1, close_button = 2, panel = 3, tab_display, tab_rendering, tab_audio, tab_regional, tab_controls, tab_company, tab_miscellaneous, }; } static_assert(Widx::tab_audio == Widx::tab_display + kTabOffsetMusic); enum tab { display, rendering, audio, regional, controls, company, miscellaneous, }; static void prepareDraw(Window& w) { w.activatedWidgets = 1ULL << (w.currentTab + 4); w.disabledWidgets = 0; w.widgets[Widx::frame].right = w.width - 1; w.widgets[Widx::frame].bottom = w.height - 1; w.widgets[Widx::panel].right = w.width - 1; w.widgets[Widx::panel].bottom = w.height - 1; w.widgets[Widx::caption].right = w.width - 2; w.widgets[Widx::close_button].left = w.width - 15; w.widgets[Widx::close_button].right = w.width - 15 + 12; disableTabsByCurrentScene(w); const auto* skin = ObjectManager::get<InterfaceSkinObject>(); // Rendering tab { static constexpr uint32_t kRedenderingTabImageIds[] = { InterfaceSkin::ImageIds::tab_colour_scheme_frame0, InterfaceSkin::ImageIds::tab_colour_scheme_frame1, InterfaceSkin::ImageIds::tab_colour_scheme_frame2, InterfaceSkin::ImageIds::tab_colour_scheme_frame3, InterfaceSkin::ImageIds::tab_colour_scheme_frame4, InterfaceSkin::ImageIds::tab_colour_scheme_frame5, InterfaceSkin::ImageIds::tab_colour_scheme_frame6, InterfaceSkin::ImageIds::tab_colour_scheme_frame7, }; uint32_t imageId = skin->img; if (w.currentTab == tab::rendering) { imageId += kRedenderingTabImageIds[(w.frameNo / 4) % std::size(kRedenderingTabImageIds)]; } else { imageId += kRedenderingTabImageIds[0]; } w.widgets[Widx::tab_rendering].image = imageId; } static constexpr uint32_t globe_tab_ids[] = { ImageIds::tab_globe_0, ImageIds::tab_globe_1, ImageIds::tab_globe_2, ImageIds::tab_globe_3, ImageIds::tab_globe_4, ImageIds::tab_globe_5, ImageIds::tab_globe_6, ImageIds::tab_globe_7, ImageIds::tab_globe_8, ImageIds::tab_globe_9, ImageIds::tab_globe_10, ImageIds::tab_globe_11, ImageIds::tab_globe_12, ImageIds::tab_globe_13, ImageIds::tab_globe_14, ImageIds::tab_globe_15, ImageIds::tab_globe_16, ImageIds::tab_globe_17, ImageIds::tab_globe_18, ImageIds::tab_globe_19, ImageIds::tab_globe_20, ImageIds::tab_globe_21, ImageIds::tab_globe_22, ImageIds::tab_globe_23, ImageIds::tab_globe_24, ImageIds::tab_globe_25, ImageIds::tab_globe_26, ImageIds::tab_globe_27, ImageIds::tab_globe_28, ImageIds::tab_globe_29, ImageIds::tab_globe_30, ImageIds::tab_globe_31, }; // Regional tab { auto imageId = ImageIds::tab_globe_0; if (w.currentTab == tab::regional) { imageId = globe_tab_ids[(w.frameNo / 2) % 32]; } w.widgets[Widx::tab_regional].image = imageId; } // Company tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::tab_company; w.widgets[Widx::tab_company].image = imageId; } } static void onClose([[maybe_unused]] Window& w) { ObjectManager::freeTemporaryObject(); free(__11364A0); } static bool onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { switch (wi) { case Widx::close_button: WindowManager::close(&w); return true; case Widx::tab_display: case Widx::tab_rendering: case Widx::tab_audio: case Widx::tab_regional: case Widx::tab_controls: case Widx::tab_company: case Widx::tab_miscellaneous: Options::tabOnMouseUp(&w, wi); return true; default: return false; } } static constexpr auto makeCommonWidgets(Ui::Size32 windowSize, StringId windowCaptionId) { constexpr auto kTabWidth = 31; return makeWidgets( Widgets::Frame({ 0, 0 }, windowSize, WindowColour::primary), Widgets::Caption({ 1, 1 }, { (uint16_t)(windowSize.width - 2), 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ (int16_t)(windowSize.width - 15), 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { windowSize.width, 102 }, WindowColour::secondary), Widgets::Tab({ 3 + kTabWidth * 0, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab_display, StringIds::tooltip_display_options), Widgets::Tab({ 3 + kTabWidth * 1, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_options_rendering), Widgets::Tab({ 3 + kTabWidth * 2, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab_sound, StringIds::tooltip_audio_options), Widgets::Tab({ 3 + kTabWidth * 3, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab_globe_0, StringIds::tooltip_regional_options), Widgets::Tab({ 3 + kTabWidth * 4, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab_control, StringIds::tooltip_control_options), Widgets::Tab({ 3 + kTabWidth * 5, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_options), Widgets::Tab({ 3 + kTabWidth * 6, 15 }, { kTabWidth, 27 }, WindowColour::secondary, ImageIds::tab_miscellaneous, StringIds::tooltip_miscellaneous_options)); } } namespace Display { static constexpr Ui::Size32 kWindowSize = { 400, 151 }; namespace Widx { enum { frame_hardware = Common::Widx::tab_miscellaneous + 1, screen_mode_label, screen_mode, screen_mode_btn, display_resolution_label, display_resolution, display_resolution_btn, display_scale_label, display_scale, display_scale_down_btn, display_scale_up_btn, uncap_fps, show_fps, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::options_title_display), Widgets::GroupBox({ 4, 49 }, { 392, 97 }, WindowColour::secondary, StringIds::frame_hardware), Widgets::Label({ 10, 63 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::options_screen_mode), Widgets::dropdownWidgets({ 235, 63 }, { 154, 12 }, WindowColour::secondary, StringIds::empty), Widgets::Label({ 10, 79 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::display_resolution), Widgets::dropdownWidgets({ 235, 79 }, { 154, 12 }, WindowColour::secondary, StringIds::display_resolution_dropdown_format), Widgets::Label({ 10, 95 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::window_scale_factor), Widgets::stepperWidgets({ 235, 95 }, { 154, 12 }, WindowColour::secondary, StringIds::scale_formatted), Widgets::Checkbox({ 10, 111 }, { 174, 12 }, WindowColour::secondary, StringIds::option_uncap_fps, StringIds::option_uncap_fps_tooltip), Widgets::Checkbox({ 10, 127 }, { 174, 12 }, WindowColour::secondary, StringIds::option_show_fps_counter, StringIds::option_show_fps_counter_tooltip) ); // 0x004BFB8C static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::show_fps: { auto& cfg = OpenLoco::Config::get(); cfg.showFPS ^= 1; OpenLoco::Config::write(); Gfx::invalidateScreen(); return; } case Widx::uncap_fps: { auto& cfg = OpenLoco::Config::get(); cfg.uncapFPS ^= 1; OpenLoco::Config::write(); Gfx::invalidateScreen(); return; } } } #if !(defined(__APPLE__) && defined(__MACH__)) static void screenModeToggleEnabled(Window* w) { if (Config::get().display.mode == Config::ScreenMode::fullscreen) { w->disabledWidgets &= ~(1ULL << Widx::display_resolution) | (1ULL << Widx::display_resolution_btn); w->disabledWidgets &= ~((1ULL << Widx::display_resolution) | (1ULL << Widx::display_resolution_btn)); } else { w->disabledWidgets |= ((1ULL << Widx::display_resolution) | (1ULL << Widx::display_resolution_btn)); w->disabledWidgets |= (1ULL << Widx::display_resolution) | (1ULL << Widx::display_resolution_btn); } } #endif static void screenModeMouseDown(Window* w, [[maybe_unused]] WidgetIndex_t wi) { Widget dropdown = w->widgets[Widx::screen_mode]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 3, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::options_mode_windowed); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::options_mode_fullscreen); Dropdown::add(2, StringIds::dropdown_stringid, StringIds::options_mode_fullscreen_window); auto selection = static_cast<uint16_t>(Config::get().display.mode); Dropdown::setItemSelected(selection); } static void screenModeDropdown([[maybe_unused]] Window* w, int16_t selection) { if (selection == -1) { return; } auto new_mode = static_cast<Config::ScreenMode>(selection); if (new_mode == Config::get().display.mode) { return; } #if !(defined(__APPLE__) && defined(__MACH__)) Ui::setDisplayMode(new_mode); #endif } #pragma mark - Resolution dropdown (Widget 11) // 0x004C0026 static void resolutionMouseDown(Window* w, [[maybe_unused]] WidgetIndex_t wi) { std::vector<Resolution> resolutions = getFullscreenResolutions(); Widget dropdown = w->widgets[Widx::display_resolution]; Dropdown::showText2(w->x + dropdown.left, w->y + dropdown.top, dropdown.width(), dropdown.height(), w->getColour(WindowColour::secondary), resolutions.size(), 0x80); auto& cfg = Config::get(); for (size_t i = 0; i < resolutions.size(); i++) { Dropdown::add(i, StringIds::dropdown_stringid, { StringIds::display_resolution_dropdown_format, (uint16_t)resolutions[i].width, (uint16_t)resolutions[i].height }); if (cfg.display.fullscreenResolution.width == resolutions[i].width && cfg.display.fullscreenResolution.height == resolutions[i].height) { Dropdown::setItemSelected((int16_t)i); } } } // 0x004C00F4 static void resolutionDropdown([[maybe_unused]] Window* w, int16_t index) { if (index == -1) { return; } std::vector<Resolution> resolutions = getFullscreenResolutions(); Ui::setDisplayMode(Config::ScreenMode::fullscreen, { resolutions[index].width, resolutions[index].height }); } #pragma mark - static void displayScaleMouseDown([[maybe_unused]] Window* w, [[maybe_unused]] WidgetIndex_t wi, float adjust_by) { OpenLoco::Ui::adjustWindowScale(adjust_by); } // 0x004BFBB7 static void onMouseDown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { switch (wi) { case Widx::screen_mode_btn: screenModeMouseDown(&w, wi); break; case Widx::display_resolution_btn: resolutionMouseDown(&w, wi); break; case Widx::display_scale_down_btn: displayScaleMouseDown(&w, wi, -OpenLoco::Ui::ScaleFactor::step); break; case Widx::display_scale_up_btn: displayScaleMouseDown(&w, wi, OpenLoco::Ui::ScaleFactor::step); break; } } // 0x004BFBE8 static void onDropdown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id, int16_t item_index) { switch (wi) { case Widx::screen_mode_btn: screenModeDropdown(&w, item_index); break; case Widx::display_resolution_btn: resolutionDropdown(&w, item_index); break; } } // 0x004C01F5 static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } // 0x004BFA04 static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::display); Common::prepareDraw(w); StringId screenModeStringId = StringIds::empty; switch (Config::get().display.mode) { case Config::ScreenMode::window: screenModeStringId = StringIds::options_mode_windowed; break; case Config::ScreenMode::fullscreen: screenModeStringId = StringIds::options_mode_fullscreen; break; case Config::ScreenMode::fullscreenBorderless: screenModeStringId = StringIds::options_mode_fullscreen_window; break; } w.widgets[Widx::screen_mode].text = screenModeStringId; // Resolution. { auto args = FormatArguments(w.widgets[Widx::display_resolution].textArgs); auto& resolution = Config::get().display.fullscreenResolution; args.push<uint16_t>(resolution.width); args.push<uint16_t>(resolution.height); } // Scale. { auto args = FormatArguments(w.widgets[Widx::display_scale].textArgs); args.push<int32_t>(Config::get().scaleFactor * 100); } if (Config::get().showFPS) { w.activatedWidgets |= (1ULL << Widx::show_fps); } if (Config::get().uncapFPS) { w.activatedWidgets |= (1ULL << Widx::uncap_fps); } if (Config::get().scaleFactor <= OpenLoco::Ui::ScaleFactor::min) { w.disabledWidgets |= (1ULL << Widx::display_scale_down_btn); } if (Config::get().scaleFactor >= OpenLoco::Ui::ScaleFactor::max) { w.disabledWidgets |= (1ULL << Widx::display_scale_up_btn); } #if !(defined(__APPLE__) && defined(__MACH__)) screenModeToggleEnabled(&w); #endif } // 0x004BFAF9 static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { // Draw widgets. w.draw(drawingCtx); } static void applyScreenModeRestrictions(Window* w) { if (Config::get().display.mode != Config::ScreenMode::fullscreen) { w->disabledWidgets = (1ULL << Display::Widx::display_resolution) | (1ULL << Display::Widx::display_resolution_btn); } #if !(defined(__APPLE__) && defined(__MACH__)) Display::screenModeToggleEnabled(w); #else w->disabledWidgets |= (1ULL << Display::Widx::screen_mode) | (1ULL << Display::Widx::screen_mode_btn) | (1ULL << Display::Widx::display_resolution) | (1ULL << Display::Widx::display_resolution_btn); #endif } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Rendering { static constexpr Ui::Size32 kWindowSize = { 400, 182 }; namespace Widx { enum { frame_map_rendering = Common::Widx::tab_miscellaneous + 1, vehicles_min_scale_label, vehicles_min_scale, vehicles_min_scale_btn, station_names_min_scale_label, station_names_min_scale, station_names_min_scale_btn, construction_marker_label, construction_marker, construction_marker_btn, landscape_smoothing, gridlines_on_landscape, cash_popup_rendering, show_company_ai_planning, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::title_options_rendering), Widgets::GroupBox({ 4, 49 }, { 392, 128 }, WindowColour::secondary, StringIds::frame_map_rendering), Widgets::Label({ 10, 63 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::vehicles_min_scale), Widgets::dropdownWidgets({ 235, 63 }, { 154, 12 }, WindowColour::secondary, StringIds::empty, StringIds::vehicles_min_scale_tip), Widgets::Label({ 10, 79 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::station_names_min_scale), Widgets::dropdownWidgets({ 235, 79 }, { 154, 12 }, WindowColour::secondary, StringIds::empty, StringIds::station_names_min_scale_tip), Widgets::Label({ 10, 95 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::construction_marker), Widgets::dropdownWidgets({ 235, 95 }, { 154, 12 }, WindowColour::secondary, StringIds::empty), Widgets::Checkbox({ 10, 110 }, { 346, 12 }, WindowColour::secondary, StringIds::landscape_smoothing, StringIds::landscape_smoothing_tip), Widgets::Checkbox({ 10, 126 }, { 346, 12 }, WindowColour::secondary, StringIds::gridlines_on_landscape, StringIds::gridlines_on_landscape_tip), Widgets::Checkbox({ 10, 142 }, { 346, 12 }, WindowColour::secondary, StringIds::cash_popup_rendering, StringIds::tooltip_cash_popup_rendering), Widgets::Checkbox({ 10, 158 }, { 346, 12 }, WindowColour::secondary, StringIds::show_company_ai_planning, StringIds::show_company_ai_planning_tip) ); // 0x004BFB8C static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::landscape_smoothing: { auto& cfg = OpenLoco::Config::get(); cfg.landscapeSmoothing ^= true; Config::write(); Gfx::invalidateScreen(); return; } case Widx::gridlines_on_landscape: { auto& cfg = OpenLoco::Config::get(); cfg.gridlinesOnLandscape ^= true; Config::write(); Gfx::invalidateScreen(); auto main = WindowManager::getMainWindow(); if (main != nullptr) { main->viewports[0]->flags &= ~ViewportFlags::gridlines_on_landscape; if (cfg.gridlinesOnLandscape) { main->viewports[0]->flags |= ViewportFlags::gridlines_on_landscape; } } return; } case Widx::cash_popup_rendering: { auto& cfg = OpenLoco::Config::get(); cfg.cashPopupRendering = !cfg.cashPopupRendering; Config::write(); w.invalidate(); return; } case Widx::show_company_ai_planning: { auto& cfg = OpenLoco::Config::get(); cfg.showAiPlanningAsGhosts = !cfg.showAiPlanningAsGhosts; Config::write(); Gfx::invalidateScreen(); } } } #pragma mark - Construction Marker (Widget 19) // 0x004BFE2E static void constructionMarkerMouseDown(Window* w, [[maybe_unused]] WidgetIndex_t wi) { Widget dropdown = w->widgets[Widx::construction_marker]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 2, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::white); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::translucent); Dropdown::setItemSelected(Config::get().constructionMarker); } // 0x004BFE98 static void constructionMarkerDropdown(int16_t ax) { if (ax == -1) { return; } if (ax == Config::get().constructionMarker) { return; } auto& cfg = OpenLoco::Config::get(); cfg.constructionMarker = ax; OpenLoco::Config::write(); Gfx::invalidateScreen(); } #pragma mark - Vehicle zoom (Widget 15) // 0x004BFEBE static void vehicleZoomMouseDown(Window* w, [[maybe_unused]] WidgetIndex_t wi) { Widget dropdown = w->widgets[Widx::vehicles_min_scale]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 4, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::full_scale); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::half_scale); Dropdown::add(2, StringIds::dropdown_stringid, StringIds::quarter_scale); Dropdown::add(3, StringIds::dropdown_stringid, StringIds::eighth_scale); Dropdown::setItemSelected(Config::get().vehiclesMinScale); } // 0x004BFF4C static void vehicleZoomDropdown(int16_t ax) { if (ax == -1) { return; } if (ax == Config::get().vehiclesMinScale) { return; } auto& cfg = OpenLoco::Config::get(); cfg.vehiclesMinScale = ax; OpenLoco::Config::write(); Gfx::invalidateScreen(); } #pragma mark - Station names minimum scale (Widget 17) // 0x004BFF72 static void stationNamesScaleMouseDown(Window* w, [[maybe_unused]] WidgetIndex_t wi) { Widget dropdown = w->widgets[Widx::station_names_min_scale]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 4, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::full_scale); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::half_scale); Dropdown::add(2, StringIds::dropdown_stringid, StringIds::quarter_scale); Dropdown::add(3, StringIds::dropdown_stringid, StringIds::eighth_scale); Dropdown::setItemSelected(Config::get().stationNamesMinScale); } // 0x004C0000 static void stationNamesScaleDropdown(int16_t ax) { if (ax == -1) { return; } if (ax == Config::get().stationNamesMinScale) { return; } auto& cfg = OpenLoco::Config::get(); cfg.stationNamesMinScale = ax; OpenLoco::Config::write(); Gfx::invalidateScreen(); } // 0x004BFBB7 static void onMouseDown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { switch (wi) { case Widx::construction_marker_btn: constructionMarkerMouseDown(&w, wi); break; case Widx::vehicles_min_scale_btn: vehicleZoomMouseDown(&w, wi); break; case Widx::station_names_min_scale_btn: stationNamesScaleMouseDown(&w, wi); break; } } // 0x004BFBE8 static void onDropdown([[maybe_unused]] Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id, int16_t item_index) { switch (wi) { case Widx::construction_marker_btn: constructionMarkerDropdown(item_index); break; case Widx::vehicles_min_scale_btn: vehicleZoomDropdown(item_index); break; case Widx::station_names_min_scale_btn: stationNamesScaleDropdown(item_index); break; } } // 0x004C01F5 static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } // 0x004BFA04 static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::rendering); Common::prepareDraw(w); if (Config::get().constructionMarker) { w.widgets[Widx::construction_marker].text = StringIds::translucent; } else { w.widgets[Widx::construction_marker].text = StringIds::white; } static constexpr StringId kScaleStringIds[] = { StringIds::full_scale, StringIds::half_scale, StringIds::quarter_scale, StringIds::eighth_scale, }; w.widgets[Widx::vehicles_min_scale].text = kScaleStringIds[Config::get().vehiclesMinScale]; w.widgets[Widx::station_names_min_scale].text = kScaleStringIds[Config::get().stationNamesMinScale]; if (Config::get().landscapeSmoothing) { w.activatedWidgets |= (1ULL << Widx::landscape_smoothing); } if (Config::get().gridlinesOnLandscape) { w.activatedWidgets |= (1ULL << Widx::gridlines_on_landscape); } if (Config::get().cashPopupRendering) { w.activatedWidgets |= (1ULL << Widx::cash_popup_rendering); } if (Config::get().showAiPlanningAsGhosts) { w.activatedWidgets |= (1ULL << Widx::show_company_ai_planning); } } // 0x004BFAF9 static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { // Draw widgets. w.draw(drawingCtx); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace AudioTab { // Some widget positions in pixels constexpr auto kSoundGroupOffset = 49; constexpr auto kSoundGroupLastItemOffset = 30; constexpr auto kSoundGroupHeight = kSoundGroupLastItemOffset + 19; constexpr auto kMusicGroupOffset = kSoundGroupOffset + kSoundGroupHeight + 4; constexpr auto kMusicGroupLastItemOffset = 73; constexpr auto kMusicGroupHeight = kMusicGroupLastItemOffset + 19; static constexpr Ui::Size32 kWindowSize = { 366, 49 + kSoundGroupHeight + 4 + kMusicGroupHeight + 4 }; namespace Widx { enum { frame_sound = Common::Widx::tab_miscellaneous + 1, audio_device, audio_device_btn, play_title_music, frame_jukebox, currently_playing_label, currently_playing, currently_playing_btn, music_controls_stop, music_controls_play, music_controls_next, music_volume_label, music_volume, music_playlist, music_playlist_btn, edit_selection }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::options_title_audio), Widgets::GroupBox({ 4, kSoundGroupOffset }, { kWindowSize.width - 8, kSoundGroupHeight }, WindowColour::secondary, StringIds::frame_sound), Widgets::dropdownWidgets({ 10, kSoundGroupOffset + 14 }, { 346, 12 }, WindowColour::secondary, StringIds::stringid), Widgets::Checkbox({ 10, kSoundGroupOffset + kSoundGroupLastItemOffset }, { 346, 12 }, WindowColour::secondary, StringIds::play_title_music), Widgets::GroupBox({ 4, kMusicGroupOffset }, { kWindowSize.width - 8, kMusicGroupHeight }, WindowColour::secondary, StringIds::frame_jukebox), Widgets::Label({ 10, kMusicGroupOffset + 14 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::currently_playing), Widgets::dropdownWidgets({ 160, kMusicGroupOffset + 14 }, { 196, 12 }, WindowColour::secondary, StringIds::stringid), Widgets::ImageButton({ 10, kMusicGroupOffset + 29 }, { 24, 24 }, WindowColour::secondary, ImageIds::music_controls_stop, StringIds::music_controls_stop_tip), Widgets::ImageButton({ 34, kMusicGroupOffset + 29 }, { 24, 24 }, WindowColour::secondary, ImageIds::music_controls_play, StringIds::music_controls_play_tip), Widgets::ImageButton({ 58, kMusicGroupOffset + 29 }, { 24, 24 }, WindowColour::secondary, ImageIds::music_controls_next, StringIds::music_controls_next_tip), Widgets::Label({ 160, kMusicGroupOffset + 35 }, { 215, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::music_volume), Widgets::Slider({ 256, kMusicGroupOffset + 35 - 6 }, { 109, 24 }, WindowColour::secondary, Widget::kContentNull, StringIds::set_music_volume_tip), Widgets::dropdownWidgets({ 10, kMusicGroupOffset + 58 }, { 346, 12 }, WindowColour::secondary, StringIds::stringid), Widgets::Button({ 183, kMusicGroupOffset + kMusicGroupLastItemOffset }, { 173, 12 }, WindowColour::secondary, StringIds::edit_music_selection, StringIds::edit_music_selection_tip)); static void audioDeviceMouseDown(Ui::Window* window); static void audioDeviceDropdown(Ui::Window* window, int16_t itemIndex); static void playTitleMusicOnMouseUp(Ui::Window* window); static void currentlyPlayingMouseDown(Window* w); static void currentlyPlayingDropdown(Window* w, int16_t ax); static void stopMusic(Window* w); static void playMusic(Window* w); static void playNextSong(Window* w); static void volumeMouseDown(Window* w); static void musicPlaylistMouseDown(Window* w); static void musicPlaylistDropdown(Window* w, int16_t ax); // 0x004C0217, 0x004C0217 static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::audio); Common::prepareDraw(w); // Audio device { auto args = FormatArguments(w.widgets[Widx::audio_device].textArgs); auto audioDeviceName = Audio::getCurrentDeviceName(); if (audioDeviceName != nullptr) { args.push(StringIds::stringptr); args.push(audioDeviceName); } else { args.push(StringIds::audio_device_none); } } // Currently playing music track { StringId songName = StringIds::music_none; if (SceneManager::isPlayMode()) { songName = Jukebox::getSelectedTrackTitleId(); } else if (SceneManager::isTitleMode()) { auto& cfg = Config::get(); if (cfg.audio.playTitleMusic) { songName = StringIds::locomotion_title; // Name of the title screen music } } auto args = FormatArguments(w.widgets[Widx::currently_playing].textArgs); args.push(songName); } // Jukebox controls (stop/play/skip) if (!SceneManager::isPlayMode()) { w.disabledWidgets |= (1ULL << Widx::currently_playing) | (1ULL << Widx::currently_playing_btn) | (1ULL << Widx::music_controls_play) | (1ULL << Widx::music_controls_stop) | (1ULL << Widx::music_controls_next); } else if (Jukebox::isMusicPlaying()) { // Play button appears pressed w.activatedWidgets |= (1ULL << Widx::music_controls_play); } else { // Stop button appears pressed w.activatedWidgets |= (1ULL << Widx::music_controls_stop); } // Selected playlist { static constexpr StringId playlist_string_ids[] = { StringIds::play_only_music_from_current_era, StringIds::play_all_music, StringIds::play_custom_music_selection, }; auto args = FormatArguments(w.widgets[Widx::music_playlist].textArgs); StringId selectedPlaylistStringId = playlist_string_ids[enumValue(Config::get().audio.playlist)]; args.push(selectedPlaylistStringId); } // Edit custom playlist music selection button if (Config::get().audio.playlist != Config::MusicPlaylistType::custom) { w.disabledWidgets |= (1ULL << Widx::edit_selection); } // Play title music checkbox if (Config::get().audio.playTitleMusic) { w.activatedWidgets |= (1ULL << Widx::play_title_music); } } // 0x004C02F5, 0x004C05F9 static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { // Draw widgets. w.draw(drawingCtx); // TODO: Move this in Slider widget. drawingCtx.drawImage(w.x + w.widgets[Widx::music_volume].left, w.y + w.widgets[Widx::music_volume].top, Gfx::recolour(ImageIds::volume_slider_track, w.getColour(WindowColour::secondary).c())); int16_t x = 90 + (Config::get().audio.mainVolume / 32); drawingCtx.drawImage(w.x + w.widgets[Widx::music_volume].left + x, w.y + w.widgets[Widx::music_volume].top, Gfx::recolour(ImageIds::volume_slider_thumb, w.getColour(WindowColour::secondary).c())); } static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::play_title_music: playTitleMusicOnMouseUp(&w); return; case Widx::music_controls_stop: stopMusic(&w); return; case Widx::music_controls_play: playMusic(&w); return; case Widx::music_controls_next: playNextSong(&w); return; case Widx::edit_selection: MusicSelection::open(); return; } } static void onMouseDown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { switch (wi) { case Widx::audio_device_btn: audioDeviceMouseDown(&w); break; case Widx::music_playlist_btn: musicPlaylistMouseDown(&w); break; case Widx::currently_playing_btn: currentlyPlayingMouseDown(&w); break; case Widx::music_volume: volumeMouseDown(&w); break; } } static void onDropdown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case Widx::audio_device_btn: audioDeviceDropdown(&window, itemIndex); break; case Widx::music_playlist_btn: musicPlaylistDropdown(&window, itemIndex); break; case Widx::currently_playing_btn: currentlyPlayingDropdown(&window, itemIndex); break; } } // 0x004C043D static void audioDeviceMouseDown(Ui::Window* w) { const auto& devices = Audio::getDevices(); if (devices.size() != 0) { Widget dropdown = w->widgets[Widx::audio_device]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), devices.size(), 0x80); for (size_t i = 0; i < devices.size(); i++) { auto name = devices[i].c_str(); Dropdown::add(i, StringIds::dropdown_stringid, { StringIds::stringptr, name }); } auto currentDevice = Audio::getCurrentDevice(); if (currentDevice != std::numeric_limits<size_t>().max()) { Dropdown::setItemSelected((int16_t)currentDevice); } } } // 0x004C04CA static void audioDeviceDropdown(Ui::Window* w, int16_t itemIndex) { if (itemIndex != -1) { Audio::setDevice(itemIndex); // Start playing the title screen music again if applicable (Fix for #2689) auto& config = Config::get(); if (SceneManager::isTitleMode() && config.audio.playTitleMusic) { Audio::playMusic(Environment::PathId::css5, config.audio.mainVolume, true); } WindowManager::invalidateWidget(w->type, w->number, Widx::audio_device); } } static void playTitleMusicOnMouseUp(Window* w) { auto& cfg = Config::get(); cfg.audio.playTitleMusic = !cfg.audio.playTitleMusic; Config::write(); w->invalidate(); if (!SceneManager::isTitleMode()) { return; } if (cfg.audio.playTitleMusic) { Audio::playMusic(Environment::PathId::css5, Config::get().audio.mainVolume, true); } else { Audio::stopMusic(); } } // 0x004C0875 static void currentlyPlayingMouseDown(Window* w) { auto tracks = Jukebox::makeSelectedPlaylist(); Widget dropdown = w->widgets[Widx::currently_playing]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), tracks.size(), 0x80); int index = -1; for (auto track : tracks) { index++; Dropdown::add(index, StringIds::dropdown_stringid, Jukebox::getMusicInfo(track).titleId); if (track == Jukebox::getCurrentTrack()) { Dropdown::setItemSelected(index); } } } // 0x004C09F8 static void currentlyPlayingDropdown(Window* w, int16_t ax) { if (ax == -1) { return; } auto track = Jukebox::makeSelectedPlaylist().at(ax); if (Jukebox::requestTrack(track)) { w->invalidate(); } } // 0x004C0778 static void stopMusic(Window* w) { if (Jukebox::disableMusic()) { w->invalidate(); } } // 0x004C07A4 static void playMusic(Window* w) { if (Jukebox::enableMusic()) { w->invalidate(); } } // 0x004C07C4 static void playNextSong(Window* w) { if (Jukebox::skipCurrentTrack()) { w->invalidate(); } } // 0x004C072A static void volumeMouseDown(Window* w) { Input::setClickRepeatTicks(31); auto mousePos = Input::getScrollLastLocation(); int x = mousePos.x - w->x - w->widgets[Widx::music_volume].left - 10; x = std::clamp(x, 0, 80); Audio::setBgmVolume((x * 32) - 2560); w->invalidate(); } // 0x004C07E4 static void musicPlaylistMouseDown(Window* w) { Widget dropdown = w->widgets[Widx::music_playlist]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 3, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::play_only_music_from_current_era); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::play_all_music); Dropdown::add(2, StringIds::dropdown_stringid, StringIds::play_custom_music_selection); Dropdown::setItemSelected(enumValue(Config::get().audio.playlist)); } // 0x004C084A static void musicPlaylistDropdown(Window* w, int16_t index) { if (index == -1) { return; } auto& cfg = Config::get().audio; cfg.playlist = Config::MusicPlaylistType(index); Config::write(); w->invalidate(); if (!SceneManager::isTitleMode()) // Prevents title music from stopping { Audio::revalidateCurrentTrack(); } WindowManager::close(WindowType::musicSelection); } // 0x004C04E0, 0x004C0A37 static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Regional { static constexpr Ui::Size32 kWindowSize = { 366, 167 }; namespace Widx { enum { language_label = Common::Widx::tab_miscellaneous + 1, language, language_btn, distance_label, distance_speed, distance_speed_btn, heights_label, heights, heights_btn, currency_label, currency, currency_btn, preferred_currency_label, preferred_currency, preferred_currency_btn, preferred_currency_for_new_games, preferred_currency_always }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::options_title_regional), Widgets::Label({ 10, 49 }, { 173, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::options_language), Widgets::dropdownWidgets({ 183, 49 }, { 173, 12 }, WindowColour::secondary, StringIds::stringptr), Widgets::Label({ 10, 69 }, { 173, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::distance_and_speed), Widgets::dropdownWidgets({ 183, 69 }, { 173, 12 }, WindowColour::secondary, StringIds::stringid), Widgets::Label({ 10, 84 }, { 173, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::heights), Widgets::dropdownWidgets({ 183, 84 }, { 173, 12 }, WindowColour::secondary, StringIds::stringid), Widgets::Label({ 10, 104 }, { 173, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::current_game_currency), Widgets::dropdownWidgets({ 183, 104 }, { 173, 12 }, WindowColour::secondary, StringIds::stringid, StringIds::current_game_currency_tip), Widgets::Label({ 10, 119 }, { 173, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::new_game_currency), Widgets::dropdownWidgets({ 183, 119 }, { 173, 12 }, WindowColour::secondary, StringIds::preferred_currency_buffer, StringIds::new_game_currency_tip), Widgets::Checkbox({ 10, 134 }, { 346, 12 }, WindowColour::secondary, StringIds::use_preferred_currency_new_game, StringIds::use_preferred_currency_new_game_tip), Widgets::Checkbox({ 10, 148 }, { 346, 12 }, WindowColour::secondary, StringIds::use_preferred_currency_always, StringIds::use_preferred_currency_always_tip) ); static void languageMouseDown(Window* w); static void languageDropdown(Window* w, int16_t ax); static void currencyMouseDown(Window* w); static void currencyDropdown(Window* w, int16_t ax); static void preferredCurrencyMouseDown(Window* w); static void preferredCurrencyDropdown(Window* w, int16_t ax); static void preferredCurrencyNewGameMouseUp(Window* w); static void preferredCurrencyAlwaysMouseUp(Window* w); static void distanceSpeedMouseDown(Window* w); static void distanceSpeedDropdown(Window* w, int16_t ax); static void heightsLabelsMouseDown(Window* w); static void heightsLabelsDropdown(Window* w, int16_t ax); // 0x004C0A59 static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::regional); Common::prepareDraw(w); { auto args = FormatArguments(w.widgets[Widx::language].textArgs); auto& language = Localisation::getDescriptorForLanguage(Config::get().language); _chosenLanguage = language.nativeName; args.push(_chosenLanguage.c_str()); } { auto args = FormatArguments(w.widgets[Widx::distance_speed].textArgs); StringId current_measurement_format = StringIds::imperial; if (OpenLoco::Config::get().measurementFormat == Config::MeasurementFormat::metric) { current_measurement_format = StringIds::metric; } args.push(current_measurement_format); } { auto args = FormatArguments(w.widgets[Widx::currency].textArgs); args.push(ObjectManager::get<CurrencyObject>()->name); } { auto args = FormatArguments(w.widgets[Widx::heights].textArgs); StringId current_height_units = StringIds::height_units; if (!OpenLoco::Config::get().showHeightAsUnits) { current_height_units = StringIds::height_real_values; } args.push(current_height_units); } if (Config::get().usePreferredCurrencyForNewGames) { w.activatedWidgets |= (1ULL << Widx::preferred_currency_for_new_games); } if (Config::get().usePreferredCurrencyAlways) { w.activatedWidgets |= (1ULL << Widx::preferred_currency_always); } if (Config::get().usePreferredCurrencyAlways || SceneManager::isTitleMode()) { w.disabledWidgets |= (1ULL << Widx::currency); w.disabledWidgets |= (1ULL << Widx::currency_btn); } } // 0x004C0B5B static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { // Draw widgets. w.draw(drawingCtx); } static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::preferred_currency_for_new_games: preferredCurrencyNewGameMouseUp(&w); return; case Widx::preferred_currency_always: preferredCurrencyAlwaysMouseUp(&w); return; } } // 0x004BFBB7 static void onMouseDown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { switch (wi) { case Widx::language_btn: languageMouseDown(&w); break; case Widx::heights_btn: heightsLabelsMouseDown(&w); break; case Widx::distance_speed_btn: distanceSpeedMouseDown(&w); break; case Widx::currency_btn: currencyMouseDown(&w); break; case Widx::preferred_currency_btn: preferredCurrencyMouseDown(&w); break; } } // 0x004C0C4A static void onDropdown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case Widx::language_btn: languageDropdown(&window, itemIndex); break; case Widx::heights_btn: heightsLabelsDropdown(&window, itemIndex); break; case Widx::distance_speed_btn: distanceSpeedDropdown(&window, itemIndex); break; case Widx::currency_btn: currencyDropdown(&window, itemIndex); break; case Widx::preferred_currency_btn: preferredCurrencyDropdown(&window, itemIndex); break; } } static void languageMouseDown(Window* w) { const auto lds = Localisation::getLanguageDescriptors(); uint8_t numLanguages = static_cast<uint8_t>(lds.size()); Widget dropdown = w->widgets[Widx::language]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), numLanguages - 1, 0x80); std::string& current_language = Config::get().language; for (uint8_t index = 1; index < numLanguages; index++) { auto& ld = lds[index]; Dropdown::add(index - 1, StringIds::dropdown_stringptr, (char*)ld.nativeName.c_str()); if (ld.locale == current_language) { Dropdown::setItemSelected(index - 1); } } } static void languageDropdown(Window* w, int16_t ax) { if (ax == -1) { w->invalidate(); return; } const auto lds = Localisation::getLanguageDescriptors(); const auto& ld = lds[ax + 1]; Config::get().language = ld.locale; Config::write(); Localisation::loadLanguageFile(); // Reloading the objects will force objects to load the new language ObjectManager::reloadAll(); Gfx::invalidateScreen(); // Rebuild the scenario index to use the new language. ScenarioManager::loadIndex(true); } // 0x004C0C73 static void currencyMouseDown(Window* w) { const auto selectedObjectFlags = getLoadedSelectedObjectFlags(); Widget dropdown = w->widgets[Widx::currency]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), _112C185, 0x80); int index = -1; for (auto& object : _availableCurrencies) { index++; Dropdown::add(index, StringIds::dropdown_stringptr, object.name.c_str()); if ((selectedObjectFlags[object.index] & ObjectManager::SelectedObjectsFlags::selected) != ObjectManager::SelectedObjectsFlags::none) { Dropdown::setItemSelected(index); } } } // 0x004C0D33 static void currencyDropdown(Window* w, int16_t ax) { if (ax == -1) { w->invalidate(); return; } const auto selectedObjectFlags = getLoadedSelectedObjectFlags(); int index = -1; for (const auto& object : _availableCurrencies) { index++; if (index == ax) { auto ebp = ObjectManager::getActiveObject(ObjectType::currency, selectedObjectFlags); if (ebp.index != ObjectManager::kNullObjectIndex) { ObjectManager::unload(ebp.object._header); } ObjectManager::load(object.header); ObjectManager::reloadAll(); Gfx::loadCurrency(); ObjectManager::markOnlyLoadedObjects(selectedObjectFlags); break; } } w->invalidate(); } // 0x004C0DCF static void preferredCurrencyMouseDown(Window* w) { Widget dropdown = w->widgets[Widx::preferred_currency]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), _112C185, 0x80); int index = -1; for (auto& object : _availableCurrencies) { index++; Dropdown::add(index, StringIds::dropdown_stringptr, object.name.c_str()); if (OpenLoco::Config::get().preferredCurrency == object.header) { Dropdown::setItemSelected(index); } } } // 0x004C0E82 static void preferredCurrencyDropdown(Window* w, int16_t ax) { if (ax == -1) { w->invalidate(); return; } int index = -1; for (const auto& object : _availableCurrencies) { index++; if (index == ax) { auto& cfg = OpenLoco::Config::get(); cfg.preferredCurrency = object.header; setPreferredCurrencyNameBuffer(); Config::write(); Scenario::loadPreferredCurrencyAlways(); ObjectManager::markOnlyLoadedObjects(getLoadedSelectedObjectFlags()); break; } } w->invalidate(); } // 0x004C0F14 static void preferredCurrencyNewGameMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.usePreferredCurrencyForNewGames ^= true; Config::write(); w->invalidate(); } // 0x004C0F27 static void preferredCurrencyAlwaysMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.usePreferredCurrencyAlways ^= true; Config::write(); Scenario::loadPreferredCurrencyAlways(); ObjectManager::markOnlyLoadedObjects(getLoadedSelectedObjectFlags()); w->invalidate(); } // 0x004C0F49 static void distanceSpeedMouseDown(Window* w) { Widget dropdown = w->widgets[Widx::distance_speed]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 2, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::imperial); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::metric); Dropdown::setItemSelected(static_cast<uint8_t>(Config::get().measurementFormat)); } // 0x004C0FB3 static void distanceSpeedDropdown([[maybe_unused]] Window* w, int16_t ax) { if (ax == -1) { return; } auto& cfg = Config::get(); cfg.measurementFormat = Config::MeasurementFormat(ax); // 0x004C0FC2 cfg.heightMarkerOffset = 0; if (!cfg.showHeightAsUnits) { cfg.heightMarkerOffset = cfg.measurementFormat == Config::MeasurementFormat::imperial ? 1 : 2; } Config::write(); Gfx::invalidateScreen(); } // 0x004C0FFA static void heightsLabelsMouseDown(Window* w) { Widget dropdown = w->widgets[Widx::heights]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 2, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::height_units); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::height_real_values); int selectedItem = 0; if (!Config::get().showHeightAsUnits) { selectedItem = 1; } Dropdown::setItemSelected(selectedItem); } // 0x004C106C static void heightsLabelsDropdown([[maybe_unused]] Window* w, int16_t index) { if (index == -1) { return; } auto& cfg = Config::get(); cfg.showHeightAsUnits = index == 0; // 0x004C0FC2 cfg.heightMarkerOffset = 0; if (!cfg.showHeightAsUnits) { cfg.heightMarkerOffset = cfg.measurementFormat == Config::MeasurementFormat::imperial ? 1 : 2; } Config::write(); Gfx::invalidateScreen(); } // 0x004C1195 static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Controls { namespace Widx { enum { edge_scrolling = Common::Widx::tab_miscellaneous + 1, zoom_to_cursor, invertRightMouseViewPan, customize_keys }; } static constexpr Ui::Size32 kWindowSize = { 366, 114 }; static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::options_title_controls), Widgets::Checkbox({ 10, 49 }, { 346, 12 }, WindowColour::secondary, StringIds::scroll_screen_edge, StringIds::scroll_screen_edge_tip), Widgets::Checkbox({ 10, 64 }, { 346, 12 }, WindowColour::secondary, StringIds::zoom_to_cursor, StringIds::zoom_to_cursor_tip), Widgets::Checkbox({ 10, 79 }, { 346, 12 }, WindowColour::secondary, StringIds::invert_right_mouse_dragging, StringIds::tooltip_invert_right_mouse_dragging), Widgets::Button({ 26, 94 }, { 160, 12 }, WindowColour::secondary, StringIds::customise_keys, StringIds::customise_keys_tip) ); static void edgeScrollingMouseUp(Window* w); static void zoomToCursorMouseUp(Window* w); static void invertRightMouseViewPan(Window* w); static void openKeyboardShortcuts(); static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::controls); Common::prepareDraw(w); w.activatedWidgets &= ~(1ULL << Widx::edge_scrolling | 1ULL << Widx::zoom_to_cursor | 1ULL << Widx::invertRightMouseViewPan); if (Config::get().edgeScrolling) { w.activatedWidgets |= (1ULL << Widx::edge_scrolling); } if (Config::get().zoomToCursor) { w.activatedWidgets |= (1ULL << Widx::zoom_to_cursor); } if (Config::get().invertRightMouseViewPan) { w.activatedWidgets |= (1ULL << Widx::invertRightMouseViewPan); } } // 0x004C113F static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { w.draw(drawingCtx); } // 0x004C114A static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::customize_keys: openKeyboardShortcuts(); break; case Widx::edge_scrolling: edgeScrollingMouseUp(&w); break; case Widx::zoom_to_cursor: zoomToCursorMouseUp(&w); break; case Widx::invertRightMouseViewPan: invertRightMouseViewPan(&w); break; } } // 0x004C117A static void edgeScrollingMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.edgeScrolling = !cfg.edgeScrolling; Config::write(); w->invalidate(); } static void zoomToCursorMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.zoomToCursor = !cfg.zoomToCursor; Config::write(); w->invalidate(); } static void invertRightMouseViewPan(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.invertRightMouseViewPan = !cfg.invertRightMouseViewPan; Config::write(); w->invalidate(); } // 0x004C118D static void openKeyboardShortcuts() { KeyboardShortcuts::open(); } // 0x004C1195 static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Company { static constexpr Ui::Size32 kWindowSize = { 420, 134 }; namespace Widx { enum { groupPreferredOwner = Common::Widx::tab_miscellaneous + 1, usePreferredOwnerFace, changeOwnerFaceBtn, labelOwnerFace, usePreferredOwnerName, changeOwnerNameBtn, labelPreferredOwnerName, ownerFacePreview, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::options_title_company), // Preferred owner group Widgets::GroupBox({ 4, 50 }, { 412, 80 }, WindowColour::secondary, StringIds::preferred_owner_name), // Preferred owner face Widgets::Checkbox({ 10, 64 }, { 400, 12 }, WindowColour::secondary, StringIds::usePreferredCompanyFace, StringIds::usePreferredCompanyFaceTip), Widgets::Button({ 265, 79 }, { 75, 12 }, WindowColour::secondary, StringIds::change), Widgets::Label({ 24, 79 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::currentPreferredFace), // Preferred owner name Widgets::Checkbox({ 10, 97 }, { 400, 12 }, WindowColour::secondary, StringIds::use_preferred_owner_name, StringIds::use_preferred_owner_name_tip), Widgets::Button({ 265, 112 }, { 75, 12 }, WindowColour::secondary, StringIds::change), Widgets::Label({ 24, 112 }, { 240, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::wcolour2_preferred_owner_name), // Preferred owner preview Widgets::ImageButton({ 345, 59 }, { 66, 66 }, WindowColour::secondary, Widget::kContentNull) ); static void loadPreferredFace(Window& self) { if (WindowManager::getCurrentModalType() == WindowType::companyFaceSelection) { self.object = nullptr; return; } auto& preferredOwnerFace = Config::get().preferredOwnerFace; if (self.object != nullptr) { // Ensure our temporary object is still loaded auto* object = ObjectManager::getTemporaryObject(); if (object == reinterpret_cast<Object*>(self.object)) { return; } } ObjectManager::freeTemporaryObject(); if (ObjectManager::loadTemporaryObject(preferredOwnerFace)) { self.object = reinterpret_cast<std::byte*>(ObjectManager::getTemporaryObject()); } else { // Can't be loaded? Disable the option auto& cfg = Config::get(); cfg.usePreferredOwnerFace = false; cfg.preferredOwnerFace = kEmptyObjectHeader; Config::write(); self.object = nullptr; } } static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::company); Common::prepareDraw(w); if (Config::get().usePreferredOwnerName) { w.activatedWidgets |= (1ULL << Widx::usePreferredOwnerName); } else { w.disabledWidgets |= (1ULL << Widx::changeOwnerNameBtn); } if (Config::get().usePreferredOwnerFace) { w.activatedWidgets |= (1ULL << Widx::usePreferredOwnerFace); } else { w.disabledWidgets |= ((1ULL << Widx::changeOwnerFaceBtn) | (1ULL << Widx::ownerFacePreview)); w.widgets[Widx::labelOwnerFace].text = StringIds::empty; w.widgets[Widx::ownerFacePreview].content = Widget::kContentNull; w.object = nullptr; } // Set preferred owner name. { // TODO: Do not share this buffer, also unsafe, we should change the localisation to use a string pointer. auto buffer = (char*)StringManager::getString(StringIds::buffer_2039); const char* playerName = Config::get().preferredOwnerName.c_str(); strcpy(buffer, playerName); buffer[strlen(playerName)] = '\0'; FormatArguments args{ w.widgets[Widx::labelPreferredOwnerName].textArgs }; args.push(StringIds::buffer_2039); } // Set preferred owner face. if (w.object != nullptr) { const CompetitorObject* competitor = reinterpret_cast<CompetitorObject*>(w.object); w.widgets[Widx::labelOwnerFace].text = StringIds::currentPreferredFace; FormatArguments args{ w.widgets[Widx::labelOwnerFace].textArgs }; args.push(competitor->name); w.widgets[Widx::ownerFacePreview].image = ImageId(competitor->images[0]).withIndexOffset(1).withPrimary(Colour::black).toUInt32(); } loadPreferredFace(w); } static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { w.draw(drawingCtx); } // 0x004C1319 static void changePreferredName(Window* w) { auto buffer = (char*)StringManager::getString(StringIds::buffer_2039); const char* playerName = Config::get().preferredOwnerName.c_str(); strcpy(buffer, playerName); buffer[strlen(playerName)] = '\0'; TextInput::openTextInput(w, StringIds::preferred_owner_name, StringIds::enter_preferred_owner_name, StringIds::buffer_2039, Widx::usePreferredOwnerName, nullptr); } // 0x004C135F static void usePreferredOwnerNameMouseUp(Window* w) { auto& cfg = Config::get(); cfg.usePreferredOwnerName ^= true; Config::write(); w->invalidate(); if (cfg.usePreferredOwnerName && cfg.preferredOwnerName.empty()) { changePreferredName(w); } } static void changePreferredFace(Window& self) { CompanyFaceSelection::open(CompanyId::neutral, self.type); } static void usePreferredOwnerFaceMouseUp(Window* w) { auto& cfg = Config::get(); cfg.usePreferredOwnerFace ^= true; Config::write(); w->invalidate(); if (cfg.usePreferredOwnerFace && cfg.preferredOwnerFace == kEmptyObjectHeader) { changePreferredFace(*w); } } static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::usePreferredOwnerName: usePreferredOwnerNameMouseUp(&w); break; case Widx::changeOwnerNameBtn: changePreferredName(&w); break; case Widx::usePreferredOwnerFace: usePreferredOwnerFaceMouseUp(&w); break; case Widx::changeOwnerFaceBtn: case Widx::ownerFacePreview: changePreferredFace(w); break; } } // 0x004C1342 static void setPreferredName(Window* w, const char* str) { auto& cfg = Config::get(); cfg.preferredOwnerName = str; if (cfg.preferredOwnerName.empty()) { cfg.usePreferredOwnerName = false; } Config::write(); w->invalidate(); } // 0x004C1304 static void textInput(Window& w, WidgetIndex_t i, [[maybe_unused]] const WidgetId id, const char* str) { switch (i) { case Widx::usePreferredOwnerName: setPreferredName(&w, str); break; } } // 0x004C139C static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onUpdate = onUpdate, .textInput = textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Misc { static constexpr Ui::Size32 kWindowSize = { 420, 266 }; namespace Widx { enum { groupCheats = Common::Widx::tab_miscellaneous + 1, enableCheatsToolbarButton, disableAICompanies, disableTownExpansion, groupVehicleBehaviour, disable_vehicle_breakdowns, disable_vehicle_load_penalty, disableStationSizeLimit, trainsReverseAtSignals, groupSaveOptions, autosave_frequency_label, autosave_frequency, autosave_frequency_btn, autosave_amount_label, autosave_amount, autosave_amount_down_btn, autosave_amount_up_btn, export_plugin_objects, }; } static constexpr auto _widgets = makeWidgets( Common::makeCommonWidgets(kWindowSize, StringIds::options_title_miscellaneous), // Gameplay tweaks group Widgets::GroupBox({ 4, 49 }, { 412, 62 }, WindowColour::secondary, StringIds::gameplay_tweaks), Widgets::Checkbox({ 10, 64 }, { 400, 12 }, WindowColour::secondary, StringIds::option_cheat_menu_enable, StringIds::tooltip_option_cheat_menu_enable), Widgets::Checkbox({ 10, 79 }, { 400, 12 }, WindowColour::secondary, StringIds::disableAICompanies, StringIds::disableAICompanies_tip), Widgets::Checkbox({ 10, 94 }, { 400, 12 }, WindowColour::secondary, StringIds::disableTownExpansion, StringIds::disableTownExpansion_tip), // Vehicle behaviour Widgets::GroupBox({ 4, 115 }, { 412, 77 }, WindowColour::secondary, StringIds::vehicleTrackBehaviour), Widgets::Checkbox({ 10, 130 }, { 400, 12 }, WindowColour::secondary, StringIds::disable_vehicle_breakdowns), Widgets::Checkbox({ 10, 145 }, { 200, 12 }, WindowColour::secondary, StringIds::disableVehicleLoadingPenalty, StringIds::disableVehicleLoadingPenaltyTip), Widgets::Checkbox({ 10, 160 }, { 200, 12 }, WindowColour::secondary, StringIds::disableStationSizeLimitLabel, StringIds::disableStationSizeLimitTooltip), Widgets::Checkbox({ 10, 175 }, { 400, 12 }, WindowColour::secondary, StringIds::trainsReverseAtSignals), // Save options group Widgets::GroupBox({ 4, 196 }, { 412, 65 }, WindowColour::secondary, StringIds::autosave_preferences), Widgets::Label({ 10, 211 }, { 200, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::autosave_frequency), Widgets::dropdownWidgets({ 250, 211 }, { 156, 12 }, WindowColour::secondary, StringIds::empty), Widgets::Label({ 10, 226 }, { 200, 12 }, WindowColour::secondary, ContentAlign::left, StringIds::autosave_amount), Widgets::stepperWidgets({ 250, 226 }, { 156, 12 }, WindowColour::secondary, StringIds::empty), Widgets::Checkbox({ 10, 241 }, { 400, 12 }, WindowColour::secondary, StringIds::export_plugin_objects, StringIds::export_plugin_objects_tip) ); static void enableCheatsToolbarButtonMouseUp(Window* w); static void disableVehicleBreakdownsMouseUp(Window* w); static void trainsReverseAtSignalsMouseUp(Window* w); static void disableAICompaniesMouseUp(Window* w); static void disableTownExpansionMouseUp(Window* w); static void exportPluginObjectsMouseUp(Window* w); // 0x004C11B7 static void prepareDraw(Window& w) { assert(w.currentTab == Common::tab::miscellaneous); Common::prepareDraw(w); if (Config::get().cheatsMenuEnabled) { w.activatedWidgets |= (1ULL << Widx::enableCheatsToolbarButton); } if (Config::get().breakdownsDisabled) { w.activatedWidgets |= (1ULL << Widx::disable_vehicle_breakdowns); } if (Config::get().trainsReverseAtSignals) { w.activatedWidgets |= (1ULL << Widx::trainsReverseAtSignals); } if (Config::get().disableVehicleLoadPenaltyCheat) { w.activatedWidgets |= (1ULL << Widx::disable_vehicle_load_penalty); } if (Config::get().disableStationSizeLimit) { w.activatedWidgets |= (1ULL << Widx::disableStationSizeLimit); } if (Config::get().companyAIDisabled) { w.activatedWidgets |= (1ULL << Widx::disableAICompanies); } if (Config::get().townGrowthDisabled) { w.activatedWidgets |= (1ULL << Widx::disableTownExpansion); } if (Config::get().exportObjectsWithSaves) { w.activatedWidgets |= (1ULL << Widx::export_plugin_objects); } w.widgets[Widx::export_plugin_objects].hidden = !ObjectManager::getCustomObjectsInIndexStatus(); } static void drawDropdownContent(Window* w, Gfx::DrawingContext& drawingCtx, WidgetIndex_t widgetIndex, StringId stringId, int32_t value) { auto tr = Gfx::TextRenderer(drawingCtx); auto& widget = w->widgets[widgetIndex]; FormatArguments args{}; args.push(stringId); args.push(value); auto point = Point(w->x + widget.left + 1, w->y + widget.top + 1); tr.drawStringLeft(point, Colour::black, StringIds::black_stringid, args); } // 0x004C1282 static void draw(Window& w, Gfx::DrawingContext& drawingCtx) { w.draw(drawingCtx); // Value for autosave frequency auto freq = Config::get().autosaveFrequency; StringId stringId; switch (freq) { case 0: stringId = StringIds::autosave_never; break; case 1: stringId = StringIds::autosave_every_month; break; default: stringId = StringIds::autosave_every_x_months; break; } drawDropdownContent(&w, drawingCtx, Widx::autosave_frequency, stringId, freq); // Value for autosave amount auto scale = Config::get().autosaveAmount; drawDropdownContent(&w, drawingCtx, Widx::autosave_amount, StringIds::int_32, scale); } static void changeAutosaveAmount(Window* w, int32_t delta) { auto& cfg = Config::get(); auto newValue = std::clamp(cfg.autosaveAmount + delta, 1, 24); if (cfg.autosaveAmount != newValue) { cfg.autosaveAmount = newValue; Config::write(); w->invalidate(); } } static void changeAutosaveFrequency(Window* w, int32_t value) { auto& cfg = Config::get(); if (cfg.autosaveFrequency != value) { cfg.autosaveFrequency = value; Config::write(); w->invalidate(); } } static void showAutosaveFrequencyDropdown(Window* w, WidgetIndex_t wi) { auto dropdown = w->widgets[wi]; Dropdown::show(w->x + dropdown.left, w->y + dropdown.top, dropdown.width() - 4, dropdown.height(), w->getColour(WindowColour::secondary), 5, 0x80); // Add pre-defined entries Dropdown::add(0, StringIds::dropdown_stringid, { StringIds::autosave_never }); Dropdown::add(1, StringIds::dropdown_stringid, { StringIds::autosave_every_month }); Dropdown::add(2, StringIds::dropdown_stringid, { StringIds::autosave_every_x_months, static_cast<uint32_t>(3) }); Dropdown::add(3, StringIds::dropdown_stringid, { StringIds::autosave_every_x_months, static_cast<uint32_t>(6) }); Dropdown::add(4, StringIds::dropdown_stringid, { StringIds::autosave_every_x_months, static_cast<uint32_t>(12) }); // Set current selection auto freq = Config::get().autosaveFrequency; std::optional<size_t> selected; switch (freq) { case 0: selected = 0; break; case 1: selected = 1; break; case 3: selected = 2; break; case 6: selected = 3; break; case 12: selected = 4; break; } if (selected) { Dropdown::setItemSelected(*selected); } } static void handleAutosaveFrequencyDropdown(Window* w, int32_t index) { switch (index) { case 0: changeAutosaveFrequency(w, 0); break; case 1: changeAutosaveFrequency(w, 1); break; case 2: changeAutosaveFrequency(w, 3); break; case 3: changeAutosaveFrequency(w, 6); break; case 4: changeAutosaveFrequency(w, 12); break; } } // 0x004C12D2 static void onMouseUp(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { if (Common::onMouseUp(w, wi, id)) { return; } switch (wi) { case Widx::enableCheatsToolbarButton: enableCheatsToolbarButtonMouseUp(&w); break; case Widx::disable_vehicle_breakdowns: disableVehicleBreakdownsMouseUp(&w); break; case Widx::trainsReverseAtSignals: trainsReverseAtSignalsMouseUp(&w); break; case Widx::disable_vehicle_load_penalty: Config::get().disableVehicleLoadPenaltyCheat = !Config::get().disableVehicleLoadPenaltyCheat; WindowManager::invalidateWidget(w.type, w.number, Widx::disable_vehicle_load_penalty); break; case Widx::disableStationSizeLimit: Config::get().disableStationSizeLimit ^= true; WindowManager::invalidateWidget(w.type, w.number, Widx::disableStationSizeLimit); break; case Widx::disableAICompanies: disableAICompaniesMouseUp(&w); break; case Widx::disableTownExpansion: disableTownExpansionMouseUp(&w); break; case Widx::export_plugin_objects: exportPluginObjectsMouseUp(&w); break; } } static void onMouseDown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { switch (wi) { case Widx::autosave_frequency_btn: showAutosaveFrequencyDropdown(&w, Widx::autosave_frequency); break; case Widx::autosave_amount_down_btn: changeAutosaveAmount(&w, -1); break; case Widx::autosave_amount_up_btn: changeAutosaveAmount(&w, 1); break; } } static void onDropdown(Window& w, WidgetIndex_t wi, [[maybe_unused]] const WidgetId id, int16_t item_index) { switch (wi) { case Widx::autosave_frequency_btn: handleAutosaveFrequencyDropdown(&w, item_index); break; } } static void enableCheatsToolbarButtonMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.cheatsMenuEnabled = !cfg.cheatsMenuEnabled; Config::write(); w->invalidate(); WindowManager::invalidate(WindowType::topToolbar); } static void disableVehicleBreakdownsMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.breakdownsDisabled = !cfg.breakdownsDisabled; Config::write(); w->invalidate(); } static void trainsReverseAtSignalsMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.trainsReverseAtSignals = !cfg.trainsReverseAtSignals; Config::write(); w->invalidate(); } static void disableAICompaniesMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.companyAIDisabled = !cfg.companyAIDisabled; Config::write(); w->invalidate(); } static void disableTownExpansionMouseUp(Window* w) { auto& cfg = OpenLoco::Config::get(); cfg.townGrowthDisabled = !cfg.townGrowthDisabled; Config::write(); w->invalidate(); } static void exportPluginObjectsMouseUp(Window* w) { auto& cfg = Config::get(); cfg.exportObjectsWithSaves ^= true; Config::write(); w->invalidate(); } // 0x004C139C static void onUpdate(Window& w) { w.frameNo += 1; w.callPrepareDraw(); WindowManager::invalidateWidget(w.type, w.number, w.currentTab + 4); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } static void sub_4BF8CD() { auto ptr = static_cast<ObjectManager::SelectedObjectsFlags*>(malloc(ObjectManager::getNumInstalledObjects())); // TODO: reimplement nullptr check? __11364A0 = ptr; ObjectManager::markOnlyLoadedObjects(getLoadedSelectedObjectFlags()); } static void disableTabsByCurrentScene(Window& w) { w.disabledWidgets &= ~(1ULL << Common::Widx::tab_regional); if (SceneManager::isEditorMode() && Scenario::getOptions().editorStep == EditorController::Step::objectSelection) { w.disabledWidgets |= 1ULL << Common::Widx::tab_regional; } Widget::leftAlignTabs(w, Common::Widx::tab_display, Common::Widx::tab_miscellaneous); } // 0x004C1519 & 0x00474911 static void setPreferredCurrencyNameBuffer() { const auto res = ObjectManager::findObjectInIndex(Config::get().preferredCurrency); if (res.has_value()) { auto buffer = const_cast<char*>(StringManager::getString(StringIds::preferred_currency_buffer)); strcpy(buffer, res->_name.c_str()); } } // 0x004BF7B9 Window* open() { Window* window; window = WindowManager::bringToFront(WindowType::options); if (window != nullptr) { return window; } // 0x004BF833 (create_options_window) window = WindowManager::createWindowCentred( WindowType::options, Display::kWindowSize, WindowFlags::none, Display::getEvents()); window->setWidgets(Display::_widgets); window->number = 0; window->currentTab = 0; window->frameNo = 0; window->rowHover = -1; window->object = nullptr; auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowOptionsColour); sub_4BF8CD(); populateAvailableCurrencies(); setPreferredCurrencyNameBuffer(); Display::applyScreenModeRestrictions(window); window->holdableWidgets = 0; window->eventHandlers = &Display::getEvents(); window->activatedWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); return window; } // 0x004BF823 Window* openMusicSettings() { auto window = open(); window->callOnMouseUp(Common::Widx::tab_audio, window->widgets[Common::Widx::tab_audio].id); return window; } struct TabInformation { std::span<const Widget> widgets; const WindowEventList& events; Ui::Size32 kWindowSize; }; // clang-format off static TabInformation kTabInformationByTabOffset[] = { { Display::_widgets, Display::getEvents(), Display::kWindowSize }, { Rendering::_widgets, Rendering::getEvents(), Rendering::kWindowSize }, { AudioTab::_widgets, AudioTab::getEvents(), AudioTab::kWindowSize }, { Regional::_widgets, Regional::getEvents(), Regional::kWindowSize }, { Controls::_widgets, Controls::getEvents(), Controls::kWindowSize }, { Company::_widgets, Company::getEvents(), Company::kWindowSize }, { Misc::_widgets, Misc::getEvents(), Misc::kWindowSize }, }; // clang-format on // 0x004BFC11 static void tabOnMouseUp(Window* w, WidgetIndex_t wi) { ToolManager::toolCancel(w->type, w->number); TextInput::sub_4CE6C9(w->type, w->number); w->currentTab = wi - Common::Widx::tab_display; w->frameNo = 0; w->flags &= ~(WindowFlags::flag_16); w->disabledWidgets = 0; w->holdableWidgets = 0; w->activatedWidgets = 0; w->rowHover = -1; w->viewportRemove(0); auto& tabInfo = kTabInformationByTabOffset[w->currentTab]; w->eventHandlers = &tabInfo.events; w->setWidgets(tabInfo.widgets); w->invalidate(); w->setSize(tabInfo.kWindowSize); if ((Common::tab)w->currentTab == Common::tab::display) { Display::applyScreenModeRestrictions(w); } else if ((Common::tab)w->currentTab == Common::tab::audio) { w->holdableWidgets = (1ULL << AudioTab::Widx::music_volume); } w->callOnResize(); w->callPrepareDraw(); w->initScrollWidgets(); w->invalidate(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/PlayerInfoPanel.cpp ```cpp #include "Date.h" #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Intro.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui.h" #include "Ui/Dropdown.h" #include "Ui/ToolTip.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include "World/Company.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <map> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::PlayerInfoPanel { static constexpr Ui::Size32 kWindowSize = { 140, 27 }; namespace Widx { enum { outer_frame, inner_frame, player, company_value, performanceIndex }; } static void performanceIndexMouseUp(); static void companyValueTooltip(FormatArguments& args); static void performanceIndexTooltip(FormatArguments& args); static void companyValueMouseUp(); // 0x00509d08 static constexpr auto _widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 140, 29 }, WindowColour::primary), Widgets::Wt3Widget({ 2, 2 }, { 136, 25 }, WindowColour::primary), Widgets::ImageButton({ 1, 1 }, { 26, 26 }, WindowColour::primary), Widgets::ImageButton({ 27, 2 }, { 111, 12 }, WindowColour::primary, Widget::kContentNull, StringIds::tooltip_company_value), Widgets::ImageButton({ 27, 14 }, { 111, 12 }, WindowColour::primary, Widget::kContentNull, StringIds::tooltip_performance_index) ); std::vector<const Company*> _sortedCompanies; static loco_global<uint16_t, 0x0050A004> _50A004; static loco_global<uint16_t, 0x0113DC78> _113DC78; // Dropdown flags? // 0x43AA4C static void playerMouseDown(Ui::Window* self, WidgetIndex_t widgetIndex) { _sortedCompanies.clear(); for (const auto& c : CompanyManager::companies()) { _sortedCompanies.push_back(&c); } sort( _sortedCompanies.begin(), _sortedCompanies.end(), [](const Company* a, const Company* b) { return a->performanceIndex > b->performanceIndex; }); const StringId positionArray[15] = { StringIds::position_1st, StringIds::position_2nd, StringIds::position_3rd, StringIds::position_4th, StringIds::position_5th, StringIds::position_6th, StringIds::position_7th, StringIds::position_8th, StringIds::position_9th, StringIds::position_10th, StringIds::position_11th, StringIds::position_12th, StringIds::position_13th, StringIds::position_14th, StringIds::position_15th, }; int index = 0; auto highlightIndex = -1; for (auto company : _sortedCompanies) { auto competitorObj = ObjectManager::get<CompetitorObject>(company->competitorId); auto args = FormatArguments(); args.push(positionArray[index]); args.push(Gfx::recolour(competitorObj->images[enumValue(company->ownerEmotion)], company->mainColours.primary)); args.push(company->name); args.push<uint16_t>(0); // Needed after a user string id formatPerformanceIndex(company->performanceIndex, args); Dropdown::add(index, StringIds::dropdown_company_performance, args); if (CompanyManager::isPlayerCompany(company->id())) { highlightIndex = index; } index++; } Dropdown::add(index++, StringIds::dropdown_companies_list, ImageIds::company_list_dropdown_icon); Dropdown::showBelow(self, widgetIndex, index, 25, (1 << 6)); if (highlightIndex != -1) { Dropdown::setHighlightedItem(highlightIndex); } _113DC78 = _113DC78 | (1 << 1); } // 0x43AB87 static void playerDropdownClick(int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } // If its index is bigger than the list then its the company list extra item if (static_cast<uint16_t>(itemIndex) >= _sortedCompanies.size()) { CompanyList::open(); } else { auto company = _sortedCompanies[itemIndex]; if (!company->empty()) { CompanyWindow::open(company->id()); } } } static const WindowEventList& getEvents(); // 0x00438BC7 Window* open() { auto window = WindowManager::createWindow( WindowType::playerInfoToolbar, { 0, Ui::height() - kWindowSize.height }, { kWindowSize.width, kWindowSize.height }, Ui::WindowFlags::stickToFront | Ui::WindowFlags::transparent | Ui::WindowFlags::noBackground, getEvents()); window->setWidgets(_widgets); window->var_854 = 0; window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, AdvancedColour(skin->playerInfoToolbarColour).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(skin->playerInfoToolbarColour).translucent()); } return window; } // 0x004393E7 static void prepareDraw(Window& window) { window.widgets[Widx::inner_frame].hidden = true; } // 0x43944B static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Widget& frame = window.widgets[Widx::outer_frame]; drawingCtx.drawRect(window.x + frame.left, window.y + frame.top, frame.width(), frame.height(), enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); // Draw widgets. window.draw(drawingCtx); drawingCtx.drawRectInset(window.x + frame.left + 1, window.y + frame.top + 1, frame.width() - 2, frame.height() - 2, window.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); auto playerCompany = CompanyManager::get(CompanyManager::getControllingId()); auto competitor = ObjectManager::get<CompetitorObject>(playerCompany->competitorId); auto image = Gfx::recolour(competitor->images[enumValue(playerCompany->ownerEmotion)], playerCompany->mainColours.primary); drawingCtx.drawImage(window.x + frame.left + 2, window.y + frame.top + 2, image); auto x = window.x + frame.width() / 2 + 12; { auto companyValueString = StringIds::player_info_bankrupt; if ((playerCompany->challengeFlags & CompanyFlags::bankrupt) == CompanyFlags::none) { if (static_cast<int16_t>(playerCompany->cash.var_04) < 0) { companyValueString = StringIds::player_info_company_value_negative; } else { companyValueString = StringIds::player_info_company_value; } } auto colour = window.getColour(WindowColour::primary).opaque(); if (Input::isHovering(WindowType::playerInfoToolbar, 0, Widx::company_value)) { colour = Colour::white; } auto args = FormatArguments(); args.push(playerCompany->cash.var_00); args.push(playerCompany->cash.var_04); auto point = Point(x, window.y + frame.top + 2); tr.drawStringCentred(point, colour, companyValueString, args); } { auto performanceString = StringIds::player_info_performance; if ((playerCompany->challengeFlags & CompanyFlags::increasedPerformance) != CompanyFlags::none) { performanceString = StringIds::player_info_performance_increase; } else if ((playerCompany->challengeFlags & CompanyFlags::decreasedPerformance) != CompanyFlags::none) { performanceString = StringIds::player_info_performance_decrease; } auto colour = window.getColour(WindowColour::primary).opaque(); if (Input::isHovering(WindowType::playerInfoToolbar, 0, Widx::performanceIndex)) { colour = Colour::white; } auto args = FormatArguments(); args.push(playerCompany->performanceIndex); auto point = Point(x, window.y + frame.top + 14); tr.drawStringCentred(point, colour, performanceString, args); } } // 0x004395A4 static void onMouseUp([[maybe_unused]] Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::company_value: companyValueMouseUp(); break; case Widx::performanceIndex: performanceIndexMouseUp(); break; } } // 0x004395B1 static void onMouseDown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::player: playerMouseDown(&window, widgetIndex); break; } } // 0x004395BC static void onDropdown([[maybe_unused]] Window& w, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t item_index) { switch (widgetIndex) { case Widx::player: playerDropdownClick(item_index); break; } } // 0x4395C7 static void companyValueMouseUp() { CompanyWindow::openFinances(CompanyManager::getControllingId()); } // 0x4395D6 static void performanceIndexMouseUp() { CompanyList::openPerformanceIndexes(); } // 0x004395DE static Ui::CursorId onCursor([[maybe_unused]] Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, [[maybe_unused]] int16_t yPos, Ui::CursorId fallback) { switch (widgetIndex) { case Widx::company_value: case Widx::performanceIndex: Ui::ToolTip::setTooltipTimeout(2000); break; } return fallback; } // 0x004395F5 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; switch (widgetIndex) { case Widx::company_value: companyValueTooltip(args); break; case Widx::performanceIndex: performanceIndexTooltip(args); break; } return args; } static void companyValueTooltip(FormatArguments& args) { auto playerCompany = CompanyManager::get(CompanyManager::getControllingId()); args.push(playerCompany->companyValueHistory[0]); args.push(playerCompany->vehicleProfit); } // 0x439643 static void performanceIndexTooltip(FormatArguments& args) { auto playerCompany = CompanyManager::get(CompanyManager::getControllingId()); formatPerformanceIndex(playerCompany->performanceIndex, args); } void invalidateFrame() { _50A004 = _50A004 | (1 << 0); } // 0x00439670 static void onUpdate(Window& w) { w.var_854++; if (w.var_854 >= 24) { w.var_854 = 0; } if (_50A004 & (1 << 0)) { _50A004 = _50A004 & ~(1 << 0); WindowManager::invalidateWidget(WindowType::playerInfoToolbar, 0, Widx::inner_frame); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseHover = onMouseDown, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .tooltip = tooltip, .cursor = onCursor, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ProgressBar.cpp ```cpp #include "Ui/ProgressBar.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Localisation/StringIds.h" #include "SceneManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Window.h" #include "Ui/WindowManager.h" #include <array> #include <string> #include <string_view> namespace OpenLoco::Ui::Windows::ProgressBar { enum Widx { frame, caption, panel, }; static constexpr Ui::Size32 kWindowSize = { 350, 47 }; static constexpr auto widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 350, 47 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 348, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::buffer_1250), Widgets::Panel({ 0, 15 }, { 350, 32 }, WindowColour::secondary) ); static std::string _captionString; static uint8_t _progressBarStyle = 0; // 0x005233C8 static uint8_t _progressBarValue = 0; // 0x011370A8 void setProgress(uint8_t value); static const WindowEventList& getEvents(); // 0x004CF6E2 Window* open(std::string_view captionString) { _captionString = captionString; SceneManager::addSceneFlags(SceneManager::Flags::progressBarActive); _progressBarValue = 0xFF; auto window = WindowManager::createWindowCentred( WindowType::progressBar, kWindowSize, WindowFlags::flag_11 | WindowFlags::stickToFront, getEvents()); window->setWidgets(widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, Colour::black); window->setColour(WindowColour::secondary, Colour::black); setProgress(0); return window; } // 0x004CF74E void close() { SceneManager::removeSceneFlags(SceneManager::Flags::progressBarActive); WindowManager::close(WindowType::progressBar); Gfx::invalidateScreen(); _progressBarStyle ^= 1; } // 0x004CF76D void setProgress(uint8_t value) { if (_progressBarValue == value) { return; } _progressBarValue = value; WindowManager::invalidate(WindowType::progressBar); Gfx::renderAndUpdate(); } // 0x004CF78A static void prepareDraw([[maybe_unused]] Window& self) { // Keep the window centered. self.x = (Ui::width() / 2) - (self.width / 2); self.y = std::max(28, (Ui::height() / 2) - (self.height / 2)); char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); strncpy(buffer, _captionString.c_str(), 256); } // 004CF7A0 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { const auto& rt = drawingCtx.currentRenderTarget(); self.draw(drawingCtx); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(self.x + 2, self.y + 17, self.width - 5, self.height - 19)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); // First, draw the train track. drawingCtx.drawImage(0, 0, ImageIds::progressbar_track); // What train image to use depends on the progress bar style. uint32_t trainImage; if (_progressBarStyle == 0) { static std::array<uint32_t, 4> style0Frames = { ImageIds::progressbar_style0_frame0, ImageIds::progressbar_style0_frame1, ImageIds::progressbar_style0_frame2, ImageIds::progressbar_style0_frame3, }; auto currentFrame = (_progressBarValue / 4) % std::size(style0Frames); trainImage = Gfx::recolour2(style0Frames.at(currentFrame), Colour::mutedSeaGreen, Colour::mutedDarkRed); } else { static std::array<uint32_t, 4> style1Frames = { ImageIds::progressbar_style1_frame0, ImageIds::progressbar_style1_frame1, ImageIds::progressbar_style1_frame2, ImageIds::progressbar_style1_frame3, }; auto currentFrame = (_progressBarValue / 4) % std::size(style1Frames); trainImage = Gfx::recolour2(style1Frames.at(currentFrame), Colour::black, Colour::mutedGrassGreen); } // Draw the train image from the right of the window, int16_t xPos = _progressBarValue - 255; drawingCtx.drawImage(xPos, 0, trainImage); drawingCtx.popRenderTarget(); } static constexpr WindowEventList kEvents = { .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/PromptBrowseWindow.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Environment.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/Conversion.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Logging.h" #include "OpenLoco.h" #include "S5/S5.h" #include "Scenario.h" #include "ScenarioOptions.h" #include "Ui.h" #include "Ui/TextInput.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TextBoxWidget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Core/FileSystem.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Platform/Platform.h> #include <OpenLoco/Utility/String.hpp> #include <SDL2/SDL.h> #include <algorithm> #include <cstring> #include <string> using namespace OpenLoco::Interop; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Ui::Windows::PromptBrowse { enum BrowseFileType : uint8_t { savedGame, landscape, heightmap, }; enum widx { frame, caption, close_button, panel, parent_button, text_filename, ok_button, scrollview, }; static constexpr auto widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 500, 380 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 498, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::empty), Widgets::ImageButton({ 485, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 500, 365 }, WindowColour::secondary), Widgets::ImageButton({ 473, 18 }, { 24, 24 }, WindowColour::secondary, ImageIds::icon_parent_folder, StringIds::window_browse_parent_folder_tooltip), Widgets::TextBox({ 88, 348 }, { 408, 14 }, WindowColour::secondary), Widgets::Button({ 426, 364 }, { 70, 12 }, WindowColour::secondary, StringIds::label_button_ok), Widgets::ScrollView({ 3, 45 }, { 494, 323 }, WindowColour::secondary, Scrollbars::vertical) ); static uint8_t _type; // 0x009D9D63 static BrowseFileType _fileType; // 0x009DA284 static char _displayFolderBuffer[512]; // 0x009DA084 static char _filter[32]; // 0x009D9E64 // 0x0112CE04 static std::optional<std::string> _targetPath; // 0x0050AEA8 static std::unique_ptr<S5::SaveDetails> _previewSaveDetails; // 0x009CCA54 static std::unique_ptr<Scenario::Options> _previewScenarioOptions; static Ui::TextInput::InputSession inputSession; static fs::path _currentDirectory; static std::vector<fs::path> _files; static fs::path getDirectory(const fs::path& path); static std::string getBasename(const fs::path& path); static void drawSavePreview(Ui::Window& window, Gfx::DrawingContext& drawingCtx, int32_t x, int32_t y, int32_t width, int32_t height, const S5::SaveDetails& saveInfo); static void drawLandscapePreview(Ui::Window& window, Gfx::DrawingContext& drawingCtx, int32_t x, int32_t y, int32_t width, int32_t height); static void drawTextInput(Ui::Window* window, Gfx::DrawingContext& drawingCtx, const char* text, int32_t caret, bool showCaret); static void upOneLevel(); static void changeDirectory(const fs::path& path); static void processFileForLoadSave(Window* window); static void processFileForDelete(Window* self, fs::path& entry); static void refreshDirectoryList(); static void loadFileDetails(Window* self); static bool filenameContainsInvalidChars(); static const WindowEventList& getEvents(); // 0x00445AB9 // ecx: path // edx: filter // ebx: title // eax: {return} std::optional<std::string> open( browse_type type, std::string_view savePath, const char* filter, StringId titleId) { auto path = fs::u8path(savePath); auto directory = getDirectory(path); auto baseName = getBasename(path); TextInput::cancel(); _type = type; _fileType = BrowseFileType::savedGame; if (Utility::iequals(filter, S5::filterSC5)) { _fileType = BrowseFileType::landscape; } // TODO: make named constant for filter else if (Utility::iequals(filter, "*.png")) { _fileType = BrowseFileType::heightmap; } Utility::strlcpy(_filter, filter, std::size(_filter)); changeDirectory(directory.make_preferred()); inputSession = Ui::TextInput::InputSession(baseName, 200); auto window = WindowManager::createWindowCentred( WindowType::fileBrowserPrompt, { 500, 380 }, Ui::WindowFlags::stickToFront | Ui::WindowFlags::resizable | Ui::WindowFlags::flag_12, getEvents()); if (window != nullptr) { window->setWidgets(widgets); window->widgets[widx::caption].text = titleId; window->initScrollWidgets(); window->rowHeight = 11; window->var_85A = -1; auto& widget = window->widgets[widx::text_filename]; inputSession.calculateTextOffset(widget.width()); // Focus the textbox element Input::setFocus(window->type, window->number, widx::text_filename); window->setColour(WindowColour::primary, Colour::black); window->setColour(WindowColour::secondary, Colour::mutedSeaGreen); WindowManager::setCurrentModalType(WindowType::fileBrowserPrompt); const bool success = promptTickLoop( []() { Input::handleKeyboard(); Audio::updateSounds(); WindowManager::dispatchUpdateAll(); Input::processKeyboardInput(); Input::processMouseWheel(); WindowManager::update(); Ui::minimalHandleInput(); Gfx::renderAndUpdate(); return WindowManager::find(WindowType::fileBrowserPrompt) != nullptr; }); WindowManager::setCurrentModalType(WindowType::undefined); return success ? _targetPath : std::nullopt; } return std::nullopt; } // 0x00447174 static void freeFileDetails() { _previewSaveDetails.reset(); } // 0x0044647C static void onClose(Window&) { _files.clear(); freeFileDetails(); } // 0x004467F6 static void onResize(Window& window) { window.capSize(400, 300, 640, 800); } // 0x00446465 static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close_button: _currentDirectory.clear(); _targetPath = std::nullopt; WindowManager::close(&window); break; case widx::parent_button: upOneLevel(); window.var_85A = -1; window.initScrollWidgets(); window.invalidate(); break; case widx::ok_button: processFileForLoadSave(&window); break; } } // 0x004467E1 static void onUpdate(Ui::Window& window) { inputSession.cursorFrame++; if ((inputSession.cursorFrame & 0x0F) == 0) { window.invalidate(); } } // 0x004464A1 static void getScrollSize(Ui::Window& window, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = window.rowHeight * _files.size(); } // 0x004464F7 static void onScrollMouseDown(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { auto index = size_t(y / self.rowHeight); if (index >= _files.size()) { return; } Audio::playSound(Audio::SoundId::clickDown, self.x + (self.width / 2)); auto& entry = _files[index]; // Clicking a directory, with left mouse button? if (Input::state() == Input::State::scrollLeft && fs::is_directory(entry)) { changeDirectory(entry); self.var_85A = -1; self.initScrollWidgets(); self.invalidate(); return; } // Clicking a file, with left mouse button? if (Input::state() == Input::State::scrollLeft) { // Copy the selected filename without extension to text input buffer. inputSession.buffer = entry.stem().u8string(); inputSession.cursorPosition = inputSession.buffer.length(); self.invalidate(); // Continue processing for load/save. processFileForLoadSave(&self); } // Clicking a file, with right mouse button else { processFileForDelete(&self, entry); } } // 0x004464B1 static void onScrollMouseOver(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scrollIndex) { if (WindowManager::getCurrentModalType() != WindowType::fileBrowserPrompt) { return; } auto index = y / self.rowHeight; if (index >= static_cast<uint16_t>(_files.size())) { return; } if (self.var_85A == index) { return; } self.var_85A = index; loadFileDetails(&self); self.invalidate(); } // 0x004467D7 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_list); return args; } // 0x00445C8F static void prepareDraw(Ui::Window& self) { self.widgets[widx::frame].right = self.width - 1; self.widgets[widx::frame].bottom = self.height - 1; self.widgets[widx::panel].right = self.width - 1; self.widgets[widx::panel].bottom = self.height - 1; self.widgets[widx::caption].right = self.width - 2; self.widgets[widx::close_button].left = self.width - 15; self.widgets[widx::close_button].right = self.width - 3; if (_type == browse_type::save) { self.widgets[widx::ok_button].left = self.width - 86; self.widgets[widx::ok_button].right = self.width - 16; self.widgets[widx::ok_button].top = self.height - 15; self.widgets[widx::ok_button].bottom = self.height - 4; self.widgets[widx::ok_button].hidden = false; self.widgets[widx::text_filename].right = self.width - 4; self.widgets[widx::text_filename].top = self.height - 31; self.widgets[widx::text_filename].bottom = self.height - 18; self.widgets[widx::text_filename].hidden = false; self.widgets[widx::scrollview].bottom = self.height - 34; } else { self.widgets[widx::ok_button].hidden = true; self.widgets[widx::text_filename].hidden = true; self.widgets[widx::scrollview].bottom = self.height - 4; } self.widgets[widx::scrollview].right = self.width - 259; if (_fileType != BrowseFileType::savedGame) { self.widgets[widx::scrollview].right += 122; } self.widgets[widx::parent_button].left = self.width - 26; self.widgets[widx::parent_button].right = self.width - 3; // Get width of the base 'Folder:' string char folderBuffer[256]{}; FormatArguments args{}; args.push(StringIds::empty); StringManager::formatString(folderBuffer, StringIds::window_browse_folder, args); const auto folderLabelWidth = Gfx::TextRenderer::getStringWidth(Gfx::Font::medium_bold, folderBuffer); // We'll ensure the folder width does not reach the parent button. const uint16_t maxWidth = self.widgets[widx::parent_button].left - folderLabelWidth - 10; auto nameBuffer = _currentDirectory.u8string(); nameBuffer = Localisation::convertUnicodeToLoco(nameBuffer); strncpy(&_displayFolderBuffer[0], nameBuffer.c_str(), 512); uint16_t folderWidth = Gfx::TextRenderer::getStringWidth(Gfx::Font::medium_bold, _displayFolderBuffer); // If the folder already fits, we're done. if (folderWidth <= maxWidth) { return; } const char* relativeDirectory = nameBuffer.c_str(); do { // If we're omitting part of the folder, prepend ellipses. if (relativeDirectory != nameBuffer.c_str()) { strncpy(_displayFolderBuffer, "...", std::size(_displayFolderBuffer) - 1); } // Seek the next directory separator token. while (*relativeDirectory != '\0' && *relativeDirectory != fs::path::preferred_separator) { relativeDirectory++; } // Use the truncated directory name in the buffer. strncat(_displayFolderBuffer, relativeDirectory, std::size(_displayFolderBuffer) - 1); // Prepare for the next pass, if needed. relativeDirectory++; } while (Gfx::TextRenderer::getStringWidth(Gfx::Font::medium_bold, _displayFolderBuffer) > maxWidth); } static FormatArguments getStringPtrFormatArgs(const char* buffer) { FormatArguments args = {}; args.push(StringIds::stringptr); args.push(buffer); return args; } // 0x00445E38 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); window.draw(drawingCtx); { auto folder = &_displayFolderBuffer[0]; auto args = getStringPtrFormatArgs(folder); auto point = Point(window.x + 3, window.y + window.widgets[widx::parent_button].top + 6); tr.drawStringLeft(point, Colour::black, StringIds::window_browse_folder, args); } auto selectedIndex = window.var_85A; if (selectedIndex != -1) { auto& selectedFile = _files[selectedIndex]; if (!fs::is_directory(selectedFile)) { const auto& widget = window.widgets[widx::scrollview]; auto width = window.width - widget.right - 8; auto x = window.x + widget.right + 3; auto y = window.y + 45; auto nameBuffer = selectedFile.stem().u8string(); nameBuffer = Localisation::convertUnicodeToLoco(nameBuffer); auto args = getStringPtrFormatArgs(nameBuffer.c_str()); auto point = Point(x + (width / 2), y); tr.drawStringCentredClipped( point, width, Colour::black, StringIds::wcolour2_stringid, args); y += 12; if (_fileType == BrowseFileType::savedGame) { // Preview image if (_previewSaveDetails != nullptr) { drawSavePreview(window, drawingCtx, x, y, width, 201, *_previewSaveDetails); } } else if (_fileType == BrowseFileType::landscape) { if (_previewScenarioOptions != nullptr) { drawLandscapePreview(window, drawingCtx, x, y, width, 129); } } } } const auto& filenameBox = window.widgets[widx::text_filename]; if (!filenameBox.hidden) { // Draw filename label auto point = Point(window.x + 3, window.y + filenameBox.top + 2); tr.drawStringLeft(point, Colour::black, StringIds::window_browse_filename); // Clip to text box const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(window.x + filenameBox.left + 1, window.y + filenameBox.top + 1, filenameBox.right - filenameBox.left - 1, filenameBox.bottom - filenameBox.top - 1)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); bool showCaret = Input::isFocused(window.type, window.number, widx::text_filename) && (inputSession.cursorFrame & 0x10) == 0; drawTextInput(&window, drawingCtx, inputSession.buffer.c_str(), inputSession.cursorPosition, showCaret); drawingCtx.popRenderTarget(); } } } static void drawSavePreview(Ui::Window& window, Gfx::DrawingContext& drawingCtx, int32_t x, int32_t y, int32_t width, int32_t height, const S5::SaveDetails& saveInfo) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.fillRectInset(x, y, x + width, y + height, window.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); auto imageId = 0; auto g1 = Gfx::getG1Element(imageId); if (g1 != nullptr) { // Temporarily substitute a g1 for the image data in the saved game auto backupg1 = *g1; *g1 = {}; g1->offset = (uint8_t*)saveInfo.image; g1->width = 250; g1->height = 200; drawingCtx.drawImage(x + 1, y + 1, imageId); *g1 = backupg1; } y += 207; uint16_t maxWidth = window.width - window.widgets[widx::scrollview].right; auto point = Point(x, y); // Company { auto args = getStringPtrFormatArgs(saveInfo.company); point = tr.drawStringLeftWrapped(point, maxWidth, Colour::black, StringIds::window_browse_company, args); } // Owner { auto args = getStringPtrFormatArgs(saveInfo.owner); point = tr.drawStringLeftWrapped(point, maxWidth, Colour::black, StringIds::owner_label, args); } // Date { auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(saveInfo.date); point = tr.drawStringLeftWrapped(point, maxWidth, Colour::black, StringIds::window_browse_date, args); } // Challenge progress auto flags = saveInfo.challengeFlags; if ((flags & CompanyFlags::challengeBeatenByOpponent) == CompanyFlags::none) { auto stringId = StringIds::window_browse_challenge_completed; int16_t progress = 0; if ((flags & CompanyFlags::challengeCompleted) == CompanyFlags::none) { stringId = StringIds::window_browse_challenge_failed; if ((flags & CompanyFlags::challengeFailed) == CompanyFlags::none) { stringId = StringIds::window_browse_challenge_progress; progress = saveInfo.challengeProgress; } } auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(progress); tr.drawStringLeftWrapped(point, maxWidth, Colour::black, stringId, args); } } static void drawLandscapePreview(Ui::Window& window, Gfx::DrawingContext& drawingCtx, int32_t x, int32_t y, int32_t width, int32_t height) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.fillRectInset(x, y, x + width, y + height, window.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); if ((_previewScenarioOptions->scenarioFlags & Scenario::ScenarioFlags::landscapeGenerationDone) != Scenario::ScenarioFlags::none) { // Height map auto imageId = 0; auto g1 = Gfx::getG1Element(imageId); if (g1 != nullptr) { // Temporarily substitute a g1 for the height map image data in the saved game auto backupg1 = *g1; *g1 = {}; g1->offset = &_previewScenarioOptions->preview[0][0]; g1->width = 128; g1->height = 128; drawingCtx.drawImage(x + 1, y + 1, imageId); *g1 = backupg1; drawingCtx.drawImage(x, y + 1, ImageIds::height_map_compass); } } else { // Randomly generated landscape auto imageId = Gfx::recolour(ImageIds::random_map_watermark, window.getColour(WindowColour::secondary).c()); drawingCtx.drawImage(x, y, imageId); auto origin = Ui::Point(x + 64, y + 60); tr.drawStringCentredWrapped(origin, 128, Colour::black, StringIds::randomly_generated_landscape); } } static void drawTextInput(Ui::Window* window, Gfx::DrawingContext& drawingCtx, const char* text, int32_t caret, bool showCaret) { auto tr = Gfx::TextRenderer(drawingCtx); // Draw text box text Ui::Point origin = { 0, 1 }; { auto args = getStringPtrFormatArgs(text); tr.drawStringLeft(origin, Colour::black, StringIds::black_stringid, args); } if (showCaret) { if (caret == -1) { // Draw horizontal caret tr.drawStringLeft(origin, Colour::black, StringIds::window_browse_input_caret); } else { // Draw text[0:caret] over the top // TODO this should really just be measuring the string const std::string gbuffer = std::string(text, caret); auto args = getStringPtrFormatArgs(gbuffer.c_str()); origin = { 0, 1 }; origin = tr.drawStringLeft(origin, Colour::black, StringIds::black_stringid, args); // Draw vertical caret drawingCtx.drawRect(origin.x, origin.y, 1, 9, Colours::getShade(window->getColour(WindowColour::secondary).c(), 9), Gfx::RectFlags::none); } } } static bool isRootPath(const fs::path& entry) { return (entry == entry.root_path()); } // 0x00446314 static void drawScroll(Ui::Window& window, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); // Background drawingCtx.clearSingle(Colours::getShade(window.getColour(WindowColour::secondary).c(), 4)); // Directories / files auto i = 0; auto y = 0; auto lineHeight = window.rowHeight; for (const auto& entry : _files) { if (y + lineHeight < rt.y) { y += lineHeight; i++; continue; } else if (y > rt.y + rt.height) { break; } // Draw the row highlight auto stringId = StringIds::black_stringid; if (i == window.var_85A) { drawingCtx.drawRect(0, y, window.width, lineHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); stringId = StringIds::wcolour2_stringid; } // Draw the folder icon (TODO: draw a drive for rootPath) auto x = 1; if (isRootPath(entry) || fs::is_directory(entry)) { drawingCtx.drawImage(x, y, ImageIds::icon_folder); x += 14; } // Copy name to our work buffer (if drive letter use the full path) auto nameBuffer = isRootPath(entry) ? entry.u8string() : entry.stem().u8string(); nameBuffer = Localisation::convertUnicodeToLoco(nameBuffer); // Draw the name auto args = getStringPtrFormatArgs(nameBuffer.c_str()); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, stringId, args); y += lineHeight; i++; } } // 0x0044685C static bool keyUp(Window& w, uint32_t charCode, uint32_t keyCode) { if (keyCode == SDLK_RETURN) { w.callOnMouseUp(widx::ok_button, w.widgets[widx::ok_button].id); return true; } else if (keyCode == SDLK_ESCAPE) { w.callOnMouseUp(widx::close_button, w.widgets[widx::close_button].id); return true; } else if (!Input::isFocused(w.type, w.number, widx::text_filename) || !inputSession.handleInput(charCode, keyCode)) { return false; } // 0x00446A6E auto containerWidth = w.widgets[widx::text_filename].width() - 2; if (inputSession.needsReoffsetting(containerWidth)) { inputSession.calculateTextOffset(containerWidth); } w.invalidate(); return true; } static fs::path getDirectory(const fs::path& path) { if (path.has_extension()) { return path.parent_path() / ""; } else { auto str = path.u8string(); if (str.size() > 0) { auto lastCharacter = str[str.size() - 1]; if (lastCharacter == fs::path::preferred_separator) { return path; } } return path / ""; } } static std::string getBasename(const fs::path& path) { auto baseName = path.stem().u8string(); if (baseName == ".") { baseName = ""; } return baseName; } // 0x00446A93 static void refreshDirectoryList() { // All our filters are probably *.something so just truncate the * // and treat as an extension filter auto filterExtension = std::string(_filter); if (filterExtension[0] == '*') { filterExtension = filterExtension.substr(1); } _files.clear(); if (_currentDirectory.empty()) { // Get all drives _files = Platform::getDrives(); return; // no need to sort these as they are already sorted } else { try { for (const auto& file : fs::directory_iterator(_currentDirectory, fs::directory_options::skip_permission_denied)) { // Only list directories and normal files if (!(file.is_regular_file() || file.is_directory())) { continue; } // Filter files by extension if (file.is_regular_file()) { auto extension = file.path().extension().u8string(); if (!Utility::iequals(extension, filterExtension)) { continue; } } _files.emplace_back(file.path()); } } catch (const fs::filesystem_error& err) { Logging::error("Invalid directory or file: {}", err.what()); } } std::sort(_files.begin(), _files.end(), [](const fs::path& a, const fs::path& b) -> bool { if (!fs::is_directory(a) && fs::is_directory(b)) { return false; } if (fs::is_directory(a) && !fs::is_directory(b)) { return true; } return a.stem() < b.stem(); }); } // 0x00446E2F static void upOneLevel() { #ifdef _WIN32 // Showing drive letters? if (_currentDirectory.empty()) { return; } // The drive letter level is above file system root level. if (isRootPath(_currentDirectory)) { _currentDirectory.clear(); refreshDirectoryList(); } #endif // Going up one level (compensating for trailing slashes). changeDirectory(_currentDirectory.parent_path().parent_path()); } // 0x00446E62 static void changeDirectory(const fs::path& newDir) { _currentDirectory = newDir / ""; refreshDirectoryList(); } // 0x00446F1D static bool filenameContainsInvalidChars() { uint8_t numNonSpacesProcessed = 0; for (const char chr : inputSession.buffer) { if (chr != ' ') { numNonSpacesProcessed++; } switch (chr) { // The following chars are considered invalid in filenames. case '.': case '"': case '\\': case '*': case '?': case ':': case ';': case ',': case '<': case '>': case '/': return true; } } // If we have only processed spaces, the filename is invalid as well. return numNonSpacesProcessed == 0; } static constexpr const char* getExtensionFromFileType(BrowseFileType type) { switch (type) { case BrowseFileType::savedGame: return S5::extensionSV5; case BrowseFileType::heightmap: return ".png"; case BrowseFileType::landscape: default: return S5::extensionSC5; } } // 0x00446574 static void processFileForLoadSave(Window* self) { // Create full path to target file. fs::path path = _currentDirectory / inputSession.buffer; // Append extension to filename. path += getExtensionFromFileType(_fileType); if (_type == browse_type::save) { if (filenameContainsInvalidChars()) { Error::open(StringIds::error_invalid_filename); return; } // Does the file already exist? if (fs::exists(path)) { // Copy directory and filename to buffer. char* buffer_2039 = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(&buffer_2039[0], inputSession.buffer.c_str(), 512); // Arguments for description text in ok/cancel window. FormatArguments args{}; args.push(StringIds::buffer_2039); // Ask for confirmation to replace the file. auto titleId = self->widgets[widx::caption].text; if (!Windows::PromptOkCancel::open(titleId, StringIds::replace_existing_file_prompt, args, StringIds::replace_existing_file_button)) { return; } } } // Copy directory and filename to buffer. _targetPath = path.u8string(); // Remember the current path for saved games if (_fileType == BrowseFileType::savedGame) { if (!fs::is_directory(_currentDirectory)) { Config::get().lastSavePath = _currentDirectory.parent_path().u8string(); } else { Config::get().lastSavePath = _currentDirectory.u8string(); } Config::write(); Environment::resolvePaths(); } // ... and similarly for landscapes else if (_fileType == BrowseFileType::landscape) { if (!fs::is_directory(_currentDirectory)) { Config::get().lastLandscapePath = _currentDirectory.parent_path().u8string(); } else { Config::get().lastLandscapePath = _currentDirectory.u8string(); } Config::write(); Environment::resolvePaths(); } // Close browse window to continue saving. WindowManager::close(self); } // 0x004466CA static void processFileForDelete(Window* self, fs::path& entry) { // Create full path to target file. fs::path path = _currentDirectory / entry.stem(); path += getExtensionFromFileType(_fileType); // Copy directory and filename to buffer. char* buffer_2039 = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(&buffer_2039[0], entry.stem().u8string().c_str(), 512); FormatArguments args{}; args.push(StringIds::buffer_2039); // Ask for confirmation to delete the file. auto titleId = self->widgets[widx::caption].text; if (!Windows::PromptOkCancel::open(titleId, StringIds::delete_file_prompt, args, StringIds::delete_file_button)) { return; } // Actually remove the file..! fs::remove(path); // Refresh window refreshDirectoryList(); self->invalidate(); } // 0x00446E87 static void loadFileDetails(Window* self) { freeFileDetails(); if (self->var_85A == -1) { return; } auto& entry = _files[self->var_85A]; if (fs::is_directory(entry)) { return; } // Create full path to target file. auto path = _currentDirectory / entry.stem(); path += getExtensionFromFileType(_fileType); // Load save game or scenario info. switch (_fileType) { case BrowseFileType::savedGame: _previewSaveDetails = S5::readSaveDetails(path); break; case BrowseFileType::landscape: _previewScenarioOptions = S5::readScenarioOptions(path); break; default: break; } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, .keyUp = keyUp, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/PromptOkCancelWindow.cpp ```cpp #include "Audio/Audio.h" #include "Graphics/Colour.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "OpenLoco.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/WindowManager.h" #include <SDL2/SDL.h> #include <cstring> namespace OpenLoco::Ui::Windows::PromptOkCancel { static char _descriptionBuffer[512]; static bool _result; // 0x009D1C9A enum widx { frame, caption, closeButton, okButton, cancelButton, }; static constexpr auto _widgets = makeWidgets( Widgets::Panel({ 0, 0 }, { 280, 92 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 278, 13 }, Widgets::Caption::Style::boxed, WindowColour::primary), Widgets::Button({ 267, 2 }, { 11, 11 }, WindowColour::primary, StringIds::close_window_cross, StringIds::tooltip_close_window), Widgets::Button({ 20, 77 }, { 100, 12 }, WindowColour::primary, StringIds::label_ok), Widgets::Button({ 160, 77 }, { 100, 12 }, WindowColour::primary, StringIds::label_button_cancel) ); static const WindowEventList& getEvents(); // 0x00446F6B // eax: okButtonStringId // eax: {return} bool open(StringId captionId, StringId descriptionId, FormatArguments& descriptionArgs, StringId okButtonStringId) { auto window = WindowManager::createWindowCentred( WindowType::confirmationPrompt, { 280, 92 }, Ui::WindowFlags::flag_12 | Ui::WindowFlags::stickToFront, getEvents()); if (window == nullptr) { return false; } window->setWidgets(_widgets); window->widgets[widx::caption].text = captionId; window->widgets[widx::okButton].text = okButtonStringId; // Prepare description buffer for drawing StringManager::formatString(_descriptionBuffer, descriptionId, descriptionArgs); window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::mutedDarkRed).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(Colour::mutedDarkRed).translucent()); window->flags |= Ui::WindowFlags::transparent; _result = false; auto originalModal = WindowManager::getCurrentModalType(); WindowManager::setCurrentModalType(WindowType::confirmationPrompt); promptTickLoop( []() { Input::handleKeyboard(); Audio::updateSounds(); WindowManager::dispatchUpdateAll(); Input::processKeyboardInput(); WindowManager::update(); Ui::minimalHandleInput(); Gfx::renderAndUpdate(); return WindowManager::find(WindowType::confirmationPrompt) != nullptr; }); WindowManager::setCurrentModalType(originalModal); return _result; } // 0x00447125 static bool keyUp(Window& w, [[maybe_unused]] uint32_t charCode, uint32_t keyCode) { if (keyCode == SDLK_ESCAPE) { w.callOnMouseUp(widx::closeButton, w.widgets[widx::closeButton].id); return true; } return false; } // 0x00447093 static void prepareDraw([[maybe_unused]] Window& self) { // Prepare description string for drawing. char* buffer_2039 = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(&buffer_2039[0], _descriptionBuffer, 512); } // 0x004470FD static void onMouseUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::closeButton: case widx::cancelButton: WindowManager::close(self.type); break; case widx::okButton: _result = true; WindowManager::close(self.type); break; } } // 0x004470AA static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); FormatArguments args{}; args.push(StringIds::buffer_2039); auto origin = Ui::Point(self.x + self.width / 2, self.y + 41); tr.drawStringCentredWrapped(origin, self.width, Colour::black, StringIds::wcolour2_stringid, args); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .prepareDraw = prepareDraw, .draw = draw, .keyUp = keyUp, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/PromptSaveWindow.cpp ```cpp #include "Audio/Audio.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/LoadSaveQuit.h" #include "Graphics/Colour.h" #include "Input.h" #include "Localisation/StringIds.h" #include "SceneManager.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <array> #include <cstring> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::PromptSaveWindow { static LoadOrQuitMode _savePromptType; // 0x0050A002 enum widx { frame, caption, closeButton, promptLabel, saveButton, dontSaveButton, cancelButton, }; static constexpr auto _widgets = makeWidgets( Widgets::Panel({ 0, 0 }, { 260, 48 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 258, 13 }, Widgets::Caption::Style::boxed, WindowColour::primary, StringIds::empty), Widgets::Button({ 247, 2 }, { 11, 11 }, WindowColour::primary, StringIds::close_window_cross, StringIds::tooltip_close_window), Widgets::Label({ 2, 17 }, { 256, 12 }, WindowColour::primary, ContentAlign::center, StringIds::empty), Widgets::Button({ 8, 33 }, { 78, 12 }, WindowColour::primary, StringIds::label_button_save), Widgets::Button({ 91, 33 }, { 78, 12 }, WindowColour::primary, StringIds::label_button_dont_save), Widgets::Button({ 174, 33 }, { 78, 12 }, WindowColour::primary, StringIds::label_button_cancel) ); static const WindowEventList& getEvents(); // 0x0043C27E Window* open(LoadOrQuitMode savePromptType) { auto window = WindowManager::bringToFront(WindowType::saveGamePrompt); if (window == nullptr) { window = WindowManager::createWindowCentred( WindowType::saveGamePrompt, { 260, 48 }, WindowFlags::notScrollView | WindowFlags::stickToFront, getEvents()); if (window == nullptr) { return nullptr; } window->setWidgets(_widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::mutedDarkRed).translucent()); window->flags |= Ui::WindowFlags::transparent; SceneManager::setPauseFlag(1 << 1); Audio::pauseSound(); WindowManager::invalidate(WindowType::timeToolbar); } _savePromptType = savePromptType; if (!SceneManager::isEditorMode()) { static constexpr std::array<const StringId, 3> kTypeToType = { StringIds::title_load_game, StringIds::title_quit_game, StringIds::title_quit_game_alt, }; window->widgets[widx::caption].text = kTypeToType.at(enumValue(savePromptType)); } else { if (savePromptType == LoadOrQuitMode::loadGamePrompt) { window->widgets[widx::caption].text = StringIds::title_load_landscape; } else { window->widgets[widx::caption].text = StringIds::title_quit_scenario_editor; } } static constexpr std::array<const StringId, 3> kTypeToPrompt = { StringIds::prompt_save_before_loading, StringIds::prompt_save_before_quitting, StringIds::prompt_save_before_quitting_alt, }; window->widgets[widx::promptLabel].text = kTypeToPrompt.at(enumValue(savePromptType)); return window; } static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); } // 0x0043C3F4 static void onMouseUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::closeButton: case widx::cancelButton: { GameCommands::LoadSaveQuitGameArgs args{}; args.loadQuitMode = _savePromptType; args.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::closeSavePrompt; GameCommands::doCommand(args, GameCommands::Flags::apply); break; } case widx::saveButton: { Game::confirmSaveGame(_savePromptType); break; } case widx::dontSaveButton: { GameCommands::LoadSaveQuitGameArgs args{}; args.loadQuitMode = _savePromptType; args.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::dontSave; GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } } // 0x0043C577 static void onClose([[maybe_unused]] Window& self) { SceneManager::unsetPauseFlag(2); Audio::unpauseSound(); WindowManager::invalidate(WindowType::timeToolbar); } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ScenarioOptions.cpp ```cpp #include "ScenarioOptions.h" #include "Economy/Economy.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/CargoObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Objects/ScenarioTextObject.h" #include "Scenario.h" #include "ScenarioObjective.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/GroupBoxWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/StepperWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" namespace OpenLoco::Ui::Windows::ScenarioOptions { static constexpr Ui::Size32 kChallengeWindowSize = { 366, 197 }; static constexpr Ui::Size32 kCompaniesWindowSize = { 366, 260 }; static constexpr Ui::Size32 kOtherWindowSize = { 366, 217 }; namespace Common { enum widx { frame, caption, close_button, panel, tab_challenge, tab_companies, tab_finances, tab_scenario, }; static constexpr auto makeCommonWidgets(int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { 366, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 364, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ 351, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 366, 175 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_scenario_challenge), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_company_options), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_financial_options), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_scenario_options)); } // 0x00440082 static void update(Window& window) { window.frameNo++; window.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::scenarioOptions, window.number, window.currentTab + widx::tab_challenge); } // 0x004400A4 static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Challenge tab { static constexpr uint32_t challengeTabImageIds[] = { InterfaceSkin::ImageIds::tab_cup_frame0, InterfaceSkin::ImageIds::tab_cup_frame1, InterfaceSkin::ImageIds::tab_cup_frame2, InterfaceSkin::ImageIds::tab_cup_frame3, InterfaceSkin::ImageIds::tab_cup_frame4, InterfaceSkin::ImageIds::tab_cup_frame5, InterfaceSkin::ImageIds::tab_cup_frame6, InterfaceSkin::ImageIds::tab_cup_frame7, InterfaceSkin::ImageIds::tab_cup_frame8, InterfaceSkin::ImageIds::tab_cup_frame9, InterfaceSkin::ImageIds::tab_cup_frame10, InterfaceSkin::ImageIds::tab_cup_frame11, InterfaceSkin::ImageIds::tab_cup_frame12, InterfaceSkin::ImageIds::tab_cup_frame13, InterfaceSkin::ImageIds::tab_cup_frame14, InterfaceSkin::ImageIds::tab_cup_frame15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_challenge - widx::tab_challenge) { imageId += challengeTabImageIds[(self.frameNo / 4) % std::size(challengeTabImageIds)]; } else { imageId += challengeTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_challenge); } // Companies tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::tab_companies; Widget::drawTab(self, drawingCtx, imageId, widx::tab_companies); } // Finances tab { static constexpr uint32_t financesTabImageIds[] = { InterfaceSkin::ImageIds::tab_finances_frame0, InterfaceSkin::ImageIds::tab_finances_frame1, InterfaceSkin::ImageIds::tab_finances_frame2, InterfaceSkin::ImageIds::tab_finances_frame3, InterfaceSkin::ImageIds::tab_finances_frame4, InterfaceSkin::ImageIds::tab_finances_frame5, InterfaceSkin::ImageIds::tab_finances_frame6, InterfaceSkin::ImageIds::tab_finances_frame7, InterfaceSkin::ImageIds::tab_finances_frame8, InterfaceSkin::ImageIds::tab_finances_frame9, InterfaceSkin::ImageIds::tab_finances_frame10, InterfaceSkin::ImageIds::tab_finances_frame11, InterfaceSkin::ImageIds::tab_finances_frame12, InterfaceSkin::ImageIds::tab_finances_frame13, InterfaceSkin::ImageIds::tab_finances_frame14, InterfaceSkin::ImageIds::tab_finances_frame15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_finances - widx::tab_challenge) { imageId += financesTabImageIds[(self.frameNo / 2) % std::size(financesTabImageIds)]; } else { imageId += financesTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_finances); } // Scenario details tab if (!self.widgets[widx::tab_scenario].hidden) { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::tab_scenario_details; Widget::drawTab(self, drawingCtx, imageId, widx::tab_scenario); } } static void draw(Window& window, Gfx::DrawingContext& drawingCtx) { window.draw(drawingCtx); drawTabs(window, drawingCtx); } static void prepareDraw(Window& self); static void switchTab(Window& self, WidgetIndex_t widgetIndex); } namespace Challenge { enum widx { objective_type = 8, objective_type_btn, objective_value, objective_value_down, objective_value_up, objective_cargo, objective_cargo_btn, check_be_top_company, check_be_within_top_three_companies, check_time_limit, time_limit_value, time_limit_value_down, time_limit_value_up, }; const uint64_t holdableWidgets = (1 << widx::objective_value_down) | (1 << widx::objective_value_up) | (1 << widx::time_limit_value_down) | (1 << widx::time_limit_value_up); static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(197, StringIds::title_scenario_challenge), Widgets::dropdownWidgets({ 10, 52 }, { 346, 12 }, WindowColour::secondary), Widgets::stepperWidgets({ 10, 67 }, { 163, 12 }, WindowColour::secondary), Widgets::dropdownWidgets({ 193, 67 }, { 163, 12 }, WindowColour::secondary), Widgets::Checkbox({ 10, 83 }, { 346, 12 }, WindowColour::secondary, StringIds::and_be_the_top_company), Widgets::Checkbox({ 10, 98 }, { 346, 12 }, WindowColour::secondary, StringIds::and_be_within_the_top_companies), Widgets::Checkbox({ 10, 113 }, { 346, 12 }, WindowColour::secondary, StringIds::with_a_time_limit), Widgets::stepperWidgets({ 256, 112 }, { 100, 12 }, WindowColour::secondary, StringIds::time_limit_years_value) ); // 0x0043FC91 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Common::draw(window, drawingCtx); auto point = Point(window.x + 5, window.y + widgets[widx::check_time_limit].bottom + 10); tr.drawStringLeft(point, Colour::black, StringIds::challenge_label); FormatArguments args{}; OpenLoco::Scenario::formatChallengeArguments(Scenario::getObjective(), Scenario::getObjectiveProgress(), args); point.y += 10; tr.drawStringLeftWrapped(point, window.width - 10, Colour::black, StringIds::challenge_value, args); } static constexpr StringId objectiveTypeLabelIds[] = { StringIds::objective_achieve_a_certain_company_value, StringIds::objective_achieve_a_certain_monthly_profit_from_vehicles, StringIds::objective_achieve_a_certain_performance_index, StringIds::objective_deliver_a_certain_amount_of_cargo, }; static constexpr uint8_t kMaxCargoObjects = static_cast<uint8_t>(ObjectManager::getMaxObjects(ObjectType::cargo)); static int16_t cargoByDropdownIndex[kMaxCargoObjects] = { -1 }; // 0x0043FD51 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (itemIndex == -1) { return; } switch (widgetIndex) { case widx::objective_type_btn: Scenario::getObjective().type = static_cast<Scenario::ObjectiveType>(itemIndex); self.invalidate(); break; case widx::objective_cargo_btn: { Scenario::getObjective().deliveredCargoType = cargoByDropdownIndex[itemIndex]; self.invalidate(); } } } // 0x0043FD14 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::objective_type_btn: { Widget& target = self.widgets[widx::objective_type]; Dropdown::show(self.x + target.left, self.y + target.top, target.width() - 4, target.height(), self.getColour(WindowColour::secondary), std::size(objectiveTypeLabelIds), 0x80); for (size_t i = 0; i < std::size(objectiveTypeLabelIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, objectiveTypeLabelIds[i]); } Dropdown::setItemSelected(enumValue(Scenario::getObjective().type)); break; } case widx::objective_value_down: { switch (Scenario::getObjective().type) { case Scenario::ObjectiveType::companyValue: Scenario::getObjective().companyValue = std::max<uint32_t>(Scenario::getObjective().companyValue - 100000, Scenario::kMinObjectiveCompanyValue); break; case Scenario::ObjectiveType::vehicleProfit: Scenario::getObjective().monthlyVehicleProfit = std::max<uint32_t>(Scenario::getObjective().monthlyVehicleProfit - 1000, Scenario::kMinObjectiveMonthlyProfitFromVehicles); break; case Scenario::ObjectiveType::performanceIndex: Scenario::getObjective().performanceIndex = std::max<uint8_t>(Scenario::getObjective().performanceIndex - 5, Scenario::kMinObjectivePerformanceIndex); break; case Scenario::ObjectiveType::cargoDelivery: { uint16_t stepSize{}; uint16_t clickRepeatTicks = Input::getClickRepeatTicks(); if (clickRepeatTicks < 100) { stepSize = 100; } else if (clickRepeatTicks >= 100) { stepSize = 1000; } else if (clickRepeatTicks >= 200) { stepSize = 10000; } // Round off cargo to the nearest multiple of the step size. uint16_t cargoFactor = (Scenario::getObjective().deliveredCargoAmount - stepSize) / stepSize; uint32_t newDeliveredCargoAmount = cargoFactor * stepSize; Scenario::getObjective().deliveredCargoAmount = std::max<uint32_t>(newDeliveredCargoAmount, Scenario::kMinObjectiveDeliveredCargo); break; } } self.invalidate(); break; } case widx::objective_value_up: { switch (Scenario::getObjective().type) { case Scenario::ObjectiveType::companyValue: Scenario::getObjective().companyValue = std::min<uint32_t>(Scenario::getObjective().companyValue + 100000, Scenario::kMaxObjectiveCompanyValue); break; case Scenario::ObjectiveType::vehicleProfit: Scenario::getObjective().monthlyVehicleProfit = std::min<uint32_t>(Scenario::getObjective().monthlyVehicleProfit + 1000, Scenario::kMaxObjectiveMonthlyProfitFromVehicles); break; case Scenario::ObjectiveType::performanceIndex: Scenario::getObjective().performanceIndex = std::min<uint8_t>(Scenario::getObjective().performanceIndex + 5, Scenario::kMaxObjectivePerformanceIndex); break; case Scenario::ObjectiveType::cargoDelivery: { uint16_t stepSize{}; uint16_t clickRepeatTicks = Input::getClickRepeatTicks(); if (clickRepeatTicks < 100) { stepSize = 100; } else if (clickRepeatTicks >= 100) { stepSize = 1000; } else if (clickRepeatTicks >= 200) { stepSize = 10000; } // Round off cargo to the nearest multiple of the step size. uint16_t cargoFactor = (Scenario::getObjective().deliveredCargoAmount + stepSize) / stepSize; uint32_t newDeliveredCargoAmount = cargoFactor * stepSize; Scenario::getObjective().deliveredCargoAmount = std::max<uint32_t>(newDeliveredCargoAmount, Scenario::kMinObjectiveDeliveredCargo); break; } } self.invalidate(); break; } case widx::objective_cargo_btn: { uint16_t numCargoObjects = 0; for (uint16_t cargoIdx = 0; cargoIdx < kMaxCargoObjects; cargoIdx++) { auto cargoObject = ObjectManager::get<CargoObject>(cargoIdx); if (cargoObject != nullptr) { numCargoObjects++; } } Widget& target = self.widgets[widx::objective_cargo]; Dropdown::show(self.x + target.left, self.y + target.top, target.width() - 4, target.height(), self.getColour(WindowColour::secondary), numCargoObjects, 0x80); uint16_t dropdownIndex = 0; for (uint16_t cargoIdx = 0; cargoIdx < kMaxCargoObjects; cargoIdx++) { auto cargoObject = ObjectManager::get<CargoObject>(cargoIdx); if (cargoObject == nullptr) { continue; } Dropdown::add(dropdownIndex, StringIds::dropdown_stringid, cargoObject->name); cargoByDropdownIndex[dropdownIndex] = cargoIdx; if (cargoIdx == Scenario::getObjective().deliveredCargoType) { Dropdown::setItemSelected(dropdownIndex); } dropdownIndex++; } break; } case widx::time_limit_value_down: { Scenario::getObjective().timeLimitYears = std::max<uint8_t>(Scenario::getObjective().timeLimitYears - 1, Scenario::kMinObjectiveYearLimit); self.invalidate(); break; } case widx::time_limit_value_up: { Scenario::getObjective().timeLimitYears = std::min<uint8_t>(Scenario::getObjective().timeLimitYears + 1, Scenario::kMaxObjectiveYearLimit); self.invalidate(); break; } } } // 0x0043FCED static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_challenge: case Common::widx::tab_companies: case Common::widx::tab_finances: case Common::widx::tab_scenario: Common::switchTab(self, widgetIndex); break; case check_be_top_company: Scenario::getObjective().flags ^= Scenario::ObjectiveFlags::beTopCompany; self.invalidate(); break; case check_be_within_top_three_companies: Scenario::getObjective().flags ^= Scenario::ObjectiveFlags::beWithinTopThreeCompanies; self.invalidate(); break; case check_time_limit: Scenario::getObjective().flags ^= Scenario::ObjectiveFlags::withinTimeLimit; self.invalidate(); break; } } // 0x0043FB0C static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::objective_type].text = objectiveTypeLabelIds[enumValue(Scenario::getObjective().type)]; self.widgets[widx::objective_cargo].hidden = true; self.widgets[widx::objective_cargo_btn].hidden = true; self.widgets[widx::time_limit_value].hidden = true; self.widgets[widx::time_limit_value_down].hidden = true; self.widgets[widx::time_limit_value_up].hidden = true; auto args = FormatArguments(self.widgets[widx::objective_value].textArgs); switch (Scenario::getObjective().type) { case Scenario::ObjectiveType::companyValue: args.push<int32_t>(Scenario::getObjective().companyValue); self.widgets[widx::objective_value].text = StringIds::challenge_monetary_value; break; case Scenario::ObjectiveType::vehicleProfit: args.push<int32_t>(Scenario::getObjective().monthlyVehicleProfit); self.widgets[widx::objective_value].text = StringIds::challenge_monetary_value; break; case Scenario::ObjectiveType::performanceIndex: args.push<int16_t>(Scenario::getObjective().performanceIndex * 10); self.widgets[widx::objective_value].text = StringIds::challenge_performance_index; break; case Scenario::ObjectiveType::cargoDelivery: args.push<int32_t>(Scenario::getObjective().deliveredCargoAmount); self.widgets[widx::objective_value].text = StringIds::challenge_delivered_cargo; auto cargo = ObjectManager::get<CargoObject>(Scenario::getObjective().deliveredCargoType); self.widgets[widx::objective_cargo].text = cargo->name; self.widgets[widx::objective_cargo].hidden = false; self.widgets[widx::objective_cargo_btn].hidden = false; break; } self.activatedWidgets &= ~((1 << widx::check_be_top_company) | (1 << widx::check_be_within_top_three_companies) | (1 << widx::check_time_limit)); if ((Scenario::getObjective().flags & Scenario::ObjectiveFlags::beTopCompany) != Scenario::ObjectiveFlags::none) { self.activatedWidgets |= 1 << widx::check_be_top_company; } if ((Scenario::getObjective().flags & Scenario::ObjectiveFlags::beWithinTopThreeCompanies) != Scenario::ObjectiveFlags::none) { self.activatedWidgets |= 1 << widx::check_be_within_top_three_companies; } if ((Scenario::getObjective().flags & Scenario::ObjectiveFlags::withinTimeLimit) != Scenario::ObjectiveFlags::none) { self.activatedWidgets |= 1 << widx::check_time_limit; self.widgets[widx::time_limit_value].hidden = false; self.widgets[widx::time_limit_value_down].hidden = false; self.widgets[widx::time_limit_value_up].hidden = false; auto args2 = FormatArguments(self.widgets[widx::time_limit_value].textArgs); args2.push<uint16_t>(Scenario::getObjective().timeLimitYears); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x0043EE58 Window* open() { auto window = WindowManager::bringToFront(WindowType::scenarioOptions, 0); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); } window = WindowManager::bringToFront(WindowType::scenarioOptions, 0); } if (window == nullptr) { // 0x0043EEFF start window = WindowManager::createWindowCentred(WindowType::scenarioOptions, kOtherWindowSize, WindowFlags::none, Challenge::getEvents()); window->setWidgets(Challenge::widgets); window->number = 0; window->currentTab = 0; window->frameNo = 0; auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowTerraFormColour); } // 0x0043EEFF end window->width = kOtherWindowSize.width; window->height = kOtherWindowSize.height; } window->currentTab = 0; window->invalidate(); window->setWidgets(Challenge::widgets); window->holdableWidgets = Challenge::holdableWidgets; window->eventHandlers = &Challenge::getEvents(); window->activatedWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); return window; } namespace Companies { enum widx { max_competing_companies = 8, max_competing_companies_down, max_competing_companies_up, delay_before_competing_companies_start, delay_before_competing_companies_start_down, delay_before_competing_companies_start_up, groupbox_preferred_ai, preferred_intelligence, preferred_intelligence_btn, preferred_aggressiveness, preferred_aggressiveness_btn, preferred_competitiveness, preferred_competitiveness_btn, groupbox_forbid_competitor_vehicles, competitor_forbid_trains, competitor_forbid_buses, competitor_forbid_trucks, competitor_forbid_trams, competitor_forbid_aircraft, competitor_forbid_ships, groupbox_forbid_player_vehicles, player_forbid_trains, player_forbid_buses, player_forbid_trucks, player_forbid_trams, player_forbid_aircraft, player_forbid_ships, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(327, StringIds::title_company_options), Widgets::stepperWidgets({ 256, 52 }, { 100, 12 }, WindowColour::secondary, StringIds::max_competing_companies_value), Widgets::stepperWidgets({ 256, 67 }, { 100, 12 }, WindowColour::secondary, StringIds::delay_before_competing_companies_start_months), Widgets::GroupBox({ 5, 102 - 14 - 5 }, { 356, 63 }, WindowColour::secondary, StringIds::selection_of_competing_companies), Widgets::dropdownWidgets({ 246, 102 - 4 }, { 110, 12 }, WindowColour::secondary), Widgets::dropdownWidgets({ 246, 117 - 4 }, { 110, 12 }, WindowColour::secondary), Widgets::dropdownWidgets({ 246, 132 - 4 }, { 110, 12 }, WindowColour::secondary), Widgets::GroupBox({ 5, 150 }, { 356, 50 }, WindowColour::secondary, StringIds::forbid_competing_companies_from_using), Widgets::Checkbox({ 15 + 113 * 0, 166 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_trains), Widgets::Checkbox({ 15 + 113 * 1, 166 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_buses), Widgets::Checkbox({ 15 + 113 * 1, 180 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_trucks), Widgets::Checkbox({ 15 + 113 * 0, 180 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_trams), Widgets::Checkbox({ 15 + 113 * 2, 166 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_aircraft), Widgets::Checkbox({ 15 + 113 * 2, 180 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_ships), Widgets::GroupBox({ 5, 202 }, { 356, 50 }, WindowColour::secondary, StringIds::forbid_player_companies_from_using), Widgets::Checkbox({ 15 + 113 * 0, 219 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_trains), Widgets::Checkbox({ 15 + 113 * 1, 219 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_buses), Widgets::Checkbox({ 15 + 113 * 1, 233 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_trucks), Widgets::Checkbox({ 15 + 113 * 0, 233 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_trams), Widgets::Checkbox({ 15 + 113 * 2, 219 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_aircraft), Widgets::Checkbox({ 15 + 113 * 2, 233 }, { 110, 12 }, WindowColour::secondary, StringIds::forbid_ships) ); const uint64_t holdableWidgets = (1ULL << widx::max_competing_companies_down) | (1ULL << widx::max_competing_companies_up) | (1ULL << widx::delay_before_competing_companies_start_down) | (1ULL << widx::delay_before_competing_companies_start_up); // 0x0043F4EB static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Common::draw(window, drawingCtx); auto point = Point(window.x + 10, window.y + widgets[widx::max_competing_companies].top + 1); tr.drawStringLeft(point, Colour::black, StringIds::max_competing_companies); point.y = window.y + widgets[widx::delay_before_competing_companies_start].top + 1; tr.drawStringLeft(point, Colour::black, StringIds::delay_before_competing_companies_start); point.y = window.y + widgets[widx::preferred_intelligence].top + 1; tr.drawStringLeft(point, Colour::black, StringIds::preferred_intelligence); point.y = window.y + widgets[widx::preferred_aggressiveness].top + 1; tr.drawStringLeft(point, Colour::black, StringIds::preferred_aggressiveness); point.y = window.y + widgets[widx::preferred_competitiveness].top + 1; tr.drawStringLeft(point, Colour::black, StringIds::preferred_competitiveness); } static StringId preferenceLabelIds[] = { StringIds::preference_any, StringIds::preference_low, StringIds::preference_medium, StringIds::preference_high, }; // 0x0043F67C static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (itemIndex == -1) { return; } auto& state = getGameState(); switch (widgetIndex) { case widx::preferred_intelligence_btn: state.preferredAIIntelligence = itemIndex; break; case widx::preferred_aggressiveness_btn: state.preferredAIAggressiveness = itemIndex; break; case widx::preferred_competitiveness_btn: state.preferredAICompetitiveness = itemIndex; break; } self.invalidate(); } // 0x0043F639 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& state = getGameState(); switch (widgetIndex) { case widx::max_competing_companies_down: CompanyManager::setMaxCompetingCompanies(std::max<int8_t>(CompanyManager::getMaxCompetingCompanies() - 1, Scenario::kMinCompetingCompanies)); self.invalidate(); break; case widx::max_competing_companies_up: CompanyManager::setMaxCompetingCompanies(std::min<uint8_t>(CompanyManager::getMaxCompetingCompanies() + 1, Scenario::kMaxCompetingCompanies)); self.invalidate(); break; case widx::delay_before_competing_companies_start_down: CompanyManager::setCompetitorStartDelay(std::max<int8_t>(CompanyManager::getCompetitorStartDelay() - 1, Scenario::kMinCompetitorStartDelay)); self.invalidate(); break; case widx::delay_before_competing_companies_start_up: CompanyManager::setCompetitorStartDelay(std::min<uint8_t>(CompanyManager::getCompetitorStartDelay() + 1, Scenario::kMaxCompetitorStartDelay)); self.invalidate(); break; case widx::preferred_intelligence_btn: { Widget& target = self.widgets[widx::preferred_intelligence]; Dropdown::show(self.x + target.left, self.y + target.top, target.width() - 4, target.height(), self.getColour(WindowColour::secondary), std::size(preferenceLabelIds), 0x80); for (size_t i = 0; i < std::size(preferenceLabelIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, preferenceLabelIds[i]); } Dropdown::setItemSelected(state.preferredAIIntelligence); break; } case widx::preferred_aggressiveness_btn: { Widget& target = self.widgets[widx::preferred_aggressiveness]; Dropdown::show(self.x + target.left, self.y + target.top, target.width() - 4, target.height(), self.getColour(WindowColour::secondary), std::size(preferenceLabelIds), 0x80); for (size_t i = 0; i < std::size(preferenceLabelIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, preferenceLabelIds[i]); } Dropdown::setItemSelected(state.preferredAIAggressiveness); break; } case widx::preferred_competitiveness_btn: { Widget& target = self.widgets[widx::preferred_competitiveness]; Dropdown::show(self.x + target.left, self.y + target.top, target.width() - 4, target.height(), self.getColour(WindowColour::secondary), std::size(preferenceLabelIds), 0x80); for (size_t i = 0; i < std::size(preferenceLabelIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, preferenceLabelIds[i]); } Dropdown::setItemSelected(state.preferredAICompetitiveness); break; } } } // 0x0043F60C static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& state = getGameState(); switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_challenge: case Common::widx::tab_companies: case Common::widx::tab_finances: case Common::widx::tab_scenario: Common::switchTab(self, widgetIndex); break; case widx::competitor_forbid_trains: case widx::competitor_forbid_buses: case widx::competitor_forbid_trucks: case widx::competitor_forbid_trams: case widx::competitor_forbid_aircraft: case widx::competitor_forbid_ships: { uint16_t targetVehicle = static_cast<uint16_t>(widgetIndex - widx::competitor_forbid_trains); uint16_t newForbiddenVehicles = state.forbiddenVehiclesCompetitors ^ (1 << targetVehicle); // TODO(avgeffen): Add a constant for this mask. if (newForbiddenVehicles != 0b111111) { state.forbiddenVehiclesCompetitors = newForbiddenVehicles; self.invalidate(); } if (!SceneManager::isEditorMode()) { CompanyManager::determineAvailableVehicles(); WindowManager::invalidate(WindowType::vehicleList); } break; } case widx::player_forbid_trains: case widx::player_forbid_buses: case widx::player_forbid_trucks: case widx::player_forbid_trams: case widx::player_forbid_aircraft: case widx::player_forbid_ships: { uint16_t targetVehicle = static_cast<uint16_t>(widgetIndex - widx::player_forbid_trains); uint16_t newForbiddenVehicles = state.forbiddenVehiclesPlayers ^ (1 << targetVehicle); // TODO(avgeffen): Add a constant for this mask. if (newForbiddenVehicles != 0b111111) { state.forbiddenVehiclesPlayers = newForbiddenVehicles; self.invalidate(); } if (!SceneManager::isEditorMode()) { CompanyManager::determineAvailableVehicles(); WindowManager::invalidate(WindowType::buildVehicle); WindowManager::invalidate(WindowType::vehicleList); } break; } } } // 0x0043F40C static void prepareDraw(Window& self) { Common::prepareDraw(self); { auto args = FormatArguments(self.widgets[widx::max_competing_companies].textArgs); args.push<uint16_t>(CompanyManager::getMaxCompetingCompanies()); } { auto args = FormatArguments(self.widgets[widx::delay_before_competing_companies_start].textArgs); args.push<uint16_t>(CompanyManager::getCompetitorStartDelay()); } auto& state = getGameState(); self.widgets[widx::preferred_intelligence].text = preferenceLabelIds[state.preferredAIIntelligence]; self.widgets[widx::preferred_aggressiveness].text = preferenceLabelIds[state.preferredAIAggressiveness]; self.widgets[widx::preferred_competitiveness].text = preferenceLabelIds[state.preferredAICompetitiveness]; self.activatedWidgets &= ~((1ULL << widx::competitor_forbid_trains) | (1ULL << widx::competitor_forbid_buses) | (1ULL << widx::competitor_forbid_trucks) | (1ULL << widx::competitor_forbid_trams) | (1ULL << widx::competitor_forbid_aircraft) | (1ULL << widx::competitor_forbid_ships) | (1ULL << widx::player_forbid_trains) | (1ULL << widx::player_forbid_buses) | (1ULL << widx::player_forbid_trucks) | (1ULL << widx::player_forbid_trams) | (1ULL << widx::player_forbid_aircraft) | (1ULL << widx::player_forbid_ships)); // TODO(avgeffen): replace with wicked smart widget-id kerfuffle, someday. self.activatedWidgets |= static_cast<uint64_t>(state.forbiddenVehiclesCompetitors) << widx::competitor_forbid_trains; self.activatedWidgets |= static_cast<uint64_t>(state.forbiddenVehiclesPlayers) << widx::player_forbid_trains; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Finances { enum widx { starting_loan = 8, starting_loan_down, starting_loan_up, max_loan_size, max_loan_size_down, max_loan_size_up, loan_interest_rate, loan_interest_rate_down, loan_interest_rate_up, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_financial_options), Widgets::stepperWidgets({ 256, 52 }, { 100, 12 }, WindowColour::secondary, StringIds::starting_loan_value), Widgets::stepperWidgets({ 256, 67 }, { 100, 12 }, WindowColour::secondary, StringIds::max_loan_size_value), Widgets::stepperWidgets({ 256, 82 }, { 100, 12 }, WindowColour::secondary, StringIds::loan_interest_rate_value) ); const uint64_t holdableWidgets = (1 << widx::starting_loan_down) | (1 << widx::starting_loan_up) | (1 << widx::max_loan_size_down) | (1 << widx::max_loan_size_up) | (1 << widx::loan_interest_rate_down) | (1 << widx::loan_interest_rate_up); // 0x0043F97D static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Common::draw(window, drawingCtx); auto point = Point(window.x + 10, window.y + widgets[widx::starting_loan].top + 1); tr.drawStringLeft(point, Colour::black, StringIds::starting_loan); point.y = window.y + widgets[widx::max_loan_size].top + 1; tr.drawStringLeft(point, Colour::black, StringIds::max_loan_size); point.y = window.y + widgets[widx::loan_interest_rate].top + 1; tr.drawStringLeft(point, Colour::black, StringIds::loan_interest_rate); } static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto& state = getGameState(); switch (widgetIndex) { case widx::starting_loan_down: CompanyManager::setStartingLoanSize(std::max<int16_t>(CompanyManager::getStartingLoanSize() - 50, Scenario::kMinStartLoanUnits)); break; case widx::starting_loan_up: CompanyManager::setStartingLoanSize(std::min<uint16_t>(CompanyManager::getStartingLoanSize() + 50, Scenario::kMaxStartLoanUnits)); if (CompanyManager::getStartingLoanSize() > CompanyManager::getMaxLoanSize()) { CompanyManager::setMaxLoanSize(CompanyManager::getStartingLoanSize()); } break; case widx::max_loan_size_down: CompanyManager::setMaxLoanSize(std::max<int16_t>(CompanyManager::getMaxLoanSize() - 50, Scenario::kMinLoanSizeUnits)); if (CompanyManager::getStartingLoanSize() > CompanyManager::getMaxLoanSize()) { CompanyManager::setStartingLoanSize((CompanyManager::getMaxLoanSize())); } break; case widx::max_loan_size_up: CompanyManager::setMaxLoanSize(std::min<uint16_t>(CompanyManager::getMaxLoanSize() + 50, Scenario::kMaxLoanSizeUnits)); break; case widx::loan_interest_rate_down: state.loanInterestRate = std::max<int16_t>(state.loanInterestRate - 1, Scenario::kMinLoanInterestUnits); break; case widx::loan_interest_rate_up: state.loanInterestRate = std::min<uint16_t>(state.loanInterestRate + 1, Scenario::kMaxLoanInterestUnits); break; } self.invalidate(); } static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_challenge: case Common::widx::tab_companies: case Common::widx::tab_finances: case Common::widx::tab_scenario: Common::switchTab(self, widgetIndex); break; } } // 0x0043F8CF static void prepareDraw(Window& self) { Common::prepareDraw(self); { auto args = FormatArguments(self.widgets[widx::starting_loan].textArgs); uint32_t loanSizeInCurrency = CompanyManager::getInflationAdjustedStartingLoan(); args.push<uint32_t>(loanSizeInCurrency); } { auto args = FormatArguments(self.widgets[widx::max_loan_size].textArgs); uint64_t maxLoanSizeInCurrency = Economy::getInflationAdjustedCost(CompanyManager::getMaxLoanSize(), 0, 8) / 100 * 100; args.push(static_cast<uint32_t>(maxLoanSizeInCurrency)); } { auto args = FormatArguments(self.widgets[widx::loan_interest_rate].textArgs); auto& state = getGameState(); args.push<uint32_t>(state.loanInterestRate); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onUpdate = Common::update, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace ScenarioTab { enum widx { change_name_btn = 8, scenario_group, scenario_group_btn, change_details_btn, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(217, StringIds::title_scenario_options), Widgets::Button({ 281, 52 }, { 75, 12 }, WindowColour::secondary, StringIds::change), Widgets::dropdownWidgets({ 196, 67 }, { 160, 12 }, WindowColour::secondary, StringIds::empty), Widgets::Button({ 281, 82 }, { 75, 12 }, WindowColour::secondary, StringIds::change) ); const uint64_t holdableWidgets = 0; // 0x0043F004 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Common::draw(window, drawingCtx); { // Prepare scenario name text. char* buffer = (char*)StringManager::getString(StringIds::buffer_2039); strncpy(buffer, Scenario::getOptions().scenarioName, 512); FormatArguments args{}; args.push(StringIds::buffer_2039); auto* stex = ObjectManager::get<ScenarioTextObject>(); if (stex != nullptr) { args.rewind(); args.push(stex->name); } const int16_t xPos = window.x + 10; int16_t yPos = window.y + widgets[widx::change_name_btn].top + 1; int16_t width = widgets[widx::change_name_btn].left - 20; auto point = Point(xPos, yPos); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::scenario_name_stringid, args); } { const int16_t xPos = window.x + 10; int16_t yPos = window.y + widgets[widx::scenario_group].top + 1; auto point = Point(xPos, yPos); tr.drawStringLeft(point, Colour::black, StringIds::scenario_group); } { const int16_t xPos = window.x + 10; int16_t yPos = window.y + widgets[widx::change_details_btn].top + 1; auto point = Point(xPos, yPos); tr.drawStringLeft(point, Colour::black, StringIds::scenario_details); } { // Prepare scenario details text. char* buffer = (char*)StringManager::getString(StringIds::buffer_2039); strncpy(buffer, Scenario::getOptions().scenarioDetails, 512); FormatArguments args{}; args.push(StringIds::buffer_2039); auto* stex = ObjectManager::get<ScenarioTextObject>(); if (stex != nullptr) { args.rewind(); args.push(stex->details); } auto& target = window.widgets[widx::change_details_btn]; auto point = Point(window.x + 16, window.y + 12 + target.top); tr.drawStringLeftWrapped(point, target.left - 26, Colour::black, StringIds::black_stringid, args); } } static StringId scenarioGroupLabelIds[] = { StringIds::scenario_group_beginner, StringIds::scenario_group_easy, StringIds::scenario_group_medium, StringIds::scenario_group_challenging, StringIds::scenario_group_expert, }; // 0x0043F14B static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == widx::scenario_group_btn && itemIndex != -1) { Scenario::getOptions().difficulty = itemIndex; self.invalidate(); } } // 0x0043F140 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::scenario_group_btn) { Widget& target = self.widgets[widx::scenario_group]; Dropdown::show(self.x + target.left, self.y + target.top, target.width() - 4, target.height(), self.getColour(WindowColour::secondary), std::size(scenarioGroupLabelIds), 0x80); for (size_t i = 0; i < std::size(scenarioGroupLabelIds); i++) { Dropdown::add(i, StringIds::dropdown_stringid, scenarioGroupLabelIds[i]); } Dropdown::setItemSelected(Scenario::getOptions().difficulty); } } // 0x0043F11F static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_challenge: case Common::widx::tab_companies: case Common::widx::tab_finances: case Common::widx::tab_scenario: Common::switchTab(self, widgetIndex); break; case widx::change_name_btn: { char* buffer = (char*)StringManager::getString(StringIds::buffer_2039); strncpy(buffer, Scenario::getOptions().scenarioName, 512); auto inputSize = std::size(Scenario::getOptions().scenarioName) - 1; TextInput::openTextInput(&self, StringIds::scenario_name_title, StringIds::enter_name_for_scenario, StringIds::buffer_2039, widgetIndex, nullptr, inputSize); break; } case widx::change_details_btn: { char* buffer = (char*)StringManager::getString(StringIds::buffer_2039); strncpy(buffer, Scenario::getOptions().scenarioDetails, 512); auto inputSize = std::size(Scenario::getOptions().scenarioDetails) - 1; TextInput::openTextInput(&self, StringIds::scenario_details_title, StringIds::enter_description_of_this_scenario, StringIds::buffer_2039, widgetIndex, nullptr, inputSize); break; } } } // 0x0043EF8B static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scenario_group].text = scenarioGroupLabelIds[Scenario::getOptions().difficulty]; } static void unloadScenarioTextObjects() { if (ObjectManager::get<ScenarioTextObject>() == nullptr) { return; } LoadedObjectHandle handle = { ObjectType::scenarioText, 0 }; auto header = ObjectManager::getHeader(handle); ObjectManager::unload(header); } // 0x0043F156 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { switch (callingWidget) { case widx::change_name_btn: { strncpy(Scenario::getOptions().scenarioName, input, sizeof(Scenario::Options::scenarioName) - 1); Scenario::getOptions().scenarioName[sizeof(Scenario::Options::scenarioName) - 1] = '\0'; unloadScenarioTextObjects(); self.invalidate(); break; } case widx::change_details_btn: { strncpy(Scenario::getOptions().scenarioDetails, input, sizeof(Scenario::Options::scenarioDetails) - 1); Scenario::getOptions().scenarioDetails[sizeof(Scenario::Options::scenarioDetails) - 1] = '\0'; unloadScenarioTextObjects(); self.invalidate(); break; } } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::update, .textInput = textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; const uint64_t* holdableWidgets; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { Challenge::widgets, widx::tab_challenge, Challenge::getEvents(), &Challenge::holdableWidgets }, { Companies::widgets, widx::tab_companies, Companies::getEvents(), &Companies::holdableWidgets }, { Finances::widgets, widx::tab_finances, Finances::getEvents(), &Finances::holdableWidgets }, { ScenarioTab::widgets, widx::tab_scenario, ScenarioTab::getEvents(), &ScenarioTab::holdableWidgets } }; // clang-format on static void prepareDraw(Window& self) { // Activate the current tab. self.activatedWidgets &= ~((1 << widx::tab_challenge) | (1 << widx::tab_companies) | (1 << widx::tab_finances) | (1 << widx::tab_scenario)); widx widgetIndex = tabInformationByTabOffset[self.currentTab].widgetIndex; self.activatedWidgets |= (1ULL << widgetIndex); // Disable close button in the scenario editor. self.widgets[Common::widx::close_button].hidden = SceneManager::isEditorMode(); self.widgets[widx::tab_scenario].hidden = !SceneManager::isEditorMode(); // Resize common widgets. self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; } // 0x0043F16B static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } TextInput::sub_4CE6C9(self.type, self.number); self.currentTab = widgetIndex - widx::tab_challenge; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.disabledWidgets = 0; auto tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_challenge]; self.holdableWidgets = *tabInfo.holdableWidgets; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.invalidate(); const auto newSize = [widgetIndex]() { if (widgetIndex == widx::tab_challenge) { return kChallengeWindowSize; } else if (widgetIndex == widx::tab_companies) { return kCompaniesWindowSize; } else { return kOtherWindowSize; } }(); self.setSize(newSize); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ScenarioSelect.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Logging.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "Scenario.h" #include "ScenarioManager.h" #include "SceneManager.h" #include "Ui/ScrollView.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" using namespace OpenLoco::Diagnostics; namespace OpenLoco::Ui::Windows::ScenarioSelect { static constexpr Ui::Size32 kWindowSize = { 610, 412 }; namespace widx { enum { frame, title, close, panel, tab0, tab1, tab2, tab3, tab4, list, }; } static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 610, 412 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 608, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::select_scenario_for_new_game), Widgets::ImageButton({ 595, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Wt3Widget({ 0, 48 }, { 610, 364 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 91, 34 }, WindowColour::secondary, ImageIds::wide_tab), Widgets::Tab({ 94, 15 }, { 91, 34 }, WindowColour::secondary, ImageIds::wide_tab), Widgets::Tab({ 185, 15 }, { 91, 34 }, WindowColour::secondary, ImageIds::wide_tab), Widgets::Tab({ 276, 15 }, { 91, 34 }, WindowColour::secondary, ImageIds::wide_tab), Widgets::Tab({ 367, 15 }, { 91, 34 }, WindowColour::secondary, ImageIds::wide_tab), Widgets::ScrollView({ 3, 52 }, { 431, 356 }, WindowColour::secondary, Scrollbars::vertical) ); constexpr auto kRowHeight = 24; static bool _warnOnce = false; // 0x00443807 static void initTabs(Window* self) { uint16_t xPos = 3; for (int i = 0; i < 5; i++) { Widget& widget = self->widgets[widx::tab0 + i]; if (ScenarioManager::hasScenariosForCategory(i)) { widget.hidden = false; widget.left = xPos; widget.right = xPos + 90; xPos += 91; } else { widget.hidden = true; } } } // 0x00443946 static void initList(Window* self) { if (self->info == 0xFFFFFFFF) { return; } using namespace ScenarioManager; auto scenarioInfo = reinterpret_cast<ScenarioIndexEntry*>(self->info); if (hasScenarioInCategory(self->currentTab, scenarioInfo)) { return; } // Reset currently selected scenario if it is not in the current category. self->info = 0xFFFFFFFF; self->invalidate(); } static const WindowEventList& getEvents(); // 0x00443868 Window* open() { Window* self = WindowManager::bringToFront(WindowType::scenarioSelect); if (self != nullptr) { return self; } self = WindowManager::createWindow( WindowType::scenarioSelect, { width() / 2 - kWindowSize.width / 2, std::max<int16_t>(height() / 2 - kWindowSize.height / 2, 28) }, kWindowSize, WindowFlags::stickToFront | WindowFlags::flag_12, getEvents()); self->setWidgets(_widgets); self->initScrollWidgets(); self->setColour(WindowColour::primary, Colour::black); self->setColour(WindowColour::secondary, Colour::mutedSeaGreen); self->var_846 = 0xFFFF; self->var_85A = static_cast<int32_t>(0xFFFFFFFF); initTabs(self); // Select the last tab used, or the first available one. uint8_t selectedTab = Config::get().scenarioSelectedTab; if (self->widgets[widx::tab0 + selectedTab].hidden) { selectedTab = 0; for (int i = 0; i < 5; i++) { if (self->widgets[widx::tab0 + i].hidden) { selectedTab = i; break; } } } self->currentTab = selectedTab; initList(self); return self; } // 0x00443995 static void prepareDraw(Window& self) { self.activatedWidgets &= ~((1 << widx::tab0) | (1 << widx::tab1) | (1 << widx::tab2) | (1 << widx::tab3) | (1 << widx::tab4)); self.activatedWidgets |= (1ULL << (self.currentTab + static_cast<uint8_t>(widx::tab0))); } // 0x004439AF static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.drawRectInset(self.x, self.y + 20, self.width, 41, self.getColour(WindowColour::primary), Gfx::RectInsetFlags::none); // Draw widgets. self.draw(drawingCtx); static const StringId scenarioGroupIds[] = { StringIds::scenario_group_beginner, StringIds::scenario_group_easy, StringIds::scenario_group_medium, StringIds::scenario_group_challenging, StringIds::scenario_group_expert, }; // Draw tab captions. for (int i = 0; i < 5; i++) { Widget& widget = self.widgets[widx::tab0 + i]; if (widget.hidden) { continue; } const auto offset = self.currentTab == i ? 1 : 0; auto origin = Ui::Point(widget.midX() + self.x, widget.midY() + self.y - 3 - offset); const StringId caption = scenarioGroupIds[i]; auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(caption); tr.drawStringCentredWrapped(origin, widget.width() - 4, Colour::black, StringIds::wcolour2_stringid, args); } // Scenario selected? if (self.info == 0 || self.info == 0xFFFFFFFF) { return; } using namespace ScenarioManager; auto scenarioInfo = reinterpret_cast<ScenarioIndexEntry*>(self.info); // Check if current currency object needs to be changed. auto isLoaded = ObjectManager::findObjectHandle(scenarioInfo->currency); if (!isLoaded) { if (ObjectManager::findObjectInIndex(scenarioInfo->currency)) { // Swap out the currency object and reload ObjectManager::unload(ObjectManager::getHeader({ ObjectType::currency, 0 })); if (!ObjectManager::load(scenarioInfo->currency)) { Logging::error("Currency object failed to load! Game will likely crash."); } ObjectManager::reloadAll(); Gfx::loadCurrency(); } else { if (!_warnOnce) { Logging::error("Currency object could not be found. Scenario may be corrupt."); _warnOnce = true; } } } const int16_t baseX = self.x + self.widgets[widx::list].right + 4; const int16_t baseY = self.y + self.widgets[widx::panel].top + 5; const int16_t colWidth = self.widgets[widx::panel].right - self.widgets[widx::list].right - 6; int16_t x = baseX, y = baseY; // Scenario name { auto str = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(str, scenarioInfo->scenarioName, std::size(scenarioInfo->scenarioName)); FormatArguments args{}; args.push(StringIds::buffer_2039); x += colWidth / 2; tr.drawStringCentredClipped(Point(x, y), 170, Colour::black, StringIds::wcolour2_stringid, args); y += 14; } // Outline for preview image { x = baseX + 20; drawingCtx.drawRectInset(x, y, 130, 130, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); x += 1; y += 1; } // Preview image? if (scenarioInfo->hasFlag(ScenarioIndexFlags::hasPreviewImage)) { const auto imageId = 0; const auto g1 = Gfx::getG1Element(imageId); if (g1 != nullptr) { // Temporarily substitute a G1 image with the data in the scenario index const auto backupG1 = *g1; *g1 = {}; g1->offset = reinterpret_cast<uint8_t*>(scenarioInfo->preview); g1->width = 128; g1->height = 128; // Draw preview image and restore original G1 image. drawingCtx.drawImage(x, y, imageId); *g1 = backupG1; // Draw compass drawingCtx.drawImage(x, y, ImageIds::height_map_compass); } } else { x += 1; y += 1; // No preview image -- a placeholder will have to do. auto image = Gfx::recolour(ImageIds::random_map_watermark, self.getColour(WindowColour::secondary).c()); drawingCtx.drawImage(x, y, image); x += 64; y += 59; FormatArguments args{}; args.push(StringIds::randomly_generated_landscape); // Overlay random map note. tr.drawStringCentredWrapped(Point(x, y), 128, Colour::black, StringIds::wcolour2_stringid, args); } { x = baseX; y = baseY + 150; // Description auto str = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(str, scenarioInfo->description, std::size(scenarioInfo->description)); FormatArguments args{}; args.push(StringIds::buffer_2039); auto point = tr.drawStringLeftWrapped(Point(x, y), 170, Colour::black, StringIds::black_stringid, args); y = point.y; // Challenge header y += 5; tr.drawStringLeft(Point(x, y), Colour::black, StringIds::challenge_label); // Challenge text str = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); strncpy(str, scenarioInfo->objective, std::size(scenarioInfo->objective)); y += 10; args = FormatArguments(); args.push(StringIds::buffer_1250); point = tr.drawStringLeftWrapped(Point(x, y), 170, Colour::black, StringIds::challenge_value, args); y = point.y; // Start year y += 5; args = FormatArguments(); args.push(scenarioInfo->startYear); tr.drawStringLeft(Point(x, y), Colour::black, StringIds::challenge_start_date, args); // Competing companies y += 10; args = FormatArguments(); args.push<uint16_t>(scenarioInfo->numCompetingCompanies); StringId competitionStringId = scenarioInfo->numCompetingCompanies == 0 ? StringIds::challenge_competing_companies_none : StringIds::challenge_competing_companies_up_to; point = tr.drawStringLeftWrapped(Point(x, y), 170, Colour::black, competitionStringId, args); y = point.y; if (scenarioInfo->numCompetingCompanies == 0 || scenarioInfo->competingCompanyDelay == 0) { return; } // Delayed start for competing companies args = FormatArguments(); args.push<uint16_t>(scenarioInfo->competingCompanyDelay); competitionStringId = scenarioInfo->numCompetingCompanies == 1 ? StringIds::competition_not_starting_for_month : StringIds::competition_not_starting_for_months; tr.drawStringLeft(Point(x, y), Colour::black, competitionStringId, args); } } // 0x00443D02 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, const uint32_t) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto colour = Colours::getShade(self.getColour(WindowColour::secondary).c(), 4); drawingCtx.clearSingle(colour); using namespace ScenarioManager; auto scenarioCount = getScenarioCountByCategory(self.currentTab); int16_t y = 0; for (auto i = 0; i < scenarioCount; i++) { auto* scenarioInfo = getNthScenarioFromCategory(self.currentTab, i); if (scenarioInfo == nullptr) { continue; } if (y + kRowHeight < rt.y) { y += kRowHeight; continue; } else if (y > rt.y + rt.height) { break; } // Highlight selected item auto formatStringId = StringIds::black_stringid; if (scenarioInfo == reinterpret_cast<ScenarioIndexEntry*>(self.info)) { drawingCtx.drawRect(0, y, self.width, kRowHeight - 1, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); formatStringId = StringIds::wcolour2_stringid; } // Scenario name { auto str = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(str, scenarioInfo->scenarioName, std::size(scenarioInfo->scenarioName)); FormatArguments args{}; args.push(StringIds::buffer_2039); auto point = Point(210, y + 1); tr.drawStringCentred(point, Colour::black, formatStringId, args); } // Completed? if (!scenarioInfo->hasFlag(ScenarioIndexFlags::completed)) { y += kRowHeight; continue; } // Draw checkmark to indicate completion drawingCtx.drawImage(self.widgets[widx::list].width() - ScrollView::kScrollbarSize - 25, y + 1, ImageIds::scenario_completed_tick); // 'Completed by' info { auto str = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); strncpy(str, scenarioInfo->highscoreName, std::size(scenarioInfo->highscoreName)); FormatArguments args{}; args.push(StringIds::completed_by_name_in_years_months); args.push(StringIds::buffer_2039); args.push<uint16_t>(scenarioInfo->completedMonths / 12); args.push<uint16_t>(scenarioInfo->completedMonths % 12); auto point = Point((self.widgets[widx::list].width() - ScrollView::kScrollbarSize) / 2, y + 10); tr.drawStringCentred(point, Colour::black, formatStringId, args); } y += kRowHeight; } } // 0x00443E9B static void onMouseUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close: WindowManager::close(&self); break; } } // 0x00443EA6 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::tab0: case widx::tab1: case widx::tab2: case widx::tab3: case widx::tab4: { uint8_t selectedCategory = widgetIndex - widx::tab0; if (self.currentTab == selectedCategory) { return; } self.currentTab = selectedCategory; auto& config = Config::get(); config.scenarioSelectedTab = selectedCategory; Config::write(); self.info = 0xFFFFFFFF; self.invalidate(); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); initList(&self); break; } } } // 0x00443EF6 static void getScrollSize(Window& self, uint32_t, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = ScenarioManager::getScenarioCountByCategory(self.currentTab) * kRowHeight; } // 0x00443F32 static void onScrollMouseDown(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto scenarioCount = ScenarioManager::getScenarioCountByCategory(self.currentTab); auto index = y / kRowHeight; if (index > scenarioCount) { return; } auto* scenarioInfo = ScenarioManager::getNthScenarioFromCategory(self.currentTab, index); if (scenarioInfo == nullptr) { return; } // Mouse click sound Audio::playSound(Audio::SoundId::clickDown, self.x + (self.width / 2)); if (SceneManager::isNetworked()) { GameCommands::do_67(scenarioInfo->filename); } else { Scenario::loadAndStart(scenarioInfo->filename); } } // 0x00443FB2 static void onScrollMouseOver(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto scenarioCount = ScenarioManager::getScenarioCountByCategory(self.currentTab); auto index = y / kRowHeight; if (index > scenarioCount) { return; } auto* scenarioEntry = ScenarioManager::getNthScenarioFromCategory(self.currentTab, index); if (scenarioEntry == nullptr) { return; } if (self.info != reinterpret_cast<uintptr_t>(scenarioEntry)) { self.info = reinterpret_cast<uintptr_t>(scenarioEntry); self.invalidate(); _warnOnce = false; } } // 0x00444001 static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_scenario_list); return args; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/StationList.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/CargoObject.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/Exception.hpp> namespace OpenLoco::Ui::Windows::StationList { static constexpr Ui::Size32 kWindowSize = { 600, 197 }; static constexpr Ui::Size kMaxDimensions = { 640, 1200 }; static constexpr Ui::Size kMinDimensions = { 192, 100 }; static constexpr uint8_t kRowHeight = 10; // CJK: 13 enum widx { frame = 0, caption = 1, close_button = 2, panel = 3, tab_all_stations, tab_rail_stations, tab_road_stations, tab_airports, tab_ship_ports, company_select, sort_name, sort_status, sort_total_waiting, sort_accepts, scrollview, status_bar, }; static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 600, 197 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 598, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, StringIds::stringid_all_stations), Widgets::ImageButton({ 585, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 600, 155 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_all_stations), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_rail_stations), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_road_stations), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_airports), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_ship_ports), Widgets::ImageButton({ 0, 14 }, { 26, 26 }, WindowColour::primary, Widget::kContentNull, StringIds::tooltip_select_company), Widgets::TableHeader({ 4, 43 }, { 200, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_name), Widgets::TableHeader({ 204, 43 }, { 200, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_station_status), Widgets::TableHeader({ 404, 43 }, { 90, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_total_units_waiting), Widgets::TableHeader({ 494, 43 }, { 120, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_cargo_accepted), Widgets::ScrollView({ 3, 56 }, { 594, 126 }, WindowColour::secondary, Scrollbars::vertical), Widgets::Label({ 4, kWindowSize.height - 12 }, { kWindowSize.width, 10 }, WindowColour::secondary, ContentAlign::left, StringIds::black_stringid) ); struct TabDetails { widx widgetIndex; StringId windowTitleId; uint32_t imageId; StationFlags stationMask; }; static TabDetails tabInformationByType[] = { { tab_all_stations, StringIds::stringid_all_stations, InterfaceSkin::ImageIds::all_stations, StationFlags::allModes }, { tab_rail_stations, StringIds::stringid_rail_stations, InterfaceSkin::ImageIds::rail_stations, StationFlags::transportModeRail }, { tab_road_stations, StringIds::stringid_road_stations, InterfaceSkin::ImageIds::road_stations, StationFlags::transportModeRoad }, { tab_airports, StringIds::stringid_airports, InterfaceSkin::ImageIds::airports, StationFlags::transportModeAir }, { tab_ship_ports, StringIds::stringid_ship_ports, InterfaceSkin::ImageIds::ship_ports, StationFlags::transportModeWater } }; enum SortMode : uint16_t { Name, Status, TotalUnitsWaiting, CargoAccepted, }; // 0x004910E8 static void refreshStationList(Window* window) { window->rowCount = 0; for (auto& station : StationManager::stations()) { if (station.owner == CompanyId(window->number)) { station.flags &= ~StationFlags::flag_4; } } } // 0x004911FD static bool orderByName(const OpenLoco::Station& lhs, const OpenLoco::Station& rhs) { char lhsString[256] = { 0 }; { auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(lhs.town); StringManager::formatString(lhsString, lhs.name, args); } char rhsString[256] = { 0 }; { auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(rhs.town); StringManager::formatString(rhsString, rhs.name, args); } return strcmp(lhsString, rhsString) < 0; } // 0x00491281, 0x00491247 static bool orderByQuantity(const OpenLoco::Station& lhs, const OpenLoco::Station& rhs) { uint32_t lhsSum = 0; for (const auto& cargo : lhs.cargoStats) { lhsSum += cargo.quantity; } uint32_t rhsSum = 0; for (const auto& cargo : rhs.cargoStats) { rhsSum += cargo.quantity; } return rhsSum < lhsSum; } // 0x004912BB static bool orderByAccepts(const OpenLoco::Station& lhs, const OpenLoco::Station& rhs) { char* ptr; char lhsString[256] = { 0 }; ptr = &lhsString[0]; for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { if (lhs.cargoStats[cargoId].isAccepted()) { ptr = StringManager::formatString(ptr, ObjectManager::get<CargoObject>(cargoId)->name); } } char rhsString[256] = { 0 }; ptr = &rhsString[0]; for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { if (rhs.cargoStats[cargoId].isAccepted()) { ptr = StringManager::formatString(ptr, ObjectManager::get<CargoObject>(cargoId)->name); } } return strcmp(lhsString, rhsString) < 0; } // 0x004911FD, 0x00491247, 0x00491281, 0x004912BB static bool getOrder(const SortMode mode, const OpenLoco::Station& lhs, const OpenLoco::Station& rhs) { switch (mode) { case SortMode::Name: return orderByName(lhs, rhs); case SortMode::Status: case SortMode::TotalUnitsWaiting: return orderByQuantity(lhs, rhs); case SortMode::CargoAccepted: return orderByAccepts(lhs, rhs); } return false; } // 0x0049111A static void updateStationList(Window* window) { StationId edi = StationId::null; for (auto& station : StationManager::stations()) { if (station.owner != CompanyId(window->number)) { continue; } if ((station.flags & StationFlags::flag_5) != StationFlags::none) { continue; } const StationFlags mask = tabInformationByType[window->currentTab].stationMask; if ((station.flags & mask) == StationFlags::none) { continue; } if ((station.flags & StationFlags::flag_4) != StationFlags::none) { continue; } if (edi == StationId::null) { edi = station.id(); continue; } if (getOrder(SortMode(window->sortMode), station, *StationManager::get(edi))) { edi = station.id(); } } if (edi != StationId::null) { bool dl = false; StationManager::get(edi)->flags |= StationFlags::flag_4; auto ebp = window->rowCount; if (edi != StationId(window->rowInfo[ebp])) { window->rowInfo[ebp] = enumValue(edi); dl = true; } window->rowCount += 1; if (window->rowCount > window->var_83C) { window->var_83C = window->rowCount; dl = true; } if (dl) { window->invalidate(); } } else { if (window->var_83C != window->rowCount) { window->var_83C = window->rowCount; window->invalidate(); } refreshStationList(window); } } // 0x004910AB void removeStationFromList(const StationId stationId) { auto* station = StationManager::get(stationId); auto* window = WindowManager::find(WindowType::stationList, enumValue(station->owner)); if (window != nullptr) { for (uint16_t i = 0; i < window->var_83C; i++) { if (stationId == StationId(window->rowInfo[i])) { window->rowInfo[i] = enumValue(StationId::null); } } } } static const WindowEventList& getEvents(); // 0x00490F6C Window* open(CompanyId companyId) { Window* window = WindowManager::bringToFront(WindowType::stationList, enumValue(companyId)); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); } // Still active? window = WindowManager::bringToFront(WindowType::stationList, enumValue(companyId)); } if (window == nullptr) { // 0x00491010 window = WindowManager::createWindow( WindowType::stationList, kWindowSize, WindowFlags::flag_11, getEvents()); window->number = enumValue(companyId); window->owner = companyId; window->currentTab = 0; window->frameNo = 0; window->sortMode = 0; window->var_83C = 0; window->rowHover = -1; refreshStationList(window); window->minWidth = kMinDimensions.width; window->minHeight = kMinDimensions.height; window->maxWidth = kMaxDimensions.width; window->maxHeight = kMaxDimensions.height; window->flags |= WindowFlags::resizable; auto interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, interface->windowPlayerColor); } window->currentTab = 0; window->invalidate(); window->setWidgets(_widgets); window->activatedWidgets = 0; window->holdableWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); return window; } Window* open(CompanyId companyId, uint8_t type) { if (type > 4) { throw Exception::RuntimeError("Unexpected station type"); } Window* stationList = open(companyId); widx target = tabInformationByType[type].widgetIndex; stationList->callOnMouseUp(target, stationList->widgets[target].id); return stationList; } // 0x004919A4 static Ui::CursorId cursor(Window& window, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, Ui::CursorId fallback) { if (widgetIdx != widx::scrollview) { return fallback; } uint16_t currentIndex = yPos / kRowHeight; if (currentIndex < window.var_83C && window.rowInfo[currentIndex] != -1) { return CursorId::handPointer; } return fallback; } // 0x0049196F static void event_08(Window& window) { window.flags |= WindowFlags::notScrollView; } // 0x00491977 static void event_09(Window& window) { if (!window.hasFlags(WindowFlags::notScrollView)) { return; } if (window.rowHover == -1) { return; } window.rowHover = -1; window.invalidate(); } // 0x00491344 static void prepareDraw(Ui::Window& window) { // Reset active tab. window.activatedWidgets &= ~((1 << tab_all_stations) | (1 << tab_rail_stations) | (1 << tab_road_stations) | (1 << tab_airports) | (1 << tab_ship_ports)); window.activatedWidgets |= (1ULL << tabInformationByType[window.currentTab].widgetIndex); { // Set company name auto company = CompanyManager::get(CompanyId(window.number)); auto args = FormatArguments(window.widgets[widx::caption].textArgs); args.push(company->name); } // Set window title. window.widgets[widx::caption].text = tabInformationByType[window.currentTab].windowTitleId; // Resize general window widgets. window.widgets[widx::frame].right = window.width - 1; window.widgets[widx::frame].bottom = window.height - 1; window.widgets[widx::panel].right = window.width - 1; window.widgets[widx::panel].bottom = window.height - 1; window.widgets[widx::caption].right = window.width - 2; window.widgets[widx::close_button].left = window.width - 15; window.widgets[widx::close_button].right = window.width - 3; window.widgets[widx::scrollview].right = window.width - 4; window.widgets[widx::scrollview].bottom = window.height - 14; // Reposition header buttons. window.widgets[widx::sort_name].right = std::min(203, window.width - 4); window.widgets[widx::sort_status].left = std::min(204, window.width - 4); window.widgets[widx::sort_status].right = std::min(403, window.width - 4); window.widgets[widx::sort_total_waiting].left = std::min(404, window.width - 4); window.widgets[widx::sort_total_waiting].right = std::min(493, window.width - 4); window.widgets[widx::sort_accepts].left = std::min(494, window.width - 4); window.widgets[widx::sort_accepts].right = std::min(613, window.width - 4); // Reposition company selection. window.widgets[widx::company_select].left = window.width - 28; window.widgets[widx::company_select].right = window.width - 3; // Set header button captions. window.widgets[widx::sort_name].text = window.sortMode == SortMode::Name ? StringIds::table_header_name_desc : StringIds::table_header_name; window.widgets[widx::sort_status].text = window.sortMode == SortMode::Status ? StringIds::table_header_status_desc : StringIds::table_header_status; window.widgets[widx::sort_total_waiting].text = window.sortMode == SortMode::TotalUnitsWaiting ? StringIds::table_header_total_waiting_desc : StringIds::table_header_total_waiting; window.widgets[widx::sort_accepts].text = window.sortMode == SortMode::CargoAccepted ? StringIds::table_header_accepts_desc : StringIds::table_header_accepts; // Reposition tabs Widget::leftAlignTabs(window, widx::tab_all_stations, widx::tab_ship_ports); // Reposition status label auto& widget = window.widgets[widx::status_bar]; widget.top = window.height - 12; widget.bottom = window.height - 2; // TODO: locale-based pluralisation. auto args = FormatArguments{ widget.textArgs }; args.push(window.var_83C == 1 ? StringIds::status_num_stations_singular : StringIds::status_num_stations_plural); args.push<uint16_t>(window.var_83C); } // 0x0049157F static void drawScroll(Ui::Window& window, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto shade = Colours::getShade(window.getColour(WindowColour::secondary).c(), 4); drawingCtx.clearSingle(shade); uint16_t yPos = 0; for (uint16_t i = 0; i < window.var_83C; i++) { auto stationId = StationId(window.rowInfo[i]); // Skip items outside of view, or irrelevant to the current filter. if (yPos + kRowHeight < rt.y || stationId == StationId::null) { yPos += kRowHeight; continue; } else if (yPos >= yPos + kRowHeight + rt.height) { break; } StringId text_colour_id = StringIds::black_stringid; // Highlight selection. if (stationId == StationId(window.rowHover)) { drawingCtx.drawRect(0, yPos, window.width, kRowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); text_colour_id = StringIds::wcolour2_stringid; } auto station = StationManager::get(stationId); // First, draw the town name. { auto args = FormatArguments{}; args.push(StringIds::stringid_stringid); args.push(station->name); args.push<uint16_t>(enumValue(station->town)); args.push<uint16_t>(getTransportIconsFromStationFlags(station->flags)); auto point = Point(0, yPos); tr.drawStringLeftClipped(point, 198, Colour::black, text_colour_id, args); } char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); station->getStatusString(buffer); // Then the station's current status. { auto args = FormatArguments{}; args.push(StringIds::buffer_1250); auto point = Point(200, yPos); tr.drawStringLeftClipped(point, 198, Colour::black, text_colour_id, args); } // Total units waiting. { uint16_t totalUnits = 0; for (const auto& stats : station->cargoStats) { totalUnits += stats.quantity; } auto args = FormatArguments{}; args.push(StringIds::num_units); args.push<uint32_t>(totalUnits); auto point = Point(400, yPos); tr.drawStringLeftClipped(point, 88, Colour::black, text_colour_id, args); } // And, finally, what goods the station accepts. char* ptr = buffer; *ptr = '\0'; for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { auto& stats = station->cargoStats[cargoId]; if (!stats.isAccepted()) { continue; } if (*buffer != '\0') { ptr = StringManager::formatString(ptr, StringIds::unit_separator); } ptr = StringManager::formatString(ptr, ObjectManager::get<CargoObject>(cargoId)->name); } { auto args = FormatArguments{}; args.push(StringIds::buffer_1250); auto point = Point(490, yPos); tr.drawStringLeftClipped(point, 118, Colour::black, text_colour_id, args); } yPos += kRowHeight; } } // 00491A76 static void drawTabs(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); auto companyColour = CompanyManager::getCompanyColour(CompanyId(self.number)); for (const auto& tab : tabInformationByType) { uint32_t image = Gfx::recolour(skin->img + tab.imageId, companyColour); Widget::drawTab(self, drawingCtx, image, tab.widgetIndex); } } // 0x004914D8 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets and tabs. self.draw(drawingCtx); drawTabs(self, drawingCtx); // Draw company owner image. auto company = CompanyManager::get(CompanyId(self.number)); auto competitor = ObjectManager::get<CompetitorObject>(company->competitorId); uint32_t image = Gfx::recolour(competitor->images[enumValue(company->ownerEmotion)], company->mainColours.primary); uint16_t x = self.x + self.widgets[widx::company_select].left + 1; uint16_t y = self.y + self.widgets[widx::company_select].top + 1; drawingCtx.drawImage(x, y, image); } // 0x004917BB static void onDropdown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::company_select) { return; } if (itemIndex == -1) { return; } CompanyId companyId = Dropdown::getCompanyIdFromSelection(itemIndex); // Try to find an open station list for this company. auto companyWindow = WindowManager::bringToFront(WindowType::stationList, enumValue(companyId)); if (companyWindow != nullptr) { return; } // If not, we'll turn this window into a window for the company selected. auto company = CompanyManager::get(companyId); if (company->name == StringIds::empty) { return; } window.number = enumValue(companyId); window.owner = companyId; window.sortMode = 0; window.rowCount = 0; refreshStationList(&window); window.var_83C = 0; window.rowHover = -1; window.callOnResize(); window.callPrepareDraw(); window.initScrollWidgets(); window.invalidate(); } // 0x004917B0 static void onMouseDown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::company_select) { Dropdown::populateCompanySelect(&window, &window.widgets[widgetIndex]); } } // 0x00491785 static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close_button: WindowManager::close(&window); break; case tab_all_stations: case tab_rail_stations: case tab_road_stations: case tab_airports: case tab_ship_ports: { if (ToolManager::isToolActive(window.type, window.number)) { ToolManager::toolCancel(); } window.currentTab = widgetIndex - widx::tab_all_stations; window.frameNo = 0; window.invalidate(); window.var_83C = 0; window.rowHover = -1; refreshStationList(&window); window.callOnResize(); window.callPrepareDraw(); window.initScrollWidgets(); window.moveInsideScreenEdges(); break; } case sort_name: case sort_status: case sort_total_waiting: case sort_accepts: { auto sortMode = widgetIndex - widx::sort_name; if (window.sortMode == sortMode) { return; } window.sortMode = sortMode; window.invalidate(); window.var_83C = 0; window.rowHover = -1; refreshStationList(&window); break; } } } // 0x00491A0C static void onScrollMouseDown(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentRow = y / kRowHeight; if (currentRow > window.var_83C) { return; } const auto currentStation = StationId(window.rowInfo[currentRow]); if (currentStation == StationId::null) { return; } Station::open(currentStation); } // 0x004919D1 static void onScrollMouseOver(Ui::Window& window, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { window.flags &= ~(WindowFlags::notScrollView); uint16_t currentRow = y / kRowHeight; int16_t currentStation = -1; if (currentRow < window.var_83C) { currentStation = window.rowInfo[currentRow]; } if (currentStation == window.rowHover) { return; } window.rowHover = currentStation; window.invalidate(); } // 0x0049193F static void onUpdate(Window& window) { window.frameNo++; window.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::stationList, window.number, window.currentTab + 4); // Add three stations every tick. updateStationList(&window); updateStationList(&window); updateStationList(&window); } // 0x00491999 static void getScrollSize(Ui::Window& window, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = kRowHeight * window.var_83C; } // 0x00491841 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_station_list); return args; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/StationWindow.cpp ```cpp #include "Config.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/RenameStation.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/MapSelection.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Objects/CargoObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include "Vehicles/VehicleManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Utility/String.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::Ui::Windows::Station { static loco_global<uint8_t[kMapSize], 0x00F00484> _byte_F00484; static loco_global<StationId, 0x00112C786> _lastSelectedStation; using Vehicles::VehicleHead; namespace Common { static constexpr Ui::Size32 kMinWindowSize = { 192, 136 }; static constexpr Ui::Size32 kMaxWindowSize = { 600, 440 }; enum widx { frame, caption, close_button, panel, tab_station, tab_cargo, tab_cargo_ratings, tab_vehicles_trains, tab_vehicles_buses, tab_vehicles_trucks, tab_vehicles_trams, tab_vehicles_aircraft, tab_vehicles_ships, content_begin, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::blackText, WindowColour::primary, StringIds::title_station), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 95 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_station), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_station_cargo), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_station_cargo_ratings), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_trains), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_buses), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_trucks), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_trams), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_aircraft), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_ships)); } static bool isVehicleTypeAvailable(Window& self, VehicleType vehicleType) { return (self.var_846 & (1U << enumValue(vehicleType))) != 0; } static void setVehicleTypeAvailable(Window& self, VehicleType vehicleType) { self.var_846 |= (1U << enumValue(vehicleType)); } // Defined at the bottom of this file. static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, const WidgetId id); static void prepareDraw(Window& self); static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input); static void update(Window& self); static void renameStationPrompt(Window* self, WidgetIndex_t widgetIndex); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); static void enableRenameByCaption(Window* self); } namespace Station { static constexpr Ui::Size32 kWindowSize = { 223, 136 }; enum widx { viewport = Common::widx::content_begin, status_bar, centre_on_viewport, }; static constexpr auto widgets = makeWidgets( // commonWidgets(kWindowSize.width, kWindowSize.height), Common::makeCommonWidgets(223, 136), Widgets::Viewport({ 3, 44 }, { 195, 80 }, WindowColour::secondary, Widget::kContentUnk), Widgets::Label({ 3, 115 }, { 195, 21 }, WindowColour::secondary, ContentAlign::center), Widgets::ImageButton({ 0, 0 }, { 24, 24 }, WindowColour::secondary, ImageIds::centre_viewport, StringIds::move_main_view_to_show_this) ); // 0x0048E352 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::viewport].right = self.width - 4; self.widgets[widx::viewport].bottom = self.height - 14; self.widgets[widx::status_bar].top = self.height - 12; self.widgets[widx::status_bar].bottom = self.height - 3; self.widgets[widx::status_bar].right = self.width - 14; self.widgets[widx::centre_on_viewport].right = self.widgets[widx::viewport].right - 1; self.widgets[widx::centre_on_viewport].bottom = self.widgets[widx::viewport].bottom - 1; self.widgets[widx::centre_on_viewport].left = self.widgets[widx::viewport].right - 24; self.widgets[widx::centre_on_viewport].top = self.widgets[widx::viewport].bottom - 24; Widget::leftAlignTabs(self, Common::widx::tab_station, Common::widx::tab_cargo_ratings); } // 0x0048E470 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto station = StationManager::get(StationId(self.number)); const char* buffer = StringManager::getString(StringIds::buffer_1250); station->getStatusString((char*)buffer); FormatArguments args{}; args.push(StringIds::buffer_1250); const auto& widget = self.widgets[widx::status_bar]; const auto width = widget.width() - 1; auto point = Point(self.x + widget.left - 1, self.y + widget.top - 1); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::black_stringid, args); } // 0x0048E4D4 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, const WidgetId id) { switch (widgetIndex) { // 0x0049932D case widx::centre_on_viewport: self.viewportCentreMain(); return; } Common::onMouseUp(self, widgetIndex, id); } static void initViewport(Window& self); // 0x0048E70B static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(kWindowSize, Common::kMaxWindowSize); if (self.viewports[0] != nullptr) { uint16_t newWidth = self.width - 8; uint16_t newHeight = self.height - 59; auto& viewport = self.viewports[0]; if (newWidth != viewport->width || newHeight != viewport->height) { viewport->width = newWidth; viewport->height = newHeight; viewport->viewWidth = newWidth << viewport->zoom; viewport->viewHeight = newHeight << viewport->zoom; self.savedView.clear(); } } initViewport(self); } // 0x0048F11B static void initViewport(Window& self) { if (self.currentTab != 0) { return; } self.callPrepareDraw(); // Figure out the station's position on the map. auto station = StationManager::get(StationId(self.number)); // Compute views. SavedView view = { station->x, station->y, ZoomLevel::half, static_cast<int8_t>(self.viewports[0]->getRotation()), station->z, }; view.flags |= (1 << 14); ViewportFlags flags = ViewportFlags::none; if (self.viewports[0] != nullptr) { if (self.savedView == view) { return; } flags = self.viewports[0]->flags; self.viewportRemove(0); } else { if (Config::get().gridlinesOnLandscape) { flags |= ViewportFlags::gridlines_on_landscape; } } // Remove station names from viewport flags |= ViewportFlags::station_names_displayed; self.savedView = view; // 0x0048F1CB start if (self.viewports[0] == nullptr) { auto widget = &self.widgets[widx::viewport]; auto tile = World::Pos3({ station->x, station->y, station->z }); auto origin = Ui::Point(widget->left + self.x + 1, widget->top + self.y + 1); auto size = Ui::Size(widget->width() - 2, widget->height() - 2); ViewportManager::create(&self, 0, origin, size, self.savedView.zoomLevel, tile); self.invalidate(); self.flags |= WindowFlags::viewportNoScrolling; } // 0x0048F1CB end if (self.viewports[0] != nullptr) { self.viewports[0]->flags = flags; self.invalidate(); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .viewportRotate = initViewport, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace VehiclesStopping { static void refreshVehicleList(Window* self); } // 0x0048F210 Window* open(StationId stationId) { auto window = WindowManager::bringToFront(WindowType::station, enumValue(stationId)); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); } window = WindowManager::bringToFront(WindowType::station, enumValue(stationId)); } if (window == nullptr) { // 0x0048F29F start const WindowFlags newFlags = WindowFlags::resizable | WindowFlags::flag_11; window = WindowManager::createWindow(WindowType::station, Station::kWindowSize, newFlags, Station::getEvents()); window->number = enumValue(stationId); auto station = StationManager::get(stationId); window->owner = station->owner; window->minWidth = Common::kMinWindowSize.width; window->minHeight = Common::kMinWindowSize.height; window->maxWidth = Common::kMaxWindowSize.width; window->maxHeight = Common::kMaxWindowSize.height; window->savedView.clear(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, skin->windowPlayerColor); // 0x0048F29F end } window->currentTab = Common::widx::tab_station - Common::widx::tab_station; window->invalidate(); // We'll need the vehicle list to determine what vehicle tabs to show VehiclesStopping::refreshVehicleList(window); window->setWidgets(Station::widgets); window->holdableWidgets = 0; window->eventHandlers = &Station::getEvents(); window->activatedWidgets = 0; window->disabledWidgets = 0; window->initScrollWidgets(); Station::initViewport(*window); return window; } void reset() { _lastSelectedStation = StationId::null; } namespace Cargo { enum widx { scrollview = Common::widx::content_begin, status_bar, station_catchment, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(223, 136), Widgets::ScrollView({ 3, 44 }, { 217, 80 }, WindowColour::secondary, 2), Widgets::Label({ 3, 125 }, { 195, 10 }, WindowColour::secondary, ContentAlign::center), Widgets::ImageButton({ 198, 44 }, { 24, 24 }, WindowColour::secondary, ImageIds::show_station_catchment, StringIds::station_catchment) ); // 0x0048E7C0 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 26; self.widgets[widx::scrollview].bottom = self.height - 14; self.widgets[widx::status_bar].top = self.height - 12; self.widgets[widx::status_bar].bottom = self.height - 3; self.widgets[widx::status_bar].right = self.width - 14; self.widgets[widx::station_catchment].right = self.width - 2; self.widgets[widx::station_catchment].left = self.width - 25; Widget::leftAlignTabs(self, Common::widx::tab_station, Common::widx::tab_cargo_ratings); self.activatedWidgets &= ~(1 << widx::station_catchment); if (StationId(self.number) == _lastSelectedStation) { self.activatedWidgets |= (1 << widx::station_catchment); } } // 0x0048E8DE static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); buffer = StringManager::formatString(buffer, StringIds::accepted_cargo_separator); auto station = StationManager::get(StationId(self.number)); uint8_t cargoTypeCount = 0; for (uint32_t cargoId = 0; cargoId < kMaxCargoStats; cargoId++) { auto& stats = station->cargoStats[cargoId]; if (!stats.isAccepted()) { continue; } *buffer++ = ' '; *buffer++ = ControlCodes::inlineSpriteStr; *(reinterpret_cast<uint32_t*>(buffer)) = ObjectManager::get<CargoObject>(cargoId)->unitInlineSprite; buffer += 4; cargoTypeCount++; } if (cargoTypeCount == 0) { buffer = StringManager::formatString(buffer, StringIds::cargo_nothing_accepted); } *buffer++ = '\0'; const auto& widget = self.widgets[widx::status_bar]; const auto width = widget.width(); auto point = Point(self.x + widget.left - 1, self.y + widget.top - 1); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::buffer_1250); } // 0x0048EB0B static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, const WidgetId id) { switch (widgetIndex) { case widx::station_catchment: { StationId windowNumber = StationId(self.number); if (windowNumber == _lastSelectedStation) { windowNumber = StationId::null; } showStationCatchment(windowNumber); return; } } Common::onMouseUp(self, widgetIndex, id); } // 0x0048EBB7 static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(Common::kMinWindowSize, Common::kMaxWindowSize); } // 0x0048EB64 static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { auto station = StationManager::get(StationId(self.number)); scrollHeight = 0; for (const auto& cargoStats : station->cargoStats) { if (cargoStats.quantity != 0) { scrollHeight += 12; if (cargoStats.origin != StationId(self.number)) { scrollHeight += 10; } } } } // 0x0048EB4F static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_cargo_list); return args; } // 0x0048E986 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); const auto station = StationManager::get(StationId(self.number)); int16_t y = 1; auto cargoId = 0; for (const auto& cargoStats : station->cargoStats) { // auto& cargo = station->cargo_stats[i]; auto& cargo = cargoStats; auto quantity = cargo.quantity; if (quantity == 0) { cargoId++; continue; } quantity = std::min(int(quantity), 400); auto units = (quantity + 9) / 10; auto cargoObj = ObjectManager::get<CargoObject>(cargoId); if (units != 0) { uint16_t xPos = 1; for (; units > 0; units--) { { drawingCtx.drawImage(xPos, y, cargoObj->unitInlineSprite); xPos += 10; } } } auto cargoName = cargoObj->unitNameSingular; if (cargo.quantity != 1) { cargoName = cargoObj->unitNamePlural; } const auto& widget = self.widgets[widx::scrollview]; auto xPos = widget.width() - 14; { FormatArguments args{}; args.push(cargoName); args.push<uint32_t>(cargo.quantity); auto cargoStr = StringIds::station_cargo; if (cargo.origin != StationId(self.number)) { cargoStr = StringIds::station_cargo_en_route_start; } auto point = Point(xPos, y); tr.drawStringRight(point, AdvancedColour(Colour::black).outline(), cargoStr, args); y += 10; } if (cargo.origin != StationId(self.number)) { auto originStation = StationManager::get(cargo.origin); FormatArguments args{}; args.push(originStation->name); args.push(originStation->town); auto point = Point(xPos, y); tr.drawStringRight(point, AdvancedColour(Colour::black).outline(), StringIds::station_cargo_en_route_end, args); y += 10; } y += 2; cargoId++; } uint16_t totalUnits = 0; for (const auto& stats : station->cargoStats) { totalUnits += stats.quantity; } if (totalUnits == 0) { FormatArguments args{}; args.push(StringIds::nothing_waiting); auto point = Point(1, 0); tr.drawStringLeft(point, Colour::black, StringIds::black_stringid, args); } } // 0x0048EC21 static void onClose(Window& self) { if (StationId(self.number) == _lastSelectedStation) { showStationCatchment(StationId::null); } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::update, .getScrollSize = getScrollSize, .textInput = Common::textInput, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CargoRatings { static constexpr Ui::Size32 kWindowSize = { 249, 136 }; static constexpr Ui::Size32 kMaxWindowSize = { 249, 440 }; enum widx { scrollview = Common::widx::content_begin, status_bar, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(249, 136), Widgets::ScrollView({ 3, 44 }, { 244, 80 }, WindowColour::secondary, 2), Widgets::Label({ 3, 125 }, { 221, 11 }, WindowColour::secondary, ContentAlign::center) ); // 0x0048EC3B static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; self.widgets[widx::status_bar].top = self.height - 12; self.widgets[widx::status_bar].bottom = self.height - 3; self.widgets[widx::status_bar].right = self.width - 14; Widget::leftAlignTabs(self, Common::widx::tab_station, Common::widx::tab_cargo_ratings); } // 0x0048ED24 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } // 0x0048EE97 static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(kWindowSize, kMaxWindowSize); } // 0x0048EE4A static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { auto station = StationManager::get(StationId(self.number)); scrollHeight = 0; for (uint8_t i = 0; i < 32; i++) { if (station->cargoStats[i].origin != StationId::null) { scrollHeight += 10; } } } // 0x0048EE73 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_ratings_list); return args; } // 0x0048EF02 static void drawRatingBar(Window* self, Gfx::DrawingContext& drawingCtx, int16_t x, int16_t y, uint8_t amount, Colour colour) { drawingCtx.fillRectInset(x, y, x + 99, y + 9, self->getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); uint16_t rating = (amount * 96) / 256; if (rating > 2) { drawingCtx.fillRectInset(x + 2, y + 2, x + 1 + rating, y + 8, colour, Gfx::RectInsetFlags::none); } } // 0x0048ED2F static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); const auto station = StationManager::get(StationId(self.number)); auto point = Point(0, 0); auto cargoId = 0; for (const auto& cargoStats : station->cargoStats) { auto& cargo = cargoStats; if (cargo.empty()) { cargoId++; continue; } auto cargoObj = ObjectManager::get<CargoObject>(cargoId); point.x = 1; { auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(cargoObj->name); tr.drawStringLeftClipped(point, 98, Colour::black, StringIds::wcolour2_stringid, args); } auto rating = cargo.rating; auto colour = Colour::green; if (rating < 100) { colour = Colour::yellow; if (rating < 50) { colour = Colour::red; } } uint8_t amount = (rating * 327) / 256; drawRatingBar(&self, drawingCtx, 100, point.y, amount, colour); uint16_t percent = rating / 2; point.x = 201; { auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(percent); tr.drawStringLeft(point, Colour::black, StringIds::station_cargo_rating_percent, args); } point.y += 10; cargoId++; } } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = Common::update, .getScrollSize = getScrollSize, .textInput = Common::textInput, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // NB: This namespace shares a fair bit of code with the VehicleList window. // We should look into sharing some of these functions. namespace VehiclesStopping { static constexpr Ui::Size32 kWindowSize = { 400, 200 }; static constexpr Ui::Size32 kMaxWindowSize = { 600, 800 }; enum widx { scrollview = Common::widx::content_begin, status_bar, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(223, 136), Widgets::ScrollView({ 3, 44 }, { 544, 138 }, WindowColour::secondary, Scrollbars::vertical), Widgets::Label({ 3, kWindowSize.height - 13 }, { kWindowSize.width, 10 }, WindowColour::secondary, ContentAlign::left, StringIds::black_stringid) ); static bool vehicleStopsAtActiveStation(const VehicleHead* head, StationId filterStationId) { auto orders = Vehicles::OrderRingView(head->orderTableOffset); for (auto& order : orders) { auto* stationOrder = order.as<Vehicles::OrderStation>(); if (stationOrder == nullptr) { continue; } const auto stationId = stationOrder->getStation(); if (stationId == filterStationId) { return true; } } return false; } static VehicleType getCurrentVehicleType(Window* self) { return static_cast<VehicleType>(self->currentTab - (Common::widx::tab_vehicles_trains - Common::widx::tab_station)); } static void refreshVehicleList(Window* self) { auto currentVehicleType = getCurrentVehicleType(self); self->rowCount = 0; for (auto* vehicle : VehicleManager::VehicleList()) { if (!vehicleStopsAtActiveStation(vehicle, StationId(self->number))) { continue; } Common::setVehicleTypeAvailable(*self, vehicle->vehicleType); if (vehicle->vehicleType != currentVehicleType) { continue; } vehicle->vehicleFlags &= ~VehicleFlags::sorted; } } static bool orderByName(const VehicleHead& lhs, const VehicleHead& rhs) { char lhsString[256] = { 0 }; { FormatArguments lhsArgs{}; lhsArgs.push(lhs.ordinalNumber); StringManager::formatString(lhsString, lhs.name, lhsArgs); } char rhsString[256] = { 0 }; { FormatArguments rhsArgs{}; rhsArgs.push(rhs.ordinalNumber); StringManager::formatString(rhsString, rhs.name, rhsArgs); } return Utility::strlogicalcmp(lhsString, rhsString) < 0; } static void updateVehicleList(Window* self) { auto currentVehicleType = getCurrentVehicleType(self); EntityId insertId = EntityId::null; for (auto* vehicle : VehicleManager::VehicleList()) { if (vehicle->vehicleType != currentVehicleType) { continue; } if (vehicle->hasVehicleFlags(VehicleFlags::sorted)) { continue; } if (!vehicleStopsAtActiveStation(vehicle, StationId(self->number))) { continue; } if (insertId == EntityId::null) { insertId = vehicle->id; continue; } auto* insertVehicle = EntityManager::get<VehicleHead>(insertId); if (insertVehicle == nullptr) { continue; } if (orderByName(*vehicle, *insertVehicle)) { insertId = vehicle->id; continue; } } if (insertId != EntityId::null) { auto vehicle = EntityManager::get<VehicleHead>(insertId); if (vehicle == nullptr) { self->var_83C = self->rowCount; refreshVehicleList(self); return; } vehicle->vehicleFlags |= VehicleFlags::sorted; if (vehicle->id != EntityId(self->rowInfo[self->rowCount])) { self->rowInfo[self->rowCount] = enumValue(vehicle->id); } self->rowCount++; if (self->rowCount > self->var_83C) { self->var_83C = self->rowCount; } } else { if (self->var_83C != self->rowCount) { self->var_83C = self->rowCount; } refreshVehicleList(self); } } void removeTrainFromList(Window& self, EntityId head) { for (auto i = 0; i < self.var_83C; ++i) { auto& entry = self.rowInfo[i]; if (entry == enumValue(head)) { entry = enumValue(EntityId::null); } } } static void prepareDraw(Window& self) { Common::prepareDraw(self); static constexpr StringId kTypeToCaption[] = { StringIds::stringid_trains, StringIds::stringid_buses, StringIds::stringid_trucks, StringIds::stringid_trams, StringIds::stringid_aircraft, StringIds::stringid_ships, }; auto currentVehicleType = getCurrentVehicleType(&self); self.widgets[Common::widx::caption].text = kTypeToCaption[enumValue(currentVehicleType)]; // Basic frame widget dimensions self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; static constexpr std::pair<StringId, StringId> kTypeToFooterStringIds[]{ { StringIds::num_trains_singular, StringIds::num_trains_plural }, { StringIds::num_buses_singular, StringIds::num_buses_plural }, { StringIds::num_trucks_singular, StringIds::num_trucks_plural }, { StringIds::num_trams_singular, StringIds::num_trams_plural }, { StringIds::num_aircrafts_singular, StringIds::num_aircrafts_plural }, { StringIds::num_ships_singular, StringIds::num_ships_plural }, }; { // Reposition status bar auto& widget = self.widgets[widx::status_bar]; widget.top = self.height - 13; widget.bottom = self.height - 3; // Set status bar FormatArguments args{ widget.textArgs }; auto& footerStringPair = kTypeToFooterStringIds[enumValue(currentVehicleType)]; args.push(self.var_83C == 1 ? footerStringPair.first : footerStringPair.second); args.push(self.var_83C); } } static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 1); drawingCtx.clearSingle(shade); auto yPos = 0; for (auto i = 0; i < self.var_83C; i++) { const auto vehicleId = EntityId(self.rowInfo[i]); // Item not in rendering context, or no vehicle available for this slot? if (yPos + self.rowHeight < rt.y || vehicleId == EntityId::null) { yPos += self.rowHeight; continue; } else if (yPos >= rt.y + rt.height + self.rowHeight) { break; } auto head = EntityManager::get<VehicleHead>(vehicleId); if (head == nullptr) { continue; } // Highlight selection. if (head->id == EntityId(self.rowHover)) { drawingCtx.drawRect(0, yPos, self.width, self.rowHeight, Colours::getShade(self.getColour(WindowColour::secondary).c(), 0), Gfx::RectFlags::none); } auto vehicle = Vehicles::Vehicle(*head); // Draw vehicle at the bottom of the row drawTrainInline(drawingCtx, vehicle, Ui::Point(0, yPos + (self.rowHeight - 28) / 2 + 6)); // Draw vehicle status { // Prepare status for drawing auto status = head->getStatus(); auto args = FormatArguments::common(); args.push(head->name); args.push(head->ordinalNumber); args.push(status.status1); args.push(status.status1Args); args.push(status.status2); args.push(status.status2Args); StringId format = StringIds::vehicle_list_status_2pos; if (status.status2 != StringIds::null) { format = StringIds::vehicle_list_status_3pos; } // Draw status yPos += 2; auto point = Point(1, yPos); tr.drawStringLeftClipped(point, 308, AdvancedColour(Colour::black).outline(), format, args); } yPos += self.rowHeight - 2; } } static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_vehicle_list); return args; } static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); updateVehicleList(&self); updateVehicleList(&self); updateVehicleList(&self); self.invalidate(); } static void event_08(Window& self) { self.flags |= WindowFlags::notScrollView; } static void event_09(Window& self) { if (self.hasFlags(WindowFlags::notScrollView)) { self.rowHover = -1; } } static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = self.var_83C * self.rowHeight; } static CursorId cursor(Window& self, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, CursorId fallback) { if (widgetIdx != widx::scrollview) { return fallback; } uint16_t currentIndex = yPos / self.rowHeight; if (currentIndex < self.var_83C && self.rowInfo[currentIndex] != -1) { return CursorId::handPointer; } return fallback; } static void onScrollMouseOver(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { self.flags &= ~WindowFlags::notScrollView; uint16_t currentRow = y / self.rowHeight; if (currentRow < self.var_83C) { self.rowHover = self.rowInfo[currentRow]; } else { self.rowHover = -1; } } static void onScrollMouseDown(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentRow = y / self.rowHeight; if (currentRow >= self.var_83C) { return; } EntityId currentVehicleId = EntityId(self.rowInfo[currentRow]); if (currentVehicleId == EntityId::null) { return; } auto* head = EntityManager::get<VehicleHead>(currentVehicleId); if (head == nullptr) { return; } if (head->isPlaced()) { Ui::Windows::Vehicle::Main::open(head); } else { Ui::Windows::Vehicle::Details::open(head); } } static void onResize(Window& self) { Common::enableRenameByCaption(&self); self.setSize(kWindowSize, kMaxWindowSize); } static constexpr WindowEventList kEvents = { .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x00491BC6 void sub_491BC6() { TileLoop tileLoop; for (uint32_t posId = 0; posId < kMapSize; posId++) { if (_byte_F00484[posId] & (1 << 0)) { TileManager::mapInvalidateTileFull(tileLoop.current()); } tileLoop.next(); } } // 0x0049271A void showStationCatchment(StationId stationId) { if (stationId == _lastSelectedStation) { return; } const StationId oldStationId = _lastSelectedStation; _lastSelectedStation = stationId; if (oldStationId != StationId::null) { if (World::hasMapSelectionFlag(World::MapSelectionFlags::catchmentArea)) { WindowManager::invalidate(WindowType::station, enumValue(oldStationId)); sub_491BC6(); World::resetMapSelectionFlag(World::MapSelectionFlags::catchmentArea); } } const StationId newStationId = _lastSelectedStation; if (newStationId != StationId::null) { Ui::Windows::Construction::sub_4A6FAC(); auto* station = StationManager::get(_lastSelectedStation); setCatchmentDisplay(station, CatchmentFlags::flag_0); World::setMapSelectionFlags(World::MapSelectionFlags::catchmentArea); WindowManager::invalidate(WindowType::station, enumValue(newStationId)); sub_491BC6(); } } namespace Common { struct TabInformation { const widx widgetIndex; std::span<const Widget> widgets; const WindowEventList& events; const uint8_t rowHeight; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { widx::tab_station, Station::widgets, Station::getEvents(), 0 }, { widx::tab_cargo, Cargo::widgets, Cargo::getEvents(), 0 }, { widx::tab_cargo_ratings, CargoRatings::widgets, CargoRatings::getEvents(), 0 }, { widx::tab_vehicles_trains, VehiclesStopping::widgets, VehiclesStopping::getEvents(), 28 }, { widx::tab_vehicles_buses, VehiclesStopping::widgets, VehiclesStopping::getEvents(), 28 }, { widx::tab_vehicles_trucks, VehiclesStopping::widgets, VehiclesStopping::getEvents(), 28 }, { widx::tab_vehicles_trams, VehiclesStopping::widgets, VehiclesStopping::getEvents(), 28 }, { widx::tab_vehicles_aircraft, VehiclesStopping::widgets, VehiclesStopping::getEvents(), 48 }, { widx::tab_vehicles_ships, VehiclesStopping::widgets, VehiclesStopping::getEvents(), 36 }, }; // clang-format on static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::caption: renameStationPrompt(&self, widgetIndex); break; case widx::close_button: WindowManager::close(&self); break; case widx::tab_station: case widx::tab_cargo: case widx::tab_cargo_ratings: case widx::tab_vehicles_trains: case widx::tab_vehicles_buses: case widx::tab_vehicles_trucks: case widx::tab_vehicles_trams: case widx::tab_vehicles_aircraft: case widx::tab_vehicles_ships: switchTab(self, widgetIndex); break; } } // 0x0048E352, 0x0048E7C0 and 0x0048EC3B static void prepareDraw(Window& self) { // Hide vehicle types without known vehicles calling at this station for (auto i = enumValue(VehicleType::train); i <= enumValue(VehicleType::ship); i++) { if (isVehicleTypeAvailable(self, VehicleType(i))) { self.disabledWidgets &= ~(1ULL << (widx::tab_vehicles_trains + i)); } else { self.disabledWidgets |= (1ULL << (widx::tab_vehicles_trains + i)); } } Widget::leftAlignTabs(self, widx::tab_station, widx::tab_vehicles_ships); // Activate the current tab. self.activatedWidgets &= ~((1ULL << widx::tab_station) | (1ULL << widx::tab_cargo) | (1ULL << widx::tab_cargo_ratings) | (1ULL << widx::tab_vehicles_trains) | (1ULL << widx::tab_vehicles_buses) | (1ULL << widx::tab_vehicles_trucks) | (1ULL << widx::tab_vehicles_trams) | (1ULL << widx::tab_vehicles_aircraft) | (1ULL << widx::tab_vehicles_ships)); widx widgetIndex = tabInformationByTabOffset[self.currentTab].widgetIndex; self.activatedWidgets |= (1ULL << widgetIndex); // Put station and town name in place. auto* station = StationManager::get(StationId(self.number)); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(station->name); args.push(station->town); args.push(getTransportIconsFromStationFlags(station->flags)); // Resize common widgets. self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; } // 0x0048E5DF static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget != Common::widx::caption) { return; } GameCommands::setErrorTitle(StringIds::error_cant_rename_station); GameCommands::RenameStationArgs args{}; args.stationId = StationId(self.number); args.nameBufferIndex = 1; std::memcpy(args.buffer, input, 36); GameCommands::doCommand(args, GameCommands::Flags::apply); args.nameBufferIndex = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.nameBufferIndex = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x0048E6F1 static void update(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidate(WindowType::station, self.number); } // 0x0048E5E7 static void renameStationPrompt(Window* self, WidgetIndex_t widgetIndex) { auto station = StationManager::get(StationId(self->number)); auto args = FormatArguments(); args.push<int64_t>(0); args.push(station->name); args.push(station->town); TextInput::openTextInput(self, StringIds::title_station_name, StringIds::prompt_type_new_station_name, station->name, widgetIndex, &station->town); } // 0x0048E520 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (widgetIndex != widx::tab_cargo) { if (StationId(self.number) == _lastSelectedStation) { showStationCatchment(StationId::null); } } if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } TextInput::sub_4CE6C9(self.type, self.number); self.currentTab = widgetIndex - widx::tab_station; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.var_85C = -1; self.viewportRemove(0); auto tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_station]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.disabledWidgets = 0; self.rowHeight = tabInfo.rowHeight; // We'll need the vehicle list to determine what vehicle tabs to show VehiclesStopping::refreshVehicleList(&self); self.rowCount = 0; self.var_83C = 0; self.rowHover = -1; self.invalidate(); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x0048EFBC void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); auto station = StationManager::get(StationId(self.number)); auto companyColour = CompanyManager::getCompanyColour(station->owner); // Station tab { uint32_t imageId = Gfx::recolour(skin->img, companyColour); imageId += InterfaceSkin::ImageIds::toolbar_menu_stations; Widget::drawTab(self, drawingCtx, imageId, widx::tab_station); } // Cargo tab { static constexpr uint32_t cargoTabImageIds[] = { InterfaceSkin::ImageIds::tab_cargo_delivered_frame0, InterfaceSkin::ImageIds::tab_cargo_delivered_frame1, InterfaceSkin::ImageIds::tab_cargo_delivered_frame2, InterfaceSkin::ImageIds::tab_cargo_delivered_frame3, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_cargo - widx::tab_station) { imageId += cargoTabImageIds[(self.frameNo / 8) % std::size(cargoTabImageIds)]; } else { imageId += cargoTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_cargo); } // Cargo ratings tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::tab_cargo_ratings; Widget::drawTab(self, drawingCtx, imageId, widx::tab_cargo_ratings); auto widget = self.widgets[widx::tab_cargo_ratings]; auto yOffset = widget.top + self.y + 14; auto xOffset = widget.left + self.x + 4; auto totalRatingBars = 0; for (const auto& cargoStats : station->cargoStats) { auto& cargo = cargoStats; if (!cargo.empty()) { drawingCtx.fillRect(xOffset, yOffset, xOffset + 22, yOffset + 1, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); auto ratingColour = Colour::green; if (cargo.rating < 100) { ratingColour = Colour::yellow; if (cargo.rating < 50) { ratingColour = Colour::red; } } auto ratingBarLength = (cargo.rating * 30) / 256; drawingCtx.fillRect(xOffset, yOffset, xOffset - 1 + ratingBarLength, yOffset + 1, Colours::getShade(ratingColour, 6), Gfx::RectFlags::none); yOffset += 3; totalRatingBars++; if (totalRatingBars >= 4) { break; } } } } // clang-format off static constexpr std::pair<WidgetIndex_t, std::array<uint32_t, 8>> kTabAnimations[] = { { Common::widx::tab_vehicles_trains, { InterfaceSkin::ImageIds::vehicle_train_frame_0, InterfaceSkin::ImageIds::vehicle_train_frame_1, InterfaceSkin::ImageIds::vehicle_train_frame_2, InterfaceSkin::ImageIds::vehicle_train_frame_3, InterfaceSkin::ImageIds::vehicle_train_frame_4, InterfaceSkin::ImageIds::vehicle_train_frame_5, InterfaceSkin::ImageIds::vehicle_train_frame_6, InterfaceSkin::ImageIds::vehicle_train_frame_7, } }, { Common::widx::tab_vehicles_aircraft, { InterfaceSkin::ImageIds::vehicle_aircraft_frame_0, InterfaceSkin::ImageIds::vehicle_aircraft_frame_1, InterfaceSkin::ImageIds::vehicle_aircraft_frame_2, InterfaceSkin::ImageIds::vehicle_aircraft_frame_3, InterfaceSkin::ImageIds::vehicle_aircraft_frame_4, InterfaceSkin::ImageIds::vehicle_aircraft_frame_5, InterfaceSkin::ImageIds::vehicle_aircraft_frame_6, InterfaceSkin::ImageIds::vehicle_aircraft_frame_7, } }, { Common::widx::tab_vehicles_buses, { InterfaceSkin::ImageIds::vehicle_buses_frame_0, InterfaceSkin::ImageIds::vehicle_buses_frame_1, InterfaceSkin::ImageIds::vehicle_buses_frame_2, InterfaceSkin::ImageIds::vehicle_buses_frame_3, InterfaceSkin::ImageIds::vehicle_buses_frame_4, InterfaceSkin::ImageIds::vehicle_buses_frame_5, InterfaceSkin::ImageIds::vehicle_buses_frame_6, InterfaceSkin::ImageIds::vehicle_buses_frame_7, } }, { Common::widx::tab_vehicles_trams, { InterfaceSkin::ImageIds::vehicle_trams_frame_0, InterfaceSkin::ImageIds::vehicle_trams_frame_1, InterfaceSkin::ImageIds::vehicle_trams_frame_2, InterfaceSkin::ImageIds::vehicle_trams_frame_3, InterfaceSkin::ImageIds::vehicle_trams_frame_4, InterfaceSkin::ImageIds::vehicle_trams_frame_5, InterfaceSkin::ImageIds::vehicle_trams_frame_6, InterfaceSkin::ImageIds::vehicle_trams_frame_7, } }, { Common::widx::tab_vehicles_trucks, { InterfaceSkin::ImageIds::vehicle_trucks_frame_0, InterfaceSkin::ImageIds::vehicle_trucks_frame_1, InterfaceSkin::ImageIds::vehicle_trucks_frame_2, InterfaceSkin::ImageIds::vehicle_trucks_frame_3, InterfaceSkin::ImageIds::vehicle_trucks_frame_4, InterfaceSkin::ImageIds::vehicle_trucks_frame_5, InterfaceSkin::ImageIds::vehicle_trucks_frame_6, InterfaceSkin::ImageIds::vehicle_trucks_frame_7, } }, { Common::widx::tab_vehicles_ships, { InterfaceSkin::ImageIds::vehicle_ships_frame_0, InterfaceSkin::ImageIds::vehicle_ships_frame_1, InterfaceSkin::ImageIds::vehicle_ships_frame_2, InterfaceSkin::ImageIds::vehicle_ships_frame_3, InterfaceSkin::ImageIds::vehicle_ships_frame_4, InterfaceSkin::ImageIds::vehicle_ships_frame_5, InterfaceSkin::ImageIds::vehicle_ships_frame_6, InterfaceSkin::ImageIds::vehicle_ships_frame_7, } }, }; // clang-format on for (auto [tab, frames] : kTabAnimations) { if (self.isDisabled(tab)) { continue; } auto isActive = tab == self.currentTab + Common::widx::tab_station; auto imageId = isActive ? frames[self.frameNo / 2 % 8] : frames[0]; uint32_t image = Gfx::recolour(skin->img + imageId, companyColour); Widget::drawTab(self, drawingCtx, image, tab); } } // 0x0048E32C static void enableRenameByCaption(Window* self) { auto station = StationManager::get(StationId(self->number)); if (station->owner != CompanyId::null) { if (CompanyManager::isPlayerCompany(station->owner)) { self->disabledWidgets &= ~(1 << Common::widx::caption); } else { self->disabledWidgets |= (1 << Common::widx::caption); } } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TerraForm.cpp ```cpp #include "Audio/Audio.h" #include "Economy/Economy.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Terraform/ChangeLandMaterial.h" #include "GameCommands/Terraform/ClearLand.h" #include "GameCommands/Terraform/CreateTree.h" #include "GameCommands/Terraform/CreateWall.h" #include "GameCommands/Terraform/LowerLand.h" #include "GameCommands/Terraform/LowerRaiseLandMountain.h" #include "GameCommands/Terraform/LowerWater.h" #include "GameCommands/Terraform/RaiseLand.h" #include "GameCommands/Terraform/RaiseWater.h" #include "GameCommands/Terraform/RemoveTree.h" #include "GameCommands/Terraform/RemoveWall.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/MapSelection.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "Map/Tree.h" #include "Map/TreeElement.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "Objects/WallObject.h" #include "Objects/WaterObject.h" #include "Scenario.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/ColourButtonWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Engine/World.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Trigonometry.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::GameCommands; namespace OpenLoco::Ui::Windows::Terraform { namespace Common { enum widx { frame = 0, caption = 1, close_button = 2, panel = 3, tab_clear_area, tab_adjust_land, tab_adjust_water, tab_plant_trees, tab_build_walls, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 130, 74 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_clear_land), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_adjust_land), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_adjust_water), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_plant_trees), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_walls)); } static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); static void prepareDraw(Window& self); static void onUpdate(Window& self); static void onResize(Window& self, uint8_t height); static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id); static void sub_4A69DD(); enum class GhostPlacedFlags : uint8_t { none = 0U, tree = 1 << 0, wall = 1 << 1, }; OPENLOCO_ENABLE_ENUM_OPERATORS(GhostPlacedFlags); } // These are still referred to in CreateWall and S5 static loco_global<World::TileElement*, 0x01136470> _lastPlacedWall; static loco_global<uint8_t, 0x01136496> _treeRotation; static int16_t _adjustToolSize; // 0x0050A000 static uint8_t _adjustLandToolSize; // 0x009C870E static uint8_t _clearAreaToolSize; // 0x009C870F static uint8_t _adjustWaterToolSize; // 0x009C8710 static uint8_t _lastSelectedLand; // 0x00F003D2 static uint32_t _raiseLandCost; // 0x00F2530C static uint32_t _lowerLandCost; // 0x00F25310 static World::TreeElement* _lastPlacedTree; // 0x01136470 static uint32_t _lastTreeCost; // 0x01136484 static World::Pos2 _terraformGhostPos; // 0x01136488 static uint16_t _lastTreeColourFlag; // 0x01136490 static uint16_t _terraformGhostTreeRotationFlag; // 0x01136492 static Colour _treeColour; // 0x01136497 static uint8_t _terraformGhostBaseZ; // 0x01136499 static Common::GhostPlacedFlags _terraformGhostPlacedFlags; // 0x0113649A static uint8_t _terraformGhostTreeElementType; // 0x0113649B static uint8_t _terraformGhostType; // 0x0113649C static uint8_t _terraformGhostQuadrant; // 0x0113649D (trees) static uint8_t _terraformGhostRotation; // 0x0113649D (walls) static uint8_t _treeClusterType; // 0x0113649E static uint32_t _lowerWaterCost; // 0x01136528 static uint32_t _raiseWaterCost; // 0x0113652C namespace PlantTrees { static constexpr Ui::Size32 kWindowSize = { 634, 162 }; static constexpr uint8_t kRowHeight = 102; static constexpr uint8_t kColumnWidth = 66; enum widx { scrollview = 9, rotate_object, object_colour, plant_cluster_selected, plant_cluster_random, }; const uint64_t holdableWidgets = 0; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(634, 162, StringIds::title_plant_trees), Widgets::ScrollView({ 3, 45 }, { 605, 101 }, WindowColour::secondary, Scrollbars::vertical), Widgets::ImageButton({ 609, 46 }, { 24, 24 }, WindowColour::secondary, ImageIds::rotate_object, StringIds::rotate_object_90), Widgets::ColourButton({ 609, 70 }, { 24, 24 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_object_colour), Widgets::ImageButton({ 609, 94 }, { 24, 24 }, WindowColour::secondary, ImageIds::plant_cluster_selected_tree, StringIds::plant_cluster_selected_tree), Widgets::ImageButton({ 609, 118 }, { 24, 24 }, WindowColour::secondary, ImageIds::plant_cluster_random_tree, StringIds::plant_cluster_random_tree) ); enum treeCluster { none = 0, selected, random, }; // 0x004BB6B2 static void updateTreeColours(Window& self) { if (self.rowHover != -1) { auto treeObj = ObjectManager::get<TreeObject>(self.rowHover); if (treeObj->colours != 0) { auto bit = Numerics::bitScanReverse(treeObj->colours); auto colour = bit == -1 ? Colour::black : static_cast<Colour>(bit); _treeColour = colour; } } } // 0x004BC4B7 static void updateActiveThumb(Window& self) { int32_t scrollWidth = 0, scrollHeight = 0; self.callGetScrollSize(0, scrollWidth, scrollHeight); self.scrollAreas[0].contentHeight = scrollHeight; auto i = 0; for (; i <= self.var_83C; i++) { if (self.rowInfo[i] == self.rowHover) { break; } } if (i >= self.var_83C) { i = 0; } i = (i / 9) * kRowHeight; self.scrollAreas[0].contentOffsetY = i; Ui::ScrollView::updateThumbs(self, widx::scrollview); } // 0x004BB63F static void refreshTreeList(Window& self) { auto treeCount = 0; for (uint16_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::tree); i++) { auto treeObj = ObjectManager::get<TreeObject>(i); if (treeObj == nullptr) { continue; } self.rowInfo[treeCount] = i; treeCount++; } self.var_83C = treeCount; auto rowHover = -1; if (getGameState().lastTreeOption != 0xFF) { for (auto i = 0; i < self.var_83C; i++) { if (getGameState().lastTreeOption == self.rowInfo[i]) { rowHover = getGameState().lastTreeOption; break; } } } if (rowHover == -1 && self.var_83C != 0) { rowHover = self.rowInfo[0]; } self.rowHover = rowHover; updateActiveThumb(self); updateTreeColours(self); } static void removeTreeGhost(); // 0x004BBB0A static void onClose([[maybe_unused]] Window& self) { removeTreeGhost(); Ui::Windows::Main::hideGridlines(); } // 0x004BBC7D static void tabReset(Window& self) { ToolManager::toolSet(self, Common::widx::panel, CursorId::plantTree); Input::setFlag(Input::Flags::flag6); _terraformGhostPlacedFlags = Common::GhostPlacedFlags::none; _lastTreeCost = 0x80000000; self.var_83C = 0; self.rowHover = -1; refreshTreeList(self); updateTreeColours(self); } // 0x004BBAB5 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_adjust_land: case Common::widx::tab_adjust_water: case Common::widx::tab_build_walls: case Common::widx::tab_clear_area: case Common::widx::tab_plant_trees: Common::switchTab(self, widgetIndex); break; case widx::rotate_object: { _treeRotation++; _treeRotation = _treeRotation & 3; self.invalidate(); break; } case widx::plant_cluster_selected: { if (_treeClusterType == treeCluster::selected) { _treeClusterType = treeCluster::none; } else { _treeClusterType = treeCluster::selected; } self.invalidate(); break; } case widx::plant_cluster_random: { if (_treeClusterType == treeCluster::random) { _treeClusterType = treeCluster::none; } else { _treeClusterType = treeCluster::random; } self.invalidate(); } } } // 0x004BBFBD static void onResize(Window& self) { self.invalidate(); Ui::Size32 kMinWindowSize = { self.minWidth, self.minHeight }; Ui::Size32 kMaxWindowSize = { self.maxWidth, self.maxHeight }; bool hasResized = self.setSize(kMinWindowSize, kMaxWindowSize); if (hasResized) { updateActiveThumb(self); } } // 0x004BBAEA static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::object_colour && self.rowHover != -1) { auto obj = ObjectManager::get<TreeObject>(self.rowHover); Dropdown::showColour(&self, &self.widgets[widgetIndex], obj->colours, _treeColour, self.getColour(WindowColour::secondary)); } } // 0x004BBAF5 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::object_colour) { return; } if (itemIndex == -1) { return; } _treeColour = static_cast<Colour>(Dropdown::getHighlightedItem()); self.invalidate(); } // 0x004BBDA5 static void onUpdate(Window& self) { if (!Input::hasFlag(Input::Flags::toolActive)) { WindowManager::close(&self); } if (ToolManager::getToolWindowType() != WindowType::terraform) { WindowManager::close(&self); } if (!Input::hasFlag(Input::Flags::rightMousePressed)) { auto cursor = Input::getMouseLocation(); auto xPos = cursor.x; auto yPos = cursor.y; Window* activeWindow = WindowManager::findAt(xPos, yPos); if (activeWindow == &self) { xPos -= self.x; xPos += 26; yPos -= self.y; if ((yPos < 42) || (xPos <= self.width)) { xPos = cursor.x; yPos = cursor.y; WidgetIndex_t activeWidget = self.findWidgetAt(xPos, yPos); if (activeWidget > Common::widx::panel) { self.expandContentCounter += 1; if (self.expandContentCounter >= 8) { auto y = std::min(self.scrollAreas[0].contentHeight - 1 + 60, 562); if (Ui::height() < 600) { y = std::min(y, 358); } self.minWidth = kWindowSize.width; self.minHeight = y; self.maxWidth = kWindowSize.width; self.maxHeight = y; } else { if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } } } else { self.expandContentCounter = 0; if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::terraform, self.number, self.currentTab + Common::widx::tab_clear_area); } // 0x004BBEDF static void event_08(Window& self) { if (self.var_846 != 0xFFFFU) { self.var_846 = 0xFFFFU; self.invalidate(); } } // 0x004BD297 (bits of) static void removeTreeGhost() { if ((_terraformGhostPlacedFlags & Common::GhostPlacedFlags::tree) != Common::GhostPlacedFlags::none) { _terraformGhostPlacedFlags = _terraformGhostPlacedFlags & ~Common::GhostPlacedFlags::tree; GameCommands::TreeRemovalArgs args; args.pos = World::Pos3((_terraformGhostPos).x, (_terraformGhostPos).y, _terraformGhostBaseZ * World::kSmallZStep); args.type = _terraformGhostType; args.elementType = _terraformGhostTreeElementType; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } } // 0x004BD237 static currency32_t placeTreeGhost(const GameCommands::TreePlacementArgs& placementArgs) { removeTreeGhost(); auto res = GameCommands::doCommand(placementArgs, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res != GameCommands::FAILURE) { _terraformGhostPos = placementArgs.pos; _terraformGhostTreeElementType = (_lastPlacedTree)->rawData()[0]; _terraformGhostType = placementArgs.type; _terraformGhostBaseZ = (_lastPlacedTree)->baseZ(); _terraformGhostPlacedFlags |= Common::GhostPlacedFlags::tree; _terraformGhostQuadrant = placementArgs.quadrant; _terraformGhostTreeRotationFlag = placementArgs.rotation | (placementArgs.buildImmediately ? 0x8000 : 0); } return res; } // 0x004BD1D9 static std::optional<GameCommands::TreePlacementArgs> getTreePlacementArgsFromCursor(const int16_t x, const int16_t y) { auto* self = WindowManager::find(WindowType::terraform); if (self == nullptr) { return {}; } auto res = ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (!res) { return {}; } if (self->rowHover == -1) { return {}; } GameCommands::TreePlacementArgs args; // 0 for Z value means game command finds first available height args.pos = World::Pos3(res->first.x & 0xFFE0, res->first.y & 0xFFE0, 0); args.type = self->rowHover; args.quadrant = World::getQuadrantFromPos(res->first) ^ (1 << 1); args.colour = _treeColour; args.rotation = (_treeRotation - WindowManager::getCurrentRotation()) & 0x3; if (SceneManager::isEditorMode()) { args.buildImmediately = true; } return { args }; } // 0x004BBB15 static void onToolUpdate([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto placementArgs = getTreePlacementArgsFromCursor(x, y); if (!placementArgs) { removeTreeGhost(); return; } auto cornerValue = enumValue(MapSelectionType::quarter0) + (placementArgs->quadrant ^ (1 << 1)); World::setMapSelectionFlags(World::MapSelectionFlags::enable); World::setMapSelectionCorner(static_cast<MapSelectionType>(cornerValue)); World::setMapSelectionArea(placementArgs->pos, placementArgs->pos); World::mapInvalidateSelectionRect(); if ((_terraformGhostPlacedFlags & Common::GhostPlacedFlags::tree) != Common::GhostPlacedFlags::none) { if (_terraformGhostPos == placementArgs->pos && _terraformGhostQuadrant == placementArgs->quadrant && _terraformGhostType == placementArgs->type && _terraformGhostTreeRotationFlag == (placementArgs->rotation | (placementArgs->buildImmediately ? 0x8000 : 0))) { return; } } removeTreeGhost(); _terraformGhostQuadrant = placementArgs->quadrant; _terraformGhostTreeRotationFlag = placementArgs->rotation | (placementArgs->buildImmediately ? 0x8000 : 0); _lastTreeCost = placeTreeGhost(*placementArgs); } // 0x004BBB20 static void onToolDown([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } removeTreeGhost(); auto placementArgs = getTreePlacementArgsFromCursor(x, y); if (placementArgs) { GameCommands::setErrorTitle(StringIds::cant_plant_this_here); switch (_treeClusterType) { case treeCluster::none: if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } break; case treeCluster::selected: { auto previousId = GameCommands::getUpdatingCompanyId(); if (SceneManager::isEditorMode()) { GameCommands::setUpdatingCompanyId(CompanyId::neutral); } if (World::placeTreeCluster(World::toTileSpace(placementArgs->pos), 320, 3, placementArgs->type)) { auto height = TileManager::getHeight(placementArgs->pos); Audio::playSound(Audio::SoundId::construct, World::Pos3{ placementArgs->pos.x, placementArgs->pos.y, height.landHeight }); } else { Error::open(StringIds::cant_plant_this_here, StringIds::empty); } if (SceneManager::isEditorMode()) { GameCommands::setUpdatingCompanyId(previousId); } break; } case treeCluster::random: auto previousId = GameCommands::getUpdatingCompanyId(); if (SceneManager::isEditorMode()) { GameCommands::setUpdatingCompanyId(CompanyId::neutral); } if (World::placeTreeCluster(World::toTileSpace(placementArgs->pos), 384, 4, std::nullopt)) { auto height = TileManager::getHeight(placementArgs->pos); Audio::playSound(Audio::SoundId::construct, World::Pos3{ placementArgs->pos.x, placementArgs->pos.y, height.landHeight }); } else { Error::open(StringIds::cant_plant_this_here, StringIds::empty); } if (SceneManager::isEditorMode()) { GameCommands::setUpdatingCompanyId(previousId); } break; } } } static void onToolAbort([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { removeTreeGhost(); } // 0x004BBEC1 static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = (self.var_83C + 8) / 9; if (scrollHeight == 0) { scrollHeight += 1; } scrollHeight *= kRowHeight; } static int getRowIndex(int16_t x, int16_t y) { return (x / kColumnWidth) + (y / kRowHeight) * 9; } // 0x004BBF3B static void scrollMouseDown(Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto index = getRowIndex(x, y); for (auto i = 0; i < self.var_83C; i++) { auto rowInfo = self.rowInfo[i]; index--; if (index < 0) { self.rowHover = rowInfo; getGameState().lastTreeOption = static_cast<uint8_t>(rowInfo); updateTreeColours(self); int32_t pan = (self.width >> 1) + self.x; Audio::playSound(Audio::SoundId::clickDown, pan); self.expandContentCounter = -16; _lastTreeCost = 0x80000000; self.invalidate(); break; } } } // 0x004BBEF8 static void scrollMouseOver(Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto index = getRowIndex(x, y); uint16_t rowInfo = y; auto i = 0; for (; i < self.var_83C; i++) { rowInfo = self.rowInfo[i]; index--; if (index < 0) { self.var_846 = rowInfo; self.invalidate(); break; } } } // 0x004BBB00 static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_trees_list); return args; } // 0x004BB756 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.activatedWidgets &= ~((1ULL << widx::plant_cluster_selected) | (1ULL << widx::plant_cluster_random)); if (_treeClusterType == treeCluster::selected) { self.activatedWidgets |= (1ULL << widx::plant_cluster_selected); } if (_treeClusterType == treeCluster::random) { self.activatedWidgets |= (1ULL << widx::plant_cluster_random); } self.widgets[widx::rotate_object].hidden = true; self.widgets[widx::object_colour].hidden = true; if (self.rowHover != -1) { auto treeObj = ObjectManager::get<TreeObject>(self.rowHover); if (treeObj->name != 0xFFFF) { if (treeObj->numRotations != 1) { self.widgets[widx::rotate_object].hidden = false; } if (treeObj->colours != 0) { self.widgets[widx::object_colour].image = Widget::kImageIdColourSet | Gfx::recolour(ImageIds::colour_swatch_recolourable, _treeColour); self.widgets[widx::object_colour].hidden = false; } } } self.widgets[widx::scrollview].right = self.width - 26; self.widgets[widx::scrollview].bottom = self.height - 14; self.widgets[widx::rotate_object].left = self.width - 25; self.widgets[widx::object_colour].left = self.width - 25; self.widgets[widx::plant_cluster_selected].left = self.width - 25; self.widgets[widx::plant_cluster_random].left = self.width - 25; self.widgets[widx::rotate_object].right = self.width - 2; self.widgets[widx::object_colour].right = self.width - 2; self.widgets[widx::plant_cluster_selected].right = self.width - 2; self.widgets[widx::plant_cluster_random].right = self.width - 2; Widget::leftAlignTabs(self, Common::widx::tab_clear_area, Common::widx::tab_build_walls); } // 0x004BB8C9 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto treeId = self.var_846; if (treeId == 0xFFFF) { treeId = self.rowHover; if (treeId == 0xFFFF) { return; } } auto treeObj = ObjectManager::get<TreeObject>(treeId); uint32_t treeCost = 0x80000000; if (self.var_846 == 0xFFFF) { treeCost = _lastTreeCost; if (treeCost == 0x80000000) { treeCost = Economy::getInflationAdjustedCost(treeObj->buildCostFactor, treeObj->costIndex, 12); } } else { treeCost = Economy::getInflationAdjustedCost(treeObj->buildCostFactor, treeObj->costIndex, 12); } if (!SceneManager::isEditorMode()) { FormatArguments args{}; args.push<uint32_t>(treeCost); auto point = Point(self.x + 3 + self.width - 17, self.y + self.height - 13); tr.drawStringRight(point, Colour::black, StringIds::build_cost, args); } { FormatArguments args{}; args.push(treeObj->name); auto point = Point(self.x + 3, self.y + self.height - 13); auto width = self.width - 19 - point.x; tr.drawStringLeftClipped(point, width, Colour::black, StringIds::black_stringid, args); } } static void drawTreeThumb(const TreeObject* treeObj, Gfx::DrawingContext& drawingCtx) { uint32_t image = treeObj->getTreeGrowthDisplayOffset() * treeObj->numRotations; auto rotation = (treeObj->numRotations - 1) & _treeRotation; image += rotation; image += treeObj->sprites[treeObj->seasonState]; auto colourOptions = treeObj->colours; if (colourOptions != 0) { auto colour = _treeColour; if (!(_lastTreeColourFlag & (1 << 5))) { auto bit = Numerics::bitScanReverse(colourOptions); colour = bit == -1 ? Colour::black : static_cast<Colour>(bit); } image = Gfx::recolour(image, colour); } drawingCtx.drawImage(32, 96, image); } // 0x004BB982 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 3); drawingCtx.clearSingle(shade); uint16_t xPos = 0; uint16_t yPos = 0; for (uint16_t i = 0; i < self.var_83C; i++) { _lastTreeColourFlag = 0xFFFF; if (self.rowInfo[i] != self.rowHover) { if (self.rowInfo[i] == self.var_846) { _lastTreeColourFlag = AdvancedColour::translucentFlag; drawingCtx.drawRectInset(xPos, yPos, 65, kRowHeight - 1, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::colourLight); } } else { _lastTreeColourFlag = AdvancedColour::translucentFlag | AdvancedColour::outlineFlag; drawingCtx.drawRectInset(xPos, yPos, 65, kRowHeight - 1, self.getColour(WindowColour::secondary), (Gfx::RectInsetFlags::colourLight | Gfx::RectInsetFlags::borderInset)); } const auto* treeObj = ObjectManager::get<TreeObject>(self.rowInfo[i]); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(xPos + 1, yPos + 1, 64, kRowHeight - 2)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); drawTreeThumb(treeObj, drawingCtx); drawingCtx.popRenderTarget(); } xPos += kColumnWidth; if (xPos >= kColumnWidth * 9) // full row { xPos = 0; yPos += kRowHeight; } } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = event_08, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x004BB4A3 Window* open() { auto window = WindowManager::bringToFront(WindowType::terraform, 0); if (window != nullptr) { window->callOnMouseUp(Common::widx::tab_plant_trees, window->widgets[Common::widx::tab_plant_trees].id); } else { // 0x004BB586 window = WindowManager::createWindow( WindowType::terraform, { Ui::width() - PlantTrees::kWindowSize.width, 30 }, PlantTrees::kWindowSize, WindowFlags::flag_11, PlantTrees::getEvents()); window->number = 0; window->currentTab = Common::widx::tab_plant_trees - Common::widx::tab_clear_area; window->frameNo = 0; _terraformGhostPlacedFlags = Common::GhostPlacedFlags::none; _lastTreeCost = 0x80000000; window->owner = CompanyManager::getControllingId(); window->var_846 = 0xFFFF; window->expandContentCounter = 0; _treeClusterType = PlantTrees::treeCluster::none; WindowManager::moveOtherWindowsDown(*window); window->minWidth = PlantTrees::kWindowSize.width; window->minHeight = PlantTrees::kWindowSize.height; window->maxWidth = PlantTrees::kWindowSize.width; window->maxHeight = PlantTrees::kWindowSize.height; auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, skin->windowTerraFormColour); // End of 0x004BB586 Ui::Windows::Main::showGridlines(); _treeRotation = 2; window->invalidate(); window->setWidgets(PlantTrees::widgets); window->holdableWidgets = 0; window->activatedWidgets = 0; window->disabledWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); window->var_83C = 0; window->rowHover = -1; PlantTrees::refreshTreeList(*window); ToolManager::toolSet(*window, Common::widx::panel, CursorId::landTool); Input::setFlag(Input::Flags::flag6); } return window; } namespace ClearArea { enum widx { tool_area = 9, decrease_area, increase_area, }; const uint64_t holdableWidgets = (1 << decrease_area) | (1 << increase_area); static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(130, 105, StringIds::clear_area), Widgets::Wt3Widget({ 33 + 16, 45 }, { 64, 44 }, WindowColour::secondary, ImageIds::tool_area, StringIds::tooltip_clear_area), Widgets::ImageButton({ 34 + 16, 46 }, { 16, 16 }, WindowColour::secondary, Gfx::recolour(ImageIds::decrease_tool_area, Colour::white), StringIds::tooltip_decrease_clear_area), Widgets::ImageButton({ 80 + 16, 72 }, { 16, 16 }, WindowColour::secondary, Gfx::recolour(ImageIds::increase_tool_area, Colour::white), StringIds::tooltip_increase_clear_area) ); // 0x004BC671 static void onClose([[maybe_unused]] Window& self) { Ui::Windows::Main::hideGridlines(); } // 0x004BBBC7 static void tabReset(Window& self) { ToolManager::toolSet(self, Common::widx::panel, CursorId::bulldozerTool); Input::setFlag(Input::Flags::flag6); _raiseLandCost = 0x80000000; _adjustToolSize = _clearAreaToolSize; } // 0x004BC7C6 static void onResize(Window& self) { Common::onResize(self, 105); } // 0x004BC65C static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::decrease_area: { _adjustToolSize--; if (_adjustToolSize < 1) { _adjustToolSize = 1; } _clearAreaToolSize = _adjustToolSize; self.invalidate(); break; } case widx::increase_area: { _adjustToolSize++; if (_adjustToolSize > 64) { _adjustToolSize = 64; } _clearAreaToolSize = _adjustToolSize; self.invalidate(); break; } } } // 0x004BC677 static void onToolUpdate([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); uint32_t cost = 0x80000000; auto res = Ui::ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (res) { if (setMapSelectionTiles(res->first, MapSelectionType::full, _adjustToolSize) == 0) { return; } const auto [pointA, pointB] = World::getMapSelectionArea(); const Pos2 centre = (pointA + pointB) / 2; ClearLandArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; cost = GameCommands::doCommand(args, GameCommands::Flags::allowNegativeCashFlow | GameCommands::Flags::ghost); } if (cost != _raiseLandCost) { _raiseLandCost = cost; WindowManager::invalidate(WindowType::terraform); } } static void clearLand(uint8_t flags) { if (World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { auto [pointA, pointB] = World::getMapSelectionArea(); Pos2 centre = (pointA + pointB) / 2; GameCommands::setErrorTitle(StringIds::error_cant_clear_entire_area); ClearLandArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; GameCommands::doCommand(args, flags); } } // 0x004BC689 static void onToolDown([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } clearLand(Flags::apply); } // 0x004BC682 static void toolDrag([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } auto window = WindowManager::find(WindowType::error); if (window == nullptr) { clearLand(Flags::apply); } } // 0x004BC701 static void toolUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { if (widgetIndex == Common::widx::panel) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); } } // 0x004BC555 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.activatedWidgets |= (1ULL << widx::tool_area); if (_adjustToolSize <= 10) { self.widgets[widx::tool_area].image = _adjustToolSize + ImageIds::tool_area; } else { self.widgets[widx::tool_area].image = Widget::kContentNull; } Widget::leftAlignTabs(self, Common::widx::tab_clear_area, Common::widx::tab_build_walls); } // 0x004BC5E7 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto& toolArea = self.widgets[widx::tool_area]; // Draw as a number if we can't fit a sprite if (_adjustToolSize > 10) { auto xPos = toolArea.midX() + self.x; auto yPos = toolArea.midY() + self.y - 5; auto point = Point(xPos, yPos); FormatArguments args{}; args.push<uint16_t>(_adjustToolSize); tr.drawStringCentred(point, Colour::black, StringIds::tile_inspector_coord, args); } if (_raiseLandCost == 0x80000000) { return; } if (_raiseLandCost == 0) { return; } { auto xPos = toolArea.midX() + self.x; auto yPos = toolArea.bottom + self.y + 5; auto point = Point(xPos, yPos); FormatArguments args{}; args.push<uint32_t>(_raiseLandCost); tr.drawStringCentred(point, Colour::black, StringIds::clear_land_cost, args); } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = Common::onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onUpdate = Common::onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .toolDrag = toolDrag, .toolUp = toolUp, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace AdjustLand { enum widx { tool_area = 9, decrease_area, increase_area, mountain_mode, paint_mode, land_material }; const uint64_t holdableWidgets = (1 << decrease_area) | (1 << increase_area); static bool isMountainMode = false; static bool isPaintMode = false; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(130, 105, StringIds::title_adjust_land), Widgets::Wt3Widget({ 49, 45 }, { 64, 44 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_adjust_land_tool), Widgets::ImageButton({ 50, 46 }, { 16, 16 }, WindowColour::secondary, Gfx::recolour(ImageIds::decrease_tool_area, Colour::white), StringIds::tooltip_decrease_adjust_land_area), Widgets::ImageButton({ 96, 72 }, { 16, 16 }, WindowColour::secondary, Gfx::recolour(ImageIds::increase_tool_area, Colour::white), StringIds::tooltip_increase_adjust_land_area), Widgets::ImageButton({ 57, 92 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_slope_up, StringIds::mountainModeTooltip), Widgets::ImageButton({ 83, 92 }, { 24, 24 }, WindowColour::secondary, ImageIds::paintbrush, StringIds::tooltip_paint_landscape_tool), Widgets::ImageButton({ 112, 94 }, { 20, 20 }, WindowColour::primary) ); // 0x004BC9D1 static void onClose([[maybe_unused]] Window& self) { Ui::Windows::Main::hideGridlines(); } // 0x004BBBF7 static void tabReset(Window& self) { if (isPaintMode) { ToolManager::toolSet(self, widx::paint_mode, CursorId::landTool); } else if (isMountainMode) { ToolManager::toolSet(self, widx::mountain_mode, CursorId::landTool); } else { ToolManager::toolSet(self, Common::widx::panel, CursorId::landTool); } Input::setFlag(Input::Flags::flag6); for (auto i = 0; i < 32; i++) { auto landObj = ObjectManager::get<LandObject>(i); if (landObj == nullptr) { continue; } _lastSelectedLand = i; _raiseLandCost = 0x80000000; _lowerLandCost = 0x80000000; _adjustToolSize = _adjustLandToolSize; break; } } // 0x004BCBF8 static void onResize(Window& self) { if (SceneManager::isEditorMode()) { Common::onResize(self, 115); } else { // CHANGE: Resizes window to allow Dropdown and cost string to be drawn separately Common::onResize(self, 140); } } // 0x004BCB47 static void showDropdown(Window* self, WidgetIndex_t widgetIndex) { auto landCount = 0; for (auto i = 0; i < 32; i++) { auto landObj = ObjectManager::get<LandObject>(i); if (landObj != nullptr) { landCount++; } } auto xPos = self->widgets[widgetIndex].left + self->x; auto yPos = self->widgets[widgetIndex].bottom + self->y; auto heightOffset = self->widgets[widgetIndex].height() - 18; auto colour = self->getColour(WindowColour::secondary).translucent(); auto count = Dropdown::getItemsPerRow(landCount); Dropdown::showImage(xPos, yPos, 20, 20, heightOffset, colour, count, landCount); auto landIndex = 0; for (uint16_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::land); i++) { auto landObj = ObjectManager::get<LandObject>(i); if (landObj == nullptr) { continue; } if (i == _lastSelectedLand) { Dropdown::setHighlightedItem(landIndex); } auto args = FormatArguments::common(); args.push(landObj->mapPixelImage + Land::ImageIds::landscape_generator_tile_icon); args.push<uint16_t>(i); Dropdown::add(landIndex, 0xFFFE, args); landIndex++; } } // 0x004BC9A7 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::land_material: { showDropdown(&self, widgetIndex); break; } case widx::decrease_area: { _adjustToolSize--; if (_adjustToolSize < 1) { _adjustToolSize = 1; } _adjustLandToolSize = _adjustToolSize; self.invalidate(); break; } case widx::increase_area: { _adjustToolSize++; if (_adjustToolSize > 64) { _adjustToolSize = 64; } _adjustLandToolSize = _adjustToolSize; self.invalidate(); break; } } } static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_adjust_land: case Common::widx::tab_adjust_water: case Common::widx::tab_build_walls: case Common::widx::tab_clear_area: case Common::widx::tab_plant_trees: Common::switchTab(self, widgetIndex); break; case widx::mountain_mode: { isMountainMode = !isMountainMode; isPaintMode = false; tabReset(self); self.invalidate(); break; } case widx::paint_mode: { isMountainMode = false; isPaintMode = !isPaintMode; tabReset(self); self.invalidate(); break; } } } // 0x004BC9C6 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::land_material) { return; } if (itemIndex == -1) { return; } _lastSelectedLand = Dropdown::getItemArgument(itemIndex, 2); self.invalidate(); } // 0x00468DFD static uint32_t lowerLand(uint8_t flags) { uint32_t cost; if ((flags & 1)) { Common::sub_4A69DD(); } auto [pointA, pointB] = World::getMapSelectionArea(); auto centre = (pointA + pointB) / 2; GameCommands::setErrorTitle(StringIds::error_cant_lower_land_here); if (isMountainMode) { GameCommands::LowerRaiseLandMountainArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; args.adjustment = -1; cost = GameCommands::doCommand(args, flags); } else { GameCommands::LowerLandArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; args.corner = World::getMapSelectionCorner(); cost = GameCommands::doCommand(args, flags); } return cost; } // 0x00468D1D static uint32_t raiseLand(uint8_t flags) { uint32_t cost; if ((flags & 1)) { Common::sub_4A69DD(); } auto [pointA, pointB] = World::getMapSelectionArea(); auto centre = (pointA + pointB) / 2; GameCommands::setErrorTitle(StringIds::error_cant_raise_land_here); if (isMountainMode) { GameCommands::LowerRaiseLandMountainArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; args.adjustment = 1; cost = GameCommands::doCommand(args, flags); } else { GameCommands::RaiseLandArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; args.corner = World::getMapSelectionCorner(); cost = GameCommands::doCommand(args, flags); } return cost; } static void setAdjustCost(uint32_t raiseCost, uint32_t lowerCost) { if (_raiseLandCost == raiseCost) { if (_lowerLandCost == lowerCost) { return; } } _raiseLandCost = raiseCost; _lowerLandCost = lowerCost; WindowManager::invalidate(WindowType::terraform, 0); } static void onPaintToolUpdate([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, const int16_t x, const int16_t y) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); uint32_t cost = 0x80000000; auto res = Ui::ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (res) { if (setMapSelectionTiles(res->first, MapSelectionType::full, _adjustToolSize) == 0) { return; } const auto [pointA, pointB] = World::getMapSelectionArea(); const Pos2 centre = (pointA + pointB) / 2; ClearLandArgs args{}; args.centre = centre; args.pointA = pointA; args.pointB = pointB; cost = GameCommands::doCommand(args, GameCommands::Flags::allowNegativeCashFlow | GameCommands::Flags::ghost); } if (cost != _raiseLandCost) { _raiseLandCost = cost; WindowManager::invalidate(WindowType::terraform); } } static void onAdjustLandToolUpdate([[maybe_unused]] const OpenLoco::Ui::WidgetIndex_t& widgetIndex, const int16_t& x, const int16_t& y) { uint16_t xPos = 0; World::mapInvalidateSelectionRect(); if (ToolManager::getToolCursor() != CursorId::upDownArrow) { World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto res = Ui::ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (res) { if (_adjustLandToolSize == 1 && !(isMountainMode || isPaintMode)) { auto count = setMapSelectionSingleTile(res->first, true); if (!count) { return; } } else { auto count = setMapSelectionTiles(res->first, MapSelectionType::full, _adjustToolSize); if (!count) { return; } } } else { xPos = 0x8000; } } else { if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { return; } } uint32_t raiseCost = 0; uint32_t lowerCost = 0; if (SceneManager::isEditorMode() || xPos == 0x8000) { raiseCost = 0x80000000; lowerCost = 0x80000000; } else { lowerCost = lowerLand(Flags::allowNegativeCashFlow); raiseCost = raiseLand(Flags::allowNegativeCashFlow); } setAdjustCost(raiseCost, lowerCost); } // 0x004BC9D7 static void onToolUpdate(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { switch (widgetIndex) { case widx::paint_mode: onPaintToolUpdate(self, widgetIndex, x, y); break; case widx::mountain_mode: case Common::widx::panel: onAdjustLandToolUpdate(widgetIndex, x, y); break; } } static void paintLand() { // CHANGE: Allows the player to change land type outside of the scenario editor. if (_adjustToolSize != 0) { if (_lastSelectedLand != 0xFF) { GameCommands::setErrorTitle(StringIds::error_cant_change_land_type); auto [pointA, pointB] = World::getMapSelectionArea(); ChangeLandMaterialArgs args{}; args.pointA = pointA; args.pointB = pointB; args.landType = _lastSelectedLand; GameCommands::doCommand(args, Flags::apply); } } } // 0x004BC9ED static void onToolDown([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { switch (widgetIndex) { case widx::paint_mode: paintLand(); break; case widx::mountain_mode: case Common::widx::panel: { if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { return; } ToolManager::setToolCursor(CursorId::upDownArrow); break; } } } // 0x004BC9E2 static void toolDrag([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { switch (widgetIndex) { case widx::paint_mode: { auto window = WindowManager::find(WindowType::error); if (window == nullptr) { paintLand(); } break; } case widx::mountain_mode: case Common::widx::panel: { auto window = WindowManager::findAt(x, y); if (window == nullptr) { break; } WidgetIndex_t newWidgetIndex = window->findWidgetAt(x, y); if (newWidgetIndex == kWidgetIndexNull) { break; } auto widget = window->widgets[newWidgetIndex]; if (widget.type != WidgetType::viewport) { break; } auto viewport = window->viewports[0]; if (viewport == nullptr) { break; } auto zoom = viewport->zoom; auto dY = -(16 >> zoom); if (dY == 0) { dY = -1; } auto deltaY = y - Input::getDragLastLocation().y; auto flags = Flags::apply; if (deltaY <= dY) { Input::setDragLastLocation(Input::getDragLastLocation() + Ui::Point{ 0, dY }); raiseLand(flags); } else { dY = -dY; if (deltaY < dY) { break; } Input::setDragLastLocation(Input::getDragLastLocation() + Ui::Point{ 0, dY }); lowerLand(flags); } _raiseLandCost = 0x80000000; _lowerLandCost = 0x80000000; break; } } } // 0x004BCA5D static void toolUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { switch (widgetIndex) { case widx::mountain_mode: case widx::paint_mode: case Common::widx::panel: { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); ToolManager::setToolCursor(CursorId::landTool); break; } } } // 0x004BC83B static void prepareDraw(Window& self) { Common::prepareDraw(self); self.activatedWidgets |= (1ULL << widx::tool_area); if (isMountainMode) { self.activatedWidgets |= (1 << widx::mountain_mode); } else { self.activatedWidgets &= ~(1 << widx::mountain_mode); } if (isPaintMode) { self.activatedWidgets |= (1 << widx::paint_mode); } else { self.activatedWidgets &= ~(1 << widx::paint_mode); } auto landObj = ObjectManager::get<LandObject>(_lastSelectedLand); auto pixelColour = static_cast<Colour>(Gfx::getG1Element(landObj->mapPixelImage)->offset[0]); self.widgets[widx::paint_mode].image = Gfx::recolour2(ImageIds::paintbrush, Colour::white, pixelColour); if (isPaintMode) { self.widgets[widx::land_material].hidden = false; self.widgets[widx::land_material].image = landObj->mapPixelImage + OpenLoco::Land::ImageIds::landscape_generator_tile_icon; } else { self.widgets[widx::land_material].hidden = true; } Widget::leftAlignTabs(self, Common::widx::tab_clear_area, Common::widx::tab_build_walls); } // 0x004BC909 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto& toolArea = self.widgets[widx::tool_area]; // Draw land tool size as a grid if (_adjustToolSize < 10) { // For mountain mode, we first draw the background grid if (isMountainMode) { auto areaImage = ImageId(ImageIds::tool_area); Ui::Point placeForImage(toolArea.left + self.x, toolArea.top + self.y); if ((_adjustToolSize & 1) == 0) { // For even sizes, we need to draw the image twice // TODO: replace with proper grid images placeForImage -= { 4, 0 }; drawingCtx.drawImage(placeForImage, areaImage); placeForImage += { 8, 0 }; drawingCtx.drawImage(placeForImage, areaImage); } else { // For odd sizes, we just need the one drawingCtx.drawImage(placeForImage, areaImage); } } // Draw tool size if (!isMountainMode || _adjustToolSize > 1) { auto areaImage = ImageId(ImageIds::tool_area).withIndexOffset(_adjustToolSize); Ui::Point placeForImage(toolArea.left + self.x, toolArea.top + self.y); drawingCtx.drawImage(placeForImage, areaImage); } } // Or draw as a number, if we can't fit a sprite else { auto xPos = toolArea.midX() + self.x; auto yPos = toolArea.midY() + self.y - 5; auto point = Point(xPos, yPos); FormatArguments args{}; args.push<uint16_t>(_adjustToolSize); tr.drawStringCentred(point, Colour::black, StringIds::tile_inspector_coord, args); } auto xPos = toolArea.midX() + self.x; auto yPos = toolArea.bottom + self.y + 28; if (_raiseLandCost != 0x80000000) { if (_raiseLandCost != 0) { FormatArguments args{}; args.push<uint32_t>(_raiseLandCost); auto point = Point(xPos, yPos); tr.drawStringCentred(point, Colour::black, StringIds::increase_height_cost, args); } } yPos += 10; if (_lowerLandCost != 0x80000000) { if (_lowerLandCost != 0) { FormatArguments args{}; args.push<uint32_t>(_lowerLandCost); auto point = Point(xPos, yPos); tr.drawStringCentred(point, Colour::black, StringIds::decrease_height_cost, args); } } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .toolDrag = toolDrag, .toolUp = toolUp, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace AdjustWater { enum widx { tool_area = 9, decrease_area, increase_area, }; const uint64_t holdableWidgets = (1 << decrease_area) | (1 << increase_area); static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(130, 105, StringIds::title_adjust_water), Widgets::Wt3Widget({ 33 + 16, 45 }, { 64, 44 }, WindowColour::secondary, ImageIds::tool_area, StringIds::tooltip_adjust_water_tool), Widgets::ImageButton({ 34 + 16, 46 }, { 16, 16 }, WindowColour::secondary, Gfx::recolour(ImageIds::decrease_tool_area, Colour::white), StringIds::tooltip_decrease_adjust_water_area), Widgets::ImageButton({ 80 + 16, 72 }, { 16, 16 }, WindowColour::secondary, Gfx::recolour(ImageIds::increase_tool_area, Colour::white), StringIds::tooltip_increase_adjust_water_area) ); // 0x004BCDAE static void onClose([[maybe_unused]] Window& self) { Ui::Windows::Main::hideGridlines(); } // 0x004BBC46 static void tabReset(Window& self) { ToolManager::toolSet(self, Common::widx::panel, CursorId::waterTool); Input::setFlag(Input::Flags::flag6); _raiseWaterCost = 0x80000000; _lowerWaterCost = 0x80000000; _adjustToolSize = _adjustWaterToolSize; } // 0x004BCEB4 static void onResize(Window& self) { Common::onResize(self, 115); } // 0x004BCD9D static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::decrease_area: { _adjustToolSize--; if (_adjustToolSize < 1) { _adjustToolSize = 1; } _adjustWaterToolSize = _adjustToolSize; self.invalidate(); break; } case widx::increase_area: { _adjustToolSize++; if (_adjustToolSize > 64) { _adjustToolSize = 64; } _adjustWaterToolSize = _adjustToolSize; self.invalidate(); break; } } } static void setAdjustCost(uint32_t raiseCost, uint32_t lowerCost) { if (_raiseWaterCost == raiseCost) { if (_lowerWaterCost == lowerCost) { return; } } _raiseWaterCost = raiseCost; _lowerWaterCost = lowerCost; WindowManager::invalidate(WindowType::terraform); } static uint32_t raiseWater(uint8_t flags); static uint32_t lowerWater(uint8_t flags); // 0x004BCDB4 static void onToolUpdate([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } World::mapInvalidateSelectionRect(); if (ToolManager::getToolCursor() != CursorId::upDownArrow) { World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::surface | ViewportInteraction::InteractionItemFlags::water)); auto& interaction = res.first; if (interaction.type == ViewportInteraction::InteractionItem::noInteraction) { setAdjustCost(0x80000000, 0x80000000); return; } if (!setMapSelectionTiles(interaction.pos + World::Pos2(16, 16), MapSelectionType::fullWater, _adjustToolSize)) { // no change in selection return; } } else { if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { return; } } if (SceneManager::isEditorMode()) { setAdjustCost(0x80000000, 0x80000000); } else { setAdjustCost(raiseWater(0), lowerWater(0)); } } // 0x004BCDCA static void onToolDown([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } if (!World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { return; } ToolManager::setToolCursor(CursorId::upDownArrow); } static uint32_t raiseWater(uint8_t flags) { if (flags & GameCommands::Flags::apply) { Common::sub_4A69DD(); GameCommands::setErrorTitle(StringIds::error_cant_raise_water_here); } auto [pointA, pointB] = World::getMapSelectionArea(); GameCommands::RaiseWaterArgs args{}; args.pointA = pointA; args.pointB = pointB; return GameCommands::doCommand(args, flags); } static uint32_t lowerWater(uint8_t flags) { if (flags & GameCommands::Flags::apply) { Common::sub_4A69DD(); GameCommands::setErrorTitle(StringIds::error_cant_raise_water_here); } auto [pointA, pointB] = World::getMapSelectionArea(); GameCommands::LowerWaterArgs args{}; args.pointA = pointA; args.pointB = pointB; return GameCommands::doCommand(args, flags); } // 0x004BCDBF static void toolDrag([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } auto window = WindowManager::findAt(x, y); if (window == nullptr) { return; } WidgetIndex_t newWidgetIndex = window->findWidgetAt(x, y); if (newWidgetIndex == kWidgetIndexNull) { return; } auto widget = window->widgets[newWidgetIndex]; if (widget.type != WidgetType::viewport) { return; } auto viewport = window->viewports[0]; if (viewport == nullptr) { return; } auto zoom = viewport->zoom; auto dY = -(16 >> zoom); if (dY == 0) { dY = -1; } auto deltaY = y - Input::getDragLastLocation().y; auto flags = Flags::apply; if (deltaY <= dY) { Input::setDragLastLocation(Input::getDragLastLocation() + Ui::Point{ 0, dY }); raiseWater(flags); } else { dY = -dY; if (deltaY < dY) { return; } Input::setDragLastLocation(Input::getDragLastLocation() + Ui::Point{ 0, dY }); lowerWater(flags); } _raiseWaterCost = 0x80000000; _lowerWaterCost = 0x80000000; } // 0x004BCDE8 static void toolUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { if (widgetIndex == Common::widx::panel) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); ToolManager::setToolCursor(CursorId::waterTool); } } // 0x004BCC6D static void prepareDraw(Window& self) { Common::prepareDraw(self); self.activatedWidgets |= (1ULL << widx::tool_area); if (_adjustToolSize <= 10) { self.widgets[widx::tool_area].image = _adjustToolSize + ImageIds::tool_area; } else { self.widgets[widx::tool_area].image = Widget::kContentNull; } Widget::leftAlignTabs(self, Common::widx::tab_clear_area, Common::widx::tab_build_walls); } // 0x004BCCFF static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto& toolArea = self.widgets[widx::tool_area]; // Draw as a number if we can't fit a sprite if (_adjustToolSize > 10) { auto xPos = toolArea.midX() + self.x; auto yPos = toolArea.midY() + self.y - 5; auto point = Point(xPos, yPos); FormatArguments args{}; args.push<uint16_t>(_adjustToolSize); tr.drawStringCentred(point, Colour::black, StringIds::tile_inspector_coord, args); } auto xPos = toolArea.midX() + self.x; auto yPos = toolArea.bottom + self.y + 5; if (_raiseWaterCost != 0x80000000) { if (_raiseWaterCost != 0) { FormatArguments args{}; args.push<uint32_t>(_raiseWaterCost); auto point = Point(xPos, yPos); tr.drawStringCentred(point, Colour::black, StringIds::increase_height_cost, args); } } yPos += 10; if (_lowerWaterCost != 0x80000000) { if (_lowerWaterCost != 0) { FormatArguments args{}; args.push<uint32_t>(_lowerWaterCost); auto point = Point(xPos, yPos); tr.drawStringCentred(point, Colour::black, StringIds::decrease_height_cost, args); } } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = Common::onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onUpdate = Common::onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .toolDrag = toolDrag, .toolUp = toolUp, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace BuildWalls { static constexpr Ui::Size32 kWindowSize = { 418, 108 }; static constexpr uint8_t kRowHeight = 48; enum widx { scrollview = 9, }; const uint64_t holdableWidgets = 0; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(418, 108, StringIds::title_build_walls), Widgets::ScrollView({ 2, 45 }, { 391, 48 }, WindowColour::secondary, Scrollbars::vertical) ); // 0x004BC506 static void updateActiveThumb(Window& self) { int32_t scrollWidth = 0, scrollHeight = 0; self.callGetScrollSize(0, scrollWidth, scrollHeight); self.scrollAreas[0].contentHeight = scrollHeight; auto i = 0; for (; i <= self.var_83C; i++) { if (self.rowInfo[i] == self.rowHover) { break; } } if (i >= self.var_83C) { i = 0; } i = (i / 10) * kRowHeight; self.scrollAreas[0].contentOffsetY = i; Ui::ScrollView::updateThumbs(self, widx::scrollview); } // 0x004BB6D5 static void refreshWallList(Window& self) { auto wallCount = 0; for (uint16_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::wall); i++) { auto wallObj = ObjectManager::get<WallObject>(i); if (wallObj == nullptr) { continue; } self.rowInfo[wallCount] = i; wallCount++; } self.var_83C = wallCount; auto rowHover = -1; if (getGameState().lastWallOption != 0xFF) { for (auto i = 0; i < self.var_83C; i++) { if (getGameState().lastWallOption == self.rowInfo[i]) { rowHover = getGameState().lastWallOption; break; } } } if (rowHover == -1 && self.var_83C != 0) { rowHover = self.rowInfo[0]; } self.rowHover = rowHover; updateActiveThumb(self); } static void removeWallGhost(); // 0x004BC21C static void onClose([[maybe_unused]] Window& self) { removeWallGhost(); Ui::Windows::Main::hideGridlines(); } // 0x004BBCBF static void tabReset(Window& self) { ToolManager::toolSet(self, Common::widx::panel, CursorId::placeFence); Input::setFlag(Input::Flags::flag6); _terraformGhostPlacedFlags = Common::GhostPlacedFlags::none; self.var_83C = 0; self.rowHover = -1; refreshWallList(self); } // 0x004BC44B static void onResize(Window& self) { self.invalidate(); Ui::Size32 kMinWindowSize = { self.minWidth, self.minHeight }; Ui::Size32 kMaxWindowSize = { self.maxWidth, self.maxHeight }; bool hasResized = self.setSize(kMinWindowSize, kMaxWindowSize); if (hasResized) { updateActiveThumb(self); } } // 0x004BC23D static void onUpdate(Window& self) { if (!Input::hasFlag(Input::Flags::toolActive)) { WindowManager::close(&self); } if (ToolManager::getToolWindowType() != WindowType::terraform) { WindowManager::close(&self); } if (!Input::hasFlag(Input::Flags::rightMousePressed)) { auto cursor = Input::getMouseLocation(); auto xPos = cursor.x; auto yPos = cursor.y; Window* activeWindow = WindowManager::findAt(xPos, yPos); if (activeWindow == &self) { xPos -= self.x; xPos += 26; yPos -= self.y; if ((yPos < 42) || (xPos <= self.width)) { xPos = cursor.x; yPos = cursor.y; WidgetIndex_t activeWidget = self.findWidgetAt(xPos, yPos); if (activeWidget > Common::widx::panel) { self.expandContentCounter += 1; if (self.expandContentCounter >= 8) { auto y = std::min(self.scrollAreas[0].contentHeight - 1 + 60, 562); if (Ui::height() < 600) { y = std::min(y, 358); } self.minWidth = kWindowSize.width; self.minHeight = y; self.maxWidth = kWindowSize.width; self.maxHeight = y; } else { if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } } } else { self.expandContentCounter = 0; if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::terraform, self.number, self.currentTab + Common::widx::tab_clear_area); } // 0x004BC377 static void event_08(Window& self) { if (self.var_846 != 0xFFFFU) { self.var_846 = 0xFFFFU; self.invalidate(); } } // 0x004BD297 (bits of) static void removeWallGhost() { if ((_terraformGhostPlacedFlags & Common::GhostPlacedFlags::wall) != Common::GhostPlacedFlags::none) { _terraformGhostPlacedFlags = _terraformGhostPlacedFlags & ~Common::GhostPlacedFlags::wall; GameCommands::WallRemovalArgs args; args.pos = World::Pos3((_terraformGhostPos).x, (_terraformGhostPos).y, _terraformGhostBaseZ * World::kSmallZStep); args.rotation = _terraformGhostRotation; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } } // 0x004BD4C8 static void placeWallGhost(const GameCommands::WallPlacementArgs& placementArgs) { removeWallGhost(); if (GameCommands::doCommand(placementArgs, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost) != GameCommands::FAILURE) { _terraformGhostPos = placementArgs.pos; _terraformGhostRotation = placementArgs.rotation; _terraformGhostTreeElementType = placementArgs.rotation; // Unsure why duplicated not used _terraformGhostType = placementArgs.type; _terraformGhostBaseZ = (*_lastPlacedWall)->baseZ(); _terraformGhostPlacedFlags |= Common::GhostPlacedFlags::wall; } } // 0x004BD48E static std::optional<GameCommands::WallPlacementArgs> getWallPlacementArgsFromCursor(const int16_t x, const int16_t y) { auto* self = WindowManager::find(WindowType::terraform); if (self == nullptr) { return {}; } auto res = ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (!res) { return {}; } if (self->rowHover == -1) { return {}; } GameCommands::WallPlacementArgs args; // 0 for Z value means game command finds first available height args.pos = World::Pos3(res->first.x & 0xFFE0, res->first.y & 0xFFE0, 0); args.type = self->rowHover; args.rotation = World::getSideFromPos(res->first); args.primaryColour = Colour::black; args.secondaryColour = Colour::black; args.tertiaryColour = Colour::black; return { args }; } // 0x004BC227 static void onToolUpdate([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto placementArgs = getWallPlacementArgsFromCursor(x, y); if (!placementArgs) { removeWallGhost(); return; } auto cornerValue = enumValue(MapSelectionType::edge0) + placementArgs->rotation; World::setMapSelectionFlags(World::MapSelectionFlags::enable); World::setMapSelectionCorner(static_cast<MapSelectionType>(cornerValue)); World::setMapSelectionArea(placementArgs->pos, placementArgs->pos); World::mapInvalidateSelectionRect(); if ((_terraformGhostPlacedFlags & Common::GhostPlacedFlags::wall) != Common::GhostPlacedFlags::none) { if (_terraformGhostPos == placementArgs->pos && _terraformGhostRotation == placementArgs->rotation && _terraformGhostType == placementArgs->type) { return; } } removeWallGhost(); _terraformGhostRotation = placementArgs->rotation; placeWallGhost(*placementArgs); } // 0x004BC232 static void onToolDown([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != Common::widx::panel) { return; } removeWallGhost(); auto placementArgs = getWallPlacementArgsFromCursor(x, y); if (placementArgs) { GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } } static void onToolAbort([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { removeWallGhost(); } // 0x004BC359 static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = (self.var_83C + 9) / 10; if (scrollHeight == 0) { scrollHeight += 1; } scrollHeight *= kRowHeight; } static int getRowIndex(int16_t x, int16_t y) { return (x / 40) + (y / kRowHeight) * 10; } // 0x004BC3D3 static void scrollMouseDown(Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto index = getRowIndex(x, y); for (auto i = 0; i < self.var_83C; i++) { auto rowInfo = self.rowInfo[i]; index--; if (index < 0) { self.rowHover = rowInfo; getGameState().lastWallOption = static_cast<uint8_t>(rowInfo); int32_t pan = (self.width >> 1) + self.x; Audio::playSound(Audio::SoundId::clickDown, pan); self.expandContentCounter = -16; self.invalidate(); break; } } } // 0x004BC390 static void scrollMouseOver(Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto index = getRowIndex(x, y); uint16_t rowInfo = 0xFFFF; auto i = 0; for (; i < self.var_83C; i++) { rowInfo = self.rowInfo[i]; index--; if (index < 0) { break; } } if (i >= self.var_83C) { rowInfo = 0xFFFF; } self.var_846 = rowInfo; self.invalidate(); } // 0x004BC212 static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_walls_list); return args; } // 0x004BC029 static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; Widget::leftAlignTabs(self, Common::widx::tab_clear_area, Common::widx::tab_build_walls); } // 0x004BC0C2 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto wallId = self.var_846; if (wallId == 0xFFFF) { wallId = self.rowHover; if (wallId == 0xFFFF) { return; } } auto wallObj = ObjectManager::get<WallObject>(wallId); auto xPos = self.x + 3; auto yPos = self.y + self.height - 13; auto width = self.width - 19; auto point = Point(xPos, yPos); FormatArguments args{}; args.push(wallObj->name); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::black_stringid, args); } // 0x004BC11C static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 3); drawingCtx.clearSingle(shade); uint16_t xPos = 0; uint16_t yPos = 0; for (uint16_t i = 0; i < self.var_83C; i++) { if (self.rowInfo[i] != self.rowHover) { if (self.rowInfo[i] == self.var_846) { drawingCtx.drawRectInset(xPos, yPos, 40, kRowHeight, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::colourLight); } } else { drawingCtx.drawRectInset(xPos, yPos, 40, kRowHeight, self.getColour(WindowColour::secondary), (Gfx::RectInsetFlags::colourLight | Gfx::RectInsetFlags::borderInset)); } auto wallObj = ObjectManager::get<WallObject>(self.rowInfo[i]); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(xPos + 1, yPos + 1, 39, 47)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); drawingCtx.drawImage(34, 28, wallObj->sprite); drawingCtx.popRenderTarget(); } xPos += 40; if (xPos >= 40 * 10) // full row { xPos = 0; yPos += kRowHeight; } } } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = Common::onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .event_08 = event_08, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; const uint64_t holdableWidgets; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { ClearArea::widgets, widx::tab_clear_area, ClearArea::getEvents(), ClearArea::holdableWidgets }, { AdjustLand::widgets, widx::tab_adjust_land, AdjustLand::getEvents(), AdjustLand::holdableWidgets }, { AdjustWater::widgets, widx::tab_adjust_water, AdjustWater::getEvents(), AdjustWater::holdableWidgets }, { PlantTrees::widgets, widx::tab_plant_trees, PlantTrees::getEvents(), PlantTrees::holdableWidgets }, { BuildWalls::widgets, widx::tab_build_walls, BuildWalls::getEvents(), BuildWalls::holdableWidgets }, }; // clang-format on static void onResize(Window& self, uint8_t height) { self.flags |= WindowFlags::resizable; /*auto width = 130; if (isEditorMode()) width += 31;*/ // CHANGE: width set to 161 to include building walls tab uint16_t width = 161; Ui::Size32 kWindowSize = { width, height }; self.setSize(kWindowSize, kWindowSize); } // 0x004BC78A, 0x004BCB0B static void onUpdate(Window& self) { if (!Input::hasFlag(Input::Flags::toolActive)) { WindowManager::close(&self); } if (ToolManager::getToolWindowType() != WindowType::terraform) { WindowManager::close(&self); } self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::terraform, self.number, self.currentTab + Common::widx::tab_clear_area); } // 0x004BCD82 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_adjust_land: case Common::widx::tab_adjust_water: case Common::widx::tab_build_walls: case Common::widx::tab_clear_area: case Common::widx::tab_plant_trees: Common::switchTab(self, widgetIndex); break; } } static void prepareDraw(Window& self) { // Activate the current tab.. self.activatedWidgets &= ~((1ULL << tab_adjust_land) | (1ULL << tab_adjust_water) | (1ULL << tab_build_walls) | (1ULL << tab_clear_area) | (1ULL << tab_plant_trees)); self.activatedWidgets |= (1ULL << tabInformationByTabOffset[self.currentTab].widgetIndex); self.widgets[widx::frame].right = self.width - 1; self.widgets[widx::frame].bottom = self.height - 1; self.widgets[widx::panel].right = self.width - 1; self.widgets[widx::panel].bottom = self.height - 1; self.widgets[widx::caption].right = self.width - 2; self.widgets[widx::close_button].left = self.width - 15; self.widgets[widx::close_button].right = self.width - 3; } // 0x004BCF7F void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Clear Land Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_bulldozer; Widget::drawTab(self, drawingCtx, imageId, widx::tab_clear_area); } // Adjust Land Tab { auto landObj = ObjectManager::get<LandObject>(getGameState().lastLandOption); uint32_t imageId = landObj->mapPixelImage + Land::ImageIds::toolbar_terraform_land; Widget::drawTab(self, drawingCtx, imageId, widx::tab_adjust_land); } // Adjust Water Tab { auto waterObj = ObjectManager::get<WaterObject>(); uint32_t imageId = waterObj->image + Water::ImageIds::kToolbarTerraformWater; if (self.currentTab == widx::tab_adjust_water - widx::tab_clear_area) { imageId += (self.frameNo / 2) % 16; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_adjust_water); } // Plant Trees Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_plant_trees; Widget::drawTab(self, drawingCtx, imageId, widx::tab_plant_trees); } // Build Walls Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_build_walls; Widget::drawTab(self, drawingCtx, imageId, widx::tab_build_walls); } } // 0x004BBB2B static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_clear_area; self.frameNo = 0; self.viewportRemove(0); const auto& tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_clear_area]; self.holdableWidgets = tabInfo.holdableWidgets; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); auto disabledWidgets = 0; // CHANGE: Disabled so the build walls tab shows outside of editor mode /*if (!isEditorMode() && !isSandboxMode()) disabledWidgets |= common::widx::tab_build_walls;*/ self.disabledWidgets = disabledWidgets; self.invalidate(); switch (widgetIndex) { case Common::widx::tab_adjust_land: AdjustLand::tabReset(self); break; case Common::widx::tab_adjust_water: AdjustWater::tabReset(self); break; case Common::widx::tab_build_walls: BuildWalls::tabReset(self); break; case Common::widx::tab_clear_area: ClearArea::tabReset(self); break; case Common::widx::tab_plant_trees: PlantTrees::tabReset(self); break; } self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x004A69DD static void sub_4A69DD() { auto* window = WindowManager::find(WindowType::construction); if (window != nullptr) { Ui::Windows::Construction::removeConstructionGhosts(); } } } // 0x004BB566 void openClearArea() { auto terraformWindow = open(); terraformWindow->callOnMouseUp(Common::widx::tab_clear_area, terraformWindow->widgets[Common::widx::tab_clear_area].id); } // 0x004BB546 void openAdjustLand() { auto terraformWindow = open(); terraformWindow->callOnMouseUp(Common::widx::tab_adjust_land, terraformWindow->widgets[Common::widx::tab_adjust_land].id); } // 0x004BB556 void openAdjustWater() { auto terraformWindow = open(); terraformWindow->callOnMouseUp(Common::widx::tab_adjust_water, terraformWindow->widgets[Common::widx::tab_adjust_water].id); } // 0x004BB4A3 void openPlantTrees() { auto terraformWindow = open(); terraformWindow->callOnMouseUp(Common::widx::tab_plant_trees, terraformWindow->widgets[Common::widx::tab_plant_trees].id); } // 0x004BB576 void openBuildWalls() { auto terraformWindow = open(); terraformWindow->callOnMouseUp(Common::widx::tab_build_walls, terraformWindow->widgets[Common::widx::tab_build_walls].id); } bool rotate(Window& self) { if (self.currentTab == Common::widx::tab_plant_trees - Common::widx::tab_clear_area) { if (!self.isDisabled(PlantTrees::widx::rotate_object)) { if (!self.widgets[PlantTrees::widx::rotate_object].hidden) { self.callOnMouseUp(PlantTrees::widx::rotate_object, self.widgets[PlantTrees::widx::rotate_object].id); return true; } } } return false; } void setAdjustLandToolSize(uint8_t size) { _adjustLandToolSize = size; } void setAdjustWaterToolSize(uint8_t size) { _adjustWaterToolSize = size; } void setClearAreaToolSize(uint8_t size) { _clearAreaToolSize = size; } void setLastPlacedTree(World::TreeElement* elTree) { _lastPlacedTree = elTree; } // 0x004BAEC4 void resetLastSelections() { _treeRotation = 2; auto& gameState = getGameState(); gameState.lastTreeOption = 0xFF; gameState.lastWallOption = 0xFF; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TextInputWindow.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui/TextInput.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/TextBoxWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <SDL2/SDL.h> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::TextInput { static int16_t _callingWidget; static WindowNumber_t _callingWindowNumber; static WindowType _callingWindowType; static char _formatArgs[16]; static StringId _title; static StringId _message; static Ui::TextInput::InputSession inputSession; static loco_global<char[16], 0x0112C826> _commonFormatArgs; namespace Widx { enum { frame, title, close, panel, input, ok, }; } static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 330, 90 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 328, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary), Widgets::ImageButton({ 315, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { 330, 75 }, WindowColour::secondary), Widgets::TextBox({ 4, 58 }, { 322, 14 }, WindowColour::secondary), Widgets::Button({ 256, 74 }, { 70, 12 }, WindowColour::secondary, StringIds::label_button_ok) ); static const WindowEventList& getEvents(); /** * 0x004CE523 * * @param caller @<esi> * @param title @<ax> * @param message @<bx> * @param value @<cx> * @param callingWidget @<dx> */ void openTextInput(Ui::Window* caller, StringId title, StringId message, StringId value, int callingWidget, const void* valueArgs, uint32_t inputSize) { _title = title; _message = message; _callingWindowType = caller->type; _callingWindowNumber = caller->number; _callingWidget = callingWidget; // Close any previous text input window cancel(); auto window = WindowManager::createWindowCentred( WindowType::textInput, { 330, 90 }, WindowFlags::stickToFront | WindowFlags::flag_12, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); memcpy(_formatArgs, _commonFormatArgs, 16); // FIXME: Make valueArgs a view. auto args = FormatArguments{ const_cast<std::byte*>(static_cast<const std::byte*>(valueArgs)), 16 }; char temp[200] = {}; StringManager::formatString(temp, value, args); inputSession = Ui::TextInput::InputSession(temp, inputSize); inputSession.calculateTextOffset(_widgets[Widx::input].width() - 2); caller = WindowManager::find(_callingWindowType, _callingWindowNumber); window->setColour(WindowColour::primary, caller->getColour(WindowColour::primary)); window->setColour(WindowColour::secondary, caller->getColour(WindowColour::secondary)); window->owner = caller->owner; if (caller->type == WindowType::titleMenu) { const InterfaceSkinObject* interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, interface->windowTitlebarColour); window->setColour(WindowColour::secondary, interface->windowColour); window->owner = CompanyId::null; } if (caller->type == WindowType::timeToolbar) { const InterfaceSkinObject* interface = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, interface->windowPlayerColor); window->owner = CompanyManager::getControllingId(); } // TODO: Get the correct type and provide getter/setter. window->widgets[Widx::title].styleData = enumValue(Widgets::Caption::Style::whiteText); if (window->owner != CompanyId::null) { window->flags |= WindowFlags::flag_11; window->widgets[Widx::title].styleData = enumValue(Widgets::Caption::Style::colourText); } // Focus the textbox element Input::setFocus(window->type, window->number, Widx::input); } /** * 0x004CE6C9 * * @param type @<cl> * @param number @<dx> */ void sub_4CE6C9(WindowType type, WindowNumber_t number) { auto window = WindowManager::find(WindowType::textInput, 0); if (window == nullptr) { return; } if (_callingWindowNumber == number && _callingWindowType == type) { cancel(); } } /** * 0x004CE6F2 */ void cancel() { WindowManager::close(WindowType::textInput); } /** * 0x004CE6FF */ void sub_4CE6FF() { auto window = WindowManager::find(WindowType::textInput); if (window == nullptr) { return; } window = WindowManager::find(_callingWindowType, _callingWindowNumber); if (window == nullptr) { cancel(); } } /** * 0x004CE726 * * @param window @<esi> */ static void prepareDraw(Ui::Window& window) { window.widgets[Widx::title].text = _title; memcpy(window.widgets[Widx::title].textArgs.data(), _formatArgs, 16); } /** * 0x004CE75B * * @param window @<esi> * @param context @<edi> */ static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); window.draw(drawingCtx); // FIXME: This is pretty horrible. *((StringId*)(&_commonFormatArgs[0])) = _message; memcpy(&_commonFormatArgs[2], _formatArgs + 8, 8); Ui::Point position = Point(window.x + window.width / 2, window.y + 30); tr.drawStringCentredWrapped(position, window.width - 8, Colour::black, StringIds::wcolour2_stringid, FormatArguments::common()); auto widget = &_widgets[Widx::input]; auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(widget->left + 1 + window.x, widget->top + 1 + window.y, widget->width() - 2, widget->height() - 2)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); char* drawnBuffer = (char*)StringManager::getString(StringIds::buffer_2039); strcpy(drawnBuffer, inputSession.buffer.c_str()); { FormatArguments args{}; args.push(StringIds::buffer_2039); position = { inputSession.xOffset, 1 }; tr.drawStringLeft(position, Colour::black, StringIds::black_stringid, args); } const uint16_t numCharacters = static_cast<uint16_t>(inputSession.cursorPosition); const uint16_t maxNumCharacters = inputSession.inputLenLimit; { FormatArguments args{}; args.push<uint16_t>(numCharacters); args.push<uint16_t>(maxNumCharacters); widget = &_widgets[Widx::ok]; auto point = Point(window.x + widget->left - 5, window.y + widget->top + 1); tr.drawStringRight(point, Colour::black, StringIds::num_characters_left_int_int, args); } if ((inputSession.cursorFrame % 32) < 16) { strncpy(drawnBuffer, inputSession.buffer.c_str(), inputSession.cursorPosition); drawnBuffer[inputSession.cursorPosition] = '\0'; if (Input::isFocused(window.type, window.number, Widx::input)) { auto width = tr.getStringWidth(drawnBuffer); auto cursorPos = Point(inputSession.xOffset + width, 1); drawingCtx.fillRect(cursorPos.x, cursorPos.y, cursorPos.x, cursorPos.y + 9, Colours::getShade(window.getColour(WindowColour::secondary).c(), 9), Gfx::RectFlags::none); } } drawingCtx.popRenderTarget(); } // 0x004CE8B6 static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::close: WindowManager::close(&window); break; case Widx::ok: inputSession.sanitizeInput(); auto caller = WindowManager::find(_callingWindowType, _callingWindowNumber); if (caller != nullptr) { caller->callTextInput(_callingWidget, caller->widgets[_callingWidget].id, inputSession.buffer.c_str()); } WindowManager::close(&window); break; } } // 0x004CE8FA static void onUpdate(Ui::Window& window) { inputSession.cursorFrame++; if ((inputSession.cursorFrame % 16) == 0) { window.invalidate(); } } // 0x004CE910 static bool keyUp(Window& w, uint32_t charCode, uint32_t keyCode) { if (charCode == SDLK_RETURN) { w.callOnMouseUp(Widx::ok, w.widgets[Widx::ok].id); return true; } else if (charCode == SDLK_ESCAPE) { w.callOnMouseUp(Widx::close, w.widgets[Widx::close].id); return true; } else if (!Input::isFocused(w.type, w.number, Widx::input) || !inputSession.handleInput(charCode, keyCode)) { return false; } WindowManager::invalidate(WindowType::textInput, 0); inputSession.cursorFrame = 0; int containerWidth = _widgets[Widx::input].width() - 2; if (inputSession.needsReoffsetting(containerWidth)) { inputSession.calculateTextOffset(containerWidth); } return true; } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onUpdate = onUpdate, .prepareDraw = prepareDraw, .draw = draw, .keyUp = keyUp, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TileInspector.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Map/WallElement.h" #include "Objects/AirportObject.h" #include "Objects/BuildingObject.h" #include "Objects/DockObject.h" #include "Objects/IndustryObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainSignalObject.h" #include "Objects/TrainStationObject.h" #include "Objects/TreeObject.h" #include "Objects/WallObject.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/GroupBoxWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/StepperWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/Station.h" #include <map> using namespace OpenLoco::World; namespace OpenLoco::Ui::Windows::TileInspector { static TilePos2 _currentPosition{}; static constexpr Ui::Size32 kWindowSize = { 350, 200 }; namespace widx { enum { frame, title, close, panel, xPos, xPosDecrease, xPosIncrease, yPos, yPosDecrease, yPosIncrease, select, nameTypeHeader, baseHeightHeader, clearHeightHeader, directionHeader, ghostHeader, scrollview, detailsGroup, }; } static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, kWindowSize, WindowColour::primary), Widgets::Caption({ 1, 1 }, { kWindowSize.width - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, StringIds::tile_inspector), Widgets::ImageButton({ kWindowSize.width - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 15 }, { kWindowSize.width, kWindowSize.height - 15 }, WindowColour::secondary), Widgets::stepperWidgets({ 19, 24 }, { 55, 12 }, WindowColour::secondary), Widgets::stepperWidgets({ 92, 24 }, { 55, 12 }, WindowColour::secondary), Widgets::ImageButton({ kWindowSize.width - 26, 18 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_new_position, StringIds::tile_inspector_select_btn_tooltip), Widgets::TableHeader({ 4, 46 }, { kWindowSize.width - 98, 12 }, WindowColour::secondary, StringIds::tileInspectorHeaderNameType, StringIds::tileInspectorHeaderNameTypeTip), // name Widgets::TableHeader({ kWindowSize.width - 109, 46 }, { 30, 12 }, WindowColour::secondary, StringIds::tileInspectorHeaderBaseHeight, StringIds::tileInspectorHeaderBaseHeightTip), Widgets::TableHeader({ kWindowSize.width - 79, 46 }, { 30, 12 }, WindowColour::secondary, StringIds::tileInspectorHeaderClearHeight, StringIds::tileInspectorHeaderClearHeightTip), Widgets::TableHeader({ kWindowSize.width - 49, 46 }, { 15, 12 }, WindowColour::secondary, StringIds::tileInspectorHeaderDirection, StringIds::tileInspectorHeaderDirectionTip), Widgets::TableHeader({ kWindowSize.width - 34, 46 }, { 30, 12 }, WindowColour::secondary, StringIds::tileInspectorHeaderGhost, StringIds::tileInspectorHeaderGhostTip), Widgets::ScrollView({ 4, 60 }, { kWindowSize.width - 8, 103 }, WindowColour::secondary, Ui::Scrollbars::vertical), Widgets::GroupBox({ 4, 165 }, { kWindowSize.width - 8, 30 }, WindowColour::secondary, StringIds::tile_element_data) ); static void activateMapSelectionTool(const Window& self) { ToolManager::toolSet(self, widx::panel, CursorId::crosshair); Input::setFlag(Input::Flags::flag6); } static const WindowEventList& getEvents(); Window* open() { auto window = WindowManager::bringToFront(WindowType::tileInspector); if (window != nullptr) { return window; } window = WindowManager::createWindow( WindowType::tileInspector, kWindowSize, WindowFlags::none, getEvents()); window->setWidgets(_widgets); window->rowCount = 0; window->rowHeight = 10; window->selectedTileIndex = -1; window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); activateMapSelectionTool(*window); return window; } static void prepareDraw(Window& self) { if (ToolManager::isToolActive(WindowType::tileInspector)) { self.activatedWidgets |= (1 << widx::select); } else { self.activatedWidgets &= ~(1 << widx::select); } } static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); // Draw widgets. self.draw(drawingCtx); // Coord X/Y labels { FormatArguments args{}; args.push(StringIds::tile_inspector_x_coord); auto& widget = self.widgets[widx::xPos]; auto point = Point(self.x + widget.left - 15, self.y + widget.top + 1); tr.drawStringLeft(point, Colour::black, StringIds::wcolour2_stringid, args); } { FormatArguments args{}; args.push(StringIds::tile_inspector_y_coord); auto& widget = self.widgets[widx::yPos]; auto point = Point(self.x + widget.left - 15, self.y + widget.top + 1); tr.drawStringLeft(point, Colour::black, StringIds::wcolour2_stringid, args); } // Coord X/Y values { FormatArguments args{}; args.push<int16_t>(_currentPosition.x); auto& widget = self.widgets[widx::xPos]; auto point = Point(self.x + widget.left + 2, self.y + widget.top + 1); tr.drawStringLeft(point, Colour::black, StringIds::tile_inspector_coord, args); } { FormatArguments args{}; args.push<int16_t>(_currentPosition.y); auto& widget = self.widgets[widx::yPos]; auto point = Point(self.x + widget.left + 2, self.y + widget.top + 1); tr.drawStringLeft(point, Colour::black, StringIds::tile_inspector_coord, args); } // Selected element details if (self.selectedTileIndex != -1) { auto tile = TileManager::get(_currentPosition)[self.selectedTileIndex]; const auto data = tile->rawData(); char buffer[32]{}; buffer[0] = ControlCodes::windowColour2; snprintf(&buffer[1], std::size(buffer) - 1, "Data: %02x %02x %02x %02x %02x %02x %02x %02x", data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]); auto widget = self.widgets[widx::detailsGroup]; auto point = Point(self.x + widget.left + 7, self.y + widget.top + 14); tr.drawString(point, Colour::black, buffer); } } static StringId getElementTypeName(const TileElement& element) { static const std::map<ElementType, StringId> typeToString = { { ElementType::surface, StringIds::tile_inspector_element_type_surface }, { ElementType::track, StringIds::tile_inspector_element_type_track }, { ElementType::station, StringIds::tile_inspector_element_type_station }, { ElementType::signal, StringIds::tile_inspector_element_type_signal }, { ElementType::building, StringIds::tile_inspector_element_type_building }, { ElementType::tree, StringIds::tile_inspector_element_type_tree }, { ElementType::wall, StringIds::tile_inspector_element_type_wall }, { ElementType::road, StringIds::tile_inspector_element_type_road }, { ElementType::industry, StringIds::tile_inspector_element_type_industry }, }; return typeToString.at(element.type()); } static StringId getObjectName(const TileElement& element) { switch (element.type()) { case ElementType::surface: { auto& surface = element.get<SurfaceElement>(); auto terrainId = surface.terrain(); auto object = ObjectManager::get<LandObject>(terrainId); return object->name; } case ElementType::track: { auto& track = element.get<TrackElement>(); auto objectId = track.trackObjectId(); auto object = ObjectManager::get<TrackObject>(objectId); return object->name; } case ElementType::station: { auto& station = element.get<StationElement>(); auto objectId = station.objectId(); auto stationType = station.stationType(); switch (stationType) { case StationType::trainStation: return ObjectManager::get<TrainStationObject>(objectId)->name; case StationType::roadStation: return ObjectManager::get<RoadStationObject>(objectId)->name; case StationType::airport: return ObjectManager::get<AirportObject>(objectId)->name; case StationType::docks: return ObjectManager::get<DockObject>(objectId)->name; } break; } case ElementType::signal: { auto& signal = element.get<SignalElement>(); const TrainSignalObject* object = nullptr; if (signal.getLeft().hasSignal()) { object = ObjectManager::get<TrainSignalObject>(signal.getLeft().signalObjectId()); } else if (signal.getRight().hasSignal()) { object = ObjectManager::get<TrainSignalObject>(signal.getRight().signalObjectId()); } if (object != nullptr) { return object->name; } break; } case ElementType::building: { auto& building = element.get<BuildingElement>(); auto objectId = building.objectId(); auto object = ObjectManager::get<BuildingObject>(objectId); return object->name; } case ElementType::tree: { auto& tree = element.get<TreeElement>(); auto objectId = tree.treeObjectId(); auto object = ObjectManager::get<TreeObject>(objectId); return object->name; } case ElementType::wall: { auto wall = element.get<WallElement>(); auto objectId = wall.wallObjectId(); auto object = ObjectManager::get<WallObject>(objectId); return object->name; } case ElementType::road: { auto& road = element.get<RoadElement>(); auto objectId = road.roadObjectId(); auto object = ObjectManager::get<RoadObject>(objectId); return object->name; } case ElementType::industry: { auto& industry = element.get<IndustryElement>(); auto object = ObjectManager::get<IndustryObject>(industry.industry()->objectId); return object->name; } } return StringIds::empty; } static StringId getOwnerName(const TileElement& element) { if (element.type() == ElementType::road) { auto& road = element.get<RoadElement>(); auto ownerId = road.owner(); if (ownerId != CompanyId::neutral) { auto company = CompanyManager::get(ownerId); return company->name; } } else if (element.type() == ElementType::track) { auto& track = element.get<TrackElement>(); auto ownerId = track.owner(); if (ownerId != CompanyId::neutral) { auto company = CompanyManager::get(ownerId); return company->name; } } return StringIds::empty; } static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, const uint32_t) { if (_currentPosition == TilePos2(0, 0)) { return; } const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto tile = TileManager::get(_currentPosition); auto yPos = 0; auto rowNum = 0; for (auto& element : tile) { if (yPos + self.rowHeight < rt.y) { yPos += self.rowHeight; continue; } else if (yPos > rt.y + rt.height) { break; } StringId formatString; if (self.selectedTileIndex == rowNum) { drawingCtx.fillRect(0, yPos, self.width, yPos + self.rowHeight, PaletteIndex::black0, Gfx::RectFlags::none); formatString = StringIds::white_stringid; } else if (self.rowHover == rowNum) { drawingCtx.fillRect(0, yPos, self.width, yPos + self.rowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); formatString = StringIds::wcolour2_stringid; } else { formatString = StringIds::wcolour2_stringid; } FormatArguments args = {}; StringId elementName = getElementTypeName(element); StringId objectName = getObjectName(element); StringId ownerName = getOwnerName(element); if (ownerName != StringIds::empty) { args.push(StringIds::tile_inspector_entry_three_pos); args.push(objectName); args.push(ownerName); args.push(StringIds::empty); args.push(elementName); } else { args.push(StringIds::tile_inspector_entry_two_pos); args.push(objectName); args.push(elementName); } // Draw name and type auto* widget = &self.widgets[widx::nameTypeHeader]; auto point = Point(0, yPos); tr.drawStringLeftClipped(point, widget->width(), Colour::black, formatString, args); // Draw base height widget = &self.widgets[widx::baseHeightHeader]; args.rewind(); args.push(StringIds::uint16_raw); args.push<uint16_t>(element.baseZ()); point = Point(widget->left - 4, yPos); tr.drawStringLeftClipped(point, widget->width(), Colour::black, formatString, args); // Draw clear height widget = &self.widgets[widx::clearHeightHeader]; args.rewind(); args.push(StringIds::uint16_raw); args.push<uint16_t>(element.clearZ()); point = Point(widget->left - 4, yPos); tr.drawStringLeftClipped(point, widget->width(), Colour::black, formatString, args); // Draw direction widget = &self.widgets[widx::directionHeader]; args.rewind(); args.push(StringIds::uint16_raw); args.push<uint16_t>(element.data()[0] & 0x03); point = Point(widget->left - 4, yPos); tr.drawStringLeftClipped(point, widget->width(), Colour::black, formatString, args); // Draw ghost flag widget = &self.widgets[widx::ghostHeader]; if (element.isGhost()) { static constexpr char strCheckmark[] = "\xAC"; point = Point(widget->left - 4, yPos); tr.drawString(point, Colour::white, strCheckmark); } rowNum++; yPos += self.rowHeight; } } static void scrollMouseDown(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { auto index = y / self.rowHeight; if (index >= self.rowCount) { return; } if (self.selectedTileIndex != index) { self.selectedTileIndex = index; self.invalidate(); return; } } static void scrollMouseOver(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { auto index = y / self.rowHeight; if (index >= self.rowCount) { return; } if (self.rowHover != index) { self.rowHover = index; self.invalidate(); } } static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::close: WindowManager::close(self.type); break; case widx::select: activateMapSelectionTool(self); break; } } static void onMouseDown(Ui::Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::xPosDecrease: _currentPosition.x = std::clamp<coord_t>(_currentPosition.x - 1, 1, World::kMapColumns); self.invalidate(); break; case widx::xPosIncrease: _currentPosition.x = std::clamp<coord_t>(_currentPosition.x + 1, 1, World::kMapColumns); self.invalidate(); break; case widx::yPosDecrease: _currentPosition.y = std::clamp<coord_t>(_currentPosition.y - 1, 1, World::kMapRows); self.invalidate(); break; case widx::yPosIncrease: _currentPosition.y = std::clamp<coord_t>(_currentPosition.y + 1, 1, World::kMapRows); self.invalidate(); break; } } static void getScrollSize(Ui::Window& self, uint32_t, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { if (_currentPosition == TilePos2(0, 0)) { scrollHeight = 0; return; } scrollHeight = self.rowCount * self.rowHeight; } static void onToolUpdate([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::panel) { return; } World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto res = Ui::ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (res) { World::setMapSelectionSingleTile(res->first); } } static void onToolDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::panel || !World::hasMapSelectionFlag(World::MapSelectionFlags::enable)) { return; } auto res = Ui::ViewportInteraction::getSurfaceLocFromUi({ x, y }); if (!res) { return; } _currentPosition = World::toTileSpace(res->first); auto tile = TileManager::get(_currentPosition); self.rowCount = static_cast<uint16_t>(tile.size()); self.rowHover = -1; self.selectedTileIndex = 0; self.invalidate(); } static void onClose([[maybe_unused]] Window& self) { ToolManager::toolCancel(); } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TimePanel.cpp ```cpp #include "Date.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/SetGameSpeed.h" #include "GameCommands/General/TogglePause.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Intro.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Network/Network.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Scenario.h" #include "ScenarioObjective.h" #include "SceneManager.h" #include "Ui.h" #include "Ui/Dropdown.h" #include "Ui/ToolTip.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" namespace OpenLoco::Ui::Windows::TimePanel { static constexpr Ui::Size32 kWindowSize = { 140, 27 }; // When paused, the time panel will alternate between displaying "* paused *" and the in-game date every this many ticks. static constexpr auto kPausedStatusTextDuration = 30; namespace Widx { enum { outer_frame, inner_frame, map_chat_menu, date_btn, pause_btn, normal_speed_btn, fast_forward_btn, extra_fast_forward_btn, }; } static void formatChallenge(FormatArguments& args); static void sendChatMessage(const char* str); static constexpr auto _widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 140, 29 }, WindowColour::primary), Widgets::Wt3Widget({ 2, 2 }, { 136, 25 }, WindowColour::primary), Widgets::ImageButton({ 113, 1 }, { 26, 26 }, WindowColour::primary), Widgets::ImageButton({ 2, 2 }, { 111, 12 }, WindowColour::primary, Widget::kContentNull, StringIds::tooltip_daymonthyear_challenge), Widgets::ImageButton({ 18, 15 }, { 20, 12 }, WindowColour::primary, ImageIds::speed_pause, StringIds::tooltip_speed_pause), Widgets::ImageButton({ 38, 15 }, { 20, 12 }, WindowColour::primary, ImageIds::speed_normal, StringIds::tooltip_speed_normal), Widgets::ImageButton({ 58, 15 }, { 20, 12 }, WindowColour::primary, ImageIds::speed_fast_forward, StringIds::tooltip_speed_fast_forward), Widgets::ImageButton({ 78, 15 }, { 20, 12 }, WindowColour::primary, ImageIds::speed_extra_fast_forward, StringIds::tooltip_speed_extra_fast_forward)); static bool redrawScheduled = false; // 0x0050A004 (2nd bit) static const WindowEventList& getEvents(); Window* open() { auto window = WindowManager::createWindow( WindowType::timeToolbar, { Ui::width() - kWindowSize.width, Ui::height() - kWindowSize.height }, { kWindowSize.width, kWindowSize.height }, Ui::WindowFlags::stickToFront | Ui::WindowFlags::transparent | Ui::WindowFlags::noBackground, getEvents()); window->setWidgets(_widgets); window->var_854 = 0; window->numTicksVisible = 0; window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, AdvancedColour(skin->timeToolbarColour).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(skin->timeToolbarColour).translucent()); } return window; } // 0x004396A4 static void prepareDraw([[maybe_unused]] Window& window) { window.widgets[Widx::inner_frame].hidden = true; window.widgets[Widx::pause_btn].image = Gfx::recolour(ImageIds::speed_pause); window.widgets[Widx::normal_speed_btn].image = Gfx::recolour(ImageIds::speed_normal); window.widgets[Widx::fast_forward_btn].image = Gfx::recolour(ImageIds::speed_fast_forward); window.widgets[Widx::extra_fast_forward_btn].image = Gfx::recolour(ImageIds::speed_extra_fast_forward); if (SceneManager::isPaused()) { window.widgets[Widx::pause_btn].image = Gfx::recolour(ImageIds::speed_pause_active); } else if (SceneManager::getGameSpeed() == GameSpeed::Normal) { window.widgets[Widx::normal_speed_btn].image = Gfx::recolour(ImageIds::speed_normal_active); } else if (SceneManager::getGameSpeed() == GameSpeed::FastForward) { window.widgets[Widx::fast_forward_btn].image = Gfx::recolour(ImageIds::speed_fast_forward_active); } else if (SceneManager::getGameSpeed() == GameSpeed::ExtraFastForward) { window.widgets[Widx::extra_fast_forward_btn].image = Gfx::recolour(ImageIds::speed_extra_fast_forward_active); } if (SceneManager::isNetworked()) { window.widgets[Widx::fast_forward_btn].hidden = true; window.widgets[Widx::extra_fast_forward_btn].hidden = true; window.widgets[Widx::pause_btn].left = 38; window.widgets[Widx::pause_btn].right = 57; window.widgets[Widx::normal_speed_btn].left = 58; window.widgets[Widx::normal_speed_btn].right = 77; } else { window.widgets[Widx::fast_forward_btn].hidden = false; window.widgets[Widx::extra_fast_forward_btn].hidden = false; window.widgets[Widx::pause_btn].left = 18; window.widgets[Widx::pause_btn].right = 37; window.widgets[Widx::normal_speed_btn].left = 38; window.widgets[Widx::normal_speed_btn].right = 57; window.widgets[Widx::fast_forward_btn].left = 58; window.widgets[Widx::fast_forward_btn].right = 77; window.widgets[Widx::extra_fast_forward_btn].left = 78; window.widgets[Widx::extra_fast_forward_btn].right = 97; } } // TODO: use same list as top toolbar static constexpr uint32_t map_sprites_by_rotation[] = { InterfaceSkin::ImageIds::toolbar_menu_map_north, InterfaceSkin::ImageIds::toolbar_menu_map_west, InterfaceSkin::ImageIds::toolbar_menu_map_south, InterfaceSkin::ImageIds::toolbar_menu_map_east, }; // 0x004397BE static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Widget& frame = self.widgets[Widx::outer_frame]; drawingCtx.drawRect(self.x + frame.left, self.y + frame.top, frame.width(), frame.height(), enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); // Draw widgets. self.draw(drawingCtx); drawingCtx.drawRectInset(self.x + frame.left + 1, self.y + frame.top + 1, frame.width() - 2, frame.height() - 2, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); FormatArguments args{}; args.push<uint32_t>(getCurrentDay()); StringId format = StringIds::date_daymonthyear; if (SceneManager::isPaused() && (SceneManager::getPauseFlags() & (1 << 2)) == 0) { if (self.numTicksVisible >= kPausedStatusTextDuration) { format = StringIds::toolbar_status_paused; } } auto c = self.getColour(WindowColour::primary).opaque(); if (Input::isHovering(WindowType::timeToolbar, 0, Widx::date_btn)) { c = Colour::white; } { auto& widget = _widgets[Widx::date_btn]; auto point = Point(self.x + widget.midX(), self.y + widget.top + 1); tr.drawStringCentred(point, c, format, args); } auto skin = ObjectManager::get<InterfaceSkinObject>(); drawingCtx.drawImage(self.x + _widgets[Widx::map_chat_menu].left - 2, self.y + _widgets[Widx::map_chat_menu].top - 1, skin->img + map_sprites_by_rotation[WindowManager::getCurrentRotation()]); } // 0x004398FB static void onMouseUp([[maybe_unused]] Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::date_btn: MessageWindow::open(); break; case Widx::pause_btn: GameCommands::doCommand(GameCommands::PauseGameArgs{}, GameCommands::Flags::apply); break; case Widx::normal_speed_btn: GameCommands::doCommand(GameCommands::SetGameSpeedArgs{ GameSpeed::Normal }, GameCommands::Flags::apply); break; case Widx::fast_forward_btn: GameCommands::doCommand(GameCommands::SetGameSpeedArgs{ GameSpeed::FastForward }, GameCommands::Flags::apply); break; case Widx::extra_fast_forward_btn: GameCommands::doCommand(GameCommands::SetGameSpeedArgs{ GameSpeed::ExtraFastForward }, GameCommands::Flags::apply); break; } } // 0x0043A67F static void mapMouseDown(Ui::Window* self, WidgetIndex_t widgetIndex) { auto skin = ObjectManager::get<InterfaceSkinObject>(); if (SceneManager::isNetworked()) { Dropdown::add(0, StringIds::menu_sprite_stringid, { (uint32_t)skin->img + InterfaceSkin::ImageIds::phone, StringIds::chat_send_message }); Dropdown::add(1, StringIds::menu_sprite_stringid, { (uint32_t)skin->img + map_sprites_by_rotation[WindowManager::getCurrentRotation()], StringIds::menu_map }); Dropdown::showBelow(self, widgetIndex, 2, 25, (1 << 6)); Dropdown::setHighlightedItem(1); } else { Dropdown::add(0, StringIds::menu_sprite_stringid, { (uint32_t)skin->img + map_sprites_by_rotation[WindowManager::getCurrentRotation()], StringIds::menu_map }); Dropdown::showBelow(self, widgetIndex, 1, 25, (1 << 6)); Dropdown::setHighlightedItem(0); } } void beginSendChatMessage(Window& self) { const auto* opponent = CompanyManager::getOpponent(); auto args = FormatArguments::common(); args.push(opponent->name); // TODO: convert this to a builder pattern, with chainable functions to set the different string ids and arguments TextInput::openTextInput(&self, StringIds::chat_title, StringIds::chat_instructions, StringIds::empty, Widx::map_chat_menu, &args); } // 0x0043A72F static void mapDropdown(Window* self, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (SceneManager::isNetworked()) { switch (itemIndex) { case 0: beginSendChatMessage(*self); break; case 1: MapWindow::open(); break; } } else { switch (itemIndex) { case 0: MapWindow::open(); break; } } } // 0x043992E static void onMouseDown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::map_chat_menu: mapMouseDown(&window, widgetIndex); break; } } // 0x439939 static void onDropdown(Window& w, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t item_index) { switch (widgetIndex) { case Widx::map_chat_menu: mapDropdown(&w, widgetIndex, item_index); break; } } // 0x00439944 static Ui::CursorId onCursor([[maybe_unused]] Ui::Window& self, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, [[maybe_unused]] int16_t yPos, Ui::CursorId fallback) { switch (widgetIdx) { case Widx::date_btn: Ui::ToolTip::setTooltipTimeout(2000); break; } return fallback; } // 0x00439955 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; switch (widgetIndex) { case Widx::date_btn: formatChallenge(args); break; } return args; } // 0x0043995C static void formatChallenge(FormatArguments& args) { args.push(getCurrentDay()); auto playerCompany = CompanyManager::get(CompanyManager::getControllingId()); if ((playerCompany->challengeFlags & CompanyFlags::challengeCompleted) != CompanyFlags::none) { args.push(StringIds::challenge_completed); } else if ((playerCompany->challengeFlags & CompanyFlags::challengeFailed) != CompanyFlags::none) { args.push(StringIds::challenge_failed); } else if ((playerCompany->challengeFlags & CompanyFlags::challengeBeatenByOpponent) != CompanyFlags::none) { args.push(StringIds::empty); } else { args.push(StringIds::challenge_progress); args.push<uint16_t>(playerCompany->challengeProgress); if ((Scenario::getObjective().flags & Scenario::ObjectiveFlags::withinTimeLimit) != Scenario::ObjectiveFlags::none) { uint16_t monthsLeft = (Scenario::getObjective().timeLimitYears * 12 - Scenario::getObjectiveProgress().monthsInChallenge); uint16_t yearsLeft = monthsLeft / 12; monthsLeft = monthsLeft % 12; args.push(StringIds::challenge_time_left); args.push(yearsLeft); args.push(monthsLeft); } else { args.push(StringIds::empty); } } } // 0x00439A15 static void textInput([[maybe_unused]] Window& w, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const char* str) { switch (widgetIndex) { case Widx::map_chat_menu: sendChatMessage(str); break; } } static void sendChatMessage(const char* string) { Network::sendChatMessage(string); } void invalidateFrame() { redrawScheduled = true; } // 0x00439AD9 static void onUpdate(Window& w) { w.var_854 += 1; if (w.var_854 >= 24) { w.var_854 = 0; } w.numTicksVisible += 1; if (w.numTicksVisible >= kPausedStatusTextDuration * 2) { w.numTicksVisible = 0; } // Determine if the text needs to be updated if (SceneManager::isPaused() && (SceneManager::getPauseFlags() & (1 << 2)) == 0) { if (w.numTicksVisible == 0 || w.numTicksVisible == kPausedStatusTextDuration) { redrawScheduled = true; } } if (redrawScheduled) { redrawScheduled = false; // Invalidating the inner frame widget effectively causes the entire time panel to be redrawn. WindowManager::invalidateWidget(WindowType::timeToolbar, 0, Widx::inner_frame); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseHover = onMouseDown, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .textInput = textInput, .tooltip = tooltip, .cursor = onCursor, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TitleExit.cpp ```cpp #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/LoadSaveQuit.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Intro.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "OpenLoco.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::TitleExit { static constexpr Ui::Size32 kWindowSize = { 40, 28 }; namespace Widx { enum { exit_button }; } static constexpr auto _widgets = makeWidgets( Widgets::ImageButton({ 0, 0 }, kWindowSize, WindowColour::secondary, Widget::kContentNull, StringIds::title_menu_exit_from_game) ); static const WindowEventList& getEvents(); Window* open() { auto window = OpenLoco::Ui::WindowManager::createWindow( WindowType::titleExit, { Ui::width() - kWindowSize.width, Ui::height() - kWindowSize.height }, kWindowSize, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground | WindowFlags::flag_6, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::mutedSeaGreen).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(Colour::mutedSeaGreen).translucent()); return window; } static void prepareDraw(Ui::Window& self) { auto exitString = StringManager::getString(StringIds::title_exit_game); self.width = Gfx::TextRenderer::getStringWidthNewLined(Gfx::Font::medium_bold, exitString) + 10; self.x = Ui::width() - self.width; self.widgets[Widx::exit_button].right = self.width; } // 0x00439236 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); // Draw widgets. window.draw(drawingCtx); int16_t x = window.x + window.width / 2; int16_t y = window.y + window.widgets[Widx::exit_button].top + 8; Ui::Point origin = { x, y }; tr.drawStringCentredWrapped(origin, window.width, Colour::black, StringIds::title_exit_game); } // 0x00439268 static void onMouseUp([[maybe_unused]] Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (Intro::isActive()) { return; } switch (widgetIndex) { case Widx::exit_button: // Exit to desktop GameCommands::LoadSaveQuitGameArgs args{}; args.loadQuitMode = LoadOrQuitMode::quitGamePrompt; args.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TitleLogo.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "OpenLoco.h" #include "Ui/Widget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::TitleLogo { static constexpr Ui::Size32 kWindowSize = { 298, 170 }; namespace Widx { enum { logo }; } static constexpr auto _widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, kWindowSize, WindowColour::primary) ); static const WindowEventList& getEvents(); Window* open() { auto window = OpenLoco::Ui::WindowManager::createWindow( WindowType::title_logo, { 0, 0 }, kWindowSize, WindowFlags::openQuietly | WindowFlags::transparent, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::grey).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(Colour::grey).translucent()); return window; } // 0x00439298 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { drawingCtx.drawImage(window.x, window.y, ImageIds::locomotion_logo); } // 0x004392AD static void onMouseUp([[maybe_unused]] Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::logo: About::open(); break; } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TitleMenu.cpp ```cpp #include "Config.h" #include "EditorController.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/LoadSaveQuit.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Gui.h" #include "Input.h" #include "Intro.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Logging.h" #include "Map/Tile.h" #include "MultiPlayer.h" #include "Network/Network.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "SceneManager.h" #include "Title.h" #include "Tutorial.h" #include "Ui.h" #include "Ui/Dropdown.h" #include "Ui/ToolTip.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include <OpenLoco/Utility/String.hpp> #include <string_view> namespace OpenLoco::Ui::Windows::TitleMenu { static constexpr uint8_t kBtnMainSize = 74; static constexpr uint8_t kBtnSubHeight = 18; static constexpr uint16_t kWW = kBtnMainSize * 4; static constexpr uint16_t kWH = kBtnMainSize + kBtnSubHeight; static constexpr std::array<uint32_t, 32> kGlobeSpin = { ImageIds::title_menu_globe_spin_0, ImageIds::title_menu_globe_spin_1, ImageIds::title_menu_globe_spin_2, ImageIds::title_menu_globe_spin_3, ImageIds::title_menu_globe_spin_4, ImageIds::title_menu_globe_spin_5, ImageIds::title_menu_globe_spin_6, ImageIds::title_menu_globe_spin_7, ImageIds::title_menu_globe_spin_8, ImageIds::title_menu_globe_spin_9, ImageIds::title_menu_globe_spin_10, ImageIds::title_menu_globe_spin_11, ImageIds::title_menu_globe_spin_12, ImageIds::title_menu_globe_spin_13, ImageIds::title_menu_globe_spin_14, ImageIds::title_menu_globe_spin_15, ImageIds::title_menu_globe_spin_16, ImageIds::title_menu_globe_spin_17, ImageIds::title_menu_globe_spin_18, ImageIds::title_menu_globe_spin_19, ImageIds::title_menu_globe_spin_20, ImageIds::title_menu_globe_spin_21, ImageIds::title_menu_globe_spin_22, ImageIds::title_menu_globe_spin_23, ImageIds::title_menu_globe_spin_24, ImageIds::title_menu_globe_spin_25, ImageIds::title_menu_globe_spin_26, ImageIds::title_menu_globe_spin_27, ImageIds::title_menu_globe_spin_28, ImageIds::title_menu_globe_spin_29, ImageIds::title_menu_globe_spin_30, ImageIds::title_menu_globe_spin_31, }; static constexpr std::array<uint32_t, 32> kGlobeConstruct = { ImageIds::title_menu_globe_construct_0, ImageIds::title_menu_globe_construct_1, ImageIds::title_menu_globe_construct_2, ImageIds::title_menu_globe_construct_3, ImageIds::title_menu_globe_construct_4, ImageIds::title_menu_globe_construct_5, ImageIds::title_menu_globe_construct_6, ImageIds::title_menu_globe_construct_7, ImageIds::title_menu_globe_construct_8, ImageIds::title_menu_globe_construct_9, ImageIds::title_menu_globe_construct_10, ImageIds::title_menu_globe_construct_11, ImageIds::title_menu_globe_construct_12, ImageIds::title_menu_globe_construct_13, ImageIds::title_menu_globe_construct_14, ImageIds::title_menu_globe_construct_15, ImageIds::title_menu_globe_construct_16, ImageIds::title_menu_globe_construct_17, ImageIds::title_menu_globe_construct_18, ImageIds::title_menu_globe_construct_19, ImageIds::title_menu_globe_construct_20, ImageIds::title_menu_globe_construct_21, ImageIds::title_menu_globe_construct_22, ImageIds::title_menu_globe_construct_23, ImageIds::title_menu_globe_construct_24, ImageIds::title_menu_globe_construct_25, ImageIds::title_menu_globe_construct_26, ImageIds::title_menu_globe_construct_27, ImageIds::title_menu_globe_construct_28, ImageIds::title_menu_globe_construct_29, ImageIds::title_menu_globe_construct_30, ImageIds::title_menu_globe_construct_31, }; namespace Widx { enum { scenario_list_btn, load_game_btn, tutorial_btn, scenario_editor_btn, chat_btn, multiplayer_toggle_btn, }; } static constexpr auto _widgets = makeWidgets( Widgets::ImageButton({ 0, 0 }, { kBtnMainSize, kBtnMainSize }, WindowColour::secondary, Widget::kContentNull, StringIds::title_menu_new_game), Widgets::ImageButton({ kBtnMainSize, 0 }, { kBtnMainSize, kBtnMainSize }, WindowColour::secondary, Widget::kContentNull, StringIds::title_menu_load_game), Widgets::ImageButton({ kBtnMainSize * 2, 0 }, { kBtnMainSize, kBtnMainSize }, WindowColour::secondary, Widget::kContentNull, StringIds::title_menu_show_tutorial), Widgets::ImageButton({ kBtnMainSize * 3, 0 }, { kBtnMainSize, kBtnMainSize }, WindowColour::secondary, Widget::kContentNull, StringIds::title_menu_scenario_editor), Widgets::ImageButton({ kBtnMainSize * 4 - 31, kBtnMainSize - 27 }, { 31, 27 }, WindowColour::secondary, Widget::kContentNull, StringIds::title_menu_chat_tooltip), Widgets::ImageButton({ 0, kBtnMainSize }, { kWW, kBtnSubHeight }, WindowColour::secondary, Widget::kContentNull, StringIds::title_multiplayer_toggle_tooltip) ); static void sub_439112(Window* window); static void sub_4391CC(int16_t itemIndex); static void sub_43918F(const char* string); static void sub_4391DA(); static void sub_4391E2(); static void sub_43910A(); static void showMultiplayer(Window* window); static void multiplayerConnect(std::string_view host); static const WindowEventList& getEvents(); Window* open() { auto window = OpenLoco::Ui::WindowManager::createWindow( WindowType::titleMenu, { (Ui::width() - kWW) / 2, Ui::height() - kWH - 25 }, { kWW, kWH }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground | WindowFlags::flag_6, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::mutedSeaGreen).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(Colour::mutedSeaGreen).translucent()); window->var_846 = 0; return window; } // 0x00438E0B static void prepareDraw(Ui::Window& window) { window.disabledWidgets = 0; window.widgets[Widx::tutorial_btn].hidden = false; window.widgets[Widx::scenario_editor_btn].hidden = false; // TODO: add widget::set_origin() window.widgets[Widx::scenario_list_btn].left = 0; window.widgets[Widx::scenario_list_btn].right = kBtnMainSize - 1; window.widgets[Widx::load_game_btn].left = kBtnMainSize; window.widgets[Widx::load_game_btn].right = kBtnMainSize * 2 - 1; window.widgets[Widx::tutorial_btn].left = kBtnMainSize * 2; window.widgets[Widx::tutorial_btn].right = kBtnMainSize * 3 - 1; window.widgets[Widx::scenario_editor_btn].left = kBtnMainSize * 3; window.widgets[Widx::scenario_editor_btn].right = kBtnMainSize * 4 - 1; window.widgets[Widx::chat_btn].hidden = true; auto& config = Config::get(); window.widgets[Widx::multiplayer_toggle_btn].hidden = config.network.enabled ? false : true; if (SceneManager::isNetworked()) { window.widgets[Widx::tutorial_btn].hidden = true; window.widgets[Widx::scenario_editor_btn].hidden = true; window.widgets[Widx::scenario_list_btn].left = kBtnMainSize; window.widgets[Widx::scenario_list_btn].right = kBtnMainSize * 2 - 1; window.widgets[Widx::load_game_btn].left = kBtnMainSize * 2; window.widgets[Widx::load_game_btn].right = kBtnMainSize * 3 - 1; window.widgets[Widx::chat_btn].hidden = false; auto* skin = ObjectManager::get<InterfaceSkinObject>(); window.widgets[Widx::chat_btn].image = skin->img + InterfaceSkin::ImageIds::phone; } } // 0x00438EC7 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); // Draw widgets. window.draw(drawingCtx); if (!window.widgets[Widx::scenario_list_btn].hidden) { int16_t x = window.widgets[Widx::scenario_list_btn].left + window.x; int16_t y = window.widgets[Widx::scenario_list_btn].top + window.y; uint32_t image_id = ImageIds::title_menu_globe_spin_0; if (Input::isHovering(WindowType::titleMenu, 0, Widx::scenario_list_btn)) { image_id = kGlobeSpin[((window.var_846 / 2) % kGlobeSpin.size())]; } drawingCtx.drawImage(x, y, image_id); drawingCtx.drawImage(x, y, ImageIds::title_menu_sparkle); } if (!window.widgets[Widx::load_game_btn].hidden) { int16_t x = window.widgets[Widx::load_game_btn].left + window.x; int16_t y = window.widgets[Widx::load_game_btn].top + window.y; uint32_t image_id = ImageIds::title_menu_globe_spin_0; if (Input::isHovering(WindowType::titleMenu, 0, Widx::load_game_btn)) { image_id = kGlobeSpin[((window.var_846 / 2) % kGlobeSpin.size())]; } drawingCtx.drawImage(x, y, image_id); drawingCtx.drawImage(x, y, ImageIds::title_menu_save); } if (!window.widgets[Widx::tutorial_btn].hidden) { int16_t x = window.widgets[Widx::tutorial_btn].left + window.x; int16_t y = window.widgets[Widx::tutorial_btn].top + window.y; uint32_t image_id = ImageIds::title_menu_globe_spin_0; if (Input::isHovering(WindowType::titleMenu, 0, Widx::tutorial_btn)) { image_id = kGlobeSpin[((window.var_846 / 2) % kGlobeSpin.size())]; } drawingCtx.drawImage(x, y, image_id); // TODO: base lesson overlay on language drawingCtx.drawImage(x, y, ImageIds::title_menu_lesson_l); } if (!window.widgets[Widx::scenario_editor_btn].hidden) { int16_t x = window.widgets[Widx::scenario_editor_btn].left + window.x; int16_t y = window.widgets[Widx::scenario_editor_btn].top + window.y; uint32_t image_id = ImageIds::title_menu_globe_construct_24; if (Input::isHovering(WindowType::titleMenu, 0, Widx::scenario_editor_btn)) { image_id = kGlobeConstruct[((window.var_846 / 2) % kGlobeConstruct.size())]; } drawingCtx.drawImage(x, y, image_id); } if (!window.widgets[Widx::multiplayer_toggle_btn].hidden) { auto& widget = window.widgets[Widx::multiplayer_toggle_btn]; auto point = Point(widget.top + 3 + window.y, window.width / 2 + window.x); StringId string = StringIds::single_player_mode; FormatArguments args{}; if (SceneManager::isNetworked()) { // char[512+1] auto buffer = StringManager::getString(StringIds::buffer_2039); // TODO: ?? replace this char* playerName = (char*)0xF254D0; strcpy((char*)buffer, playerName); args.push(StringIds::buffer_2039); string = StringIds::two_player_mode_connected; } tr.drawStringCentredClipped(point, kWW - 4, Colour::black, string, args); } } // 0x00439094 static void onMouseUp(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (Intro::isActive()) { return; } switch (widgetIndex) { case Widx::scenario_list_btn: sub_4391DA(); break; case Widx::load_game_btn: sub_4391E2(); break; case Widx::scenario_editor_btn: Title::stop(); sub_43910A(); break; case Widx::chat_btn: beginSendChatMessage(window); break; case Widx::multiplayer_toggle_btn: showMultiplayer(&window); break; } } // 0x004390D1 static void onMouseDown(Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::tutorial_btn: sub_439112(&window); break; } } // 0x004390DD static void onDropdown([[maybe_unused]] Ui::Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case Widx::tutorial_btn: sub_4391CC(itemIndex); break; } } // 0x004390ED static void onTextInput([[maybe_unused]] Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const char* input) { switch (widgetIndex) { case Widx::chat_btn: sub_43918F(input); break; case Widx::multiplayer_toggle_btn: multiplayerConnect(input); break; } } // 0x004390f8 static Ui::CursorId onCursor([[maybe_unused]] Window& window, [[maybe_unused]] WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, [[maybe_unused]] int16_t yPos, Ui::CursorId fallback) { // Reset tooltip timeout to keep tooltips open. Ui::ToolTip::setTooltipTimeout(2000); return fallback; } static void showMultiplayer(Window* window) { StringManager::setString(StringIds::buffer_2039, ""); TextInput::openTextInput(window, StringIds::enter_host_address, StringIds::enter_host_address_description, StringIds::buffer_2039, Widx::multiplayer_toggle_btn, nullptr); } static void multiplayerConnect(std::string_view host) { Network::joinServer(host); } static void sub_43910A() { EditorController::init(); } static void sub_439112(Window* window) { Dropdown::add(0, StringIds::tutorial_1_title); Dropdown::add(1, StringIds::tutorial_2_title); Dropdown::add(2, StringIds::tutorial_3_title); Widget* widget = &window->widgets[Widx::tutorial_btn]; Dropdown::showText( window->x + widget->left, window->y + widget->top, widget->width(), widget->height(), window->getColour(WindowColour::primary).translucent(), 3, 0x80); } void beginSendChatMessage(Window& self) { WindowManager::close(WindowType::multiplayer); auto args = FormatArguments::common(); args.push(StringIds::the_other_player); // TODO: convert this to a builder pattern, with chainable functions to set the different string ids and arguments TextInput::openTextInput(&self, StringIds::chat_title, StringIds::chat_instructions, StringIds::empty, Widx::chat_btn, &args); } static void sub_43918F(const char* string) { // Identical to processChatMessage GameCommands::setErrorTitle(StringIds::empty); for (int i = 0; i < 32; i++) { GameCommands::do_71(i, &string[i * 16]); } } static void sub_4391CC(int16_t itemIndex) { // DROPDOWN_ITEM_UNDEFINED if (itemIndex == -1) { return; } OpenLoco::Tutorial::start(itemIndex); } static void sub_4391DA() { ScenarioSelect::open(); } static void sub_4391E2() { GameCommands::LoadSaveQuitGameArgs args{}; args.loadQuitMode = LoadOrQuitMode::loadGamePrompt; args.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x004391F9 static void onUpdate(Window& window) { window.var_846++; window.invalidate(); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .textInput = onTextInput, .cursor = onCursor, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TitleOptions.cpp ```cpp #include "GameCommands/GameCommands.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Intro.h" #include "Localisation/StringIds.h" #include "OpenLoco.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::TitleOptions { static constexpr Ui::Size32 kWindowSize = { 60, 15 }; namespace Widx { enum { options_button }; } static constexpr auto _widgets = makeWidgets( Widgets::ImageButton({ 0, 0 }, kWindowSize, WindowColour::secondary) ); static const WindowEventList& getEvents(); Window* open() { auto window = WindowManager::createWindow( WindowType::titleOptions, { Ui::width() - kWindowSize.width, 0 }, kWindowSize, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground | WindowFlags::flag_6, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::mutedSeaGreen).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(Colour::mutedSeaGreen).translucent()); return window; } static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); // Draw widgets. window.draw(drawingCtx); int16_t x = window.x + window.width / 2; int16_t y = window.y + window.widgets[Widx::options_button].top + 2; Ui::Point origin = { x, y }; auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(StringIds::options); tr.drawStringCentredWrapped(origin, window.width, Colour::white, StringIds::outlined_wcolour2_stringid, args); } static void onMouseUp([[maybe_unused]] Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (Intro::isActive()) { return; } switch (widgetIndex) { case Widx::options_button: Ui::Windows::Options::open(); break; } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TitleVersion.cpp ```cpp #include "Graphics/Colour.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Window.h" #include "Ui/WindowManager.h" #include "Version.h" namespace OpenLoco::Ui::Windows::TitleVersion { static const WindowEventList& getEvents(); Window* open() { const auto kWidth = 512; const auto kHeight = 30; auto window = OpenLoco::Ui::WindowManager::createWindow( WindowType::openLocoVersion, { 8, Ui::height() - kHeight }, { kWidth, kHeight }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground | WindowFlags::flag_6, getEvents()); return window; } // 0x00439236 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); auto versionInfo = getVersionInfo(); auto point = Point(window.x, window.y); tr.drawString(point, AdvancedColour(Colour::white).outline(), versionInfo.c_str()); auto platformInfo = getPlatformInfo(); point.y += 12; tr.drawString(point, AdvancedColour(Colour::white).outline(), platformInfo.c_str()); } static constexpr WindowEventList kEvents = { .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ToolTip.cpp ```cpp #include "Ui/ToolTip.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <algorithm> #include <cstring> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::ToolTip { static WindowType _tooltipWindowType; static WindowNumber_t _tooltipWindowNumber; static WidgetIndex_t _tooltipWidgetIndex; static uint16_t _tooltipNotShownTicks; static StringId _currentTooltipStringId; static Ui::Point _tooltipCursor; static uint16_t _tooltipTimeout; static bool _52336E; void setWindowType(WindowType wndType) { _tooltipWindowType = wndType; } WindowType getWindowType() { return _tooltipWindowType; } void setWindowNumber(WindowNumber_t wndNumber) { _tooltipWindowNumber = wndNumber; } WindowNumber_t getWindowNumber() { return _tooltipWindowNumber; } void setWidgetIndex(WidgetIndex_t widx) { _tooltipWidgetIndex = widx; } WidgetIndex_t getWidgetIndex() { return _tooltipWidgetIndex; } void setNotShownTicks(uint16_t ticks) { _tooltipNotShownTicks = ticks; } uint16_t getNotShownTicks() { return _tooltipNotShownTicks; } StringId getCurrentStringId() { return _currentTooltipStringId; } void setCurrentStringId(StringId stringId) { _currentTooltipStringId = stringId; } // 0x00439BB1 bool isTimeTooltip() { return _tooltipWindowType == WindowType::timeToolbar && _tooltipWidgetIndex == 3; } Ui::Point getTooltipMouseLocation() { return _tooltipCursor; } void setTooltipMouseLocation(const Ui::Point& loc) { _tooltipCursor = loc; } uint16_t getTooltipTimeout() { return _tooltipTimeout; } void setTooltipTimeout(uint16_t tooltipTimeout) { _tooltipTimeout = tooltipTimeout; } void set_52336E(bool value) { _52336E = value; } } namespace OpenLoco::Ui::Windows::ToolTip { static char _text[512]; // 0x01136D90 static uint16_t _lineBreakCount; // 0x01136F90 enum widx { text }; // 0x005234CC static constexpr auto _widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 200, 32 }, WindowColour::primary) ); static const WindowEventList& getEvents(); static void common([[maybe_unused]] const Window* window, [[maybe_unused]] int32_t widgetIndex, StringId stringId, int16_t cursorX, int16_t cursorY, FormatArguments& args) { StringManager::formatString(_text, stringId, args); const auto font = Gfx::Font::medium_bold; int16_t strWidth = Gfx::TextRenderer::getStringWidthNewLined(font, _text); strWidth = std::min<int16_t>(strWidth, 196); auto [wrappedWidth, breakCount] = Gfx::TextRenderer::wrapString(font, _text, strWidth + 1); _lineBreakCount = breakCount; int width = wrappedWidth + 3; int height = (_lineBreakCount + 1) * 10 + 4; int x, y; int maxY = Ui::height() - height; y = cursorY + 26; // Normally, we'd display the tooltip 26 lower if (y > maxY) { // If y is too large, the tooltip could be forced below the cursor if we'd just clamped y, // so we'll subtract a bit more y -= height + 40; } y = std::clamp(y, 22, maxY); x = width <= Ui::width() ? std::clamp(cursorX - (width / 2), 0, Ui::width() - width) : 0; auto tooltip = WindowManager::createWindow( WindowType::tooltip, { x, y }, { width, height }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::flag_7, getEvents()); tooltip->setWidgets(_widgets); tooltip->widgets[widx::text].right = width; tooltip->widgets[widx::text].bottom = height; Ui::ToolTip::setNotShownTicks(0); } // 0x004C906B void open(Ui::Window* window, int32_t widgetIndex, int16_t cursorX, int16_t cursorY) { WindowManager::close(WindowType::tooltip, 0); if (window == nullptr || widgetIndex == kWidgetIndexNull) { return; } window->callPrepareDraw(); if (window->widgets[widgetIndex].tooltip == StringIds::null) { return; } Ui::ToolTip::setWindowType(window->type); Ui::ToolTip::setWindowNumber(window->number); Ui::ToolTip::setWidgetIndex(widgetIndex); auto toolArgs = window->callTooltip(widgetIndex, window->widgets[widgetIndex].id); if (!toolArgs) { return; } auto wnd = WindowManager::find(WindowType::error, 0); if (wnd != nullptr) { return; } Ui::ToolTip::setCurrentStringId(StringIds::null); common(window, widgetIndex, window->widgets[widgetIndex].tooltip, cursorX, cursorY, *toolArgs); } // 0x004C9216 void update(Ui::Window* window, int32_t widgetIndex, StringId stringId, int16_t cursorX, int16_t cursorY) { WindowManager::close(WindowType::tooltip, 0); Ui::ToolTip::setWindowType(window->type); Ui::ToolTip::setWindowNumber(window->number); Ui::ToolTip::setWidgetIndex(widgetIndex); auto toolArgs = window->callTooltip(widgetIndex, window->widgets[widgetIndex].id); if (!toolArgs) { return; } auto wnd = WindowManager::find(WindowType::error, 0); if (wnd != nullptr) { return; } Ui::ToolTip::setCurrentStringId(stringId); common(window, widgetIndex, stringId, cursorX, cursorY, *toolArgs); } // 0x004C9397 static void draw(Ui::Window& window, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); uint16_t x = window.x; uint16_t y = window.y; uint16_t width = window.width; uint16_t height = window.height; drawingCtx.drawRect(x + 1, y + 1, width - 2, height - 2, enumValue(ExtColour::unk2D), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + 1, y + 1, width - 2, height - 2, (enumValue(ExtColour::unk74) + enumValue(ObjectManager::get<InterfaceSkinObject>()->tooltipColour)), Gfx::RectFlags::transparent); drawingCtx.drawRect(x, y + 2, 1, height - 4, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + width - 1, y + 2, 1, height - 4, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + 2, y + height - 1, width - 4, 1, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + 2, y, width - 4, 1, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + 1, y + 1, 1, 1, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + width - 1 - 1, y + 1, 1, 1, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + 1, y + height - 1 - 1, 1, 1, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); drawingCtx.drawRect(x + width - 1 - 1, y + height - 1 - 1, 1, 1, enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); auto point = Point(((width + 1) / 2) + x - 1, y + 1); tr.drawStringCentredRaw(point, _lineBreakCount, Colour::black, _text); } // 0x004C94F7 static void onClose([[maybe_unused]] Ui::Window& window) { auto str337 = const_cast<char*>(StringManager::getString(StringIds::buffer_337)); str337[0] = '\0'; } // 0x004C94FF static void update([[maybe_unused]] Ui::Window& window) { if (Ui::ToolTip::_52336E == false) { Ui::ToolTip::setNotShownTicks(0); } } // 0x004C87B5 void closeAndReset() { Ui::WindowManager::close(WindowType::tooltip, 0); Ui::ToolTip::setTooltipTimeout(0); Ui::ToolTip::setWindowType(WindowType::undefined); Ui::ToolTip::setCurrentStringId(StringIds::null); Ui::ToolTip::set_52336E(false); } static constexpr WindowEventList kEvents = { .onClose = onClose, .onUpdate = update, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ToolbarBottomEditor.cpp ```cpp #include "EditorController.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/StringIds.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include <map> namespace OpenLoco::Ui::Windows::ToolbarBottom::Editor { enum widx { previous_frame, previous_button, next_frame, next_button, }; static constexpr uint16_t kWindowHeight = 32; static constexpr auto _widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 200, 34 }, WindowColour::primary), Widgets::ImageButton({ 2, 2 }, { 196, 30 }, WindowColour::primary), Widgets::Wt3Widget({ 440, 0 }, { 200, 34 }, WindowColour::primary), Widgets::ImageButton({ 442, 2 }, { 196, 30 }, WindowColour::primary) ); static std::map<EditorController::Step, StringId> _stepNames = { { EditorController::Step::objectSelection, StringIds::editor_step_object_selection }, { EditorController::Step::landscapeEditor, StringIds::editor_step_landscape }, { EditorController::Step::scenarioOptions, StringIds::editor_step_options }, { EditorController::Step::saveScenario, StringIds::editor_step_save }, }; // 0x0043CE21 static void prepareDraw(Window& self) { self.widgets[widx::next_frame].hidden = false; self.widgets[widx::next_button].hidden = false; if (EditorController::canGoBack()) { self.widgets[widx::previous_frame].hidden = false; self.widgets[widx::previous_button].hidden = false; } else { self.widgets[widx::previous_frame].hidden = true; self.widgets[widx::previous_button].hidden = true; } // 0x0043CDD1 self.widgets[widx::next_frame].right = self.width - 1; self.widgets[widx::next_frame].left = self.width - 1 - 2 - 195 - 2; self.widgets[widx::next_button].left = self.widgets[widx::next_frame].left + 2; self.widgets[widx::next_button].right = self.widgets[widx::next_frame].right - 2; } // 0x0043CE65 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); Widget& previous = self.widgets[widx::previous_frame]; Widget& next = self.widgets[widx::next_frame]; if (EditorController::canGoBack()) { drawingCtx.drawRect(previous.left + self.x, previous.top + self.y, previous.width(), previous.height(), enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); } drawingCtx.drawRect(next.left + self.x, next.top + self.y, next.width(), next.height(), enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); self.draw(drawingCtx); if (EditorController::canGoBack()) { drawingCtx.drawRectInset(previous.left + self.x + 1, previous.top + self.y + 1, previous.width() - 2, previous.height() - 2, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); } drawingCtx.drawRectInset(next.left + self.x + 1, next.top + self.y + 1, next.width() - 2, next.height() - 2, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillNone); auto point = Point((previous.right + next.left) / 2 + self.x, self.y + self.height - 12); tr.drawStringCentred(point, self.getColour(WindowColour::tertiary).opaque().outline(), _stepNames[EditorController::getCurrentStep()]); if (EditorController::canGoBack()) { drawingCtx.drawImage(self.x + previous.left + 6, self.y + previous.top + 6, ImageIds::step_back); int x = (previous.left + 30 + previous.right) / 2; int y = previous.top + 6; auto textColour = self.getColour(WindowColour::secondary).opaque(); if (Input::isHovering(self.type, self.number, widx::previous_button)) { textColour = Colour::white; } point = Point(self.x + x, self.y + y); tr.drawStringCentred(point, textColour, StringIds::editor_previous_step); point = Point(self.x + x, self.y + y + 10); tr.drawStringCentred(point, textColour, _stepNames[EditorController::getPreviousStep()]); } drawingCtx.drawImage(self.x + next.right - 29, self.y + next.top + 4, ImageIds::step_forward); int x = next.left + (next.width() - 31) / 2; int y = next.top + 6; auto textColour = self.getColour(WindowColour::secondary).opaque(); if (Input::isHovering(self.type, self.number, widx::next_button)) { textColour = Colour::white; } point = Point(self.x + x, self.y + y); tr.drawStringCentred(point, textColour, StringIds::editor_next_step); point = Point(self.x + x, self.y + y + 10); tr.drawStringCentred(point, textColour, _stepNames[EditorController::getNextStep()]); } // 0x0043D0ED static void onMouseUp(Window&, WidgetIndex_t i, [[maybe_unused]] const WidgetId id) { switch (i) { case widx::previous_button: EditorController::goToPreviousStep(); break; case widx::next_button: EditorController::goToNextStep(); break; } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } // 0x0043CCCD void open() { const auto origin = Ui::Point32(0, Ui::height() - kWindowHeight); const auto windowSize = Ui::Size32(Ui::width(), kWindowHeight); auto window = WindowManager::createWindow( WindowType::editorToolbar, origin, windowSize, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground, getEvents()); window->setWidgets(_widgets); window->var_854 = 0; window->initScrollWidgets(); window->setColour(WindowColour::primary, AdvancedColour(Colour::mutedSeaGreen).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(Colour::mutedSeaGreen).translucent()); window->setColour(WindowColour::tertiary, AdvancedColour(Colour::mutedSeaGreen).translucent()); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ToolbarTop.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Entities/EntityManager.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/LoadSaveQuit.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Input.h" #include "Jukebox.h" #include "Localisation/StringIds.h" #include "MultiPlayer.h" #include "Network/Network.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/WaterObject.h" #include "S5/S5.h" #include "SceneManager.h" #include "ToolbarTopCommon.h" #include "Ui/Dropdown.h" #include "Ui/Screenshot.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <map> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::ToolbarTop::Game { static loco_global<uint32_t, 0x009C86F8> _zoomTicks; static loco_global<uint8_t, 0x009C870C> _lastTownOption; static loco_global<uint8_t, 0x009C870D> _lastPortOption; static loco_global<uint8_t[18], 0x0050A006> _availableObjects; // Replaces 0x0050A006 AvailableTracksAndRoads availableTracks; namespace Widx { enum { cheats_menu = Common::Widx::w2 }; } static constexpr auto _widgets = makeWidgets( Widgets::ImageButton({ 0, 0 }, { 30, 28 }, WindowColour::primary), Widgets::ImageButton({ 30, 0 }, { 30, 28 }, WindowColour::primary), Widgets::ImageButton({ 60, 0 }, { 30, 28 }, WindowColour::primary), Widgets::ImageButton({ 104, 0 }, { 30, 28 }, WindowColour::secondary), Widgets::ImageButton({ 134, 0 }, { 30, 28 }, WindowColour::secondary), Widgets::ImageButton({ 164, 0 }, { 30, 28 }, WindowColour::secondary), Widgets::ImageButton({ 267, 0 }, { 30, 28 }, WindowColour::tertiary), Widgets::ImageButton({ 387, 0 }, { 30, 28 }, WindowColour::tertiary), Widgets::ImageButton({ 357, 0 }, { 30, 28 }, WindowColour::tertiary), Widgets::ImageButton({ 417, 0 }, { 30, 28 }, WindowColour::tertiary), Widgets::ImageButton({ 417, 0 }, { 30, 28 }, WindowColour::tertiary), Widgets::ImageButton({ 490, 0 }, { 30, 28 }, WindowColour::quaternary), Widgets::ImageButton({ 520, 0 }, { 30, 28 }, WindowColour::quaternary), Widgets::ImageButton({ 460, 0 }, { 30, 28 }, WindowColour::quaternary) ); enum class LoadSaveDropdownId { loadGame, saveGame, about, options, screenshot, giantScreenshot, server, quitToMenu, quitToDesktop }; static const WindowEventList& getEvents(); // 0x00438B26 void open() { _zoomTicks = 0; _lastTownOption = 0; _lastPortOption = 0; auto window = WindowManager::createWindow( WindowType::topToolbar, { 0, 0 }, { Ui::width(), 28 }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, skin->topToolbarPrimaryColour); window->setColour(WindowColour::secondary, skin->topToolbarSecondaryColour); window->setColour(WindowColour::tertiary, skin->topToolbarTertiaryColour); window->setColour(WindowColour::quaternary, skin->topToolbarQuaternaryColour); } } // 0x0043B0F7 static void loadsaveMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto d = Dropdown::create() .below(*window, widgetIndex) .item(LoadSaveDropdownId::loadGame, StringIds::menu_load_game) .item(LoadSaveDropdownId::saveGame, StringIds::menu_save_game) .separator() .item(LoadSaveDropdownId::about, StringIds::menu_about) .item(LoadSaveDropdownId::options, StringIds::options) .item(LoadSaveDropdownId::screenshot, StringIds::menu_screenshot) .item(LoadSaveDropdownId::giantScreenshot, StringIds::menu_giant_screenshot); auto& newConfig = Config::get(); if (newConfig.network.enabled) { d.separator(); if (SceneManager::isNetworked()) { if (SceneManager::isNetworkHost()) { d.item(LoadSaveDropdownId::server, StringIds::closeServer); } else { d.item(LoadSaveDropdownId::server, StringIds::disconnect); } } else { d.item(LoadSaveDropdownId::server, StringIds::startServer); } } d.separator() .item(LoadSaveDropdownId::quitToMenu, StringIds::menu_quit_to_menu) .item(LoadSaveDropdownId::quitToDesktop, StringIds::menu_exit_openloco) .highlight(LoadSaveDropdownId::saveGame) .show(); } // 0x0043B1C4 static void prepareSaveGame() { ToolManager::toolCancel(); if (SceneManager::isNetworked()) { if (GameCommands::getUpdatingCompanyId() == CompanyManager::getControllingId()) { GameCommands::do_72(); MultiPlayer::setFlag(MultiPlayer::flags::flag_2); } return; } auto res = OpenLoco::Game::saveSaveGameOpen(); if (!res) { // Cancelled by user Gfx::invalidateScreen(); return; } auto path = fs::u8path(*res).replace_extension(S5::extensionSV5); OpenLoco::Game::setActiveSavePath(path.u8string()); S5::SaveFlags flags = S5::SaveFlags::none; if (Config::get().exportObjectsWithSaves) { flags = S5::SaveFlags::packCustomObjects; } if (!S5::exportGameStateToFile(path, flags)) { Error::open(StringIds::error_game_save_failed, StringIds::null); } } static void startOrCloseServer() { if (SceneManager::isNetworked()) { Network::close(); } else { Network::openServer(); } } // 0x0043B154 static void loadsaveMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { auto id = Dropdown::getSelectedItem<LoadSaveDropdownId>(itemIndex); if (!id) { return; } switch (*id) { case LoadSaveDropdownId::loadGame: // Load game { GameCommands::LoadSaveQuitGameArgs loadGameArgs{}; loadGameArgs.loadQuitMode = LoadOrQuitMode::loadGamePrompt; loadGameArgs.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(loadGameArgs, GameCommands::Flags::apply); } break; case LoadSaveDropdownId::saveGame: // Save game prepareSaveGame(); break; case LoadSaveDropdownId::about: About::open(); break; case LoadSaveDropdownId::options: Options::open(); break; case LoadSaveDropdownId::screenshot: triggerScreenshotCountdown(10, ScreenshotType::regular); break; case LoadSaveDropdownId::giantScreenshot: triggerScreenshotCountdown(10, ScreenshotType::giant); break; case LoadSaveDropdownId::server: startOrCloseServer(); break; case LoadSaveDropdownId::quitToMenu: // Return to title screen { GameCommands::LoadSaveQuitGameArgs quitToMenuArgs{}; quitToMenuArgs.loadQuitMode = LoadOrQuitMode::returnToTitlePrompt; quitToMenuArgs.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(quitToMenuArgs, GameCommands::Flags::apply); } break; case LoadSaveDropdownId::quitToDesktop: // Exit to desktop { GameCommands::LoadSaveQuitGameArgs quitToDesktopArgs{}; quitToDesktopArgs.loadQuitMode = LoadOrQuitMode::quitGamePrompt; quitToDesktopArgs.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(quitToDesktopArgs, GameCommands::Flags::apply); } break; } } // 0x0043B04B static void audioMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { Dropdown::add(0, StringIds::dropdown_without_checkmark, StringIds::menu_mute); Dropdown::add(1, StringIds::dropdown_without_checkmark, StringIds::menu_play_music); Dropdown::add(2, 0); Dropdown::add(3, StringIds::menu_music_options); Dropdown::showBelow(window, widgetIndex, 4, 0); if (!Audio::isAudioEnabled()) { Dropdown::setItemSelected(0); } if (Config::get().audio.playJukeboxMusic) { Dropdown::setItemSelected(1); } Dropdown::setHighlightedItem(0); } // 0x0043B0B8 static void audioMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } switch (itemIndex) { case 0: // "Mute" Audio::toggleSound(); break; case 1: // "Play Music" { auto& config = Config::get().audio; if (config.playJukeboxMusic) { Jukebox::disableMusic(); } else { Jukebox::enableMusic(); } WindowManager::invalidate(WindowType::options); break; } case 3: Options::openMusicSettings(); break; } } static void cheatsMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { Dropdown::add(0, StringIds::cheats); Dropdown::add(1, StringIds::tile_inspector); Dropdown::add(2, StringIds::open_scenario_options); Dropdown::add(3, StringIds::open_object_selection); Dropdown::add(4, 0); Dropdown::add(5, StringIds::dropdown_without_checkmark, StringIds::cheat_enable_sandbox_mode); Dropdown::add(6, StringIds::dropdown_without_checkmark, StringIds::cheat_allow_building_while_paused); Dropdown::add(7, StringIds::dropdown_without_checkmark, StringIds::cheat_allow_manual_driving); Dropdown::showBelow(window, widgetIndex, 8, 0); if (SceneManager::isSandboxMode()) { Dropdown::setItemSelected(5); } if (SceneManager::isPauseOverrideEnabled()) { Dropdown::setItemSelected(6); } if (SceneManager::isDriverCheatEnabled()) { Dropdown::setItemSelected(7); } } static void cheatsMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = 0; } switch (itemIndex) { case 0: Cheats::open(); break; case 1: TileInspector::open(); break; case 2: ScenarioOptions::open(); break; case 3: ObjectSelectionWindow::open(); break; case 5: if (!SceneManager::isSandboxMode()) { SceneManager::addSceneFlags(SceneManager::Flags::sandboxMode); } else { SceneManager::removeSceneFlags(SceneManager::Flags::sandboxMode); } break; case 6: if (!SceneManager::isPauseOverrideEnabled()) { SceneManager::addSceneFlags(SceneManager::Flags::pauseOverrideEnabled); } else { SceneManager::removeSceneFlags(SceneManager::Flags::pauseOverrideEnabled); } break; case 7: if (!SceneManager::isDriverCheatEnabled()) { SceneManager::addSceneFlags(SceneManager::Flags::driverCheatEnabled); } else { SceneManager::removeSceneFlags(SceneManager::Flags::driverCheatEnabled); } break; } } // 0x0043A2B0 static void railroadMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { // Load dropdown objects removing any that are not unlocked. // Note: This is not using player company id! This looks odd. availableTracks = companyGetAvailableRailTracks(GameCommands::getUpdatingCompanyId()); assert(std::size(_availableObjects) >= std::size(availableTracks)); // Legacy copy to available_objects remove when all users of 0x0050A006 accounted for std::copy(std::begin(availableTracks), std::end(availableTracks), std::begin(_availableObjects)); _availableObjects[availableTracks.size()] = std::numeric_limits<uint8_t>::max(); if (availableTracks.size() == 0) { return; } auto companyColour = CompanyManager::getPlayerCompanyColour(); // Add available objects to Dropdown. uint16_t highlightedItem = 0; for (auto i = 0u; i < std::size(availableTracks); i++) { uint32_t objImage; StringId objStringId; auto objIndex = availableTracks[i]; if ((objIndex & (1 << 7)) != 0) { auto road = ObjectManager::get<RoadObject>(objIndex & 0x7F); objStringId = road->name; objImage = Gfx::recolour(road->image, companyColour); } else { auto track = ObjectManager::get<TrackObject>(objIndex); objStringId = track->name; objImage = Gfx::recolour(track->image + TrackObj::ImageIds::kUiPreviewImage0, companyColour); } Dropdown::add(i, StringIds::menu_sprite_stringid_construction, { objImage, objStringId }); if (objIndex == getGameState().lastRailroadOption) { highlightedItem = i; } } Dropdown::showBelow(window, widgetIndex, std::size(availableTracks), 25, (1 << 6)); Dropdown::setHighlightedItem(highlightedItem); } // 0x0043A39F static void railroadMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (itemIndex == -1) { return; } uint8_t objIndex = availableTracks[itemIndex]; Construction::openWithFlags(objIndex); } // 0x0043A965 static void portMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { uint8_t ddIndex = 0; auto interface = ObjectManager::get<InterfaceSkinObject>(); if (getGameState().lastAirport != 0xFF) { Dropdown::add(ddIndex, StringIds::menu_sprite_stringid_construction, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_airport, StringIds::menu_airport }); Dropdown::setMenuOption(ddIndex, 0); ddIndex++; } if (getGameState().lastShipPort != 0xFF) { Dropdown::add(ddIndex, StringIds::menu_sprite_stringid_construction, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_ship_port, StringIds::menu_ship_port }); Dropdown::setMenuOption(ddIndex, 1); ddIndex++; } if (ddIndex == 0) { return; } Dropdown::showBelow(window, widgetIndex, ddIndex, 25, (1 << 6)); ddIndex = 0; if (_lastPortOption != Dropdown::getMenuOption(0)) { ddIndex++; } Dropdown::setHighlightedItem(ddIndex); } // 0x0043AA0A static void portMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } _lastPortOption = Dropdown::getMenuOption(itemIndex); if (_lastPortOption == 0) { Construction::openWithFlags(1U << 31); } else if (_lastPortOption == 1) { Construction::openWithFlags(1U << 30); } } struct VehicleTypeInterfaceParam { uint32_t image; uint32_t buildImage; StringId buildString; StringId numSingular; StringId numPlural; }; // clang-format off static const std::map<VehicleType, VehicleTypeInterfaceParam> VehicleTypeInterfaceParameters{ { VehicleType::bus, { InterfaceSkin::ImageIds::vehicle_buses_frame_0, InterfaceSkin::ImageIds::build_vehicle_bus_frame_0, StringIds::build_buses, StringIds::num_buses_singular, StringIds::num_buses_plural } }, { VehicleType::aircraft, { InterfaceSkin::ImageIds::vehicle_aircraft_frame_0, InterfaceSkin::ImageIds::build_vehicle_aircraft_frame_0, StringIds::build_aircraft, StringIds::num_aircrafts_singular, StringIds::num_aircrafts_plural } }, { VehicleType::ship, { InterfaceSkin::ImageIds::vehicle_ships_frame_0, InterfaceSkin::ImageIds::build_vehicle_ship_frame_0, StringIds::build_ships, StringIds::num_ships_singular, StringIds::num_ships_plural } }, { VehicleType::train, { InterfaceSkin::ImageIds::vehicle_train_frame_0, InterfaceSkin::ImageIds::build_vehicle_train_frame_0, StringIds::build_trains, StringIds::num_trains_singular, StringIds::num_trains_plural } }, { VehicleType::tram, { InterfaceSkin::ImageIds::vehicle_trams_frame_0, InterfaceSkin::ImageIds::build_vehicle_tram_frame_0, StringIds::build_trams, StringIds::num_trams_singular, StringIds::num_trams_plural } }, { VehicleType::truck, { InterfaceSkin::ImageIds::vehicle_trucks_frame_0, InterfaceSkin::ImageIds::build_vehicle_truck_frame_0, StringIds::build_trucks, StringIds::num_trucks_singular, StringIds::num_trucks_plural } }, }; // clang-format on // 0x0043AD1F static void buildVehiclesMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto company = CompanyManager::get(CompanyManager::getControllingId()); uint16_t availableVehicles = company->availableVehicles; auto companyColour = CompanyManager::getPlayerCompanyColour(); auto interface = ObjectManager::get<InterfaceSkinObject>(); uint8_t ddIndex = 0; for (uint8_t vehicleType = 0; vehicleType < vehicleTypeCount; vehicleType++) { if ((availableVehicles & (1 << vehicleType)) == 0) { continue; } auto& interface_param = VehicleTypeInterfaceParameters.at(static_cast<VehicleType>(vehicleType)); uint32_t vehicle_image = Gfx::recolour(interface_param.buildImage, companyColour); Dropdown::add(ddIndex, StringIds::menu_sprite_stringid, { interface->img + vehicle_image, interface_param.buildString }); Dropdown::setMenuOption(ddIndex, vehicleType); ddIndex++; } Dropdown::showBelow(window, widgetIndex, ddIndex, 25, (1 << 6)); Dropdown::setHighlightedItem(enumValue(getGameState().lastBuildVehiclesOption)); } // 0x0043ADC7 static void buildVehiclesMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (itemIndex == -1) { return; } itemIndex = Dropdown::getMenuOption(itemIndex); const auto vehicleType = static_cast<VehicleType>(itemIndex); getGameState().lastBuildVehiclesOption = vehicleType; BuildVehicle::openByType(vehicleType); } // 0x0043ABCB static void vehiclesMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto player_company_id = CompanyManager::getControllingId(); auto company = CompanyManager::get(player_company_id); uint16_t availableVehicles = company->availableVehicles; auto companyColour = CompanyManager::getPlayerCompanyColour(); auto interface = ObjectManager::get<InterfaceSkinObject>(); uint16_t vehicle_counts[vehicleTypeCount]{ 0 }; for (auto* v : VehicleManager::VehicleList()) { if (v->owner != player_company_id) { continue; } if (v->has38Flags(Vehicles::Flags38::isGhost)) { continue; } vehicle_counts[static_cast<uint8_t>(v->vehicleType)]++; } uint8_t ddIndex = 0; for (uint16_t vehicleType = 0; vehicleType < vehicleTypeCount; vehicleType++) { if ((availableVehicles & (1 << vehicleType)) == 0) { continue; } auto& interfaceParam = VehicleTypeInterfaceParameters.at(static_cast<VehicleType>(vehicleType)); uint32_t vehicleImage = Gfx::recolour(interfaceParam.image, companyColour); uint16_t vehicle_count = vehicle_counts[vehicleType]; // TODO: replace with locale-based plurals. StringId vehicleStringId; if (vehicle_count == 1) { vehicleStringId = interfaceParam.numSingular; } else { vehicleStringId = interfaceParam.numPlural; } Dropdown::add(ddIndex, StringIds::menu_sprite_stringid, { interface->img + vehicleImage, vehicleStringId, vehicle_count }); Dropdown::setMenuOption(ddIndex, vehicleType); ddIndex++; } Dropdown::showBelow(window, widgetIndex, ddIndex, 25, (1 << 6)); Dropdown::setHighlightedItem(static_cast<uint8_t>(getGameState().lastVehicleType)); } // 0x0043ACEF static void vehiclesMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (itemIndex == -1) { return; } auto vehicleType = VehicleType(Dropdown::getMenuOption(itemIndex)); getGameState().lastVehicleType = vehicleType; VehicleList::open(CompanyManager::getControllingId(), vehicleType); } // 0x0043A4E9 static void stationsMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto interface = ObjectManager::get<InterfaceSkinObject>(); uint32_t sprite_base = interface->img; // Apply company colour. const auto companyColour = CompanyManager::getPlayerCompanyColour(); sprite_base = Gfx::recolour(sprite_base, companyColour); Dropdown::add(0, StringIds::menu_sprite_stringid, { sprite_base + InterfaceSkin::ImageIds::all_stations, StringIds::all_stations }); Dropdown::add(1, StringIds::menu_sprite_stringid, { sprite_base + InterfaceSkin::ImageIds::rail_stations, StringIds::rail_stations }); Dropdown::add(2, StringIds::menu_sprite_stringid, { sprite_base + InterfaceSkin::ImageIds::road_stations, StringIds::road_stations }); Dropdown::add(3, StringIds::menu_sprite_stringid, { sprite_base + InterfaceSkin::ImageIds::airports, StringIds::airports }); Dropdown::add(4, StringIds::menu_sprite_stringid, { sprite_base + InterfaceSkin::ImageIds::ship_ports, StringIds::ship_ports }); Dropdown::showBelow(window, widgetIndex, 5, 25, (1 << 6)); Dropdown::setHighlightedItem(0); } // 0x0043A596 static void stationsMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (itemIndex > 4) { return; } StationList::open(CompanyManager::getControllingId(), itemIndex); } // 0x0043A071 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::Widx::loadsave_menu: loadsaveMenuMouseDown(&window, widgetIndex); break; case Common::Widx::audio_menu: audioMenuMouseDown(&window, widgetIndex); break; case Widx::cheats_menu: cheatsMenuMouseDown(&window, widgetIndex); break; case Common::Widx::railroad_menu: railroadMenuMouseDown(&window, widgetIndex); break; case Common::Widx::port_menu: portMenuMouseDown(&window, widgetIndex); break; case Common::Widx::build_vehicles_menu: buildVehiclesMenuMouseDown(&window, widgetIndex); break; case Common::Widx::vehicles_menu: vehiclesMenuMouseDown(&window, widgetIndex); break; case Common::Widx::stations_menu: stationsMenuMouseDown(&window, widgetIndex); break; default: Common::onMouseDown(&window, widgetIndex); break; } } static void onDropdown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case Common::Widx::loadsave_menu: loadsaveMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::audio_menu: audioMenuDropdown(&window, widgetIndex, itemIndex); break; case Widx::cheats_menu: cheatsMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::railroad_menu: railroadMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::port_menu: portMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::build_vehicles_menu: buildVehiclesMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::vehicles_menu: vehiclesMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::stations_menu: stationsMenuDropdown(&window, widgetIndex, itemIndex); break; default: Common::onDropdown(&window, widgetIndex, itemIndex); break; } } // 0x00439DE4 static void draw(Window& window, Gfx::DrawingContext& drawingCtx) { Common::draw(window, drawingCtx); const auto companyColour = CompanyManager::getPlayerCompanyColour(); if (!window.widgets[Common::Widx::railroad_menu].hidden) { uint32_t x = window.widgets[Common::Widx::railroad_menu].left + window.x; uint32_t y = window.widgets[Common::Widx::railroad_menu].top + window.y; uint32_t fg_image = 0; // Figure out what icon to show on the button face. uint8_t ebx = getGameState().lastRailroadOption; if ((ebx & (1 << 7)) != 0) { ebx = ebx & ~(1 << 7); auto obj = ObjectManager::get<RoadObject>(ebx); fg_image = Gfx::recolour(obj->image, companyColour); } else { auto obj = ObjectManager::get<TrackObject>(ebx); fg_image = Gfx::recolour(obj->image + TrackObj::ImageIds::kUiPreviewImage0, companyColour); } auto interface = ObjectManager::get<InterfaceSkinObject>(); uint32_t bg_image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_transparent, window.getColour(WindowColour::tertiary).c()); y--; if (Input::isDropdownActive(Ui::WindowType::topToolbar, window.number, Common::Widx::railroad_menu)) { y++; bg_image++; } drawingCtx.drawImage(x, y, fg_image); y = window.widgets[Common::Widx::railroad_menu].top + window.y; drawingCtx.drawImage(x, y, bg_image); } { uint32_t x = window.widgets[Common::Widx::vehicles_menu].left + window.x; uint32_t y = window.widgets[Common::Widx::vehicles_menu].top + window.y; static constexpr uint32_t button_face_image_ids[] = { InterfaceSkin::ImageIds::vehicle_train_frame_0, InterfaceSkin::ImageIds::vehicle_buses_frame_0, InterfaceSkin::ImageIds::vehicle_trucks_frame_0, InterfaceSkin::ImageIds::vehicle_trams_frame_0, InterfaceSkin::ImageIds::vehicle_aircraft_frame_0, InterfaceSkin::ImageIds::vehicle_ships_frame_0, }; auto interface = ObjectManager::get<InterfaceSkinObject>(); uint32_t fg_image = Gfx::recolour(interface->img + button_face_image_ids[static_cast<uint8_t>(getGameState().lastVehicleType)], companyColour); uint32_t bg_image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_transparent, window.getColour(WindowColour::quaternary).c()); y--; if (Input::isDropdownActive(Ui::WindowType::topToolbar, window.number, Common::Widx::vehicles_menu)) { y++; bg_image++; } drawingCtx.drawImage(x, y, fg_image); y = window.widgets[Common::Widx::vehicles_menu].top + window.y; drawingCtx.drawImage(x, y, bg_image); } { uint32_t x = window.widgets[Common::Widx::build_vehicles_menu].left + window.x; uint32_t y = window.widgets[Common::Widx::build_vehicles_menu].top + window.y; static constexpr uint32_t kBuildVehicleImages[] = { InterfaceSkin::ImageIds::toolbar_build_vehicle_train, InterfaceSkin::ImageIds::toolbar_build_vehicle_bus, InterfaceSkin::ImageIds::toolbar_build_vehicle_truck, InterfaceSkin::ImageIds::toolbar_build_vehicle_tram, InterfaceSkin::ImageIds::toolbar_build_vehicle_airplane, InterfaceSkin::ImageIds::toolbar_build_vehicle_boat, }; // Figure out what icon to show on the button face. auto interface = ObjectManager::get<InterfaceSkinObject>(); uint32_t fg_image = Gfx::recolour(interface->img + kBuildVehicleImages[enumValue(getGameState().lastBuildVehiclesOption)], companyColour); if (Input::isDropdownActive(Ui::WindowType::topToolbar, window.number, Common::Widx::build_vehicles_menu)) { fg_image++; } drawingCtx.drawImage(x, y, fg_image); } } // 0x00439BCB static void prepareDraw(Window& window) { auto interface = ObjectManager::get<InterfaceSkinObject>(); if (!Audio::isAudioEnabled()) { window.activatedWidgets |= (1 << Common::Widx::audio_menu); window.widgets[Common::Widx::audio_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_audio_inactive, window.getColour(WindowColour::primary).c()); } else { window.activatedWidgets &= ~(1 << Common::Widx::audio_menu); window.widgets[Common::Widx::audio_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_audio_active, window.getColour(WindowColour::primary).c()); } if (Config::get().cheatsMenuEnabled) { window.widgets[Widx::cheats_menu].hidden = false; auto& baseWidget = window.widgets[Widx::cheats_menu]; window.widgets[Common::Widx::zoom_menu].left = baseWidget.left + 14 + (baseWidget.width() * 1); window.widgets[Common::Widx::rotate_menu].left = baseWidget.left + 14 + (baseWidget.width() * 2); window.widgets[Common::Widx::view_menu].left = baseWidget.left + 14 + (baseWidget.width() * 3); } else { window.widgets[Widx::cheats_menu].hidden = true; auto& baseWidget = window.widgets[Common::Widx::audio_menu]; window.widgets[Common::Widx::zoom_menu].left = baseWidget.left + 14 + (baseWidget.width() * 1); window.widgets[Common::Widx::rotate_menu].left = baseWidget.left + 14 + (baseWidget.width() * 2); window.widgets[Common::Widx::view_menu].left = baseWidget.left + 14 + (baseWidget.width() * 3); } if (_lastPortOption == 0 && getGameState().lastAirport == 0xFF && getGameState().lastShipPort != 0xFF) { _lastPortOption = 1; } window.widgets[Common::Widx::loadsave_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_loadsave); window.widgets[Widx::cheats_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_cogwheels); window.widgets[Common::Widx::zoom_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_zoom); window.widgets[Common::Widx::rotate_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_rotate); window.widgets[Common::Widx::view_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_view); window.widgets[Common::Widx::terraform_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_terraform); window.widgets[Common::Widx::railroad_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_opaque); window.widgets[Common::Widx::road_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_opaque); window.widgets[Common::Widx::port_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_opaque); window.widgets[Common::Widx::build_vehicles_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_opaque); window.widgets[Common::Widx::vehicles_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_opaque); window.widgets[Common::Widx::stations_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_stations); if (_lastTownOption == 0) { window.widgets[Common::Widx::towns_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_towns); } else { window.widgets[Common::Widx::towns_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_industries); } if (_lastPortOption == 0) { window.widgets[Common::Widx::port_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_airports); } else { window.widgets[Common::Widx::port_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_ports); } window.widgets[Common::Widx::road_menu].hidden = !(getGameState().lastRoadOption != 0xFF); window.widgets[Common::Widx::railroad_menu].hidden = !(getGameState().lastRailroadOption != 0xFF); window.widgets[Common::Widx::port_menu].hidden = !(getGameState().lastAirport != 0xFF || getGameState().lastShipPort != 0xFF); uint32_t x = std::max(640, Ui::width()) - 1; Common::rightAlignTabs(&window, x, { Common::Widx::towns_menu, Common::Widx::stations_menu, Common::Widx::vehicles_menu }); x -= 11; Common::rightAlignTabs(&window, x, { Common::Widx::build_vehicles_menu }); if (!window.widgets[Common::Widx::port_menu].hidden) { Common::rightAlignTabs(&window, x, { Common::Widx::port_menu }); } if (!window.widgets[Common::Widx::road_menu].hidden) { Common::rightAlignTabs(&window, x, { Common::Widx::road_menu }); } if (!window.widgets[Common::Widx::railroad_menu].hidden) { Common::rightAlignTabs(&window, x, { Common::Widx::railroad_menu }); } Common::rightAlignTabs(&window, x, { Common::Widx::terraform_menu }); } static constexpr WindowEventList kEvents = { .onResize = Common::onResize, .onMouseHover = onMouseDown, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::onUpdate, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ToolbarTopAlt.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "EditorController.h" #include "Entities/EntityManager.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "GameCommands/General/LoadSaveQuit.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Input.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/WaterObject.h" #include "ScenarioOptions.h" #include "ToolbarTopCommon.h" #include "Ui/Dropdown.h" #include "Ui/Screenshot.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::ToolbarTop::Editor { static loco_global<uint8_t, 0x009C870C> _lastTownOption; namespace Widx { enum { map_generation_menu = Common::Widx::w2, }; } static constexpr auto _widgets = makeWidgets( Widgets::ImageButton({ 0, 0 }, { 30, 28 }, WindowColour::primary), // 0 Widgets::ImageButton({ 30, 0 }, { 30, 28 }, WindowColour::primary), // 1 Widgets::ImageButton({ 60, 0 }, { 30, 28 }, WindowColour::primary), // 2 Widgets::ImageButton({ 104, 0 }, { 30, 28 }, WindowColour::secondary), // 3 Widgets::ImageButton({ 134, 0 }, { 30, 28 }, WindowColour::secondary), // 4 Widgets::ImageButton({ 164, 0 }, { 30, 28 }, WindowColour::secondary), // 5 Widgets::ImageButton({ 267, 0 }, { 30, 28 }, WindowColour::tertiary), // 6 Widgets::ImageButton({ 0, 0 }, { 1, 1 }, WindowColour::primary), // 7 Widgets::ImageButton({ 357, 0 }, { 30, 28 }, WindowColour::tertiary), // 8 Widgets::ImageButton({ 0, 0 }, { 1, 1 }, WindowColour::primary), // 9 Widgets::ImageButton({ 0, 0 }, { 1, 1 }, WindowColour::primary), // 10 Widgets::ImageButton({ 0, 0 }, { 1, 1 }, WindowColour::primary), // 11 Widgets::ImageButton({ 0, 0 }, { 1, 1 }, WindowColour::primary), // 12 Widgets::ImageButton({ 460, 0 }, { 30, 28 }, WindowColour::quaternary) // 13 ); static const WindowEventList& getEvents(); // 0x0043CC2C void open() { auto window = WindowManager::createWindow( WindowType::topToolbar, { 0, 0 }, { Ui::width(), 28 }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground, getEvents()); window->setWidgets(_widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, Colour::grey); window->setColour(WindowColour::secondary, Colour::grey); window->setColour(WindowColour::tertiary, Colour::grey); window->setColour(WindowColour::quaternary, Colour::grey); auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, skin->topToolbarPrimaryColour); window->setColour(WindowColour::secondary, skin->topToolbarSecondaryColour); window->setColour(WindowColour::tertiary, skin->topToolbarTertiaryColour); window->setColour(WindowColour::quaternary, skin->topToolbarQuaternaryColour); } } // 0x0043D638 static void loadsaveMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { Dropdown::add(0, StringIds::load_landscape); Dropdown::add(1, StringIds::save_landscape); Dropdown::add(2, 0); Dropdown::add(3, StringIds::menu_about); Dropdown::add(4, StringIds::options); Dropdown::add(5, StringIds::menu_screenshot); Dropdown::add(6, StringIds::menu_giant_screenshot); Dropdown::add(7, 0); Dropdown::add(8, StringIds::menu_quit_to_menu); Dropdown::add(9, StringIds::menu_exit_openloco); Dropdown::showBelow(window, widgetIndex, 9, 0); Dropdown::setHighlightedItem(1); } // 0x0043D695 static void loadsaveMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } switch (itemIndex) { case 0: // Load Landscape { GameCommands::LoadSaveQuitGameArgs args{}; args.loadQuitMode = LoadOrQuitMode::loadGamePrompt; args.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(args, GameCommands::Flags::apply); } break; case 1: { if (Scenario::getOptions().editorStep == EditorController::Step::objectSelection) { if (!ObjectSelectionWindow::tryCloseWindow()) { // Try close has failed so do not open save window! return; } } WindowManager::closeAllFloatingWindows(); ToolManager::toolCancel(); // Save Landscape if (auto res = OpenLoco::Game::saveLandscapeOpen()) { OpenLoco::Game::saveLandscape(*res); Gfx::invalidateScreen(); } break; } case 3: About::open(); break; case 4: Options::open(); break; case 5: triggerScreenshotCountdown(10, ScreenshotType::regular); break; case 6: triggerScreenshotCountdown(10, ScreenshotType::giant); break; case 8: // Return to title screen { GameCommands::LoadSaveQuitGameArgs quitToMenuArgs{}; quitToMenuArgs.loadQuitMode = LoadOrQuitMode::returnToTitlePrompt; quitToMenuArgs.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(quitToMenuArgs, GameCommands::Flags::apply); } break; case 9: // Exit to desktop { GameCommands::LoadSaveQuitGameArgs quitToDesktopArgs{}; quitToDesktopArgs.loadQuitMode = LoadOrQuitMode::quitGamePrompt; quitToDesktopArgs.saveMode = GameCommands::LoadSaveQuitGameArgs::SaveMode::promptSave; GameCommands::doCommand(quitToDesktopArgs, GameCommands::Flags::apply); } break; } } // 0x0043D789 static void audioMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { Dropdown::add(0, StringIds::dropdown_without_checkmark, StringIds::menu_mute); Dropdown::showBelow(window, widgetIndex, 1, 0); if (!Audio::isAudioEnabled()) { Dropdown::setItemSelected(0); } Dropdown::setHighlightedItem(0); } // 0x0043D7C1 static void audioMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } switch (itemIndex) { case 0: Audio::toggleSound(); break; } } // 0x004402BC static void mapGenerationMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { Dropdown::add(0, StringIds::landscape_generation_options); auto numItems = 1; if (Config::get().cheatsMenuEnabled) { Dropdown::add(1, StringIds::tile_inspector); numItems += 1; } Dropdown::showBelow(window, widgetIndex, numItems, 0); Dropdown::setHighlightedItem(0); } // 0x004402DA static void mapGenerationMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } switch (itemIndex) { case 0: Windows::LandscapeGeneration::open(); break; case 1: TileInspector::open(); break; } } // 0x0043D541 static void onMouseDown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::Widx::loadsave_menu: loadsaveMenuMouseDown(&window, widgetIndex); break; case Common::Widx::audio_menu: audioMenuMouseDown(&window, widgetIndex); break; case Widx::map_generation_menu: mapGenerationMenuMouseDown(&window, widgetIndex); break; default: Common::onMouseDown(&window, widgetIndex); break; } } // 0x0043D5A6 static void onDropdown(Window& window, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { switch (widgetIndex) { case Common::Widx::loadsave_menu: loadsaveMenuDropdown(&window, widgetIndex, itemIndex); break; case Common::Widx::audio_menu: audioMenuDropdown(&window, widgetIndex, itemIndex); break; case Widx::map_generation_menu: mapGenerationMenuDropdown(&window, widgetIndex, itemIndex); break; default: Common::onDropdown(&window, widgetIndex, itemIndex); break; } } // 0x0043D2F3 static void prepareDraw(Window& window) { uint32_t x = std::max(640, Ui::width()) - 1; Common::rightAlignTabs(&window, x, { Common::Widx::towns_menu }); x -= 11; Common::rightAlignTabs(&window, x, { Common::Widx::road_menu, Common::Widx::terraform_menu }); const bool isLandscapeEditor = EditorController::getCurrentStep() == EditorController::Step::landscapeEditor; window.widgets[Common::Widx::zoom_menu].hidden = !isLandscapeEditor; window.widgets[Common::Widx::rotate_menu].hidden = !isLandscapeEditor; window.widgets[Common::Widx::view_menu].hidden = !isLandscapeEditor; window.widgets[Common::Widx::terraform_menu].hidden = !isLandscapeEditor; window.widgets[Widx::map_generation_menu].hidden = !isLandscapeEditor; window.widgets[Common::Widx::towns_menu].hidden = !isLandscapeEditor; window.widgets[Common::Widx::road_menu].hidden = !(isLandscapeEditor && getGameState().lastRoadOption != 0xFF); auto interface = ObjectManager::get<InterfaceSkinObject>(); if (!Audio::isAudioEnabled()) { window.activatedWidgets |= (1 << Common::Widx::audio_menu); window.widgets[Common::Widx::audio_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_audio_inactive, window.getColour(WindowColour::primary).c()); } else { window.activatedWidgets &= ~(1 << Common::Widx::audio_menu); window.widgets[Common::Widx::audio_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_audio_active, window.getColour(WindowColour::primary).c()); } window.widgets[Common::Widx::loadsave_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_loadsave); window.widgets[Common::Widx::zoom_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_zoom); window.widgets[Common::Widx::rotate_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_rotate); window.widgets[Common::Widx::view_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_view); window.widgets[Common::Widx::terraform_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_terraform); window.widgets[Widx::map_generation_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_cogwheels); window.widgets[Common::Widx::road_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_opaque); if (_lastTownOption == 0) { window.widgets[Common::Widx::towns_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_towns); } else { window.widgets[Common::Widx::towns_menu].image = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_industries); } } static constexpr WindowEventList kEvents = { .onResize = Common::onResize, .onMouseHover = onMouseDown, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = Common::onUpdate, .prepareDraw = prepareDraw, .draw = Common::draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ToolbarTopCommon.cpp ```cpp #include "ToolbarTopCommon.h" #include "Audio/Audio.h" #include "Config.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Input.h" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Objects/WaterObject.h" #include "Ui/Dropdown.h" #include "Ui/Widget.h" #include "Vehicles/Vehicle.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <map> using namespace OpenLoco::Interop; namespace OpenLoco::Ui::Windows::ToolbarTop::Common { static loco_global<uint32_t, 0x009C86F8> _zoomTicks; static loco_global<uint8_t, 0x009C870C> _lastTownOption; static loco_global<uint8_t[18], 0x0050A006> _availableObjects; // 0x00439DE4 void draw(Window& self, Gfx::DrawingContext& drawingCtx) { // Draw widgets. self.draw(drawingCtx); const auto companyColour = CompanyManager::getPlayerCompanyColour(); auto lastRoadOption = getGameState().lastRoadOption; if (!self.widgets[Widx::road_menu].hidden && lastRoadOption != 0xFF) { uint32_t x = self.widgets[Widx::road_menu].left + self.x; uint32_t y = self.widgets[Widx::road_menu].top + self.y; uint32_t fgImage = 0; // Figure out what icon to show on the button face. bool isRoad = lastRoadOption & (1 << 7); if (isRoad) { auto obj = ObjectManager::get<RoadObject>(lastRoadOption & ~(1 << 7)); fgImage = Gfx::recolour(obj->image, companyColour); } else { auto obj = ObjectManager::get<TrackObject>(lastRoadOption); fgImage = Gfx::recolour(obj->image + TrackObj::ImageIds::kUiPreviewImage0, companyColour); } y--; auto interface = ObjectManager::get<InterfaceSkinObject>(); uint32_t bgImage = Gfx::recolour(interface->img + InterfaceSkin::ImageIds::toolbar_empty_transparent, self.getColour(WindowColour::tertiary).c()); if (Input::isDropdownActive(Ui::WindowType::topToolbar, self.number, Widx::road_menu)) { y++; bgImage++; } drawingCtx.drawImage(x, y, fgImage); y = self.widgets[Widx::road_menu].top + self.y; drawingCtx.drawImage(x, y, bgImage); } } // 0x0043A78E void zoomMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto interface = ObjectManager::get<InterfaceSkinObject>(); Dropdown::add(0, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_zoom_in, StringIds::menu_zoom_in }); Dropdown::add(1, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_zoom_out, StringIds::menu_zoom_out }); static constexpr uint32_t kMapSpritesByRotation[] = { InterfaceSkin::ImageIds::toolbar_menu_map_north, InterfaceSkin::ImageIds::toolbar_menu_map_west, InterfaceSkin::ImageIds::toolbar_menu_map_south, InterfaceSkin::ImageIds::toolbar_menu_map_east, }; uint32_t mapSprite = kMapSpritesByRotation[WindowManager::getCurrentRotation()]; Dropdown::add(2, StringIds::menu_sprite_stringid, { interface->img + mapSprite, StringIds::menu_map }); Dropdown::showBelow(window, widgetIndex, 3, 25, (1 << 6)); Dropdown::setHighlightedItem(0); auto mainWindow = WindowManager::getMainWindow(); if (mainWindow->viewports[0]->zoom == 0) { Dropdown::setItemDisabled(0); Dropdown::setHighlightedItem(1); } if (mainWindow->viewports[0]->zoom == 3) { Dropdown::setItemDisabled(1); _zoomTicks = 1000; } if (mainWindow->viewports[0]->zoom != 3 && _zoomTicks <= 32) { Dropdown::setHighlightedItem(1); } } // 0x0043A5C5 void rotateMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto interface = ObjectManager::get<InterfaceSkinObject>(); Dropdown::add(0, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_rotate_clockwise, StringIds::menu_rotate_clockwise }); Dropdown::add(1, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_rotate_anti_clockwise, StringIds::menu_rotate_anti_clockwise }); Dropdown::showBelow(window, widgetIndex, 2, 25, (1 << 6)); Dropdown::setHighlightedItem(0); } // 0x0043ADF6 void viewMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { Dropdown::add(0, StringIds::dropdown_without_checkmark, StringIds::menu_underground_view); Dropdown::add(1, StringIds::dropdown_without_checkmark, StringIds::menuSeeThroughTracks); Dropdown::add(2, StringIds::dropdown_without_checkmark, StringIds::menuSeeThroughRoads); Dropdown::add(3, StringIds::dropdown_without_checkmark, StringIds::menuSeeThroughTrees); Dropdown::add(4, StringIds::dropdown_without_checkmark, StringIds::menuSeeThroughBuildings); Dropdown::add(5, StringIds::dropdown_without_checkmark, StringIds::menuSeeThroughScenery); Dropdown::add(6, StringIds::dropdown_without_checkmark, StringIds::menuSeeThroughBridges); Dropdown::add(7, 0); Dropdown::add(8, StringIds::dropdown_without_checkmark, StringIds::menu_height_marks_on_land); Dropdown::add(9, StringIds::dropdown_without_checkmark, StringIds::menu_height_marks_on_tracks_roads); Dropdown::add(10, StringIds::dropdown_without_checkmark, StringIds::menu_one_way_direction_arrows); Dropdown::add(11, 0); Dropdown::add(12, StringIds::dropdown_without_checkmark, StringIds::menu_town_names_displayed); Dropdown::add(13, StringIds::dropdown_without_checkmark, StringIds::menu_station_names_displayed); Dropdown::showBelow(window, widgetIndex, 14, 0); ViewportFlags current_viewport_flags = WindowManager::getMainWindow()->viewports[0]->flags; if ((current_viewport_flags & ViewportFlags::underground_view) != ViewportFlags::none) { Dropdown::setItemSelected(0); } if ((current_viewport_flags & ViewportFlags::seeThroughTracks) != ViewportFlags::none) { Dropdown::setItemSelected(1); } if ((current_viewport_flags & ViewportFlags::seeThroughRoads) != ViewportFlags::none) { Dropdown::setItemSelected(2); } if ((current_viewport_flags & ViewportFlags::seeThroughTrees) != ViewportFlags::none) { Dropdown::setItemSelected(3); } if ((current_viewport_flags & ViewportFlags::seeThroughBuildings) != ViewportFlags::none) { Dropdown::setItemSelected(4); } if ((current_viewport_flags & ViewportFlags::seeThroughScenery) != ViewportFlags::none) { Dropdown::setItemSelected(5); } if ((current_viewport_flags & ViewportFlags::seeThroughBridges) != ViewportFlags::none) { Dropdown::setItemSelected(6); } if ((current_viewport_flags & ViewportFlags::height_marks_on_land) != ViewportFlags::none) { Dropdown::setItemSelected(8); } if ((current_viewport_flags & ViewportFlags::height_marks_on_tracks_roads) != ViewportFlags::none) { Dropdown::setItemSelected(9); } if ((current_viewport_flags & ViewportFlags::one_way_direction_arrows) != ViewportFlags::none) { Dropdown::setItemSelected(10); } if ((current_viewport_flags & ViewportFlags::town_names_displayed) == ViewportFlags::none) { Dropdown::setItemSelected(12); } if ((current_viewport_flags & ViewportFlags::station_names_displayed) == ViewportFlags::none) { Dropdown::setItemSelected(13); } Dropdown::setHighlightedItem(0); } // 0x0043A3C3 void terraformMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto interface = ObjectManager::get<InterfaceSkinObject>(); auto land = ObjectManager::get<LandObject>(getGameState().lastLandOption); auto water = ObjectManager::get<WaterObject>(); Dropdown::add(0, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_bulldozer, StringIds::menu_clear_area }); Dropdown::add(1, StringIds::menu_sprite_stringid, { land->mapPixelImage + Land::ImageIds::toolbar_terraform_land, StringIds::menu_adjust_land }); Dropdown::add(2, StringIds::menu_sprite_stringid, { water->image + Water::ImageIds::kToolbarTerraformWater, StringIds::menu_adjust_water }); Dropdown::add(3, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_plant_trees, StringIds::menu_plant_trees }); Dropdown::add(4, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_build_walls, StringIds::menu_build_walls }); Dropdown::showBelow(window, widgetIndex, 5, 25, (1 << 6)); Dropdown::setHighlightedItem(0); } // 0x0043A19F void roadMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { const auto availableObjects = companyGetAvailableRoads(CompanyManager::getControllingId()); // Copy to global as its used in the dropdown event std::copy(availableObjects.begin(), availableObjects.end(), _availableObjects.begin()); // Sanity check: any objects available? if (availableObjects.empty()) { return; } auto companyColour = CompanyManager::getPlayerCompanyColour(); // Add available objects to Dropdown. uint16_t highlightedItem = 0; for (auto i = 0U; i < std::size(availableObjects); i++) { uint32_t objImage; StringId objStringId; auto objIndex = availableObjects[i]; if ((objIndex & (1 << 7)) != 0) { auto road = ObjectManager::get<RoadObject>(objIndex & 0x7F); objStringId = road->name; objImage = Gfx::recolour(road->image, companyColour); } else { auto track = ObjectManager::get<TrackObject>(objIndex); objStringId = track->name; objImage = Gfx::recolour(track->image + TrackObj::ImageIds::kUiPreviewImage0, companyColour); } Dropdown::add(i, StringIds::menu_sprite_stringid_construction, { objImage, objStringId }); if (objIndex == getGameState().lastRoadOption) { highlightedItem = i; } } Dropdown::showBelow(window, widgetIndex, std::size(availableObjects), 25, (1 << 6)); Dropdown::setHighlightedItem(highlightedItem); } // 0x0043A8CE void townsMenuMouseDown(Window* window, WidgetIndex_t widgetIndex) { auto interface = ObjectManager::get<InterfaceSkinObject>(); Dropdown::add(0, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_towns, StringIds::menu_towns }); Dropdown::add(1, StringIds::menu_sprite_stringid, { interface->img + InterfaceSkin::ImageIds::toolbar_menu_industries, StringIds::menu_industries }); Dropdown::showBelow(window, widgetIndex, 2, 25, (1 << 6)); Dropdown::setHighlightedItem(_lastTownOption); } // 0x0043A86D void zoomMenuDropdown(Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } window = WindowManager::getMainWindow(); if (itemIndex == 0) { window->viewportZoomIn(false); TownManager::updateLabels(); StationManager::updateLabels(); } else if (itemIndex == 1) { _zoomTicks = 0; window->viewportZoomOut(false); TownManager::updateLabels(); StationManager::updateLabels(); } else if (itemIndex == 2) { MapWindow::open(); } } // 0x0043A624 void rotateMenuDropdown(Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } auto mouseButtonUsed = Input::getLastKnownButtonState(); window = WindowManager::getMainWindow(); if (itemIndex == 1 || mouseButtonUsed == Input::MouseButton::rightPressed) { window->viewportRotateLeft(); TownManager::updateLabels(); StationManager::updateLabels(); MapWindow::centerOnViewPoint(); } else if (itemIndex == 0) { window->viewportRotateRight(); TownManager::updateLabels(); StationManager::updateLabels(); MapWindow::centerOnViewPoint(); } } // 0x0043AF37 void viewMenuDropdown(Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } window = WindowManager::getMainWindow(); auto viewport = WindowManager::getMainWindow()->viewports[0]; if (itemIndex == 0) { viewport->flags ^= ViewportFlags::underground_view; } else if (itemIndex == 1) { viewport->flags ^= ViewportFlags::seeThroughTracks; } else if (itemIndex == 2) { viewport->flags ^= ViewportFlags::seeThroughRoads; } else if (itemIndex == 3) { viewport->flags ^= ViewportFlags::seeThroughTrees; } else if (itemIndex == 4) { viewport->flags ^= ViewportFlags::seeThroughBuildings; } else if (itemIndex == 5) { viewport->flags ^= ViewportFlags::seeThroughScenery; } else if (itemIndex == 6) { viewport->flags ^= ViewportFlags::seeThroughBridges; } else if (itemIndex == 8) { viewport->flags ^= ViewportFlags::height_marks_on_land; } else if (itemIndex == 9) { viewport->flags ^= ViewportFlags::height_marks_on_tracks_roads; } else if (itemIndex == 10) { viewport->flags ^= ViewportFlags::one_way_direction_arrows; } else if (itemIndex == 12) { viewport->flags ^= ViewportFlags::town_names_displayed; } else if (itemIndex == 13) { viewport->flags ^= ViewportFlags::station_names_displayed; } window->invalidate(); } // 0x0043A4A8 void terraformMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } switch (itemIndex) { case 0: Terraform::openClearArea(); break; case 1: Terraform::openAdjustLand(); break; case 2: Terraform::openAdjustWater(); break; case 3: Terraform::openPlantTrees(); break; case 4: Terraform::openBuildWalls(); break; } } // 0x0043A28C void roadMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (itemIndex == -1) { return; } uint8_t objIndex = _availableObjects[itemIndex]; Construction::openWithFlags(objIndex); } // 0x0043A932 void townsMenuDropdown([[maybe_unused]] Window* window, [[maybe_unused]] WidgetIndex_t widgetIndex, int16_t itemIndex) { if (itemIndex == -1) { itemIndex = Dropdown::getHighlightedItem(); } if (itemIndex == 0) { TownList::open(); _lastTownOption = 0; } else if (itemIndex == 1) { IndustryList::open(); _lastTownOption = 1; } } void onDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex) { switch (widgetIndex) { case Widx::zoom_menu: zoomMenuDropdown(window, widgetIndex, itemIndex); break; case Widx::rotate_menu: rotateMenuDropdown(window, widgetIndex, itemIndex); break; case Widx::view_menu: viewMenuDropdown(window, widgetIndex, itemIndex); break; case Widx::terraform_menu: terraformMenuDropdown(window, widgetIndex, itemIndex); break; case Widx::road_menu: roadMenuDropdown(window, widgetIndex, itemIndex); break; case Widx::towns_menu: townsMenuDropdown(window, widgetIndex, itemIndex); break; } } // 0x0043A071 void onMouseDown(Window* window, WidgetIndex_t widgetIndex) { switch (widgetIndex) { case Widx::zoom_menu: zoomMenuMouseDown(window, widgetIndex); break; case Widx::rotate_menu: rotateMenuMouseDown(window, widgetIndex); break; case Widx::view_menu: viewMenuMouseDown(window, widgetIndex); break; case Widx::terraform_menu: terraformMenuMouseDown(window, widgetIndex); break; case Widx::road_menu: roadMenuMouseDown(window, widgetIndex); break; case Widx::towns_menu: townsMenuMouseDown(window, widgetIndex); break; } } void onUpdate([[maybe_unused]] Window& window) { _zoomTicks++; } // 0x0043A17E void onResize(Window& window) { auto main = WindowManager::getMainWindow(); if (main == nullptr) { window.setDisabledWidgetsAndInvalidate(Widx::zoom_menu | Widx::rotate_menu); } else { window.setDisabledWidgetsAndInvalidate(0); } } void rightAlignTabs(Window* window, uint32_t& x, const std::initializer_list<uint32_t> widxs) { for (const auto& widx : widxs) { window->widgets[widx].right = x; window->widgets[widx].left = x - 29; x -= 30; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/ToolbarTopCommon.h ```h #pragma once #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::ToolbarTop::Common { namespace Widx { enum { loadsave_menu, audio_menu, w2, zoom_menu, rotate_menu, view_menu, terraform_menu, railroad_menu, road_menu, port_menu, build_vehicles_menu, vehicles_menu, stations_menu, towns_menu, }; } void draw(Window& window, Gfx::DrawingContext& drawingCtx); void zoomMenuMouseDown(Window* window, WidgetIndex_t widgetIndex); void rotateMenuMouseDown(Window* window, WidgetIndex_t widgetIndex); void viewMenuMouseDown(Window* window, WidgetIndex_t widgetIndex); void terraformMenuMouseDown(Window* window, WidgetIndex_t widgetIndex); void roadMenuMouseDown(Window* window, WidgetIndex_t widgetIndex); void townsMenuMouseDown(Window* window, WidgetIndex_t widgetIndex); void zoomMenuDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void rotateMenuDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void viewMenuDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void terraformMenuDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void roadMenuDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void townsMenuDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void onUpdate(Window& window); void onResize(Window& window); void onMouseDown(Window* window, WidgetIndex_t widgetIndex); void onDropdown(Window* window, WidgetIndex_t widgetIndex, int16_t itemIndex); void rightAlignTabs(Window* window, uint32_t& x, const std::initializer_list<uint32_t> widxs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TownList.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "GameCommands/Buildings/CreateBuilding.h" #include "GameCommands/Buildings/RemoveBuilding.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Town/CreateTown.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/MapSelection.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/ColourButtonWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include "World/Town.h" #include "World/TownManager.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::Ui::Windows::TownList { static currency32_t _buildingPlacementCost; // 0x01135C34 static World::Pos3 _buildingGhostPos; // 0x01135C50 static bool _buildingGhostPlaced; // 0x01135C60 static Colour _buildingColour; // 0x01135C61 static uint8_t _buildingGhostType; // 0x01135C62 static uint8_t _buildingRotation; // 0x01135C63 static uint8_t _buildingGhostRotation; // 0x01135C64 static uint8_t _buildingVariation; // 0x01135C65 static uint8_t _townSize; // 0x01135C66 namespace Common { enum widx { frame, caption, close_button, panel, tab_town_list, tab_build_town, tab_build_buildings, tab_build_misc_buildings, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 155 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_town_list), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_town), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_buildings), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_build_misc_buildings)); } static void prepareDraw(Window& self); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void refreshTownList(Window& self); } namespace TownList { static constexpr Ui::Size32 kWindowSize = { 600, 197 }; static constexpr Ui::Size kMaxDimensions = { 600, 900 }; static constexpr Ui::Size kMinDimensions = { 192, 100 }; static constexpr uint8_t kRowHeight = 10; enum widx { sort_town_name = 8, sort_town_type, sort_town_population, sort_town_stations, scrollview, status_bar, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(600, 197, StringIds::title_towns), Widgets::TableHeader({ 4, 43 }, { 200, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_name), Widgets::TableHeader({ 204, 43 }, { 80, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_town_type), Widgets::TableHeader({ 284, 43 }, { 70, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_population), Widgets::TableHeader({ 354, 43 }, { 70, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_stations), Widgets::ScrollView({ 3, 56 }, { 594, 126 }, WindowColour::secondary, 2), Widgets::Label({ 4, kWindowSize.height - 17 }, { kWindowSize.width, 10 }, WindowColour::secondary, ContentAlign::left, StringIds::black_stringid) ); enum SortMode : uint16_t { Name, Type, Population, Stations, }; // 0x00499F53 static void prepareDraw(Ui::Window& self) { Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 4; self.widgets[widx::scrollview].bottom = self.height - 14; // Reposition header buttons self.widgets[widx::sort_town_name].right = std::min(203, self.width - 8); self.widgets[widx::sort_town_type].left = std::min(204, self.width - 8); self.widgets[widx::sort_town_type].right = std::min(283, self.width - 8); self.widgets[widx::sort_town_population].left = std::min(284, self.width - 8); self.widgets[widx::sort_town_population].right = std::min(353, self.width - 8); self.widgets[widx::sort_town_stations].left = std::min(354, self.width - 8); self.widgets[widx::sort_town_stations].right = std::min(423, self.width - 8); // Set header button captions self.widgets[widx::sort_town_name].text = self.sortMode == SortMode::Name ? StringIds::table_header_name_desc : StringIds::table_header_name; self.widgets[widx::sort_town_type].text = self.sortMode == SortMode::Type ? StringIds::table_header_town_type_desc : StringIds::table_header_town_type; self.widgets[widx::sort_town_population].text = self.sortMode == SortMode::Population ? StringIds::table_header_population_desc : StringIds::table_header_population; self.widgets[widx::sort_town_stations].text = self.sortMode == SortMode::Stations ? StringIds::table_header_stations_desc : StringIds::table_header_stations; Widget::leftAlignTabs(self, Common::widx::tab_town_list, Common::widx::tab_build_misc_buildings); // Reposition status bar auto& widget = self.widgets[widx::status_bar]; widget.top = self.height - 12; widget.bottom = self.height - 2; // Set status bar text FormatArguments args{ widget.textArgs }; args.push(self.var_83C == 1 ? StringIds::status_towns_singular : StringIds::status_towns_plural); args.push(self.var_83C); } // 0x0049A0F8 static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 3); drawingCtx.clearSingle(shade); uint16_t yPos = 0; for (uint16_t i = 0; i < self.var_83C; i++) { const auto townId = TownId(self.rowInfo[i]); // Skip items outside of view, or irrelevant to the current filter. if (yPos + kRowHeight < rt.y || yPos >= yPos + kRowHeight + rt.height || townId == TownId::null) { yPos += kRowHeight; continue; } StringId text_colour_id = StringIds::black_stringid; // Highlight selection. if (townId == TownId(self.rowHover)) { drawingCtx.drawRect(0, yPos, self.width, kRowHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); text_colour_id = StringIds::wcolour2_stringid; } if (townId == TownId::null) { continue; } auto town = TownManager::get(townId); // Town Name { FormatArguments args{}; args.push(town->name); auto point = Point(0, yPos); tr.drawStringLeftClipped(point, 198, Colour::black, text_colour_id, args); } // Town Type { FormatArguments args{}; args.push(town->getTownSizeString()); auto point = Point(200, yPos); tr.drawStringLeftClipped(point, 278, Colour::black, text_colour_id, args); } // Town Population { FormatArguments args{}; args.push(StringIds::int_32); args.push(town->population); auto point = Point(280, yPos); tr.drawStringLeftClipped(point, 68, Colour::black, text_colour_id, args); } // Town Stations { FormatArguments args{}; args.push(StringIds::int_32); args.push<int32_t>(town->numStations); auto point = Point(350, yPos); tr.drawStringLeftClipped(point, 68, Colour::black, text_colour_id, args); } yPos += kRowHeight; } } // 0x0049A0A7 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); } // 0x0049A27F static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_town_list: case Common::widx::tab_build_town: case Common::widx::tab_build_buildings: case Common::widx::tab_build_misc_buildings: Common::switchTab(self, widgetIndex); break; case widx::sort_town_name: case widx::sort_town_type: case widx::sort_town_population: case widx::sort_town_stations: { auto sortMode = widgetIndex - widx::sort_town_name; if (self.sortMode == sortMode) { return; } self.sortMode = sortMode; self.invalidate(); self.var_83C = 0; self.rowHover = -1; Common::refreshTownList(self); break; } } } // 0x0049A56D static void onScrollMouseDown(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentRow = y / kRowHeight; if (currentRow > self.var_83C) { return; } int16_t currentTown = self.rowInfo[currentRow]; if (currentTown == -1) { return; } Town::open(currentTown); } // 0x0049A532 static void onScrollMouseOver(Ui::Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { self.flags &= ~(WindowFlags::notScrollView); uint16_t currentRow = y / kRowHeight; int16_t currentTown = -1; if (currentRow < self.var_83C) { currentTown = self.rowInfo[currentRow]; } if (self.rowHover == currentTown) { return; } self.rowHover = currentTown; self.invalidate(); } // 0x00499EC9 static bool orderByName(const OpenLoco::Town& lhs, const OpenLoco::Town& rhs) { char lhsString[256] = { 0 }; StringManager::formatString(lhsString, lhs.name); char rhsString[256] = { 0 }; StringManager::formatString(rhsString, rhs.name); return strcmp(lhsString, rhsString) < 0; } // 0x00499F28 static bool orderByPopulation(const OpenLoco::Town& lhs, const OpenLoco::Town& rhs) { auto lhsPopulation = lhs.population; auto rhsPopulation = rhs.population; return rhsPopulation < lhsPopulation; } // 0x00499F0A Left this in to match the x86 code. can be replaced with orderByPopulation static bool orderByType(const OpenLoco::Town& lhs, const OpenLoco::Town& rhs) { auto lhsSize = lhs.size; auto rhsSize = rhs.size; if (rhsSize != lhsSize) { return rhsSize < lhsSize; } else { return orderByPopulation(lhs, rhs); } } // 0x00499F3B static bool orderByStations(const OpenLoco::Town& lhs, const OpenLoco::Town& rhs) { auto lhsStations = lhs.numStations; auto rhsStations = rhs.numStations; return rhsStations < lhsStations; } // 0x00499EC9, 0x00499F0A, 0x00499F28, 0x00499F3B static bool getOrder(const SortMode mode, OpenLoco::Town& lhs, OpenLoco::Town& rhs) { switch (mode) { case SortMode::Name: return orderByName(lhs, rhs); case SortMode::Type: return orderByType(lhs, rhs); case SortMode::Population: return orderByPopulation(lhs, rhs); case SortMode::Stations: return orderByStations(lhs, rhs); } return false; } // 0x00499E0B static void updateTownList(Window& self) { TownId chosenTown = TownId::null; for (auto& town : TownManager::towns()) { if ((town.flags & TownFlags::sorted) != TownFlags::none) { continue; } if (chosenTown == TownId::null) { chosenTown = town.id(); continue; } if (getOrder(SortMode(self.sortMode), town, *TownManager::get(chosenTown))) { chosenTown = town.id(); } } if (chosenTown != TownId::null) { bool shouldInvalidate = false; TownManager::get(chosenTown)->flags |= TownFlags::sorted; if (chosenTown != TownId(self.rowInfo[self.rowCount])) { self.rowInfo[self.rowCount] = enumValue(chosenTown); shouldInvalidate = true; } self.rowCount += 1; if (self.rowCount > self.var_83C) { self.var_83C = self.rowCount; shouldInvalidate = true; } if (shouldInvalidate) { self.invalidate(); } } else { if (self.var_83C != self.rowCount) { self.var_83C = self.rowCount; self.invalidate(); } Common::refreshTownList(self); } } // 0x0049A4A0 static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::townList, self.number, self.currentTab + Common::widx::tab_town_list); // Add three towns every tick. updateTownList(self); updateTownList(self); updateTownList(self); } // 0x0049A4D0 static void event_08(Window& self) { self.flags |= WindowFlags::notScrollView; } // 0x0049A4D8 static void event_09(Window& self) { if (!self.hasFlags(WindowFlags::notScrollView)) { return; } if (self.rowHover == -1) { return; } self.rowHover = -1; self.invalidate(); } // 0x0049A4FA static void getScrollSize(Ui::Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = kRowHeight * self.var_83C; } // 0x00491841 static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_town_list); return args; } // 0x004919A4 static Ui::CursorId cursor(Window& self, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, Ui::CursorId fallback) { if (widgetIdx != widx::scrollview) { return fallback; } uint16_t currentIndex = yPos / kRowHeight; if (currentIndex < self.var_83C && self.rowInfo[currentIndex] != -1) { return CursorId::handPointer; } return fallback; } // 0x0049A37E static void tabReset(Window& self) { self.minWidth = kMinDimensions.width; self.minHeight = kMinDimensions.height; self.maxWidth = kMaxDimensions.width; self.maxHeight = kMaxDimensions.height; self.width = kWindowSize.width; self.height = kWindowSize.height; self.var_83C = 0; self.rowHover = -1; Common::refreshTownList(self); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onUpdate = onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x00499C83 Window* open() { auto window = WindowManager::bringToFront(WindowType::townList, 0); if (window != nullptr) { window->callOnMouseUp(Common::widx::tab_town_list, window->widgets[Common::widx::tab_town_list].id); } else { // 0x00499CFC auto origin = Ui::Point32(Ui::width() - TownList::kWindowSize.width, 30); window = WindowManager::createWindow( WindowType::townList, origin, TownList::kWindowSize, WindowFlags::resizable, TownList::getEvents()); window->number = 0; window->currentTab = 0; window->frameNo = 0; window->sortMode = 0; window->var_83C = 0; window->rowHover = -1; Common::refreshTownList(*window); WindowManager::moveOtherWindowsDown(*window); window->minWidth = TownList::kMinDimensions.width; window->minHeight = TownList::kMinDimensions.height; window->maxWidth = TownList::kMaxDimensions.width; window->maxHeight = TownList::kMaxDimensions.height; window->flags |= WindowFlags::resizable; auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); // 0x00499CFC end window->width = TownList::kWindowSize.width; window->height = TownList::kWindowSize.height; window->invalidate(); window->setWidgets(TownList::widgets); if (SceneManager::isEditorMode() || SceneManager::isSandboxMode()) { window->disabledWidgets = 0; } else { window->disabledWidgets |= (1 << Common::widx::tab_build_town) | (1 << Common::widx::tab_build_buildings) | (1 << Common::widx::tab_build_misc_buildings); } window->activatedWidgets = 0; window->holdableWidgets = 0; window->callOnResize(); window->callPrepareDraw(); window->initScrollWidgets(); } return window; } // 0x00496B50 void reset() { getGameState().lastBuildingOption = 0xFF; getGameState().lastMiscBuildingOption = 0xFF; _buildingRotation = 2; _townSize = 3; } // 0x00499DAE void removeTown(TownId townId) { auto* window = WindowManager::find(WindowType::townList); if (window == nullptr) { return; } for (auto i = 0; i < window->var_83C; i++) { if (window->rowInfo[i] == enumValue(townId)) { window->rowInfo[i] = -1; } } } namespace BuildTowns { static constexpr Ui::Size32 kWindowSize = { 220, 87 }; enum widx { current_size = 8, select_size, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(220, 87, StringIds::title_build_new_towns), Widgets::dropdownWidgets({ 100, 45 }, { 117, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_town_size) ); constexpr StringId townSizeNames[9] = { StringIds::town_size_1, StringIds::town_size_2, StringIds::town_size_3, StringIds::town_size_4, StringIds::town_size_5, StringIds::town_size_6, StringIds::town_size_7, StringIds::town_size_8, }; // 0x0049A59A static void prepareDraw(Ui::Window& self) { Common::prepareDraw(self); Widget::leftAlignTabs(self, Common::widx::tab_town_list, Common::widx::tab_build_misc_buildings); self.widgets[widx::current_size].text = townSizeNames[_townSize - 1]; } // 0x0049A627 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto point = Point(self.x + 3, self.y + self.widgets[widx::current_size].top + 1); tr.drawStringLeft(point, Colour::black, StringIds::town_size_label); point = Point(self.x + 3, self.y + self.height - 13); tr.drawStringLeft(point, Colour::black, StringIds::select_town_size); } // 0x0049A675 static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_town_list: case Common::widx::tab_build_town: case Common::widx::tab_build_buildings: case Common::widx::tab_build_misc_buildings: Common::switchTab(self, widgetIndex); break; } } // 0x0049A7F2 static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::townList, self.number, self.currentTab + Common::widx::tab_town_list); if ((!Input::hasFlag(Input::Flags::toolActive)) || self.type != ToolManager::getToolWindowType() || self.number != ToolManager::getToolWindowNumber()) { WindowManager::close(&self); } } // 0x0049A697 static void onDropdown(Window& self, Ui::WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::select_size) { return; } if (itemIndex != -1) { itemIndex++; _townSize = itemIndex; self.invalidate(); } } // 0x0049A7C1 static void onToolAbort([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { Ui::Windows::Main::hideGridlines(); } // 0x0049A710 static void onToolUpdate([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto mapPos = Ui::ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); if (mapPos) { World::setMapSelectionFlags(World::MapSelectionFlags::enable); World::setMapSelectionCorner(MapSelectionType::full); World::setMapSelectionArea(*mapPos, *mapPos); World::mapInvalidateSelectionRect(); } } // 0x0049A75E static void onToolDown([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { auto mapPos = Ui::ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); if (mapPos) { GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); GameCommands::TownPlacementArgs placementArgs; placementArgs.pos = *mapPos; placementArgs.size = _townSize; if (GameCommands::doCommand(placementArgs, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } } // 0x0049A69E static void populateTownSizeSelect(Window& self, [[maybe_unused]] Widget* widget) { auto& currentSizeWidget = self.widgets[widx::current_size]; Dropdown::show(self.x + currentSizeWidget.left, self.y + currentSizeWidget.top, currentSizeWidget.width() - 2, currentSizeWidget.height(), self.getColour(WindowColour::secondary), 8, (1 << 7)); for (size_t i = 0; i < std::size(townSizeNames); ++i) { Dropdown::add(i, townSizeNames[i]); } Dropdown::setHighlightedItem(_townSize - 1); } // 0x0049A690 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::select_size) { populateTownSizeSelect(self, &self.widgets[widgetIndex]); } } // 0x0049A844 static void onResize(Window& self) { self.setSize(kWindowSize, kWindowSize); } // 0x0049A7C7 static void onClose(Window& self) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } } // 0x0049A3BE static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxWidth = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; ToolManager::toolSet(self, Common::widx::tab_build_town, CursorId::placeTown); Input::setFlag(Input::Flags::flag6); Ui::Windows::Main::showGridlines(); } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace BuildBuildings { static constexpr Ui::Size32 kWindowSize = { 600, 172 }; static constexpr uint8_t kRowHeight = 112; enum widx { scrollview = 8, rotate_object, object_colour, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(640, 172, StringIds::title_build_new_buildings), Widgets::ScrollView({ 2, 45 }, { 573, 112 }, WindowColour::secondary, 2), Widgets::ImageButton({ 575, 46 }, { 24, 24 }, WindowColour::secondary, ImageIds::rotate_object, StringIds::rotate_object_90), Widgets::ColourButton({ 579, 91 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_object_colour) ); // 0x0049A8A6 static void prepareDraw(Ui::Window& self) { self.widgets[widx::object_colour].image = Widget::kImageIdColourSet | Gfx::recolour(ImageIds::colour_swatch_recolourable, _buildingColour); self.widgets[widx::object_colour].hidden = true; if (self.rowHover != -1) { auto buildingObj = ObjectManager::get<BuildingObject>(self.rowHover); if (buildingObj->colours != 0) { self.widgets[widx::object_colour].hidden = false; } } Common::prepareDraw(self); self.widgets[widx::scrollview].right = self.width - 26; self.widgets[widx::scrollview].bottom = self.height - 14; self.widgets[widx::rotate_object].left = self.width - 25; self.widgets[widx::rotate_object].right = self.width - 2; self.widgets[widx::object_colour].left = self.width - 21; self.widgets[widx::object_colour].right = self.width - 6; self.widgets[Common::widx::caption].text = StringIds::title_build_new_buildings; if (self.currentTab == Common::widx::tab_build_misc_buildings - Common::widx::tab_town_list) { self.widgets[Common::widx::caption].text = StringIds::title_build_new_misc_buildings; } Widget::leftAlignTabs(self, Common::widx::tab_town_list, Common::widx::tab_build_misc_buildings); } // 0x0049A9C2 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto buildingId = self.var_846; if (buildingId == 0xFFFF) { buildingId = self.rowHover; if (buildingId == 0xFFFF) { return; } } auto buildingObj = ObjectManager::get<BuildingObject>(buildingId); FormatArguments args{}; args.push(buildingObj->name); auto point = Point(self.x + 3, self.y + self.height - 13); tr.drawStringLeftClipped(point, self.width - 19, Colour::black, StringIds::black_stringid, args); } // 0x0049AB31 static void onMouseUp(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_town_list: case Common::widx::tab_build_town: case Common::widx::tab_build_buildings: case Common::widx::tab_build_misc_buildings: Common::switchTab(self, widgetIndex); break; case widx::rotate_object: if (_buildingRotation < 3) { _buildingRotation++; } else { _buildingRotation = 0; } self.invalidate(); break; } } // 0x0049AD51 static void onUpdate(Window& self) { if (!Input::hasFlag(Input::Flags::rightMousePressed)) { auto cursor = Input::getMouseLocation(); auto xPos = cursor.x; auto yPos = cursor.y; Window* activeWindow = WindowManager::findAt(xPos, yPos); if (activeWindow == &self) { xPos -= self.x; xPos += 26; yPos -= self.y; if ((yPos < 42) || (xPos <= self.width)) { xPos = cursor.x; yPos = cursor.y; WidgetIndex_t activeWidget = self.findWidgetAt(xPos, yPos); if (activeWidget > Common::widx::panel) { self.expandContentCounter += 1; if (self.expandContentCounter >= 8) { auto y = std::min(self.scrollAreas[0].contentHeight - 1 + 60, 500); if (Ui::height() < 600) { y = std::min(y, 276); } self.minWidth = kWindowSize.width; self.minHeight = y; self.maxWidth = kWindowSize.width; self.maxHeight = y; } else { if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } } } else { self.expandContentCounter = 0; if (Input::state() != Input::State::scrollLeft) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxHeight = kWindowSize.height; } } } self.frameNo++; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::townList, self.number, self.currentTab + Common::widx::tab_town_list); if (!ToolManager::isToolActive(self.type, self.number)) { WindowManager::close(&self); } } // 0x0049AB59 static void onDropdown(Window& self, Ui::WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::object_colour) { return; } if (itemIndex == -1) { return; } _buildingColour = static_cast<Colour>(Dropdown::getItemArgument(itemIndex, 2)); self.invalidate(); } // 0x0049B37F static void removeBuildingGhost() { if (_buildingGhostPlaced) { GameCommands::BuildingRemovalArgs args; args.pos = _buildingGhostPos; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); _buildingGhostPlaced = false; } } // 0x0049AD46 static void onToolAbort([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { removeBuildingGhost(); Ui::Windows::Main::hideGridlines(); } // 0x0049B32A static currency32_t placeBuildingGhost(const GameCommands::BuildingPlacementArgs& placementArgs) { removeBuildingGhost(); auto res = GameCommands::doCommand(placementArgs, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res != GameCommands::FAILURE) { _buildingGhostPos = placementArgs.pos; _buildingGhostType = placementArgs.type; _buildingGhostRotation = placementArgs.rotation; _buildingGhostPlaced = true; } return res; } // 0x0049B3B2 static std::optional<GameCommands::BuildingPlacementArgs> getBuildingPlacementArgsFromCursor(const int16_t x, const int16_t y) { auto* townListWnd = WindowManager::find(WindowType::townList); if (townListWnd == nullptr) { return {}; } if (townListWnd->currentTab != (Common::widx::tab_build_misc_buildings - Common::widx::tab_town_list) && townListWnd->currentTab != (Common::widx::tab_build_buildings - Common::widx::tab_town_list)) { return {}; } if (townListWnd->rowHover == -1) { return {}; } const auto pos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); // ax,cx if (!pos) { return {}; } GameCommands::BuildingPlacementArgs args; args.rotation = (_buildingRotation - WindowManager::getCurrentRotation()) & 0x3; // bh args.colour = _buildingColour; auto tile = World::TileManager::get(*pos); const auto* surface = tile.surface(); if (surface == nullptr) { return {}; } auto z = surface->baseHeight(); // di if (surface->slope()) { z += 16; } args.pos = World::Pos3(pos->x, pos->y, z); args.type = townListWnd->rowHover; // dl args.variation = _buildingVariation; // dh if (SceneManager::isEditorMode()) { args.buildImmediately = true; // bh } return { args }; } // 0x0049ABF0 static void onToolUpdate(Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { World::mapInvalidateSelectionRect(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable); auto placementArgs = getBuildingPlacementArgsFromCursor(x, y); if (!placementArgs) { removeBuildingGhost(); return; } // Always show buildings, not scaffolding, for ghost placements. placementArgs->buildImmediately = true; World::setMapSelectionFlags(World::MapSelectionFlags::enable); World::setMapSelectionCorner(MapSelectionType::full); auto* building = ObjectManager::get<BuildingObject>(placementArgs->type); auto posB = World::Pos2(placementArgs->pos) + (building->hasFlags(BuildingObjectFlags::largeTile) ? World::Pos2(32, 32) : World::Pos2(0, 0)); World::setMapSelectionArea(placementArgs->pos, posB); World::mapInvalidateSelectionRect(); if (_buildingGhostPlaced) { if (_buildingGhostPos == placementArgs->pos && _buildingGhostRotation == placementArgs->rotation && _buildingGhostType == placementArgs->type) { return; } } removeBuildingGhost(); auto cost = placeBuildingGhost(*placementArgs); if (cost != _buildingPlacementCost) { _buildingPlacementCost = cost; self.invalidate(); } } // 0x0049ACBD static void onToolDown(Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { removeBuildingGhost(); auto placementArgs = getBuildingPlacementArgsFromCursor(x, y); if (placementArgs) { GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } uint8_t variation = 0; if (self.rowHover != -1) { auto* buildingObj = ObjectManager::get<BuildingObject>(self.rowHover); variation = (_buildingVariation + 1) % buildingObj->numVariations; } _buildingVariation = variation; } // 0x0049AB52 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::object_colour) { auto obj = ObjectManager::get<BuildingObject>(self.rowHover); Dropdown::showColour(&self, &self.widgets[widgetIndex], obj->colours, _buildingColour, self.getColour(WindowColour::secondary)); } } // 0x0049B2B5 static void updateActiveThumb(Window& self) { int32_t scrollWidth = 0, scrollHeight = 0; self.callGetScrollSize(0, scrollWidth, scrollHeight); self.scrollAreas[0].contentHeight = scrollHeight; auto i = 0; for (; i <= self.var_83C; i++) { if (self.rowInfo[i] == self.rowHover) { break; } } if (i >= self.var_83C) { i = 0; } i = (i / 5) * kRowHeight; self.scrollAreas[0].contentOffsetY = i; Ui::ScrollView::updateThumbs(self, widx::scrollview); } // 0x0049AF98 static void onResize(Window& self) { self.invalidate(); Ui::Size32 kMinWindowSize = { self.minWidth, self.minHeight }; Ui::Size32 kMaxWindowSize = { self.maxWidth, self.maxHeight }; bool hasResized = self.setSize(kMinWindowSize, kMaxWindowSize); if (hasResized) { updateActiveThumb(self); } } // 0x0049AE83 static void getScrollSize(Ui::Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = (4 + self.var_83C) / 5; if (scrollHeight == 0) { scrollHeight += 1; } scrollHeight *= kRowHeight; } // 0x0049ABBB static std::optional<FormatArguments> tooltip([[maybe_unused]] Ui::Window& window, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_building_list); return args; } // 0x0049AA1C static void drawScroll(Ui::Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 3); drawingCtx.clearSingle(shade); uint16_t xPos = 0; uint16_t yPos = 0; for (uint16_t i = 0; i < self.var_83C; i++) { if (yPos + kRowHeight < rt.y) { xPos += kRowHeight; if (xPos >= kRowHeight * 5) // full row { xPos = 0; yPos += kRowHeight; } continue; } else if (yPos > rt.y + rt.height) { break; } if (self.rowInfo[i] != self.rowHover) { if (self.rowInfo[i] == self.var_846) { drawingCtx.drawRectInset(xPos, yPos, kRowHeight, kRowHeight, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::colourLight); } } else { drawingCtx.drawRectInset(xPos, yPos, kRowHeight, kRowHeight, self.getColour(WindowColour::secondary), (Gfx::RectInsetFlags::colourLight | Gfx::RectInsetFlags::borderInset)); } auto buildingObj = ObjectManager::get<BuildingObject>(self.rowInfo[i]); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(xPos + 1, yPos + 1, 110, 110)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); auto colour = _buildingColour; if (self.rowHover != self.rowInfo[i]) { auto bit = Numerics::bitScanReverse(buildingObj->colours); colour = bit == -1 ? Colour::black : static_cast<Colour>(bit); } buildingObj->drawBuilding(drawingCtx, _buildingRotation, 56, 96, colour); drawingCtx.popRenderTarget(); } xPos += kRowHeight; if (xPos >= kRowHeight * 5) // full row { xPos = 0; yPos += kRowHeight; } } } // 0x0049B304 static void updateBuildingColours(Window& self) { if (self.rowHover != -1) { auto buildingObj = ObjectManager::get<BuildingObject>(self.rowHover); if (buildingObj->colours != 0) { auto bit = Numerics::bitScanReverse(buildingObj->colours); auto colour = bit == -1 ? Colour::black : static_cast<Colour>(bit); _buildingColour = colour; } } } static int getRowIndex(int16_t x, int16_t y) { return (x / 112) + (y / 112) * 5; } // 0x0049AEFD static void onScrollMouseDown(Ui::Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto index = getRowIndex(x, y); for (auto i = 0; i < self.var_83C; i++) { auto rowInfo = self.rowInfo[i]; index--; if (index < 0) { self.rowHover = rowInfo; if (self.currentTab == Common::widx::tab_build_misc_buildings - Common::widx::tab_town_list) { getGameState().lastMiscBuildingOption = static_cast<uint8_t>(rowInfo); } else { getGameState().lastBuildingOption = static_cast<uint8_t>(rowInfo); } updateBuildingColours(self); int32_t pan = (self.width >> 1) + self.x; Audio::playSound(Audio::SoundId::clickDown, pan); self.expandContentCounter = -16; _buildingPlacementCost = GameCommands::FAILURE; _buildingVariation = 0; self.invalidate(); break; } } } // 0x0049AEBA static void onScrollMouseOver(Ui::Window& self, int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { auto index = getRowIndex(x, y); uint16_t rowInfo = y; auto i = 0; for (; i < self.var_83C; i++) { rowInfo = self.rowInfo[i]; index--; if (index < 0) { self.var_846 = rowInfo; self.invalidate(); break; } } } // 0x0049ABC5 static void onClose(Window& self) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } } // 0x0049AEA1 static void event_08(Window& self) { if (self.var_846 != 0xFFFF) { self.var_846 = 0xFFFF; self.invalidate(); } } // 0x0049B206 static void updateBuildingList(Window& self) { auto buildingCount = 0; for (auto i = 0; i < 128; i++) { auto buildingObj = ObjectManager::get<BuildingObject>(i); if (buildingObj == nullptr) { continue; } if (self.currentTab == Common::widx::tab_build_misc_buildings - Common::widx::tab_town_list) { if (!buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { continue; } if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters)) { continue; } } else { if (buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { continue; } } self.rowInfo[buildingCount] = i; buildingCount++; } self.var_83C = buildingCount; auto rowHover = -1; auto lastSelectedBuilding = getGameState().lastBuildingOption; if (self.currentTab == Common::widx::tab_build_misc_buildings - Common::widx::tab_town_list) { lastSelectedBuilding = getGameState().lastMiscBuildingOption; } if (lastSelectedBuilding != 0xFF) { for (auto i = 0; i <= self.var_83C; i++) { if (lastSelectedBuilding == self.rowInfo[i]) { rowHover = lastSelectedBuilding; break; } } } if (rowHover == -1 && self.var_83C != 0) { rowHover = self.rowInfo[0]; } self.rowHover = rowHover; updateActiveThumb(self); updateBuildingColours(self); } // 0x0049A3FF static void tabReset(Window& self) { self.minWidth = kWindowSize.width; self.minHeight = kWindowSize.height; self.maxWidth = kWindowSize.width; self.maxWidth = kWindowSize.height; self.width = kWindowSize.width; self.height = kWindowSize.height; auto tab = Common::widx::tab_build_buildings; if (self.currentTab == Common::widx::tab_build_misc_buildings - Common::widx::tab_town_list) { tab = Common::widx::tab_build_misc_buildings; } ToolManager::toolSet(self, tab, CursorId::placeBuilding); Input::setFlag(Input::Flags::flag6); Ui::Windows::Main::showGridlines(); _buildingGhostPlaced = 0; _buildingPlacementCost = GameCommands::FAILURE; self.var_83C = 0; self.rowHover = -1; self.var_846 = 0xFFFFU; updateBuildingList(self); updateBuildingColours(self); _buildingVariation = 0; } static constexpr WindowEventList kEvents = { .onClose = onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = event_08, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } bool rotate(Window& self) { if (self.currentTab >= Common::widx::tab_build_buildings - Common::widx::tab_town_list) { if (!self.isDisabled(BuildBuildings::widx::rotate_object)) { if (!self.widgets[BuildBuildings::widx::rotate_object].hidden) { self.callOnMouseUp(BuildBuildings::widx::rotate_object, self.widgets[BuildBuildings::widx::rotate_object].id); return true; } } } return false; } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { TownList::widgets, widx::tab_town_list, TownList::getEvents() }, { BuildTowns::widgets, widx::tab_build_town, BuildTowns::getEvents() }, { BuildBuildings::widgets, widx::tab_build_buildings, BuildBuildings::getEvents() }, { BuildBuildings::widgets, widx::tab_build_misc_buildings, BuildBuildings::getEvents() }, }; // clang-format on static void prepareDraw(Window& self) { // Activate the current tab self.activatedWidgets &= ~((1ULL << tab_town_list) | (1ULL << tab_build_town) | (1ULL << tab_build_buildings) | (1ULL << tab_build_misc_buildings)); self.activatedWidgets |= (1ULL << Common::tabInformationByTabOffset[self.currentTab].widgetIndex); self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; } // 0x0049B054 void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Town List Tab { uint32_t imageId = skin->img; imageId += InterfaceSkin::ImageIds::toolbar_menu_towns; Widget::drawTab(self, drawingCtx, imageId, widx::tab_town_list); } // Build New Towns Tab { static constexpr uint32_t buildNewTownsImageIds[] = { InterfaceSkin::ImageIds::build_town_frame_0, InterfaceSkin::ImageIds::build_town_frame_1, InterfaceSkin::ImageIds::build_town_frame_2, InterfaceSkin::ImageIds::build_town_frame_3, InterfaceSkin::ImageIds::build_town_frame_4, InterfaceSkin::ImageIds::build_town_frame_5, InterfaceSkin::ImageIds::build_town_frame_6, InterfaceSkin::ImageIds::build_town_frame_7, InterfaceSkin::ImageIds::build_town_frame_8, InterfaceSkin::ImageIds::build_town_frame_9, InterfaceSkin::ImageIds::build_town_frame_10, InterfaceSkin::ImageIds::build_town_frame_11, InterfaceSkin::ImageIds::build_town_frame_12, InterfaceSkin::ImageIds::build_town_frame_13, InterfaceSkin::ImageIds::build_town_frame_14, InterfaceSkin::ImageIds::build_town_frame_15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_build_town - widx::tab_town_list) { imageId += buildNewTownsImageIds[(self.frameNo / 2) % std::size(buildNewTownsImageIds)]; } else { imageId += buildNewTownsImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_build_town); } // Build New Buildings Tab { static constexpr uint32_t buildBuildingsImageIds[] = { InterfaceSkin::ImageIds::build_buildings_frame_0, InterfaceSkin::ImageIds::build_buildings_frame_1, InterfaceSkin::ImageIds::build_buildings_frame_2, InterfaceSkin::ImageIds::build_buildings_frame_3, InterfaceSkin::ImageIds::build_buildings_frame_4, InterfaceSkin::ImageIds::build_buildings_frame_5, InterfaceSkin::ImageIds::build_buildings_frame_6, InterfaceSkin::ImageIds::build_buildings_frame_7, InterfaceSkin::ImageIds::build_buildings_frame_8, InterfaceSkin::ImageIds::build_buildings_frame_9, InterfaceSkin::ImageIds::build_buildings_frame_10, InterfaceSkin::ImageIds::build_buildings_frame_11, InterfaceSkin::ImageIds::build_buildings_frame_12, InterfaceSkin::ImageIds::build_buildings_frame_13, InterfaceSkin::ImageIds::build_buildings_frame_14, InterfaceSkin::ImageIds::build_buildings_frame_15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_build_buildings - widx::tab_town_list) { imageId += buildBuildingsImageIds[(self.frameNo / 2) % std::size(buildBuildingsImageIds)]; } else { imageId += buildBuildingsImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_build_buildings); } // Build New Misc Buildings Tab { static constexpr uint32_t buildMiscBuildingsImageIds[] = { InterfaceSkin::ImageIds::build_misc_buildings_frame_0, InterfaceSkin::ImageIds::build_misc_buildings_frame_1, InterfaceSkin::ImageIds::build_misc_buildings_frame_2, InterfaceSkin::ImageIds::build_misc_buildings_frame_3, InterfaceSkin::ImageIds::build_misc_buildings_frame_4, InterfaceSkin::ImageIds::build_misc_buildings_frame_5, InterfaceSkin::ImageIds::build_misc_buildings_frame_6, InterfaceSkin::ImageIds::build_misc_buildings_frame_7, InterfaceSkin::ImageIds::build_misc_buildings_frame_8, InterfaceSkin::ImageIds::build_misc_buildings_frame_9, InterfaceSkin::ImageIds::build_misc_buildings_frame_10, InterfaceSkin::ImageIds::build_misc_buildings_frame_11, InterfaceSkin::ImageIds::build_misc_buildings_frame_12, InterfaceSkin::ImageIds::build_misc_buildings_frame_13, InterfaceSkin::ImageIds::build_misc_buildings_frame_14, InterfaceSkin::ImageIds::build_misc_buildings_frame_15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_build_misc_buildings - widx::tab_town_list) { imageId += buildMiscBuildingsImageIds[(self.frameNo / 2) % std::size(buildMiscBuildingsImageIds)]; } else { imageId += buildMiscBuildingsImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_build_misc_buildings); } } // 0x0049A2E2 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_town_list; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.viewportRemove(0); const auto& tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_town_list]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); if (SceneManager::isEditorMode() || SceneManager::isSandboxMode()) { self.disabledWidgets = 0; } else { self.disabledWidgets |= (1 << Common::widx::tab_build_town) | (1 << Common::widx::tab_build_buildings) | (1 << Common::widx::tab_build_misc_buildings); } self.invalidate(); if (self.currentTab == widx::tab_town_list - widx::tab_town_list) { TownList::tabReset(self); } if (self.currentTab == widx::tab_build_town - widx::tab_town_list) { BuildTowns::tabReset(self); } if (self.currentTab == widx::tab_build_buildings - widx::tab_town_list || self.currentTab == widx::tab_build_misc_buildings - widx::tab_town_list) { BuildBuildings::tabReset(self); } self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x00499DDE static void refreshTownList(Window& self) { self.rowCount = 0; for (auto& town : TownManager::towns()) { town.flags &= ~TownFlags::sorted; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/TownWindow.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Town/RemoveTown.h" #include "GameCommands/Town/RenameTown.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "SceneManager.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/TownManager.h" #include <OpenLoco/Engine/World.hpp> using namespace OpenLoco::GameCommands; namespace OpenLoco::Ui::Windows::Town { static constexpr Ui::Size32 kWindowSize = { 223, 161 }; namespace Common { enum widx { frame, caption, close_button, panel, tab_town, tab_population, tab_company_ratings, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::whiteText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, 120 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_town), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_population_graph), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_town_ratings_each_company)); } // Defined at the bottom of this file. static void prepareDraw(Window& self); static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input); static void update(Window& self); static void renameTownPrompt(Window& self, WidgetIndex_t widgetIndex); static void switchTab(Window& self, WidgetIndex_t widgetIndex); static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); } namespace Town { enum widx { viewport = 7, status_bar, centre_on_viewport, expand_town, demolish_town, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(223, 161, StringIds::title_town), Widgets::Viewport({ 3, 44 }, { 195, 104 }, WindowColour::secondary, Widget::kContentUnk), Widgets::Label({ 3, 139 }, { 195, 21 }, WindowColour::secondary, ContentAlign::center), Widgets::ImageButton({ 0, 0 }, { 24, 24 }, WindowColour::secondary, ImageIds::centre_viewport, StringIds::move_main_view_to_show_this), Widgets::ImageButton({ 198, 44 }, { 24, 24 }, WindowColour::secondary, ImageIds::town_expand, StringIds::expand_this_town), Widgets::ImageButton({ 198, 68 }, { 24, 24 }, WindowColour::secondary, ImageIds::rubbish_bin, StringIds::demolish_this_town) ); // 0x00498EAF static void prepareDraw(Window& self) { Common::prepareDraw(self); self.widgets[widx::viewport].right = self.width - 26; self.widgets[widx::viewport].bottom = self.height - 14; self.widgets[widx::status_bar].top = self.height - 12; self.widgets[widx::status_bar].bottom = self.height - 3; self.widgets[widx::status_bar].right = self.width - 14; self.widgets[widx::expand_town].right = self.width - 2; self.widgets[widx::expand_town].left = self.width - 25; self.widgets[widx::demolish_town].right = self.width - 2; self.widgets[widx::demolish_town].left = self.width - 25; if (SceneManager::isEditorMode() || SceneManager::isSandboxMode()) { self.widgets[widx::expand_town].hidden = false; self.widgets[widx::demolish_town].hidden = false; } else { self.widgets[widx::expand_town].hidden = true; self.widgets[widx::demolish_town].hidden = true; self.widgets[widx::viewport].right += 22; } self.widgets[widx::centre_on_viewport].right = self.widgets[widx::viewport].right - 1; self.widgets[widx::centre_on_viewport].bottom = self.widgets[widx::viewport].bottom - 1; self.widgets[widx::centre_on_viewport].left = self.widgets[widx::viewport].right - 24; self.widgets[widx::centre_on_viewport].top = self.widgets[widx::viewport].bottom - 24; Widget::leftAlignTabs(self, Common::widx::tab_town, Common::widx::tab_company_ratings); } // 0x00498FFE static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto town = TownManager::get(TownId(self.number)); FormatArguments args{}; args.push(town->getTownSizeString()); args.push(town->population); const auto& widget = self.widgets[widx::status_bar]; const auto width = widget.width() - 1; auto point = Point(self.x + widget.left - 1, self.y + widget.top - 1); tr.drawStringLeftClipped(point, width, Colour::black, StringIds::status_town_population, args); } // 0x00499079 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameTownPrompt(self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_town: case Common::widx::tab_population: case Common::widx::tab_company_ratings: Common::switchTab(self, widgetIndex); break; // 0x0049932D case widx::centre_on_viewport: self.viewportCentreMain(); break; // 0x004990B9 case widx::expand_town: { auto town = TownManager::get(TownId(self.number)); const uint32_t ebx = (town->numBuildings >> 3) + 5; const int16_t currentYear = getCurrentYear(); int16_t tempYear = currentYear - 51; setCurrentYear(tempYear); for (uint8_t i = 8; i > 0; i--) { for (uint32_t j = ebx; j > 0; j--) { town->grow(TownGrowFlags::all); town->recalculateSize(); } tempYear += 7; setCurrentYear(tempYear); } setCurrentYear(currentYear); // Set new history entry. uint8_t historyEntry = std::min<uint8_t>(town->population / 50, 255); town->history[town->historySize - 1] = historyEntry; // Play construction sound at the town centre. int16_t tileZ = World::TileManager::getHeight({ town->x, town->y }).landHeight; Audio::playSound(Audio::SoundId::construct, World::Pos3(town->x + 16, town->y + 16, tileZ)); break; } // 0x0049916A case widx::demolish_town: { GameCommands::setErrorTitle(StringIds::cant_remove_town); GameCommands::TownRemovalArgs args{}; args.townId = static_cast<TownId>(self.number); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::demolish, GameCommands::getPosition()); } break; } } } static void initViewport(Window& self); // 0x004993A5 static void onResize(Window& self) { // Call to sub_498E9B has been deliberately omitted. self.setSize({ 192, 161 }, { 600, 440 }); if (self.viewports[0] != nullptr) { uint16_t newWidth = self.width - 30; if (!SceneManager::isEditorMode() && !SceneManager::isSandboxMode()) { newWidth += 22; } uint16_t newHeight = self.height - 59; auto& viewport = self.viewports[0]; if (newWidth != viewport->width || newHeight != viewport->height) { viewport->width = newWidth; viewport->height = newHeight; viewport->viewWidth = newWidth << viewport->zoom; viewport->viewHeight = newHeight << viewport->zoom; self.savedView.clear(); } } initViewport(self); } // 0x00499A87 static void initViewport(Window& self) { if (self.currentTab != 0) { return; } self.callPrepareDraw(); // Figure out the town's position on the map. auto town = TownManager::get(TownId(self.number)); int16_t tileZ = World::TileManager::getHeight({ town->x, town->y }).landHeight; // Compute views. SavedView view = { town->x, town->y, ZoomLevel::quarter, static_cast<int8_t>(self.viewports[0]->getRotation()), tileZ, }; ViewportFlags flags = ViewportFlags::none; if (self.viewports[0] != nullptr) { if (self.savedView == view) { return; } flags = self.viewports[0]->flags; self.viewportRemove(0); } else { if (Config::get().gridlinesOnLandscape) { flags |= ViewportFlags::gridlines_on_landscape; } } self.savedView = view; // 0x00499B39 start if (self.viewports[0] == nullptr) { auto widget = &self.widgets[widx::viewport]; auto tile = World::Pos3({ town->x, town->y, tileZ }); auto origin = Ui::Point(widget->left + self.x + 1, widget->top + self.y + 1); auto size = Ui::Size(widget->width() - 2, widget->height() - 2); ViewportManager::create(&self, 0, origin, size, self.savedView.zoomLevel, tile); self.invalidate(); self.flags |= WindowFlags::viewportNoScrolling; } // 0x00499B39 end if (self.viewports[0] != nullptr) { self.viewports[0]->flags = flags; self.invalidate(); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .viewportRotate = initViewport, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } // 0x00499B7E Window* open(uint16_t townId) { auto window = WindowManager::bringToFront(WindowType::town, townId); if (window != nullptr) { if (ToolManager::isToolActive(window->type, window->number)) { ToolManager::toolCancel(); } window = WindowManager::bringToFront(WindowType::town, townId); } if (window == nullptr) { // 0x00499C0D start const WindowFlags newFlags = WindowFlags::flag_8 | WindowFlags::resizable; window = WindowManager::createWindow(WindowType::town, kWindowSize, newFlags, Town::getEvents()); window->number = townId; window->minWidth = 192; window->minHeight = 161; window->maxWidth = 600; window->maxHeight = 440; auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, skin->windowTitlebarColour); window->setColour(WindowColour::secondary, skin->windowColour); } // 0x00499C0D end window->savedView.clear(); } window->currentTab = 0; window->invalidate(); window->setWidgets(Town::widgets); window->holdableWidgets = 0; window->eventHandlers = &Town::getEvents(); window->activatedWidgets = 0; window->disabledWidgets = 0; window->initScrollWidgets(); Town::initViewport(*window); return window; } namespace Population { static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(223, 161, StringIds::title_town_population) ); // 0x00499469 static void prepareDraw(Window& self) { Common::prepareDraw(self); } // 0x004994F9 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(self.x, self.y + 44, self.width, self.height - 44)); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); auto town = TownManager::get(TownId(self.number)); // Draw Y label and grid lines. int32_t yTick = town->historyMinPopulation; for (int16_t yPos = self.height - 57; yPos >= 14; yPos -= 20) { FormatArguments args{}; args.push(yTick); const uint16_t xPos = 39; drawingCtx.drawRect(xPos, yPos, 241, 1, Colours::getShade(self.getColour(WindowColour::secondary).c(), 4), Gfx::RectFlags::none); auto point = Point(xPos, yPos - 6); tr.drawStringRight(point, Colour::black, StringIds::population_graph_people, args); yTick += 1000; } int8_t month = static_cast<int8_t>(getCurrentMonth()); int16_t year = getCurrentYear(); int8_t yearSkip = 0; for (uint8_t i = town->historySize - 1; i > 0; i--) { const uint16_t xPos = 41 + i; const uint16_t yPos = 2; // Draw horizontal year and vertical grid lines. if (month == 0) { if (yearSkip == 0) { FormatArguments args{}; args.push(year); auto point = Point(xPos, yPos); tr.drawStringCentred(point, Colour::black, StringIds::population_graph_year, args); } drawingCtx.drawRect(xPos, 11, 1, self.height - 66, Colours::getShade(self.getColour(WindowColour::secondary).c(), 4), Gfx::RectFlags::none); } // Draw population graph uint16_t yPos1 = -town->history[i] + (self.height - 57); uint16_t yPos2 = -town->history[i + 1] + (self.height - 57); // Do not draw current segment yet; it may be zeroed. if (i < town->historySize - 1) { drawingCtx.drawLine(Ui::Point(xPos, yPos1), Ui::Point(xPos + 1, yPos2), Colours::getShade(self.getColour(WindowColour::secondary).c(), 7)); } month--; if (month < 0) { month = 11; year--; yearSkip++; if (yearSkip >= 3) { yearSkip = 0; } } } drawingCtx.popRenderTarget(); } // 0x004996AC static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameTownPrompt(self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_town: case Common::widx::tab_population: case Common::widx::tab_company_ratings: Common::switchTab(self, widgetIndex); break; } } // 0x004996F6 static void onResize(Window& self) { // Call to sub_498E9B has been deliberately omitted. self.setSize({ 299, 172 }, { 299, 327 }); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace CompanyRatings { static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(340, 208, StringIds::title_town_local_authority) ); // 0x00499761 static void prepareDraw(Window& self) { Common::prepareDraw(self); } // 0x004997F1 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto point = Point(self.x + 4, self.y + 46); tr.drawStringLeft(point, Colour::black, StringIds::local_authority_ratings_transport_companies); point.x += 4; point.y += 14; auto town = TownManager::get(TownId(self.number)); for (uint8_t i = 0; i < std::size(town->companyRatings); i++) { if ((town->companiesWithRating & (1 << i)) == 0) { continue; } int16_t rating = (std::clamp<int16_t>(town->companyRatings[i], -1000, 1000) + 1000) / 20; StringId rank{}; if (rating >= 70) { rank = StringIds::town_rating_excellent; } else if (rating >= 60) { rank = StringIds::town_rating_good; } else if (rating >= 50) { rank = StringIds::town_rating_average; } else if (rating >= 25) { rank = StringIds::town_rating_poor; } else { rank = StringIds::town_rating_appalling; } FormatArguments args{}; args.push(CompanyManager::get(CompanyId(i))->name); args.push<int16_t>(0); args.push(rating); args.push(rank); tr.drawStringLeftClipped(point, self.width - 12, Colour::black, StringIds::town_rating_company_percentage_rank, args); point.y += 10; } } // 0x004998E7 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::caption: Common::renameTownPrompt(self, widgetIndex); break; case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_town: case Common::widx::tab_population: case Common::widx::tab_company_ratings: Common::switchTab(self, widgetIndex); break; } } // 0x00499936 static void onResize(Window& self) { // Call to sub_498E9B has been deliberately omitted. self.setSize({ 340, 208 }, { 340, 208 }); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = Common::update, .textInput = Common::textInput, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { Town::widgets, widx::tab_town, Town::getEvents() }, { Population::widgets, widx::tab_population, Population::getEvents() }, { CompanyRatings::widgets, widx::tab_company_ratings, CompanyRatings::getEvents() } }; // clang-format on static void prepareDraw(Window& self) { // Activate the current tab. self.activatedWidgets &= ~((1 << widx::tab_town) | (1 << widx::tab_population) | (1 << widx::tab_company_ratings)); widx widgetIndex = tabInformationByTabOffset[self.currentTab].widgetIndex; self.activatedWidgets |= (1ULL << widgetIndex); // Put town name in place. auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(TownManager::get(TownId(self.number))->name); // Resize common widgets. self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::close_button].left = self.width - 15; self.widgets[Common::widx::close_button].right = self.width - 3; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; } // 0x00499287 static void textInput(Window& self, WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* input) { if (callingWidget != Common::widx::caption) { return; } if (strlen(input) == 0) { return; } GameCommands::setErrorTitle(StringIds::error_cant_rename_town); GameCommands::RenameTownArgs args{}; args.townId = TownId(self.number); args.nameBufferIndex = 1; std::memcpy(args.buffer, input, 36); GameCommands::doCommand(args, GameCommands::Flags::apply); args.nameBufferIndex = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.nameBufferIndex = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); } static void update(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidate(WindowType::town, self.number); } static void renameTownPrompt(Window& self, WidgetIndex_t widgetIndex) { auto town = TownManager::get(TownId(self.number)); FormatArguments args{}; args.skip(4); args.push(town->name); args.push(town->name); TextInput::openTextInput(&self, StringIds::title_town_name, StringIds::prompt_type_new_town_name, town->name, widgetIndex, &args); } // 0x004991BC static void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } TextInput::sub_4CE6C9(self.type, self.number); self.currentTab = widgetIndex - widx::tab_town; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); self.var_85C = -1; self.viewportRemove(0); auto tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_town]; self.holdableWidgets = 0; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.disabledWidgets = 0; self.invalidate(); self.setSize(kWindowSize); self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x004999E1 void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); // Town tab { const uint32_t imageId = skin->img + InterfaceSkin::ImageIds::toolbar_menu_towns; Widget::drawTab(self, drawingCtx, imageId, widx::tab_town); } // Population tab { static constexpr uint32_t populationTabImageIds[] = { InterfaceSkin::ImageIds::tab_population_frame0, InterfaceSkin::ImageIds::tab_population_frame1, InterfaceSkin::ImageIds::tab_population_frame2, InterfaceSkin::ImageIds::tab_population_frame3, InterfaceSkin::ImageIds::tab_population_frame4, InterfaceSkin::ImageIds::tab_population_frame5, InterfaceSkin::ImageIds::tab_population_frame6, InterfaceSkin::ImageIds::tab_population_frame7, }; uint32_t imageId = Gfx::recolour(skin->img, self.getColour(WindowColour::secondary).c()); if (self.currentTab == widx::tab_population - widx::tab_town) { imageId += populationTabImageIds[(self.frameNo / 4) % std::size(populationTabImageIds)]; } else { imageId += populationTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_population); } // Company ratings tab { static constexpr uint32_t ratingsTabImageIds[] = { InterfaceSkin::ImageIds::tab_ratings_frame0, InterfaceSkin::ImageIds::tab_ratings_frame1, InterfaceSkin::ImageIds::tab_ratings_frame2, InterfaceSkin::ImageIds::tab_ratings_frame3, InterfaceSkin::ImageIds::tab_ratings_frame4, InterfaceSkin::ImageIds::tab_ratings_frame5, InterfaceSkin::ImageIds::tab_ratings_frame6, InterfaceSkin::ImageIds::tab_ratings_frame7, InterfaceSkin::ImageIds::tab_ratings_frame8, InterfaceSkin::ImageIds::tab_ratings_frame9, InterfaceSkin::ImageIds::tab_ratings_frame10, InterfaceSkin::ImageIds::tab_ratings_frame11, InterfaceSkin::ImageIds::tab_ratings_frame12, InterfaceSkin::ImageIds::tab_ratings_frame13, InterfaceSkin::ImageIds::tab_ratings_frame14, InterfaceSkin::ImageIds::tab_ratings_frame15, }; uint32_t imageId = skin->img; if (self.currentTab == widx::tab_company_ratings - widx::tab_town) { imageId += ratingsTabImageIds[(self.frameNo / 4) % std::size(ratingsTabImageIds)]; } else { imageId += ratingsTabImageIds[0]; } Widget::drawTab(self, drawingCtx, imageId, widx::tab_company_ratings); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Tutorial.cpp ```cpp #include "Tutorial.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui.h" #include "Ui/Widget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Ui::Windows::Tutorial { enum Widx { frame, }; static constexpr Ui::Size32 kWindowSize = { 140, 29 }; static constexpr auto widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, kWindowSize, WindowColour::primary) ); static const WindowEventList& getEvents(); // 0x00438CAE Window* open() { auto window = WindowManager::createWindow( WindowType::tutorial, { kWindowSize.width, Ui::height() - 27 }, { Ui::width() - 280, 27 }, WindowFlags::stickToFront | WindowFlags::transparent | WindowFlags::noBackground, getEvents()); window->setWidgets(widgets); window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); if (skin != nullptr) { window->setColour(WindowColour::primary, AdvancedColour(skin->mapTooltipObjectColour).translucent()); window->setColour(WindowColour::secondary, AdvancedColour(skin->mapTooltipCargoColour).translucent()); } return window; } // 0x00439B3D static void prepareDraw(Window& self) { self.widgets[Widx::frame].right = self.width - 1; } // 0x00439B4A static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { static constexpr StringId titleStringIds[] = { StringIds::tutorial_1_title, StringIds::tutorial_2_title, StringIds::tutorial_3_title, }; auto tr = Gfx::TextRenderer(drawingCtx); auto tutorialNumber = OpenLoco::Tutorial::getTutorialNumber(); FormatArguments args{}; args.push(titleStringIds[tutorialNumber]); auto& widget = self.widgets[Widx::frame]; auto point = Point(self.x + widget.midX(), self.y + widget.top + 4); tr.drawStringCentred(point, Colour::black, StringIds::tutorial_text, args); point.y += 10; tr.drawStringCentred(point, Colour::black, StringIds::tutorial_control); } static constexpr WindowEventList kEvents = { .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Vehicle.cpp ```cpp #include "Vehicles/Vehicle.h" #include "Config.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Vehicles/CloneVehicle.h" #include "GameCommands/Vehicles/RenameVehicle.h" #include "GameCommands/Vehicles/VehicleChangeRunningMode.h" #include "GameCommands/Vehicles/VehicleOrderDelete.h" #include "GameCommands/Vehicles/VehicleOrderDown.h" #include "GameCommands/Vehicles/VehicleOrderInsert.h" #include "GameCommands/Vehicles/VehicleOrderReverse.h" #include "GameCommands/Vehicles/VehicleOrderSkip.h" #include "GameCommands/Vehicles/VehicleOrderUp.h" #include "GameCommands/Vehicles/VehiclePassSignal.h" #include "GameCommands/Vehicles/VehiclePickup.h" #include "GameCommands/Vehicles/VehiclePickupAir.h" #include "GameCommands/Vehicles/VehiclePickupWater.h" #include "GameCommands/Vehicles/VehiclePlace.h" #include "GameCommands/Vehicles/VehiclePlaceAir.h" #include "GameCommands/Vehicles/VehiclePlaceWater.h" #include "GameCommands/Vehicles/VehicleRearrange.h" #include "GameCommands/Vehicles/VehicleRefit.h" #include "GameCommands/Vehicles/VehicleRepaint.h" #include "GameCommands/Vehicles/VehicleReverse.h" #include "GameCommands/Vehicles/VehicleSell.h" #include "GameCommands/Vehicles/VehicleSpeedControl.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "LabelFrame.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Map/Track/SubpositionData.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/AirportObject.h" #include "Objects/CargoObject.h" #include "Objects/DockObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/WaterObject.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/ScrollView.h" #include "Ui/ToolManager.h" #include "Ui/ToolTip.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/ColourButtonWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/SliderWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include "Vehicles/VehicleManager.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <OpenLoco/Math/Trigonometry.hpp> #include <map> #include <sfl/static_vector.hpp> #include <sstream> using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::Literals; using OpenLoco::GameCommands::VehicleChangeRunningModeArgs; namespace OpenLoco::Ui::Windows::Vehicle { static loco_global<StationId, 0x00F252A4> _hoveredStationId; namespace Common { enum widx { frame = 0, caption = 1, closeButton = 2, panel = 3, tabMain = 4, tabDetails = 5, tabCargo = 6, tabFinances = 7, tabRoute = 8, }; static constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { (frameWidth), (frameHeight) }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { (frameWidth)-2, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ (frameWidth)-15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 265, 136 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicle_tab_main), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicle_tab_details), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicle_tab_cargo), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicle_tab_finance), Widgets::Tab({ 158, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_vehicle_tab_route)); } static Vehicles::VehicleHead* getVehicle(const Window& self) { auto* veh = EntityManager::get<Vehicles::VehicleHead>(EntityId(self.number)); if (veh == nullptr) { WindowManager::close(WindowType::vehicle, self.number); return nullptr; } return veh; } static bool confirmComponentChange(const EntityId id, const OpenLoco::StringId windowTitle, const OpenLoco::StringId windowMessage, const OpenLoco::StringId windowConfirm) { auto* vehBase = EntityManager::get<Vehicles::VehicleBase>(id); if (vehBase == nullptr) { // Should still run GameCommand so code path is identical to vanilla return true; } auto* head = EntityManager::get<Vehicles::VehicleHead>(vehBase->getHead()); if (head == nullptr) { return true; } if (!head->hasAnyCargo()) { return true; } if (head->getCarCount() > 0 && CompanyManager::getControllingId() == head->owner) { auto format = FormatArguments{}; return Windows::PromptOkCancel::open(windowTitle, windowMessage, format, windowConfirm); } return false; } static void onClose(Window& self); static void setActiveTabs(Window& self); static void textInput(Window& self, const WidgetIndex_t callingWidget, const WidgetId id, const char* const input); static void renameVehicle(Window& self, const WidgetIndex_t widgetIndex); static void switchTab(Window& self, const WidgetIndex_t widgetIndex); static void setCaptionEnableState(Window& self); static void onPickup(Window& self, const WidgetIndex_t pickupWidx); static void event8(Window& self); static void event9(Window& self); static size_t getNumCars(Ui::Window& self); static void drawTabs(Window& window, Gfx::DrawingContext& drawingCtx); static void pickupToolUpdate(Window& self, const int16_t x, const int16_t y); static void pickupToolDown(Window& self, const int16_t x, const int16_t y); static void pickupToolAbort(Window& self); static size_t getNumCars(Ui::Window& self); static std::optional<Vehicles::Car> getCarFromScrollView(Window& self, const int16_t y); static std::pair<uint32_t, StringId> getPickupImageIdandTooltip(const Vehicles::VehicleHead& head, const bool isPlaced); } namespace Details { static constexpr Ui::Size32 kMinWindowSize = { 192, 166 }; static constexpr Ui::Size32 kMinWindowSizeWithPaintEnabled = { 192, 182 }; static constexpr Ui::Size32 kMaxWindowSize = { 400, 440 }; enum widx { buildNew = Common::widx::tabRoute + 1, pickup, remove, paintBrush, paintBrushProxy, // hack until a better solution presents itself paintColourPrimary, paintColourSecondary, carList, }; struct BodyItem { uint32_t image; int32_t dist; EntityId body; }; struct BodyItems { sfl::static_vector<BodyItem, VehicleObject::kMaxBodySprites * (2 + 1)> items; int32_t totalDistance; }; constexpr uint64_t holdableWidgets = 0; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(265, 177, StringIds::title_vehicle_details), Widgets::ImageButton({ 240, 44 }, { 24, 24 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_build_new_vehicle_for), Widgets::ImageButton({ 240, 68 }, { 24, 24 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_remove_from_track), Widgets::ImageButton({ 240, 96 }, { 24, 24 }, WindowColour::secondary, ImageIds::rubbish_bin, StringIds::tooltip_sell_or_drag_vehicle), Widgets::ImageButton({ 240, 122 }, { 24, 24 }, WindowColour::secondary, ImageIds::paintbrush, StringIds::vehicleRepaintTooltip), Widgets::Frame({ 0, 0 }, { 0, 0 }, WindowColour::secondary, Widget::kContentNull, StringIds::null), Widgets::ColourButton({ 240, 150 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_main_colour), Widgets::ColourButton({ 258, 150 }, { 16, 16 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_secondary_colour), Widgets::ScrollView({ 3, 44 }, { 237, 110 }, WindowColour::secondary, Scrollbars::vertical) ); static void paintEntireTrain(Window& self); static void paintToolBegin(Window& self); static void paintToolDown(Window& self, const int16_t x, const int16_t y); static void paintToolAbort(Window& self); static void paintToolDownScroll(Window& self, Vehicles::Car car, const int16_t x); static constexpr bool isPaintToolActive(Window& self); static ColourScheme getPaintToolColour(Window& self); static BodyItems getBodyItemsForVehicle(const VehicleObject& vehObject, const uint8_t yaw, const Vehicles::Car& car); } namespace Cargo { static constexpr Ui::Size32 kMinWindowSize = { 192, 142 }; static constexpr Ui::Size32 kMaxWindowSize = { 400, 440 }; enum widx { refit = 9, cargoList = 10, }; constexpr uint64_t holdableWidgets = 0; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(265, 177, StringIds::title_vehicle_cargo), Widgets::ImageButton({ 240, 44 }, { 24, 24 }, WindowColour::secondary, ImageIds::refit_cargo_button, StringIds::refit_vehicle_tip), Widgets::ScrollView({ 3, 44 }, { 259, 120 }, WindowColour::secondary, Scrollbars::vertical) ); } namespace Finances { static constexpr Ui::Size32 kMinWindowSize = { 400, 202 }; static constexpr Ui::Size32 kMaxWindowSize = kMinWindowSize; constexpr uint64_t holdableWidgets = 0; // 0x00522470 static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(636, 319, StringIds::title_company_finances) ); } namespace Route { static constexpr Ui::Size32 kMinWindowSize = { 265, 202 }; static constexpr Ui::Size32 kMaxWindowSize = { 600, 440 }; enum widx { tool = Common::widx::tabRoute + 1, // Only used to hold the tool does nothing localMode, expressMode, routeList, orderForceUnload, orderWait, orderSkip, orderDelete, orderUp, orderDown, orderReverse }; constexpr uint64_t holdableWidgets = 0; constexpr auto lineHeight = 10; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(265, 189, StringIds::title_vehicle_route), // TODO: This is not ideal, this is used for the tool, do this in a better way. makeWidget({ 0, 0 }, { 1, 1 }, WidgetType::empty, WindowColour::primary), Widgets::Button({ 3, 44 }, { 118, 12 }, WindowColour::secondary, StringIds::local_mode_button), Widgets::Button({ 121, 44 }, { 119, 12 }, WindowColour::secondary, StringIds::express_mode_button), Widgets::ScrollView({ 3, 58 }, { 237, 120 }, WindowColour::secondary, Scrollbars::vertical, StringIds::tooltip_route_scrollview), Widgets::ImageButton({ 240, 44 }, { 24, 24 }, WindowColour::secondary, ImageIds::route_force_unload, StringIds::tooltip_route_insert_force_unload), Widgets::ImageButton({ 240, 68 }, { 24, 24 }, WindowColour::secondary, ImageIds::route_wait, StringIds::tooltip_route_insert_wait_full_cargo), Widgets::ImageButton({ 240, 92 }, { 24, 24 }, WindowColour::secondary, ImageIds::route_skip, StringIds::tooltip_route_skip_next_order), Widgets::ImageButton({ 240, 116 }, { 24, 24 }, WindowColour::secondary, ImageIds::route_delete, StringIds::tooltip_route_delete_order), Widgets::ImageButton({ 240, 140 }, { 24, 12 }, WindowColour::secondary, ImageIds::red_arrow_up, StringIds::tooltip_route_move_order_up), Widgets::ImageButton({ 240, 152 }, { 24, 12 }, WindowColour::secondary, ImageIds::red_arrow_down, StringIds::tooltip_route_move_order_down), Widgets::ImageButton({ 240, 164 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_right_turnaround, StringIds::reverseOrderTableTooltip) ); } static loco_global<Vehicles::VehicleBogie*, 0x0113614E> _dragCarComponent; static loco_global<EntityId, 0x01136156> _dragVehicleHead; static loco_global<int32_t, 0x01136264> _1136264; static loco_global<uint8_t, 0x01136264> _ghostAirportNode; static loco_global<World::Pos3, 0x0113625E> _ghostVehiclePos; static loco_global<StationId, 0x0113625A> _ghostAirportStationId; static loco_global<uint32_t, 0x0113625A> _ghostLandTrackAndDirection; namespace Main { static constexpr Ui::Size32 kWindowSize = { 265, 177 }; static constexpr Ui::Size32 kMinWindowSize = { 192, 177 }; static constexpr Ui::Size32 kMaxWindowSize = { 600, 440 }; enum widx { viewport = Common::widx::tabRoute + 1, status = 10, speedControl = 11, stopStart = 12, pickup = 13, passSignal = 14, changeDirection = 15, centreViewport = 16, }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(265, 177, StringIds::stringid), Widgets::Viewport({ 3, 44 }, { 237, 120 }, WindowColour::secondary), Widgets::Label({ 3, 155 }, { 237, 21 }, WindowColour::secondary, ContentAlign::center), Widgets::Slider({ 240, 46 }, { 24, 115 }, WindowColour::secondary), Widgets::ImageButton({ 240, 44 }, { 24, 24 }, WindowColour::secondary, ImageIds::red_flag, StringIds::tooltip_stop_start), Widgets::ImageButton({ 240, 68 }, { 24, 24 }, WindowColour::secondary, ImageIds::null, StringIds::tooltip_remove_from_track), Widgets::ImageButton({ 240, 92 }, { 24, 24 }, WindowColour::secondary, ImageIds::pass_signal, StringIds::tooltip_pass_signal_at_danger), Widgets::ImageButton({ 240, 116 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_right_turnaround, StringIds::tooltip_change_direction), Widgets::ImageButton({ 0, 0 }, { 24, 24 }, WindowColour::secondary, ImageIds::centre_viewport, StringIds::move_main_view_to_show_this) ); constexpr uint64_t interactiveWidgets = (1 << widx::stopStart) | (1 << widx::pickup) | (1 << widx::passSignal) | (1 << widx::changeDirection) | (1 << widx::centreViewport); constexpr uint64_t holdableWidgets = 1 << widx::speedControl; // 0x004B5D82 static void resetDisabledWidgets(Window& self) { self.disabledWidgets = 0; } // 0x004B5D88 // 0x004B32F9 static void createViewport(Window& self) { if (self.currentTab != (Common::widx::tabMain - Common::widx::tabMain)) { return; } self.callPrepareDraw(); auto vehHead = Common::getVehicle(self); if (vehHead == nullptr) { return; } Vehicles::Vehicle train(*vehHead); // If picked up no need for viewport drawn if (vehHead->tileX == -1) { self.viewportRemove(0); self.invalidate(); return; } // By default focus on the veh2 id and if there are cars focus on the body of the first car EntityId targetEntity = train.veh2->id; if (!train.cars.empty()) { targetEntity = train.cars.firstCar.front->id; // Always true so above is pointless if (train.cars.firstCar.front->getSubType() == Vehicles::VehicleEntityType::bogie) { targetEntity = train.cars.firstCar.body->id; } } // Compute views. SavedView view = { targetEntity, (1 << 15) | (1 << 14), ZoomLevel::full, static_cast<int8_t>(self.viewports[0]->getRotation()), 0 }; ViewportFlags flags = ViewportFlags::none; if (self.viewports[0] != nullptr) { if (self.savedView == view) { return; } flags = self.viewports[0]->flags; self.viewportRemove(0); } else { if (Config::get().gridlinesOnLandscape) { flags |= ViewportFlags::gridlines_on_landscape; } } self.savedView = view; // 0x004B5E88 start if (self.viewports[0] == nullptr) { auto widget = &self.widgets[widx::viewport]; auto origin = Ui::Point(widget->left + self.x + 1, widget->top + self.y + 1); auto size = Ui::Size(widget->width() - 2, widget->height() - 2); ViewportManager::create(&self, 0, origin, size, self.savedView.zoomLevel, targetEntity); self.invalidate(); self.flags |= WindowFlags::viewportNoScrolling; } // 0x004B5E88 end if (self.viewports[0] != nullptr) { self.viewports[0]->flags = flags; self.invalidate(); } } static constexpr uint16_t rowHeights[vehicleTypeCount] = { 22, 22, 22, 22, 82, 45 }; static const WindowEventList& getEvents(); // 0x004B60DC static Window* create(const EntityId head) { auto* const self = WindowManager::createWindow(WindowType::vehicle, kWindowSize, WindowFlags::flag_11 | WindowFlags::flag_8 | WindowFlags::resizable, Main::getEvents()); self->setWidgets(widgets); self->number = enumValue(head); const auto* vehicle = Common::getVehicle(*self); if (vehicle == nullptr) { return self; } self->owner = vehicle->owner; self->rowHeight = rowHeights[static_cast<uint8_t>(vehicle->vehicleType)]; self->currentTab = 0; self->frameNo = 0; resetDisabledWidgets(*self); self->minWidth = kMinWindowSize.width; self->minHeight = kMinWindowSize.height; self->maxWidth = kMaxWindowSize.width; self->maxHeight = kMaxWindowSize.height; self->var_85C = -1; WindowManager::close(WindowType::dragVehiclePart, 0); _dragCarComponent = nullptr; _dragVehicleHead = EntityId::null; const auto* skin = ObjectManager::get<InterfaceSkinObject>(); self->setColour(WindowColour::secondary, skin->windowPlayerColor); return self; } // 0x004B6033 Window* open(const Vehicles::VehicleBase* vehicle) { if (vehicle == nullptr) { return nullptr; } const auto head = vehicle->getHead(); auto* self = WindowManager::find(WindowType::vehicle, enumValue(head)); if (self != nullptr) { if (ToolManager::isToolActive(self->type, self->number)) { ToolManager::toolCancel(); } self = WindowManager::bringToFront(WindowType::vehicle, enumValue(head)); } if (self == nullptr) { self = create(head); self->savedView.clear(); } self->currentTab = 0; self->invalidate(); self->setWidgets(widgets); self->holdableWidgets = holdableWidgets; self->eventHandlers = &getEvents(); self->activatedWidgets = 0; resetDisabledWidgets(*self); self->initScrollWidgets(); createViewport(*self); return self; } // 0x004B288F static void onChangeDirection(Window& self) { if (ToolManager::isToolActive(self.type, self.number, widx::pickup)) { getGameState().pickupDirection = getGameState().pickupDirection ^ 1; return; } GameCommands::setErrorTitle(StringIds::cant_reverse_train); GameCommands::VehicleReverseArgs args{}; args.head = static_cast<EntityId>(self.number); GameCommands::doCommand(args, GameCommands::Flags::apply); } static void onCentreViewportControl(Window& self) { Dropdown::add(0, StringIds::dropdown_stringid, StringIds::dropdown_viewport_move); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::dropdown_viewport_focus); Widget& widget = self.widgets[widx::centreViewport]; Dropdown::showText( self.x + widget.left, self.y + widget.top, widget.width(), widget.height(), self.getColour(WindowColour::secondary), 2, 0); Dropdown::setItemSelected(0); Dropdown::setHighlightedItem(0); } // 0x004B24D1 static void onMouseUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::closeButton: WindowManager::close(&self); break; case Common::widx::caption: Common::renameVehicle(self, widgetIndex); break; case Common::widx::tabMain: case Common::widx::tabDetails: case Common::widx::tabCargo: case Common::widx::tabFinances: case Common::widx::tabRoute: Common::switchTab(self, widgetIndex); break; case widx::pickup: Common::onPickup(self, widx::pickup); break; case widx::changeDirection: onChangeDirection(self); break; case widx::passSignal: { GameCommands::VehiclePassSignalArgs args{}; args.head = EntityId(self.number); GameCommands::setErrorTitle(StringIds::cant_pass_signal_at_danger); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } } } // 0x004B30F3 static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::vehicle, self.number, Common::widx::tabMain); WindowManager::invalidateWidget(WindowType::vehicle, self.number, widx::status); WindowManager::invalidateWidget(WindowType::vehicle, self.number, widx::pickup); WindowManager::invalidateWidget(WindowType::vehicle, self.number, widx::passSignal); WindowManager::invalidateWidget(WindowType::vehicle, self.number, widx::changeDirection); if (self.isDisabled(widx::pickup)) { ToolManager::toolCancel(WindowType::vehicle, self.number); return; } auto head = Common::getVehicle(self); if (head == nullptr) { return; } // If vehicle not placed put into pick-up mode if window in focus if (head->isPlaced()) { return; } if (!WindowManager::isInFront(&self)) { return; } if (head->owner != CompanyManager::getControllingId()) { return; } if (!ToolManager::isToolActive(WindowType::vehicle, self.number)) { Common::onPickup(self, widx::pickup); } } // 0x004B3210 static void onResize(Window& self) { Common::setCaptionEnableState(self); self.setSize(kMinWindowSize, kMaxWindowSize); if (self.viewports[0] != nullptr) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } uint16_t newWidth = self.width - 30; if (head->owner != CompanyManager::getControllingId()) { newWidth += 22; } uint16_t newHeight = self.height - 59; if (head->hasVehicleFlags(VehicleFlags::manualControl) && head->owner == CompanyManager::getControllingId()) { newWidth -= 27; } auto& viewport = self.viewports[0]; if (newWidth != viewport->width || newHeight != viewport->height) { self.invalidate(); viewport->width = newWidth; viewport->height = newHeight; viewport->viewWidth = newWidth << viewport->zoom; viewport->viewHeight = newHeight << viewport->zoom; self.savedView.clear(); } } createViewport(self); } // 0x004B274B static void stopStartOpen(Window& self) { Dropdown::add(0, StringIds::dropdown_stringid, StringIds::stop); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::start); Dropdown::add(2, StringIds::dropdown_stringid, StringIds::manual); auto dropdownCount = 2; auto head = Common::getVehicle(self); if (head == nullptr) { return; } if (head->mode == TransportMode::rail && SceneManager::isDriverCheatEnabled()) { dropdownCount = 3; } Widget& widget = self.widgets[widx::stopStart]; Dropdown::showText( self.x + widget.left, self.y + widget.top, widget.width(), widget.height(), self.getColour(WindowColour::secondary), dropdownCount, 0); auto selected = 0; // Stop if (!head->hasVehicleFlags(VehicleFlags::commandStop)) { selected = 1; // Start } if (head->hasVehicleFlags(VehicleFlags::manualControl)) { selected = 2; // Manual } Dropdown::setItemSelected(selected); Dropdown::setHighlightedItem(selected == 0 ? 1 : 0); // Stop becomes start highlighted. Manual or Start becomes Stop highlighted } // 0x004B2637 static void onSpeedControl(Window& self) { Input::setClickRepeatTicks(31); auto pos = Input::getScrollLastLocation(); auto speed = pos.y - (self.y + self.widgets[widx::speedControl].top + 58); speed = -(std::clamp(speed, -40, 40)); GameCommands::VehicleSpeedControlArgs args{}; args.head = EntityId(self.number); args.speed = speed; GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x004B251A static void onMouseDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::stopStart: stopStartOpen(self); break; case widx::speedControl: onSpeedControl(self); break; case widx::centreViewport: onCentreViewportControl(self); break; } } // 0x004B253A static void onStopStartDropdown(Window& self, const int16_t itemIndex) { auto item = itemIndex == -1 ? Dropdown::getHighlightedItem() : itemIndex; if (item == -1 || item > 2) { return; } static constexpr std::pair<StringId, VehicleChangeRunningModeArgs::Mode> itemToGameCommandInfo[3] = { { StringIds::cant_stop_string_id, VehicleChangeRunningModeArgs::Mode::stopVehicle }, { StringIds::cant_start_string_id, VehicleChangeRunningModeArgs::Mode::startVehicle }, { StringIds::cant_select_manual_mode_string_id, VehicleChangeRunningModeArgs::Mode::driveManually }, }; auto [errorTitle, mode] = itemToGameCommandInfo[item]; GameCommands::setErrorTitle(errorTitle); auto head = Common::getVehicle(self); if (head == nullptr) { return; } auto args = FormatArguments::common(); args.skip(6); args.push(head->name); args.push(head->ordinalNumber); VehicleChangeRunningModeArgs vargs{}; vargs.head = EntityId(self.number); vargs.mode = mode; GameCommands::doCommand(vargs, GameCommands::Flags::apply); } static void onCentreViewportDropdown(Window& self, const int16_t itemIndex) { if (itemIndex <= 0) { // Centre main window on vehicle, without locking. self.viewportCentreMain(); } // Focus main viewport on vehicle if (itemIndex == 1) { auto vehHead = Common::getVehicle(self); if (vehHead == nullptr) { return; } Vehicles::Vehicle train(*vehHead); EntityId targetEntity = train.veh2->id; // Focus viewport on vehicle, with locking. auto main = WindowManager::getMainWindow(); Windows::Main::viewportFocusOnEntity(*main, targetEntity); } } // 0x004B253A static void onDropdown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t itemIndex) { switch (widgetIndex) { case widx::stopStart: onStopStartDropdown(self, itemIndex); break; case widx::centreViewport: onCentreViewportDropdown(self, itemIndex); break; } } // 0x004B2545 static void onToolUpdate(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::pickup) { return; } Common::pickupToolUpdate(self, x, y); } // 0x004B2550 static void onToolDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::pickup) { return; } Common::pickupToolDown(self, x, y); } // 0x004B255B static void onToolAbort(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex != widx::pickup) { return; } Common::pickupToolAbort(self); } // 0x004B31F2 static std::optional<FormatArguments> tooltip(Ui::Window& self, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; auto head = Common::getVehicle(self); if (head == nullptr) { return {}; } args.skip(2); args.push(StringIds::getVehicleType(head->vehicleType)); return args; } // 0x004B1EB5 static void prepareDraw(Window& self) { Common::setActiveTabs(self); auto head = Common::getVehicle(self); if (head == nullptr) { return; } Vehicles::Vehicle train(*head); self.widgets[widx::stopStart].hidden = false; self.widgets[widx::pickup].hidden = false; self.widgets[widx::passSignal].hidden = false; self.widgets[widx::changeDirection].hidden = false; if (head->mode != TransportMode::rail) { self.widgets[widx::passSignal].hidden = true; } if (head->mode == TransportMode::air || head->mode == TransportMode::water) { self.widgets[widx::changeDirection].hidden = true; } self.disabledWidgets &= ~interactiveWidgets; auto veh1 = train.veh1; if (train.cars.empty()) { self.disabledWidgets |= (1 << widx::pickup); } if (veh1->var_3C >= 0x3689) { self.disabledWidgets |= (1 << widx::pickup) | (1 << widx::changeDirection); } if (head->mode == TransportMode::air || head->mode == TransportMode::water) { if (head->status != Vehicles::Status::stopped && head->status != Vehicles::Status::loading && head->tileX != -1) { self.disabledWidgets |= (1 << widx::pickup); } } if (head->tileX == -1) { self.disabledWidgets |= (1 << widx::stopStart) | (1 << widx::passSignal) | (1 << widx::changeDirection) | (1 << widx::centreViewport); if (ToolManager::isToolActive(WindowType::vehicle, self.number)) { self.disabledWidgets &= ~(1 << widx::changeDirection); //??? } } if (head->status != Vehicles::Status::waitingAtSignal) { self.disabledWidgets |= (1 << widx::passSignal); } auto company = CompanyManager::get(head->owner); // Set title. auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); if (CompanyManager::isPlayerCompany(head->owner)) { args.push(StringIds::company_vehicle); } else { args.push(StringIds::competitor_vehicle); } args.push(company->name); args.skip(2); args.push(head->name); args.push(head->ordinalNumber); uint32_t stopStartImage = ImageIds::red_flag; if (head->hasVehicleFlags(VehicleFlags::manualControl)) { stopStartImage = ImageIds::yellow_flag; } else if (head->hasVehicleFlags(VehicleFlags::commandStop)) { stopStartImage = ImageIds::red_flag; } else { stopStartImage = ImageIds::green_flag; } self.widgets[widx::stopStart].image = stopStartImage; auto [pickupImage, pickupTooltip] = Common::getPickupImageIdandTooltip(*head, head->isPlaced()); self.widgets[widx::pickup].image = Gfx::recolour(pickupImage); self.widgets[widx::pickup].tooltip = pickupTooltip; self.widgets[widx::speedControl].hidden = true; self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::closeButton].left = self.width - 15; self.widgets[Common::widx::closeButton].right = self.width - 3; int viewportRight = self.width - 26; if (head->hasVehicleFlags(VehicleFlags::manualControl)) { if (CompanyManager::isPlayerCompany(head->owner)) { viewportRight -= 27; self.widgets[widx::speedControl].hidden = false; } } self.widgets[widx::viewport].right = viewportRight; self.widgets[widx::viewport].bottom = self.height - 1 - 13; self.widgets[widx::status].top = self.height - 1 - 13 + 2; self.widgets[widx::status].bottom = self.height - 1 - 13 + 2 + 9; self.widgets[widx::status].right = self.width - 14; self.widgets[widx::stopStart].right = self.width - 2; self.widgets[widx::pickup].right = self.width - 2; self.widgets[widx::passSignal].right = self.width - 2; self.widgets[widx::changeDirection].right = self.width - 2; self.widgets[widx::stopStart].left = self.width - 2 - 23; self.widgets[widx::pickup].left = self.width - 2 - 23; self.widgets[widx::passSignal].left = self.width - 2 - 23; self.widgets[widx::changeDirection].left = self.width - 2 - 23; self.widgets[widx::speedControl].left = self.width - 2 - 23 - 26; self.widgets[widx::speedControl].right = self.width - 2 - 23 - 26 + 23; if (!CompanyManager::isPlayerCompany(head->owner)) { self.widgets[widx::stopStart].hidden = true; self.widgets[widx::pickup].hidden = true; self.widgets[widx::passSignal].hidden = true; self.widgets[widx::changeDirection].hidden = true; self.widgets[widx::viewport].right += 22; } self.widgets[widx::centreViewport].right = self.widgets[widx::viewport].right - 1; self.widgets[widx::centreViewport].bottom = self.widgets[widx::viewport].bottom - 1; self.widgets[widx::centreViewport].left = self.widgets[widx::viewport].right - 1 - 23; self.widgets[widx::centreViewport].top = self.widgets[widx::viewport].bottom - 1 - 23; Widget::leftAlignTabs(self, Common::widx::tabMain, Common::widx::tabRoute); } // 0x004B226D static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); Widget& pickupButton = self.widgets[widx::pickup]; if (!pickupButton.hidden) { if ((pickupButton.image & 0x20000000) != 0 && !self.isDisabled(widx::pickup)) { drawingCtx.drawImage( self.x + pickupButton.left, self.y + pickupButton.top, Gfx::recolour(pickupButton.image, CompanyManager::getCompanyColour(self.owner))); } } auto veh = Common::getVehicle(self); if (veh == nullptr) { return; } { auto status = veh->getStatus(); FormatArguments args = {}; args.push(status.status1); args.push(status.status1Args); args.push(status.status2); args.push(status.status2Args); StringId strFormat = StringIds::black_stringid_stringid; if (status.status2 == StringIds::null) { strFormat = StringIds::black_stringid; } auto& widget = self.widgets[widx::status]; auto point = Point(self.x + widget.left - 1, self.y + widget.top - 1); tr.drawStringLeftClipped(point, widget.width() - 1, Colour::black, strFormat, args); } Widget& speedWidget = self.widgets[widx::speedControl]; if (!speedWidget.hidden) { drawingCtx.drawImage( self.x + speedWidget.left, self.y + speedWidget.top + 10, Gfx::recolour(ImageIds::speed_control_track, self.getColour(WindowColour::secondary).c())); auto point = Point(self.x + speedWidget.midX(), self.y + speedWidget.top + 4); tr.drawStringCentred(point, Colour::black, StringIds::tiny_power); point = Point(self.x + speedWidget.midX(), self.y + speedWidget.bottom - 10); tr.drawStringCentred(point, Colour::black, StringIds::tiny_brake); drawingCtx.drawImage( self.x + speedWidget.left + 1, self.y + speedWidget.top + 57 - veh->manualPower, Gfx::recolour(ImageIds::speed_control_thumb, self.getColour(WindowColour::secondary).c())); } if (self.viewports[0] == nullptr && ToolManager::isToolActive(self.type, self.number)) { FormatArguments args = {}; args.push(StringIds::getVehicleType(veh->vehicleType)); auto& button = self.widgets[widx::viewport]; auto origin = Point(self.x + button.midX(), self.y + button.midY()); tr.drawStringCentredWrapped(origin, button.width() - 6, Colour::black, StringIds::click_on_view_select_string_id_start, args); } } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .textInput = Common::textInput, .viewportRotate = createViewport, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Details { // 0x4B60CC Window* open(const Vehicles::VehicleBase* vehicle) { auto self = Main::open(vehicle); if (self != nullptr) { self->callOnMouseUp(Common::widx::tabDetails, self->widgets[Common::widx::tabDetails].id); } return self; } static void cloneVehicle(Window& self) { static loco_global<EntityId, 0x0113642A> _113642A; auto head = Common::getVehicle(self); if (head == nullptr) { return; } GameCommands::setErrorTitle(StringIds::cant_clone_vehicle); GameCommands::VehicleCloneArgs args{}; args.vehicleHeadId = head->head; if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { auto* newVehicle = EntityManager::get<Vehicles::VehicleBase>(_113642A); if (newVehicle != nullptr) { Windows::Vehicle::Details::open(newVehicle); } } } // 0x004B3823 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::closeButton: WindowManager::close(&self); break; case Common::widx::caption: Common::renameVehicle(self, widgetIndex); break; case Common::widx::tabMain: case Common::widx::tabDetails: case Common::widx::tabCargo: case Common::widx::tabFinances: case Common::widx::tabRoute: Common::switchTab(self, widgetIndex); break; case widx::pickup: Common::onPickup(self, widx::pickup); break; case widx::remove: { auto head = Common::getVehicle(self); if (head == nullptr) { break; } FormatArguments args{}; args.skip(10); args.push(head->name); args.push(head->ordinalNumber); GameCommands::setErrorTitle(StringIds::cant_sell_string_id); GameCommands::VehicleSellArgs gcArgs{}; gcArgs.car = head->id; GameCommands::doCommand(gcArgs, GameCommands::Flags::apply); break; } } } // 0x004B3D73 static void onResize(Window& self) { Common::setCaptionEnableState(self); if (CompanyManager::getControllingId() == self.owner) { self.setSize(kMinWindowSizeWithPaintEnabled, kMaxWindowSize); } else { self.setSize(kMinWindowSize, kMaxWindowSize); } } static void onMouseDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == widx::buildNew) { Dropdown::add(0, StringIds::dropdown_stringid, StringIds::dropdown_modify_vehicle); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::dropdown_clone_vehicle); auto& widget = self.widgets[widx::buildNew]; Dropdown::showText( self.x + widget.left, self.y + widget.top, widget.width(), widget.height(), self.getColour(WindowColour::secondary), 2, 0); Dropdown::setItemSelected(0); Dropdown::setHighlightedItem(0); return; } if (widgetIndex == widx::paintColourPrimary || widgetIndex == widx::paintColourSecondary) { auto availableColours = 0x7FFFFFFF; Colour selectedColour = ImageId::fromUInt32(self.widgets[widgetIndex].image).getPrimary(); Dropdown::showColour(&self, &self.widgets[widgetIndex], availableColours, selectedColour, self.getColour(WindowColour::secondary)); return; } if (widgetIndex == widx::paintBrush) { Dropdown::add(0, StringIds::dropdown_stringid, StringIds::vehicleRepaintTool); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::vehicleRepaintEntireVehicle); auto& widget = self.widgets[widx::paintBrush]; Dropdown::showText( self.x + widget.left, self.y + widget.top, widget.width(), widget.height(), self.getColour(WindowColour::secondary), 2, 0); Dropdown::setItemSelected(0); Dropdown::setHighlightedItem(0); return; } } // 0x004B253A static void onDropdown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t itemIndex) { if (widgetIndex == widx::buildNew) { if (itemIndex <= 0) { BuildVehicle::openByVehicleId(EntityId(self.number)); } else if (itemIndex == 1) { cloneVehicle(self); } return; } if (widgetIndex == widx::paintColourPrimary || widgetIndex == widx::paintColourSecondary) { if (itemIndex == -1) { return; } Colour selectedColour = static_cast<Colour>(Dropdown::getItemArgument(itemIndex, 2)); self.widgets[widgetIndex].image = Widget::kImageIdColourSet | ImageId::fromUInt32(ImageIds::colour_swatch_recolourable).withPrimary(selectedColour).toUInt32(); self.invalidate(); return; } if (widgetIndex == widx::paintBrush) { if (itemIndex == 1 || Input::hasKeyModifier(Input::KeyModifier::shift)) { paintEntireTrain(self); if (!isPaintToolActive(self)) { paintToolBegin(self); } } else if (itemIndex <= 0) { paintToolBegin(self); } return; } } // 0x004B3C45 // "Show <vehicle> design details and options" tab in vehicle window static void onUpdate(Window& self) { if (EntityId(self.number) == _dragVehicleHead) { if (WindowManager::find(WindowType::dragVehiclePart) == nullptr) { _dragVehicleHead = EntityId::null; _dragCarComponent = nullptr; self.invalidate(); } } self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::vehicle, self.number, Common::widx::tabDetails); if (_dragVehicleHead == EntityId::null && self.isActivated(widx::remove)) { self.activatedWidgets &= ~(1ULL << widx::remove); WindowManager::invalidateWidget(WindowType::vehicle, self.number, widx::remove); } if (self.isDisabled(widx::pickup)) { ToolManager::toolCancel(WindowType::vehicle, self.number); return; } auto vehicle = Common::getVehicle(self); if (vehicle == nullptr) { return; } if (vehicle->isPlaced()) { return; } if (!WindowManager::isInFrontAlt(&self)) { return; } if (vehicle->owner != CompanyManager::getControllingId()) { return; } if (!ToolManager::isToolActive(WindowType::vehicle, self.number)) { Common::onPickup(self, widx::pickup); } } // 0x004B385F static void onToolUpdate(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { switch (widgetIndex) { case widx::pickup: Common::pickupToolUpdate(self, x, y); break; default: break; } } // 0x004B386A static void onToolDown(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { switch (widgetIndex) { case widx::pickup: Common::pickupToolDown(self, x, y); break; case widx::paintBrush: paintToolDown(self, x, y); break; default: break; } } // 0x004B3875 static void onToolAbort(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::pickup: Common::pickupToolAbort(self); break; case widx::paintBrush: paintToolAbort(self); break; default: break; } } // 0x4B38FA static void getScrollSize(Ui::Window& self, [[maybe_unused]] const uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = Common::getNumCars(self) * self.rowHeight; } // 0x004B3B54 static void scrollMouseDown(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } if (head->owner != CompanyManager::getControllingId()) { return; } auto car = Common::getCarFromScrollView(self, y); if (!car) { return; } OpenLoco::Vehicles::Vehicle train{ *head }; for (auto c : train.cars) { if (c.front == car->front) { if (isPaintToolActive(self)) { paintToolDownScroll(self, c, x); return; } DragVehiclePart::open(c); break; } } } // 0x004B399E static void scrollMouseOver(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { Ui::ToolTip::setTooltipTimeout(2000); self.flags &= ~WindowFlags::notScrollView; auto car = Common::getCarFromScrollView(self, y); StringId tooltipFormat = StringIds::null; EntityId tooltipContent = EntityId::null; if (car) { tooltipFormat = StringIds::buffer_337; tooltipContent = car->front->id; } if (EntityId(self.rowHover) != tooltipContent) { self.rowHover = enumValue(tooltipContent); self.invalidate(); } char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_337)); if (StringManager::locoStrlen(buffer) != 0) { if (self.widgets[widx::carList].tooltip == tooltipFormat && self.var_85C == enumValue(tooltipContent)) { return; } } self.widgets[widx::carList].tooltip = tooltipFormat; self.var_85C = enumValue(tooltipContent); ToolTip::closeAndReset(); if (tooltipContent == EntityId::null) { return; } Ui::ToolTip::set_52336E(true); auto vehicleObj = ObjectManager::get<VehicleObject>(car->front->objectId); { FormatArguments args{}; args.push(vehicleObj->name); buffer = StringManager::formatString(buffer, StringIds::tooltip_stringid, args); } { FormatArguments args{}; args.push(car->front->creationDay); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_built, args); } if (vehicleObj->power != 0 && (vehicleObj->mode == TransportMode::road || vehicleObj->mode == TransportMode::rail)) { FormatArguments args{}; args.push(vehicleObj->power); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_power, args); } if (vehicleObj->mode == TransportMode::rail || vehicleObj->mode == TransportMode::road) { FormatArguments args{}; args.push<uint32_t>(StringManager::internalLengthToComma1DP(vehicleObj->getLength())); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_length, args); } { FormatArguments args{}; args.push(vehicleObj->weight); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_weight, args); } { FormatArguments args{}; args.push(vehicleObj->speed); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_max_speed, args); } if (vehicleObj->hasFlags(VehicleObjectFlags::rackRail)) { FormatArguments args{}; args.push(vehicleObj->rackSpeed); auto rackRailObj = ObjectManager::get<TrackExtraObject>(vehicleObj->rackRailType); args.push(rackRailObj->name); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_speed_on_stringid, args); } { FormatArguments args{}; args.push(car->front->refundCost); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_value, args); } if (car->front->reliability != 0) { FormatArguments args{}; args.push(car->front->reliability / 256); buffer = StringManager::formatString(buffer, StringIds::vehicle_details_tooltip_reliability, args); } } // 0x004B3880 TODO: common across 3 tabs static std::optional<FormatArguments> tooltip(Ui::Window& self, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_vehicle_list); auto vehicle = Common::getVehicle(self); if (vehicle == nullptr) { return {}; } args.push(StringIds::getVehicleType(vehicle->vehicleType)); return args; } // 0x004B3B18 static Ui::CursorId cursor(Window& self, const WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, const int16_t y, const Ui::CursorId fallback) { if (widgetIdx != widx::carList) { return fallback; } auto head = Common::getVehicle(self); if (head == nullptr) { return fallback; } if (head->owner != CompanyManager::getControllingId()) { return fallback; } auto selectedCar = Common::getCarFromScrollView(self, y); if (!selectedCar) { return fallback; } if (isPaintToolActive(self)) { return CursorId::brush; } return CursorId::openHand; } static const std::map<VehicleType, uint32_t> additionalVehicleButtonByVehicleType{ { VehicleType::train, InterfaceSkin::ImageIds::build_additional_train }, { VehicleType::bus, InterfaceSkin::ImageIds::build_additional_bus }, { VehicleType::truck, InterfaceSkin::ImageIds::build_additional_truck }, { VehicleType::tram, InterfaceSkin::ImageIds::build_additional_tram }, { VehicleType::aircraft, InterfaceSkin::ImageIds::build_additional_aircraft }, { VehicleType::ship, InterfaceSkin::ImageIds::build_additional_ship }, }; constexpr auto kVehicleDetailsOffset = 2; constexpr auto kVehicleDetailsLineHeight = 12; constexpr auto kVehicleDetailsTextHeight2Lines = kVehicleDetailsOffset + kVehicleDetailsLineHeight * 2; constexpr auto kVehicleDetailsTextHeight3Lines = kVehicleDetailsOffset + kVehicleDetailsLineHeight * 3; static auto getVehicleDetailsHeight(const OpenLoco::TransportMode transportMode) { return transportMode == TransportMode::rail || transportMode == TransportMode::road ? kVehicleDetailsTextHeight3Lines : kVehicleDetailsTextHeight2Lines; } static void alignToRightBar(Window& self, widx widget) { self.widgets[widget].left = self.width - 25; self.widgets[widget].right = self.width - 2; } // 0x004B3300 static void prepareDraw(Window& self) { Common::setActiveTabs(self); auto head = Common::getVehicle(self); if (head == nullptr) { return; } // Set title. { auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(head->name); args.push(head->ordinalNumber); } self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::closeButton].left = self.width - 15; self.widgets[Common::widx::closeButton].right = self.width - 3; Widget::leftAlignTabs(self, Common::widx::tabMain, Common::widx::tabRoute); self.widgets[widx::carList].right = self.width - 26; self.widgets[widx::carList].bottom = self.height - getVehicleDetailsHeight(head->getTransportMode()); alignToRightBar(self, widx::buildNew); alignToRightBar(self, widx::pickup); alignToRightBar(self, widx::remove); alignToRightBar(self, widx::paintBrush); if (isPaintToolActive(self)) { self.activatedWidgets |= (1U << widx::paintBrush); self.widgets[widx::carList].bottom = self.height - kVehicleDetailsTextHeight3Lines; self.widgets[widx::paintColourPrimary].hidden = false; self.widgets[widx::paintColourPrimary].right = self.width - 23; self.widgets[widx::paintColourPrimary].left = self.width - 39; self.widgets[widx::paintColourPrimary].bottom = self.height - 17; self.widgets[widx::paintColourPrimary].top = self.height - 33; self.widgets[widx::paintColourSecondary].hidden = false; self.widgets[widx::paintColourSecondary].right = self.width - 5; self.widgets[widx::paintColourSecondary].left = self.width - 21; self.widgets[widx::paintColourSecondary].bottom = self.height - 17; self.widgets[widx::paintColourSecondary].top = self.height - 33; } else { self.activatedWidgets &= ~(1U << widx::paintBrush); self.widgets[widx::paintColourPrimary].hidden = true; self.widgets[widx::paintColourSecondary].hidden = true; } // Differs to main tab! Unsure why. if (head->isPlaced()) { self.widgets[widx::pickup].hidden = true; } if (head->owner != CompanyManager::getControllingId()) { self.widgets[widx::carList].bottom = self.height - getVehicleDetailsHeight(head->getTransportMode()); self.widgets[Details::widx::paintColourPrimary].hidden = true; self.widgets[Details::widx::paintColourSecondary].hidden = true; self.widgets[widx::buildNew].hidden = true; self.widgets[widx::pickup].hidden = true; self.widgets[widx::remove].hidden = true; self.widgets[widx::carList].right = self.width - 4; self.widgets[widx::paintBrush].hidden = true; self.widgets[widx::paintBrush].content = Widget::kContentNull; } else { self.widgets[widx::buildNew].hidden = false; self.widgets[widx::pickup].hidden = false; self.widgets[widx::remove].hidden = false; self.widgets[widx::paintBrush].bottom = self.height - kVehicleDetailsTextHeight3Lines; self.widgets[widx::paintBrush].top = self.height - kVehicleDetailsTextHeight3Lines - 24; } auto skin = ObjectManager::get<InterfaceSkinObject>(); auto buildImage = skin->img + additionalVehicleButtonByVehicleType.at(head->vehicleType); self.widgets[widx::buildNew].image = Gfx::recolour(buildImage, CompanyManager::getCompanyColour(self.owner)) | Widget::kImageIdColourSet; Vehicles::Vehicle train{ *head }; if (train.cars.empty()) { self.disabledWidgets |= 1 << widx::pickup; } else { self.disabledWidgets &= ~(1ULL << widx::pickup); } auto [pickupImage, pickupTooltip] = Common::getPickupImageIdandTooltip(*head, head->isPlaced()); self.widgets[widx::pickup].image = Gfx::recolour(pickupImage); self.widgets[widx::pickup].tooltip = pickupTooltip; } static void paintEntireTrain(Window& self) { GameCommands::VehicleRepaintArgs args{}; args.paintFlags = GameCommands::VehicleRepaintFlags::paintFromVehicleUi | GameCommands::VehicleRepaintFlags::applyToEntireTrain; args.head = EntityId(self.number); args.setColours(getPaintToolColour(self)); GameCommands::doCommand(args, GameCommands::Flags::apply); self.invalidate(); } static void paintToolDown(Window& self, const int16_t x, const int16_t y) { auto* head = Common::getVehicle(self); if (head == nullptr) { return; } auto interaction = ViewportInteraction::getItemLeft(x, y); if (interaction.type == ViewportInteraction::InteractionItem::entity) { auto _entity = reinterpret_cast<EntityBase*>(interaction.object); auto veh = _entity->asBase<Vehicles::VehicleBase>(); if (veh->getHead() != EntityId(self.number)) { return; } GameCommands::VehicleRepaintArgs args{}; args.paintFlags = GameCommands::VehicleRepaintFlags::paintFromVehicleUi; if (Input::hasKeyModifier(Input::KeyModifier::control)) { args.paintFlags ^= GameCommands::VehicleRepaintFlags::applyToEntireCar; } if (Input::hasKeyModifier(Input::KeyModifier::shift)) { args.paintFlags |= GameCommands::VehicleRepaintFlags::applyToEntireTrain; } args.setColours(getPaintToolColour(self)); args.head = veh->id; GameCommands::doCommand(args, GameCommands::Flags::apply); self.invalidate(); } } static void paintToolDownScroll(Window& self, Vehicles::Car car, const int16_t x) { GameCommands::VehicleRepaintArgs args{}; args.paintFlags = GameCommands::VehicleRepaintFlags::paintFromVehicleUi; args.setColours(getPaintToolColour(self)); args.head = car.front->id; if (Input::hasKeyModifier(Input::KeyModifier::shift)) { args.paintFlags |= GameCommands::VehicleRepaintFlags::applyToEntireTrain; } if (Input::hasKeyModifier(Input::KeyModifier::control) && !args.hasRepaintFlags(GameCommands::VehicleRepaintFlags::applyToEntireTrain)) { auto obj = ObjectManager::get<VehicleObject>(car.front->objectId); if (obj == nullptr) { return; } constexpr const uint8_t drawYaw = 40; BodyItems items = getBodyItemsForVehicle(*obj, drawYaw, car); auto cursorPosX = x - self.widgets[widx::carList].left; for (BodyItem& body : items.items) { auto g1Elem = Gfx::getG1Element(body.image); auto spriteRight = body.dist + g1Elem->xOffset + g1Elem->width; if (cursorPosX <= spriteRight) { args.head = body.body; args.paintFlags ^= GameCommands::VehicleRepaintFlags::applyToEntireCar; break; } } } GameCommands::doCommand(args, GameCommands::Flags::apply); self.invalidate(); } static constexpr bool isPaintToolActive(Window& self) { return self.activatedWidgets & (1U << widx::paintBrushProxy); } static void paintToolBegin(Window& self) { bool active = ToolManager::toolSet(self, widx::paintBrush, CursorId::brush); self.activatedWidgets &= ~(1U << widx::paintBrushProxy); self.activatedWidgets |= (1U << widx::paintBrushProxy) * active; self.invalidate(); } static void paintToolAbort(Window& self) { ToolManager::toolCancel(self.type, self.number); self.activatedWidgets &= ~(1U << widx::paintBrush); self.invalidate(); } static ColourScheme getPaintToolColour(Window& self) { return { ImageId(self.widgets[widx::paintColourPrimary].image).getPrimary(), ImageId(self.widgets[widx::paintColourSecondary].image).getPrimary() }; } // 0x004B3542 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); // TODO: identical to main tab (doesn't appear to do anything useful) if (!self.widgets[widx::pickup].hidden) { if ((self.widgets[widx::pickup].image & (1 << 29)) && !self.isDisabled(widx::pickup)) { auto image = Gfx::recolour(self.widgets[widx::pickup].image, CompanyManager::getCompanyColour(self.owner)); drawingCtx.drawImage(self.widgets[widx::pickup].left + self.x, self.widgets[widx::pickup].top + self.y, image); } } uint16_t textRightEdge = isPaintToolActive(self) ? self.width - 39 : self.width; auto head = Common::getVehicle(self); if (head == nullptr) { return; } OpenLoco::Vehicles::Vehicle train{ *head }; Ui::Point pos = { static_cast<int16_t>(self.x + 3), static_cast<int16_t>(self.y + self.height - getVehicleDetailsHeight(head->getTransportMode()) + kVehicleDetailsOffset) }; { FormatArguments args{}; args.push(train.veh2->totalPower); args.push<uint32_t>(train.veh2->totalWeight); StringId str = StringIds::vehicle_details_weight; if (train.veh2->mode == TransportMode::rail || train.veh2->mode == TransportMode::road) { str = StringIds::vehicle_details_total_power_and_weight; } tr.drawStringLeftClipped(pos, std::min<uint16_t>(self.width - 6, textRightEdge), Colour::black, str, args); } { pos.y += kVehicleDetailsLineHeight; FormatArguments args{}; args.push<uint16_t>(train.veh2->maxSpeed == kSpeed16Null ? 0 : train.veh2->maxSpeed.getRaw()); args.push<uint16_t>(train.veh2->rackRailMaxSpeed == kSpeed16Null ? 0 : train.veh2->rackRailMaxSpeed.getRaw()); args.push<uint16_t>(train.veh2->reliability == 0 ? 64 : train.veh2->reliability); StringId str = StringIds::vehicle_details_max_speed_and_reliability; if (train.veh1->var_49 != 0) { str = StringIds::vehicle_details_max_speed_and_rack_rail_and_reliability; } tr.drawStringLeftClipped(pos, std::min<uint16_t>(self.width - 16, textRightEdge), Colour::black, str, args); } { // Draw car count and vehicle length pos.y += kVehicleDetailsLineHeight; FormatArguments args = {}; StringId str = StringIds::vehicle_length; args.push<uint32_t>(StringManager::internalLengthToComma1DP(head->getVehicleTotalLength())); if (train.veh2->mode == TransportMode::rail && head->getCarCount() > 1) { str = StringIds::vehicle_car_count_and_length; args.push<uint32_t>(head->getCarCount()); } tr.drawStringLeftClipped(pos, std::min<uint16_t>(self.width - 16, textRightEdge), Colour::black, str, args); } } // 0x004B36A3 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t i) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); auto head = Common::getVehicle(self); if (head == nullptr) { return; } OpenLoco::Vehicles::Vehicle train{ *head }; Ui::Point pos{ 0, 0 }; for (auto& car : train.cars) { StringId carStr = StringIds::black_stringid; if (EntityId(self.rowHover) == car.front->id) { carStr = StringIds::wcolour2_stringid; int16_t top = pos.y; int16_t bottom = pos.y + self.rowHeight - 1; if (_dragCarComponent != nullptr) { bottom = pos.y; top = pos.y - 1; carStr = StringIds::black_stringid; } drawingCtx.fillRect(0, top, self.width, bottom, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); } int16_t y = pos.y + (self.rowHeight - 22) / 2; const auto disableColour = car.front == _dragCarComponent ? std::make_optional(self.getColour(WindowColour::secondary).c()) : std::nullopt; drawVehicleInline(drawingCtx, car, { 0, y }, VehicleInlineMode::basic, VehiclePartsToDraw::bogies, disableColour); auto x = drawVehicleInline(drawingCtx, car, { 0, y }, VehicleInlineMode::basic, VehiclePartsToDraw::bodies, disableColour); auto vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); FormatArguments args{}; args.push(vehicleObj->name); x += 2; y = pos.y + (self.rowHeight / 2) - 6; { auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, carStr, args); } pos.y += self.rowHeight; } if (EntityId(self.rowHover) == train.tail->id && _dragCarComponent != nullptr) { drawingCtx.fillRect(0, pos.y - 1, self.width, pos.y, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); } } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = Common::event8, .event_09 = Common::event9, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .onToolAbort = onToolAbort, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .textInput = Common::textInput, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } static Ui::Window* getVehicleDetailsWindow(const Ui::Point& pos) { auto vehicleWindow = WindowManager::findAt(pos); if (vehicleWindow == nullptr || vehicleWindow->type != WindowType::vehicle || vehicleWindow->currentTab != (Common::widx::tabDetails - Common::widx::tabMain)) { return nullptr; } return vehicleWindow; } static Vehicles::VehicleBase* getCarFromScrollViewPos(Ui::Window& self, const Ui::Point& pos) { Input::setPressedWidgetIndex(widx::carList); auto res = Ui::ScrollView::getPart(self, &self.widgets[widx::carList], pos.x, pos.y); if (res.area != ScrollPart::view) { return nullptr; } auto y = self.rowHeight / 2 + res.scrollviewLoc.y; auto car = Common::getCarFromScrollView(self, y); if (!car) { auto head = Common::getVehicle(self); if (head == nullptr) { return nullptr; } Vehicles::Vehicle train(*head); return train.tail; } return car->front; } void scrollDrag(const Ui::Point& pos) { auto vehicleWindow = getVehicleDetailsWindow(pos); if (vehicleWindow == nullptr) { return; } auto targetWidget = vehicleWindow->findWidgetAt(pos.x, pos.y); switch (targetWidget) { case widx::remove: { if (!vehicleWindow->isActivated(widx::remove)) { vehicleWindow->activatedWidgets |= (1 << widx::remove); WindowManager::invalidateWidget(WindowType::vehicle, vehicleWindow->number, widx::remove); } return; } case widx::carList: { auto car = getCarFromScrollViewPos(*vehicleWindow, pos); if (car != nullptr) { vehicleWindow->flags &= ~WindowFlags::notScrollView; if (car->id != EntityId(vehicleWindow->rowHover)) { vehicleWindow->rowHover = enumValue(car->id); } vehicleWindow->invalidate(); } // TODO: define constant for hot zone if (pos.y < vehicleWindow->widgets[widx::carList].top + vehicleWindow->y + 5) { Ui::ScrollView::verticalNudgeUp(*vehicleWindow, vehicleWindow->getScrollDataIndex(widx::carList), widx::carList); } else if (pos.y > vehicleWindow->widgets[widx::carList].bottom + vehicleWindow->y - 5) { Ui::ScrollView::verticalNudgeDown(*vehicleWindow, vehicleWindow->getScrollDataIndex(widx::carList), widx::carList); } break; } } if (vehicleWindow->isActivated(widx::remove)) { vehicleWindow->activatedWidgets &= ~(1ULL << widx::remove); WindowManager::invalidateWidget(WindowType::vehicle, vehicleWindow->number, widx::remove); } } void scrollDragEnd(const Ui::Point& pos) { if (_dragCarComponent == nullptr) { return; } auto vehicleWindow = getVehicleDetailsWindow(pos); if (vehicleWindow == nullptr) { return; } auto targetWidget = vehicleWindow->findWidgetAt(pos.x, pos.y); switch (targetWidget) { case widx::remove: { GameCommands::VehicleSellArgs gcArgs{}; gcArgs.car = (*_dragCarComponent)->id; if (Common::confirmComponentChange(gcArgs.car, StringIds::confirm_vehicle_component_sell_cargo_warning_title, StringIds::confirm_vehicle_component_sell_cargo_warning_message, StringIds::confirm_vehicle_component_sell_cargo_warning_confirm)) { GameCommands::setErrorTitle(StringIds::cant_sell_vehicle); GameCommands::doCommand(gcArgs, GameCommands::Flags::apply); } break; } case widx::carList: { auto car = getCarFromScrollViewPos(*vehicleWindow, pos); if (car != nullptr) { GameCommands::VehicleRearrangeArgs args{}; args.source = (*_dragCarComponent)->id; args.dest = car->id; GameCommands::setErrorTitle(StringIds::cant_move_vehicle); GameCommands::doCommand(args, GameCommands::Flags::apply); } break; } } } // copied and modified from VehicleDraw::getDrawItemsForVehicle static BodyItems getBodyItemsForVehicle(const VehicleObject& vehObject, const uint8_t yaw, const Vehicles::Car& car) { const auto getScreenDistance = [](int32_t gameDist, uint8_t yaw) { const auto unk1 = Math::Trigonometry::computeXYVector(gameDist, yaw); const auto p1 = World::gameToScreen(World::Pos3(unk1.x, unk1.y, 0), 0); // This /4 is meant to be after the compute but we need to carry it to here // to keep precision high return -p1.x / 4; }; Vehicles::Vehicle train(car.front->head); BodyItems bodyItems{}; const auto isCarReversed = car.body->has38Flags(Vehicles::Flags38::isReversed); const auto isAnimated = false; uint8_t componentIndex = isCarReversed ? vehObject.numCarComponents - 1 : 0; for (auto& carComponent : car) { auto& componentObject = vehObject.carComponents[componentIndex]; // 0x01136172 auto unkDist = isCarReversed ? componentObject.backBogiePosition : componentObject.frontBogiePosition; auto carComponentLength = 0; if (componentObject.bodySpriteInd != SpriteIndex::null) { auto& bodySprites = vehObject.bodySprites[componentObject.bodySpriteInd & ~(1U << 7)]; carComponentLength = bodySprites.halfLength * 2; } auto unk1136174 = isCarReversed ? componentObject.frontBogiePosition : componentObject.backBogiePosition; auto bodyDist = bodyItems.totalDistance + (unkDist + carComponentLength - unk1136174) / 2; if (carComponent.body->objectSpriteType != SpriteIndex::null) { auto& bodySprites = vehObject.bodySprites[carComponent.body->objectSpriteType]; auto unk = yaw; if (carComponent.body->has38Flags(Vehicles::Flags38::isReversed)) { unk ^= 1U << 5; } auto rollIndex = isAnimated ? carComponent.body->animationFrame : 0; rollIndex += carComponent.body->cargoFrame; auto spriteIndex = getBodyImageIndex(bodySprites, Pitch::flat, unk, rollIndex, 0); bodyItems.items.push_back(BodyItem{ spriteIndex, getScreenDistance(bodyDist, yaw), carComponent.body->id }); } bodyItems.totalDistance += carComponentLength; if (isCarReversed) { componentIndex--; } else { componentIndex++; } } return bodyItems; } } namespace Cargo { static void onRefitButton(Window& self, const WidgetIndex_t wi, const WidgetId id); static bool canRefit(Vehicles::VehicleHead* headVehicle) { if (!CompanyManager::isPlayerCompany(headVehicle->owner)) { return false; } OpenLoco::Vehicles::Vehicle train(*headVehicle); if (train.cars.empty()) { return false; } auto object = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); return (object->hasFlags(VehicleObjectFlags::refittable)); } // 0x004B3DDE static void prepareDraw(Window& self) { Common::setActiveTabs(self); auto* headVehicle = Common::getVehicle(self); if (headVehicle == nullptr) { return; } // Set title. { auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(headVehicle->name); args.push(headVehicle->ordinalNumber); } self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::closeButton].left = self.width - 15; self.widgets[Common::widx::closeButton].right = self.width - 3; self.widgets[widx::cargoList].right = self.width - 26; self.widgets[widx::cargoList].bottom = self.height - 27; self.widgets[widx::refit].right = self.width - 2; self.widgets[widx::refit].left = self.width - 25; self.widgets[widx::refit].hidden = false; if (!canRefit(headVehicle)) { self.widgets[widx::refit].hidden = true; self.widgets[widx::cargoList].right = self.width - 26 + 22; } Widget::leftAlignTabs(self, Common::widx::tabMain, Common::widx::tabRoute); } // 0x004B3F0D static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); // draw total cargo char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); auto head = Common::getVehicle(self); if (head == nullptr) { return; } head->generateCargoTotalString(buffer); { FormatArguments args = {}; args.push<StringId>(StringIds::buffer_1250); auto point = Point(self.x + 3, self.y + self.height - 25); tr.drawStringLeftClipped(point, self.width - 15, Colour::black, StringIds::total_stringid, args); } // draw cargo capacity { buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_1250)); head->generateCargoCapacityString(buffer); FormatArguments args = {}; args.push<StringId>(StringIds::buffer_1250); auto point = Point(self.x + 3, self.y + self.height - 13); tr.drawStringLeftClipped(point, self.width - 15, Colour::black, StringIds::vehicle_capacity_stringid, args); } } // based on 0x004B40C7 static void drawCargoText(Gfx::DrawingContext& drawingCtx, const int16_t x, int16_t& y, const StringId strFormat, uint8_t cargoQty, uint8_t cargoType, StationId stationId) { if (cargoQty == 0) { return; } auto tr = Gfx::TextRenderer(drawingCtx); auto cargoObj = ObjectManager::get<CargoObject>(cargoType); auto unitNameFormat = cargoQty == 1 ? cargoObj->unitNameSingular : cargoObj->unitNamePlural; auto station = StationManager::get(stationId); FormatArguments args{}; args.push(StringIds::cargo_from); args.push(unitNameFormat); args.push<uint32_t>(cargoQty); args.push(station->name); args.push(station->town); auto point = Point(x, y); tr.drawStringLeft(point, Colour::black, strFormat, args); y += 10; } // 0x004B3F62 static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t i) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); auto* head = Common::getVehicle(self); if (head == nullptr) { return; } Vehicles::Vehicle train{ *head }; int16_t y = 0; for (auto& car : train.cars) { StringId strFormat = StringIds::black_stringid; auto front = car.front; auto body = car.body; // Draw hover background if applicable if (front->id == EntityId(self.rowHover)) { drawingCtx.fillRect(0, y, self.width, y + self.rowHeight - 1, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); strFormat = StringIds::wcolour2_stringid; } constexpr auto kCargoXPos = 24; // Get width of the drawing auto width = getWidthVehicleInline(car); // Actually draw it drawVehicleInline(drawingCtx, car, Ui::Point(kCargoXPos - width, y + (self.rowHeight - 22) / 2), VehicleInlineMode::basic, VehiclePartsToDraw::bogies); drawVehicleInline(drawingCtx, car, Ui::Point(kCargoXPos - width, y + (self.rowHeight - 22) / 2), VehicleInlineMode::basic, VehiclePartsToDraw::bodies); if (body->primaryCargo.type != 0xFF) { int16_t cargoTextYPos = y + self.rowHeight / 2 - ((self.rowHeight - 22) / 2) - 10; if (front->secondaryCargo.qty != 0 || body->primaryCargo.qty != 0) { if (body->primaryCargo.qty == 0 || front->secondaryCargo.qty == 0) { cargoTextYPos += 5; } drawCargoText(drawingCtx, kCargoXPos, cargoTextYPos, strFormat, body->primaryCargo.qty, body->primaryCargo.type, body->primaryCargo.townFrom); drawCargoText(drawingCtx, kCargoXPos, cargoTextYPos, strFormat, front->secondaryCargo.qty, front->secondaryCargo.type, front->secondaryCargo.townFrom); } else { FormatArguments args{}; args.push<StringId>(StringIds::cargo_empty); auto point = Point(kCargoXPos, cargoTextYPos + 5); tr.drawStringLeft(point, Colour::black, strFormat, args); } } y += self.rowHeight; } } // 0x004B41BD static void onMouseUp(Window& self, const WidgetIndex_t i, [[maybe_unused]] const WidgetId id) { switch (i) { case Common::widx::closeButton: WindowManager::close(&self); break; case Common::widx::tabMain: case Common::widx::tabDetails: case Common::widx::tabCargo: case Common::widx::tabFinances: case Common::widx::tabRoute: Common::switchTab(self, i); break; case Common::widx::caption: Common::renameVehicle(self, i); break; } } // 0x004B41E2 static void onMouseDown(Window& self, const WidgetIndex_t i, [[maybe_unused]] const WidgetId id) { switch (i) { case widx::refit: onRefitButton(self, i, id); break; } } // 0x004B41E9 static void onDropdown(Window& self, const WidgetIndex_t i, [[maybe_unused]] const WidgetId id, const int16_t dropdownIndex) { switch (i) { case widx::refit: { if (dropdownIndex == -1) { break; } GameCommands::VehicleRefitArgs args{}; args.head = static_cast<EntityId>(self.number); args.cargoType = Dropdown::getItemArgument(dropdownIndex, 3); if (Common::confirmComponentChange(args.head, StringIds::confirm_vehicle_component_refit_cargo_warning_title, StringIds::confirm_vehicle_component_refit_cargo_warning_message, StringIds::confirm_vehicle_component_refit_cargo_warning_confirm)) { GameCommands::setErrorTitle(StringIds::cant_refit_vehicle); GameCommands::doCommand(args, GameCommands::Flags::apply); } break; } } } static void onRefitButton(Window& self, const WidgetIndex_t wi, [[maybe_unused]] const WidgetId id) { auto* head = Common::getVehicle(self); if (head == nullptr) { return; } Vehicles::Vehicle train(*head); auto vehicleObject = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); auto maxPrimaryCargo = vehicleObject->maxCargo[0]; auto primaryCargoId = Numerics::bitScanForward(vehicleObject->compatibleCargoCategories[0]); int32_t index = 0; for (uint16_t cargoId = 0; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); cargoId++) { auto cargoObject = ObjectManager::get<CargoObject>(cargoId); if (cargoObject == nullptr) { continue; } if (!cargoObject->hasFlags(CargoObjectFlags::refit)) { continue; } StringId format = StringIds::dropdown_stringid; if (cargoId == train.cars.firstCar.body->primaryCargo.type) { format = StringIds::dropdown_stringid_selected; } FormatArguments args{}; args.push<StringId>(cargoObject->unitNamePlural); args.push<uint32_t>(Vehicles::getNumUnitsForCargo(maxPrimaryCargo, primaryCargoId, cargoId)); args.push<uint16_t>(cargoId); Dropdown::add(index, format, args); index++; } Widget& button = self.widgets[wi]; Dropdown::showText( self.x + button.left, self.y + button.top, button.width(), button.height(), self.getColour(WindowColour::secondary), index, 0); Dropdown::setHighlightedItem(0); } // 0x004B4339 static std::optional<FormatArguments> tooltip(Ui::Window& self, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_vehicle_list); auto vehicle = Common::getVehicle(self); if (vehicle == nullptr) { return {}; } args.push(StringIds::getVehicleType(vehicle->vehicleType)); return args; } // 0x004B4360 static void getScrollSize(Ui::Window& self, [[maybe_unused]] const uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = Common::getNumCars(self) * self.rowHeight; } static char* generateCargoTooltipDetails(char* buffer, const StringId cargoFormat, const uint8_t cargoType, const uint8_t maxCargo, const uint32_t acceptedCargoTypes) { if (cargoType == 0xFF) { return buffer; } { auto cargoObj = ObjectManager::get<CargoObject>(cargoType); FormatArguments args{}; args.push(maxCargo == 1 ? cargoObj->unitNameSingular : cargoObj->unitNamePlural); args.push<uint32_t>(maxCargo); buffer = StringManager::formatString(buffer, cargoFormat, args); } auto availableCargoTypes = acceptedCargoTypes & ~(1 << cargoType); if (availableCargoTypes != 0) { *buffer++ = ' '; *buffer++ = '('; while (availableCargoTypes != 0) { auto type = Numerics::bitScanForward(availableCargoTypes); availableCargoTypes &= ~(1 << type); auto cargoObj = ObjectManager::get<CargoObject>(type); FormatArguments args{}; args.push(cargoObj->name); buffer = StringManager::formatString(buffer, StringIds::stats_or_string, args); *buffer++ = ' '; } --buffer; *buffer++ = ')'; *buffer++ = '\0'; } return buffer; } // 0x004B4404 static void scrollMouseOver(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { Ui::ToolTip::setTooltipTimeout(2000); self.flags &= ~WindowFlags::notScrollView; auto car = Common::getCarFromScrollView(self, y); StringId tooltipFormat = StringIds::null; EntityId tooltipContent = EntityId::null; if (car) { tooltipFormat = StringIds::buffer_337; tooltipContent = car->front->id; if (EntityId(self.rowHover) != tooltipContent) { self.rowHover = enumValue(tooltipContent); self.invalidate(); } } char* buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_337)); if (*buffer != '\0') { if (self.widgets[widx::cargoList].tooltip == tooltipFormat && EntityId(self.var_85C) == tooltipContent) { return; } } self.widgets[widx::cargoList].tooltip = tooltipFormat; self.var_85C = enumValue(tooltipContent); ToolTip::closeAndReset(); if (tooltipContent == EntityId::null) { return; } Ui::ToolTip::set_52336E(true); { auto vehicleObj = ObjectManager::get<VehicleObject>(car->front->objectId); FormatArguments args{}; args.push(vehicleObj->name); buffer = StringManager::formatString(buffer, StringIds::cargo_capacity_tooltip, args); } auto body = car->body; auto front = car->front; buffer = generateCargoTooltipDetails(buffer, StringIds::cargo_capacity, body->primaryCargo.type, body->primaryCargo.maxQty, body->primaryCargo.acceptedTypes); buffer = generateCargoTooltipDetails(buffer, StringIds::cargo_capacity_plus, front->secondaryCargo.type, front->secondaryCargo.maxQty, front->secondaryCargo.acceptedTypes); } // 0x004B4607 static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(self.type, self.number, 6); } // 0x004B4621 static void onResize(Window& self) { Common::setCaptionEnableState(self); self.setSize(kMinWindowSize, kMaxWindowSize); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = Common::event8, .event_09 = Common::event9, .getScrollSize = getScrollSize, .scrollMouseOver = scrollMouseOver, .textInput = Common::textInput, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Finances { // 0x004B56CE static void prepareDraw(Window& self) { Common::setActiveTabs(self); auto vehicle = Common::getVehicle(self); if (vehicle == nullptr) { return; } // Set title. { auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(vehicle->name); args.push(vehicle->ordinalNumber); } self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::closeButton].left = self.width - 15; self.widgets[Common::widx::closeButton].right = self.width - 3; Widget::leftAlignTabs(self, Common::widx::tabMain, Common::widx::tabRoute); } // 0x004B576C static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto pos = Ui::Point(self.x + 4, self.y + 46); auto head = Common::getVehicle(self); if (head == nullptr) { return; } Vehicles::Vehicle train(*head); auto veh1 = train.veh1; if (veh1->lastIncome.day != -1) { { FormatArguments args{}; args.push<uint32_t>(veh1->lastIncome.day); // Last income on: {DATE DMY} tr.drawStringLeft(pos, Colour::black, StringIds::last_income_on_date, args); } pos.y += 10; for (int i = 0; i < 4; i++) { auto cargoType = veh1->lastIncome.cargoTypes[i]; if (cargoType == 0xFF) { continue; } auto cargoObject = ObjectManager::get<CargoObject>(cargoType); auto str = veh1->lastIncome.cargoQtys[i] == 1 ? cargoObject->unitNameSingular : cargoObject->unitNamePlural; FormatArguments args{}; args.push(str); args.push<uint32_t>(veh1->lastIncome.cargoQtys[i]); args.push(veh1->lastIncome.cargoDistances[i]); args.push<uint16_t>(veh1->lastIncome.cargoAges[i]); args.push<currency32_t>(veh1->lastIncome.cargoProfits[i]); // {STRINGID} transported {INT16} blocks in {INT16} days = {CURRENCY32} pos.x += 4; tr.drawStringLeftWrapped(pos, self.width - 12, Colour::black, StringIds::transported_blocks_in_days, args); pos.x -= 4; // TODO: fix function to take pointer to offset pos.y += 12; } } else { // Last income: N/A" tr.drawStringLeft(pos, Colour::black, StringIds::last_income_na); pos.y += 10; } pos.y += 5; if (head->lastAverageSpeed != 0_mph) { // Last journey average speed: {VELOCITY} FormatArguments args{}; args.push(head->lastAverageSpeed); tr.drawStringLeft(pos, Colour::black, StringIds::last_journey_average_speed, args); pos.y += 10 + 5; } { // Monthly Running Cost: {CURRENCY32} FormatArguments args{}; args.push(head->calculateRunningCost()); tr.drawStringLeft(pos, Colour::black, StringIds::vehicle_monthly_running_cost, args); pos.y += 10; } { // Monthly Profit: {CURRENCY32} FormatArguments args{}; auto monthlyProfit = (train.veh2->totalRecentProfit()) / 4; args.push(monthlyProfit); tr.drawStringLeft(pos, Colour::black, StringIds::vehicle_monthly_profit, args); pos.y += 10 + 5; } { // Sale value of vehicle: {CURRENCY32} FormatArguments args{}; args.push(train.head->totalRefundCost); pos.y = self.y + self.height - 14; tr.drawStringLeft(pos, Colour::black, StringIds::sale_value_of_vehicle, args); } } // 0x004B5945 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::closeButton: WindowManager::close(&self); break; case Common::widx::caption: Common::renameVehicle(self, widgetIndex); break; case Common::widx::tabMain: case Common::widx::tabDetails: case Common::widx::tabCargo: case Common::widx::tabFinances: case Common::widx::tabRoute: Common::switchTab(self, widgetIndex); break; } } // 0x004B5977 static std::optional<FormatArguments> tooltip(Ui::Window& self, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; auto veh0 = Common::getVehicle(self); if (veh0 == nullptr) { return {}; } args.skip(2); args.push(StringIds::getVehicleType(veh0->vehicleType)); return args; } // 0x004B5995 static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(self.type, self.number, Common::widx::tabFinances); } // 0x004B59AF static void onResize(Window& self) { Common::setCaptionEnableState(self); self.setSize(kMinWindowSize, kMaxWindowSize); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .textInput = Common::textInput, .tooltip = tooltip, .prepareDraw = prepareDraw, .draw = draw, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Route { static Vehicles::OrderRingView getOrderTable(const Vehicles::VehicleHead* const head) { return Vehicles::OrderRingView(head->orderTableOffset); } // 0x004B509B static void close(Window& self) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } } static void orderDeleteCommand(Vehicles::VehicleHead* const head, const uint32_t orderOffset) { GameCommands::VehicleOrderDeleteArgs args{}; args.head = head->id; args.orderOffset = orderOffset - head->orderTableOffset; GameCommands::setErrorTitle(StringIds::empty); GameCommands::doCommand(args, GameCommands::Flags::apply); Vehicles::OrderManager::generateNumDisplayFrames(head); } // 0x004B4F6D static void onOrderDelete(Vehicles::VehicleHead* const head, const int16_t orderId) { // No deletable orders if (head->sizeOfOrderTable <= 1) { return; } // orderId can be -1 at this point for none selected auto i = 0; const Vehicles::Order* last = nullptr; for (const auto& order : getOrderTable(head)) { if (i == orderId) { orderDeleteCommand(head, order.getOffset()); return; } last = &order; i++; } // No order selected so delete the last one if (last != nullptr) { orderDeleteCommand(head, last->getOffset()); } } // 0x004B4C14 static bool orderUpCommand(Vehicles::VehicleHead* const head, const uint32_t orderOffset) { GameCommands::VehicleOrderUpArgs args{}; args.head = head->id; args.orderOffset = orderOffset - head->orderTableOffset; GameCommands::setErrorTitle(StringIds::empty); auto result = GameCommands::doCommand(args, GameCommands::Flags::apply); Vehicles::OrderManager::generateNumDisplayFrames(head); // Note: order changed, check if this matters. return result != GameCommands::FAILURE; } // 0x004B4CCB based on static bool orderDownCommand(Vehicles::VehicleHead* const head, const uint32_t orderOffset) { GameCommands::VehicleOrderDownArgs args{}; args.head = head->id; args.orderOffset = orderOffset - head->orderTableOffset; GameCommands::setErrorTitle(StringIds::empty); auto result = GameCommands::doCommand(args, GameCommands::Flags::apply); Vehicles::OrderManager::generateNumDisplayFrames(head); // Note: order changed, check if this matters. return result != GameCommands::FAILURE; } static bool orderReverseCommand(Vehicles::VehicleHead* const head) { GameCommands::VehicleOrderReverseArgs args{}; args.head = head->id; GameCommands::setErrorTitle(StringIds::empty); auto result = GameCommands::doCommand(args, GameCommands::Flags::apply); Vehicles::OrderManager::generateNumDisplayFrames(head); return result != GameCommands::FAILURE; } // 0x004B4BC1 / 0x004B4C78 based on static bool onOrderMove(Vehicles::VehicleHead* const head, const int16_t orderId, bool(orderMoveFunc)(Vehicles::VehicleHead*, uint32_t)) { // No moveable orders if (head->sizeOfOrderTable <= 1) { return false; } // Valid orderId should be positive (avoid -1 / null) if (orderId < 0) { return false; } auto* order = getOrderTable(head).atIndex(orderId); if (order != nullptr) { return orderMoveFunc(head, order->getOffset()); } return false; } // 0x004B4B43 static void onMouseUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { auto* head = Common::getVehicle(self); if (head == nullptr) { return; } switch (widgetIndex) { case Common::widx::closeButton: WindowManager::close(&self); break; case Common::widx::caption: Common::renameVehicle(self, widgetIndex); break; case Common::widx::tabMain: case Common::widx::tabDetails: case Common::widx::tabCargo: case Common::widx::tabFinances: case Common::widx::tabRoute: Common::switchTab(self, widgetIndex); break; case widx::orderDelete: { onOrderDelete(head, self.orderTableIndex); if (self.orderTableIndex == -1) { return; } // Refresh selection (check if we are now at no order selected) auto* order = getOrderTable(head).atIndex(self.orderTableIndex); // If no order selected anymore if (order == nullptr) { self.orderTableIndex = -1; } break; } case widx::localMode: { if (!CompanyManager::isPlayerCompany(head->owner)) { return; } Vehicles::Vehicle train(*head); if ((train.veh1->var_48 & Vehicles::Flags48::expressMode) != Vehicles::Flags48::none) { GameCommands::setErrorTitle(StringIds::empty); VehicleChangeRunningModeArgs args{}; args.head = head->id; args.mode = VehicleChangeRunningModeArgs::Mode::toggleLocalExpress; GameCommands::doCommand(args, GameCommands::Flags::apply); } break; } case widx::expressMode: { if (!CompanyManager::isPlayerCompany(head->owner)) { return; } Vehicles::Vehicle train(*head); if ((train.veh1->var_48 & Vehicles::Flags48::expressMode) == Vehicles::Flags48::none) { GameCommands::setErrorTitle(StringIds::empty); VehicleChangeRunningModeArgs args{}; args.head = head->id; args.mode = VehicleChangeRunningModeArgs::Mode::toggleLocalExpress; GameCommands::doCommand(args, GameCommands::Flags::apply); } break; } case widx::orderSkip: { GameCommands::setErrorTitle(StringIds::empty); GameCommands::VehicleOrderSkipArgs args{}; args.head = EntityId(self.number); GameCommands::doCommand(args, GameCommands::Flags::apply); break; } case widx::orderUp: if (onOrderMove(head, self.orderTableIndex, orderUpCommand)) { if (self.orderTableIndex <= 0) { return; } self.orderTableIndex--; } break; case widx::orderDown: if (onOrderMove(head, self.orderTableIndex, orderDownCommand)) { if (self.orderTableIndex < 0) { return; } auto* order = getOrderTable(head).atIndex(self.orderTableIndex); if (order != nullptr) { self.orderTableIndex++; } } break; case widx::orderReverse: { orderReverseCommand(head); break; } } } // 0x004B564E static void onResize(Window& self) { Common::setCaptionEnableState(self); self.setSize(kMinWindowSize, kMaxWindowSize); } // 0x004B4DD3 static void createOrderDropdown(Window& self, const WidgetIndex_t i, const StringId orderType) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } auto index = 0; for (uint16_t cargoId = 0; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoId) { if (!(head->trainAcceptedCargoTypes & (1 << cargoId))) { continue; } auto cargoObj = ObjectManager::get<CargoObject>(cargoId); FormatArguments args{}; args.push(cargoObj->name); args.push(cargoObj->unitInlineSprite); args.push(cargoId); Dropdown::add(index, orderType, args); index++; } auto x = self.widgets[i].left + self.x; auto y = self.widgets[i].top + self.y; auto width = self.widgets[i].width(); auto height = self.widgets[i].height(); Dropdown::showText(x, y, width, height, self.getColour(WindowColour::secondary), index, 0); Dropdown::setHighlightedItem(0); } // 0x004B4B8C static void onMouseDown(Window& self, const WidgetIndex_t i, [[maybe_unused]] const WidgetId id) { switch (i) { case widx::orderForceUnload: createOrderDropdown(self, i, StringIds::orders_unload_all2); break; case widx::orderWait: createOrderDropdown(self, i, StringIds::orders_wait_for_full_load_of2); break; } } // order : al (first 3 bits) // order argument : eax (3 - 32 bits), cx // Note will move orders so do not use while iterating OrderRingView // 0x004B4ECB static void addNewOrder(Window& self, const Vehicles::Order& order) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } auto chosenOffset = head->sizeOfOrderTable - 1; if (self.orderTableIndex != -1) { auto* chosenOrder = getOrderTable(head).atIndex(self.orderTableIndex); if (chosenOrder != nullptr) { chosenOffset = chosenOrder->getOffset() - head->orderTableOffset; } } GameCommands::setErrorTitle(StringIds::orders_cant_insert); auto previousSize = head->sizeOfOrderTable; GameCommands::VehicleOrderInsertArgs args{}; args.head = head->id; args.orderOffset = chosenOffset; args.rawOrder = order.getRaw(); GameCommands::doCommand(args, GameCommands::Flags::apply); Vehicles::OrderManager::generateNumDisplayFrames(head); if (head->sizeOfOrderTable == previousSize) { return; } if (self.orderTableIndex == -1) { return; } self.orderTableIndex++; } // 0x004B4BAC static void onDropdown(Window& self, const WidgetIndex_t i, [[maybe_unused]] const WidgetId id, const int16_t dropdownIndex) { auto item = dropdownIndex == -1 ? Dropdown::getHighlightedItem() : dropdownIndex; if (item == -1) { return; } switch (i) { case widx::orderForceUnload: { Vehicles::OrderUnloadAll unload(Dropdown::getItemArgument(item, 3)); addNewOrder(self, unload); break; } case widx::orderWait: { Vehicles::OrderWaitFor wait(Dropdown::getItemArgument(item, 3)); addNewOrder(self, wait); break; } } } // 0x004B55D1 // "Show <vehicle> route details" tab in vehicle window static void onUpdate(Window& self) { self.frameNo += 1; self.callPrepareDraw(); WindowManager::invalidateWidget(WindowType::vehicle, self.number, 8); if (!WindowManager::isInFront(&self)) { return; } auto* head = Common::getVehicle(self); if (head == nullptr) { return; } if (head->owner != CompanyManager::getControllingId()) { return; } if (!ToolManager::isToolActive(WindowType::vehicle, self.number)) { if (ToolManager::toolSet(self, widx::tool, CursorId::crosshair)) { self.invalidate(); Vehicles::OrderManager::generateNumDisplayFrames(head); } } } // 0x004B4D74 static std::optional<FormatArguments> tooltip(Ui::Window& self, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_orders_list); auto head = Common::getVehicle(self); if (head == nullptr) { return {}; } args.push(StringIds::getVehicleType(head->vehicleType)); return args; } // 0x004B5BB9 static ViewportInteraction::InteractionArg stationLabelAdjustedInteraction(const Vehicles::VehicleHead& head, int16_t orderTableIndex, StationId stationId, ViewportInteraction::InteractionArg interaction) { auto* station = StationManager::get(stationId); if (station == nullptr) { return ViewportInteraction::kNoInteractionArg; } if (station->owner != CompanyManager::getControllingId()) { return ViewportInteraction::kNoInteractionArg; } _hoveredStationId = stationId; World::setMapSelectionFlags(World::MapSelectionFlags::hoveringOverStation); ViewportManager::invalidate(station); { auto args = FormatArguments::mapToolTip(StringIds::click_to_insert_new_order_stop_at); args.push(station->name); args.push(station->town); } if (orderTableIndex != 0) { uint32_t targetOffset = 0U; Vehicles::OrderRingView orders(head.orderTableOffset); auto lastOrder = orders.begin(); if (orderTableIndex < 0) { while ((lastOrder + 1) != orders.end()) { lastOrder++; } } else { while ((lastOrder + 1) != orders.end() && orderTableIndex != 0) { lastOrder++; orderTableIndex--; } } targetOffset = lastOrder->getOffset(); auto* order = Vehicles::OrderManager::orders()[targetOffset].as<Vehicles::OrderStopAt>(); if (order != nullptr) { if (order->getStation() == stationId) { if (head.mode != TransportMode::water && head.mode != TransportMode::air) { auto args = FormatArguments::mapToolTip(StringIds::click_again_to_change_last_order_route_through); args.push(station->name); args.push(station->town); } } } } return ViewportInteraction::InteractionArg(interaction.pos, enumValue(stationId), ViewportInteraction::InteractionItem::stationLabel, interaction.modId); } // 0x004B5BA3 static ViewportInteraction::InteractionArg stationAdjustedInteraction(const Vehicles::VehicleHead& head, int16_t orderTableIndex, World::TileElementBase* el, ViewportInteraction::InteractionArg interaction) { auto* elStation = el->as<StationElement>(); if (elStation == nullptr) { return ViewportInteraction::kNoInteractionArg; } if (elStation->isAiAllocated() || elStation->isGhost()) { return ViewportInteraction::kNoInteractionArg; } return stationLabelAdjustedInteraction(head, orderTableIndex, elStation->stationId(), interaction); } // 0x004B5B92 static ViewportInteraction::InteractionArg trainStationAdjustedInteraction(const Vehicles::VehicleHead& head, int16_t orderTableIndex, ViewportInteraction::InteractionArg interaction) { auto* el = static_cast<TileElement*>(interaction.object); auto* elStation = el->as<StationElement>(); if (elStation == nullptr) { return ViewportInteraction::kNoInteractionArg; } auto* elTrack = elStation->prev()->as<TrackElement>(); if (elTrack == nullptr) { return ViewportInteraction::kNoInteractionArg; } if (elTrack->owner() != CompanyManager::getControllingId()) { return ViewportInteraction::kNoInteractionArg; } return stationAdjustedInteraction(head, orderTableIndex, elStation, interaction); } // 0x004B5AC9 static ViewportInteraction::InteractionArg trackAdjustedInteraction(const Vehicles::VehicleHead& head, int16_t orderTableIndex, ViewportInteraction::InteractionArg interaction) { auto* el = static_cast<TileElement*>(interaction.object); auto* elTrack = el->as<TrackElement>(); if (elTrack == nullptr) { return ViewportInteraction::kNoInteractionArg; } if (elTrack->isAiAllocated() || elTrack->isGhost()) { return ViewportInteraction::kNoInteractionArg; } if (elTrack->owner() != CompanyManager::getControllingId()) { return ViewportInteraction::kNoInteractionArg; } if (elTrack->hasStationElement()) { auto* elStation = elTrack->next()->as<StationElement>(); if (elStation != nullptr) { if (!elStation->isAiAllocated() && !elStation->isGhost()) { ViewportInteraction::InteractionArg arg{ interaction.pos, 0, interaction.type, interaction.modId }; arg.object = elStation; return trainStationAdjustedInteraction(head, orderTableIndex, arg); } } } if (head.mode == TransportMode::water || head.mode == TransportMode::air) { return ViewportInteraction::kNoInteractionArg; } FormatArguments::mapToolTip(StringIds::click_to_insert_new_order_route_through); return interaction; } // 0x004B5AC9 static ViewportInteraction::InteractionArg roadAdjustedInteraction(const Vehicles::VehicleHead& head, int16_t orderTableIndex, ViewportInteraction::InteractionArg interaction) { auto* el = static_cast<TileElement*>(interaction.object); auto* elRoad = el->as<RoadElement>(); if (elRoad == nullptr) { return ViewportInteraction::kNoInteractionArg; } if (elRoad->isAiAllocated() || elRoad->isGhost()) { return ViewportInteraction::kNoInteractionArg; } if (elRoad->hasStationElement()) { auto* elStation = getStationElement({ interaction.pos, elRoad->baseHeight() }); if (elStation != nullptr) { if (!elStation->isAiAllocated() && !elStation->isGhost()) { return stationAdjustedInteraction(head, orderTableIndex, elStation, interaction); } } } if (head.mode == TransportMode::air) { return ViewportInteraction::kNoInteractionArg; } FormatArguments::mapToolTip(StringIds::click_to_insert_new_order_route_through); return interaction; } // 0x004B5B7F static ViewportInteraction::InteractionArg dockAirportAdjustedInteraction(const Vehicles::VehicleHead& head, int16_t orderTableIndex, ViewportInteraction::InteractionArg interaction) { auto* el = static_cast<TileElement*>(interaction.object); auto* elStation = el->as<StationElement>(); if (elStation == nullptr) { return ViewportInteraction::kNoInteractionArg; } if (elStation->owner() != CompanyManager::getControllingId()) { return ViewportInteraction::kNoInteractionArg; } return stationAdjustedInteraction(head, orderTableIndex, elStation, interaction); } // 0x004B5A9B static ViewportInteraction::InteractionArg waterAdjustedInteraction(const Vehicles::VehicleHead& head, ViewportInteraction::InteractionArg interaction) { if (head.mode != TransportMode::water) { return ViewportInteraction::kNoInteractionArg; } FormatArguments::mapToolTip(StringIds::click_to_insert_new_order_route_through); return interaction; } // 0x004B5A1A static Ui::ViewportInteraction::InteractionArg getRouteInteractionFromCursor(Window& self, const int16_t x, const int16_t y) { auto head = Common::getVehicle(self); auto flags = ViewportInteraction::InteractionItemFlags::track | ViewportInteraction::InteractionItemFlags::roadAndTram | ViewportInteraction::InteractionItemFlags::station | ViewportInteraction::InteractionItemFlags::stationLabel; if (head->mode == TransportMode::water) { flags = ViewportInteraction::InteractionItemFlags::water | ViewportInteraction::InteractionItemFlags::station | ViewportInteraction::InteractionItemFlags::stationLabel; } auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~flags); switch (interaction.type) { case ViewportInteraction::InteractionItem::track: return trackAdjustedInteraction(*head, self.orderTableIndex, interaction); case ViewportInteraction::InteractionItem::road: return roadAdjustedInteraction(*head, self.orderTableIndex, interaction); case ViewportInteraction::InteractionItem::trainStation: return trainStationAdjustedInteraction(*head, self.orderTableIndex, interaction); case ViewportInteraction::InteractionItem::roadStation: return stationAdjustedInteraction(*head, self.orderTableIndex, static_cast<TileElement*>(interaction.object), interaction); case ViewportInteraction::InteractionItem::airport: case ViewportInteraction::InteractionItem::dock: return dockAirportAdjustedInteraction(*head, self.orderTableIndex, interaction); case ViewportInteraction::InteractionItem::stationLabel: return stationLabelAdjustedInteraction(*head, self.orderTableIndex, static_cast<StationId>(interaction.value), interaction); case ViewportInteraction::InteractionItem::water: return waterAdjustedInteraction(*head, interaction); default: return ViewportInteraction::kNoInteractionArg; } } // 0x004B5088 static void toolCancel(Window& self, [[maybe_unused]] const WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id) { self.invalidate(); World::resetMapSelectionFlag(World::MapSelectionFlags::unk_04); Gfx::invalidateScreen(); } static void onToolDown(Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { const auto args = getRouteInteractionFromCursor(self, x, y); switch (args.type) { case Ui::ViewportInteraction::InteractionItem::track: { // 0x004B5160 auto tileElement = static_cast<TileElement*>(args.object); auto trackElement = tileElement->as<TrackElement>(); if (trackElement == nullptr) { break; } auto height = trackElement->baseHeight(); auto trackId = trackElement->trackId(); const auto& trackPiece = World::TrackData::getTrackPiece(trackId); const auto& trackPart = trackPiece[trackElement->sequenceIndex()]; auto offsetToFirstTile = Math::Vector::rotate(Pos2{ trackPart.x, trackPart.y }, trackElement->rotation()); auto firstTilePos = args.pos - offsetToFirstTile; const auto tPos = World::toTileSpace(firstTilePos); height -= trackPart.z; Vehicles::OrderRouteWaypoint waypoint(tPos, height / 8, trackElement->rotation(), trackId); Audio::playSound(Audio::SoundId::waypoint, Input::getDragLastLocation().x); addNewOrder(self, waypoint); break; } case Ui::ViewportInteraction::InteractionItem::water: { // Water auto heights = TileManager::getHeight(args.pos); auto height = heights.landHeight; if (heights.waterHeight != 0) { height = heights.waterHeight; } Audio::playSound(Audio::SoundId::waypoint, Input::getDragLastLocation().x); const auto tPos = World::toTileSpace(args.pos); Vehicles::OrderRouteWaypoint waypoint(tPos, height / 8, 0, 0); addNewOrder(self, waypoint); break; } case Ui::ViewportInteraction::InteractionItem::stationLabel: { Audio::playSound(Audio::SoundId::waypoint, Input::getDragLastLocation().x); const auto stationId = StationId(args.value); Vehicles::OrderStopAt station(stationId); addNewOrder(self, station); break; } case Ui::ViewportInteraction::InteractionItem::road: { // 0x004B5223 auto* tileElement = static_cast<TileElement*>(args.object); auto* roadElement = tileElement->as<RoadElement>(); if (roadElement == nullptr) { break; } auto height = roadElement->baseHeight(); auto roadId = roadElement->roadId(); const auto& roadPiece = World::TrackData::getRoadPiece(roadId); const auto& roadPart = roadPiece[roadElement->sequenceIndex()]; auto offsetToFirstTile = Math::Vector::rotate(Pos2{ roadPart.x, roadPart.y }, roadElement->rotation()); auto firstTilePos = args.pos - offsetToFirstTile; const auto tPos = World::toTileSpace(firstTilePos); height -= roadPart.z; Vehicles::OrderRouteWaypoint waypoint(tPos, height / 8, roadElement->rotation(), roadId); Audio::playSound(Audio::SoundId::waypoint, Input::getDragLastLocation().x); addNewOrder(self, waypoint); break; } default: break; } } // 0x004B50CE static Ui::CursorId toolCursor(Window& self, const int16_t x, const int16_t y, const Ui::CursorId fallback, bool& out) { const auto args = getRouteInteractionFromCursor(self, x, y); out = args.type != Ui::ViewportInteraction::InteractionItem::noInteraction; if (out) { return CursorId::inwardArrows; } return fallback; } // 0x004B4D9B static void getScrollSize(Ui::Window& self, [[maybe_unused]] const uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } auto table = getOrderTable(head); scrollHeight = lineHeight * std::distance(table.begin(), table.end()); // Space for the 'end of orders' item scrollHeight += lineHeight; } static void scrollMouseDown(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } int16_t item = y / lineHeight; Vehicles::Order* selectedOrder = getOrderTable(head).atIndex(item); if (selectedOrder == nullptr) { item = -1; } auto* toolWindow = ToolManager::toolGetActiveWindow(); // If another vehicle window is open and has focus (tool) if (toolWindow != nullptr && toolWindow->type == self.type && toolWindow->number != self.number) { if (item == -1) { // Copy complete order list Audio::playSound(Audio::SoundId::waypoint, Input::getDragLastLocation().x); std::vector<std::shared_ptr<Vehicles::Order>> clonedOrders; for (auto& existingOrders : getOrderTable(head)) { clonedOrders.push_back(existingOrders.clone()); } for (auto& order : clonedOrders) { addNewOrder(*toolWindow, *order); } WindowManager::bringToFront(*toolWindow); } else { // Copy a single entry on the order list Audio::playSound(Audio::SoundId::waypoint, Input::getDragLastLocation().x); auto clonedOrder = selectedOrder->clone(); addNewOrder(*toolWindow, *clonedOrder); WindowManager::bringToFront(*toolWindow); } return; } if (item != self.orderTableIndex) { self.orderTableIndex = item; self.invalidate(); return; } if (selectedOrder == nullptr) { return; } switch (selectedOrder->getType()) { case Vehicles::OrderType::StopAt: case Vehicles::OrderType::RouteThrough: { auto* stationOrder = static_cast<Vehicles::OrderStation*>(selectedOrder); auto station = StationManager::get(stationOrder->getStation()); auto main = WindowManager::getMainWindow(); if (main) { main->viewportCentreOnTile({ station->x, station->y, static_cast<coord_t>(station->z + 32) }); } break; } case Vehicles::OrderType::RouteWaypoint: { auto* routeOrder = selectedOrder->as<Vehicles::OrderRouteWaypoint>(); if (routeOrder != nullptr) { auto main = WindowManager::getMainWindow(); if (main) { auto position = routeOrder->getWaypoint(); position.x += 16; position.y += 16; position.z += 32; main->viewportCentreOnTile(position); } } break; } case Vehicles::OrderType::UnloadAll: case Vehicles::OrderType::WaitFor: case Vehicles::OrderType::End: // These orders don't have a location to centre on break; } } // 0x004B530C static void scrollMouseOver(Window& self, [[maybe_unused]] const int16_t x, const int16_t y, [[maybe_unused]] const uint8_t scrollIndex) { self.flags &= ~WindowFlags::notScrollView; auto item = y / lineHeight; if (self.rowHover != item) { self.rowHover = item; self.invalidate(); } } // 0x004B5339 static Ui::CursorId cursor(Window& self, const WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y, const Ui::CursorId fallback) { if (widgetIdx != widx::routeList) { return fallback; } if (ToolManager::isToolActive(self.type, self.number)) { return CursorId::inwardArrows; } return fallback; } // 0x004B56B8 TODO Rename static void createViewport(Window& self) { auto head = Common::getVehicle(self); if (head == nullptr) { return; } Vehicles::OrderManager::generateNumDisplayFrames(head); } // 0x004B468C static void prepareDraw(Window& self) { Common::setActiveTabs(self); auto head = Common::getVehicle(self); if (head == nullptr) { return; } // Set title. { auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(head->name); args.push(head->ordinalNumber); } self.widgets[widx::routeList].tooltip = ToolManager::isToolActive(self.type, self.number) ? StringIds::tooltip_route_scrollview_copy : StringIds::tooltip_route_scrollview; self.widgets[Common::widx::frame].right = self.width - 1; self.widgets[Common::widx::frame].bottom = self.height - 1; self.widgets[Common::widx::panel].right = self.width - 1; self.widgets[Common::widx::panel].bottom = self.height - 1; self.widgets[Common::widx::caption].right = self.width - 2; self.widgets[Common::widx::closeButton].left = self.width - 15; self.widgets[Common::widx::closeButton].right = self.width - 3; self.widgets[widx::routeList].right = self.width - 26; self.widgets[widx::routeList].bottom = self.height - 14; self.widgets[widx::orderForceUnload].right = self.width - 2; self.widgets[widx::orderWait].right = self.width - 2; self.widgets[widx::orderSkip].right = self.width - 2; self.widgets[widx::orderDelete].right = self.width - 2; self.widgets[widx::orderUp].right = self.width - 2; self.widgets[widx::orderDown].right = self.width - 2; self.widgets[widx::orderReverse].right = self.width - 2; self.widgets[widx::orderForceUnload].left = self.width - 25; self.widgets[widx::orderWait].left = self.width - 25; self.widgets[widx::orderSkip].left = self.width - 25; self.widgets[widx::orderDelete].left = self.width - 25; self.widgets[widx::orderUp].left = self.width - 25; self.widgets[widx::orderDown].left = self.width - 25; self.widgets[widx::orderReverse].left = self.width - 25; self.disabledWidgets |= (1 << widx::orderForceUnload) | (1 << widx::orderWait) | (1 << widx::orderSkip) | (1 << widx::orderDelete); if (head->sizeOfOrderTable != 1) { self.disabledWidgets &= ~((1 << widx::orderSkip) | (1 << widx::orderDelete)); } if (head->trainAcceptedCargoTypes != 0) { self.disabledWidgets &= ~((1 << widx::orderWait) | (1 << widx::orderForceUnload)); } // Express / local self.activatedWidgets &= ~((1 << widx::expressMode) | (1 << widx::localMode)); Vehicles::Vehicle train(*head); if ((train.veh1->var_48 & Vehicles::Flags48::expressMode) != Vehicles::Flags48::none) { self.activatedWidgets |= (1 << widx::expressMode); } else { self.activatedWidgets |= (1 << widx::localMode); } const bool isControllingCompany = head->owner == CompanyManager::getControllingId() ? false : true; self.widgets[widx::orderForceUnload].hidden = isControllingCompany; self.widgets[widx::orderWait].hidden = isControllingCompany; self.widgets[widx::orderSkip].hidden = isControllingCompany; self.widgets[widx::orderDelete].hidden = isControllingCompany; self.widgets[widx::orderUp].hidden = isControllingCompany; self.widgets[widx::orderDown].hidden = isControllingCompany; self.widgets[widx::orderReverse].hidden = isControllingCompany; if (isControllingCompany) { self.widgets[widx::routeList].right += 22; self.disabledWidgets |= (1 << widx::expressMode | 1 << widx::localMode); } else { self.disabledWidgets &= ~(1 << widx::expressMode | 1 << widx::localMode); } self.widgets[widx::expressMode].right = self.widgets[widx::routeList].right; self.widgets[widx::expressMode].left = (self.widgets[widx::expressMode].right - 3) / 2 + 3; self.widgets[widx::localMode].right = self.widgets[widx::expressMode].left - 1; self.disabledWidgets |= (1 << widx::orderUp) | (1 << widx::orderDown); if (self.orderTableIndex != -1) { self.disabledWidgets &= ~((1 << widx::orderUp) | (1 << widx::orderDown)); } Widget::leftAlignTabs(self, Common::widx::tabMain, Common::widx::tabRoute); } // 0x004B4866 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); if (ToolManager::isToolActive(WindowType::vehicle, self.number)) { // Location at bottom left edge of window auto loc = Point(self.x + 3, self.y + self.height - 13); tr.drawStringLeftClipped(loc, self.width - 14, Colour::black, StringIds::route_click_on_waypoint); } } const std::array<StringId, 6> orderString = { { StringIds::orders_end, StringIds::orders_stop_at, StringIds::orders_route_through, StringIds::orders_route_thought_waypoint, StringIds::orders_unload_all, StringIds::orders_wait_for_full_load_of, } }; static constexpr std::array<uint32_t, 63> kNumberCircle = { { ImageIds::number_circle_01, ImageIds::number_circle_02, ImageIds::number_circle_03, ImageIds::number_circle_04, ImageIds::number_circle_05, ImageIds::number_circle_06, ImageIds::number_circle_07, ImageIds::number_circle_08, ImageIds::number_circle_09, ImageIds::number_circle_10, ImageIds::number_circle_11, ImageIds::number_circle_12, ImageIds::number_circle_13, ImageIds::number_circle_14, ImageIds::number_circle_15, ImageIds::number_circle_16, ImageIds::number_circle_17, ImageIds::number_circle_18, ImageIds::number_circle_19, ImageIds::number_circle_20, ImageIds::number_circle_21, ImageIds::number_circle_22, ImageIds::number_circle_23, ImageIds::number_circle_24, ImageIds::number_circle_25, ImageIds::number_circle_26, ImageIds::number_circle_27, ImageIds::number_circle_28, ImageIds::number_circle_29, ImageIds::number_circle_30, ImageIds::number_circle_31, ImageIds::number_circle_32, ImageIds::number_circle_33, ImageIds::number_circle_34, ImageIds::number_circle_35, ImageIds::number_circle_36, ImageIds::number_circle_37, ImageIds::number_circle_38, ImageIds::number_circle_39, ImageIds::number_circle_40, ImageIds::number_circle_41, ImageIds::number_circle_42, ImageIds::number_circle_43, ImageIds::number_circle_44, ImageIds::number_circle_45, ImageIds::number_circle_46, ImageIds::number_circle_47, ImageIds::number_circle_48, ImageIds::number_circle_49, ImageIds::number_circle_50, ImageIds::number_circle_51, ImageIds::number_circle_52, ImageIds::number_circle_53, ImageIds::number_circle_54, ImageIds::number_circle_55, ImageIds::number_circle_56, ImageIds::number_circle_57, ImageIds::number_circle_58, ImageIds::number_circle_59, ImageIds::number_circle_60, ImageIds::number_circle_61, ImageIds::number_circle_62, ImageIds::number_circle_63, } }; // 0x004B4A58 based on static void drawOrderLabel(Window& self, Gfx::DrawingContext& drawingCtx, const StringId strFormat, FormatArguments& args, Vehicles::Order& order, int16_t& y, int16_t& orderNumber) { auto tr = Gfx::TextRenderer(drawingCtx); char buffer[512]; StringManager::formatString(buffer, std::size(buffer), strFormat, args); tr.setCurrentFont(Gfx::Font::medium_bold); tr.drawString(Point(8, y - 1), Colour::black, buffer); auto labelWidth = tr.getStringWidth(buffer); if (order.hasFlags(Vehicles::OrderFlags::HasNumber)) { if (ToolManager::isToolActive(self.type, self.number)) { auto imageId = kNumberCircle[orderNumber - 1]; drawingCtx.drawImage(labelWidth + 8 + 3, y, Gfx::recolour(imageId, Colour::white)); } orderNumber++; } } // 0x004B48BA static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t i) { auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(Colours::getShade(self.getColour(WindowColour::secondary).c(), 4)); auto head = Common::getVehicle(self); if (head == nullptr) { return; } Vehicles::Vehicle train(*head); auto rowNum = 0; if (head->sizeOfOrderTable == 1) { auto point = Point(8, 0); tr.drawStringLeft(point, Colour::black, StringIds::no_route_defined); rowNum++; // Used to move down the text } int16_t orderNumber = 1; for (auto& order : getOrderTable(head)) { int16_t y = rowNum * lineHeight; auto strFormat = StringIds::black_stringid; if (self.orderTableIndex == rowNum) { drawingCtx.fillRect(0, y, self.width, y + 9, PaletteIndex::black0, Gfx::RectFlags::none); strFormat = StringIds::white_stringid; } if (self.rowHover == rowNum) { strFormat = StringIds::wcolour2_stringid; drawingCtx.fillRect(0, y, self.width, y + 9, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); } FormatArguments args{}; args.push(orderString[static_cast<uint8_t>(order.getType())]); switch (order.getType()) { case Vehicles::OrderType::End: case Vehicles::OrderType::RouteWaypoint: // Fall through break; case Vehicles::OrderType::StopAt: case Vehicles::OrderType::RouteThrough: { auto* stationOrder = static_cast<Vehicles::OrderStation*>(&order); stationOrder->setFormatArguments(args); break; } case Vehicles::OrderType::UnloadAll: case Vehicles::OrderType::WaitFor: { auto* cargoOrder = static_cast<Vehicles::OrderCargo*>(&order); cargoOrder->setFormatArguments(args); break; } } drawOrderLabel(self, drawingCtx, strFormat, args, order, y, orderNumber); if (head->currentOrder + head->orderTableOffset == order.getOffset()) { auto point = Point(1, y - 1); tr.drawStringLeft(point, Colour::black, StringIds::orders_current_order); } rowNum++; } // Output the end of orders Ui::Point loc = { 8, static_cast<int16_t>(rowNum * lineHeight) }; auto strFormat = StringIds::black_stringid; if (self.orderTableIndex == rowNum) { drawingCtx.fillRect(0, loc.y, self.width, loc.y + lineHeight, PaletteIndex::black0, Gfx::RectFlags::none); strFormat = StringIds::white_stringid; } if (self.rowHover == rowNum) { strFormat = StringIds::wcolour2_stringid; drawingCtx.fillRect(0, loc.y, self.width, loc.y + lineHeight, enumValue(ExtColour::unk30), Gfx::RectFlags::transparent); } loc.y -= 1; auto args = FormatArguments::common(orderString[0]); tr.drawStringLeft(loc, Colour::black, strFormat, args); } static constexpr WindowEventList kEvents = { .onClose = close, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = Common::event8, .event_09 = Common::event9, .onToolDown = onToolDown, .onToolAbort = toolCancel, .toolCursor = toolCursor, .getScrollSize = getScrollSize, .scrollMouseDown = scrollMouseDown, .scrollMouseOver = scrollMouseOver, .textInput = Common::textInput, .viewportRotate = createViewport, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } namespace Common { struct TabInformation { const widx widgetIndex; std::span<const Widget> widgets; const WindowEventList& events; const uint64_t* holdableWidgets; }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { widx::tabMain, Main::widgets, Main::getEvents(), &Main::holdableWidgets }, { widx::tabDetails, Details::widgets, Details::getEvents(), &Details::holdableWidgets }, { widx::tabCargo, Cargo::widgets, Cargo::getEvents(), &Cargo::holdableWidgets }, { widx::tabFinances, Finances::widgets, Finances::getEvents(), &Finances::holdableWidgets }, { widx::tabRoute, Route::widgets, Route::getEvents(), &Route::holdableWidgets } }; // clang-format on static void setActiveTabs(Window& self) { self.activatedWidgets &= ~((1 << widx::tabMain) | (1 << widx::tabDetails) | (1 << widx::tabCargo) | (1 << widx::tabFinances) | (1 << widx::tabRoute)); self.activatedWidgets |= 1ULL << (widx::tabMain + self.currentTab); } static std::pair<uint32_t, StringId> getPickupImageIdandTooltip(const Vehicles::VehicleHead& head, const bool isPlaced) { uint32_t image = 0; StringId tooltip = 0; switch (head.mode) { case TransportMode::rail: { auto trackObj = ObjectManager::get<TrackObject>(head.trackType); image = trackObj->image + (isPlaced ? TrackObj::ImageIds::kUiPickupFromTrack : TrackObj::ImageIds::kUiPlaceOnTrack); tooltip = isPlaced ? StringIds::tooltip_remove_from_track : StringIds::tooltip_place_on_track; break; } case TransportMode::road: { auto roadObjId = head.trackType == 0xFF ? getGameState().lastTrackTypeOption : head.trackType; auto roadObj = ObjectManager::get<RoadObject>(roadObjId); image = roadObj->image + (isPlaced ? 32 : 33); tooltip = isPlaced ? StringIds::tooltip_remove_from_track : StringIds::tooltip_place_on_track; break; } case TransportMode::air: { image = isPlaced ? ImageIds::airport_pickup : ImageIds::airport_place; tooltip = isPlaced ? StringIds::tooltip_remove_from_airport : StringIds::tooltip_place_on_airport; break; } case TransportMode::water: { auto waterObj = ObjectManager::get<WaterObject>(); image = waterObj->image + (isPlaced ? 58 : 59); tooltip = isPlaced ? StringIds::tooltip_remove_from_water : StringIds::tooltip_place_on_dock; break; } } return std::make_pair(image, tooltip); } // NB: not a vanilla function static void onClose(Window& self) { if (ToolManager::isToolActive(WindowType::vehicle, self.number)) { ToolManager::toolCancel(); } } // 0x004B26C0 static void textInput(Window& self, const WidgetIndex_t callingWidget, [[maybe_unused]] const WidgetId id, const char* const input) { if (callingWidget != widx::caption) { return; } if (strlen(input) == 0) { return; } GameCommands::setErrorTitle(StringIds::cant_rename_this_vehicle); GameCommands::VehicleRenameArgs args{}; args.head = EntityId(self.number); std::memcpy(args.buffer, input, 36); args.i = 1; GameCommands::doCommand(args, GameCommands::Flags::apply); args.head = EntityId(0); args.i = 2; GameCommands::doCommand(args, GameCommands::Flags::apply); args.i = 0; GameCommands::doCommand(args, GameCommands::Flags::apply); } // 0x0050029C static constexpr std::array<std::array<CursorId, 2>, 6> kTypeToToolCursor = { { { { CursorId::placeTrain, CursorId::placeTrainAlt } }, { { CursorId::placeBus, CursorId::placeBusAlt } }, { { CursorId::placeTruck, CursorId::placeTruckAlt } }, { { CursorId::placeTram, CursorId::placeTramAlt } }, { { CursorId::placePlane, CursorId::placePlane } }, { { CursorId::placeShip, CursorId::placeShip } }, } }; // 0x00427595 static std::optional<GameCommands::VehicleWaterPlacementArgs> getVehicleWaterPlacementArgsFromCursor(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto pos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); if (!pos) { return {}; } // Search 8x8 area centred on mouse pos const auto centerPos = *pos + World::Pos2(16, 16); World::Pos2 initialPos = *pos - World::toWorldSpace(World::TilePos2(4, 4)); int32_t bestDistance = std::numeric_limits<int32_t>::max(); World::Pos3 bestLoc{}; for (tile_coord_t i = 0; i < 8; ++i) { for (tile_coord_t j = 0; j < 8; ++j) { const auto loc = initialPos + World::toWorldSpace(World::TilePos2{ i, j }); if (!World::validCoords(loc)) { continue; } auto tile = World::TileManager::get(loc); for (auto& el : tile) { auto* elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->stationType() != StationType::docks) { continue; } if (elStation->sequenceIndex() != 0) { continue; } auto firstTile = loc - World::kOffsets[elStation->sequenceIndex()]; auto* dockObject = ObjectManager::get<DockObject>(elStation->objectId()); auto boatLoc = firstTile + World::toWorldSpace(TilePos2{ 1, 1 }) + Math::Vector::rotate(dockObject->boatPosition, elStation->rotation()); auto distance = Math::Vector::manhattanDistance2D(boatLoc, centerPos); if (distance < bestDistance) { bestDistance = distance; bestLoc = World::Pos3(loc.x, loc.y, elStation->baseHeight()); } } } } if (bestDistance == std::numeric_limits<int32_t>::max()) { return {}; } GameCommands::VehicleWaterPlacementArgs args; args.pos = bestLoc; args.head = head.id; return { args }; } static void removeBoatGhost(const Vehicles::VehicleHead& head) { // Note: don't use isPlaced as we need to know if its a ghost // consider creating isGhostPlaced if (head.tileX != -1 && head.has38Flags(Vehicles::Flags38::isGhost)) { GameCommands::VehiclePickupWaterArgs gcArgs{}; gcArgs.head = head.id; auto flags = GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::ghost; GameCommands::doCommand(gcArgs, flags); } _1136264 = -1; } // 0x004B2B9E static void pickupToolUpdateWater(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto placementArgs = getVehicleWaterPlacementArgsFromCursor(head, x, y); if (!placementArgs) { removeBoatGhost(head); return; } if (_1136264 == 0 && *_ghostVehiclePos == placementArgs->pos) { return; } _ghostVehiclePos = placementArgs->pos; removeBoatGhost(head); if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply | GameCommands::Flags::ghost | GameCommands::Flags::noErrorWindow) != GameCommands::FAILURE) { _1136264 = 0; } } // 0x00426F0B static std::optional<GameCommands::VehicleAirPlacementArgs> getVehicleAirPlacementArgsFromCursor(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~ViewportInteraction::InteractionItemFlags::station); auto* elStation = static_cast<World::StationElement*>(res.first.object); if (res.first.type != ViewportInteraction::InteractionItem::airport) { res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::surface | ViewportInteraction::InteractionItemFlags::water)); const auto& interaction = res.first; if (interaction.type == ViewportInteraction::InteractionItem::noInteraction) { return {}; } bool stationFound = false; for (auto& station : StationManager::stations()) { if ((station.flags & StationFlags::flag_6) == StationFlags::none) { continue; } if ((station.flags & StationFlags::flag_5) != StationFlags::none) { continue; } if (std::abs(interaction.pos.x - station.airportStartPos.x) > 5 * World::kTileSize) { continue; } if (std::abs(interaction.pos.y - station.airportStartPos.y) > 5 * World::kTileSize) { continue; } auto tile = TileManager::get(station.airportStartPos); for (auto& el : tile) { elStation = el.as<StationElement>(); if (elStation == nullptr) { continue; } if (elStation->isAiAllocated() || elStation->isGhost()) { continue; } if (elStation->stationType() != StationType::airport) { continue; } stationFound = true; break; } } if (!stationFound) { return {}; } } if (elStation->isAiAllocated() || elStation->isGhost()) { return {}; } GameCommands::VehicleAirPlacementArgs placementArgs; placementArgs.stationId = elStation->stationId(); placementArgs.head = head.id; auto* airportObj = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementNodes = airportObj->getMovementNodes(); int32_t bestDistance = std::numeric_limits<int32_t>::max(); uint8_t bestNode = 0; // TODO: Use std::ranges::reverse_view for (auto node = airportObj->numMovementNodes - 1; node > -1; node--) { const auto& movementNode = movementNodes[node]; if (!movementNode.hasFlags(AirportMovementNodeFlags::terminal)) { continue; } auto nodeLoc = getAirportMovementNodeLoc(placementArgs.stationId, node); if (!nodeLoc) { continue; } auto viewPos = World::gameToScreen(*nodeLoc, res.second->getRotation()); auto uiPos = res.second->viewportToScreen(viewPos); auto distance = Math::Vector::manhattanDistance2D(uiPos, Point{ x, y }); if (distance < bestDistance) { bestDistance = distance; bestNode = node; } } if (bestDistance == std::numeric_limits<int32_t>::max()) { return {}; } placementArgs.airportNode = bestNode; return { placementArgs }; } static void removeAirplaneGhost(const Vehicles::VehicleHead& head) { // Note: don't use isPlaced as we need to know if its a ghost // consider creating isGhostPlaced if (head.tileX != -1 && head.has38Flags(Vehicles::Flags38::isGhost)) { GameCommands::VehiclePickupAirArgs gcArgs{}; gcArgs.head = head.id; auto flags = GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::ghost; GameCommands::doCommand(gcArgs, flags); } _ghostAirportStationId = StationId::null; } // 0x004B2AFA static void pickupToolUpdateAir(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto placementArgs = getVehicleAirPlacementArgsFromCursor(head, x, y); if (!placementArgs) { removeAirplaneGhost(head); return; } if (_ghostAirportStationId != StationId::null && *_ghostAirportStationId == placementArgs->stationId && *_ghostAirportNode == placementArgs->airportNode) { return; } removeAirplaneGhost(head); if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply | GameCommands::Flags::ghost | GameCommands::Flags::noErrorWindow) != GameCommands::FAILURE) { _ghostAirportNode = placementArgs->airportNode; _ghostAirportStationId = placementArgs->stationId; } } // 0x004A43E4 static uint16_t getRoadProgressAtCursor(const Point& cursorLoc, Ui::Viewport& viewport, const RoadElement& roadElement, const World::Pos3& loc) { // Get the coordinates of the first tile of the possibly multi-tile road const auto& roadDataArr = World::TrackData::getRoadPiece(roadElement.roadId()); const auto& roadData = roadDataArr[roadElement.sequenceIndex()]; auto roadOffset2 = Math::Vector::rotate(World::Pos2(roadData.x, roadData.y), roadElement.rotation()); auto roadOffset = World::Pos3(roadOffset2.x, roadOffset2.y, roadData.z); auto roadFirstTile = loc - roadOffset; // Get the movement info for this specific road id uint16_t trackAndDirection = roadElement.rotation() | (roadElement.roadId() << 3); const auto moveInfoArr = World::TrackData::getRoadPlacementSubPositon(trackAndDirection); // This iterates the movement info trying to find the distance along the road that is as close as possible // to the cursors location. int32_t bestDistance = std::numeric_limits<int32_t>::max(); uint16_t bestProgress = 0; for (const auto& moveInfo : moveInfoArr) { auto potentialLoc = roadFirstTile + moveInfo.loc; auto viewPos = World::gameToScreen(potentialLoc, viewport.getRotation()); auto uiPos = viewport.viewportToScreen(viewPos); auto distance = Math::Vector::manhattanDistance2D(uiPos, cursorLoc); if (distance < bestDistance) { bestDistance = distance; bestProgress = std::distance(&*moveInfoArr.begin(), &moveInfo); } } return bestProgress; } // 0x00478415 static std::optional<GameCommands::VehiclePlacementArgs> getRoadAtCursor(const int16_t x, const int16_t y) { auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~ViewportInteraction::InteractionItemFlags::roadAndTram); if (interaction.type != ViewportInteraction::InteractionItem::road) { return {}; } // Get the best progress along the road relative to the cursor auto* roadElement = static_cast<World::RoadElement*>(interaction.object); World::Pos3 loc(interaction.pos.x, interaction.pos.y, roadElement->baseHeight()); auto progress = getRoadProgressAtCursor({ x, y }, *viewport, *roadElement, loc); // Get the coordinates of the first tile of the possibly multi-tile road const auto& roadDataArr = World::TrackData::getRoadPiece(roadElement->roadId()); const auto& roadData = roadDataArr[roadElement->sequenceIndex()]; auto roadOffset2 = Math::Vector::rotate(World::Pos2(roadData.x, roadData.y), roadElement->rotation()); auto roadOffset = World::Pos3(roadOffset2.x, roadOffset2.y, roadData.z); auto roadFirstTile = loc - roadOffset; GameCommands::VehiclePlacementArgs placementArgs; placementArgs.pos = roadFirstTile; placementArgs.trackProgress = progress; placementArgs.trackAndDirection = roadElement->rotation() | (roadElement->roadId() << 3); return { placementArgs }; } // 0x00479707 static std::optional<GameCommands::VehiclePlacementArgs> getVehicleRoadPlacementArgsFromCursor(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto placementArgs = getRoadAtCursor(x, y); if (!placementArgs) { return {}; } placementArgs->head = head.id; const auto moveInfoArr = World::TrackData::getRoadPlacementSubPositon(placementArgs->trackAndDirection); const auto& moveInfo = moveInfoArr[placementArgs->trackProgress]; uint8_t unkYaw = moveInfo.yaw + (WindowManager::getCurrentRotation() << 4); unkYaw -= 0x37; if (getGameState().pickupDirection != 0) { unkYaw -= 0x20; } unkYaw &= 0x3F; if (unkYaw <= 0x20) { const auto& unkItem = TrackData::getUnkRoad(placementArgs->trackAndDirection); placementArgs->pos += unkItem.pos; if (unkItem.rotationEnd < 12) { placementArgs->pos -= World::Pos3{ World::kRotationOffset[unkItem.rotationEnd], 0 }; } placementArgs->trackProgress = std::max<uint16_t>(static_cast<uint16_t>(moveInfoArr.size()) - placementArgs->trackProgress, 0); if (placementArgs->trackProgress >= moveInfoArr.size()) { placementArgs->trackProgress = static_cast<uint16_t>(moveInfoArr.size()) - 1; } placementArgs->trackAndDirection ^= (1 << 2); } return placementArgs; } // 0x004A43E4 static uint16_t getTrackProgressAtCursor(const Point& cursorLoc, Ui::Viewport& viewport, const TrackElement& trackElement, const World::Pos3& loc) { // Get the coordinates of the first tile of the possibly multi-tile track const auto& trackDataArr = World::TrackData::getTrackPiece(trackElement.trackId()); const auto& trackData = trackDataArr[trackElement.sequenceIndex()]; auto trackOffset2 = Math::Vector::rotate(World::Pos2(trackData.x, trackData.y), trackElement.rotation()); auto trackOffset = World::Pos3(trackOffset2.x, trackOffset2.y, trackData.z); auto trackFirstTile = loc - trackOffset; // Get the movement info for this specific track id uint16_t trackAndDirection = trackElement.rotation() | (trackElement.trackId() << 3); const auto moveInfoArr = World::TrackData::getTrackSubPositon(trackAndDirection); // This iterates the movement info trying to find the distance along the track that is as close as possible // to the cursors location. int32_t bestDistance = std::numeric_limits<int32_t>::max(); uint16_t bestProgress = 0; for (const auto& moveInfo : moveInfoArr) { auto potentialLoc = trackFirstTile + moveInfo.loc; auto viewPos = World::gameToScreen(potentialLoc, viewport.getRotation()); auto uiPos = viewport.viewportToScreen(viewPos); auto distance = Math::Vector::manhattanDistance2D(uiPos, cursorLoc); if (distance < bestDistance) { bestDistance = distance; bestProgress = std::distance(&*moveInfoArr.begin(), &moveInfo); } } return bestProgress; } // 0x004A40C5 static std::optional<GameCommands::VehiclePlacementArgs> getTrackAtCursor(const int16_t x, const int16_t y) { auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~ViewportInteraction::InteractionItemFlags::track); if (interaction.type != ViewportInteraction::InteractionItem::track) { return {}; } // Get the best progress along the track relative to the cursor auto* trackElement = static_cast<World::TrackElement*>(interaction.object); World::Pos3 loc(interaction.pos.x, interaction.pos.y, trackElement->baseHeight()); auto progress = getTrackProgressAtCursor({ x, y }, *viewport, *trackElement, loc); // Get the coordinates of the first tile of the possibly multi-tile road const auto& trackDataArr = World::TrackData::getTrackPiece(trackElement->trackId()); const auto& trackData = trackDataArr[trackElement->sequenceIndex()]; auto trackOffset2 = Math::Vector::rotate(World::Pos2(trackData.x, trackData.y), trackElement->rotation()); auto trackOffset = World::Pos3(trackOffset2.x, trackOffset2.y, trackData.z); auto trackFirstTile = loc - trackOffset; GameCommands::VehiclePlacementArgs placementArgs; placementArgs.pos = trackFirstTile; placementArgs.trackProgress = progress; placementArgs.trackAndDirection = trackElement->rotation() | (trackElement->trackId() << 3); return { placementArgs }; } // 0x004B6444 static std::optional<GameCommands::VehiclePlacementArgs> getVehicleRailPlacementArgsFromCursor(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto placementArgs = getTrackAtCursor(x, y); if (!placementArgs) { return {}; } placementArgs->head = head.id; const auto moveInfoArr = World::TrackData::getTrackSubPositon(placementArgs->trackAndDirection); const auto& moveInfo = moveInfoArr[placementArgs->trackProgress]; uint8_t unkYaw = moveInfo.yaw + (WindowManager::getCurrentRotation() << 4); unkYaw -= 0x37; if (getGameState().pickupDirection != 0) { unkYaw -= 0x20; } unkYaw &= 0x3F; if (unkYaw <= 0x20) { const auto& unkItem = TrackData::getUnkTrack(placementArgs->trackAndDirection); placementArgs->pos += unkItem.pos; if (unkItem.rotationEnd < 12) { placementArgs->pos -= World::Pos3{ World::kRotationOffset[unkItem.rotationEnd], 0 }; } placementArgs->trackProgress = std::max<uint16_t>(static_cast<uint16_t>(moveInfoArr.size()) - placementArgs->trackProgress, 0); if (placementArgs->trackProgress >= moveInfoArr.size()) { placementArgs->trackProgress = static_cast<uint16_t>(moveInfoArr.size()) - 1; } placementArgs->trackAndDirection ^= (1 << 2); } return placementArgs; } static void removeLandGhost(const Vehicles::VehicleHead& head) { // Note: don't use isPlaced as we need to know if its a ghost // consider creating isGhostPlaced if (head.tileX != -1 && head.has38Flags(Vehicles::Flags38::isGhost)) { GameCommands::VehiclePickupArgs args{}; args.head = head.id; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::ghost); } _1136264 = -1; } // 0x004B2A1D template<typename GetPlacementArgsFunc> static void pickupToolUpdateLand(const Vehicles::VehicleHead& head, const int16_t x, const int16_t y, GetPlacementArgsFunc&& getPlacementArgs) { auto placementArgs = getPlacementArgs(head, x, y); if (!placementArgs) { removeLandGhost(head); return; } if (_1136264 != -1 && *_ghostLandTrackAndDirection == placementArgs->trackAndDirection && *_ghostVehiclePos == placementArgs->pos && *_1136264 == placementArgs->trackProgress) { return; } removeLandGhost(head); if (GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply | GameCommands::Flags::ghost | GameCommands::Flags::noErrorWindow) != GameCommands::FAILURE) { _ghostLandTrackAndDirection = placementArgs->trackAndDirection; _ghostVehiclePos = placementArgs->pos; _1136264 = placementArgs->trackProgress; } } // 0x004B29C0 static void pickupToolUpdate(Window& self, const int16_t x, const int16_t y) { auto* head = getVehicle(self); if (head == nullptr) { return; } ToolManager::setToolCursor(kTypeToToolCursor[static_cast<uint8_t>(head->vehicleType)][getGameState().pickupDirection != 0 ? 1 : 0]); switch (head->mode) { case TransportMode::rail: pickupToolUpdateLand(*head, x, y, getVehicleRailPlacementArgsFromCursor); break; case TransportMode::road: pickupToolUpdateLand(*head, x, y, getVehicleRoadPlacementArgsFromCursor); break; case TransportMode::air: pickupToolUpdateAir(*head, x, y); break; case TransportMode::water: pickupToolUpdateWater(*head, x, y); break; } } // 0x004B2D8A static void pickupToolError(const Vehicles::VehicleHead& head) { auto args = FormatArguments::common(); args.skip(6); args.push(head.name); args.push(head.ordinalNumber); Error::open(StringIds::cant_place_string_id_here, StringIds::null); } static void pickupToolPlacementCommandCallback(uint32_t gameCommandResult, Window& self, EntityId vehicleHead) { if (gameCommandResult == GameCommands::FAILURE) { return; } if (Input::hasKeyModifier(Input::KeyModifier::shift)) { VehicleChangeRunningModeArgs args{}; args.head = vehicleHead; args.mode = VehicleChangeRunningModeArgs::Mode::startVehicle; GameCommands::doCommand(args, GameCommands::Flags::apply); } ToolManager::toolCancel(); self.callOnMouseUp(Common::widx::tabMain, self.widgets[Common::widx::tabMain].id); } // 0x004B2E18 static void pickupToolDownAir(Window& self, const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto placementArgs = getVehicleAirPlacementArgsFromCursor(head, x, y); if (!placementArgs) { pickupToolError(head); return; } if (*_ghostAirportStationId == placementArgs->stationId && *_ghostAirportNode == placementArgs->airportNode) { if (head.tileX != -1 && head.has38Flags(Vehicles::Flags38::isGhost)) { // Will convert inplace vehicle into non ghost placementArgs->convertGhost = true; } } if (!placementArgs->convertGhost) { removeAirplaneGhost(head); } auto args = FormatArguments::common(); args.skip(6); args.push(head.name); args.push(head.ordinalNumber); GameCommands::setErrorTitle(StringIds::cant_place_string_id_here); auto result = GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply); pickupToolPlacementCommandCallback(result, self, head.head); } // 0x004B2F1C static void pickupToolDownWater(Window& self, const Vehicles::VehicleHead& head, const int16_t x, const int16_t y) { auto placementArgs = getVehicleWaterPlacementArgsFromCursor(head, x, y); if (!placementArgs) { pickupToolError(head); return; } if (_1136264 == 0 && *_ghostVehiclePos == placementArgs->pos) { if (head.tileX != -1 && head.has38Flags(Vehicles::Flags38::isGhost)) { // Will convert inplace vehicle into non ghost placementArgs->convertGhost = true; } } if (!placementArgs->convertGhost) { removeBoatGhost(head); } auto args = FormatArguments::common(); args.skip(6); args.push(head.name); args.push(head.ordinalNumber); GameCommands::setErrorTitle(StringIds::cant_place_string_id_here); auto result = GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply); pickupToolPlacementCommandCallback(result, self, head.head); } // 0x004B2C95 template<typename GetPlacementArgsFunc> static void pickupToolDownLand(Window& self, const Vehicles::VehicleHead& head, const int16_t x, const int16_t y, GetPlacementArgsFunc&& getPlacementArgs) { auto placementArgs = getPlacementArgs(head, x, y); if (!placementArgs) { pickupToolError(head); return; } if (*_ghostLandTrackAndDirection == placementArgs->trackAndDirection && *_ghostVehiclePos == placementArgs->pos && *_1136264 == placementArgs->trackProgress) { if (head.tileX != -1 && head.has38Flags(Vehicles::Flags38::isGhost)) { // Will convert inplace vehicle into non ghost placementArgs->convertGhost = true; } } if (!placementArgs->convertGhost) { removeLandGhost(head); } auto args = FormatArguments::common(); args.skip(6); args.push(head.name); args.push(head.ordinalNumber); GameCommands::setErrorTitle(StringIds::cant_place_string_id_here); auto result = GameCommands::doCommand(*placementArgs, GameCommands::Flags::apply); pickupToolPlacementCommandCallback(result, self, head.head); } // 0x004B2C74 static void pickupToolDown(Window& self, const int16_t x, const int16_t y) { auto* head = getVehicle(self); if (head == nullptr) { return; } switch (head->mode) { case TransportMode::rail: pickupToolDownLand(self, *head, x, y, getVehicleRailPlacementArgsFromCursor); break; case TransportMode::road: pickupToolDownLand(self, *head, x, y, getVehicleRoadPlacementArgsFromCursor); break; case TransportMode::air: pickupToolDownAir(self, *head, x, y); break; case TransportMode::water: pickupToolDownWater(self, *head, x, y); break; } } // 0x004B3035 static void pickupToolAbort(Window& self) { // TODO: refactor to use removeAirplaneGhost family of functions auto* head = EntityManager::get<Vehicles::VehicleHead>(EntityId(self.number)); if (head == nullptr) { return; } if (head->tileX == -1 || !head->has38Flags(Vehicles::Flags38::isGhost)) { self.invalidate(); return; } switch (head->mode) { case TransportMode::rail: case TransportMode::road: { GameCommands::VehiclePickupArgs args{}; args.head = head->id; auto flags = GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::ghost; GameCommands::doCommand(args, flags); break; } case TransportMode::air: { GameCommands::VehiclePickupAirArgs gcArgs{}; gcArgs.head = head->id; auto flags = GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::ghost; GameCommands::doCommand(gcArgs, flags); break; } case TransportMode::water: { GameCommands::VehiclePickupWaterArgs gcArgs{}; gcArgs.head = head->id; auto flags = GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::ghost; GameCommands::doCommand(gcArgs, flags); break; } } self.invalidate(); } // 0x004B2680 static void renameVehicle(Window& self, WidgetIndex_t widgetIndex) { auto vehicle = getVehicle(self); if (vehicle != nullptr) { FormatArguments args{}; args.push(StringIds::getVehicleType(vehicle->vehicleType)); // 0 args.skip(6); args.push(StringIds::getVehicleType(vehicle->vehicleType)); // 8 TextInput::openTextInput(&self, StringIds::title_name_vehicle, StringIds::prompt_enter_new_vehicle_name, vehicle->name, widgetIndex, &vehicle->ordinalNumber); } } // 0x004B2566 static void switchTab(Window& self, WidgetIndex_t widgetIndex) { ToolManager::toolCancel(self.type, self.number); TextInput::sub_4CE6C9(self.type, self.number); self.currentTab = widgetIndex - Common::widx::tabMain; self.frameNo = 0; self.flags &= ~WindowFlags::flag_16; self.var_85C = -1; self.viewportRemove(0); auto tabInfo = tabInformationByTabOffset[widgetIndex - widx::tabMain]; self.holdableWidgets = *tabInfo.holdableWidgets; self.eventHandlers = &tabInfo.events; self.activatedWidgets = ``` > [truncated] --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/VehicleList.cpp ```cpp #include "Date.h" #include "Entities/EntityManager.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Objects/CargoObject.h" #include "Objects/CompetitorObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "OpenLoco.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/ToolTip.h" #include "Ui/Widget.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/LabelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/ScrollViewWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/Widgets/TableHeaderWidget.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include "Vehicles/VehicleManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Utility/String.hpp> #include <stdexcept> #include <utility> namespace OpenLoco::Ui::Windows::VehicleList { static constexpr Ui::Size32 kWindowSize = { 550, 213 }; static constexpr Ui::Size kMaxDimensions = { 550, 1200 }; static constexpr Ui::Size kMinDimensions = { 220, 160 }; enum Widx { frame = 0, caption = 1, close_button = 2, panel = 3, tab_trains, tab_buses, tab_trucks, tab_trams, tab_aircraft, tab_ships, company_select, sort_name, sort_profit, sort_age, sort_reliability, scrollview, status_bar, filter_type, filter_type_btn, cargo_type, cargo_type_btn, }; static constexpr auto _widgets = makeWidgets( Widgets::Frame({ 0, 0 }, { 550, 213 }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { 548, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary), Widgets::ImageButton({ 535, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { 550, 172 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_trains), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_buses), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_trucks), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_trams), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_aircraft), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tooltip_ships), Widgets::ImageButton({ 0, 14 }, { 26, 26 }, WindowColour::primary, Widget::kContentNull, StringIds::tooltip_select_company), Widgets::TableHeader({ 4, 43 }, { 310, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_name), Widgets::TableHeader({ 314, 43 }, { 100, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_profit), Widgets::TableHeader({ 414, 43 }, { 65, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_age), Widgets::TableHeader({ 479, 43 }, { 67, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_sort_by_reliability), Widgets::ScrollView({ 3, 56 }, { 544, 138 }, WindowColour::secondary, Scrollbars::vertical), Widgets::Label({ 3, kWindowSize.height - 13 }, { kWindowSize.width, 10 }, WindowColour::secondary, ContentAlign::left, StringIds::black_stringid), Widgets::dropdownWidgets({ 280 - 16, 200 }, { 120, 12 }, WindowColour::secondary, StringIds::wcolour2_stringid), Widgets::dropdownWidgets({ 402 - 16, 200 }, { 150, 12 }, WindowColour::secondary, StringIds::wcolour2_stringid) ); // clang-format off constexpr uint16_t _tabWidgets = (1 << Widx::tab_trains) | (1 << Widx::tab_buses) | (1 << Widx::tab_trucks) | (1 << Widx::tab_trams) | (1 << Widx::tab_aircraft) | (1 << Widx::tab_ships); // clang-format on enum SortMode : uint16_t { Name, Profit, Age, Reliability, }; enum FilterMode : uint8_t { allVehicles, transportingCargo, }; static constexpr uint8_t row_heights[] = { 28, 28, 28, 28, 48, 36 }; static Widx getTabFromType(VehicleType type); constexpr bool isCargoFilterActive(const Window& self, bool checkSelection = true) { return self.var_88A == static_cast<int16_t>(FilterMode::transportingCargo) && (!checkSelection || self.var_88C != -1); } using Vehicles::VehicleHead; static bool vehicleIsTransportingCargo(const VehicleHead* head, int16_t filterCargoId) { auto orders = Vehicles::OrderRingView(head->orderTableOffset); for (auto& order : orders) { Vehicles::OrderCargo* cargoOrder = order.as<Vehicles::OrderUnloadAll>(); if (cargoOrder == nullptr) { cargoOrder = order.as<Vehicles::OrderWaitFor>(); } if (cargoOrder == nullptr) { continue; } const auto cargoId = cargoOrder->getCargo(); if (cargoId == filterCargoId) { return true; } } return false; } // 0x004C1D4F static void refreshVehicleList(Window& self) { self.rowCount = 0; for (auto* vehicle : VehicleManager::VehicleList()) { if (vehicle->vehicleType != static_cast<VehicleType>(self.currentTab)) { continue; } if (vehicle->owner != CompanyId(self.number)) { continue; } if (isCargoFilterActive(self) && !vehicleIsTransportingCargo(vehicle, self.var_88C)) { continue; } vehicle->vehicleFlags &= ~VehicleFlags::sorted; } } // 0x004C1E4F static bool orderByName(const VehicleHead& lhs, const VehicleHead& rhs) { char lhsString[256] = { 0 }; { FormatArguments lhsArgs{}; lhsArgs.push(lhs.ordinalNumber); StringManager::formatString(lhsString, lhs.name, lhsArgs); } char rhsString[256] = { 0 }; { FormatArguments rhsArgs{}; rhsArgs.push(rhs.ordinalNumber); StringManager::formatString(rhsString, rhs.name, rhsArgs); } return Utility::strlogicalcmp(lhsString, rhsString) < 0; } // 0x004C1EC9 static bool orderByProfit(const VehicleHead& lhs, const VehicleHead& rhs) { auto profitL = Vehicles::Vehicle(lhs).veh2->totalRecentProfit(); auto profitR = Vehicles::Vehicle(rhs).veh2->totalRecentProfit(); return profitR - profitL < 0; } // 0x004C1F1E static bool orderByAge(const VehicleHead& lhs, const VehicleHead& rhs) { auto dayCreatedL = Vehicles::Vehicle(lhs).veh1->dayCreated; auto dayCreatedR = Vehicles::Vehicle(rhs).veh1->dayCreated; return static_cast<int32_t>(dayCreatedL - dayCreatedR) < 0; } // 0x004C1F45 static bool orderByReliability(const VehicleHead& lhs, const VehicleHead& rhs) { auto reliabilityL = Vehicles::Vehicle(lhs).veh2->reliability; auto reliabilityR = Vehicles::Vehicle(rhs).veh2->reliability; return static_cast<int32_t>(reliabilityR - reliabilityL) < 0; } static bool getOrder(const SortMode mode, const VehicleHead& lhs, const VehicleHead& rhs) { switch (mode) { case SortMode::Name: return orderByName(lhs, rhs); case SortMode::Profit: return orderByProfit(lhs, rhs); case SortMode::Age: return orderByAge(lhs, rhs); case SortMode::Reliability: return orderByReliability(lhs, rhs); } return false; } // 0x004C1D92 static void updateVehicleList(Window& self) { EntityId insertId = EntityId::null; for (auto* vehicle : VehicleManager::VehicleList()) { if (vehicle->vehicleType != static_cast<VehicleType>(self.currentTab)) { continue; } if (vehicle->owner != CompanyId(self.number)) { continue; } if (vehicle->hasVehicleFlags(VehicleFlags::sorted)) { continue; } if (isCargoFilterActive(self) && !vehicleIsTransportingCargo(vehicle, self.var_88C)) { continue; } if (insertId == EntityId::null) { insertId = vehicle->id; continue; } auto* insertVehicle = EntityManager::get<VehicleHead>(insertId); if (insertVehicle == nullptr) { continue; } if (getOrder(SortMode(self.sortMode), *vehicle, *insertVehicle)) { insertId = vehicle->id; continue; } } if (insertId != EntityId::null) { auto vehicle = EntityManager::get<VehicleHead>(insertId); if (vehicle == nullptr) { self.var_83C = self.rowCount; refreshVehicleList(self); return; } vehicle->vehicleFlags |= VehicleFlags::sorted; if (vehicle->id != EntityId(self.rowInfo[self.rowCount])) { self.rowInfo[self.rowCount] = enumValue(vehicle->id); } self.rowCount++; if (self.rowCount > self.var_83C) { self.var_83C = self.rowCount; } } else { if (self.var_83C != self.rowCount) { self.var_83C = self.rowCount; } refreshVehicleList(self); } } // 0x004C2A6E static void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto skin = ObjectManager::get<InterfaceSkinObject>(); auto companyColour = CompanyManager::getCompanyColour(CompanyId(self.number)); static constexpr std::pair<WidgetIndex_t, std::array<uint32_t, 8>> tabAnimations[] = { { Widx::tab_trains, { InterfaceSkin::ImageIds::vehicle_train_frame_0, InterfaceSkin::ImageIds::vehicle_train_frame_1, InterfaceSkin::ImageIds::vehicle_train_frame_2, InterfaceSkin::ImageIds::vehicle_train_frame_3, InterfaceSkin::ImageIds::vehicle_train_frame_4, InterfaceSkin::ImageIds::vehicle_train_frame_5, InterfaceSkin::ImageIds::vehicle_train_frame_6, InterfaceSkin::ImageIds::vehicle_train_frame_7, } }, { Widx::tab_aircraft, { InterfaceSkin::ImageIds::vehicle_aircraft_frame_0, InterfaceSkin::ImageIds::vehicle_aircraft_frame_1, InterfaceSkin::ImageIds::vehicle_aircraft_frame_2, InterfaceSkin::ImageIds::vehicle_aircraft_frame_3, InterfaceSkin::ImageIds::vehicle_aircraft_frame_4, InterfaceSkin::ImageIds::vehicle_aircraft_frame_5, InterfaceSkin::ImageIds::vehicle_aircraft_frame_6, InterfaceSkin::ImageIds::vehicle_aircraft_frame_7, } }, { Widx::tab_buses, { InterfaceSkin::ImageIds::vehicle_buses_frame_0, InterfaceSkin::ImageIds::vehicle_buses_frame_1, InterfaceSkin::ImageIds::vehicle_buses_frame_2, InterfaceSkin::ImageIds::vehicle_buses_frame_3, InterfaceSkin::ImageIds::vehicle_buses_frame_4, InterfaceSkin::ImageIds::vehicle_buses_frame_5, InterfaceSkin::ImageIds::vehicle_buses_frame_6, InterfaceSkin::ImageIds::vehicle_buses_frame_7, } }, { Widx::tab_trams, { InterfaceSkin::ImageIds::vehicle_trams_frame_0, InterfaceSkin::ImageIds::vehicle_trams_frame_1, InterfaceSkin::ImageIds::vehicle_trams_frame_2, InterfaceSkin::ImageIds::vehicle_trams_frame_3, InterfaceSkin::ImageIds::vehicle_trams_frame_4, InterfaceSkin::ImageIds::vehicle_trams_frame_5, InterfaceSkin::ImageIds::vehicle_trams_frame_6, InterfaceSkin::ImageIds::vehicle_trams_frame_7, } }, { Widx::tab_trucks, { InterfaceSkin::ImageIds::vehicle_trucks_frame_0, InterfaceSkin::ImageIds::vehicle_trucks_frame_1, InterfaceSkin::ImageIds::vehicle_trucks_frame_2, InterfaceSkin::ImageIds::vehicle_trucks_frame_3, InterfaceSkin::ImageIds::vehicle_trucks_frame_4, InterfaceSkin::ImageIds::vehicle_trucks_frame_5, InterfaceSkin::ImageIds::vehicle_trucks_frame_6, InterfaceSkin::ImageIds::vehicle_trucks_frame_7, } }, { Widx::tab_ships, { InterfaceSkin::ImageIds::vehicle_ships_frame_0, InterfaceSkin::ImageIds::vehicle_ships_frame_1, InterfaceSkin::ImageIds::vehicle_ships_frame_2, InterfaceSkin::ImageIds::vehicle_ships_frame_3, InterfaceSkin::ImageIds::vehicle_ships_frame_4, InterfaceSkin::ImageIds::vehicle_ships_frame_5, InterfaceSkin::ImageIds::vehicle_ships_frame_6, InterfaceSkin::ImageIds::vehicle_ships_frame_7, } }, }; for (auto [tab, frames] : tabAnimations) { if (self.isDisabled(tab)) { continue; } auto isActive = tab == self.currentTab + Widx::tab_trains; auto imageId = isActive ? frames[self.frameNo / 2 % 8] : frames[0]; uint32_t image = Gfx::recolour(skin->img + imageId, companyColour); Widget::drawTab(self, drawingCtx, image, tab); } } // 0x004C28A5 static void disableUnavailableVehicleTypes(Window& self) { // The original game looks at all companies here. We only look at the current company instead. auto* company = CompanyManager::get(CompanyId(self.number)); // Disable the tabs for the vehicles that are _not_ available for this company. self.disabledWidgets = (static_cast<uint64_t>(company->availableVehicles ^ 0x3F)) << Widx::tab_trains; } static const WindowEventList& getEvents(); // 0x004C1AA2 static Window* create(CompanyId companyId) { Window* self = WindowManager::createWindow( WindowType::vehicleList, kWindowSize, WindowFlags::flag_11, getEvents()); self->setWidgets(_widgets); self->number = enumValue(companyId); self->owner = companyId; self->frameNo = 0; auto skin = ObjectManager::get<InterfaceSkinObject>(); self->setColour(WindowColour::secondary, skin->windowPlayerColor); disableUnavailableVehicleTypes(*self); return self; } // 0x004C19DC Window* open(CompanyId companyId, VehicleType type) { Window* self = WindowManager::bringToFront(WindowType::vehicleList, enumValue(companyId)); if (self != nullptr) { const auto tabWidx = getTabFromType(type); self->callOnMouseUp(tabWidx, self->widgets[tabWidx].id); return self; } // 0x004C1A05 self = create(companyId); auto tabIndex = static_cast<uint8_t>(type); self->currentTab = tabIndex; self->rowHeight = row_heights[tabIndex]; self->width = kWindowSize.width; self->height = kWindowSize.height; self->sortMode = 0; self->var_83C = 0; self->rowHover = -1; self->var_88A = static_cast<int16_t>(FilterMode::allVehicles); self->var_88C = -1; refreshVehicleList(*self); self->invalidate(); self->callOnResize(); self->callPrepareDraw(); self->initScrollWidgets(); return self; } // 0x004C1D19 void removeTrainFromList(Window& self, EntityId head) { for (auto i = 0; i < self.var_83C; ++i) { auto& entry = self.rowInfo[i]; if (entry == enumValue(head)) { entry = enumValue(EntityId::null); } } } static Widx getTabFromType(VehicleType type) { auto tabIndex = static_cast<uint8_t>(type); if (tabIndex > 5) { throw Exception::RuntimeError("Unexpected vehicle type"); } static constexpr Widx type_to_widx[] = { tab_trains, tab_buses, tab_trucks, tab_trams, tab_aircraft, tab_ships, }; return type_to_widx[tabIndex]; } // 0x004C1F88 static void prepareDraw(Window& self) { disableUnavailableVehicleTypes(self); // The original game was setting widget sets here. As all tabs are the same, this has been omitted. self.activatedWidgets &= ~_tabWidgets; self.activatedWidgets |= 1ULL << (self.currentTab + Widx::tab_trains); auto company = CompanyManager::get(CompanyId(self.number)); { // Set company in title auto args = FormatArguments(self.widgets[Widx::caption].textArgs); args.push(company->name); } static constexpr StringId kTypeToCaption[] = { StringIds::stringid_trains, StringIds::stringid_buses, StringIds::stringid_trucks, StringIds::stringid_trams, StringIds::stringid_aircraft, StringIds::stringid_ships, }; // Basic frame widget dimensions self.widgets[Widx::frame].right = self.width - 1; self.widgets[Widx::frame].bottom = self.height - 1; self.widgets[Widx::panel].right = self.width - 1; self.widgets[Widx::panel].bottom = self.height - 1; self.widgets[Widx::caption].right = self.width - 2; self.widgets[Widx::caption].text = kTypeToCaption[self.currentTab]; self.widgets[Widx::close_button].left = self.width - 15; self.widgets[Widx::close_button].right = self.width - 3; self.widgets[Widx::scrollview].right = self.width - 4; self.widgets[Widx::scrollview].bottom = self.height - 14; // Reposition table headers self.widgets[Widx::sort_name].right = std::min(self.width - 4, 313); self.widgets[Widx::sort_profit].left = std::min(self.width - 4, 314); self.widgets[Widx::sort_profit].right = std::min(self.width - 4, 413); self.widgets[Widx::sort_age].left = std::min(self.width - 4, 414); self.widgets[Widx::sort_age].right = std::min(self.width - 4, 478); self.widgets[Widx::sort_reliability].left = std::min(self.width - 4, 479); self.widgets[Widx::sort_reliability].right = std::min(self.width - 4, 545); // Reposition company selection self.widgets[Widx::company_select].left = self.width - 28; self.widgets[Widx::company_select].right = self.width - 3; // Set header button captions. self.widgets[Widx::sort_name].text = self.sortMode == SortMode::Name ? StringIds::table_header_name_desc : StringIds::table_header_name; self.widgets[Widx::sort_profit].text = self.sortMode == SortMode::Profit ? StringIds::table_header_monthly_profit_desc : StringIds::table_header_monthly_profit; self.widgets[Widx::sort_age].text = self.sortMode == SortMode::Age ? StringIds::table_header_age_desc : StringIds::table_header_age; self.widgets[Widx::sort_reliability].text = self.sortMode == SortMode::Reliability ? StringIds::table_header_reliability_desc : StringIds::table_header_reliability; // Reposition filter dropdowns self.widgets[Widx::filter_type].top = self.height - 13; self.widgets[Widx::filter_type].bottom = self.height - 2; self.widgets[Widx::filter_type_btn].top = self.height - 12; self.widgets[Widx::filter_type_btn].bottom = self.height - 3; self.widgets[Widx::cargo_type].top = self.height - 13; self.widgets[Widx::cargo_type].bottom = self.height - 2; self.widgets[Widx::cargo_type_btn].top = self.height - 12; self.widgets[Widx::cargo_type_btn].bottom = self.height - 3; // Disable cargo dropdown if not applicable if (self.var_88A != FilterMode::transportingCargo) { self.disabledWidgets |= (1 << Widx::cargo_type) | (1 << Widx::cargo_type_btn); } else { self.disabledWidgets &= ~((1 << Widx::cargo_type) | (1 << Widx::cargo_type_btn)); } // Set appropriate tooltip static constexpr std::array<StringId, 3> kFilterTooltipByType = { StringIds::null, StringIds::tooltip_open_station_window_to_filter, StringIds::tooltip_select_cargo_type, }; self.widgets[Widx::cargo_type_btn].tooltip = kFilterTooltipByType[self.var_88A]; Widget::leftAlignTabs(self, Widx::tab_trains, Widx::tab_ships); static constexpr std::pair<StringId, StringId> kTypeToFooterStringIds[]{ { StringIds::num_trains_singular, StringIds::num_trains_plural }, { StringIds::num_buses_singular, StringIds::num_buses_plural }, { StringIds::num_trucks_singular, StringIds::num_trucks_plural }, { StringIds::num_trams_singular, StringIds::num_trams_plural }, { StringIds::num_aircrafts_singular, StringIds::num_aircrafts_plural }, { StringIds::num_ships_singular, StringIds::num_ships_plural }, }; { // Reposition status bar auto& widget = self.widgets[Widx::status_bar]; widget.top = self.height - 13; widget.bottom = self.height - 3; // Set status bar FormatArguments args{ widget.textArgs }; auto& footerStringPair = kTypeToFooterStringIds[self.currentTab]; args.push(self.var_83C == 1 ? footerStringPair.first : footerStringPair.second); args.push(self.var_83C); } static constexpr std::array<StringId, 2> kTypeToFilterStringIds{ StringIds::all_vehicles, StringIds::transporting_cargo, }; { // Set current filter type auto& widget = self.widgets[Widx::filter_type]; FormatArguments args{ widget.textArgs }; args.push(kTypeToFilterStringIds[self.var_88A]); } auto& widget = self.widgets[Widx::cargo_type]; bool filterActive = false; FormatArguments args{ widget.textArgs }; if (isCargoFilterActive(self, false)) { filterActive = true; if (self.var_88C != -1) { // Show current cargo auto cargoObj = ObjectManager::get<CargoObject>(self.var_88C); args.push(StringIds::carrying_cargoid_sprite); args.push(cargoObj->name); args.push(cargoObj->unitInlineSprite); } else { args.push(StringIds::no_cargo_selected); } } widget.text = filterActive ? StringIds::wcolour2_stringid : StringIds::empty; } // 0x004C211C static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); drawTabs(self, drawingCtx); // Draw company owner image. auto company = CompanyManager::get(CompanyId(self.number)); auto competitorObj = ObjectManager::get<CompetitorObject>(company->competitorId); uint32_t image = Gfx::recolour(competitorObj->images[enumValue(company->ownerEmotion)], company->mainColours.primary); uint16_t x = self.x + self.widgets[Widx::company_select].left + 1; uint16_t y = self.y + self.widgets[Widx::company_select].top + 1; drawingCtx.drawImage(x, y, image); } // 0x004C21CD static void drawScroll(Window& self, Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const uint32_t scrollIndex) { const auto& rt = drawingCtx.currentRenderTarget(); auto tr = Gfx::TextRenderer(drawingCtx); auto shade = Colours::getShade(self.getColour(WindowColour::secondary).c(), 1); drawingCtx.clearSingle(shade); auto yPos = 0; for (auto i = 0; i < self.var_83C; i++) { const auto vehicleId = EntityId(self.rowInfo[i]); // Item not in rendering context, or no vehicle available for this slot? if (yPos + self.rowHeight < rt.y || vehicleId == EntityId::null) { yPos += self.rowHeight; continue; } else if (yPos >= rt.y + rt.height + self.rowHeight) { break; } auto head = EntityManager::get<VehicleHead>(vehicleId); if (head == nullptr) { continue; } // Highlight selection. if (head->id == EntityId(self.rowHover)) { drawingCtx.drawRect(0, yPos, self.width, self.rowHeight, Colours::getShade(self.getColour(WindowColour::secondary).c(), 0), Gfx::RectFlags::none); } auto vehicle = Vehicles::Vehicle(*head); // Draw vehicle at the bottom of the row. drawTrainInline(drawingCtx, vehicle, Ui::Point(0, yPos + (self.rowHeight - 28) / 2 + 6)); // Draw vehicle status { // Prepare status for drawing auto status = head->getStatus(); auto args = FormatArguments::common(); args.push(head->name); args.push(head->ordinalNumber); args.push(status.status1); args.push(status.status1Args); args.push(status.status2); args.push(status.status2Args); StringId format = StringIds::vehicle_list_status_2pos; if (status.status2 != StringIds::null) { format = StringIds::vehicle_list_status_3pos; } // Draw status yPos += 2; auto point = Point(1, yPos); tr.drawStringLeftClipped(point, 308, AdvancedColour(Colour::black).outline(), format, args); } // Vehicle profit { StringId format = StringIds::vehicle_list_profit_pos; currency32_t profit = vehicle.veh2->totalRecentProfit() / 4; if (profit < 0) { format = StringIds::vehicle_list_profit_neg; profit *= -1; } auto args = FormatArguments::common(profit); auto point = Point(310, yPos); tr.drawStringLeftClipped(point, 98, AdvancedColour(Colour::black).outline(), format, args); } // Vehicle age { StringId format = StringIds::vehicle_list_age_years; auto age = (getCurrentDay() - vehicle.veh1->dayCreated) / 365; if (age == 1) { format = StringIds::vehicle_list_age_year; } auto args = FormatArguments::common(age); auto point = Point(410, yPos); tr.drawStringLeftClipped(point, 63, AdvancedColour(Colour::black).outline(), format, args); } // Vehicle reliability { int16_t reliability = vehicle.veh2->reliability; auto args = FormatArguments::common(reliability); auto point = Point(475, yPos); tr.drawStringLeftClipped(point, 65, AdvancedColour(Colour::black).outline(), StringIds::vehicle_list_reliability, args); } yPos += self.rowHeight - 2; } } // 0x004C24F7 static void switchTab(Window& self, VehicleType type) { if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } auto tabIndex = static_cast<uint8_t>(type); self.currentTab = tabIndex; self.rowHeight = row_heights[tabIndex]; self.frameNo = 0; if (CompanyManager::getControllingId() == CompanyId(self.number) && getGameState().lastVehicleType != type) { getGameState().lastVehicleType = type; WindowManager::invalidate(WindowType::topToolbar); } // The original game was setting viewports and (enabled/disabled) widgets here. // As all tabs are the same, we've simplified this. disableUnavailableVehicleTypes(self); self.invalidate(); if (self.width < 220) { self.width = 220; } self.rowCount = 0; refreshVehicleList(self); self.var_83C = 0; self.rowHover = -1; self.callOnResize(); self.callOnPeriodicUpdate(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); self.moveInsideScreenEdges(); } // 0x004C2409 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Widx::close_button: WindowManager::close(&self); break; case Widx::tab_trains: case Widx::tab_buses: case Widx::tab_trucks: case Widx::tab_trams: case Widx::tab_aircraft: case Widx::tab_ships: { auto vehicleType = VehicleType(widgetIndex - Widx::tab_trains); switchTab(self, vehicleType); break; } case Widx::sort_name: case Widx::sort_profit: case Widx::sort_age: case Widx::sort_reliability: { auto sortMode = widgetIndex - Widx::sort_name; if (self.sortMode == sortMode) { return; } self.sortMode = sortMode; self.invalidate(); refreshVehicleList(self); break; } } } // 0x004C2434 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex == Widx::company_select) { Dropdown::populateCompanySelect(&self, &self.widgets[widgetIndex]); } else if (widgetIndex == Widx::filter_type_btn) { Widget dropdown = self.widgets[Widx::filter_type]; Dropdown::show(self.x + dropdown.left, self.y + dropdown.top, dropdown.width() - 4, dropdown.height(), self.getColour(WindowColour::secondary), 2, 0x80); Dropdown::add(0, StringIds::dropdown_stringid, StringIds::all_vehicles); Dropdown::add(1, StringIds::dropdown_stringid, StringIds::transporting_cargo); Dropdown::setItemSelected(self.var_88A); } else if (widgetIndex == Widx::cargo_type_btn) { auto index = 0; auto selectedIndex = -1; for (uint16_t cargoId = 0; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); ++cargoId) { auto cargoObj = ObjectManager::get<CargoObject>(cargoId); if (cargoObj == nullptr) { continue; } FormatArguments args{}; args.push(cargoObj->name); args.push(cargoObj->unitInlineSprite); args.push(cargoId); Dropdown::add(index, StringIds::carrying_cargoid_sprite, args); if (index == self.var_88C) { selectedIndex = index; } index++; } Widget dropdown = self.widgets[Widx::cargo_type]; Dropdown::showText(self.x + dropdown.left, self.y + dropdown.top, dropdown.width() - 4, dropdown.height(), self.getColour(WindowColour::secondary), index, 0); if (selectedIndex != -1) { Dropdown::setItemSelected(selectedIndex); } } } // 0x004C243F static void onCompanyDropdown(Ui::Window& self, int16_t itemIndex) { if (itemIndex == -1) { return; } CompanyId companyId = Dropdown::getCompanyIdFromSelection(itemIndex); // Try to find an open vehicle list for this company. auto companyWindow = WindowManager::bringToFront(WindowType::vehicleList, enumValue(companyId)); if (companyWindow != nullptr) { return; } // If not, we'll turn this window into a window for the company selected. auto company = CompanyManager::get(companyId); if (company->name == StringIds::empty) { return; } self.number = enumValue(companyId); self.owner = companyId; disableUnavailableVehicleTypes(self); self.rowCount = 0; refreshVehicleList(self); self.var_83C = 0; self.rowHover = -1; self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); } static void onDropdown(Ui::Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == Widx::company_select) { return onCompanyDropdown(self, itemIndex); } if (widgetIndex == filter_type_btn && itemIndex != -1) { if (self.var_88A != itemIndex) { self.var_88A = itemIndex; self.var_88C = -1; } } else if (widgetIndex == cargo_type_btn && itemIndex != -1) { self.var_88C = Dropdown::getItemArgument(itemIndex, 3); } } // 0x004C24CA static std::optional<FormatArguments> tooltip([[maybe_unused]] Window& self, [[maybe_unused]] WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.push(StringIds::tooltip_scroll_vehicle_list); return args; } // 0x004C260B static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); auto widgetIndex = getTabFromType(static_cast<VehicleType>(self.currentTab)); WindowManager::invalidateWidget(WindowType::vehicleList, self.number, widgetIndex); // It adds 3 vehicles per update, this is not an accident. updateVehicleList(self); updateVehicleList(self); updateVehicleList(self); self.invalidate(); } // 0x004C2640 static void event_08(Window& self) { self.flags |= WindowFlags::notScrollView; } // 0x004C2648 static void event_09(Window& self) { if (self.hasFlags(WindowFlags::notScrollView)) { self.rowHover = -1; } } // 0x004C265B static void getScrollSize(Window& self, [[maybe_unused]] uint32_t scrollIndex, [[maybe_unused]] int32_t& scrollWidth, int32_t& scrollHeight) { scrollHeight = self.var_83C * self.rowHeight; } // 0x004C266D static CursorId cursor(Window& self, WidgetIndex_t widgetIdx, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, int16_t yPos, CursorId fallback) { if (widgetIdx != Widx::scrollview) { return fallback; } uint16_t currentIndex = yPos / self.rowHeight; if (currentIndex < self.var_83C && self.rowInfo[currentIndex] != -1) { return CursorId::handPointer; } return fallback; } // 0x004C26A4 static void onScrollMouseOver(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { Ui::ToolTip::setTooltipTimeout(2000); self.flags &= ~WindowFlags::notScrollView; uint16_t currentRow = y / self.rowHeight; if (currentRow < self.var_83C) { self.rowHover = self.rowInfo[currentRow]; } else { self.rowHover = -1; } StringId tooltipId = StringIds::buffer_337; if (self.rowHover == -1) { tooltipId = StringIds::null; } char* tooltipBuffer = const_cast<char*>(StringManager::getString(StringIds::buffer_337)); // Have we already got the right tooltip? if (tooltipBuffer[0] != '\0' && self.widgets[Widx::scrollview].tooltip == tooltipId && self.rowHover == self.var_85C) { return; } self.widgets[Widx::scrollview].tooltip = tooltipId; self.var_85C = self.rowHover; Ui::Windows::ToolTip::closeAndReset(); if (self.rowHover == -1) { return; } // Initialise tooltip buffer. char* buffer = StringManager::formatString(tooltipBuffer, StringIds::vehicle_list_tooltip_load); // Append load to buffer. auto head = EntityManager::get<VehicleHead>(EntityId(self.var_85C)); if (head == nullptr) { return; } buffer = head->generateCargoTotalString(buffer); // Figure out what stations the vehicle stops at. auto orders = Vehicles::OrderRingView(head->orderTableOffset); bool isFirstStop = true; for (auto& order : orders) { // Is this order a station? auto* stopOrder = order.as<Vehicles::OrderStopAt>(); if (stopOrder == nullptr) { continue; } StringId stopFormat = StringIds::vehicle_list_tooltip_comma_stringid; if (isFirstStop) { stopFormat = StringIds::vehicle_list_tooltip_stops_at_stringid; } // Append station name to the tooltip buffer FormatArguments args{}; stopOrder->setFormatArguments(args); buffer = StringManager::formatString(buffer, stopFormat, args); isFirstStop = false; } } // 0x004C27C0 static void onScrollMouseDown(Window& self, [[maybe_unused]] int16_t x, int16_t y, [[maybe_unused]] uint8_t scroll_index) { uint16_t currentRow = y / self.rowHeight; if (currentRow >= self.var_83C) { return; } EntityId currentVehicleId = EntityId(self.rowInfo[currentRow]); if (currentVehicleId == EntityId::null) { return; } auto* head = EntityManager::get<VehicleHead>(currentVehicleId); if (head == nullptr) { return; } if (head->isPlaced()) { Ui::Windows::Vehicle::Main::open(head); } else { Ui::Windows::Vehicle::Details::open(head); } } // 0x004C2820 static void onResize(Window& self) { self.flags |= WindowFlags::resizable; self.minWidth = kMinDimensions.width; self.minHeight = kMinDimensions.height; self.maxWidth = kMaxDimensions.width; self.maxHeight = kMaxDimensions.height; if (self.width < self.minWidth) { self.width = self.minWidth; self.invalidate(); } if (self.height < self.minHeight) { self.height = self.minHeight; self.invalidate(); } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .event_08 = event_08, .event_09 = event_09, .getScrollSize = getScrollSize, .scrollMouseDown = onScrollMouseDown, .scrollMouseOver = onScrollMouseOver, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, .drawScroll = drawScroll, }; static const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Construction/Common.cpp ```cpp #include "Construction.h" #include "Date.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Input.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/TileElement.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/AirportObject.h" #include "Objects/BridgeObject.h" #include "Objects/DockObject.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "Objects/ObjectUtils.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainSignalObject.h" #include "Objects/TrainStationObject.h" #include "SceneManager.h" #include "Ui/ToolManager.h" #include "Ui/Widget.h" #include "World/CompanyManager.h" #include "World/StationManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::TileManager; namespace OpenLoco::Ui::Windows::Construction { static Window* nonTrackWindow() { auto window = WindowManager::find(WindowType::construction); if (window != nullptr) { Common::setDisabledWidgets(window); } window = WindowManager::find(WindowType::construction); if (window != nullptr) { window->callOnMouseUp(Common::widx::tab_station, window->widgets[Common::widx::tab_station].id); } return window; } static Window* trackWindow() { auto window = WindowManager::find(WindowType::construction); if (window != nullptr) { Common::setDisabledWidgets(window); } Construction::activateSelectedConstructionWidgets(); window = WindowManager::find(WindowType::construction); if (window != nullptr) { window->callOnMouseUp(Construction::widx::rotate_90, window->widgets[Construction::widx::rotate_90].id); } return window; } static Window* createTrackConstructionWindow() { Common::createConstructionWindow(); const auto signalList = getAvailableCompatibleSignals(_cState->trackType); Common::copyToLegacyList(signalList, _cState->signalList); auto lastSignal = Scenario::getConstruction().signals[_cState->trackType]; if (lastSignal == 0xFF) { lastSignal = _cState->signalList[0]; } _cState->lastSelectedSignal = lastSignal; const auto stationList = getAvailableCompatibleStations(_cState->trackType, TransportMode::rail); Common::copyToLegacyList(stationList, _cState->stationList); auto lastStation = Scenario::getConstruction().trainStations[_cState->trackType]; if (lastStation == 0xFF) { lastStation = _cState->stationList[0]; } _cState->lastSelectedStationType = lastStation; const auto bridgeList = getAvailableCompatibleBridges(_cState->trackType, TransportMode::rail); Common::copyToLegacyList(bridgeList, _cState->bridgeList); auto lastBridge = Scenario::getConstruction().bridges[_cState->trackType]; if (lastBridge == 0xFF) { lastBridge = _cState->bridgeList[0]; } _cState->lastSelectedBridge = lastBridge; const auto modList = getAvailableCompatibleMods(_cState->trackType, TransportMode::rail, GameCommands::getUpdatingCompanyId()); std::copy(modList.begin(), modList.end(), std::begin(_cState->modList)); auto lastMod = Scenario::getConstruction().trackMods[_cState->trackType]; if (lastMod == 0xFF) { lastMod = 0; } _cState->lastSelectedMods = lastMod; _cState->byte_113603A = 0; return trackWindow(); } static Window* createRoadConstructionWindow() { Common::createConstructionWindow(); _cState->lastSelectedSignal = 0xFF; const auto stationList = getAvailableCompatibleStations(_cState->trackType, TransportMode::road); Common::copyToLegacyList(stationList, _cState->stationList); auto lastStation = Scenario::getConstruction().roadStations[(_cState->trackType & ~(1ULL << 7))]; if (lastStation == 0xFF) { lastStation = _cState->stationList[0]; } _cState->lastSelectedStationType = lastStation; const auto bridgeList = getAvailableCompatibleBridges(_cState->trackType, TransportMode::road); Common::copyToLegacyList(bridgeList, _cState->bridgeList); auto lastBridge = Scenario::getConstruction().bridges[(_cState->trackType & ~(1ULL << 7))]; if (lastBridge == 0xFF) { lastBridge = _cState->bridgeList[0]; } _cState->lastSelectedBridge = lastBridge; const auto modList = getAvailableCompatibleMods(_cState->trackType, TransportMode::road, GameCommands::getUpdatingCompanyId()); std::copy(modList.begin(), modList.end(), std::begin(_cState->modList)); auto lastMod = Scenario::getConstruction().roadMods[(_cState->trackType & ~(1ULL << 7))]; if (lastMod == 0xff) { lastMod = 0; } _cState->lastSelectedMods = lastMod; _cState->byte_113603A = 0; return trackWindow(); } static Window* createDockConstructionWindow() { Common::createConstructionWindow(); _cState->lastSelectedSignal = 0xFF; _cState->modList[0] = 0xFF; _cState->modList[1] = 0xFF; _cState->modList[2] = 0xFF; _cState->modList[3] = 0xFF; _cState->lastSelectedMods = 0; _cState->lastSelectedBridge = 0xFF; const auto stationList = getAvailableDocks(); Common::copyToLegacyList(stationList, _cState->stationList); if (getGameState().lastShipPort == 0xFF) { _cState->lastSelectedStationType = _cState->stationList[0]; } else { _cState->lastSelectedStationType = getGameState().lastShipPort; } return nonTrackWindow(); } static Window* createAirportConstructionWindow() { Common::createConstructionWindow(); _cState->lastSelectedSignal = 0xFF; _cState->modList[0] = 0xFF; _cState->modList[1] = 0xFF; _cState->modList[2] = 0xFF; _cState->modList[3] = 0xFF; _cState->lastSelectedMods = 0; _cState->lastSelectedBridge = 0xFF; const auto stationList = getAvailableAirports(); Common::copyToLegacyList(stationList, _cState->stationList); if (getGameState().lastAirport == 0xFF) { _cState->lastSelectedStationType = _cState->stationList[0]; } else { _cState->lastSelectedStationType = getGameState().lastAirport; } return nonTrackWindow(); } // 0x004A0EAD Window* openAtTrack(const Window& main, TrackElement* track, const Pos2 pos) { auto* viewport = main.viewports[0]; _cState->backupTileElement = *reinterpret_cast<TileElement*>(track); auto* copyElement = (_cState->backupTileElement).as<TrackElement>(); if (copyElement == nullptr) { return nullptr; } if (copyElement->owner() != CompanyManager::getControllingId()) { return nullptr; } removeConstructionGhosts(); auto* wnd = WindowManager::find(WindowType::construction); if (wnd == nullptr) { WindowManager::closeConstructionWindows(); Common::createConstructionWindow(); } else { Common::resetWindow(*wnd, Common::widx::tab_construction); } _cState->trackType = copyElement->trackObjectId(); _cState->byte_1136063 = 0; Common::setTrackOptions(_cState->trackType); _cState->constructionHover = 0; _cState->byte_113607E = 1; _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; _cState->lastSelectedTrackModSection = Track::ModSection::single; Common::setNextAndPreviousTrackTile(*copyElement, pos); const bool isCloserToNext = Common::isPointCloserToNextOrPreviousTile(Input::getDragLastLocation(), *viewport); const auto chosenLoc = isCloserToNext ? _cState->nextTile : _cState->previousTile; const auto chosenRotation = isCloserToNext ? _cState->nextTileRotation : _cState->previousTileRotation; _cState->x = chosenLoc.x; _cState->y = chosenLoc.y; _cState->constructionZ = chosenLoc.z; _cState->constructionRotation = chosenRotation; _cState->lastSelectedTrackPiece = 0; _cState->lastSelectedTrackGradient = 0; const auto signalList = getAvailableCompatibleSignals(_cState->trackType); Common::copyToLegacyList(signalList, _cState->signalList); auto lastSignal = Scenario::getConstruction().signals[_cState->trackType]; if (lastSignal == 0xFF) { lastSignal = _cState->signalList[0]; } _cState->lastSelectedSignal = lastSignal; const auto stationList = getAvailableCompatibleStations(_cState->trackType, TransportMode::rail); Common::copyToLegacyList(stationList, _cState->stationList); auto lastStation = Scenario::getConstruction().trainStations[_cState->trackType]; if (lastStation == 0xFF) { lastStation = _cState->stationList[0]; } _cState->lastSelectedStationType = lastStation; const auto bridgeList = getAvailableCompatibleBridges(_cState->trackType, TransportMode::rail); Common::copyToLegacyList(bridgeList, _cState->bridgeList); auto lastBridge = Scenario::getConstruction().bridges[_cState->trackType]; if (lastBridge == 0xFF) { lastBridge = _cState->bridgeList[0]; } _cState->lastSelectedBridge = lastBridge; if (copyElement->hasBridge()) { _cState->lastSelectedBridge = copyElement->bridge(); } const auto modList = getAvailableCompatibleMods(_cState->trackType, TransportMode::rail, GameCommands::getUpdatingCompanyId()); std::copy(modList.begin(), modList.end(), std::begin(_cState->modList)); _cState->lastSelectedMods = copyElement->mods(); _cState->byte_113603A = 0; auto* window = WindowManager::find(WindowType::construction); if (window != nullptr) { Common::setDisabledWidgets(window); } return window; } // 0x004A147F Window* openAtRoad(const Window& main, RoadElement* road, const Pos2 pos) { auto* viewport = main.viewports[0]; _cState->backupTileElement = *reinterpret_cast<TileElement*>(road); auto* copyElement = (_cState->backupTileElement).as<RoadElement>(); if (copyElement == nullptr) { return nullptr; } removeConstructionGhosts(); auto* wnd = WindowManager::find(WindowType::construction); if (wnd == nullptr) { WindowManager::closeConstructionWindows(); Common::createConstructionWindow(); } else { Common::resetWindow(*wnd, Common::widx::tab_construction); } _cState->trackType = copyElement->roadObjectId() | (1 << 7); _cState->byte_1136063 = 0; Common::setTrackOptions(_cState->trackType); _cState->constructionHover = 0; _cState->byte_113607E = 1; _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; _cState->lastSelectedTrackModSection = Track::ModSection::single; Common::setNextAndPreviousRoadTile(*copyElement, pos); const bool isCloserToNext = Common::isPointCloserToNextOrPreviousTile(Input::getDragLastLocation(), *viewport); const auto chosenLoc = isCloserToNext ? _cState->nextTile : _cState->previousTile; const auto chosenRotation = isCloserToNext ? _cState->nextTileRotation : _cState->previousTileRotation; _cState->x = chosenLoc.x; _cState->y = chosenLoc.y; _cState->constructionZ = chosenLoc.z; _cState->constructionRotation = chosenRotation; _cState->lastSelectedTrackPiece = 0; _cState->lastSelectedTrackGradient = 0; _cState->lastSelectedSignal = 0xFF; const auto stationList = getAvailableCompatibleStations(_cState->trackType, TransportMode::road); Common::copyToLegacyList(stationList, _cState->stationList); auto lastStation = Scenario::getConstruction().roadStations[(_cState->trackType & ~(1ULL << 7))]; if (lastStation == 0xFF) { lastStation = _cState->stationList[0]; } _cState->lastSelectedStationType = lastStation; const auto bridgeList = getAvailableCompatibleBridges(_cState->trackType, TransportMode::road); Common::copyToLegacyList(bridgeList, _cState->bridgeList); auto lastBridge = Scenario::getConstruction().bridges[(_cState->trackType & ~(1ULL << 7))]; if (lastBridge == 0xFF) { lastBridge = _cState->bridgeList[0]; } _cState->lastSelectedBridge = lastBridge; if (copyElement->hasBridge()) { _cState->lastSelectedBridge = copyElement->bridge(); } const auto modList = getAvailableCompatibleMods(_cState->trackType, TransportMode::road, GameCommands::getUpdatingCompanyId()); std::copy(modList.begin(), modList.end(), std::begin(_cState->modList)); _cState->lastSelectedMods = 0; auto* roadObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1ULL << 7)); if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { _cState->lastSelectedMods = copyElement->mods(); } _cState->byte_113603A = 0; auto* window = WindowManager::find(WindowType::construction); if (window != nullptr) { Common::setDisabledWidgets(window); } return window; } // 0x004A3B0D Window* openWithFlags(const uint32_t flags) { auto mainWindow = WindowManager::getMainWindow(); if (mainWindow) { auto viewport = mainWindow->viewports[0]; _cState->viewportFlags = viewport->flags; } auto window = WindowManager::find(WindowType::construction); if (window != nullptr) { if (flags & (1 << 7)) { auto trackType = flags & ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(trackType); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { if (_cState->trackType & (1 << 7)) { trackType = _cState->trackType & ~(1 << 7); roadObj = ObjectManager::get<RoadObject>(trackType); if (roadObj->hasFlags(RoadObjectFlags::unk_03)) { _cState->trackType = static_cast<uint8_t>(flags); Common::sub_4A3A50(); _cState->lastSelectedTrackPiece = 0; _cState->lastSelectedTrackGradient = 0; return window; } } } } } WindowManager::closeConstructionWindows(); Common::sub_4CD454(); mainWindow = WindowManager::getMainWindow(); if (mainWindow) { auto viewport = mainWindow->viewports[0]; viewport->flags = _cState->viewportFlags; } _cState->trackType = static_cast<uint8_t>(flags); _cState->byte_1136063 = flags >> 24; _cState->x = 0x1800; _cState->y = 0x1800; _cState->constructionZ = 0x100; _cState->constructionRotation = 0; _cState->constructionHover = 0; _cState->byte_113607E = 1; _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; _cState->lastSelectedTrackPiece = 0; _cState->lastSelectedTrackGradient = 0; _cState->lastSelectedTrackModSection = Track::ModSection::single; Common::setTrackOptions(flags); if (flags & (1 << 31)) { return createAirportConstructionWindow(); } else if (flags & (1 << 30)) { return createDockConstructionWindow(); } else if (flags & (1 << 7)) { return createRoadConstructionWindow(); } return createTrackConstructionWindow(); } // 0x004A6E2B // Update available road and rail for player company void updateAvailableRoadAndRailOptions() { if (getGameState().lastRoadOption == 0xFF) { uint8_t lastRoadOption = getGameState().lastTrackTypeOption; if (lastRoadOption == 0xFF) { const auto availableObjects = companyGetAvailableRoads(CompanyManager::getControllingId()); if (!availableObjects.empty()) { lastRoadOption = availableObjects[0]; } } else { lastRoadOption |= 1 << 7; } getGameState().lastRoadOption = lastRoadOption; WindowManager::invalidate(Ui::WindowType::topToolbar, 0); } if (getGameState().lastRailroadOption == 0xFF) { const auto availableObjects = companyGetAvailableRailTracks(CompanyManager::getControllingId()); if (!availableObjects.empty()) { getGameState().lastRailroadOption = availableObjects[0]; } WindowManager::invalidate(Ui::WindowType::topToolbar, 0); } } // 0x004A6E9B // Update available airports and docks for player company void updateAvailableAirportAndDockOptions() { if (getGameState().lastAirport != 0xFF) { const auto* airportObj = ObjectManager::get<AirportObject>(getGameState().lastAirport); if (getGameState().currentYear > airportObj->obsoleteYear) { getGameState().lastAirport = 0xFF; } } if (getGameState().lastAirport == 0xFF) { const auto availableObjects = getAvailableAirports(); if (!availableObjects.empty()) { getGameState().lastAirport = availableObjects[0]; bool found = false; for (size_t vehicleObjectIndex = 0; vehicleObjectIndex < ObjectManager::getMaxObjects(ObjectType::vehicle); ++vehicleObjectIndex) { const auto* vehicleObject = ObjectManager::get<VehicleObject>(vehicleObjectIndex); if (vehicleObject == nullptr) { continue; } if (vehicleObject->mode == TransportMode::air) { const Company* company = CompanyManager::get(getGameState().playerCompanies[0]); if (company->unlockedVehicles.get(vehicleObjectIndex)) { found = true; break; } } } if (!found) { getGameState().lastAirport = 0xFF; } } } if (getGameState().lastShipPort == 0xFF) { const auto availableObjects = getAvailableDocks(); if (!availableObjects.empty()) { getGameState().lastShipPort = availableObjects[0]; bool found = false; for (size_t vehicleObjectIndex = 0; vehicleObjectIndex < ObjectManager::getMaxObjects(ObjectType::vehicle); ++vehicleObjectIndex) { const auto* vehicleObject = ObjectManager::get<VehicleObject>(vehicleObjectIndex); if (vehicleObject == nullptr) { continue; } if (vehicleObject->mode == TransportMode::water) { const Company* company = CompanyManager::get(getGameState().playerCompanies[0]); if (company->unlockedVehicles.get(vehicleObjectIndex)) { found = true; break; } } } if (!found) { getGameState().lastShipPort = 0xFF; } } } WindowManager::invalidate(Ui::WindowType::topToolbar, 0); } // 0x004A6FAC void sub_4A6FAC() { auto window = WindowManager::find(WindowType::construction); if (window == nullptr) { return; } if (window->currentTab == Common::widx::tab_station - Common::widx::tab_construction) { if (_cState->byte_1136063 & ((1 << 7) | (1 << 6))) { WindowManager::close(window); } else { window->callOnMouseUp(Common::widx::tab_construction, window->widgets[Common::widx::tab_construction].id); } } } // 0x004A6A0C bool isStationTabOpen() { auto* window = WindowManager::find(WindowType::construction); if (window == nullptr) { return false; } return window->currentTab == Common::widx::tab_station - Common::widx::tab_construction; } // 0x004A69EE bool isOverheadTabOpen() { auto* window = WindowManager::find(WindowType::construction); if (window == nullptr) { return false; } return window->currentTab == Common::widx::tab_overhead - Common::widx::tab_construction; } // 0x004A6A2A bool isSignalTabOpen() { auto* window = WindowManager::find(WindowType::construction); if (window == nullptr) { return false; } return window->currentTab == Common::widx::tab_signal - Common::widx::tab_construction; } // 0x0049FEC7 void removeConstructionGhosts() { if ((_ghostVisibilityFlags & GhostVisibilityFlags::constructArrow) != GhostVisibilityFlags::none) { World::TileManager::mapInvalidateTileFull(World::Pos2(_cState->x, _cState->y)); World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstructionArrow); _ghostVisibilityFlags = _ghostVisibilityFlags & ~GhostVisibilityFlags::constructArrow; } Construction::removeTrackGhosts(); Signal::removeSignalGhost(); Station::removeStationGhost(); Overhead::removeTrackModsGhost(); } uint16_t getLastSelectedMods() { return _cState->lastSelectedMods; } Track::ModSection getLastSelectedTrackModSection() { if (WindowManager::find(WindowType::construction) != nullptr) { return _cState->lastSelectedTrackModSection; } else { return Track::ModSection::single; } } namespace Common { struct TabInformation { std::span<const Widget> widgets; const widx widgetIndex; const WindowEventList& events; void (*tabReset)(Window&); }; // clang-format off static TabInformation tabInformationByTabOffset[] = { { Construction::getWidgets(), widx::tab_construction, Construction::getEvents(), &Construction::tabReset }, { Station::getWidgets(), widx::tab_station, Station::getEvents(), &Station::tabReset }, { Signal::getWidgets(), widx::tab_signal, Signal::getEvents(), &Signal::tabReset }, { Overhead::getWidgets(), widx::tab_overhead, Overhead::getEvents(), &Overhead::tabReset }, }; // clang-format on void prepareDraw(Window* self) { // Activate the current tab self->activatedWidgets &= ~((1ULL << tab_construction) | (1ULL << tab_overhead) | (1ULL << tab_signal) | (1ULL << tab_station)); self->activatedWidgets |= (1ULL << Common::tabInformationByTabOffset[self->currentTab].widgetIndex); } // 0x004A0EF4 void resetWindow(Window& self, WidgetIndex_t tabWidgetIndex) { self.currentTab = tabWidgetIndex - widx::tab_construction; const auto& tabInfo = tabInformationByTabOffset[tabWidgetIndex - widx::tab_construction]; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); setDisabledWidgets(&self); self.width = self.widgets[widx::frame].right + 1; self.height = self.widgets[widx::frame].bottom + 1; } void setNextAndPreviousTrackTile(const TrackElement& elTrack, const World::Pos2& pos) { const auto& piece = TrackData::getTrackPiece(elTrack.trackId())[elTrack.sequenceIndex()]; const auto firstTileOffset = Math::Vector::rotate(World::Pos2(piece.x, piece.y), elTrack.rotation()); const auto firstTile = World::Pos3(pos.x, pos.y, elTrack.baseHeight()) - World::Pos3(firstTileOffset.x, firstTileOffset.y, piece.z); // Get coordinates of the next tile after the end of the track piece const auto trackAndDirection = (elTrack.trackId() << 3) | elTrack.rotation(); const auto& trackSize = TrackData::getUnkTrack(trackAndDirection); const auto nextTile = firstTile + trackSize.pos; _cState->nextTile = nextTile; _cState->nextTileRotation = trackSize.rotationEnd; // Get coordinates of the previous tile before the start of the track piece const auto unk = World::kReverseRotation[trackSize.rotationBegin]; auto previousTile = firstTile; _cState->previousTileRotation = unk; if (unk < 12) { previousTile += World::Pos3{ World::kRotationOffset[unk], 0 }; } _cState->previousTile = previousTile; } void setNextAndPreviousRoadTile(const RoadElement& elRoad, const World::Pos2& pos) { const auto& piece = TrackData::getRoadPiece(elRoad.roadId())[elRoad.sequenceIndex()]; const auto firstTileOffset = Math::Vector::rotate(World::Pos2(piece.x, piece.y), elRoad.rotation()); const auto firstTile = World::Pos3(pos.x, pos.y, elRoad.baseHeight()) - World::Pos3(firstTileOffset.x, firstTileOffset.y, piece.z); // Get coordinates of the next tile after the end of the track piece const auto trackAndDirection = (elRoad.roadId() << 3) | elRoad.rotation(); const auto& trackSize = TrackData::getUnkRoad(trackAndDirection); const auto nextTile = firstTile + trackSize.pos; _cState->nextTile = nextTile; _cState->nextTileRotation = trackSize.rotationEnd; // Get coordinates of the previous tile before the start of the track piece const auto unk = World::kReverseRotation[trackSize.rotationBegin]; auto previousTile = firstTile; _cState->previousTileRotation = unk; if (unk < 12) { previousTile += World::Pos3{ World::kRotationOffset[unk], 0 }; } _cState->previousTile = previousTile; } // True for next, false for previous bool isPointCloserToNextOrPreviousTile(const Point& point, const Viewport& viewport) { const auto vpPosNext = gameToScreen(_cState->nextTile + World::Pos3(16, 16, 0), viewport.getRotation()); const auto uiPosNext = viewport.viewportToScreen(vpPosNext); const auto distanceToNext = Math::Vector::manhattanDistance2D(uiPosNext, point); const auto vpPosPrevious = gameToScreen(_cState->previousTile + World::Pos3(16, 16, 0), viewport.getRotation()); const auto uiPosPrevious = viewport.viewportToScreen(vpPosPrevious); const auto distanceToPrevious = Math::Vector::manhattanDistance2D(uiPosPrevious, point); return distanceToNext < distanceToPrevious; } // 0x0049D93A void switchTab(Window& self, WidgetIndex_t widgetIndex) { if (self.currentTab == widgetIndex - widx::tab_construction) { return; } if (widgetIndex == widx::tab_station) { Ui::Windows::Station::showStationCatchment(StationId::null); } if (widgetIndex == widx::tab_construction) { Construction::activateSelectedConstructionWidgets(); } removeConstructionGhosts(); World::mapInvalidateMapSelectionFreeFormTiles(); World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstruct); _cState->trackCost = 0x80000000; _cState->signalCost = 0x80000000; _cState->stationCost = 0x80000000; _cState->modCost = 0x80000000; _cState->byte_1136076 = 0; if (ToolManager::isToolActive(self.type, self.number)) { ToolManager::toolCancel(); } self.currentTab = widgetIndex - widx::tab_construction; self.frameNo = 0; self.flags &= ~(WindowFlags::flag_16); auto tabInfo = tabInformationByTabOffset[widgetIndex - widx::tab_construction]; self.eventHandlers = &tabInfo.events; self.activatedWidgets = 0; self.setWidgets(tabInfo.widgets); self.holdableWidgets = 0; setDisabledWidgets(&self); self.invalidate(); self.width = self.widgets[widx::frame].right + 1; self.height = self.widgets[widx::frame].bottom + 1; self.callOnResize(); self.callPrepareDraw(); self.initScrollWidgets(); self.invalidate(); tabInfo.tabReset(self); self.moveInsideScreenEdges(); } // 0x0049EFEF static void drawRoadTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto company = CompanyManager::getPlayerCompany(); auto companyColour = company->mainColours.primary; auto roadObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1 << 7)); // Construction Tab { auto imageId = roadObj->image; if (self.currentTab == widx::tab_construction - widx::tab_construction) { imageId += (self.frameNo / 4) % 32; } Widget::drawTab(self, drawingCtx, Gfx::recolour(imageId, companyColour), widx::tab_construction); } // Station Tab { Widget::drawTab(self, drawingCtx, ImageIds::null, widx::tab_station); if (!self.isDisabled(widx::tab_station)) { auto x = self.widgets[widx::tab_station].left + self.x + 1; auto y = self.widgets[widx::tab_station].top + self.y + 1; auto width = 29; auto height = 25; if (self.currentTab == widx::tab_station - widx::tab_construction) { height++; } const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (clipped) { clipped->zoomLevel = 1; clipped->width <<= 1; clipped->height <<= 1; clipped->x <<= 1; clipped->y <<= 1; drawingCtx.pushRenderTarget(*clipped); auto roadStationObj = ObjectManager::get<RoadStationObject>(_cState->lastSelectedStationType); auto imageId = Gfx::recolour(roadStationObj->image, companyColour); drawingCtx.drawImage(-4, -10, imageId); auto colour = Colours::getTranslucent(companyColour); if (!roadStationObj->hasFlags(RoadStationFlags::recolourable)) { colour = ExtColour::unk2E; } imageId = Gfx::recolourTranslucent(roadStationObj->image, colour) + 1; drawingCtx.drawImage(-4, -10, imageId); drawingCtx.popRenderTarget(); } Widget::drawTab(self, drawingCtx, Widget::kContentUnk, widx::tab_station); } } // Overhead tab { Widget::drawTab(self, drawingCtx, ImageIds::null, widx::tab_overhead); if (!self.isDisabled(widx::tab_overhead)) { auto x = self.widgets[widx::tab_overhead].left + self.x + 2; auto y = self.widgets[widx::tab_overhead].top + self.y + 2; for (auto i = 0; i < 2; i++) { if (_cState->modList[i] != 0xFF) { auto roadExtraObj = ObjectManager::get<RoadExtraObject>(_cState->modList[i]); auto imageId = roadExtraObj->var_0E; if (self.currentTab == widx::tab_overhead - widx::tab_construction) { imageId += (self.frameNo / 2) % 8; } drawingCtx.drawImage(x, y, imageId); } } Widget::drawTab(self, drawingCtx, Widget::kContentUnk, widx::tab_overhead); } } } std::array<uint32_t, 16> kTrackPreviewImages = { TrackObj::ImageIds::kUiPreviewImage0, TrackObj::ImageIds::kUiPreviewImage1, TrackObj::ImageIds::kUiPreviewImage2, TrackObj::ImageIds::kUiPreviewImage3, TrackObj::ImageIds::kUiPreviewImage4, TrackObj::ImageIds::kUiPreviewImage5, TrackObj::ImageIds::kUiPreviewImage6, TrackObj::ImageIds::kUiPreviewImage7, TrackObj::ImageIds::kUiPreviewImage8, TrackObj::ImageIds::kUiPreviewImage9, TrackObj::ImageIds::kUiPreviewImage10, TrackObj::ImageIds::kUiPreviewImage11, TrackObj::ImageIds::kUiPreviewImage12, TrackObj::ImageIds::kUiPreviewImage13, TrackObj::ImageIds::kUiPreviewImage14, TrackObj::ImageIds::kUiPreviewImage15, }; // 0x0049ED40 static void drawTrackTabs(Window& self, Gfx::DrawingContext& drawingCtx) { auto company = CompanyManager::getPlayerCompany(); auto companyColour = company->mainColours.primary; auto trackObj = ObjectManager::get<TrackObject>(_cState->trackType); // Construction Tab { auto imageId = trackObj->image; if (self.currentTab == widx::tab_construction - widx::tab_construction) { imageId += kTrackPreviewImages[(self.frameNo / 4) % kTrackPreviewImages.size()]; } Widget::drawTab(self, drawingCtx, Gfx::recolour(imageId, companyColour), widx::tab_construction); } // Station Tab { if (_cState->byte_1136063 & (1 << 7)) { auto imageId = ObjectManager::get<InterfaceSkinObject>()->img + InterfaceSkin::ImageIds::toolbar_menu_airport; Widget::drawTab(self, drawingCtx, imageId, widx::tab_station); } else { if (_cState->byte_1136063 & (1 << 6)) { auto imageId = ObjectManager::get<InterfaceSkinObject>()->img + InterfaceSkin::ImageIds::toolbar_menu_ship_port; Widget::drawTab(self, drawingCtx, imageId, widx::tab_station); } else { Widget::drawTab(self, drawingCtx, ImageIds::null, widx::tab_station); if (!self.isDisabled(widx::tab_station)) { auto x = self.widgets[widx::tab_station].left + self.x + 1; auto y = self.widgets[widx::tab_station].top + self.y + 1; auto width = 29; auto height = 25; if (self.currentTab == widx::tab_station - widx::tab_construction) { height++; } const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (clipped) { clipped->zoomLevel = 1; clipped->width *= 2; clipped->height *= 2; clipped->x *= 2; clipped->y *= 2; drawingCtx.pushRenderTarget(*clipped); auto trainStationObj = ObjectManager::get<TrainStationObject>(_cState->lastSelectedStationType); auto imageId = Gfx::recolour(trainStationObj->image + TrainStation::ImageIds::preview_image, companyColour); drawingCtx.drawImage(-4, -9, imageId); auto colour = Colours::getTranslucent(companyColour); if (!trainStationObj->hasFlags(TrainStationFlags::recolourable)) { colour = ExtColour::unk2E; } imageId = Gfx::recolourTranslucent(trainStationObj->image + TrainStation::ImageIds::preview_image_windows, colour); drawingCtx.drawImage(-4, -9, imageId); drawingCtx.popRenderTarget(); } Widget::drawTab(self, drawingCtx, Widget::kContentUnk, widx::tab_station); } } } } // Signal Tab { Widget::drawTab(self, drawingCtx, ImageIds::null, widx::tab_signal); if (!self.isDisabled(widx::tab_signal)) { auto x = self.widgets[widx::tab_signal].left + self.x + 1; auto y = self.widgets[widx::tab_signal].top + self.y + 1; auto width = 29; auto height = 25; if (self.currentTab == widx::tab_station - widx::tab_construction) { height++; } const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); auto trainSignalObject = ObjectManager::get<TrainSignalObject>(_cState->lastSelectedSignal); auto imageId = trainSignalObject->image; if (self.currentTab == widx::tab_signal - widx::tab_construction) { auto frames = signalFrames[(((trainSignalObject->numFrames + 2) / 3) - 2)]; auto frameCount = std::size(frames) - 1; frameCount &= (self.frameNo >> trainSignalObject->animationSpeed); auto frameIndex = frames[frameCount]; frameIndex <<= 3; imageId += frameIndex; } drawingCtx.drawImage(15, 31, imageId); drawingCtx.popRenderTarget(); } Widget::drawTab(self, drawingCtx, Widget::kContentUnk, widx::tab_signal); } } // Overhead Tab { Widget::drawTab(self, drawingCtx, ImageIds::null, widx::tab_overhead); if (!self.isDisabled(widx::tab_overhead)) { auto x = self.widgets[widx::tab_overhead].left + self.x + 2; auto y = self.widgets[widx::tab_overhead].top + self.y + 2; for (auto i = 0; i < 4; i++) { if (_cState->modList[i] != 0xFF) { auto trackExtraObj = ObjectManager::get<TrackExtraObject>(_cState->modList[i]); auto imageId = trackExtraObj->var_0E; if (self.currentTab == widx::tab_overhead - widx::tab_construction) { imageId += (self.frameNo / 2) % 8; } drawingCtx.drawImage(x, y, imageId); } } Widget::drawTab(self, drawingCtx, Widget::kContentUnk, widx::tab_overhead); } } } // 0x0049ED33 void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx) { if (_cState->trackType & (1 << 7)) { drawRoadTabs(self, drawingCtx); } else { drawTrackTabs(self, drawingCtx); } } // 0x004A09DE void repositionTabs(Window* self) { int16_t xPos = self->widgets[widx::tab_construction].left; const int16_t tabWidth = self->widgets[widx::tab_construction].right - xPos; for (uint8_t i = widx::tab_construction; i <= widx::tab_overhead; i++) { if (self->isDisabled(i)) { self->widgets[i].hidden = true; continue; } self->widgets[i].hidden = false; self->widgets[i].left = xPos; self->widgets[i].right = xPos + tabWidth; xPos = self->widgets[i].right + 1; } } // 0x0049DD14 void onClose([[maybe_unused]] Window& self) { removeConstructionGhosts(); WindowManager::viewportSetVisibility(WindowManager::ViewportVisibility::reset); World::mapInvalidateMapSelectionFreeFormTiles(); World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstruct); World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstructionArrow); Windows::Main::hideDirectionArrows(); Windows::Main::hideGridlines(); } // 0x0049E437, 0x0049E76F, 0x0049ECD1 void onUpdate(Window* self, GhostVisibilityFlags flag) { self->frameNo++; self->callPrepareDraw(); WindowManager::invalidateWidget(WindowType::construction, self->number, self->currentTab + Common::widx::tab_construction); if (ToolManager::isToolActive(WindowType::construction, self->number)) { return; } if ((_ghostVisibilityFlags & flag) == GhostVisibilityFlags::none) { return; } removeConstructionGhosts(); } // 0x004CD454 void sub_4CD454() { if (SceneManager::isNetworkHost()) { auto window = WindowManager::find(ToolManager::getToolWindowType(), ToolManager::getToolWindowNumber()); if (window != nullptr) { ToolManager::toolCancel(); } } } // 0x004A3A06 void setTrackOptions(const uint8_t trackType) { auto newTrackType = trackType; if (trackType & (1 << 7)) { newTrackType &= ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(newTrackType); if (!roadObj->hasFlags(RoadObjectFlags::unk_01)) { getGameState().lastRoadOption = trackType; } else { getGameState().lastRailroadOption = trackType; } } else { auto trackObj = ObjectManager::get<TrackObject>(newTrackType); if (!trackObj->hasFlags(TrackObjectFlags::unk_02)) { getGameState().lastRailroadOption = trackType; } else { getGameState().lastRoadOption = trackType; } } WindowManager::invalidate(WindowType::topToolbar, 0); } // 0x0049CE33 void setDisabledWidgets(Window* self) { auto disabledWidgets = 0; if (SceneManager::isEditorMode()) { disabledWidgets |= (1ULL << Common::widx::tab_station); } if (_cState->byte_1136063 & (1 << 7 | 1 << 6)) { disabledWidgets |= (1ULL << Common::widx::tab_construction); } if (_cState->lastSelectedSignal == 0xFF) { disabledWidgets |= (1ULL << Common::widx::tab_signal); } if (_cState->modList[0] == 0xFF && _cState->modList[1] == 0xFF && _cState->modList[2] == 0xFF && _cState->modList[3] == 0xFF) { disabledWidgets |= (1ULL << Common::widx::tab_overhead); } if (_cState->lastSelectedStationType == 0xFF) { disabledWidgets |= (1ULL << Common::widx::tab_station); } self->disabledWidgets = disabledWidgets; } // 0x004A0963 void createConstructionWindow() { auto window = WindowManager::createWindow( WindowType::construction, Construction::kWindowSize, WindowFlags::flag_11 | WindowFlags::noAutoClose, Construction::getEvents()); window->setWidgets(Construction::getWidgets()); window->currentTab = 0; window->activatedWidgets = 0; setDisabledWidgets(window); window->initScrollWidgets(); window->owner = CompanyManager::getControllingId(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::secondary, skin->windowConstructionColour); WindowManager::moveOtherWindowsDown(*window); Windows::Main::showDirectionArrows(); Windows::Main::showGridlines(); } // 0x004A3A50 void sub_4A3A50() { removeConstructionGhosts(); setTrackOptions(_cState->trackType); const auto stationList = getAvailableCompatibleStations(_cState->trackType, TransportMode::road); copyToLegacyList(stationList, _cState->stationList); auto lastStation = Scenario::getConstruction().roadStations[(_cState->trackType & ~(1ULL << 7))]; if (lastStation == 0xFF) { lastStation = _cState->stationList[0]; } _cState->lastSelectedStationType = lastStation; const auto bridgeList = getAvailableCompatibleBridges(_cState->trackType, TransportMode::road); copyToLegacyList(bridgeList, _cState->bridgeList); auto lastBridge = Scenario::getConstruction().bridges[(_cState->trackType & ~(1ULL << 7))]; if (lastBridge == 0xFF) { lastBridge = _cState->bridgeList[0]; } _cState->lastSelectedBridge = lastBridge; const auto modList = getAvailableCompatibleMods(_cState->trackType, TransportMode::road, GameCommands::getUpdatingCompanyId()); std::copy(modList.begin(), modList.end(), std::begin(_cState->modList)); auto lastMod = Scenario::getConstruction().roadMods[(_cState->trackType & ~(1ULL << 7))]; if (lastMod == 0xFF) { lastMod = 0; } _cState->lastSelectedMods = lastMod; auto window = WindowManager::find(WindowType::construction); if (window != nullptr) { setDisabledWidgets(window); } Construction::activateSelectedConstructionWidgets(); } void previousTab(Window* self) { WidgetIndex_t prev = self->prevAvailableWidgetInRange(widx::tab_construction, widx::tab_overhead); if (prev != -1) { self->callOnMouseUp(prev, self->widgets[prev].id); } } void nextTab(Window* self) { WidgetIndex_t next = self->nextAvailableWidgetInRange(widx::tab_construction, widx::tab_overhead); if (next != -1) { self->callOnMouseUp(next, self->widgets[next].id); } } } bool rotate(Window& self) { switch (self.currentTab) { case Common::widx::tab_construction - Common::widx::tab_construction: if (_cState->constructionHover == 1) { self.callOnMouseUp(Construction::widx::rotate_90, self.widgets[Construction::widx::rotate_90].id); removeConstructionGhosts(); return true; } break; case Common::widx::tab_station - Common::widx::tab_construction: if (!self.widgets[Station::widx::rotate].hidden) { self.callOnMouseUp(Station::widx::rotate, self.widgets[Station::widx::rotate].id); return true; } break; } return false; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Construction/Construction.h ```h #pragma once #include "GameCommands/Track/CreateTrackMod.h" #include "Map/TileManager.h" #include "Map/Track/TrackModSection.h" #include "Objects/VehicleObject.h" #include "ScenarioConstruction.h" #include "Ui/Widgets/CaptionWidget.h" #include "Ui/Widgets/FrameWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/TabWidget.h" #include "Ui/WindowManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <sfl/static_vector.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::TileManager; namespace OpenLoco::Ui::Windows::Construction { enum class GhostVisibilityFlags : uint8_t { none = 0U, constructArrow = 1U << 0, track = 1U << 1, signal = 1U << 2, station = 1U << 3, overhead = 1U << 4, }; OPENLOCO_ENABLE_ENUM_OPERATORS(GhostVisibilityFlags); static loco_global<uint8_t, 0x00522093> _ghostRemovalTrackObjectId; static loco_global<uint8_t, 0x00522095> _byte_522095; static loco_global<GhostVisibilityFlags, 0x00522096> _ghostVisibilityFlags; #pragma pack(push, 1) struct ConstructionState { uint32_t trackCost; // 0x01135F3E uint32_t dword_1135F42; // 0x01135F42 uint32_t modCost; // 0x01135F46 uint32_t pad_1135F4A; // 0x01135F4A uint32_t signalCost; // 0x01135F4E uint8_t pad_1135F52[26]; // 0x01135F52 uint32_t stationCost; // 0x01135F6C uint32_t constructingStationId; // 0x01135F70 uint32_t constructingStationAcceptedCargoTypes; // 0x01135F74 uint32_t constructingStationProducedCargoTypes; // 0x01135F78 uint8_t pad_1135F7C[10]; // 0x01135F7C ViewportFlags viewportFlags; // 0x01135F86 uint8_t pad_1135F88[44]; // 0x01135F88 uint16_t x; // 0x01135FB4 uint16_t y; // 0x01135FB6 uint16_t constructionZ; // 0x01135FB8 World::Pos3 ghostTrackPos; // 0x01135FBA World::Pos3 ghostRemovalTrackPos; // 0x01135FC0 World::Pos3 nextTile; // 0x01135FC6 uint16_t nextTileRotation; // 0x01135FCC World::Pos3 previousTile; // 0x01135FCE uint16_t previousTileRotation; // 0x01135FD4 uint16_t word_1135FD6; // 0x01135FD6 uint16_t word_1135FD8; // 0x01135FD8 uint8_t pad_1135FDA[10]; // 0x01135FDA uint16_t lastSelectedMods; // 0x01135FE4 World::Pos3 stationGhostPos; // 0x01135FE6 uint8_t pad_1135FEC[2]; // 0x01135FEC uint16_t stationGhostType; // 0x01135FEE uint8_t pad_1135FF0[8]; // 0x01135FF0 World::Pos3 modGhostPos; // 0x01135FF8 uint16_t word_1135FFE; // 0x01135FFE int16_t word_1136000; // 0x01136000 uint16_t signalGhostSides; // 0x01136002 World::Pos3 signalGhostPos; // 0x01136004 uint16_t signalGhostTrackObjId; // 0x0113600A uint8_t pad_113600C[4]; // 0x0113600C uint8_t modGhostTrackObjId; // 0x01136010 uint8_t pad_11360011[12]; // 0x01136011 uint8_t signalList[17]; // 0x0113601D uint8_t lastSelectedSignal; // 0x0113602E uint8_t isSignalBothDirections; // 0x0113602F uint8_t bridgeList[9]; // 0x01136030 uint8_t lastSelectedBridge; // 0x01136039 uint8_t byte_113603A; // 0x0113603A uint8_t stationList[17]; // 0x0113603B uint8_t lastSelectedStationType; // 0x0113604C uint8_t signalGhostRotation; // 0x0113604D uint8_t signalGhostTrackId; // 0x0113604E uint8_t signalGhostTileIndex; // 0x0113604F uint8_t pad_1136050[4]; // 0x01136050 uint8_t modList[4]; // 0x01136054 uint8_t modGhostRotation; // 0x01136058 uint8_t modGhostTrackId; // 0x01136059 uint8_t modGhostTileIndex; // 0x0113605A uint8_t pad_113605B[2]; // 0x0113605B uint8_t makeJunction; // 0x0113605D uint8_t pad_113605E[3]; // 0x0113605E uint8_t constructionHover; // 0x01136061 uint8_t trackType; // 0x01136062 uint8_t byte_1136063; // 0x01136063 uint8_t constructionRotation; // 0x01136064 uint8_t byte_1136065; // 0x01136065 uint8_t constructionArrowFrameNum; // 0x01136066 uint8_t lastSelectedTrackPiece; // 0x01136067 uint8_t lastSelectedTrackGradient; // 0x01136068 uint8_t ghostRemovalTrackRotation; // 0x01136069 uint8_t ghostRemovalTrackId; // 0x0113606A uint8_t stationGhostRotation; // 0x0113606B uint8_t stationGhostTrackId; // 0x0113606C uint8_t stationGhostTileIndex; // 0x0113606D Track::ModSection lastSelectedTrackModSection; // 0x0113606E uint8_t pad_113606F[3]; // 0x0113606F uint8_t byte_1136072; // 0x01136072 uint8_t byte_1136073; // 0x01136073 uint8_t pad_1136074; // 0x01136074 uint8_t byte_1136075; // 0x01136075 uint8_t byte_1136076; // 0x01136076 uint8_t byte_1136077; // 0x01136077 uint8_t byte_1136078; // 0x01136078 uint8_t lastSelectedTrackPieceId; // 0x01136079 uint8_t pad_113607A[4]; // 0x0113607A uint8_t byte_113607E; // 0x0113607E uint8_t pad_113607F[10]; // 0x0113607F uint8_t stationGhostTypeDockAirport; // 0x01136089 uint8_t pad_113608A[6]; // 0x0113608A World::TileElement backupTileElement; // 0x01136090 }; #pragma pack(pop) static_assert(sizeof(ConstructionState) == 0x01136090 + 8 - 0x01135F3E); static loco_global<ConstructionState, 0x01135F3E> _cState; namespace Common { enum widx { frame, caption, close_button, panel, tab_construction, tab_station, tab_signal, tab_overhead, }; constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight, StringId windowCaptionId) { return makeWidgets( Widgets::Frame({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::Caption({ 1, 1 }, { frameWidth - 2, 13 }, Widgets::Caption::Style::colourText, WindowColour::primary, windowCaptionId), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Panel({ 0, 41 }, { frameWidth, frameHeight - 41 }, WindowColour::secondary), Widgets::Tab({ 3, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_track_road_construction), Widgets::Tab({ 34, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_station_construction), Widgets::Tab({ 65, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_signal_construction), Widgets::Tab({ 96, 15 }, { 31, 27 }, WindowColour::secondary, ImageIds::tab, StringIds::tab_electrification_construction)); } void prepareDraw(Window* self); void resetWindow(Window& self, WidgetIndex_t tabWidgetIndex); void switchTab(Window& self, WidgetIndex_t widgetIndex); void repositionTabs(Window* self); void drawTabs(Window& self, Gfx::DrawingContext& drawingCtx); void onClose(Window& self); void onUpdate(Window* self, GhostVisibilityFlags flag); void sub_4CD454(); void setTrackOptions(const uint8_t trackType); void setDisabledWidgets(Window* self); void createConstructionWindow(); void sub_4A3A50(); void setNextAndPreviousTrackTile(const TrackElement& elTrack, const World::Pos2& pos); void setNextAndPreviousRoadTile(const RoadElement& elRoad, const World::Pos2& pos); bool isPointCloserToNextOrPreviousTile(const Point& point, const Viewport& viewport); void previousTab(Window* self); void nextTab(Window* self); template<size_t NewCapacity, size_t LegacyCapacity> void copyToLegacyList(const sfl::static_vector<uint8_t, NewCapacity>& sflType, uint8_t (&legacyList)[LegacyCapacity]) { static_assert(LegacyCapacity > NewCapacity); std::copy(sflType.begin(), sflType.end(), legacyList); legacyList[sflType.size()] = 0xFFU; } } namespace Construction { static constexpr Ui::Size32 kWindowSize = { 138, 276 }; enum widx { left_hand_curve_very_small = 8, left_hand_curve_small, left_hand_curve, left_hand_curve_large, right_hand_curve_large, right_hand_curve, right_hand_curve_small, right_hand_curve_very_small, s_bend_dual_track_left, s_bend_left, straight, s_bend_right, s_bend_dual_track_right, steep_slope_down, slope_down, level, slope_up, steep_slope_up, bridge, bridge_dropdown, construct, remove, rotate_90, }; // clang-format off constexpr uint64_t allTrack = { (1ULL << widx::left_hand_curve_very_small) | (1ULL << widx::left_hand_curve_small) | (1ULL << widx::left_hand_curve) | (1ULL << widx::left_hand_curve_large) | (1ULL << widx::right_hand_curve_large) | (1ULL << widx::right_hand_curve) | (1ULL << widx::right_hand_curve_small) | (1ULL << widx::right_hand_curve_very_small ) | (1ULL << widx::s_bend_dual_track_left) | (1ULL << widx::s_bend_left) | (1ULL << widx::straight) | (1ULL << widx::s_bend_right) | (1ULL << widx::s_bend_dual_track_right) | (1ULL << widx::steep_slope_down) | (1ULL << widx::slope_down) | (1ULL << widx::level) | (1ULL << widx::slope_up) | (1ULL << widx::steep_slope_up) }; constexpr uint64_t allConstruction = { allTrack | (1ULL << widx::bridge) | (1ULL << widx::bridge_dropdown) | (1ULL << widx::construct) | (1ULL << widx::remove) | (1ULL << widx::rotate_90) }; //clang-format on std::span<const Widget> getWidgets(); void reset(); void activateSelectedConstructionWidgets(); void tabReset(Window& self); void drawTrack(const World::Pos3& pos, uint16_t selectedMods, uint8_t trackType, uint8_t trackPieceId, uint8_t rotation, Gfx::DrawingContext& drawingCtx); void drawRoad(const World::Pos3& pos, uint16_t selectedMods, uint8_t trackType, uint8_t trackPieceId, uint8_t rotation, Gfx::DrawingContext& drawingCtx); void removeTrackGhosts(); void previousTrackPiece(Window& self); void nextTrackPiece(Window& self); void previousSlope(Window& self); void nextSlope(Window& self); void buildAtCurrentPos(Window& self); void removeAtCurrentPos(Window& self); void selectPosition(Window& self); const WindowEventList& getEvents(); } namespace Station { enum widx { station = 8, station_dropdown, image, rotate, }; std::span<const Widget> getWidgets(); void tabReset(Window& self); void removeStationGhost(); const WindowEventList& getEvents(); void sub_49E1F1(StationId id); } namespace Signal { enum widx { signal = 8, signal_dropdown, both_directions, single_direction, }; std::span<const Widget> getWidgets(); void tabReset(Window& self); void removeSignalGhost(); const WindowEventList& getEvents(); } namespace Overhead { enum widx { checkbox_1 = 8, checkbox_2, checkbox_3, checkbox_4, image, track, track_dropdown, }; std::span<const Widget> getWidgets(); void tabReset(Window& self); void removeTrackModsGhost(); const WindowEventList& getEvents(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Construction/ConstructionTab.cpp ```cpp #include "Audio/Audio.h" #include "Construction.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/CreateRoad.h" #include "GameCommands/Road/RemoveRoad.h" #include "GameCommands/Track/CreateTrack.h" #include "GameCommands/Track/RemoveTrack.h" #include "GameState.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/SurfaceElement.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/BridgeObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Paint/Paint.h" #include "Paint/PaintTile.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/ToolTip.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "World/CompanyManager.h" #include "World/Station.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::TileManager; using namespace OpenLoco::Literals; namespace OpenLoco::Ui::Windows::Construction::Construction { static loco_global<uint8_t, 0x00508F09> _suppressErrorSound; static loco_global<World::Pos3, 0x00F24942> _constructionArrowPos; static loco_global<uint8_t, 0x00F24948> _constructionArrowDirection; static loco_global<uint8_t, 0x0112C2E9> _alternateTrackObjectId; // set from GameCommands::createRoad static loco_global<uint8_t[18], 0x0050A006> _availableObjects; // top toolbar // TODO: move to ConstructionState when no longer a loco_global? static bool _isDragging = false; static World::TilePos2 _toolPosDrag; static World::TilePos2 _toolPosInitial; namespace TrackPiece { enum { straight, left_hand_curve_very_small, right_hand_curve_very_small, left_hand_curve_small, right_hand_curve_small, left_hand_curve, right_hand_curve, left_hand_curve_large, right_hand_curve_large, s_bend_left, s_bend_right, s_bend_to_dual_track, s_bend_to_single_track, turnaround, }; } namespace TrackGradient { enum { level = 0, slope_up = 2, steep_slope_up = 4, slope_down = 6, steep_slope_down = 8, }; }; struct TrackPieceId { uint8_t id; uint8_t rotation; }; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(138, 276, StringIds::stringid_2), Widgets::ImageButton({ 3, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_left_hand_curve_very_small, StringIds::tooltip_left_hand_curve_very_small), Widgets::ImageButton({ 3, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_left_hand_curve_small, StringIds::tooltip_left_hand_curve_small), Widgets::ImageButton({ 25, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_left_hand_curve, StringIds::tooltip_left_hand_curve), Widgets::ImageButton({ 47, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_left_hand_curve_large, StringIds::tooltip_left_hand_curve_large), Widgets::ImageButton({ 69, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_right_hand_curve_large, StringIds::tooltip_right_hand_curve_large), Widgets::ImageButton({ 91, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_right_hand_curve, StringIds::tooltip_right_hand_curve), Widgets::ImageButton({ 113, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_right_hand_curve_small, StringIds::tooltip_right_hand_curve_small), Widgets::ImageButton({ 113, 45 }, { 22, 24 }, WindowColour::secondary, ImageIds::construction_right_hand_curve_very_small, StringIds::tooltip_right_hand_curve_very_small), Widgets::ImageButton({ 9, 69 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_s_bend_dual_track_left, StringIds::tooltip_s_bend_left_dual_track), Widgets::ImageButton({ 33, 69 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_s_bend_left, StringIds::tooltip_s_bend_left), Widgets::ImageButton({ 57, 69 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_straight, StringIds::tooltip_straight), Widgets::ImageButton({ 81, 69 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_s_bend_right, StringIds::tooltip_s_bend_right), Widgets::ImageButton({ 105, 69 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_s_bend_dual_track_right, StringIds::tooltip_s_bend_right_dual_track), Widgets::ImageButton({ 9, 96 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_steep_slope_down, StringIds::tooltip_steep_slope_down), Widgets::ImageButton({ 33, 96 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_slope_down, StringIds::tooltip_slope_down), Widgets::ImageButton({ 57, 96 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_level, StringIds::tooltip_level), Widgets::ImageButton({ 81, 96 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_slope_up, StringIds::tooltip_slope_up), Widgets::ImageButton({ 105, 96 }, { 24, 24 }, WindowColour::secondary, ImageIds::construction_steep_slope_up, StringIds::tooltip_steep_slope_up), Widgets::dropdownWidgets({ 40, 123 }, { 58, 20 }, WindowColour::secondary, StringIds::empty, StringIds::tooltip_bridge_stats), Widgets::Wt3Widget({ 3, 145 }, { 132, 100 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_construct), Widgets::ImageButton({ 6, 248 }, { 46, 24 }, WindowColour::secondary, ImageIds::construction_remove, StringIds::tooltip_remove), Widgets::ImageButton({ 57, 248 }, { 24, 24 }, WindowColour::secondary, ImageIds::rotate_object, StringIds::rotate_90)); std::span<const Widget> getWidgets() { return widgets; } // 0x00522085 uint8_t trackPieceWidgets[] = { widx::straight, widx::left_hand_curve_very_small, widx::right_hand_curve_very_small, widx::left_hand_curve_small, widx::right_hand_curve_small, widx::left_hand_curve, widx::right_hand_curve, widx::left_hand_curve_large, widx::right_hand_curve_large, widx::s_bend_left, widx::s_bend_right, widx::s_bend_dual_track_left, // s_bend_to_dual_track; unused? widx::s_bend_dual_track_left, // s_bend_to_single_track; unused? widx::s_bend_dual_track_left, // turnaround }; WindowEventList events; static std::optional<TrackPieceId> getRoadPieceId(uint8_t trackPiece, uint8_t gradient, uint8_t rotation); static std::optional<TrackPieceId> getTrackPieceId(uint8_t trackPiece, uint8_t gradient, uint8_t rotation); // 0x0049B50C void reset() { Scenario::resetTrackObjects(); getGameState().lastAirport = 0xFF; getGameState().lastShipPort = 0xFF; getGameState().pickupDirection = 0; } // 0x004A18D4 static void sub_4A18D4() { if (_alternateTrackObjectId == 0xFF) { return; } if ((_alternateTrackObjectId | (1 << 7)) == _cState->trackType) { return; } auto* alternativeRoadObj = ObjectManager::get<RoadObject>(_alternateTrackObjectId); if (!alternativeRoadObj->hasFlags(RoadObjectFlags::unk_03)) { return; } auto* curRoadObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1 << 7)); if (!curRoadObj->hasFlags(RoadObjectFlags::unk_03)) { return; } for (const auto objId : _availableObjects) { if (objId == 0xFF) { return; } if (objId == (_alternateTrackObjectId | (1 << 7))) { _cState->trackType = _alternateTrackObjectId | (1 << 7); Common::sub_4A3A50(); } } } // 0x0049FA10 static void constructRoad() { _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; _cState->dword_1135F42 = 0x80000000; removeConstructionGhosts(); auto roadPiece = getRoadPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!roadPiece) { return; } auto* roadObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1 << 7)); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(roadObj->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); GameCommands::RoadPlacementArgs args; args.pos = World::Pos3(_cState->x, _cState->y, _cState->constructionZ); args.rotation = roadPiece->rotation; args.roadId = roadPiece->id; args.mods = _cState->lastSelectedMods; args.bridge = _cState->lastSelectedBridge; args.roadObjectId = _cState->trackType & ~(1 << 7); args.unkFlags = 0; _cState->dword_1135F42 = GameCommands::doCommand(args, GameCommands::Flags::apply); if (_cState->dword_1135F42 == GameCommands::FAILURE) { if (GameCommands::getErrorText() != StringIds::unable_to_cross_or_create_junction_with_string || _alternateTrackObjectId == 0xFF) { return; } sub_4A18D4(); roadPiece = getRoadPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!roadPiece) { return; } WindowManager::close(WindowType::error); args.pos = World::Pos3(_cState->x, _cState->y, _cState->constructionZ); args.rotation = roadPiece->rotation; args.roadId = roadPiece->id; args.mods = _cState->lastSelectedMods; args.bridge = _cState->lastSelectedBridge; args.roadObjectId = _cState->trackType & ~(1 << 7); _cState->dword_1135F42 = GameCommands::doCommand(args, GameCommands::Flags::apply); } if (_cState->dword_1135F42 != GameCommands::FAILURE) { const auto& trackSize = TrackData::getUnkRoad((args.roadId << 3) | (args.rotation & 0x3)); const auto newPosition = args.pos + trackSize.pos; _cState->x = newPosition.x; _cState->y = newPosition.y; _cState->constructionZ = newPosition.z; _cState->constructionRotation = trackSize.rotationEnd; _ghostVisibilityFlags = GhostVisibilityFlags::none; _cState->constructionArrowFrameNum = 0; if (_cState->lastSelectedTrackPiece >= 9) { _cState->lastSelectedTrackPiece = 0; } } } // 0x0049F93A static void constructTrack() { _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; _cState->dword_1135F42 = 0x80000000; removeConstructionGhosts(); auto trackPiece = getTrackPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!trackPiece) { return; } auto* roadObj = ObjectManager::get<TrackObject>(_cState->trackType); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(roadObj->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); GameCommands::TrackPlacementArgs args; args.pos = World::Pos3(_cState->x, _cState->y, _cState->constructionZ); args.rotation = trackPiece->rotation; args.trackId = trackPiece->id; args.mods = _cState->lastSelectedMods; args.bridge = _cState->lastSelectedBridge; args.trackObjectId = _cState->trackType; args.unk = _cState->byte_113607E & (1 << 0); args.unkFlags = 0; _cState->dword_1135F42 = GameCommands::doCommand(args, GameCommands::Flags::apply); if (_cState->dword_1135F42 == GameCommands::FAILURE) { return; } const auto& trackSize = TrackData::getUnkTrack((args.trackId << 3) | (args.rotation & 0x3)); const auto newPosition = args.pos + trackSize.pos; _cState->x = newPosition.x; _cState->y = newPosition.y; _cState->constructionZ = newPosition.z; _cState->constructionRotation = trackSize.rotationEnd; _ghostVisibilityFlags = GhostVisibilityFlags::none; _cState->constructionArrowFrameNum = 0; if (_cState->lastSelectedTrackPiece >= 9) { _cState->lastSelectedTrackPiece = 0; } } // 0x0049F92D static void constructTrackOrRoad([[maybe_unused]] Window* self, [[maybe_unused]] WidgetIndex_t widgetIndex) { if (_cState->trackType & (1 << 7)) { constructRoad(); } else { constructTrack(); } activateSelectedConstructionWidgets(); } // 0x004A012E static void removeTrack() { _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; removeConstructionGhosts(); if (_cState->constructionHover != 0) { return; } World::Pos3 loc(_cState->x, _cState->y, _cState->constructionZ); uint32_t trackAndDirection = 0; if (_cState->constructionRotation < 4) { trackAndDirection = 0; } else if (_cState->constructionRotation < 8) { trackAndDirection = 26 << 3; } else if (_cState->constructionRotation < 12) { trackAndDirection = 27 << 3; } else { trackAndDirection = 1 << 3; loc += World::Pos3{ World::kRotationOffset[_cState->constructionRotation], 0 }; } trackAndDirection |= (1 << 2) | (_cState->constructionRotation & 0x3); auto trackEnd = World::Track::getTrackConnectionEnd(loc, trackAndDirection); auto tc = World::Track::getTrackConnections(trackEnd.nextPos, trackEnd.nextRotation, CompanyManager::getControllingId(), _cState->trackType, 0, 0); if (tc.connections.empty()) { return; } const auto trackAndDirection2 = (tc.connections.back() & World::Track::AdditionalTaDFlags::basicTaDMask) ^ (1 << 2); World::Pos3 loc2(_cState->x, _cState->y, _cState->constructionZ); loc2 -= TrackData::getUnkTrack(trackAndDirection2).pos; if (trackAndDirection2 & (1 << 2)) { loc2.z += TrackData::getUnkTrack(trackAndDirection2).pos.z; } const auto& trackPiece = TrackData::getTrackPiece(trackAndDirection2 >> 3); const auto i = (trackAndDirection2 & (1 << 2)) ? trackPiece.size() - 1 : 0; loc2.z += trackPiece[i].z; GameCommands::TrackRemovalArgs args; args.pos = loc2; args.index = trackPiece[i].index; args.rotation = trackAndDirection2 & 0x3; args.trackId = trackAndDirection2 >> 3; args.trackObjectId = _cState->trackType; auto* trackObj = ObjectManager::get<TrackObject>(_cState->trackType); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(trackObj->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); if (GameCommands::doCommand(args, GameCommands::Flags::apply) != GameCommands::FAILURE) { World::Pos3 newConstructLoc = World::Pos3(_cState->x, _cState->y, _cState->constructionZ) - TrackData::getUnkTrack(trackAndDirection2).pos; _cState->x = newConstructLoc.x; _cState->y = newConstructLoc.y; _cState->constructionZ = newConstructLoc.z; _cState->constructionRotation = TrackData::getUnkTrack(trackAndDirection2).rotationBegin; _cState->lastSelectedTrackPiece = 0; _cState->lastSelectedTrackGradient = 0; activateSelectedConstructionWidgets(); } } // 0x004A02F2 static void removeRoad() { _cState->trackCost = 0x80000000; _cState->byte_1136076 = 0; removeConstructionGhosts(); if (_cState->constructionHover != 0) { return; } World::Pos3 loc(_cState->x, _cState->y, _cState->constructionZ); uint32_t trackAndDirection = (1 << 2) | (_cState->constructionRotation & 0x3); const auto roadEnd = World::Track::getRoadConnectionEnd(loc, trackAndDirection); auto rc = World::Track::getRoadConnections(roadEnd.nextPos, roadEnd.nextRotation, CompanyManager::getControllingId(), _cState->trackType & ~(1 << 7), 0, 0); if (rc.connections.empty()) { return; } for (auto& c : rc.connections) { // If trackId is zero if ((c & 0x1F8) == 0) { std::swap(c, rc.connections[0]); } } auto* roadObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1 << 7)); if (!roadObj->hasFlags(RoadObjectFlags::unk_02)) { rc.connections.resize(1); } uint16_t trackAndDirection2 = 0; for (auto c : rc.connections) { trackAndDirection2 = (c & World::Track::AdditionalTaDFlags::basicTaDMask) ^ (1 << 2); World::Pos3 loc2(_cState->x, _cState->y, _cState->constructionZ); loc2 -= TrackData::getUnkRoad(trackAndDirection2).pos; if (trackAndDirection2 & (1 << 2)) { loc2.z += TrackData::getUnkRoad(trackAndDirection2).pos.z; } const auto& roadPiece = TrackData::getRoadPiece(trackAndDirection2 >> 3); const auto i = (trackAndDirection2 & (1 << 2)) ? roadPiece.size() - 1 : 0; loc2.z += roadPiece[i].z; GameCommands::RoadRemovalArgs args; args.pos = loc2; args.sequenceIndex = roadPiece[i].index; args.rotation = trackAndDirection2 & 0x3; args.roadId = trackAndDirection2 >> 3; args.objectId = _cState->trackType & ~(1 << 7); auto* trackObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1 << 7)); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(trackObj->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); if (GameCommands::doCommand(args, GameCommands::Flags::apply) == GameCommands::FAILURE) { return; } } World::Pos3 newConstructLoc = World::Pos3(_cState->x, _cState->y, _cState->constructionZ) - TrackData::getUnkRoad(trackAndDirection2).pos; _cState->x = newConstructLoc.x; _cState->y = newConstructLoc.y; _cState->constructionZ = newConstructLoc.z; _cState->constructionRotation = TrackData::getUnkRoad(trackAndDirection2).rotationBegin; _cState->lastSelectedTrackPiece = 0; _cState->lastSelectedTrackGradient = 0; activateSelectedConstructionWidgets(); } // 0x004A0121 static void removeTrack([[maybe_unused]] Window* self, [[maybe_unused]] WidgetIndex_t widgetIndex) { if (_cState->trackType & (1 << 7)) { removeRoad(); } else { removeTrack(); } } // 0x0049D3F6 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_construction: case Common::widx::tab_overhead: case Common::widx::tab_signal: case Common::widx::tab_station: Common::switchTab(self, widgetIndex); break; case widx::construct: constructTrackOrRoad(&self, widgetIndex); break; case widx::remove: removeTrack(&self, widgetIndex); break; case widx::rotate_90: { if (_cState->constructionHover == 1) { _cState->constructionRotation++; _cState->constructionRotation = _cState->constructionRotation & 3; _cState->trackCost = 0x80000000; activateSelectedConstructionWidgets(); break; } removeConstructionGhosts(); WindowManager::viewportSetVisibility(WindowManager::ViewportVisibility::overgroundView); ToolManager::toolSet(self, widx::construct, CursorId::crosshair); Input::setFlag(Input::Flags::flag6); _cState->constructionHover = 1; _cState->byte_113607E = 0; _cState->constructionRotation = _cState->constructionRotation & 3; activateSelectedConstructionWidgets(); break; } } } // 0x0049DB71 static void disableUnusedPiecesRotation(uint64_t* disabledWidgets) { if (_cState->constructionRotation < 12) { if (_cState->constructionRotation >= 8) { *disabledWidgets |= (1 << widx::left_hand_curve_small) | (1 << widx::left_hand_curve) | (1 << widx::left_hand_curve_large) | (1 << widx::right_hand_curve_large) | (1 << widx::right_hand_curve) | (1 << widx::right_hand_curve_small); *disabledWidgets |= (1 << widx::s_bend_right) | (1 << widx::slope_down) | (1 << widx::slope_up); } else { if (_cState->constructionRotation >= 4) { *disabledWidgets |= (1 << widx::left_hand_curve_small) | (1 << widx::left_hand_curve) | (1 << widx::left_hand_curve_large) | (1 << widx::right_hand_curve_large) | (1 << widx::right_hand_curve) | (1 << widx::right_hand_curve_small); *disabledWidgets |= (1 << widx::s_bend_left) | (1 << widx::slope_down) | (1 << widx::slope_up); } } } else { *disabledWidgets |= (1 << widx::left_hand_curve_very_small) | (1 << widx::left_hand_curve_small) | (1 << widx::left_hand_curve) | (1 << widx::right_hand_curve) | (1 << widx::right_hand_curve_very_small) | (1 << widx::right_hand_curve_small); *disabledWidgets |= (1 << widx::s_bend_dual_track_left) | (1 << widx::s_bend_left) | (1 << widx::s_bend_right) | (1 << widx::s_bend_dual_track_right) | (1 << widx::steep_slope_down) | (1 << widx::slope_down) | (1 << widx::slope_up) | (1 << widx::steep_slope_up); } } // 0x0049DBEC static void disableUnusedRoadPieces(Window* self, uint64_t disabledWidgets) { if (_cState->lastSelectedTrackGradient == 2 || _cState->lastSelectedTrackGradient == 6 || _cState->lastSelectedTrackGradient == 4 || _cState->lastSelectedTrackGradient == 8) { disabledWidgets |= (1 << widx::left_hand_curve_very_small) | (1 << widx::left_hand_curve) | (1 << widx::left_hand_curve_large) | (1 << widx::right_hand_curve_large) | (1 << widx::right_hand_curve) | (1 << widx::right_hand_curve_very_small); disabledWidgets |= (1 << widx::s_bend_dual_track_left) | (1 << widx::s_bend_left) | (1 << widx::s_bend_right) | (1 << widx::s_bend_dual_track_right); disabledWidgets |= (1 << widx::left_hand_curve_small) | (1 << widx::right_hand_curve_small); } disableUnusedPiecesRotation(&disabledWidgets); if (_cState->constructionHover == 0) { auto road = getRoadPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!road) { disabledWidgets |= (1 << widx::construct); } } self->setDisabledWidgetsAndInvalidate(disabledWidgets); } // 0x0049DB1F static void disableUnusedTrackPieces(Window* self, TrackObject trackObj, uint64_t disabledWidgets) { if (_cState->lastSelectedTrackGradient == 2 || _cState->lastSelectedTrackGradient == 6 || _cState->lastSelectedTrackGradient == 4 || _cState->lastSelectedTrackGradient == 8) { disabledWidgets |= (1 << widx::left_hand_curve_very_small) | (1 << widx::left_hand_curve) | (1 << widx::left_hand_curve_large) | (1 << widx::right_hand_curve_large) | (1 << widx::right_hand_curve) | (1 << widx::right_hand_curve_very_small); disabledWidgets |= (1 << widx::s_bend_dual_track_left) | (1 << widx::s_bend_left) | (1 << widx::s_bend_right) | (1 << widx::s_bend_dual_track_right); if (!trackObj.hasTraitFlags(Track::TrackTraitFlags::slopedCurve)) { disabledWidgets |= (1 << widx::left_hand_curve_small) | (1 << widx::right_hand_curve_small); } } disableUnusedPiecesRotation(&disabledWidgets); if (_cState->constructionHover == 0) { auto track = getTrackPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!track) { disabledWidgets |= (1 << widx::construct); } } self->setDisabledWidgetsAndInvalidate(disabledWidgets); } // 0x0049DAF3 static void disableTrackSlopes(Window* self, TrackObject trackObj, uint64_t disabledWidgets) { if (!trackObj.hasTraitFlags(Track::TrackTraitFlags::slope) && !trackObj.hasTraitFlags(Track::TrackTraitFlags::slopedCurve)) { disabledWidgets |= (1 << widx::slope_down) | (1 << widx::slope_up); } if (!trackObj.hasTraitFlags(Track::TrackTraitFlags::steepSlope) && !trackObj.hasTraitFlags(Track::TrackTraitFlags::slopedCurve)) { disabledWidgets |= (1 << widx::steep_slope_down) | (1 << widx::steep_slope_up); } disableUnusedTrackPieces(self, trackObj, disabledWidgets); } static void setMapSelectedTilesFromPiece(const std::span<const TrackData::PreviewTrack> pieces, const World::Pos2& origin, const uint8_t rotation) { resetMapSelectionFreeFormTiles(); for (const auto& piece : pieces) { if (piece.hasFlags(World::TrackData::PreviewTrackFlags::diagonal)) { continue; } addMapSelectionFreeFormTile(origin + Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, rotation)); } mapInvalidateMapSelectionFreeFormTiles(); } static void activateSelectedRoadWidgets(Window* window) { World::mapInvalidateMapSelectionFreeFormTiles(); World::setMapSelectionFlags(World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::unk_03); auto road = getRoadPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); uint8_t rotation; uint8_t roadId; const uint16_t x = _cState->x; const uint16_t y = _cState->y; if (!road) { rotation = _cState->constructionRotation; roadId = 0; } else { rotation = road->rotation; roadId = road->id; } const auto& roadPiece = World::TrackData::getRoadPiece(roadId); rotation &= 3; setMapSelectedTilesFromPiece(roadPiece, World::Pos2(x, y), rotation); window->holdableWidgets = (1 << widx::construct) | (1 << widx::remove); auto trackType = _cState->trackType & ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(trackType); window->widgets[widx::s_bend_left].hidden = true; window->widgets[widx::s_bend_right].hidden = true; window->widgets[widx::left_hand_curve_large].hidden = true; window->widgets[widx::right_hand_curve_large].hidden = true; window->widgets[widx::left_hand_curve].hidden = true; window->widgets[widx::right_hand_curve].hidden = true; window->widgets[widx::left_hand_curve_small].hidden = true; window->widgets[widx::right_hand_curve_small].hidden = true; window->widgets[widx::left_hand_curve_very_small].hidden = true; window->widgets[widx::right_hand_curve_very_small].hidden = true; window->widgets[widx::left_hand_curve_small].left = 3; window->widgets[widx::left_hand_curve_small].right = 24; window->widgets[widx::right_hand_curve_small].left = 113; window->widgets[widx::right_hand_curve_small].right = 134; window->widgets[widx::left_hand_curve].left = 25; window->widgets[widx::left_hand_curve].right = 46; window->widgets[widx::right_hand_curve].left = 91; window->widgets[widx::right_hand_curve].right = 112; if (roadObj->hasTraitFlags(World::Track::RoadTraitFlags::verySmallCurve)) { window->widgets[widx::left_hand_curve_small].left = 25; window->widgets[widx::left_hand_curve_small].right = 46; window->widgets[widx::right_hand_curve_small].left = 91; window->widgets[widx::right_hand_curve_small].right = 112; window->widgets[widx::left_hand_curve].left = 47; window->widgets[widx::left_hand_curve].right = 68; window->widgets[widx::right_hand_curve].left = 69; window->widgets[widx::right_hand_curve].right = 90; window->widgets[widx::left_hand_curve_very_small].hidden = false; window->widgets[widx::right_hand_curve_very_small].hidden = false; } if (roadObj->hasTraitFlags(World::Track::RoadTraitFlags::smallCurve)) { window->widgets[widx::left_hand_curve_small].hidden = false; window->widgets[widx::right_hand_curve_small].hidden = false; } window->widgets[widx::s_bend_dual_track_left].hidden = true; window->widgets[widx::s_bend_dual_track_right].hidden = true; if (roadObj->hasTraitFlags(World::Track::RoadTraitFlags::turnaround)) { window->widgets[widx::s_bend_dual_track_left].hidden = false; window->widgets[widx::s_bend_dual_track_left].image = ImageIds::construction_right_turnaround; window->widgets[widx::s_bend_dual_track_left].tooltip = StringIds::tooltip_turnaround; if (getGameState().trafficHandedness == 0) { window->widgets[widx::s_bend_dual_track_left].image = ImageIds::construction_left_turnaround; } } window->widgets[widx::steep_slope_down].hidden = true; window->widgets[widx::slope_down].hidden = true; window->widgets[widx::slope_up].hidden = true; window->widgets[widx::steep_slope_up].hidden = true; if (roadObj->hasTraitFlags(World::Track::RoadTraitFlags::slope)) { window->widgets[widx::slope_down].hidden = false; window->widgets[widx::slope_up].hidden = false; } if (roadObj->hasTraitFlags(World::Track::RoadTraitFlags::steepSlope)) { window->widgets[widx::steep_slope_down].hidden = false; window->widgets[widx::steep_slope_up].hidden = false; } window->widgets[widx::bridge].hidden = false; window->widgets[widx::bridge_dropdown].hidden = false; if (_cState->lastSelectedBridge == 0xFF || (_cState->constructionHover != 1 && !(_cState->byte_1136076 & 1))) { window->widgets[widx::bridge].hidden = true; window->widgets[widx::bridge_dropdown].hidden = true; } auto activatedWidgets = window->activatedWidgets; activatedWidgets &= ~(Construction::allTrack); window->widgets[widx::construct].hidden = true; window->widgets[widx::remove].hidden = false; window->widgets[widx::rotate_90].hidden = true; if (_cState->constructionHover == 1) { // Previously turned to wt_6 which is same as Tab, when pressed increments image index and no background. window->widgets[widx::construct].hidden = false; window->widgets[widx::construct].tooltip = StringIds::tooltip_start_construction; window->widgets[widx::remove].hidden = true; window->widgets[widx::rotate_90].hidden = false; window->widgets[widx::rotate_90].image = ImageIds::rotate_object; window->widgets[widx::rotate_90].tooltip = StringIds::rotate_90; } else if (_cState->constructionHover == 0) { // Previously turned to wt_3, draws background and image, no behavior when clicked. window->widgets[widx::construct].hidden = false; window->widgets[widx::construct].tooltip = StringIds::tooltip_construct; window->widgets[widx::rotate_90].hidden = false; window->widgets[widx::rotate_90].image = ImageIds::construction_new_position; window->widgets[widx::rotate_90].tooltip = StringIds::new_construction_position; } if (_cState->constructionHover == 0 || _cState->constructionHover == 1) { if (_cState->lastSelectedTrackPiece != 0xFF) { auto trackPieceWidget = trackPieceWidgets[_cState->lastSelectedTrackPiece]; activatedWidgets |= 1ULL << trackPieceWidget; } uint8_t trackGradient = widx::level; switch (_cState->lastSelectedTrackGradient) { case TrackGradient::level: trackGradient = widx::level; break; case TrackGradient::slope_up: trackGradient = widx::slope_up; break; case TrackGradient::slope_down: trackGradient = widx::slope_down; break; case TrackGradient::steep_slope_up: trackGradient = widx::steep_slope_up; break; case TrackGradient::steep_slope_down: trackGradient = widx::steep_slope_down; break; } activatedWidgets |= 1ULL << trackGradient; } window->activatedWidgets = activatedWidgets; window->invalidate(); } static void activateSelectedTrackWidgets(Window* window) { World::mapInvalidateMapSelectionFreeFormTiles(); World::setMapSelectionFlags(World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::unk_03); auto track = getTrackPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); uint8_t rotation; uint8_t trackId; const uint16_t x = _cState->x; const uint16_t y = _cState->y; if (!track) { rotation = _cState->constructionRotation; trackId = 0; } else { rotation = track->rotation; trackId = track->id; } const auto& trackPiece = World::TrackData::getTrackPiece(trackId); rotation &= 3; setMapSelectedTilesFromPiece(trackPiece, World::Pos2(x, y), rotation); window->holdableWidgets = (1 << widx::construct) | (1 << widx::remove); auto trackObj = ObjectManager::get<TrackObject>(_cState->trackType); window->widgets[widx::s_bend_left].hidden = false; window->widgets[widx::s_bend_right].hidden = false; window->widgets[widx::left_hand_curve_large].hidden = true; window->widgets[widx::right_hand_curve_large].hidden = true; window->widgets[widx::left_hand_curve].hidden = true; window->widgets[widx::right_hand_curve].hidden = true; window->widgets[widx::left_hand_curve_small].hidden = true; window->widgets[widx::right_hand_curve_small].hidden = true; window->widgets[widx::left_hand_curve_very_small].hidden = true; window->widgets[widx::right_hand_curve_very_small].hidden = true; window->widgets[widx::left_hand_curve_small].left = 3; window->widgets[widx::left_hand_curve_small].right = 24; window->widgets[widx::right_hand_curve_small].left = 113; window->widgets[widx::right_hand_curve_small].right = 134; window->widgets[widx::left_hand_curve].left = 25; window->widgets[widx::left_hand_curve].right = 46; window->widgets[widx::right_hand_curve].left = 91; window->widgets[widx::right_hand_curve].right = 112; if (trackObj->hasTraitFlags(Track::TrackTraitFlags::verySmallCurve)) { window->widgets[widx::left_hand_curve_small].left = 25; window->widgets[widx::left_hand_curve_small].right = 46; window->widgets[widx::right_hand_curve_small].left = 91; window->widgets[widx::right_hand_curve_small].right = 112; window->widgets[widx::left_hand_curve].left = 47; window->widgets[widx::left_hand_curve].right = 68; window->widgets[widx::right_hand_curve].left = 69; window->widgets[widx::right_hand_curve].right = 90; window->widgets[widx::left_hand_curve_very_small].hidden = false; window->widgets[widx::right_hand_curve_very_small].hidden = false; } if (trackObj->hasTraitFlags(Track::TrackTraitFlags::largeCurve)) { window->widgets[widx::left_hand_curve_large].hidden = false; window->widgets[widx::right_hand_curve_large].hidden = false; } if (trackObj->hasTraitFlags(Track::TrackTraitFlags::normalCurve)) { window->widgets[widx::left_hand_curve].hidden = false; window->widgets[widx::right_hand_curve].hidden = false; } if (trackObj->hasTraitFlags(Track::TrackTraitFlags::smallCurve)) { window->widgets[widx::left_hand_curve_small].hidden = false; window->widgets[widx::right_hand_curve_small].hidden = false; } window->widgets[widx::s_bend_dual_track_left].hidden = true; window->widgets[widx::s_bend_dual_track_right].hidden = true; if (trackObj->hasTraitFlags(Track::TrackTraitFlags::oneSided)) { window->widgets[widx::s_bend_dual_track_left].hidden = false; window->widgets[widx::s_bend_dual_track_right].hidden = false; window->widgets[widx::s_bend_dual_track_left].image = ImageIds::construction_s_bend_dual_track_left; window->widgets[widx::s_bend_dual_track_right].image = ImageIds::construction_s_bend_dual_track_right; window->widgets[widx::s_bend_dual_track_left].tooltip = StringIds::tooltip_s_bend_left_dual_track; window->widgets[widx::s_bend_dual_track_right].tooltip = StringIds::tooltip_s_bend_right_dual_track; trackPieceWidgets[TrackPiece::s_bend_to_dual_track] = widx::s_bend_dual_track_left; trackPieceWidgets[TrackPiece::s_bend_to_single_track] = widx::s_bend_dual_track_right; if (_cState->constructionRotation >= 4 && _cState->constructionRotation < 12) { window->widgets[widx::s_bend_dual_track_left].image = ImageIds::construction_right_turnaround; window->widgets[widx::s_bend_dual_track_right].image = ImageIds::construction_s_bend_to_single_track_left; window->widgets[widx::s_bend_dual_track_left].tooltip = StringIds::tooltip_turnaround; window->widgets[widx::s_bend_dual_track_right].tooltip = StringIds::tooltip_s_bend_to_single_track; trackPieceWidgets[TrackPiece::s_bend_to_dual_track] = widx::s_bend_dual_track_right; trackPieceWidgets[TrackPiece::turnaround] = widx::s_bend_dual_track_left; if (_cState->constructionRotation >= 8) { window->widgets[widx::s_bend_dual_track_left].image = ImageIds::construction_s_bend_to_single_track_right; window->widgets[widx::s_bend_dual_track_right].image = ImageIds::construction_left_turnaround; window->widgets[widx::s_bend_dual_track_left].tooltip = StringIds::tooltip_s_bend_to_single_track; window->widgets[widx::s_bend_dual_track_right].tooltip = StringIds::tooltip_turnaround; trackPieceWidgets[TrackPiece::s_bend_to_single_track] = widx::s_bend_dual_track_left; trackPieceWidgets[TrackPiece::turnaround] = widx::s_bend_dual_track_right; } } } window->widgets[widx::steep_slope_down].hidden = true; window->widgets[widx::slope_down].hidden = true; window->widgets[widx::slope_up].hidden = true; window->widgets[widx::steep_slope_up].hidden = true; if (trackObj->hasTraitFlags(Track::TrackTraitFlags::slope)) { window->widgets[widx::slope_down].hidden = false; window->widgets[widx::slope_up].hidden = false; } if (trackObj->hasTraitFlags(Track::TrackTraitFlags::steepSlope)) { window->widgets[widx::steep_slope_down].hidden = false; window->widgets[widx::steep_slope_up].hidden = false; } window->widgets[widx::bridge].hidden = false; window->widgets[widx::bridge_dropdown].hidden = false; if (_cState->lastSelectedBridge == 0xFF || (_cState->constructionHover != 1 && !(_cState->byte_1136076 & 1))) { window->widgets[widx::bridge].hidden = true; window->widgets[widx::bridge_dropdown].hidden = true; } auto activatedWidgets = window->activatedWidgets; activatedWidgets &= ~(Construction::allTrack); window->widgets[widx::construct].hidden = true; window->widgets[widx::remove].hidden = false; window->widgets[widx::rotate_90].hidden = true; if (_cState->constructionHover == 1) { window->widgets[widx::construct].hidden = false; window->widgets[widx::construct].tooltip = StringIds::tooltip_start_construction; window->widgets[widx::remove].hidden = true; window->widgets[widx::rotate_90].hidden = false; window->widgets[widx::rotate_90].image = ImageIds::rotate_object; window->widgets[widx::rotate_90].tooltip = StringIds::rotate_90; } else if (_cState->constructionHover == 0) { window->widgets[widx::construct].hidden = false; window->widgets[widx::construct].tooltip = StringIds::tooltip_construct; window->widgets[widx::rotate_90].hidden = false; window->widgets[widx::rotate_90].image = ImageIds::construction_new_position; window->widgets[widx::rotate_90].tooltip = StringIds::new_construction_position; } if (_cState->constructionHover == 0 || _cState->constructionHover == 1) { if (_cState->lastSelectedTrackPiece != 0xFF) { auto trackPieceWidget = trackPieceWidgets[_cState->lastSelectedTrackPiece]; activatedWidgets |= 1ULL << trackPieceWidget; } uint8_t trackGradient = widx::level; switch (_cState->lastSelectedTrackGradient) { case TrackGradient::level: trackGradient = widx::level; break; case TrackGradient::slope_up: trackGradient = widx::slope_up; break; case TrackGradient::slope_down: trackGradient = widx::slope_down; break; case TrackGradient::steep_slope_up: trackGradient = widx::steep_slope_up; break; case TrackGradient::steep_slope_down: trackGradient = widx::steep_slope_down; break; } activatedWidgets |= 1ULL << trackGradient; } window->activatedWidgets = activatedWidgets; window->invalidate(); } // 0x0049F1B5 void activateSelectedConstructionWidgets() { auto window = WindowManager::find(WindowType::construction); if (window == nullptr) { return; } if (window->currentTab == Common::widx::tab_construction - Common::widx::tab_construction) { if (_cState->trackType & (1 << 7)) { activateSelectedRoadWidgets(window); } else { activateSelectedTrackWidgets(window); } } } // 0x004A0832 static std::optional<TrackPieceId> getRoadPieceId(uint8_t trackPiece, uint8_t gradient, uint8_t rotation) { if (trackPiece == 0xFF) { return std::nullopt; } uint8_t id = 0; switch (trackPiece) { case TrackPiece::straight: // 0x004A0856 { if (rotation >= 4) { return std::nullopt; } switch (gradient) { default: return std::nullopt; case TrackGradient::level: id = 0; break; case TrackGradient::slope_up: id = 5; break; case TrackGradient::slope_down: id = 6; break; case TrackGradient::steep_slope_up: id = 7; break; case TrackGradient::steep_slope_down: id = 8; break; } break; } case TrackPiece::left_hand_curve_very_small: // 0x004A08A5 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 4) { return std::nullopt; } id = 1; break; } case TrackPiece::right_hand_curve_very_small: // 0x004A08CD { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 4) { return std::nullopt; } id = 2; break; } case TrackPiece::left_hand_curve_small: // 0x004A08ED { if (rotation >= 4) { return std::nullopt; } id = 3; if (gradient != TrackGradient::level) { return std::nullopt; } break; } case TrackPiece::right_hand_curve_small: // 0x004A08FB { if (rotation >= 4) { return std::nullopt; } id = 4; if (gradient != TrackGradient::level) { return std::nullopt; } break; } case TrackPiece::left_hand_curve: // 0x004A095F case TrackPiece::right_hand_curve: case TrackPiece::left_hand_curve_large: case TrackPiece::right_hand_curve_large: case TrackPiece::s_bend_left: case TrackPiece::s_bend_right: case TrackPiece::s_bend_to_dual_track: case TrackPiece::s_bend_to_single_track: { return std::nullopt; } case TrackPiece::turnaround: // 0x004A0909 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 12) { return std::nullopt; } id = 9; break; } } if (rotation < 12) { rotation &= 3; } return TrackPieceId{ id, rotation }; } // 0x004A04F8 std::optional<TrackPieceId> getTrackPieceId(uint8_t trackPiece, uint8_t gradient, uint8_t rotation) { if (trackPiece == 0xFF) { return std::nullopt; } uint8_t id = 0; switch (trackPiece) { case TrackPiece::straight: // loc_4A051C { if (rotation >= 12) { id = 1; if (gradient != TrackGradient::level) { return std::nullopt; } } else { if (rotation >= 8) { switch (gradient) { default: return std::nullopt; case TrackGradient::level: id = 27; break; case TrackGradient::steep_slope_up: id = 35; break; case TrackGradient::steep_slope_down: id = 37; break; } } else if (rotation >= 4) { switch (gradient) { default: return std::nullopt; case TrackGradient::level: id = 26; break; case TrackGradient::steep_slope_up: id = 34; break; case TrackGradient::steep_slope_down: id = 36; break; } } else { switch (gradient) { default: return std::nullopt; case TrackGradient::level: id = 0; break; case TrackGradient::slope_up: id = 14; break; case TrackGradient::slope_down: id = 15; break; case TrackGradient::steep_slope_up: id = 16; break; case TrackGradient::steep_slope_down: id = 17; break; } } } break; } case TrackPiece::left_hand_curve_very_small: // loc_4A05C3 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 12) { return std::nullopt; } if (rotation >= 8) { id = 29; break; } if (rotation >= 4) { id = 28; break; } id = 2; break; } case TrackPiece::right_hand_curve_very_small: // loc_4A05F4 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 12) { return std::nullopt; } if (rotation >= 8) { id = 31; break; } if (rotation >= 4) { id = 30; break; } id = 3; break; } case TrackPiece::left_hand_curve_small: // loc_4A0625 { if (rotation >= 4) { return std::nullopt; } switch (gradient) { default: return std::nullopt; case TrackGradient::level: id = 4; break; case TrackGradient::slope_up: id = 18; break; case TrackGradient::slope_down: id = 20; break; case TrackGradient::steep_slope_up: id = 22; break; case TrackGradient::steep_slope_down: id = 24; break; } break; } case TrackPiece::right_hand_curve_small: // loc_4A066A { if (rotation >= 4) { return std::nullopt; } switch (gradient) { default: return std::nullopt; case TrackGradient::level: id = 5; break; case TrackGradient::slope_up: id = 19; break; case TrackGradient::slope_down: id = 21; break; case TrackGradient::steep_slope_up: id = 23; break; case TrackGradient::steep_slope_down: id = 25; break; } break; } case TrackPiece::left_hand_curve: // loc_4A06AF { if (rotation >= 4) { return std::nullopt; } id = 6; if (gradient != TrackGradient::level) { return std::nullopt; } break; } case TrackPiece::right_hand_curve: // loc_4A06C8 { if (rotation >= 4) { return std::nullopt; } id = 7; if (gradient != TrackGradient::level) { return std::nullopt; } break; } case TrackPiece::left_hand_curve_large: // loc_4A06E1 { if (gradient != TrackGradient::level) { return std::nullopt; } id = 10; if (rotation >= 12) { break; } if (rotation >= 4) { return std::nullopt; } id = 8; break; } case TrackPiece::right_hand_curve_large: // loc_4A0705 { if (gradient != TrackGradient::level) { return std::nullopt; } id = 11; if (rotation >= 12) { break; } if (rotation >= 4) { return std::nullopt; } id = 9; break; } case TrackPiece::s_bend_left: // loc_4A0729 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 12) { return std::nullopt; } id = 33; if (rotation >= 8) { break; } if (rotation >= 4) { return std::nullopt; } id = 12; break; } case TrackPiece::s_bend_right: // loc_4A0756 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 8) { return std::nullopt; } id = 32; if (rotation >= 4) { break; } id = 13; break; } case TrackPiece::s_bend_to_dual_track: // loc_4A077C { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 8) { return std::nullopt; } id = 40; if (rotation >= 4) { break; } id = 38; break; } case TrackPiece::s_bend_to_single_track: // loc_4A07A2 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 12) { return std::nullopt; } id = 41; if (rotation >= 8) { break; } if (rotation >= 4) { return std::nullopt; } id = 39; break; } case TrackPiece::turnaround: // loc_4A07C0 { if (gradient != TrackGradient::level) { return std::nullopt; } if (rotation >= 12) { return std::nullopt; } id = 43; if (rotation >= 8) { break; } id = 42; if (rotation >= 4) { return std::nullopt; } break; } } if (rotation < 12) { rotation &= 3; } return TrackPieceId{ id, rotation }; } // 0x0049DAA5 static void onResize(Window& self) { self.disabledWidgets |= (1ULL << widx::construct); if (_cState->constructionHover != 1) { self.disabledWidgets &= ~(1ULL << widx::construct); } auto disabledWidgets = self.disabledWidgets; disabledWidgets &= (1 << Common::widx::tab_construction | 1 << Common::widx::tab_overhead | 1 << Common::widx::tab_signal | 1 << Common::widx::tab_station); uint8_t trackType = _cState->trackType; if (trackType & (1 << 7)) { trackType &= ~(1 << 7); if (_cState->lastSelectedTrackPiece == 0xFF) { disableUnusedRoadPieces(&self, disabledWidgets); return; } switch (_cState->lastSelectedTrackPiece) { case TrackPiece::straight: case TrackPiece::left_hand_curve: case TrackPiece::right_hand_curve: case TrackPiece::left_hand_curve_large: case TrackPiece::right_hand_curve_large: case TrackPiece::s_bend_left: case TrackPiece::s_bend_right: case TrackPiece::s_bend_to_dual_track: case TrackPiece::s_bend_to_single_track: { disableUnusedRoadPieces(&self, disabledWidgets); break; } case TrackPiece::left_hand_curve_very_small: case TrackPiece::right_hand_curve_very_small: case TrackPiece::left_hand_curve_small: case TrackPiece::right_hand_curve_small: case TrackPiece::turnaround: { disabledWidgets |= (1 << widx::steep_slope_down) | (1 << widx::slope_down) | (1 << widx::slope_up) | (1 << widx::steep_slope_up); disableUnusedRoadPieces(&self, disabledWidgets); break; } } } else { auto trackObj = ObjectManager::get<TrackObject>(trackType); if (_cState->lastSelectedTrackPiece == 0xFF) { disableUnusedTrackPieces(&self, *trackObj, disabledWidgets); return; } switch (_cState->lastSelectedTrackPiece) { case TrackPiece::straight: disableUnusedTrackPieces(&self, *trackObj, disabledWidgets); break; case TrackPiece::left_hand_curve_very_small: case TrackPiece::right_hand_curve_very_small: case TrackPiece::left_hand_curve: case TrackPiece::right_hand_curve: case TrackPiece::left_hand_curve_large: case TrackPiece::right_hand_curve_large: case TrackPiece::s_bend_left: case TrackPiece::s_bend_right: case TrackPiece::s_bend_to_dual_track: case TrackPiece::s_bend_to_single_track: case TrackPiece::turnaround: { disabledWidgets |= (1 << widx::steep_slope_down) | (1 << widx::slope_down) | (1 << widx::slope_up) | (1 << widx::steep_slope_up); disableUnusedTrackPieces(&self, *trackObj, disabledWidgets); break; } case TrackPiece::left_hand_curve_small: case TrackPiece::right_hand_curve_small: { disableTrackSlopes(&self, *trackObj, disabledWidgets); break; } } } } // 0x0049d600 (based on) static void changeTrackPiece(uint8_t trackPiece, bool slope) { _cState->byte_113603A = 0xFF; removeConstructionGhosts(); if (slope) { _cState->lastSelectedTrackGradient = trackPiece; } else { _cState->lastSelectedTrackPiece = trackPiece; } _cState->trackCost = 0x80000000; activateSelectedConstructionWidgets(); } // 0x0049D83A static void bridgeDropdown(Window* self) { auto bridgeCount = 0; for (; bridgeCount < 9; bridgeCount++) { if (_cState->bridgeList[bridgeCount] == 0xFF) { break; } } uint8_t flags = (1 << 7) | (1 << 6); auto widget = self->widgets[widx::bridge]; auto x = widget.left + self->x; auto y = widget.top + self->y; auto width = 155; auto height = widget.height(); Dropdown::show(x, y, width, height, self->getColour(WindowColour::secondary), bridgeCount, 22, flags); for (auto i = 0; i < 9; i++) { auto bridge = _cState->bridgeList[i]; if (bridge == 0xFF) { return; } if (bridge == _cState->lastSelectedBridge) { Dropdown::setHighlightedItem(i); } auto bridgeObj = ObjectManager::get<BridgeObject>(bridge); auto company = CompanyManager::getPlayerCompany(); auto companyColour = company->mainColours.primary; auto imageId = Gfx::recolour(bridgeObj->image, companyColour); auto args = FormatArguments(); args.push(imageId); if (bridgeObj->maxSpeed == kSpeed16Null) { args.push(StringIds::unlimited_speed); args.push<uint16_t>(0); } else { args.push(StringIds::velocity); args.push(bridgeObj->maxSpeed); } args.push<uint16_t>(bridgeObj->maxHeight); Dropdown::add(i, StringIds::dropdown_bridge_stats, args); } } // 0x0049D42F static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::left_hand_curve: changeTrackPiece(TrackPiece::left_hand_curve, false); break; case widx::right_hand_curve: changeTrackPiece(TrackPiece::right_hand_curve, false); break; case widx::left_hand_curve_small: changeTrackPiece(TrackPiece::left_hand_curve_small, false); break; case widx::right_hand_curve_small: changeTrackPiece(TrackPiece::right_hand_curve_small, false); break; case widx::left_hand_curve_very_small: changeTrackPiece(TrackPiece::left_hand_curve_very_small, false); break; case widx::right_hand_curve_very_small: changeTrackPiece(TrackPiece::right_hand_curve_very_small, false); break; case widx::left_hand_curve_large: changeTrackPiece(TrackPiece::left_hand_curve_large, false); break; case widx::right_hand_curve_large: changeTrackPiece(TrackPiece::right_hand_curve_large, false); break; case widx::straight: changeTrackPiece(TrackPiece::straight, false); break; case widx::s_bend_left: changeTrackPiece(TrackPiece::s_bend_left, false); break; case widx::s_bend_right: changeTrackPiece(TrackPiece::s_bend_right, false); break; case widx::s_bend_dual_track_left: { _cState->byte_113603A = 0xFF; removeConstructionGhosts(); _cState->trackCost = 0x80000000; if (self.widgets[widx::s_bend_dual_track_left].image == ImageIds::construction_s_bend_dual_track_left) { _cState->lastSelectedTrackPiece = TrackPiece::s_bend_to_dual_track; } else if (self.widgets[widx::s_bend_dual_track_left].image == ImageIds::construction_left_turnaround || self.widgets[widx::s_bend_dual_track_left].image == ImageIds::construction_right_turnaround) { _cState->lastSelectedTrackPiece = TrackPiece::turnaround; } else { _cState->lastSelectedTrackPiece = TrackPiece::s_bend_to_single_track; } activateSelectedConstructionWidgets(); break; } case widx::s_bend_dual_track_right: { _cState->byte_113603A = 0xFF; removeConstructionGhosts(); _cState->trackCost = 0x80000000; if (self.widgets[widx::s_bend_dual_track_right].image == ImageIds::construction_s_bend_dual_track_right) { _cState->lastSelectedTrackPiece = TrackPiece::s_bend_to_dual_track; } else if (self.widgets[widx::s_bend_dual_track_right].image == ImageIds::construction_left_turnaround) { _cState->lastSelectedTrackPiece = TrackPiece::turnaround; } else { _cState->lastSelectedTrackPiece = TrackPiece::s_bend_to_single_track; } activateSelectedConstructionWidgets(); break; } case widx::steep_slope_down: changeTrackPiece(TrackGradient::steep_slope_down, true); break; case widx::slope_down: changeTrackPiece(TrackGradient::slope_down, true); break; case widx::level: changeTrackPiece(TrackGradient::level, true); break; case widx::slope_up: changeTrackPiece(TrackGradient::slope_up, true); break; case widx::steep_slope_up: changeTrackPiece(TrackGradient::steep_slope_up, true); break; case widx::bridge_dropdown: { bridgeDropdown(&self); break; } case widx::construct: { if (Input::getClickRepeatTicks() >= 40) { constructTrackOrRoad(&self, widgetIndex); } break; } case widx::remove: { if (Input::getClickRepeatTicks() >= 40) { removeTrack(&self, widgetIndex); } break; } } } // 0x0049D4EA static void onDropdown([[maybe_unused]] Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == widx::bridge_dropdown) { if (itemIndex != -1) { auto bridge = _cState->bridgeList[itemIndex]; _cState->lastSelectedBridge = bridge; // TODO: & ~(1 << 7) added to prevent crashing when selecting bridges for road/trams Scenario::getConstruction().bridges[_cState->trackType & ~(1 << 7)] = bridge; removeConstructionGhosts(); _cState->trackCost = 0x80000000; activateSelectedConstructionWidgets(); } } } static std::optional<GameCommands::RoadPlacementArgs> getRoadPlacementArgs(const World::Pos3& pos, const uint8_t trackPiece, const uint8_t gradient, const uint8_t rotation); static std::optional<GameCommands::TrackPlacementArgs> getTrackPlacementArgs(const World::Pos3& pos, const uint8_t trackPiece, const uint8_t gradient, const uint8_t rotation); static uint32_t placeRoadGhost(const GameCommands::RoadPlacementArgs& args); static uint32_t placeTrackGhost(const GameCommands::TrackPlacementArgs& args); static void sub_4A193B(); static void updateConstructionArrow() { _cState->constructionArrowFrameNum = _cState->constructionArrowFrameNum - 1; if (_cState->constructionArrowFrameNum == 0xFF) { _cState->constructionArrowFrameNum = 5; _ghostVisibilityFlags = _ghostVisibilityFlags ^ GhostVisibilityFlags::constructArrow; _constructionArrowPos = World::Pos3(_cState->x, _cState->y, _cState->constructionZ); _constructionArrowDirection = _cState->constructionRotation; World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstructionArrow); if ((_ghostVisibilityFlags & GhostVisibilityFlags::constructArrow) != GhostVisibilityFlags::none) { World::setMapSelectionFlags(World::MapSelectionFlags::enableConstructionArrow); } World::TileManager::mapInvalidateTileFull(World::Pos2(_cState->x, _cState->y)); } } // 0x0049FD66 // Places/removes the ghost, gets price, resets active widgets, updates the construction arrow // Ideally only construction arrow should be updated here the reason for doing the rest every update // instead of only in toolUpdate is unknown (but probably just to catch edge cases) static void updateConstruction() { if (_cState->constructionHover != 0) { return; } if ((_ghostVisibilityFlags & GhostVisibilityFlags::track) == GhostVisibilityFlags::none) { if (_cState->trackType & (1 << 7)) { auto args = getRoadPlacementArgs(World::Pos3(_cState->x, _cState->y, _cState->constructionZ), _cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (args) { _cState->trackCost = placeRoadGhost(*args); _cState->byte_1136076 = _cState->byte_1136073; sub_4A193B(); activateSelectedConstructionWidgets(); } else { removeTrackGhosts(); } } else { auto args = getTrackPlacementArgs(World::Pos3(_cState->x, _cState->y, _cState->constructionZ), _cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (args) { _cState->trackCost = placeTrackGhost(*args); _cState->byte_1136076 = _cState->byte_1136073; sub_4A193B(); activateSelectedConstructionWidgets(); } else { removeTrackGhosts(); } } } updateConstructionArrow(); } // 0x0049DCA2 static void onUpdate(Window& self) { self.frameNo++; self.callPrepareDraw(); WindowManager::invalidate(WindowType::construction, self.number); if (_cState->constructionHover == 1) { if (!ToolManager::isToolActive(WindowType::construction, self.number) || ToolManager::getToolWidgetIndex() != widx::construct) { WindowManager::close(&self); } } if (_cState->constructionHover == 0) { if (ToolManager::isToolActive(WindowType::construction, self.number)) { ToolManager::toolCancel(); } } updateConstruction(); } // Simplified TileManager::getHeight that only considers flat height static std::optional<World::TileHeight> getConstructionHeight(const Pos2& mapPos) { auto tile = TileManager::get(mapPos); auto surfaceTile = tile.surface(); if (surfaceTile == nullptr) { return std::nullopt; } World::TileHeight height = { static_cast<coord_t>(surfaceTile->baseHeight()), surfaceTile->waterHeight() }; if (surfaceTile->slopeCorners()) { height.landHeight += 16; } if (surfaceTile->isSlopeDoubleHeight()) { height.landHeight += 16; } return { height }; } // 0x00478361 static std::optional<int16_t> getExistingRoadAtLoc(int16_t x, int16_t y) { static loco_global<Viewport*, 0x01135F52> _1135F52; auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::roadAndTram)); _1135F52 = viewport; if (interaction.type != ViewportInteraction::InteractionItem::road) { return std::nullopt; } const auto* elTrack = reinterpret_cast<World::TileElement*>(interaction.object)->as<RoadElement>(); if (elTrack == nullptr) { return std::nullopt; } const auto& roadPieces = TrackData::getRoadPiece(elTrack->roadId()); const auto& roadPiece = roadPieces[elTrack->sequenceIndex()]; const auto startHeight = elTrack->baseHeight() - roadPiece.z; return { startHeight }; } // 0x004A4011 static std::optional<std::pair<int16_t, int16_t>> getExistingTrackAtLoc(int16_t x, int16_t y) { static loco_global<Viewport*, 0x01135F52> _1135F52; auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::track)); _1135F52 = viewport; if (interaction.type != ViewportInteraction::InteractionItem::track) { return std::nullopt; } const auto* elTrack = reinterpret_cast<World::TileElement*>(interaction.object)->as<TrackElement>(); if (elTrack == nullptr) { return std::nullopt; } const auto& trackPieces = TrackData::getTrackPiece(elTrack->trackId()); const auto& trackPiece = trackPieces[elTrack->sequenceIndex()]; const auto startHeight = elTrack->baseHeight() - trackPiece.z; return { std::make_pair(startHeight, elTrack->trackId()) }; } static void constructionLoop(const Pos2& mapPos, uint32_t maxRetries, int16_t height) { while (true) { _cState->constructionHover = 0; _cState->byte_113607E = 0; _cState->x = mapPos.x; _cState->y = mapPos.y; _cState->constructionZ = height; _ghostVisibilityFlags = GhostVisibilityFlags::none; _cState->constructionArrowFrameNum = 0; activateSelectedConstructionWidgets(); auto window = WindowManager::find(WindowType::construction); // Attempt to place track piece -- in silence _suppressErrorSound = true; onMouseUp(*window, widx::construct, WidgetId::none); _suppressErrorSound = false; if (_cState->dword_1135F42 != 0x80000000) { _cState->byte_113607E = 1; WindowManager::close(WindowType::error, 0); return; } if (GameCommands::getErrorText() != StringIds::error_can_only_build_above_ground) { maxRetries--; if (maxRetries != 0) { height -= 16; if (height >= 0) { if (!Input::hasKeyModifier(Input::KeyModifier::shift)) { height += 32; } continue; } } } // Failed to place track piece -- rotate and make error sound onMouseUp(*window, widx::rotate_90, WidgetId::none); Audio::playSound(Audio::SoundId::error, int32_t(Input::getMouseLocation().x)); return; } } // 0 if nothing currently selected static int16_t getMaxConstructHeightFromExistingSelection() { int16_t maxHeight = 0; if (World::hasMapSelectionFlag(World::MapSelectionFlags::enableConstruct)) { for (const auto& tile : getMapSelectionFreeFormTiles()) { if (!World::validCoords(tile)) { continue; } const auto tileHeight = getConstructionHeight(tile); if (!tileHeight) { continue; } maxHeight = std::max(tileHeight->landHeight, maxHeight); if (tileHeight->waterHeight) { // Constructing over water is always +16 maxHeight = std::max<int16_t>(tileHeight->waterHeight + 16, maxHeight); } } } return maxHeight; } static std::optional<std::pair<World::TilePos2, int16_t>> tryMakeRoadJunctionAtLoc(const int16_t x, const int16_t y) { const auto existingRoad = getExistingRoadAtLoc(x, y); if (existingRoad) { const auto& existingHeight = *existingRoad; const auto mapPos = screenGetMapXyWithZ(Point(x, y), existingHeight); if (mapPos) { return { std::make_pair(World::toTileSpace(*mapPos), existingHeight) }; } } return std::nullopt; } static std::optional<std::pair<World::TilePos2, int16_t>> tryMakeTrackJunctionAtLoc(const int16_t x, const int16_t y) { const auto existingTrack = getExistingTrackAtLoc(x, y); if (existingTrack) { const auto [existingHeight, existingTrackId] = *existingTrack; if (TrackData::getUnkTrack(existingTrackId << 3).pos.z == 0) { const auto mapPos = screenGetMapXyWithZ(Point(x, y), existingHeight); if (mapPos) { return { std::make_pair(World::toTileSpace(*mapPos), existingHeight) }; } } } return std::nullopt; } static std::optional<std::pair<World::TilePos2, int16_t>> getConstructionPos(const int16_t x, const int16_t y, const int16_t baseHeight = std::numeric_limits<int16_t>::max()) { auto mapPos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); if (!mapPos) { return std::nullopt; } auto tileHeight = getConstructionHeight(*mapPos); if (!tileHeight) { return std::nullopt; } auto height = std::min(tileHeight->landHeight, baseHeight); height = std::max(height, tileHeight->waterHeight); return { std::make_pair(World::toTileSpace(*mapPos), height) }; } static int16_t getMinPieceHeight(const std::span<const TrackData::PreviewTrack> piece) { return std::ranges::min_element(piece, {}, &TrackData::PreviewTrack::z)->z; } // 0x004A193B static void sub_4A193B() { for (const auto bridgeType : _cState->bridgeList) { if (bridgeType == 0xFF) { return; } if (_cState->byte_1136075 == bridgeType) { _cState->lastSelectedBridge = bridgeType; return; } } } // 0x004A006C void removeTrackGhosts() { if ((_ghostVisibilityFlags & GhostVisibilityFlags::track) != GhostVisibilityFlags::none) { if (_ghostRemovalTrackObjectId & (1 << 7)) { GameCommands::RoadRemovalArgs args; args.pos = _cState->ghostRemovalTrackPos; args.pos.z += TrackData::getRoadPiece(_cState->ghostRemovalTrackId)[0].z; args.rotation = _cState->ghostRemovalTrackRotation & 3; args.sequenceIndex = 0; args.roadId = _cState->ghostRemovalTrackId; args.objectId = _ghostRemovalTrackObjectId & ~(1 << 7); GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } else { GameCommands::TrackRemovalArgs args; args.pos = _cState->ghostRemovalTrackPos; args.pos.z += TrackData::getTrackPiece(_cState->ghostRemovalTrackId)[0].z; args.rotation = _cState->ghostRemovalTrackRotation & 3; args.index = 0; args.trackId = _cState->ghostRemovalTrackId; args.trackObjectId = _ghostRemovalTrackObjectId; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } _ghostVisibilityFlags = _ghostVisibilityFlags & ~GhostVisibilityFlags::track; } } // 0x0049FB63 static uint32_t placeTrackGhost(const GameCommands::TrackPlacementArgs& args) { removeTrackGhosts(); const auto res = GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res == GameCommands::FAILURE) { if (GameCommands::getErrorText() == StringIds::bridge_type_unsuitable_for_this_configuration) { _cState->byte_113603A = 0; for (const auto bridgeType : _cState->bridgeList) { if (bridgeType == 0xFF) { break; } const auto* bridgeObj = ObjectManager::get<BridgeObject>(bridgeType); if ((bridgeObj->disabledTrackCfg & TrackData::getTrackMiscData(args.trackId).flags) != Track::CommonTraitFlags::none) { continue; } if (bridgeType == _cState->lastSelectedBridge) { break; } auto newArgs(args); newArgs.bridge = bridgeType; _cState->lastSelectedBridge = bridgeType; WindowManager::invalidate(WindowType::construction); return placeTrackGhost(args); } } } else { _cState->ghostRemovalTrackPos = args.pos; _cState->ghostRemovalTrackId = args.trackId; _ghostRemovalTrackObjectId = args.trackObjectId; _cState->ghostRemovalTrackRotation = args.rotation; _ghostVisibilityFlags = GhostVisibilityFlags::track | *_ghostVisibilityFlags; const auto newViewState = (_cState->byte_1136072 & (1 << 1)) ? WindowManager::ViewportVisibility::undergroundView : WindowManager::ViewportVisibility::overgroundView; WindowManager::viewportSetVisibility(newViewState); if (_cState->lastSelectedTrackGradient != 0) { WindowManager::viewportSetVisibility(WindowManager::ViewportVisibility::heightMarksOnTrack); } } _cState->byte_113603A = 0; return res; } // 0x0049FC60 static uint32_t placeRoadGhost(const GameCommands::RoadPlacementArgs& args) { removeTrackGhosts(); const auto res = GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res == GameCommands::FAILURE) { if (GameCommands::getErrorText() == StringIds::bridge_type_unsuitable_for_this_configuration) { _cState->byte_113603A = 0; for (const auto bridgeType : _cState->bridgeList) { if (bridgeType == 0xFF) { break; } const auto* bridgeObj = ObjectManager::get<BridgeObject>(bridgeType); if ((bridgeObj->disabledTrackCfg & TrackData::getRoadMiscData(args.roadId).flags) != Track::CommonTraitFlags::none) { continue; } if (bridgeType == _cState->lastSelectedBridge) { break; } auto newArgs(args); newArgs.bridge = bridgeType; _cState->lastSelectedBridge = bridgeType; WindowManager::invalidate(WindowType::construction); return placeRoadGhost(args); } } } else { _cState->ghostRemovalTrackPos = args.pos; _cState->ghostRemovalTrackId = args.roadId; _ghostRemovalTrackObjectId = args.roadObjectId | (1 << 7); _cState->ghostRemovalTrackRotation = args.rotation; _ghostVisibilityFlags = GhostVisibilityFlags::track | *_ghostVisibilityFlags; const auto newViewState = (_cState->byte_1136072 & (1 << 1)) ? WindowManager::ViewportVisibility::undergroundView : WindowManager::ViewportVisibility::overgroundView; WindowManager::viewportSetVisibility(newViewState); if (_cState->lastSelectedTrackGradient != 0) { WindowManager::viewportSetVisibility(WindowManager::ViewportVisibility::heightMarksOnTrack); } } _cState->byte_113603A = 0; return res; } static std::optional<GameCommands::TrackPlacementArgs> getTrackPlacementArgs(const World::Pos3& pos, const uint8_t trackPiece, const uint8_t gradient, const uint8_t rotation) { auto trackId = getTrackPieceId(trackPiece, gradient, rotation); if (!trackId) { return std::nullopt; } GameCommands::TrackPlacementArgs args; args.pos = pos; args.bridge = _cState->lastSelectedBridge; args.mods = _cState->lastSelectedMods; args.rotation = trackId->rotation; args.trackObjectId = _cState->trackType; args.trackId = trackId->id; args.unk = _cState->byte_113607E & (1 << 0); args.unkFlags = 0; return args; } static std::optional<GameCommands::RoadPlacementArgs> getRoadPlacementArgs(const World::Pos3& pos, const uint8_t trackPiece, const uint8_t gradient, const uint8_t rotation) { auto roadId = getRoadPieceId(trackPiece, gradient, rotation); if (!roadId) { return std::nullopt; } GameCommands::RoadPlacementArgs args; args.pos = pos; args.bridge = _cState->lastSelectedBridge; args.mods = _cState->lastSelectedMods; args.rotation = roadId->rotation; args.roadObjectId = _cState->trackType & ~(1 << 7); args.roadId = roadId->id; args.unkFlags = 0; return args; } template<typename GetPlacementArgsFunc, typename PlaceGhostFunc> static void constructionGhostLoop(const Pos3& mapPos, uint32_t maxRetries, GetPlacementArgsFunc&& getPlacementArgs, PlaceGhostFunc&& placeGhost) { _cState->x = mapPos.x; _cState->y = mapPos.y; _cState->constructionZ = mapPos.z; if ((_ghostVisibilityFlags & GhostVisibilityFlags::track) != GhostVisibilityFlags::none) { if (_cState->ghostTrackPos == mapPos) { return; } } _cState->ghostTrackPos = mapPos; auto args = getPlacementArgs(mapPos, _cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!args) { return; } while (true) { auto res = placeGhost(*args); _cState->trackCost = res; _cState->byte_1136076 = _cState->byte_1136073; sub_4A193B(); if (_cState->trackCost == 0x80000000) { maxRetries--; if (maxRetries != 0) { args->pos.z -= 16; if (args->pos.z >= 0) { if (Input::hasKeyModifier(Input::KeyModifier::shift)) { continue; } else { args->pos.z += 32; continue; } } } } activateSelectedConstructionWidgets(); return; } } // 0x004A1968 template<typename TGetPieceId, typename TTryMakeJunction, typename TGetPiece, typename GetPlacementArgsFunc, typename PlaceGhostFunc> static void onToolUpdateSingle(const int16_t x, const int16_t y, TGetPieceId&& getPieceId, TTryMakeJunction&& tryMakeJunction, TGetPiece&& getPiece, GetPlacementArgsFunc&& getPlacementArgs, PlaceGhostFunc&& placeGhost) { World::mapInvalidateMapSelectionFreeFormTiles(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable | World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); Pos2 constructPos; int16_t constructHeight = 0; const auto junctionRes = tryMakeJunction(x, y); if (junctionRes) { constructPos = World::toWorldSpace(junctionRes->first); constructHeight = junctionRes->second; _cState->makeJunction = 1; } else { const auto constRes = getConstructionPos(x, y); if (!constRes) { return; } constructPos = World::toWorldSpace(constRes->first); constructHeight = constRes->second; _cState->makeJunction = 0; } World::setMapSelectionFlags(World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); World::resetMapSelectionFlag(World::MapSelectionFlags::unk_03); _constructionArrowPos = World::Pos3(constructPos.x, constructPos.y, constructHeight); _constructionArrowDirection = _cState->constructionRotation; resetMapSelectionFreeFormTiles(); addMapSelectionFreeFormTile(constructPos); auto pieceId = getPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!pieceId) { removeConstructionGhosts(); World::mapInvalidateMapSelectionFreeFormTiles(); return; } _cState->byte_1136065 = pieceId->id; const auto trackPieces = getPiece(pieceId->id); setMapSelectedTilesFromPiece(trackPieces, constructPos, _cState->constructionRotation); if (_cState->makeJunction != 1) { constructHeight = std::max(getMaxConstructHeightFromExistingSelection(), constructHeight); } constructHeight -= getMinPieceHeight(trackPieces); _constructionArrowPos->z = constructHeight; constructHeight -= 16; auto maxRetries = 2; if (Input::hasKeyModifier(Input::KeyModifier::shift)) { maxRetries = 0x80000008; constructHeight -= 16; _constructionArrowPos->z = constructHeight; } constructionGhostLoop({ constructPos.x, constructPos.y, constructHeight }, maxRetries, getPlacementArgs, placeGhost); World::mapInvalidateMapSelectionFreeFormTiles(); } // 0x0049DC8C static void onToolUpdate([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::construct) { return; } if (_isDragging) { mapInvalidateMapSelectionFreeFormTiles(); removeConstructionGhosts(); return; } if (_cState->trackType & (1 << 7)) { onToolUpdateSingle(x, y, getRoadPieceId, tryMakeRoadJunctionAtLoc, TrackData::getRoadPiece, getRoadPlacementArgs, placeRoadGhost); } else { onToolUpdateSingle(x, y, getTrackPieceId, tryMakeTrackJunctionAtLoc, TrackData::getTrackPiece, getTrackPlacementArgs, placeTrackGhost); } } static void onToolDown([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::surface | ViewportInteraction::InteractionItemFlags::water)); auto& interaction = res.first; if (interaction.type == ViewportInteraction::InteractionItem::noInteraction) { return; } _toolPosInitial = World::toTileSpace(interaction.pos); _isDragging = false; } static void onToolDrag([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { mapInvalidateSelectionRect(); removeConstructionGhosts(); auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::surface | ViewportInteraction::InteractionItemFlags::water)); auto& interaction = res.first; if (interaction.type == ViewportInteraction::InteractionItem::noInteraction) { return; } _toolPosDrag = World::toTileSpace(interaction.pos); _isDragging = _toolPosInitial != _toolPosDrag; if (!_isDragging) { return; } setMapSelectionFlags(MapSelectionFlags::enable); setMapSelectionCorner(MapSelectionType::full); setMapSelectionArea(toWorldSpace(_toolPosInitial), toWorldSpace(_toolPosDrag)); mapInvalidateSelectionRect(); } template<typename TGetPieceId, typename TTryMakeJunction, typename TGetPiece> static void onToolUpSingle(const int16_t x, const int16_t y, TGetPieceId&& getPieceId, TTryMakeJunction&& tryMakeJunction, TGetPiece&& getPiece) { mapInvalidateMapSelectionFreeFormTiles(); removeConstructionGhosts(); auto pieceId = getPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); if (!pieceId) { return; } _cState->byte_1136065 = pieceId->id; int16_t constructHeight = getMaxConstructHeightFromExistingSelection(); _cState->word_1136000 = constructHeight; World::resetMapSelectionFlag(World::MapSelectionFlags::enable | World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); Pos2 constructPos; const auto junctionRes = tryMakeJunction(x, y); if (junctionRes) { constructPos = World::toWorldSpace(junctionRes->first); _cState->makeJunction = 1; _cState->word_1135FFE = junctionRes->second; } else { const auto constRes = getConstructionPos(x, y, _cState->word_1136000); if (!constRes) { return; } constructPos = World::toWorldSpace(constRes->first); constructHeight = std::max(constructHeight, constRes->second); _cState->makeJunction = 0; } ToolManager::toolCancel(); auto maxRetries = 0; if (Input::hasKeyModifier(Input::KeyModifier::shift) || _cState->makeJunction != 1) { const auto piece = getPiece(_cState->byte_1136065); constructHeight -= getMinPieceHeight(piece); constructHeight -= 16; maxRetries = 2; if (Input::hasKeyModifier(Input::KeyModifier::shift)) { maxRetries = 0x80000008; constructHeight -= 16; } } else { maxRetries = 1; constructHeight = _cState->word_1135FFE; } // Height should never go negative constructHeight = std::max<int16_t>(0, constructHeight); constructionLoop(constructPos, maxRetries, constructHeight); } static void onToolUpMultiple(Window& self, const WidgetIndex_t widgetIndex) { mapInvalidateSelectionRect(); removeConstructionGhosts(); World::resetMapSelectionFlags(); auto rotation = _cState->constructionRotation; auto piece = _cState->lastSelectedTrackPiece; auto dirX = _toolPosDrag.x - _toolPosInitial.x > 0 ? 1 : -1; auto dirY = _toolPosDrag.y - _toolPosInitial.y > 0 ? 1 : -1; bool builtAnything = false; for (auto yPos = _toolPosInitial.y; yPos != _toolPosDrag.y + dirY; yPos += dirY) { for (auto xPos = _toolPosInitial.x; xPos != _toolPosDrag.x + dirX; xPos += dirX) { auto pos = World::toWorldSpace({ xPos, yPos }); _cState->x = pos.x; _cState->y = pos.y; auto height = TileManager::getHeight(pos); _cState->constructionZ = height.landHeight; // Try placing the track at this location, ignoring errors if they occur _suppressErrorSound = true; constructTrackOrRoad(&self, widgetIndex); _suppressErrorSound = false; builtAnything |= _cState->dword_1135F42 != GameCommands::FAILURE; // Prevent automatic track advancement when constructing track _cState->constructionRotation = rotation; _cState->lastSelectedTrackPiece = piece; } } if (builtAnything) { WindowManager::close(WindowType::error); } // Leave the tool active, but make ghost piece visible for the next round _isDragging = false; } // 0x0049DC97 static void onToolUp(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::construct) { return; } if (_isDragging) { onToolUpMultiple(self, widgetIndex); } else if (_cState->trackType & (1 << 7)) { onToolUpSingle(x, y, getRoadPieceId, tryMakeRoadJunctionAtLoc, TrackData::getRoadPiece); } else { onToolUpSingle(x, y, getTrackPieceId, tryMakeTrackJunctionAtLoc, TrackData::getTrackPiece); } } static void onToolAbort([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex != widx::construct) { return; } _isDragging = false; } // 0x0049D4F5 static Ui::CursorId cursor([[maybe_unused]] Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] int16_t xPos, [[maybe_unused]] int16_t yPos, Ui::CursorId fallback) { if (widgetIndex == widx::bridge || widgetIndex == widx::bridge_dropdown) { Ui::ToolTip::setTooltipTimeout(2000); } return fallback; } // 0x0049CE79 static void prepareDraw(Window& self) { Common::prepareDraw(&self); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); if (_cState->trackType & (1 << 7)) { auto roadObj = ObjectManager::get<RoadObject>(_cState->trackType & ~(1 << 7)); args.push(roadObj->name); } else { auto trackObj = ObjectManager::get<TrackObject>(_cState->trackType); args.push(trackObj->name); } Common::repositionTabs(&self); } static std::optional<FormatArguments> tooltip(Ui::Window&, WidgetIndex_t, [[maybe_unused]] const WidgetId id) { FormatArguments args{}; args.skip(2); if (_cState->lastSelectedBridge != 0xFF) { auto bridgeObj = ObjectManager::get<BridgeObject>(_cState->lastSelectedBridge); if (bridgeObj != nullptr) { args.push(bridgeObj->name); if (bridgeObj->maxSpeed == kSpeed16Null) { args.push(StringIds::unlimited_speed); args.push<uint16_t>(0); } else { args.push(StringIds::velocity); args.push(bridgeObj->maxSpeed); } args.push<uint16_t>(bridgeObj->maxHeight); } } return args; } // 0x004A0AE5 void drawTrack(const World::Pos3& pos, uint16_t selectedMods, uint8_t trackType, uint8_t trackPieceId, uint8_t direction, Gfx::DrawingContext& drawingCtx) { const auto backupSelectionFlags = World::getMapSelectionFlags(); const World::Pos3 backupConstructionArrowPos = _constructionArrowPos; const uint8_t backupConstructionArrowDir = _constructionArrowDirection; World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstructionArrow); if (_byte_522095 & (1 << 1)) { World::setMapSelectionFlags(World::MapSelectionFlags::enableConstructionArrow); _constructionArrowPos = pos; _constructionArrowDirection = direction; } const auto* trackObj = ObjectManager::get<TrackObject>(trackType); // Remove any none compatible track mods for (auto mod = 0; mod < 4; ++mod) { if (selectedMods & (1 << mod)) { const auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[mod]); if ((trackExtraObj->trackPieces & TrackData::getTrackMiscData(trackPieceId).compatibleFlags) != TrackData::getTrackMiscData(trackPieceId).compatibleFlags) { selectedMods &= ~(1 << mod); } } } const auto& trackPieces = TrackData::getTrackPiece(trackPieceId); const auto trackDirection = direction & 3; World::TileElement backupTileElements[5] = {}; World::SurfaceElement previewSideSurfaceTileElement{ 255, 255, 0xF, true }; previewSideSurfaceTileElement.setLastFlag(true); Paint::SessionOptions options{}; options.rotation = WindowManager::getCurrentRotation(); auto session = Paint::PaintSession(drawingCtx.currentRenderTarget(), options); for (const auto& trackPiece : trackPieces) { const auto pieceOffset = World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, trackDirection), trackPiece.z }; const auto quarterTile = trackPiece.subTileClearance.rotate(trackDirection); const auto trackPos = pos + pieceOffset; const auto baseZ = trackPos.z / kSmallZStep; const auto clearZ = baseZ + (trackPiece.clearZ + 32) / kSmallZStep; const auto centreTileCoords = World::toTileSpace(trackPos); const auto eastTileCoords = centreTileCoords + World::toTileSpace(World::kOffsets[1]); const auto westTileCoords = centreTileCoords - World::toTileSpace(World::kOffsets[1]); const auto northTileCoords = centreTileCoords + World::toTileSpace(World::kOffsets[3]); const auto southTileCoords = centreTileCoords - World::toTileSpace(World::kOffsets[3]); // Copy map elements which will be replaced with temporary ones containing track backupTileElements[0] = *World::TileManager::get(centreTileCoords)[0]; backupTileElements[1] = *World::TileManager::get(eastTileCoords)[0]; backupTileElements[2] = *World::TileManager::get(westTileCoords)[0]; backupTileElements[3] = *World::TileManager::get(northTileCoords)[0]; backupTileElements[4] = *World::TileManager::get(southTileCoords)[0]; // Set the temporary track element World::TrackElement newTrackEl(baseZ, clearZ, trackDirection, quarterTile.getBaseQuarterOccupied(), trackPiece.index, trackType, trackPieceId, std::nullopt, CompanyManager::getControllingId(), selectedMods); newTrackEl.setLastFlag(true); // Replace map elements with temp ones *World::TileManager::get(centreTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&newTrackEl); *World::TileManager::get(eastTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); *World::TileManager::get(westTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); *World::TileManager::get(northTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); *World::TileManager::get(southTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); // Draw this map tile Paint::paintTileElements(session, trackPos); // Restore map elements *World::TileManager::get(centreTileCoords)[0] = backupTileElements[0]; *World::TileManager::get(eastTileCoords)[0] = backupTileElements[1]; *World::TileManager::get(westTileCoords)[0] = backupTileElements[2]; *World::TileManager::get(northTileCoords)[0] = backupTileElements[3]; *World::TileManager::get(southTileCoords)[0] = backupTileElements[4]; } session.arrangeStructs(); session.drawStructs(drawingCtx); // setMapSelectionFlags OR's flags so reset them to zero to set the backup World::resetMapSelectionFlags(); World::setMapSelectionFlags(backupSelectionFlags); _constructionArrowPos = backupConstructionArrowPos; _constructionArrowDirection = backupConstructionArrowDir; } // 0x00478F1F void drawRoad(const World::Pos3& pos, uint16_t selectedMods, uint8_t roadType, uint8_t roadPieceId, uint8_t direction, Gfx::DrawingContext& drawingCtx) { const auto backupSelectionFlags = World::getMapSelectionFlags(); const World::Pos3 backupConstructionArrowPos = _constructionArrowPos; const uint8_t backupConstructionArrowDir = _constructionArrowDirection; World::resetMapSelectionFlag(World::MapSelectionFlags::enableConstructionArrow); if (_byte_522095 & (1 << 1)) { World::setMapSelectionFlags(World::MapSelectionFlags::enableConstructionArrow); _constructionArrowPos = pos; _constructionArrowDirection = direction; } const auto* roadObj = ObjectManager::get<RoadObject>(roadType); // Remove any none compatible road mods for (auto mod = 0; mod < 2; ++mod) { if (selectedMods & (1 << mod)) { const auto* roadExtraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[mod]); if ((roadExtraObj->roadPieces & TrackData::getRoadMiscData(roadPieceId).compatibleFlags) != TrackData::getRoadMiscData(roadPieceId).compatibleFlags) { selectedMods &= ~(1 << mod); } } } const auto& roadPieces = TrackData::getRoadPiece(roadPieceId); const auto roadDirection = direction & 3; World::TileElement backupTileElements[5] = {}; World::SurfaceElement previewSideSurfaceTileElement{ 255, 255, 0xF, true }; previewSideSurfaceTileElement.setLastFlag(true); Paint::SessionOptions options{}; options.rotation = WindowManager::getCurrentRotation(); auto session = Paint::PaintSession(drawingCtx.currentRenderTarget(), options); for (const auto& roadPiece : roadPieces) { const auto pieceOffset = World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece.x, roadPiece.y }, roadDirection), roadPiece.z }; const auto quarterTile = roadPiece.subTileClearance.rotate(roadDirection); const auto trackPos = pos + pieceOffset; const auto baseZ = trackPos.z / kSmallZStep; const auto clearZ = baseZ + (roadPiece.clearZ + 32) / kSmallZStep; const auto centreTileCoords = World::toTileSpace(trackPos); const auto eastTileCoords = centreTileCoords + World::toTileSpace(World::kOffsets[1]); const auto westTileCoords = centreTileCoords - World::toTileSpace(World::kOffsets[1]); const auto northTileCoords = centreTileCoords + World::toTileSpace(World::kOffsets[3]); const auto southTileCoords = centreTileCoords - World::toTileSpace(World::kOffsets[3]); // Copy map elements which will be replaced with temporary ones containing road backupTileElements[0] = *World::TileManager::get(centreTileCoords)[0]; backupTileElements[1] = *World::TileManager::get(eastTileCoords)[0]; backupTileElements[2] = *World::TileManager::get(westTileCoords)[0]; backupTileElements[3] = *World::TileManager::get(northTileCoords)[0]; backupTileElements[4] = *World::TileManager::get(southTileCoords)[0]; // Set the temporary road element World::RoadElement newRoadEl(baseZ, clearZ); newRoadEl.setRotation(roadDirection); newRoadEl.setSequenceIndex(roadPiece.index); newRoadEl.setRoadObjectId(roadType); newRoadEl.setRoadId(roadPieceId); newRoadEl.setMods(selectedMods); newRoadEl.setOccupiedQuarter(quarterTile.getBaseQuarterOccupied()); newRoadEl.setOwner(CompanyManager::getControllingId()); newRoadEl.setLastFlag(true); // Replace map elements with temp ones *World::TileManager::get(centreTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&newRoadEl); *World::TileManager::get(eastTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); *World::TileManager::get(westTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); *World::TileManager::get(northTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); *World::TileManager::get(southTileCoords)[0] = *reinterpret_cast<World::TileElement*>(&previewSideSurfaceTileElement); // Draw this map tile Paint::paintTileElements(session, trackPos); // Restore map elements *World::TileManager::get(centreTileCoords)[0] = backupTileElements[0]; *World::TileManager::get(eastTileCoords)[0] = backupTileElements[1]; *World::TileManager::get(westTileCoords)[0] = backupTileElements[2]; *World::TileManager::get(northTileCoords)[0] = backupTileElements[3]; *World::TileManager::get(southTileCoords)[0] = backupTileElements[4]; } session.arrangeStructs(); session.drawStructs(drawingCtx); // setMapSelectionFlags OR's flags so reset them to zero to set the backup World::resetMapSelectionFlags(); World::setMapSelectionFlags(backupSelectionFlags); _constructionArrowPos = backupConstructionArrowPos; _constructionArrowDirection = backupConstructionArrowDir; } // 0x0049D38A and 0x0049D16B static void drawCostString(Window* self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); auto x = self->widgets[widx::construct].midX(); x += self->x; auto y = self->widgets[widx::construct].bottom + self->y - 23; if (_cState->constructionHover != 1) { tr.drawStringCentred(Point(x, y), Colour::black, StringIds::build_this); } y += 11; if (_cState->trackCost != 0x80000000) { if (_cState->trackCost != 0) { FormatArguments args{}; args.push<uint32_t>(_cState->trackCost); tr.drawStringCentred(Point(x, y), Colour::black, StringIds::build_cost, args); } } } // 0x0049D106 static void drawTrackCost(Window* self, Gfx::RenderTarget* clipped, Gfx::DrawingContext& drawingCtx, Point pos, uint16_t width, uint16_t height) { width >>= 1; height >>= 1; height += 16; pos.x -= width; pos.y -= height; clipped->x += pos.x; clipped->y += pos.y; _byte_522095 = _byte_522095 | (1 << 1); drawingCtx.pushRenderTarget(*clipped); drawTrack( World::Pos3(256 * World::kTileSize, 256 * World::kTileSize, 120 * World::kSmallZStep), _cState->word_1135FD8, _cState->byte_1136077, _cState->lastSelectedTrackPieceId, _cState->byte_1136078, drawingCtx); drawingCtx.popRenderTarget(); _byte_522095 = _byte_522095 & ~(1 << 1); drawCostString(self, drawingCtx); } // 0x0049D325 static void drawRoadCost(Window* self, Gfx::RenderTarget* clipped, Gfx::DrawingContext& drawingCtx, Point pos, uint16_t width, uint16_t height) { width >>= 1; height >>= 1; height += 16; pos.x -= width; pos.y -= height; clipped->x += pos.x; clipped->y += pos.y; _byte_522095 = _byte_522095 | (1 << 1); drawingCtx.pushRenderTarget(*clipped); drawRoad( World::Pos3(256 * World::kTileSize, 256 * World::kTileSize, 120 * World::kSmallZStep), _cState->word_1135FD8, _cState->byte_1136077, _cState->lastSelectedTrackPieceId, _cState->byte_1136078, drawingCtx); drawingCtx.popRenderTarget(); _byte_522095 = _byte_522095 & ~(1 << 1); drawCostString(self, drawingCtx); } // 0x0049CF36 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); if (!self.widgets[widx::bridge].hidden) { if (_cState->lastSelectedBridge != 0xFF) { auto bridgeObj = ObjectManager::get<BridgeObject>(_cState->lastSelectedBridge); if (bridgeObj != nullptr) { auto company = CompanyManager::getPlayerCompany(); auto imageId = Gfx::recolour(bridgeObj->image, company->mainColours.primary); auto x = self.x + self.widgets[widx::bridge].left + 2; auto y = self.y + self.widgets[widx::bridge].top + 1; drawingCtx.drawImage(x, y, imageId); } } } if (self.widgets[widx::construct].hidden) { return; } if (_cState->trackType & (1 << 7)) { auto road = getRoadPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); _cState->word_1135FD8 = _cState->lastSelectedMods; if (!road) { return; } _cState->byte_1136077 = _cState->trackType & ~(1 << 7); _cState->byte_1136078 = road->rotation; _cState->lastSelectedTrackPieceId = road->id; _cState->word_1135FD6 = (_cState->lastSelectedBridge << 8) & 0x1F; auto x = self.x + self.widgets[widx::construct].left + 1; auto y = self.y + self.widgets[widx::construct].top + 1; auto width = self.widgets[widx::construct].width(); auto height = self.widgets[widx::construct].height(); const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (clipped) { const auto& roadPiece = World::TrackData::getRoadPiece(_cState->lastSelectedTrackPieceId); const auto& lastRoadPart = roadPiece.back(); Pos3 pos3D = { lastRoadPart.x, lastRoadPart.y, lastRoadPart.z }; if (lastRoadPart.hasFlags(World::TrackData::PreviewTrackFlags::unused)) { pos3D.x = 0; pos3D.y = 0; } auto rotatedPos = Math::Vector::rotate(pos3D, _cState->byte_1136078 & 3); pos3D.x = rotatedPos.x / 2; pos3D.y = rotatedPos.y / 2; pos3D.x += 0x2010; pos3D.y += 0x2010; pos3D.z += 0x1CC; auto pos2D = gameToScreen(pos3D, WindowManager::getCurrentRotation()); Point pos = { pos2D.x, pos2D.y }; drawRoadCost(&self, &*clipped, drawingCtx, pos, width, height); } else { drawCostString(&self, drawingCtx); } } else { auto track = getTrackPieceId(_cState->lastSelectedTrackPiece, _cState->lastSelectedTrackGradient, _cState->constructionRotation); _cState->word_1135FD8 = _cState->lastSelectedMods; if (!track) { return; } _cState->byte_1136077 = _cState->trackType; _cState->byte_1136078 = track->rotation; _cState->lastSelectedTrackPieceId = track->id; _cState->word_1135FD6 = (_cState->lastSelectedBridge << 8) & 0x1F; auto x = self.x + self.widgets[widx::construct].left + 1; auto y = self.y + self.widgets[widx::construct].top + 1; auto width = self.widgets[widx::construct].width(); auto height = self.widgets[widx::construct].height(); const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x, y, width, height)); if (clipped) { const auto& trackPiece = World::TrackData::getTrackPiece(_cState->lastSelectedTrackPieceId); const auto& lastTrackPart = trackPiece.back(); Pos3 pos3D = { lastTrackPart.x, lastTrackPart.y, lastTrackPart.z }; if (lastTrackPart.hasFlags(World::TrackData::PreviewTrackFlags::unused)) { pos3D.x = 0; pos3D.y = 0; } auto rotatedPos = Math::Vector::rotate(pos3D, _cState->byte_1136078 & 3); pos3D.x = rotatedPos.x / 2; pos3D.y = rotatedPos.y / 2; pos3D.x += 0x2010; pos3D.y += 0x2010; pos3D.z += 0x1CC; auto pos2D = gameToScreen(pos3D, WindowManager::getCurrentRotation()); Point pos = { pos2D.x, pos2D.y }; drawTrackCost(&self, &*clipped, drawingCtx, pos, width, height); } else { drawCostString(&self, drawingCtx); } } } void tabReset(Window& self) { if (_cState->constructionHover != 0) { _cState->constructionHover = 0; _cState->byte_113607E = 1; self.callOnMouseUp(widx::rotate_90, self.widgets[widx::rotate_90].id); } } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onResize = onResize, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .toolDrag = onToolDrag, .toolUp = onToolUp, .onToolAbort = onToolAbort, .tooltip = tooltip, .cursor = cursor, .prepareDraw = prepareDraw, .draw = draw, }; const WindowEventList& getEvents() { return kEvents; } void previousTrackPiece(Window& self) { WidgetIndex_t prev = self.prevAvailableWidgetInRange(widx::left_hand_curve_very_small, widx::s_bend_dual_track_right); if (prev != -1) { self.callOnMouseDown(prev, self.widgets[prev].id); } } void nextTrackPiece(Window& self) { WidgetIndex_t next = self.nextAvailableWidgetInRange(widx::left_hand_curve_very_small, widx::s_bend_dual_track_right); if (next != -1) { self.callOnMouseDown(next, self.widgets[next].id); } } void previousSlope(Window& self) { WidgetIndex_t prev = self.prevAvailableWidgetInRange(widx::steep_slope_down, widx::steep_slope_up); if (prev != -1) { self.callOnMouseDown(prev, self.widgets[prev].id); } } void nextSlope(Window& self) { WidgetIndex_t next = self.nextAvailableWidgetInRange(widx::steep_slope_down, widx::steep_slope_up); if (next != -1) { self.callOnMouseDown(next, self.widgets[next].id); } } void buildAtCurrentPos(Window& self) { if (self.currentTab != Common::widx::tab_construction - Common::widx::tab_construction) { return; } if (_cState->constructionHover == 0) { self.callOnMouseUp(widx::construct, self.widgets[widx::construct].id); } } void removeAtCurrentPos(Window& self) { if (self.currentTab == Common::widx::tab_construction - Common::widx::tab_construction) { self.callOnMouseUp(widx::remove, self.widgets[widx::remove].id); } } void selectPosition(Window& self) { if (self.currentTab != Common::widx::tab_construction - Common::widx::tab_construction) { return; } if (_cState->constructionHover == 0) { self.callOnMouseUp(widx::rotate_90, self.widgets[widx::rotate_90].id); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Construction/OverheadTab.cpp ```cpp #include "Audio/Audio.h" #include "Construction.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/CreateRoadMod.h" #include "GameCommands/Road/RemoveRoadMod.h" #include "GameCommands/Track/CreateTrackMod.h" #include "GameCommands/Track/RemoveTrackMod.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/RoadElement.h" #include "Map/Track/TrackModSection.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "SceneManager.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/CheckboxWidget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "World/CompanyManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::TileManager; namespace OpenLoco::Ui::Windows::Construction::Overhead { static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(138, 192, StringIds::stringid_2), Widgets::Checkbox({ 3, 45 }, { 132, 12 }, WindowColour::secondary, StringIds::empty, StringIds::tooltip_select_track_mod), Widgets::Checkbox({ 3, 57 }, { 132, 12 }, WindowColour::secondary, StringIds::empty, StringIds::tooltip_select_track_mod), Widgets::Checkbox({ 3, 69 }, { 132, 12 }, WindowColour::secondary, StringIds::empty, StringIds::tooltip_select_track_mod), Widgets::Checkbox({ 3, 81 }, { 132, 12 }, WindowColour::secondary, StringIds::empty, StringIds::tooltip_select_track_mod), Widgets::Wt3Widget({ 35, 110 }, { 66, 66 }, WindowColour::secondary), Widgets::dropdownWidgets({ 3, 95 }, { 132, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_track_to_upgrade)); std::span<const Widget> getWidgets() { return widgets; } WindowEventList events; // 0x0049EBD1 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_construction: case Common::widx::tab_overhead: case Common::widx::tab_signal: case Common::widx::tab_station: Common::switchTab(self, widgetIndex); break; case widx::checkbox_1: case widx::checkbox_2: case widx::checkbox_3: case widx::checkbox_4: { auto checkboxIndex = widgetIndex - widx::checkbox_1; _cState->lastSelectedMods = _cState->lastSelectedMods ^ (1 << checkboxIndex); // TODO: & ~(1 << 7) added to prevent crashing when selecting/deselecting overhead wires for trams Scenario::getConstruction().trackMods[_cState->trackType & ~(1 << 7)] = _cState->lastSelectedMods; self.invalidate(); break; } } } // 0x0049EBFC static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::track_dropdown: { uint8_t modCount = 3; auto widget = self.widgets[widx::track]; auto xPos = widget.left + self.x; auto yPos = widget.top + self.y; auto width = widget.width() + 2; auto height = widget.height(); Dropdown::show(xPos, yPos, width, height, self.getColour(WindowColour::secondary), modCount, (1 << 7)); Dropdown::add(0, StringIds::single_section); Dropdown::add(1, StringIds::block_section); Dropdown::add(2, StringIds::all_connected_track); Dropdown::setHighlightedItem(enumValue(_cState->lastSelectedTrackModSection)); break; } case widx::image: { ToolManager::toolCancel(); ToolManager::toolSet(self, widgetIndex, CursorId::crosshair); break; } } } // 0x0049EC09 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::track_dropdown) { return; } if (itemIndex != -1) { _cState->lastSelectedTrackModSection = static_cast<Track::ModSection>(itemIndex); self.invalidate(); } } // 0x0049ECD1 static void onUpdate(Window& self) { Common::onUpdate(&self, GhostVisibilityFlags::overhead); } static std::optional<GameCommands::RoadModsPlacementArgs> getRoadModsPlacementArgsFromCursor(const int16_t x, const int16_t y) { static loco_global<Viewport*, 0x01135F52> _1135F52; auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::roadAndTram)); _1135F52 = viewport; if (interaction.type != ViewportInteraction::InteractionItem::road) { return std::nullopt; } auto* elRoad = reinterpret_cast<World::TileElement*>(interaction.object)->as<RoadElement>(); if (elRoad == nullptr) { return std::nullopt; } GameCommands::RoadModsPlacementArgs args; args.type = _cState->lastSelectedMods; args.pos = World::Pos3(interaction.pos.x, interaction.pos.y, elRoad->baseHeight()); args.rotation = elRoad->rotation(); args.roadId = elRoad->roadId(); args.index = elRoad->sequenceIndex(); args.roadObjType = elRoad->roadObjectId(); args.modSection = _cState->lastSelectedTrackModSection; return { args }; } static std::optional<GameCommands::TrackModsPlacementArgs> getTrackModsPlacementArgsFromCursor(const int16_t x, const int16_t y) { static loco_global<Viewport*, 0x01135F52> _1135F52; auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::track)); _1135F52 = viewport; if (interaction.type != ViewportInteraction::InteractionItem::track) { return std::nullopt; } auto* elTrack = reinterpret_cast<World::TileElement*>(interaction.object)->as<TrackElement>(); if (elTrack == nullptr) { return std::nullopt; } GameCommands::TrackModsPlacementArgs args; args.type = _cState->lastSelectedMods; args.pos = World::Pos3(interaction.pos.x, interaction.pos.y, elTrack->baseHeight()); args.rotation = elTrack->rotation(); args.trackId = elTrack->trackId(); args.index = elTrack->sequenceIndex(); args.trackObjType = elTrack->trackObjectId(); args.modSection = _cState->lastSelectedTrackModSection; return { args }; } // 0x0049FF0 void removeTrackModsGhost() { if ((_ghostVisibilityFlags & GhostVisibilityFlags::overhead) != GhostVisibilityFlags::none) { if (_cState->modGhostTrackObjId & (1 << 7)) { GameCommands::RoadModsRemovalArgs args; args.pos = _cState->modGhostPos; args.rotation = _cState->modGhostRotation; args.roadId = _cState->modGhostTrackId; args.index = _cState->modGhostTileIndex; args.roadObjType = _cState->modGhostTrackObjId & ~(1 << 7); args.type = _cState->lastSelectedMods; args.modSection = _cState->lastSelectedTrackModSection; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } else { GameCommands::TrackModsRemovalArgs args; args.pos = _cState->modGhostPos; args.rotation = _cState->modGhostRotation; args.trackId = _cState->modGhostTrackId; args.index = _cState->modGhostTileIndex; args.trackObjType = _cState->modGhostTrackObjId & ~(1 << 7); args.type = _cState->lastSelectedMods; args.modSection = _cState->lastSelectedTrackModSection; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } _ghostVisibilityFlags = _ghostVisibilityFlags & ~GhostVisibilityFlags::overhead; } } static uint32_t placeRoadModGhost(const GameCommands::RoadModsPlacementArgs& args) { auto res = GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res != GameCommands::FAILURE) { _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::overhead; _cState->modGhostPos = args.pos; _cState->modGhostRotation = args.rotation; _cState->modGhostTrackId = args.roadId; _cState->modGhostTileIndex = args.index; _cState->modGhostTrackObjId = args.roadObjType | (1 << 7); // This looks wrong! } return res; } static uint32_t placeTrackModGhost(const GameCommands::TrackModsPlacementArgs& args) { auto res = GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res != GameCommands::FAILURE) { _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::overhead; _cState->modGhostPos = args.pos; _cState->modGhostRotation = args.rotation; _cState->modGhostTrackId = args.trackId; _cState->modGhostTileIndex = args.index; _cState->modGhostTrackObjId = args.trackObjType; } return res; } // 0x0049EC15 static void onToolUpdate(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::image) { return; } if (_cState->trackType & (1 << 7)) { auto placementArgs = getRoadModsPlacementArgsFromCursor(x, y); if (!placementArgs || ((placementArgs->roadObjType | (1 << 7)) != _cState->trackType)) { removeConstructionGhosts(); if (_cState->modCost != 0x80000000) { _cState->modCost = 0x80000000; self.invalidate(); } return; } if ((_ghostVisibilityFlags & GhostVisibilityFlags::overhead) != GhostVisibilityFlags::none) { if (_cState->modGhostPos == placementArgs->pos && _cState->modGhostRotation == placementArgs->rotation && _cState->modGhostTrackId == placementArgs->roadId && _cState->modGhostTileIndex == placementArgs->index && _cState->modGhostTrackObjId == placementArgs->roadObjType) { return; } } removeConstructionGhosts(); auto cost = placeRoadModGhost(*placementArgs); if (cost != _cState->modCost) { _cState->modCost = cost; self.invalidate(); } } else { auto placementArgs = getTrackModsPlacementArgsFromCursor(x, y); if (!placementArgs || (placementArgs->trackObjType != _cState->trackType)) { removeConstructionGhosts(); if (_cState->modCost != 0x80000000) { _cState->modCost = 0x80000000; self.invalidate(); } return; } if ((_ghostVisibilityFlags & GhostVisibilityFlags::overhead) != GhostVisibilityFlags::none) { if (_cState->modGhostPos == placementArgs->pos && _cState->modGhostRotation == placementArgs->rotation && _cState->modGhostTrackId == placementArgs->trackId && _cState->modGhostTileIndex == placementArgs->index && _cState->modGhostTrackObjId == placementArgs->trackObjType) { return; } } removeConstructionGhosts(); auto cost = placeTrackModGhost(*placementArgs); if (cost != _cState->modCost) { _cState->modCost = cost; self.invalidate(); } } } // 0x0049EC20 static void onToolUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::image) { return; } removeConstructionGhosts(); if (_cState->trackType & (1 << 7)) { auto args = getRoadModsPlacementArgsFromCursor(x, y); if (!args) { return; } if ((args->roadObjType | (1 << 7)) != _cState->trackType) { Error::open(StringIds::error_cant_build_this_here, StringIds::wrong_type_of_track_road); return; } GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); auto res = GameCommands::doCommand(*args, GameCommands::Flags::apply); if (res == GameCommands::FAILURE || res == 0) { return; } Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } else { auto args = getTrackModsPlacementArgsFromCursor(x, y); if (!args) { return; } if (args->trackObjType != _cState->trackType) { Error::open(StringIds::error_cant_build_this_here, StringIds::wrong_type_of_track_road); return; } GameCommands::setErrorTitle(StringIds::error_cant_build_this_here); auto res = GameCommands::doCommand(*args, GameCommands::Flags::apply); if (res == GameCommands::FAILURE || res == 0) { return; } Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } static void setCheckbox(Window* self, WidgetIndex_t checkboxIndex, StringId name) { auto widgetIndex = checkboxIndex + widx::checkbox_1; self->widgets[widgetIndex].hidden = false; self->widgets[widgetIndex].text = name; if (_cState->lastSelectedMods & (1 << checkboxIndex)) { self->activatedWidgets |= (1ULL << widgetIndex); } } // 0x0049E7D3 static void prepareDraw(Window& self) { Common::prepareDraw(&self); self.activatedWidgets &= ~(1 << widx::checkbox_1 | 1 << widx::checkbox_2 | 1 << widx::checkbox_3 | 1 << widx::checkbox_4); self.widgets[widx::checkbox_1].hidden = true; self.widgets[widx::checkbox_2].hidden = true; self.widgets[widx::checkbox_3].hidden = true; self.widgets[widx::checkbox_4].hidden = true; if (_cState->trackType & (1 << 7)) { auto trackType = _cState->trackType & ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(trackType); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(roadObj->name); for (auto i = 0; i < 2; i++) { if (_cState->modList[i] != 0xFF) { auto extraName = ObjectManager::get<RoadExtraObject>(_cState->modList[i])->name; setCheckbox(&self, i, extraName); } } } else { auto trackObj = ObjectManager::get<TrackObject>(_cState->trackType); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(trackObj->name); for (auto i = 0; i < 4; i++) { if (_cState->modList[i] != 0xFF) { auto extraName = ObjectManager::get<TrackExtraObject>(_cState->modList[i])->name; setCheckbox(&self, i, extraName); } } } // self->activatedWidgets = activatedWidgets; self.widgets[widx::image].hidden = true; self.widgets[widx::track].hidden = true; self.widgets[widx::track_dropdown].hidden = true; self.widgets[widx::image].tooltip = StringIds::null; if (_cState->lastSelectedMods & 0xF) { self.widgets[widx::image].hidden = false; self.widgets[widx::track].hidden = false; self.widgets[widx::track_dropdown].hidden = false; self.widgets[widx::image].tooltip = StringIds::upgrade_track_with_mods; if (SceneManager::isNetworkHost()) { if (ToolManager::getToolWindowType() == WindowType::construction) { self.widgets[widx::image].tooltip = StringIds::click_track_to_upgrade; } } } static StringId modString[] = { StringIds::single_section, StringIds::block_section, StringIds::all_connected_track, }; self.widgets[widx::track].text = modString[enumValue(_cState->lastSelectedTrackModSection)]; Common::repositionTabs(&self); } // 0x0049EA3E static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); if (_cState->lastSelectedMods & 0xF) { auto xPos = self.x + self.widgets[widx::image].left + 1; auto yPos = self.y + self.widgets[widx::image].top + 1; auto width = self.widgets[widx::image].width(); auto height = self.widgets[widx::image].height(); const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(xPos, yPos, width, height)); if (clipped) { coord_t x = 0x2010; coord_t y = 0x2010; auto rotCoord = Math::Vector::rotate(Pos2{ x, y }, WindowManager::getCurrentRotation()); Ui::Point screenPos = { static_cast<int16_t>(rotCoord.y - rotCoord.x), static_cast<int16_t>(((rotCoord.x + rotCoord.y) >> 1) - 460) }; screenPos.x -= (self.widgets[widx::image].width() / 2); screenPos.y -= ((self.widgets[widx::image].width() / 2) + 16); clipped->x += screenPos.x; clipped->y += screenPos.y; drawingCtx.pushRenderTarget(*clipped); const auto previewPos = World::Pos3(256 * World::kTileSize, 256 * World::kTileSize, 116 * World::kSmallZStep); _byte_522095 = _byte_522095 | (1 << 0); if (_cState->trackType & (1 << 7)) { uint8_t trackType = _cState->trackType & ~(1 << 7); Construction::drawRoad(previewPos, _cState->lastSelectedMods, trackType, 0, WindowManager::getCurrentRotation(), drawingCtx); } else { Construction::drawTrack(previewPos, _cState->lastSelectedMods, _cState->trackType, 0, WindowManager::getCurrentRotation(), drawingCtx); } _byte_522095 = _byte_522095 & ~(1 << 0); drawingCtx.popRenderTarget(); } } if (_cState->modCost != 0x80000000 && _cState->modCost != 0) { FormatArguments args{}; args.push<uint32_t>(_cState->modCost); auto tr = Gfx::TextRenderer(drawingCtx); auto point = Point(self.x + 69, self.widgets[widx::image].bottom + self.y + 4); tr.drawStringCentred(point, Colour::black, StringIds::build_cost, args); } } void tabReset(Window& self) { self.callOnMouseDown(Overhead::widx::image, self.widgets[Overhead::widx::image].id); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .toolUp = onToolUp, .prepareDraw = prepareDraw, .draw = draw, }; const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Construction/SignalTab.cpp ```cpp #include "Audio/Audio.h" #include "Construction.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Track/CreateSignal.h" #include "GameCommands/Track/RemoveSignal.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/SignalElement.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrackObject.h" #include "Objects/TrainSignalObject.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::TileManager; namespace OpenLoco::Ui::Windows::Construction::Signal { static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(138, 167, StringIds::stringid_2), Widgets::dropdownWidgets({ 3, 45 }, { 132, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_signal_type), Widgets::ImageButton({ 27, 110 }, { 40, 40 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_signal_both_directions), Widgets::ImageButton({ 71, 110 }, { 40, 40 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_signal_single_direction)); std::span<const Widget> getWidgets() { return widgets; } WindowEventList events; // 0x0049E64E static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_construction: case Common::widx::tab_overhead: case Common::widx::tab_signal: case Common::widx::tab_station: Common::switchTab(self, widgetIndex); break; } } // 0x0049E669 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::signal_dropdown: { uint8_t signalCount = 0; while (_cState->signalList[signalCount] != 0xFF) { signalCount++; } auto widget = self.widgets[widx::signal]; auto xPos = widget.left + self.x; auto yPos = widget.top + self.y; auto width = widget.width() + 2; auto height = widget.height(); Dropdown::show(xPos, yPos, width, height, self.getColour(WindowColour::secondary), signalCount, (1 << 7)); for (auto signalIndex = 0; signalIndex < signalCount; signalIndex++) { auto signal = _cState->signalList[signalIndex]; if (signal == _cState->lastSelectedSignal) { Dropdown::setHighlightedItem(signalIndex); } auto trainSignalObj = ObjectManager::get<TrainSignalObject>(signal); Dropdown::add(signalIndex, trainSignalObj->name); } break; } case widx::both_directions: { _cState->isSignalBothDirections = 1; ToolManager::toolCancel(); ToolManager::toolSet(self, widgetIndex, CursorId::placeSignal); break; } case widx::single_direction: { _cState->isSignalBothDirections = 0; ToolManager::toolCancel(); ToolManager::toolSet(self, widgetIndex, CursorId::placeSignal); break; } } } // 0x0049E67C static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex != widx::signal_dropdown) { return; } if (itemIndex != -1) { _cState->lastSelectedSignal = _cState->signalList[itemIndex]; Scenario::getConstruction().signals[_cState->trackType] = _cState->signalList[itemIndex]; self.invalidate(); } } // 0x0049E76F static void onUpdate(Window& self) { Common::onUpdate(&self, GhostVisibilityFlags::signal); } // 0x004A417A // false for left, true for right static bool getSide(const World::Pos3& loc, const Point& mousePos, const TrackElement& elTrack, const Viewport& viewport) { Common::setNextAndPreviousTrackTile(elTrack, loc); const bool isCloserToNext = Common::isPointCloserToNextOrPreviousTile(mousePos, viewport); return isCloserToNext; } static std::optional<GameCommands::SignalPlacementArgs> getSignalPlacementArgsFromCursor(const int16_t x, const int16_t y, const bool isBothDirectons) { static loco_global<Viewport*, 0x01135F52> _1135F52; auto [interaction, viewport] = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::track)); _1135F52 = viewport; if (interaction.type != ViewportInteraction::InteractionItem::track) { return std::nullopt; } auto* elTrack = reinterpret_cast<World::TileElement*>(interaction.object)->as<TrackElement>(); if (elTrack == nullptr) { return std::nullopt; } GameCommands::SignalPlacementArgs args; args.type = _cState->lastSelectedSignal; args.pos = World::Pos3(interaction.pos.x, interaction.pos.y, elTrack->baseHeight()); args.rotation = elTrack->rotation(); args.trackId = elTrack->trackId(); args.index = elTrack->sequenceIndex(); args.trackObjType = elTrack->trackObjectId(); if (isBothDirectons) { args.sides = 0xC000; } else { args.sides = getSide(args.pos, { x, y }, *elTrack, *viewport) ? 0x4000 : 0x8000; } return { args }; } static uint32_t placeSignalGhost(const GameCommands::SignalPlacementArgs& args) { auto res = GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::preventBuildingClearing | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); if (res != GameCommands::FAILURE) { _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::signal; _cState->signalGhostPos = args.pos; _cState->signalGhostRotation = args.rotation; _cState->signalGhostTrackId = args.trackId; _cState->signalGhostTileIndex = args.index; _cState->signalGhostSides = args.sides; _cState->signalGhostTrackObjId = args.trackObjType; } return res; } // 0x0049FEF6 void removeSignalGhost() { if ((_ghostVisibilityFlags & GhostVisibilityFlags::signal) != GhostVisibilityFlags::none) { GameCommands::SignalRemovalArgs args; args.pos = _cState->signalGhostPos; args.rotation = _cState->signalGhostRotation; args.trackId = _cState->signalGhostTrackId; args.index = _cState->signalGhostTileIndex; args.flags = _cState->signalGhostSides; args.trackObjType = _cState->signalGhostTrackObjId; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); _ghostVisibilityFlags = _ghostVisibilityFlags & ~GhostVisibilityFlags::signal; } } // 0x0049E745 static void onToolUpdate(Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::single_direction && widgetIndex != widx::both_directions) { return; } const bool isBothDirections = widgetIndex == widx::both_directions; auto placementArgs = getSignalPlacementArgsFromCursor(x, y, isBothDirections); if (!placementArgs || (placementArgs->trackObjType != _cState->trackType)) { removeConstructionGhosts(); if (_cState->signalCost != 0x80000000) { _cState->signalCost = 0x80000000; self.invalidate(); } return; } if ((_ghostVisibilityFlags & GhostVisibilityFlags::signal) != GhostVisibilityFlags::none) { if (_cState->signalGhostPos == placementArgs->pos && _cState->signalGhostRotation == placementArgs->rotation && _cState->signalGhostTrackId == placementArgs->trackId && _cState->signalGhostTileIndex == placementArgs->index && _cState->signalGhostSides == placementArgs->sides && _cState->signalGhostTrackObjId == placementArgs->trackObjType) { return; } } removeConstructionGhosts(); auto cost = placeSignalGhost(*placementArgs); if (cost != _cState->signalCost) { _cState->signalCost = cost; self.invalidate(); } } // 0x0049E75A static void onToolUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::single_direction && widgetIndex != widx::both_directions) { return; } removeConstructionGhosts(); const bool isBothDirections = widgetIndex == widx::both_directions; auto args = getSignalPlacementArgsFromCursor(x, y, isBothDirections); if (!args) { return; } if (args->trackObjType != _cState->trackType) { Error::open(StringIds::cant_build_signal_here, StringIds::wrong_type_of_track_road); return; } GameCommands::setErrorTitle(isBothDirections ? StringIds::cant_build_signals_here : StringIds::cant_build_signal_here); auto res = GameCommands::doCommand(*args, GameCommands::Flags::apply); if (res == GameCommands::FAILURE) { return; } Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } // 0x0049E499 static void prepareDraw(Window& self) { Common::prepareDraw(&self); auto trackObj = ObjectManager::get<TrackObject>(_cState->trackType); auto args = FormatArguments(self.widgets[Common::widx::caption].textArgs); args.push(trackObj->name); auto trainSignalObject = ObjectManager::get<TrainSignalObject>(_cState->lastSelectedSignal); self.widgets[widx::signal].text = trainSignalObject->name; Common::repositionTabs(&self); } // 0x0049E501 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto trainSignalObject = ObjectManager::get<TrainSignalObject>(_cState->lastSelectedSignal); auto xPos = self.x + 3; auto yPos = self.y + 63; auto width = 130; { FormatArguments args{}; args.push(trainSignalObject->description); auto point = Point(xPos, yPos); tr.drawStringLeftWrapped(point, width, Colour::black, StringIds::signal_black, args); } auto imageId = trainSignalObject->image; xPos = self.widgets[widx::both_directions].midX() + self.x; yPos = self.widgets[widx::both_directions].bottom + self.y - 4; drawingCtx.drawImage(xPos - 8, yPos, imageId); drawingCtx.drawImage(xPos + 8, yPos, imageId + 4); xPos = self.widgets[widx::single_direction].midX() + self.x; yPos = self.widgets[widx::single_direction].bottom + self.y - 4; drawingCtx.drawImage(xPos, yPos, imageId); if (_cState->signalCost != 0x80000000 && _cState->signalCost != 0) { FormatArguments args{}; args.push<uint32_t>(_cState->signalCost); auto point = Point(self.x + 69, self.widgets[widx::single_direction].bottom + self.y + 5); tr.drawStringCentred(point, Colour::black, StringIds::build_cost, args); } } void tabReset(Window& self) { self.callOnMouseDown(Signal::widx::both_directions, self.widgets[Signal::widx::both_directions].id); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .toolUp = onToolUp, .prepareDraw = prepareDraw, .draw = draw, }; const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/Construction/StationTab.cpp ```cpp #include "Audio/Audio.h" #include "Construction.h" #include "GameCommands/Airports/CreateAirport.h" #include "GameCommands/Airports/RemoveAirport.h" #include "GameCommands/Docks/CreatePort.h" #include "GameCommands/Docks/RemovePort.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Road/CreateRoadStation.h" #include "GameCommands/Road/RemoveRoadStation.h" #include "GameCommands/Track/CreateTrainStation.h" #include "GameCommands/Track/RemoveTrainStation.h" #include "GameState.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/IndustryElement.h" #include "Map/MapSelection.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TrackElement.h" #include "Objects/AirportObject.h" #include "Objects/CargoObject.h" #include "Objects/DockObject.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainStationObject.h" #include "Ui/Dropdown.h" #include "Ui/ToolManager.h" #include "Ui/ViewportInteraction.h" #include "Ui/Widget.h" #include "Ui/Widgets/DropdownWidget.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/StationManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::TileManager; namespace OpenLoco::Ui::Windows::Construction::Station { static loco_global<uint8_t, 0x00508F09> _suppressErrorSound; static loco_global<World::Pos3, 0x00F24942> _constructionArrowPos; static loco_global<uint8_t, 0x00F24948> _constructionArrowDirection; static loco_global<uint32_t, 0x00112C734> _lastConstructedAdjoiningStationId; // Can be 0xFFFF'FFFFU for no adjoining station static loco_global<World::Pos2, 0x00112C792> _lastConstructedAdjoiningStationCentrePos; // Can be x = -1 for no adjoining station // TODO: move to ConstructionState when no longer a loco_global static bool _isDragging = false; static World::TilePos2 _toolPosDrag; static World::TilePos2 _toolPosInitial; static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets(138, 190, StringIds::stringid_2), Widgets::dropdownWidgets({ 3, 45 }, { 132, 12 }, WindowColour::secondary, Widget::kContentNull, StringIds::tooltip_select_station_type), Widgets::Wt3Widget({ 35, 60 }, { 68, 68 }, WindowColour::secondary), Widgets::ImageButton({ 112, 104 }, { 24, 24 }, WindowColour::secondary, ImageIds::rotate_object, StringIds::rotate_90)); std::span<const Widget> getWidgets() { return widgets; } WindowEventList events; // 0x0049E228 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: WindowManager::close(&self); break; case Common::widx::tab_construction: case Common::widx::tab_overhead: case Common::widx::tab_signal: case Common::widx::tab_station: Common::switchTab(self, widgetIndex); break; case widx::rotate: _cState->constructionRotation++; _cState->constructionRotation = _cState->constructionRotation & 3; _cState->stationCost = 0x80000000; self.invalidate(); break; } } template<typename obj_type> void AddStationsToDropdown(const uint8_t stationCount) { for (auto stationIndex = 0; stationIndex < stationCount; stationIndex++) { auto station = _cState->stationList[stationIndex]; if (station == _cState->lastSelectedStationType) { Dropdown::setHighlightedItem(stationIndex); } auto obj = ObjectManager::get<obj_type>(station); Dropdown::add(stationIndex, obj->name); } } // 0x0049E249 static void onMouseDown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case widx::station_dropdown: { uint8_t stationCount = 0; while (_cState->stationList[stationCount] != 0xFF) { stationCount++; } auto widget = self.widgets[widx::station]; auto xPos = widget.left + self.x; auto yPos = widget.top + self.y; auto width = widget.width() + 2; auto height = widget.height(); Dropdown::show(xPos, yPos, width, height, self.getColour(WindowColour::secondary), stationCount, (1 << 7)); if (_cState->byte_1136063 & (1 << 7)) { AddStationsToDropdown<AirportObject>(stationCount); } else if (_cState->byte_1136063 & (1 << 6)) { AddStationsToDropdown<DockObject>(stationCount); } else if (_cState->trackType & (1 << 7)) { AddStationsToDropdown<RoadStationObject>(stationCount); } else { AddStationsToDropdown<TrainStationObject>(stationCount); } break; } case widx::image: { ToolManager::toolCancel(); ToolManager::toolSet(self, widgetIndex, CursorId::placeStation); break; } } } // 0x0049E256 static void onDropdown(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, int16_t itemIndex) { if (widgetIndex == widx::station_dropdown) { if (itemIndex == -1) { return; } auto selectedStation = _cState->stationList[itemIndex]; _cState->lastSelectedStationType = selectedStation; if (_cState->byte_1136063 & (1 << 7)) { getGameState().lastAirport = selectedStation; } else if (_cState->byte_1136063 & (1 << 6)) { getGameState().lastShipPort = selectedStation; } else if (_cState->trackType & (1 << 7)) { auto trackType = _cState->trackType & ~(1 << 7); Scenario::getConstruction().roadStations[trackType] = selectedStation; } else { Scenario::getConstruction().trainStations[_cState->trackType] = selectedStation; } self.invalidate(); } } // 0x0049E437 static void onUpdate(Window& self) { Common::onUpdate(&self, GhostVisibilityFlags::station); } // 0x0049FF4B void removeStationGhost() { if ((_ghostVisibilityFlags & GhostVisibilityFlags::station) != GhostVisibilityFlags::none) { if (World::hasMapSelectionFlag(World::MapSelectionFlags::catchmentArea)) { Windows::Station::sub_491BC6(); World::resetMapSelectionFlag(World::MapSelectionFlags::catchmentArea); } if (_cState->stationGhostType & (1 << 15)) { GameCommands::AirportRemovalArgs args; args.pos = _cState->stationGhostPos; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } else if (_cState->stationGhostType & (1 << 14)) { GameCommands::PortRemovalArgs args; args.pos = _cState->stationGhostPos; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } else if (_cState->stationGhostType & (1 << 7)) { GameCommands::RoadStationRemovalArgs args; args.pos = _cState->stationGhostPos; args.rotation = _cState->stationGhostRotation; args.roadId = _cState->stationGhostTrackId; args.index = _cState->stationGhostTileIndex; args.roadObjectId = _cState->stationGhostType & ~(1 << 7); GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } else { GameCommands::TrainStationRemovalArgs args; args.pos = _cState->stationGhostPos; args.rotation = _cState->stationGhostRotation; args.trackId = _cState->stationGhostTrackId; args.index = _cState->stationGhostTileIndex; args.type = _cState->stationGhostType; GameCommands::doCommand(args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); } _ghostVisibilityFlags = _ghostVisibilityFlags & ~GhostVisibilityFlags::station; } } static void setMapSelectedTilesFromRange(const World::TilePosRangeView& range) { resetMapSelectionFreeFormTiles(); for (const auto& pos : range) { addMapSelectionFreeFormTile(World::toWorldSpace(pos)); } mapInvalidateMapSelectionFreeFormTiles(); } static std::optional<GameCommands::AirportPlacementArgs> getAirportPlacementArgsFromCursor(const int16_t x, const int16_t y); static std::optional<GameCommands::PortPlacementArgs> getDockPlacementArgsFromCursor(const int16_t x, const int16_t y); static std::optional<GameCommands::RoadStationPlacementArgs> getRoadStationPlacementArgsFromCursor(const int16_t x, const int16_t y); static std::optional<GameCommands::TrainStationPlacementArgs> getTrainStationPlacementArgsFromCursor(const int16_t x, const int16_t y); static std::optional<GameCommands::AirportPlacementArgs> getAirportPlacementArgs(const World::Pos2 pos); static std::optional<GameCommands::PortPlacementArgs> getDockPlacementArgs(const World::Pos2 pos); static std::optional<GameCommands::RoadStationPlacementArgs> getRoadStationPlacementArgs(const World::Pos2 pos, const World::RoadElement* roadEl); static std::optional<GameCommands::TrainStationPlacementArgs> getTrainStationPlacementArgs(const World::Pos2 pos, const World::TrackElement* trackEl); static loco_global<World::Pos2, 0x001135F7C> _1135F7C; static loco_global<World::Pos2, 0x001135F80> _1135F90; // 0x004A4CF9 static void onToolUpdateFail() { removeConstructionGhosts(); if (_cState->stationCost != 0x80000000U) { _cState->stationCost = 0x80000000U; Ui::WindowManager::invalidate(Ui::WindowType::construction); } } // 0x004A4F3B static void onToolUpdateAirport(const Ui::Point& mousePos) { World::mapInvalidateMapSelectionFreeFormTiles(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable | World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); const auto args = getAirportPlacementArgsFromCursor(mousePos.x, mousePos.y); if (!args.has_value()) { onToolUpdateFail(); return; } World::setMapSelectionFlags(World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); World::resetMapSelectionFlag(World::MapSelectionFlags::unk_03); _constructionArrowDirection = args->rotation; _constructionArrowPos = args->pos; setMapSelectedTilesFromRange(World::getClampedRange(*_1135F7C, *_1135F90)); if ((_ghostVisibilityFlags & GhostVisibilityFlags::station) != GhostVisibilityFlags::none) { if (_cState->stationGhostPos == args->pos && _cState->stationGhostRotation == args->rotation && _cState->stationGhostTypeDockAirport == args->type) { return; } removeConstructionGhosts(); } _cState->stationGhostPos = args->pos; _cState->stationGhostRotation = args->rotation; _cState->stationGhostTypeDockAirport = args->type; _cState->stationGhostType = (1U << 15); const auto cost = GameCommands::doCommand(*args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); _cState->stationCost = cost; Ui::WindowManager::invalidate(Ui::WindowType::construction); if (cost == GameCommands::FAILURE) { return; } _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::station; World::setMapSelectionFlags(World::MapSelectionFlags::catchmentArea); _cState->constructingStationId = _lastConstructedAdjoiningStationId; auto* station = _lastConstructedAdjoiningStationId != 0xFFFFFFFFU ? StationManager::get(static_cast<StationId>(*_lastConstructedAdjoiningStationId)) : nullptr; setCatchmentDisplay(station, CatchmentFlags::flag_0); auto pos = *_lastConstructedAdjoiningStationCentrePos; if (pos.x == -1) { pos = args->pos; } sub_491C6F(_cState->stationGhostTypeDockAirport, pos, _cState->stationGhostRotation, CatchmentFlags::flag_0); Windows::Station::sub_491BC6(); auto res = calcAcceptedCargoAirportGhost(station, _cState->stationGhostTypeDockAirport, pos, _cState->stationGhostRotation, 0xFFFFFFFFU); _cState->constructingStationAcceptedCargoTypes = res.accepted; _cState->constructingStationProducedCargoTypes = res.produced; } // 0x004A5158 static void onToolUpdateDock(const Ui::Point& mousePos) { World::mapInvalidateMapSelectionFreeFormTiles(); World::resetMapSelectionFlag(World::MapSelectionFlags::enable | World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); const auto args = getDockPlacementArgsFromCursor(mousePos.x, mousePos.y); if (!args.has_value()) { onToolUpdateFail(); return; } World::setMapSelectionFlags(World::MapSelectionFlags::enableConstruct | World::MapSelectionFlags::enableConstructionArrow); World::resetMapSelectionFlag(World::MapSelectionFlags::unk_03); _constructionArrowDirection = args->rotation; _constructionArrowPos = args->pos; setMapSelectedTilesFromRange(World::getClampedRange(*_1135F7C, *_1135F90)); if ((_ghostVisibilityFlags & GhostVisibilityFlags::station) != GhostVisibilityFlags::none) { if (_cState->stationGhostPos == args->pos && _cState->stationGhostRotation == args->rotation && _cState->stationGhostTypeDockAirport == args->type) { return; } removeConstructionGhosts(); } _cState->stationGhostPos = args->pos; _cState->stationGhostRotation = args->rotation; _cState->stationGhostTypeDockAirport = args->type; _cState->stationGhostType = (1U << 14); const auto cost = GameCommands::doCommand(*args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); _cState->stationCost = cost; Ui::WindowManager::invalidate(Ui::WindowType::construction); if (cost == GameCommands::FAILURE) { return; } _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::station; World::setMapSelectionFlags(World::MapSelectionFlags::catchmentArea); _cState->constructingStationId = _lastConstructedAdjoiningStationId; auto* station = _lastConstructedAdjoiningStationId != 0xFFFFFFFFU ? StationManager::get(static_cast<StationId>(*_lastConstructedAdjoiningStationId)) : nullptr; setCatchmentDisplay(station, CatchmentFlags::flag_0); auto pos = *_lastConstructedAdjoiningStationCentrePos; if (pos.x == -1) { pos = args->pos; } sub_491D20(pos, CatchmentFlags::flag_0); Windows::Station::sub_491BC6(); auto res = calcAcceptedCargoDockGhost(station, pos, 0xFFFFFFFFU); _cState->constructingStationAcceptedCargoTypes = res.accepted; _cState->constructingStationProducedCargoTypes = res.produced; } // 0x004A4D21 static void onToolUpdateRoadStation(const Ui::Point& mousePos) { const auto args = getRoadStationPlacementArgsFromCursor(mousePos.x, mousePos.y); if (!args.has_value()) { onToolUpdateFail(); return; } if ((_ghostVisibilityFlags & GhostVisibilityFlags::station) != GhostVisibilityFlags::none) { if (_cState->stationGhostPos == args->pos && _cState->stationGhostRotation == args->rotation && _cState->stationGhostTrackId == args->roadId && _cState->stationGhostTileIndex == args->index && _cState->stationGhostType == (args->roadObjectId | (1 << 7))) { return; } removeConstructionGhosts(); } _cState->stationGhostPos = args->pos; _cState->stationGhostRotation = args->rotation; _cState->stationGhostTrackId = args->roadId; _cState->stationGhostTileIndex = args->index; _cState->stationGhostType = args->roadObjectId | (1 << 7); const auto cost = GameCommands::doCommand(*args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); _cState->stationCost = cost; Ui::WindowManager::invalidate(Ui::WindowType::construction); if (cost == GameCommands::FAILURE) { return; } _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::station; World::setMapSelectionFlags(World::MapSelectionFlags::catchmentArea); _cState->constructingStationId = _lastConstructedAdjoiningStationId; auto* station = _lastConstructedAdjoiningStationId != 0xFFFFFFFFU ? StationManager::get(static_cast<StationId>(*_lastConstructedAdjoiningStationId)) : nullptr; setCatchmentDisplay(station, CatchmentFlags::flag_0); auto pos = *_lastConstructedAdjoiningStationCentrePos; if (pos.x == -1) { pos = args->pos; } sub_491BF5(pos, CatchmentFlags::flag_0); Windows::Station::sub_491BC6(); const auto* roadStationObj = ObjectManager::get<RoadStationObject>(args->type); uint32_t filter = 0xFFFFFFFFU; if (roadStationObj->hasFlags(RoadStationFlags::passenger)) { filter = 1U << roadStationObj->cargoType; } if (roadStationObj->hasFlags(RoadStationFlags::freight)) { filter = 0xFFFFFFFFU; filter &= ~(1U << roadStationObj->cargoType); } auto res = calcAcceptedCargoTrainStationGhost(station, pos, filter); _cState->constructingStationAcceptedCargoTypes = res.accepted; _cState->constructingStationProducedCargoTypes = res.produced; } // 0x004A4B2E static void onToolUpdateTrainStation(const Ui::Point& mousePos) { const auto args = getTrainStationPlacementArgsFromCursor(mousePos.x, mousePos.y); if (!args.has_value()) { onToolUpdateFail(); return; } if ((_ghostVisibilityFlags & GhostVisibilityFlags::station) != GhostVisibilityFlags::none) { if (_cState->stationGhostPos == args->pos && _cState->stationGhostRotation == args->rotation && _cState->stationGhostTrackId == args->trackId && _cState->stationGhostTileIndex == args->index && _cState->stationGhostType == args->trackObjectId) { return; } removeConstructionGhosts(); } _cState->stationGhostPos = args->pos; _cState->stationGhostRotation = args->rotation; _cState->stationGhostTrackId = args->trackId; _cState->stationGhostTileIndex = args->index; _cState->stationGhostType = args->trackObjectId; const auto cost = GameCommands::doCommand(*args, GameCommands::Flags::apply | GameCommands::Flags::noErrorWindow | GameCommands::Flags::noPayment | GameCommands::Flags::ghost); _cState->stationCost = cost; Ui::WindowManager::invalidate(Ui::WindowType::construction); if (cost == GameCommands::FAILURE) { return; } _ghostVisibilityFlags = _ghostVisibilityFlags | GhostVisibilityFlags::station; World::setMapSelectionFlags(World::MapSelectionFlags::catchmentArea); _cState->constructingStationId = _lastConstructedAdjoiningStationId; auto* station = _lastConstructedAdjoiningStationId != 0xFFFFFFFFU ? StationManager::get(static_cast<StationId>(*_lastConstructedAdjoiningStationId)) : nullptr; setCatchmentDisplay(station, CatchmentFlags::flag_0); auto pos = *_lastConstructedAdjoiningStationCentrePos; if (pos.x == -1) { pos = args->pos; } sub_491BF5(pos, CatchmentFlags::flag_0); Windows::Station::sub_491BC6(); auto res = calcAcceptedCargoTrainStationGhost(station, pos, 0xFFFFFFFFU); _cState->constructingStationAcceptedCargoTypes = res.accepted; _cState->constructingStationProducedCargoTypes = res.produced; } // 0x0049E421 static void onToolUpdate(Window&, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::image) { return; } if (_isDragging) { mapInvalidateMapSelectionFreeFormTiles(); removeConstructionGhosts(); return; } if (_cState->byte_1136063 & (1 << 7)) { onToolUpdateAirport({ x, y }); } else if (_cState->byte_1136063 & (1 << 6)) { onToolUpdateDock({ x, y }); } else if (_cState->trackType & (1 << 7)) { onToolUpdateRoadStation({ x, y }); } else { onToolUpdateTrainStation({ x, y }); } } static void onToolDown([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::surface | ViewportInteraction::InteractionItemFlags::water)); auto& interaction = res.first; if (interaction.type == ViewportInteraction::InteractionItem::noInteraction) { return; } _toolPosInitial = World::toTileSpace(interaction.pos); _isDragging = false; } static void onToolDrag([[maybe_unused]] Window& self, [[maybe_unused]] const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, [[maybe_unused]] const int16_t x, [[maybe_unused]] const int16_t y) { mapInvalidateSelectionRect(); removeConstructionGhosts(); auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::surface | ViewportInteraction::InteractionItemFlags::water)); auto& interaction = res.first; if (interaction.type == ViewportInteraction::InteractionItem::noInteraction) { return; } _toolPosDrag = World::toTileSpace(interaction.pos); _isDragging = _toolPosInitial != _toolPosDrag; if (!_isDragging) { return; } setMapSelectionFlags(MapSelectionFlags::enable); setMapSelectionCorner(MapSelectionType::full); setMapSelectionArea(toWorldSpace(_toolPosInitial), toWorldSpace(_toolPosDrag)); mapInvalidateSelectionRect(); } // 0x004A47D9 static std::optional<GameCommands::AirportPlacementArgs> getAirportPlacementArgsFromCursor(const int16_t x, const int16_t y) { auto pos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); if (!pos) { return std::nullopt; } return getAirportPlacementArgs(pos.value()); } static std::optional<GameCommands::AirportPlacementArgs> getAirportPlacementArgs(const World::Pos2 pos) { GameCommands::AirportPlacementArgs placementArgs; placementArgs.type = _cState->lastSelectedStationType; placementArgs.rotation = _cState->constructionRotation; const auto airportObj = ObjectManager::get<AirportObject>(placementArgs.type); const auto [minPos, maxPos] = airportObj->getAirportExtents(World::toTileSpace(pos), placementArgs.rotation); _1135F7C = World::toWorldSpace(minPos); _1135F90 = World::toWorldSpace(maxPos); auto maxBaseZ = 0; for (auto checkPos = minPos; checkPos.y <= maxPos.y; ++checkPos.y) { for (checkPos.x = minPos.x; checkPos.x <= maxPos.x; ++checkPos.x) { if (!validCoords(checkPos)) { continue; } const auto tile = TileManager::get(checkPos); const auto* surface = tile.surface(); if (surface == nullptr) { return std::nullopt; } const auto baseZ = surface->water() ? surface->water() * World::kMicroToSmallZStep : surface->baseZ(); maxBaseZ = std::max(maxBaseZ, baseZ); } } placementArgs.pos = World::Pos3(pos.x, pos.y, maxBaseZ * World::kSmallZStep); return { placementArgs }; } // 0x004A5550 static void onToolUpAirport(const int16_t x, const int16_t y) { removeConstructionGhosts(); const auto args = getAirportPlacementArgsFromCursor(x, y); if (!args) { return; } const auto* airportObject = ObjectManager::get<AirportObject>(_cState->lastSelectedStationType); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(airportObject->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); GameCommands::doCommand(*args, GameCommands::Flags::apply); } // 0x004A4903 static std::optional<GameCommands::PortPlacementArgs> getDockPlacementArgsFromCursor(const int16_t x, const int16_t y) { auto pos = ViewportInteraction::getSurfaceOrWaterLocFromUi({ x, y }); if (!pos) { return std::nullopt; } return getDockPlacementArgs(pos.value()); } static std::optional<GameCommands::PortPlacementArgs> getDockPlacementArgs(const World::Pos2 pos) { // count of water on each side of the placement // 0x0113608B std::array<uint8_t, 4> _nearbyWaterCount = { 0 }; uint8_t directionOfIndustry = 0xFF; uint8_t waterHeight = 0; _1135F7C = pos; _1135F90 = World::toWorldSpace(World::toTileSpace(pos) + TilePos2(1, 1)); constexpr std::array<std::array<TilePos2, 2>, 4> searchArea = { std::array<TilePos2, 2>{ TilePos2{ -1, 0 }, TilePos2{ -1, 1 } }, std::array<TilePos2, 2>{ TilePos2{ 0, 2 }, TilePos2{ 1, 2 } }, std::array<TilePos2, 2>{ TilePos2{ 2, 0 }, TilePos2{ 2, 1 } }, std::array<TilePos2, 2>{ TilePos2{ 0, -1 }, TilePos2{ 1, -1 } }, }; for (auto side = 0; side < 4; ++side) { for (const auto& offset : searchArea[side]) { const auto searchPos = offset + World::toTileSpace(pos); if (!validCoords(searchPos)) { continue; } const auto tile = TileManager::get(searchPos); bool surfaceFound = false; for (const auto& el : tile) { if (surfaceFound) { const auto* elIndustry = el.as<IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->isGhost()) { continue; } auto* industry = elIndustry->industry(); const auto* industryObj = industry->getObject(); if (!industryObj->hasFlags(IndustryObjectFlags::builtOnWater)) { continue; } directionOfIndustry = side; } const auto* surface = el.as<SurfaceElement>(); if (surface == nullptr) { continue; } else { surfaceFound = true; if (!surface->water()) { continue; } waterHeight = surface->water() * World::kMicroToSmallZStep; if (waterHeight - 4 == surface->baseZ() && surface->isSlopeDoubleHeight()) { continue; } _nearbyWaterCount[(side + 2) & 0x3]++; } } } } if (waterHeight == 0) { return std::nullopt; } GameCommands::PortPlacementArgs placementArgs; placementArgs.type = _cState->lastSelectedStationType; placementArgs.pos = World::Pos3(pos.x, pos.y, waterHeight * World::kSmallZStep); if (directionOfIndustry != 0xFF) { placementArgs.rotation = directionOfIndustry; } else { auto res = std::find_if(std::begin(_nearbyWaterCount), std::end(_nearbyWaterCount), [](uint8_t value) { return value >= 2; }); if (res != std::end(_nearbyWaterCount)) { placementArgs.rotation = std::distance(std::begin(_nearbyWaterCount), res); } else { res = std::find_if(std::begin(_nearbyWaterCount), std::end(_nearbyWaterCount), [](uint8_t value) { return value >= 1; }); if (res != std::end(_nearbyWaterCount)) { placementArgs.rotation = std::distance(std::begin(_nearbyWaterCount), res); } else { static loco_global<uint8_t, 0x00113608A> _113608A; // ai rotation?? placementArgs.rotation = _113608A; } } } return { placementArgs }; } // 0x004A55AB static void onToolUpDock(const int16_t x, const int16_t y) { removeConstructionGhosts(); const auto args = getDockPlacementArgsFromCursor(x, y); if (!args) { return; } const auto* dockObject = ObjectManager::get<DockObject>(_cState->lastSelectedStationType); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(dockObject->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); GameCommands::doCommand(*args, GameCommands::Flags::apply); } static std::optional<GameCommands::RoadStationPlacementArgs> getRoadStationPlacementArgsFromCursor(const int16_t x, const int16_t y) { const auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::roadAndTram | ViewportInteraction::InteractionItemFlags::station)); const auto& interaction = res.first; if (interaction.type != ViewportInteraction::InteractionItem::road && interaction.type != ViewportInteraction::InteractionItem::roadStation) { return std::nullopt; } auto* elRoad = reinterpret_cast<const TileElement*>(interaction.object)->as<RoadElement>(); auto* elStation = reinterpret_cast<const TileElement*>(interaction.object)->as<StationElement>(); if (elRoad == nullptr && elStation == nullptr) { return std::nullopt; } // Deliberately always passing road and not station element, even if nullptr return getRoadStationPlacementArgs(interaction.pos, elRoad); } static std::optional<GameCommands::RoadStationPlacementArgs> getRoadStationPlacementArgs(const World::Pos2 pos, const RoadElement* elRoad) { if (elRoad == nullptr) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoadCandidate = el.as<World::RoadElement>(); if (elRoadCandidate != nullptr) { elRoad = elRoadCandidate; break; } } } if (elRoad == nullptr) { return std::nullopt; } GameCommands::RoadStationPlacementArgs placementArgs; placementArgs.pos = World::Pos3(pos.x, pos.y, elRoad->baseHeight()); placementArgs.rotation = elRoad->rotation(); placementArgs.roadId = elRoad->roadId(); placementArgs.index = elRoad->sequenceIndex(); placementArgs.roadObjectId = elRoad->roadObjectId(); placementArgs.type = _cState->lastSelectedStationType; return { placementArgs }; } // 0x004A548F static void onToolUpRoadStation(const int16_t x, const int16_t y) { removeConstructionGhosts(); const auto args = getRoadStationPlacementArgsFromCursor(x, y); if (!args) { return; } const auto* roadStationObject = ObjectManager::get<RoadStationObject>(_cState->lastSelectedStationType); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(roadStationObject->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); if (GameCommands::doCommand(*args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } static std::optional<GameCommands::TrainStationPlacementArgs> getTrainStationPlacementArgsFromCursor(const int16_t x, const int16_t y) { const auto res = ViewportInteraction::getMapCoordinatesFromPos(x, y, ~(ViewportInteraction::InteractionItemFlags::track | ViewportInteraction::InteractionItemFlags::station)); const auto& interaction = res.first; if (interaction.type != ViewportInteraction::InteractionItem::track && interaction.type != ViewportInteraction::InteractionItem::trainStation) { return std::nullopt; } auto* elTrack = reinterpret_cast<const TileElement*>(interaction.object)->as<TrackElement>(); auto* elStation = reinterpret_cast<const TileElement*>(interaction.object)->as<StationElement>(); if (elTrack == nullptr && elStation == nullptr) { return std::nullopt; } // Deliberately always passing track and not station element, even if nullptr return getTrainStationPlacementArgs(interaction.pos, elTrack); } static std::optional<GameCommands::TrainStationPlacementArgs> getTrainStationPlacementArgs(const World::Pos2 pos, const TrackElement* elTrack) { if (elTrack == nullptr) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrackCandidate = el.as<World::TrackElement>(); if (elTrackCandidate != nullptr) { elTrack = elTrackCandidate; break; } } } if (elTrack == nullptr) { return std::nullopt; } GameCommands::TrainStationPlacementArgs placementArgs; placementArgs.pos = World::Pos3(pos.x, pos.y, elTrack->baseHeight()); placementArgs.rotation = elTrack->rotation(); placementArgs.trackId = elTrack->trackId(); placementArgs.index = elTrack->sequenceIndex(); placementArgs.trackObjectId = elTrack->trackObjectId(); placementArgs.type = _cState->lastSelectedStationType; return { placementArgs }; } // 0x004A5390 static void onToolUpTrainStation(const int16_t x, const int16_t y) { removeConstructionGhosts(); const auto args = getTrainStationPlacementArgsFromCursor(x, y); if (!args) { return; } const auto* trainStationObject = ObjectManager::get<TrainStationObject>(_cState->lastSelectedStationType); auto formatArgs = FormatArguments::common(); formatArgs.skip(3 * sizeof(StringId)); formatArgs.push(trainStationObject->name); GameCommands::setErrorTitle(StringIds::cant_build_pop3_string); if (args->trackObjectId != _cState->trackType) { Error::open(StringIds::null, StringIds::wrong_type_of_track_road); return; } if (GameCommands::doCommand(*args, GameCommands::Flags::apply) != GameCommands::FAILURE) { Audio::playSound(Audio::SoundId::construct, GameCommands::getPosition()); } } static void onToolUpSingle(const int16_t x, const int16_t y) { if (_cState->byte_1136063 & (1 << 7)) { onToolUpAirport(x, y); } else if (_cState->byte_1136063 & (1 << 6)) { onToolUpDock(x, y); } else if (_cState->trackType & (1 << 7)) { onToolUpRoadStation(x, y); } else { onToolUpTrainStation(x, y); } } static uint32_t constructPieceAtPosition(World::Pos2 pos) { if (_cState->byte_1136063 & (1 << 7)) { if (auto args = getAirportPlacementArgs(pos)) { return GameCommands::doCommand(*args, GameCommands::Flags::apply); } } else if (_cState->byte_1136063 & (1 << 6)) { if (auto args = getDockPlacementArgs(pos)) { return GameCommands::doCommand(*args, GameCommands::Flags::apply); } } else if (_cState->trackType & (1 << 7)) { if (auto args = getRoadStationPlacementArgs(pos, nullptr)) { return GameCommands::doCommand(*args, GameCommands::Flags::apply); } } else { if (auto args = getTrainStationPlacementArgs(pos, nullptr)) { return GameCommands::doCommand(*args, GameCommands::Flags::apply); } } return GameCommands::FAILURE; } static void onToolUpMultiple() { mapInvalidateSelectionRect(); removeConstructionGhosts(); World::resetMapSelectionFlags(); auto dirX = _toolPosDrag.x - _toolPosInitial.x > 0 ? 1 : -1; auto dirY = _toolPosDrag.y - _toolPosInitial.y > 0 ? 1 : -1; bool builtAnything = false; for (auto yPos = _toolPosInitial.y; yPos != _toolPosDrag.y + dirY; yPos += dirY) { for (auto xPos = _toolPosInitial.x; xPos != _toolPosDrag.x + dirX; xPos += dirX) { auto pos = World::toWorldSpace({ xPos, yPos }); _cState->x = pos.x; _cState->y = pos.y; auto height = TileManager::getHeight(pos); _cState->constructionZ = height.landHeight; // Try placing the station at this location, ignoring errors if they occur _suppressErrorSound = true; builtAnything |= constructPieceAtPosition(pos) != GameCommands::FAILURE; _suppressErrorSound = false; } } if (builtAnything) { WindowManager::close(WindowType::error); } // Leave the tool active, but make ghost piece visible for the next round _isDragging = false; } // 0x0049E42C static void onToolUp([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id, const int16_t x, const int16_t y) { if (widgetIndex != widx::image) { return; } if (_isDragging) { onToolUpMultiple(); } else { onToolUpSingle(x, y); } } static void onToolAbort([[maybe_unused]] Window& self, const WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex != widx::image) { return; } _isDragging = false; } // 0x0049DD39 static void prepareDraw(Window& self) { Common::prepareDraw(&self); self.widgets[widx::rotate].hidden = true; auto captionArgs = FormatArguments(self.widgets[Common::widx::caption].textArgs); if (_cState->byte_1136063 & (1 << 7)) { self.widgets[widx::rotate].hidden = false; auto airportObj = ObjectManager::get<AirportObject>(_cState->lastSelectedStationType); self.widgets[widx::station].text = airportObj->name; captionArgs.push(StringIds::title_airport); } else if (_cState->byte_1136063 & (1 << 6)) { auto dockObj = ObjectManager::get<DockObject>(_cState->lastSelectedStationType); self.widgets[widx::station].text = dockObj->name; captionArgs.push(StringIds::title_ship_port); } else if (_cState->trackType & (1 << 7)) { auto trackType = _cState->trackType & ~(1 << 7); auto roadObj = ObjectManager::get<RoadObject>(trackType); captionArgs.push(roadObj->name); auto roadStationObject = ObjectManager::get<RoadStationObject>(_cState->lastSelectedStationType); self.widgets[widx::station].text = roadStationObject->name; } else { auto trackObj = ObjectManager::get<TrackObject>(_cState->trackType); captionArgs.push(trackObj->name); auto trainStationObject = ObjectManager::get<TrainStationObject>(_cState->lastSelectedStationType); self.widgets[widx::station].text = trainStationObject->name; } Common::repositionTabs(&self); } // 0x0049DE40 static void draw(Window& self, Gfx::DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); self.draw(drawingCtx); Common::drawTabs(self, drawingCtx); auto company = CompanyManager::getPlayerCompany(); auto companyColour = company->mainColours.primary; int16_t xPos = self.widgets[widx::image].left + self.x; int16_t yPos = self.widgets[widx::image].top + self.y; if (_cState->byte_1136063 & (1 << 7)) { auto airportObj = ObjectManager::get<AirportObject>(_cState->lastSelectedStationType); auto imageId = Gfx::recolour(airportObj->image, companyColour); drawingCtx.drawImage(xPos, yPos, imageId); } else if (_cState->byte_1136063 & (1 << 6)) { auto dockObj = ObjectManager::get<DockObject>(_cState->lastSelectedStationType); auto imageId = Gfx::recolour(dockObj->image, companyColour); drawingCtx.drawImage(xPos, yPos, imageId); } else if (_cState->trackType & (1 << 7)) { auto roadStationObj = ObjectManager::get<RoadStationObject>(_cState->lastSelectedStationType); auto imageId = Gfx::recolour(roadStationObj->image + RoadStation::ImageIds::preview_image, companyColour); drawingCtx.drawImage(xPos, yPos, imageId); auto colour = Colours::getTranslucent(companyColour); if (!roadStationObj->hasFlags(RoadStationFlags::recolourable)) { colour = ExtColour::unk2E; } imageId = Gfx::recolourTranslucent(roadStationObj->image + RoadStation::ImageIds::preview_image_windows, colour); drawingCtx.drawImage(xPos, yPos, imageId); } else { auto trainStationObj = ObjectManager::get<TrainStationObject>(_cState->lastSelectedStationType); auto imageId = Gfx::recolour(trainStationObj->image + TrainStation::ImageIds::preview_image, companyColour); drawingCtx.drawImage(xPos, yPos, imageId); auto colour = Colours::getTranslucent(companyColour); if (!trainStationObj->hasFlags(TrainStationFlags::recolourable)) { colour = ExtColour::unk2E; } imageId = Gfx::recolourTranslucent(trainStationObj->image + TrainStation::ImageIds::preview_image_windows, colour); drawingCtx.drawImage(xPos, yPos, imageId); } if (_cState->stationCost != 0x80000000 && _cState->stationCost != 0) { auto& widget = self.widgets[widx::image]; auto point = Point(self.x + 69, widget.bottom + self.y + 4); FormatArguments args{}; args.push<uint32_t>(_cState->stationCost); tr.drawStringCentred(point, Colour::black, StringIds::build_cost, args); } xPos = self.x + 3; yPos = self.widgets[widx::image].bottom + self.y + 16; auto width = self.width - 4; drawingCtx.drawRectInset(xPos, yPos, width, 1, self.getColour(WindowColour::secondary), Gfx::RectInsetFlags::borderInset); if ((_ghostVisibilityFlags & GhostVisibilityFlags::station) == GhostVisibilityFlags::none) { return; } FormatArguments args{}; // Todo: change globals type to be StationId and make this StationId::null if (_cState->constructingStationId == 0xFFFFFFFF) { args.push(StringIds::new_station); } else { auto station = StationManager::get(StationId(_cState->constructingStationId)); args.push(station->name); args.push(station->town); } xPos = self.x + 69; yPos = self.widgets[widx::image].bottom + self.y + 18; auto origin = Point(xPos, yPos); width = self.width - 4; tr.drawStringCentredClipped(origin, width, Colour::black, StringIds::new_station_buffer, args); xPos = self.x + 2; yPos = self.widgets[widx::image].bottom + self.y + 29; origin = Point(xPos, yPos); origin = tr.drawStringLeft(origin, Colour::black, StringIds::catchment_area_accepts); if (_cState->constructingStationAcceptedCargoTypes == 0) { origin = tr.drawStringLeft(origin, Colour::black, StringIds::catchment_area_nothing); } else { yPos--; for (uint8_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::cargo); i++) { if (_cState->constructingStationAcceptedCargoTypes & (1 << i)) { auto xPosMax = self.x + self.width - 12; if (origin.x <= xPosMax) { auto cargoObj = ObjectManager::get<CargoObject>(i); drawingCtx.drawImage(origin.x, origin.y, cargoObj->unitInlineSprite); origin.x += 10; } } } } xPos = self.x + 2; yPos = self.widgets[widx::image].bottom + self.y + 49; origin = Point(xPos, yPos); origin = tr.drawStringLeft(origin, Colour::black, StringIds::catchment_area_produces); if (_cState->constructingStationProducedCargoTypes == 0) { origin = tr.drawStringLeft(origin, Colour::black, StringIds::catchment_area_nothing); } else { yPos--; for (uint8_t i = 0; i < ObjectManager::getMaxObjects(ObjectType::cargo); i++) { if (_cState->constructingStationProducedCargoTypes & (1 << i)) { auto xPosMax = self.x + self.width - 12; if (origin.x <= xPosMax) { auto cargoObj = ObjectManager::get<CargoObject>(i); drawingCtx.drawImage(origin.x, origin.y, cargoObj->unitInlineSprite); origin.x += 10; } } } } } void tabReset(Window& self) { self.callOnMouseDown(Station::widx::image, self.widgets[Station::widx::image].id); } static constexpr WindowEventList kEvents = { .onClose = Common::onClose, .onMouseUp = onMouseUp, .onMouseDown = onMouseDown, .onDropdown = onDropdown, .onUpdate = onUpdate, .onToolUpdate = onToolUpdate, .onToolDown = onToolDown, .toolDrag = onToolDrag, .toolUp = onToolUp, .onToolAbort = onToolAbort, .prepareDraw = prepareDraw, .draw = draw, }; const WindowEventList& getEvents() { return kEvents; } // 0x0049E1F1 void sub_49E1F1(StationId id) { auto w = WindowManager::find(WindowType::construction); if (w != nullptr && w->currentTab == 1) { if (((*_ghostVisibilityFlags & GhostVisibilityFlags::station) != GhostVisibilityFlags::none) && StationId(_cState->constructingStationId) == id) // _constructingStationId { _cState->constructingStationId = 0xFFFFFFFFU; w->invalidate(); } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/News/Common.cpp ```cpp #include "Audio/Audio.h" #include "Config.h" #include "Graphics/Colour.h" #include "Message.h" #include "MessageManager.h" #include "News.h" #include "Objects/InterfaceSkinObject.h" #include "Objects/ObjectManager.h" #include "SceneManager.h" #include "Ui/Widgets/NewsPanelWidget.h" #include "World/CompanyManager.h" namespace OpenLoco::Ui::Windows::NewsWindow { NewsState _nState{}; static void createNewsWindow(Ui::Size32 kWindowSize, std::span<const Widget> widgets, AdvancedColour colour, bool isOld, WindowFlags flags) { _nState.slideInHeight = 5; int16_t y = Ui::height() - _nState.slideInHeight; if (SceneManager::getGameSpeed() != GameSpeed::Normal || isOld) { y = Ui::height() - kWindowSize.height; _nState.slideInHeight = kWindowSize.height; } int16_t x = (Ui::width() / 2) - (kWindowSize.width / 2); auto window = WindowManager::createWindow( WindowType::news, { x, y }, kWindowSize, flags, Common::getEvents()); window->setWidgets(widgets); window->initScrollWidgets(); window->setColour(WindowColour::primary, colour); _nState.savedView[0].clear(); _nState.savedView[1].clear(); Common::initViewports(*window); } // 0x00428F8B void open(MessageId messageIndex) { bool isOld = false; auto news = MessageManager::get(messageIndex); if (news == nullptr) { return; } if ((news->timeActive != 0) && (SceneManager::getSceneAge() >= 10)) { isOld = true; } MessageManager::setActiveIndex(messageIndex); const auto& mtd = getMessageTypeDescriptor(news->type); if (!isOld) { auto messageSubType = mtd.criticality; if (messageSubType == MessageCriticality::majorCompany) { if (news->companyId != CompanyManager::getControllingId()) { messageSubType = MessageCriticality::majorCompetitor; } } if (messageSubType == MessageCriticality::minorCompany) { if (news->companyId != CompanyManager::getControllingId()) { messageSubType = MessageCriticality::minorCompetitor; } } auto newsSettings = Config::get().newsSettings[static_cast<uint8_t>(messageSubType)]; if (newsSettings == Config::NewsType::none) { news->setActive(false); return; } if (newsSettings == Config::NewsType::ticker) { _nState.numCharsToDisplay = 0; WindowFlags flags = WindowFlags::stickToFront | WindowFlags::viewportNoScrolling | WindowFlags::transparent | WindowFlags::flag_7; auto window = WindowManager::createWindow( WindowType::news, { Ui::width() - 138, Ui::height() - 25 }, Ticker::kWindowSize, flags, Ticker::getEvents()); window->setWidgets(Ticker::getWidgets()); window->initScrollWidgets(); auto skin = ObjectManager::get<InterfaceSkinObject>(); window->setColour(WindowColour::primary, AdvancedColour(skin->windowColour).translucent()); window->var_852 = 0; return; } } if (!isOld) { Audio::SoundId soundId = Audio::SoundId::notification; if (!Config::get().audio.playNewsSounds) { soundId = Audio::SoundId::null; } else if (news->companyId == CompanyId::null || news->companyId == CompanyManager::getControllingId()) { soundId = mtd.sound; } if (soundId != Audio::SoundId::null) { int32_t pan = Ui::width() / 2; Audio::playSound(soundId, pan); } } if (mtd.hasFlag(MessageTypeFlags::unk1)) { WindowFlags flags = WindowFlags::stickToFront | WindowFlags::viewportNoScrolling | WindowFlags::transparent | WindowFlags::noBackground; createNewsWindow(News2::kWindowSize, News2::getWidgets(), Colour::grey, isOld, flags); } else { WindowFlags flags = WindowFlags::stickToFront | WindowFlags::viewportNoScrolling | WindowFlags::transparent; constexpr auto colour = AdvancedColour(Colour::mutedDarkRed).translucent(); createNewsWindow(News1::kWindowSize, News1::getWidgets(), colour, isOld, flags); } } // 0x0042AC27 void openLastMessage() { if (MessageManager::getActiveIndex() != MessageId::null) { auto message = MessageManager::get(MessageManager::getActiveIndex()); if (message->isActive()) { // If the current active message was user selected then remove from queue of active messages if (message->isUserSelected()) { message->setActive(false); } } } MessageManager::setActiveIndex(MessageId::null); WindowManager::close(WindowType::news, 0); if (MessageManager::getNumMessages() != 0) { auto message = MessageManager::get(MessageId(MessageManager::getNumMessages() - 1)); message->setUserSelected(); message->timeActive++; NewsWindow::open(MessageId(MessageManager::getNumMessages() - 1)); } } void close(Window* self) { // Only affects the newspaper view; the ticker ignores this widget self->callOnMouseUp(Common::close_button, self->widgets[Common::close_button].id); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/News/News.cpp ```cpp #include "News.h" #include "Date.h" #include "Entities/EntityManager.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/TileManager.h" #include "Message.h" #include "MessageManager.h" #include "Objects/CompetitorObject.h" #include "Objects/ObjectManager.h" #include "Objects/VehicleObject.h" #include "Ui/Widget.h" #include "Ui/Widgets/NewsPanelWidget.h" #include "Ui/Widgets/PanelWidget.h" #include "Ui/Widgets/Wt3Widget.h" #include "Ui/Window.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleDraw.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" namespace OpenLoco::Ui::Windows::NewsWindow { namespace News1 { static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets<Widgets::Panel>(360, 117) ); std::span<const Widget> getWidgets() { return widgets; } } namespace News2 { static constexpr auto widgets = makeWidgets( Common::makeCommonWidgets<Widgets::NewsPanel>(360, 159) ); std::span<const Widget> getWidgets() { return widgets; } } namespace Common { // 0x00429BB7 static void onMouseUp([[maybe_unused]] Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { switch (widgetIndex) { case Common::widx::close_button: { MessageManager::clearActiveMessage(); break; } case Common::widx::viewport1Button: case Common::widx::viewport2Button: { if (MessageManager::getActiveIndex() != MessageId::null) { auto news = MessageManager::get(MessageManager::getActiveIndex()); const auto& mtd = getMessageTypeDescriptor(news->type); if (widgetIndex == Common::widx::viewport1Button) { if (!mtd.hasFlag(MessageTypeFlags::hasFirstItem)) { break; } } else { if (!mtd.hasFlag(MessageTypeFlags::hasSecondItem)) { break; } } MessageItemArgumentType itemType; uint16_t itemId; if (widgetIndex == Common::widx::viewport1Button) { itemType = mtd.argumentTypes[0]; itemId = news->itemSubjects[0]; } else { itemType = mtd.argumentTypes[1]; itemId = news->itemSubjects[1]; } switch (itemType) { case MessageItemArgumentType::industry: Ui::Windows::Industry::open(IndustryId(itemId)); break; case MessageItemArgumentType::station: Ui::Windows::Station::open(StationId(itemId)); break; case MessageItemArgumentType::town: Ui::Windows::Town::open(itemId); break; case MessageItemArgumentType::vehicle: { auto vehicle = EntityManager::get<Vehicles::VehicleBase>(EntityId(itemId)); Ui::Windows::Vehicle::Main::open(vehicle); break; } case MessageItemArgumentType::company: Ui::Windows::CompanyWindow::open(CompanyId(itemId)); break; case MessageItemArgumentType::location: case MessageItemArgumentType::unk6: case MessageItemArgumentType::null: break; case MessageItemArgumentType::vehicleTab: Ui::Windows::BuildVehicle::openByVehicleObjectId(itemId); break; } } } } } // 0x00429D2C static void onUpdate(Window& self) { uint16_t height = _nState.slideInHeight + 4; _nState.slideInHeight = std::min(height, self.height); height = Ui::height() - _nState.slideInHeight - self.y; auto width = (Ui::width() / 2) - (self.width / 2) - self.x; if (width != 0 || height != 0) { self.invalidate(); self.y += height; self.x += width; if (self.viewports[0] != nullptr) { self.viewports[0]->x += width; self.viewports[0]->y += height; } if (self.viewports[1] != nullptr) { self.viewports[1]->x += width; self.viewports[1]->y += height; } self.invalidate(); } } static SavedView getView(Window* self, Message* news, uint16_t itemId, MessageItemArgumentType itemType, bool* selectable) { SavedView view; view.mapX = -1; view.mapY = -1; view.surfaceZ = -1; view.rotation = -1; view.zoomLevel = (ZoomLevel)0xFFU; view.entityId = EntityId::null; switch (itemType) { case MessageItemArgumentType::industry: { auto industry = IndustryManager::get(IndustryId(itemId)); view.mapX = industry->x; view.mapY = industry->y; view.surfaceZ = World::TileManager::getHeight({ view.mapX, view.mapY }).landHeight; view.rotation = WindowManager::getCurrentRotation(); view.zoomLevel = ZoomLevel::half; *selectable = true; break; } case MessageItemArgumentType::station: { auto station = StationManager::get(StationId(itemId)); view.mapX = station->x; view.mapY = station->y; view.surfaceZ = station->z; view.rotation = WindowManager::getCurrentRotation(); view.zoomLevel = ZoomLevel::full; *selectable = true; break; } case MessageItemArgumentType::town: { auto town = TownManager::get(TownId(itemId)); view.mapX = town->x; view.mapY = town->y; view.surfaceZ = World::TileManager::getHeight({ view.mapX, view.mapY }).landHeight; view.rotation = WindowManager::getCurrentRotation(); view.zoomLevel = ZoomLevel::half; *selectable = true; break; } case MessageItemArgumentType::vehicle: { auto* head = EntityManager::get<Vehicles::VehicleHead>(EntityId(itemId)); if (head == nullptr) { break; } Vehicles::Vehicle train(*head); if (train.head->tileX == -1) { break; } view.entityId = train.veh2->id; if (!train.cars.empty()) { view.entityId = train.cars.firstCar.body->id; } view.flags = (1 << 15); view.zoomLevel = ZoomLevel::full; view.rotation = WindowManager::getCurrentRotation(); *selectable = true; break; } case MessageItemArgumentType::company: // Used to indicate to drawNewsSubjectImages to draw a company image // TODO: Do this better view.zoomLevel = enumValue(SubjectType::companyFace); self->invalidate(); *selectable = true; break; case MessageItemArgumentType::location: view.mapX = news->itemSubjects[0]; // possible union? view.mapY = news->itemSubjects[1]; view.surfaceZ = World::TileManager::getHeight({ view.mapX, view.mapY }).landHeight; view.zoomLevel = ZoomLevel::full; view.rotation = WindowManager::getCurrentRotation(); *selectable = true; break; case MessageItemArgumentType::unk6: case MessageItemArgumentType::null: break; case MessageItemArgumentType::vehicleTab: // Used to indicate to drawNewsSubjectImages to draw a vehicle image // TODO: Do this better view.zoomLevel = enumValue(SubjectType::vehicleImage); self->invalidate(); *selectable = true; break; } return view; } // TODO: deduplicate with initViewport1 static void initViewport0(Window& self) { SavedView view; view.mapX = -1; view.mapY = -1; view.surfaceZ = -1; view.rotation = -1; view.zoomLevel = (ZoomLevel)0xFFU; view.entityId = EntityId::null; auto news = MessageManager::get(MessageManager::getActiveIndex()); const auto& mtd = getMessageTypeDescriptor(news->type); bool selectable = false; if (MessageManager::getActiveIndex() != MessageId::null) { if (mtd.hasFlag(MessageTypeFlags::hasFirstItem)) { auto itemType = mtd.argumentTypes[0]; if (news->itemSubjects[0] != 0xFFFF) { view = getView(&self, news, news->itemSubjects[0], itemType, &selectable); } } } self.widgets[Common::widx::viewport1].hidden = true; self.widgets[Common::widx::viewport1Button].hidden = true; if (!view.isEmpty()) { self.widgets[Common::widx::viewport1].hidden = false; } if (selectable) { self.widgets[Common::widx::viewport1Button].hidden = false; } if (_nState.savedView[0] != view) { _nState.savedView[0] = view; self.viewportRemove(0); self.invalidate(); self.widgets[Common::widx::viewport1].left = 6; self.widgets[Common::widx::viewport1].right = 353; self.widgets[Common::widx::viewport1Button].left = 4; self.widgets[Common::widx::viewport1Button].right = 355; if (mtd.hasFlag(MessageTypeFlags::hasSecondItem)) { self.widgets[Common::widx::viewport1].left = 6; self.widgets[Common::widx::viewport1].right = 173; self.widgets[Common::widx::viewport1Button].left = 4; self.widgets[Common::widx::viewport1Button].right = 175; } if (!view.isEmpty()) { int16_t x = self.widgets[Common::widx::viewport1].left + 1 + self.x; int16_t y = self.widgets[Common::widx::viewport1].top + 1 + self.y; Ui::Point origin = { x, y }; uint16_t viewportWidth = self.widgets[Common::widx::viewport1].width(); uint16_t viewportHeight = 62; Ui::Size viewportSize = { viewportWidth, viewportHeight }; if (mtd.hasFlag(MessageTypeFlags::unk1)) { x = self.widgets[Common::widx::viewport1].left + self.x; y = self.widgets[Common::widx::viewport1].top + self.y; origin = { x, y }; viewportWidth = self.widgets[Common::widx::viewport1].width() + 2; viewportHeight = 64; viewportSize = { viewportWidth, viewportHeight }; } if (view.isEntityView()) { ViewportManager::create(&self, 0, origin, viewportSize, view.zoomLevel, view.entityId); } else { ViewportManager::create(&self, 0, origin, viewportSize, view.zoomLevel, view.getPos()); } self.invalidate(); } } } // TODO: deduplicate with initViewport0 static void initViewport1(Window& self) { SavedView view; view.mapX = -1; view.mapY = -1; view.surfaceZ = -1; view.rotation = -1; view.zoomLevel = (ZoomLevel)0xFFU; view.entityId = EntityId::null; auto news = MessageManager::get(MessageManager::getActiveIndex()); const auto& mtd = getMessageTypeDescriptor(news->type); bool selectable = false; if (MessageManager::getActiveIndex() != MessageId::null) { if (mtd.hasFlag(MessageTypeFlags::hasSecondItem)) { auto itemType = mtd.argumentTypes[1]; if (news->itemSubjects[1] != 0xFFFF) { view = getView(&self, news, news->itemSubjects[1], itemType, &selectable); } } } self.widgets[Common::widx::viewport2].hidden = true; self.widgets[Common::widx::viewport2Button].hidden = true; if (!view.isEmpty()) { self.widgets[Common::widx::viewport2].hidden = false; } if (selectable) { self.widgets[Common::widx::viewport2Button].hidden = false; } if (_nState.savedView[1] != view) { _nState.savedView[1] = view; self.viewportRemove(1); self.invalidate(); self.widgets[Common::widx::viewport2].left = 186; self.widgets[Common::widx::viewport2].right = 353; self.widgets[Common::widx::viewport2Button].left = 184; self.widgets[Common::widx::viewport2Button].right = 355; if (!view.isEmpty()) { int16_t x = self.widgets[Common::widx::viewport2].left + 1 + self.x; int16_t y = self.widgets[Common::widx::viewport2].top + 1 + self.y; Ui::Point origin = { x, y }; uint16_t viewportWidth = self.widgets[Common::widx::viewport2].width(); uint16_t viewportHeight = 62; Ui::Size viewportSize = { viewportWidth, viewportHeight }; if (mtd.hasFlag(MessageTypeFlags::unk1)) { x = self.widgets[Common::widx::viewport2].left + self.x; y = self.widgets[Common::widx::viewport2].top + self.y; origin = { x, y }; viewportWidth = self.widgets[Common::widx::viewport2].width() + 2; viewportHeight = 64; viewportSize = { viewportWidth, viewportHeight }; } ViewportManager::create(&self, 1, origin, viewportSize, view.zoomLevel, view.getPos()); self.invalidate(); } } } // 0x00429209 void initViewports(Window& self) { initViewport0(self); initViewport1(self); } // 0x0042A136 static void drawNewsSubjectImages(Window* self, Gfx::DrawingContext& drawingCtx, Message* news) { for (auto i = 0; i < 2; ++i) { const auto itemSubject = news->itemSubjects[i]; const auto& viewWidget = self->widgets[Common::widx::viewport1 + i]; const SubjectType subjectType = SubjectType((uint8_t)_nState.savedView[i].zoomLevel); if (subjectType == SubjectType::companyFace && itemSubject != 0xFFFFU) { const auto* company = CompanyManager::get(CompanyId(itemSubject)); const auto* competitorObj = ObjectManager::get<CompetitorObject>(company->competitorId); const auto imageIndexBase = competitorObj->images[enumValue(company->ownerEmotion)]; const ImageId imageId(imageIndexBase + 1, company->mainColours.primary); const auto x = self->x + viewWidget.midX() - 31; const auto y = self->y + viewWidget.midY() - 31; drawingCtx.drawImage(Ui::Point(x, y), imageId); if (company->jailStatus != 0) { drawingCtx.drawImage(Ui::Point(x, y), ImageId(ImageIds::owner_jailed)); } } if (subjectType == SubjectType::vehicleImage && itemSubject != 0xFFFFU) { const auto x = self->x + viewWidget.left; const auto y = self->y + viewWidget.top; const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(x + 1, y + 1, viewWidget.width() - 2, viewWidget.height() - 2)); if (clipped) { drawingCtx.pushRenderTarget(*clipped); drawVehicleOverview( drawingCtx, { viewWidget.midX(), 35 }, itemSubject, Ui::WindowManager::getVehiclePreviewRotationFrameYaw(), Ui::WindowManager::getVehiclePreviewRotationFrameRoll(), CompanyManager::getControllingId()); drawingCtx.popRenderTarget(); } } } } // 0x0042A036 static void drawViewportString(Gfx::DrawingContext& drawingCtx, Point origin, uint16_t width, MessageItemArgumentType itemType, uint16_t itemIndex) { FormatArguments args{}; switch (itemType) { case MessageItemArgumentType::industry: { auto industry = IndustryManager::get(IndustryId(itemIndex)); args.push(industry->name); args.push(industry->town); break; } case MessageItemArgumentType::station: { auto station = StationManager::get(StationId(itemIndex)); args.push(station->name); args.push(station->town); break; } case MessageItemArgumentType::town: { auto town = TownManager::get(TownId(itemIndex)); args.push(town->name); break; } case MessageItemArgumentType::vehicle: { auto vehicle = EntityManager::get<Vehicles::VehicleHead>(EntityId(itemIndex)); if (vehicle == nullptr) { // We could close the window now but then we can't view old news about removed vehicles. return; } auto company = CompanyManager::get(vehicle->owner); if (CompanyManager::isPlayerCompany(vehicle->owner)) { args.push(StringIds::company_vehicle); } else { args.push(StringIds::competitor_vehicle); } args.push(company->name); args.skip(2); args.push(vehicle->name); args.push(vehicle->ordinalNumber); break; } case MessageItemArgumentType::company: { auto company = CompanyManager::get(CompanyId(itemIndex)); args.push(company->name); break; } case MessageItemArgumentType::location: case MessageItemArgumentType::unk6: case MessageItemArgumentType::null: break; case MessageItemArgumentType::vehicleTab: { auto vehicleObj = ObjectManager::get<VehicleObject>(itemIndex); args.push(vehicleObj->name); break; } } switch (itemType) { case MessageItemArgumentType::industry: case MessageItemArgumentType::station: case MessageItemArgumentType::town: case MessageItemArgumentType::vehicle: case MessageItemArgumentType::company: case MessageItemArgumentType::vehicleTab: { auto tr = Gfx::TextRenderer(drawingCtx); tr.drawStringCentredClipped(origin, width, Colour::black, StringIds::black_tiny_font, args); break; } case MessageItemArgumentType::location: case MessageItemArgumentType::unk6: case MessageItemArgumentType::null: break; } } // 0x00429872 static void drawLateNews(Window& self, Gfx::DrawingContext& drawingCtx, Message* news) { // TODO: This should be a proper setter and we should obtain it type safe. self.widgets[Common::widx::frame].styleData = enumValue(Widgets::NewsPanel::Style::new_); self.draw(drawingCtx); auto tr = Gfx::TextRenderer(drawingCtx); char* newsString = news->messageString; auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); const auto& mtd = getMessageTypeDescriptor(news->type); if (!mtd.hasFlag(MessageTypeFlags::unk5)) { tr.setCurrentFont(Gfx::Font::large); } *buffer = ControlCodes::Colour::black; buffer++; strncpy(buffer, newsString, 512); int16_t x = (self.width / 2) + self.x; int16_t y = self.y + 38; Ui::Point origin = { x, y }; tr.drawStringCentredWrapped(origin, 352, Colour::black, StringIds::buffer_2039); x = self.x + 1; y = self.y + 1; origin = { x, y }; auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(news->date); tr.drawStringLeft(origin, Colour::black, StringIds::news_date, args); drawNewsSubjectImages(&self, drawingCtx, news); } // 0x00429934 static void drawMiddleNews(Window& self, Gfx::DrawingContext& drawingCtx, Message* news) { const auto& mtd = getMessageTypeDescriptor(news->type); if (mtd.hasFlag(MessageTypeFlags::hasFirstItem)) { if (mtd.hasFlag(MessageTypeFlags::unk1)) { if (news->itemSubjects[0] != 0xFFFF) { auto x = self.widgets[Common::widx::viewport1].left + self.x; auto y = self.widgets[Common::widx::viewport1].top + self.y; auto width = self.widgets[Common::widx::viewport1].width() + 1; auto height = self.widgets[Common::widx::viewport1].height() + 1; constexpr auto colour = enumValue(ExtColour::translucentGrey1); drawingCtx.drawRect(x, y, width, height, colour, Gfx::RectFlags::transparent); } } } if (mtd.hasFlag(MessageTypeFlags::hasSecondItem)) { if (mtd.hasFlag(MessageTypeFlags::unk1)) { if (news->itemSubjects[1] != 0xFFFF) { auto x = self.widgets[Common::widx::viewport2].left + self.x; auto y = self.widgets[Common::widx::viewport2].top + self.y; auto width = self.widgets[Common::widx::viewport2].width() + 1; auto height = self.widgets[Common::widx::viewport2].height() + 1; constexpr auto colour = enumValue(ExtColour::translucentGrey1); drawingCtx.drawRect(x, y, width, height, colour, Gfx::RectFlags::transparent); } } } } // 0x004299E7 static void drawEarlyNews(Window& self, Gfx::DrawingContext& drawingCtx, Message* news) { // TODO: This should be a proper setter and we should obtain it type safe. self.widgets[Common::widx::frame].styleData = enumValue(Widgets::NewsPanel::Style::old); self.draw(drawingCtx); auto tr = Gfx::TextRenderer(drawingCtx); char* newsString = news->messageString; auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); const auto& mtd = getMessageTypeDescriptor(news->type); if (!mtd.hasFlag(MessageTypeFlags::unk5)) { tr.setCurrentFont(Gfx::Font::large); } *buffer = ControlCodes::Colour::black; buffer++; strncpy(buffer, newsString, 512); int16_t x = (self.width / 2) + self.x; int16_t y = self.y + 38; Ui::Point origin = { x, y }; tr.drawStringCentredWrapped(origin, 352, Colour::black, StringIds::buffer_2039); origin.x = self.x + 4; origin.y = self.y + 5; auto argsBuf = FormatArgumentsBuffer{}; auto args = FormatArguments{ argsBuf }; args.push(news->date); tr.drawStringLeft(origin, Colour::black, StringIds::news_date, args); drawNewsSubjectImages(&self, drawingCtx, news); x = self.x + 3; y = self.y + 5; auto width = self.width - 6; auto height = self.height; auto colour = enumValue(ExtColour::translucentBrown1); drawingCtx.drawRect(x, y, width, height, colour, Gfx::RectFlags::transparent); x = self.widgets[Common::widx::viewport1].left + self.x; y = self.widgets[Common::widx::viewport1].top + self.y; width = self.widgets[Common::widx::viewport1].width(); height = self.widgets[Common::widx::viewport1].height(); colour = enumValue(ExtColour::translucentBrown1); drawingCtx.drawRect(x, y, width, height, colour, Gfx::RectFlags::transparent); } // 0x00429761 static void drawStationNews(Window& self, Gfx::DrawingContext& drawingCtx, Message* news) { self.draw(drawingCtx); auto tr = Gfx::TextRenderer(drawingCtx); char* newsString = news->messageString; auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); *buffer = ControlCodes::Colour::black; buffer++; strncpy(buffer, newsString, 512); int16_t x = (self.width / 2) + self.x; int16_t y = self.y + 17; Ui::Point origin = { x, y }; tr.drawStringCentredWrapped(origin, 338, Colour::black, StringIds::buffer_2039); const auto& mtd = getMessageTypeDescriptor(news->type); if (mtd.hasFlag(MessageTypeFlags::hasFirstItem)) { if (mtd.hasFlag(MessageTypeFlags::unk1)) { if (news->itemSubjects[0] != 0xFFFF) { x = self.widgets[Common::widx::viewport1].left + self.x; y = self.widgets[Common::widx::viewport1].top + self.y; auto width = self.widgets[Common::widx::viewport1].width(); auto height = self.widgets[Common::widx::viewport1].height(); constexpr auto colour = enumValue(ExtColour::translucentGrey1); drawingCtx.drawRect(x, y, width, height, colour, Gfx::RectFlags::transparent); } } } if (mtd.hasFlag(MessageTypeFlags::hasSecondItem)) { if (mtd.hasFlag(MessageTypeFlags::unk1)) { if (news->itemSubjects[1] != 0xFFFF) { x = self.widgets[Common::widx::viewport2].left + self.x; y = self.widgets[Common::widx::viewport2].top + self.y; auto width = self.widgets[Common::widx::viewport2].width(); auto height = self.widgets[Common::widx::viewport2].height(); constexpr auto colour = enumValue(ExtColour::translucentGrey1); drawingCtx.drawRect(x, y, width, height, colour, Gfx::RectFlags::transparent); } } } } // 0x00429739 static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { auto news = MessageManager::get(MessageManager::getActiveIndex()); const auto& mtd = getMessageTypeDescriptor(news->type); if (mtd.hasFlag(MessageTypeFlags::unk1)) { if (calcDate(news->date).year >= 1945) { drawLateNews(self, drawingCtx, news); if (calcDate(news->date).year < 1985) { drawMiddleNews(self, drawingCtx, news); } } else { drawEarlyNews(self, drawingCtx, news); } } else { drawStationNews(self, drawingCtx, news); } if (mtd.hasFlag(MessageTypeFlags::hasFirstItem)) { if (news->itemSubjects[0] != 0xFFFF) { auto x = (self.widgets[Common::widx::viewport1Button].left + self.widgets[Common::widx::viewport1Button].right) / 2; x += self.x; auto y = self.widgets[Common::widx::viewport1Button].bottom - 7 + self.y; auto width = self.widgets[Common::widx::viewport1Button].width() - 1; auto point = Point(x, y); drawViewportString(drawingCtx, point, width, mtd.argumentTypes[0], news->itemSubjects[0]); } } if (mtd.hasFlag(MessageTypeFlags::hasSecondItem)) { if (news->itemSubjects[1] != 0xFFFF) { auto x = (self.widgets[Common::widx::viewport2Button].left + self.widgets[Common::widx::viewport2Button].right) / 2; x += self.x; auto y = self.widgets[Common::widx::viewport2Button].bottom - 7 + self.y; auto width = self.widgets[Common::widx::viewport2Button].width() - 1; auto point = Point(x, y); drawViewportString(drawingCtx, point, width, mtd.argumentTypes[1], news->itemSubjects[1]); } } } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = initViewports, .onUpdate = onUpdate, .viewportRotate = initViewports, .draw = draw, }; const WindowEventList& getEvents() { return kEvents; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/News/News.h ```h #pragma once #include "Graphics/Gfx.h" #include "Ui/Widgets/ImageButtonWidget.h" #include "Ui/Widgets/NewsPanelWidget.h" #include "Ui/Widgets/ViewportWidget.h" #include "Ui/WindowManager.h" #include "World/Company.h" namespace OpenLoco::Ui::Windows::NewsWindow { struct NewsState { SavedView savedView[2]; uint16_t slideInHeight; uint16_t numCharsToDisplay; }; enum class SubjectType : int8_t { companyFace = -2, vehicleImage = -3, }; extern NewsState _nState; namespace Common { enum widx { frame, close_button, viewport1, viewport2, viewport1Button, viewport2Button, }; template<typename TFrameWidget> constexpr auto makeCommonWidgets(int32_t frameWidth, int32_t frameHeight) { return makeWidgets( TFrameWidget({ 0, 0 }, { frameWidth, frameHeight }, WindowColour::primary), Widgets::ImageButton({ frameWidth - 15, 2 }, { 13, 13 }, WindowColour::primary, ImageIds::close_button, StringIds::tooltip_close_window), Widgets::Viewport({ 2, frameHeight - 73 }, { 168, 64 }, WindowColour::primary, Widget::kContentUnk), Widgets::Viewport({ 180, frameHeight - 73 }, { 168, 64 }, WindowColour::primary, Widget::kContentUnk), Widgets::ImageButton({ 2, frameHeight - 75 }, { 180, 75 }, WindowColour::primary), Widgets::ImageButton({ 2, frameHeight - 75 }, { 180, 75 }, WindowColour::primary)); } const WindowEventList& getEvents(); void initViewports(Window& self); } namespace News1 { static constexpr Ui::Size32 kWindowSize = { 360, 117 }; std::span<const Widget> getWidgets(); } namespace News2 { static constexpr Ui::Size32 kWindowSize = { 360, 159 }; std::span<const Widget> getWidgets(); } namespace Ticker { static constexpr Ui::Size32 kWindowSize = { 111, 26 }; enum widx { frame, }; std::span<const Widget> getWidgets(); const WindowEventList& getEvents(); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Windows/News/Ticker.cpp ```cpp #include "Audio/Audio.h" #include "Graphics/Colour.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Input.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Message.h" #include "MessageManager.h" #include "News.h" #include "SceneManager.h" #include "Ui/Widget.h" #include "Ui/Widgets/Wt3Widget.h" namespace OpenLoco::Ui::Windows::NewsWindow::Ticker { static constexpr auto widgets = makeWidgets( Widgets::Wt3Widget({ 0, 0 }, { 111, 26 }, WindowColour::primary) ); std::span<const Widget> getWidgets() { return widgets; } // 0x00429EA2 static void onMouseUp(Window& self, WidgetIndex_t widgetIndex, [[maybe_unused]] const WidgetId id) { if (widgetIndex != 0) { return; } if (MessageManager::getActiveIndex() == MessageId::null) { return; } auto news = MessageManager::get(MessageManager::getActiveIndex()); news->setActive(true); news->timeActive++; auto activeMessageIndex = MessageManager::getActiveIndex(); MessageManager::setActiveIndex(MessageId::null); WindowManager::close(&self); open(activeMessageIndex); } // 0x00429FE4 static void onResize(Window& self) { auto y = Ui::height() - kWindowSize.height + 1; auto x = Ui::width() - kWindowSize.width - 27; auto height = kWindowSize.height - 1; if (y != self.y || x != self.x || kWindowSize.width != self.width || height != self.height) { self.invalidate(); self.y = y; self.x = x; self.width = kWindowSize.width; self.height = height; self.invalidate(); } } // 0x00429EEB static void onUpdate(Window& self) { auto cursor = Input::getMouseLocation2(); auto window = WindowManager::findAtAlt(cursor.x, cursor.y); if (window == &self) { self.var_852 = 12; } if (self.var_852 != 0) { if (!SceneManager::isPaused()) { self.var_852--; } } self.invalidate(); if (self.var_852 == 0 && !SceneManager::isPaused()) { _nState.numCharsToDisplay = _nState.numCharsToDisplay + 2; if (!((_nState.numCharsToDisplay & (1 << 15)) || _nState.numCharsToDisplay & 7)) { if (MessageManager::getActiveIndex() != MessageId::null) { auto news = MessageManager::get(MessageManager::getActiveIndex()); auto cx = _nState.numCharsToDisplay >> 2; char* newsString = news->messageString; auto newsStringChar = *newsString; while (true) { newsStringChar = *newsString; if (newsStringChar == ControlCodes::newline) { newsStringChar = ' '; cx--; if (cx < 0) { break; } } if (newsStringChar != static_cast<char>(-1)) { cx--; if (cx < 0) { break; } newsString++; if (!newsStringChar) { break; } } else { cx--; if (cx < 0) { break; } newsString += 3; } } if (newsStringChar != ' ') { if (newsStringChar != 0) { Audio::playSound(Audio::SoundId::ticker, Ui::width()); } } } } } if (MessageManager::getActiveIndex() != MessageId::null) { return; } MessageManager::setActiveIndex(MessageId::null); WindowManager::close(&self); } // 0x00429DAA static void draw(Ui::Window& self, Gfx::DrawingContext& drawingCtx) { if (self.var_852 != 0) { return; } if (SceneManager::getPauseFlags() & (1 << 2)) { return; } auto news = MessageManager::get(MessageManager::getActiveIndex()); auto x = self.x; auto y = self.y; auto width = self.width; auto height = self.height; const auto& rt = drawingCtx.currentRenderTarget(); auto clipped = Gfx::clipRenderTarget(rt, { x, y, width, height }); if (!clipped) { return; } drawingCtx.pushRenderTarget(*clipped); auto colour = Colours::getShade(Colour::white, 5); const auto& mtd = getMessageTypeDescriptor(news->type); if (!mtd.hasFlag(MessageTypeFlags::unk1)) { colour = Colours::getShade(Colour::mutedDarkRed, 5); } auto tr = Gfx::TextRenderer(drawingCtx); drawingCtx.clearSingle(colour); char* newsString = news->messageString; auto buffer = const_cast<char*>(StringManager::getString(StringIds::buffer_2039)); *buffer = ControlCodes::Colour::black; buffer++; *buffer = ControlCodes::Font::small; buffer++; auto newsStringChar = *newsString; auto i = 0; while (true) { newsStringChar = *newsString; if (newsStringChar == ControlCodes::newline) { newsStringChar = ' '; *buffer = newsStringChar; buffer++; } if (newsStringChar == static_cast<char>(-1)) { *buffer++ = *newsString++; *buffer++ = *newsString++; newsStringChar = *newsString; } *buffer = newsStringChar; buffer++; newsString++; i++; if (!newsStringChar) { break; } } if ((_nState.numCharsToDisplay >> 2) > i) { _nState.numCharsToDisplay = _nState.numCharsToDisplay | (1 << 15); } auto point = Point(55, 0); tr.drawStringTicker(point, StringIds::buffer_2039, Colour::black, 4, ((_nState.numCharsToDisplay & ~(1 << 15)) >> 2), 109); drawingCtx.popRenderTarget(); } static constexpr WindowEventList kEvents = { .onMouseUp = onMouseUp, .onResize = onResize, .onUpdate = onUpdate, .draw = draw, }; const WindowEventList& getEvents() { return kEvents; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ButtonWidget.cpp ```cpp #include "ButtonWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "LabelWidget.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x004CB164 void Button::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { const auto* window = widgetState.window; auto flags = widgetState.flags; if (widgetState.activated) { flags |= Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset(window->position() + widget.position(), widget.size(), widgetState.colour, flags); Label::draw(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ButtonWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Button : public Widget { static constexpr auto kWidgetType = WidgetType::button; constexpr Button(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; contentAlign = ContentAlign::center; } constexpr Button(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Button(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/CaptionWidget.cpp ```cpp #include "CaptionWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Ui/Window.h" #include <cassert> namespace OpenLoco::Ui::Widgets { // 0x004CA6AE static void drawBoxed(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; auto tr = Gfx::TextRenderer(drawingCtx); const auto pos = window->position() + widget.position(); const auto size = widget.size(); drawingCtx.fillRectInset( pos, size, widgetState.colour, widgetState.flags | Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker); drawingCtx.fillRect( pos + Ui::Point(1, 1), size - Ui::Size(2, 2), enumValue(ExtColour::unk2E), Gfx::RectFlags::transparent); int16_t width = size.width - 4 - 10; auto centerPos = pos + Point(2 + (width / 2), 1); auto formatArgs = FormatArguments(widget.textArgs); tr.drawStringCentredClipped( centerPos, width, AdvancedColour(Colour::white).outline(), widget.text, formatArgs); } // 0x004CF3EB static void drawStationNameBackground(Gfx::DrawingContext& drawingCtx, const Ui::Point& origin, AdvancedColour colour, int32_t width) { drawingCtx.drawImage(origin - Ui::Point{ 4, 0 }, Gfx::recolour(ImageIds::curved_border_left_medium, colour.c())); drawingCtx.drawImage(origin + Ui::Point(width, 0), Gfx::recolour(ImageIds::curved_border_right_medium, colour.c())); drawingCtx.fillRect(origin, Ui::Size{ width, 11 } - Ui::Size{ 1, 0 }, Colours::getShade(colour.c(), 5), Gfx::RectFlags::none); } static void drawSimple(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState, const Caption::Style captionStyle) { auto formatArgs = FormatArguments(widget.textArgs); char stringBuffer[512]; if (captionStyle == Caption::Style::blackText) { stringBuffer[0] = ControlCodes::Colour::black; } else if (captionStyle == Caption::Style::colourText) { stringBuffer[0] = ControlCodes::windowColour1; } else if (captionStyle == Caption::Style::whiteText) { stringBuffer[0] = ControlCodes::Colour::white; } else { assert(false); } StringManager::formatString(&stringBuffer[1], widget.text, formatArgs); auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); int16_t width = size.width - 4 - 14; auto stationNamePos = pos + Ui::Point(2 + (width / 2), 1); auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(Gfx::Font::medium_bold); int16_t stringWidth = tr.clipString(width - 8, stringBuffer); stationNamePos.x -= (stringWidth - 1) / 2; if (captionStyle == Caption::Style::blackText) { drawStationNameBackground(drawingCtx, stationNamePos, widgetState.colour, stringWidth); } auto textPos = stationNamePos; tr.drawString(textPos, AdvancedColour(Colour::black).outline(), stringBuffer); } void Caption::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { const auto captionStyle = static_cast<Caption::Style>(widget.styleData); if (captionStyle != Caption::Style::boxed) { drawSimple(drawingCtx, widget, widgetState, captionStyle); } else { drawBoxed(drawingCtx, widget, widgetState); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/CaptionWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Caption : public Widget { static constexpr auto kWidgetType = WidgetType::caption; enum class Style : uint32_t { boxed, // 22 blackText, // 23 colourText, // 24 whiteText, // 25 }; constexpr Caption(WidgetId id, Point32 origin, Size32 size, Style captionStyle, WindowColour colour, StringId content = StringIds::empty, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; styleData = enumValue(captionStyle); } constexpr Caption(Point32 origin, Size32 size, Style captionStyle, WindowColour colour, StringId content = StringIds::empty, StringId tooltip = StringIds::null) : Caption(WidgetId::none, origin, size, captionStyle, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/CheckboxWidget.cpp ```cpp #include "CheckboxWidget.h" #include "Graphics/Colour.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { static constexpr auto kCheckMarkSize = Ui::Size{ 10, 10 }; static constexpr auto kLabelMarginLeft = 4; // 0x004CB00B static void drawCheckBox(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); drawingCtx.fillRectInset( pos, kCheckMarkSize, widgetState.colour, widgetState.flags | Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker); if (widgetState.activated) { auto tr = Gfx::TextRenderer(drawingCtx); static constexpr char strCheckmark[] = "\xAC"; auto colour = widgetState.colour; if (widgetState.disabled) { colour = colour.inset(); } tr.setCurrentFont(widget.font); tr.drawString(pos, colour.opaque(), strCheckmark); } } // 0x004CB080 static void drawLabel(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { if (widget.content == Widget::kContentNull) { return; } auto colour = widgetState.colour; colour = colour.opaque(); if (widgetState.disabled) { colour = colour.inset(); } auto formatArgs = FormatArguments(widget.textArgs); auto* window = widgetState.window; auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(widget.font); const auto pos = window->position() + widget.position(); tr.drawStringLeft(pos + Point{ kCheckMarkSize.width + kLabelMarginLeft, 0 }, colour, widget.text, formatArgs); } void Checkbox::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { drawCheckBox(drawingCtx, widget, widgetState); drawLabel(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/CheckboxWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Checkbox : public Widget { static constexpr auto kWidgetType = WidgetType::checkbox; constexpr Checkbox(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Checkbox(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Checkbox(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ColourButtonWidget.cpp ```cpp #include "ColourButtonWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x004CB164 void ColourButton::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { if (widget.content == Widget::kContentNull) { return; } const bool isColourSet = widget.image & Widget::kImageIdColourSet; // TODO: Remove addition ImageId imageId = ImageId::fromUInt32(widget.image & ~Widget::kImageIdColourSet); if (!widgetState.disabled && widgetState.activated && widgetState.hovered) { // TODO: Remove addition imageId = imageId.withIndexOffset(2); } else if (!widgetState.disabled && !widgetState.activated && widgetState.hovered) { // TODO: Remove addition imageId = imageId.withIndexOffset(1); } if (!isColourSet && imageId.hasPrimary()) { imageId = imageId.withPrimary(widgetState.colour.c()); } auto* window = widgetState.window; const auto pos = window->position() + widget.position(); drawingCtx.drawImage(pos, imageId); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ColourButtonWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct ColourButton : public Widget { static constexpr auto kWidgetType = WidgetType::buttonWithColour; constexpr ColourButton(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; contentAlign = ContentAlign::center; } constexpr ColourButton(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : ColourButton(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/DropdownWidget.cpp ```cpp #include "DropdownWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "LabelWidget.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x4CB2D6 static void drawText(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetStated) { if (widget.content == Widget::kContentNull || widget.content == Widget::kContentUnk) { return; } auto colour = widgetStated.colour; if (widgetStated.disabled) { colour = colour.inset(); } else { colour = colour.FD(); } auto* window = widgetStated.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); auto tr = Gfx::TextRenderer(drawingCtx); auto formatArgs = FormatArgumentsView(widget.textArgs); tr.drawStringLeftClipped(pos + Ui::Point{ 1, 1 }, size.width - 2, colour, widget.text, formatArgs); } // 0x004CB164 void ComboBox::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { const auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); const auto flags = widgetState.flags | Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker; drawingCtx.fillRectInset( pos, size, widgetState.colour, flags); drawText(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/DropdownWidget.h ```h #pragma once #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" namespace OpenLoco::Ui::Widgets { struct ComboBox : public Widget { static constexpr auto kWidgetType = WidgetType::combobox; constexpr ComboBox(WidgetId id, Point32 origin, Size32 size, WindowColour colour, StringId content = StringIds::null, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr ComboBox(Point32 origin, Size32 size, WindowColour colour, StringId content = StringIds::null, StringId tooltip = StringIds::null) : ComboBox(WidgetId::none, origin, size, colour, content, tooltip) { events.draw = &draw; } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; constexpr auto dropdownWidgets(Ui::Point32 origin, Ui::Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) { const auto makeDropdownButtonWidget = [](Ui::Point32 origin, Ui::Size32 size, WindowColour colour) { const int16_t xPos = origin.x + size.width - 12; const int16_t yPos = origin.y + 1; const uint16_t width = 11; const uint16_t height = 10; return Button({ xPos, yPos }, { width, height }, colour, StringIds::dropdown); }; // TODO: Make this a single widget. return makeWidgets( ComboBox(origin, size, colour, content, tooltip), makeDropdownButtonWidget(origin, size, colour)); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/FrameWidget.cpp ```cpp #include "FrameWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x004CAB8E static void drawResizeHandle(Gfx::DrawingContext& drawingCtx, const Window* window, const Widget& widget, AdvancedColour colour) { if (!window->hasFlags(WindowFlags::resizable)) { return; } if (window->minHeight == window->maxHeight || window->minWidth == window->maxWidth) { return; } const auto pos = window->position() + widget.position(); const auto size = widget.size(); const auto resizeBarPos = pos + Ui::Point(size.width - 18, size.height - 18); uint32_t image = Gfx::recolour(ImageIds::window_resize_handle, colour.c()); drawingCtx.drawImage(resizeBarPos, image); } // 0x004CAAB9 void Frame::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); const auto& rt = drawingCtx.currentRenderTarget(); const auto clipped = Gfx::clipRenderTarget(rt, Ui::Rect(pos.x, pos.y, size.width, 41)); if (clipped) { uint32_t imageId = widget.image; if (window->hasFlags(WindowFlags::flag_11)) { imageId = Gfx::recolour(ImageIds::frame_background_image, widgetState.colour.c()); } else { imageId = Gfx::recolour(ImageIds::frame_background_image_alt, widgetState.colour.c()); } drawingCtx.pushRenderTarget(*clipped); drawingCtx.drawImage(0, 0, imageId); drawingCtx.popRenderTarget(); } uint8_t shade; if (window->hasFlags(WindowFlags::flag_11)) { shade = Colours::getShade(widgetState.colour.c(), 3); } else { shade = Colours::getShade(widgetState.colour.c(), 1); } // Shadow at the right side. drawingCtx.fillRect( pos + Point{ size.width - 1, 0 }, Ui::Size{ 1, 40u }, shade, Gfx::RectFlags::none); drawResizeHandle(drawingCtx, window, widget, widgetState.colour); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/FrameWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Frame : public Widget { static constexpr auto kWidgetType = WidgetType::frame; constexpr Frame(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Frame(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Frame(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/GroupBoxWidget.cpp ```cpp #include "GroupBoxWidget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { void GroupBox::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto position = window->position() + widget.position(); const auto size = widget.size(); auto colour = widgetState.colour.opaque(); int16_t textEndPos = position.x + 5; // Draw label text if present if (widget.text != StringIds::null) { auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(widget.font); char buffer[512] = { 0 }; StringManager::formatString(buffer, sizeof(buffer), widget.text); auto point = Point(position.x + 5, position.y); tr.drawString(point, colour, buffer); textEndPos = position.x + 5 + tr.getStringWidth(buffer) + 1; } // Prepare border position and size const auto borderPos = position + Ui::Point{ 0, 4 }; const auto borderSize = Ui::Size{ size.width + 0, size.height - 4 }; // Border left of text drawingCtx.fillRect(borderPos, { 5, 1 }, Colours::getShade(colour.c(), 4), Gfx::RectFlags::none); drawingCtx.fillRect(borderPos + Ui::Point{ 1, 1 }, { 4, 1 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); // Border right of text drawingCtx.fillRect(Ui::Point{ textEndPos, borderPos.y }, { borderSize.width - (textEndPos - borderPos.x) - 1, 1 }, Colours::getShade(colour.c(), 4), Gfx::RectFlags::none); drawingCtx.fillRect(Ui::Point{ textEndPos, borderPos.y } + Ui::Point(0, 1), { borderSize.width - (textEndPos - borderPos.x) - 2, 1 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); // Border right drawingCtx.fillRect(Ui::Point{ borderPos.x + borderSize.width - 1, borderPos.y + 1 }, { 1, borderSize.height - 1 }, Colours::getShade(colour.c(), 4), Gfx::RectFlags::none); drawingCtx.fillRect(Ui::Point{ borderPos.x + borderSize.width, borderPos.y }, { 1, borderSize.height + 1 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); // Border bottom drawingCtx.fillRect(Ui::Point{ borderPos.x, borderPos.y + borderSize.height - 1 }, { borderSize.width - 1, 1 }, Colours::getShade(colour.c(), 4), Gfx::RectFlags::none); drawingCtx.fillRect(Ui::Point{ borderPos.x, borderPos.y + borderSize.height }, { borderSize.width + 0, 1 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); // Border left drawingCtx.fillRect(Ui::Point{ borderPos.x, borderPos.y + 1 }, { 1, borderSize.height - 2 }, Colours::getShade(colour.c(), 4), Gfx::RectFlags::none); drawingCtx.fillRect(Ui::Point{ borderPos.x + 1, borderPos.y + 2 }, { 1, borderSize.height - 3 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/GroupBoxWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct GroupBox : public Widget { static constexpr auto kWidgetType = WidgetType::groupbox; constexpr GroupBox(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr GroupBox(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : GroupBox(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ImageButtonWidget.cpp ```cpp #include "ImageButtonWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "LabelWidget.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x004CADE8 static void drawImage(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const bool isColourSet = widget.image & Widget::kImageIdColourSet; ImageId imageId = ImageId::fromUInt32(widget.image & ~Widget::kImageIdColourSet); auto colour = widgetState.colour; if (widgetState.disabled) { // TODO: this is odd most likely this is another flag like Widget::kImageIdColourSet if (imageId.hasSecondary()) { return; } // No colour applied image const auto pureImage = ImageId{ imageId.getIndex() }; uint8_t c; if (colour.isTranslucent()) { c = Colours::getShade(colour.c(), 4); drawingCtx.drawImageSolid(pos + Ui::Point{ 1, 1 }, pureImage, c); c = Colours::getShade(colour.c(), 2); drawingCtx.drawImageSolid(pos, pureImage, c); } else { c = Colours::getShade(colour.c(), 6); drawingCtx.drawImageSolid(pos + Ui::Point{ 1, 1 }, pureImage, c); c = Colours::getShade(colour.c(), 4); drawingCtx.drawImageSolid(pos, pureImage, c); } return; } if (!isColourSet && imageId.hasSecondary()) { imageId = imageId.withSecondary(colour.c()); } if (!isColourSet && imageId.hasPrimary()) { imageId = imageId.withPrimary(colour.c()); } if (!isColourSet) { imageId = ImageId::fromUInt32(Gfx::recolour(imageId.getIndex(), colour.c())); } drawingCtx.drawImage(pos, imageId); } static void draw_3(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); auto flags = widgetState.flags; if (widgetState.activated) { flags |= Gfx::RectInsetFlags::borderInset; } if (widget.content == Widget::kContentUnk) { flags |= Gfx::RectInsetFlags::fillNone; drawingCtx.fillRectInset(pos, size, widgetState.colour, flags); return; } if (window->hasFlags(WindowFlags::flag_6)) { drawingCtx.fillRect(pos, size, enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); } // TODO: Add a setting to decide if it should be translucent or not, for now it seems all ImageButton's require this. drawingCtx.fillRectInset(pos, size, widgetState.colour.translucent(), flags); if (widget.content == Widget::kContentNull) { return; } drawImage(drawingCtx, widget, widgetState); } // 0x004CB164 void ImageButton::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { if (!widgetState.disabled && widgetState.hovered) { // TODO: Fix mixed windows draw_3(drawingCtx, widget, widgetState); return; } auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); if (widgetState.activated) { auto flags = widgetState.flags; flags |= Gfx::RectInsetFlags::borderInset; if (widget.content == Widget::kContentUnk) { // 0x004CABE8 flags |= Gfx::RectInsetFlags::fillNone; drawingCtx.fillRectInset(pos, size, widgetState.colour, flags); return; } drawingCtx.fillRectInset(pos, size, widgetState.colour, flags); } if (widget.content == Widget::kContentNull) { return; } drawImage(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ImageButtonWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct ImageButton : public Widget { static constexpr auto kWidgetType = WidgetType::buttonWithImage; constexpr ImageButton(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; contentAlign = ContentAlign::center; } constexpr ImageButton(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : ImageButton(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/LabelWidget.cpp ```cpp #include "LabelWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Ui/Window.h" #include <cassert> namespace OpenLoco::Ui::Widgets { // 0x004CB21D void Label::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { if (widget.text == StringIds::null || widget.text == StringIds::empty) { return; } auto colour = widgetState.colour.opaque(); if (widgetState.disabled) { colour = colour.inset(); } auto* window = widgetState.window; const auto position = window->position() + widget.position(); const auto size = widget.size(); auto formatArgs = FormatArguments(widget.textArgs); auto tr = Gfx::TextRenderer(drawingCtx); tr.setCurrentFont(widget.font); const auto x = [&]() -> int16_t { if (widget.contentAlign == ContentAlign::left) { return position.x; } else if (widget.contentAlign == ContentAlign::center) { return position.x + (size.width - 1) / 2; } else if (widget.contentAlign == ContentAlign::right) { char buffer[512]{}; StringManager::formatString(buffer, std::size(buffer), widget.text, formatArgs); const auto stringWidth = tr.getStringWidthNewLined(buffer); return position.x + size.width - stringWidth - 1; } assert(false); return {}; }(); const auto fontHeight = tr.getLineHeight(tr.getCurrentFont()); // NOTE: -1 is an ugly hack for buttons with inset border, remove that when all buttons have consistent height. const int16_t yOffset = std::max<int16_t>(0, (size.height - fontHeight) / 2 - 1); const int16_t y = position.y + yOffset; const int16_t width = size.width - 2; if (widget.contentAlign == ContentAlign::left) { tr.drawStringLeftClipped(Point(x, y), width, colour, widget.text, formatArgs); } else if (widget.contentAlign == ContentAlign::center) { tr.drawStringCentredClipped(Point(x, y), width, colour, widget.text, formatArgs); } else if (widget.contentAlign == ContentAlign::right) { tr.drawStringLeftClipped(Point(x, y), width, colour, widget.text, formatArgs); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/LabelWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Label : public Widget { static constexpr auto kWidgetType = WidgetType::label; constexpr Label(WidgetId id, Point32 origin, Size32 size, WindowColour colour, ContentAlign align, StringId content = StringIds::empty, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; contentAlign = align; } constexpr Label(Point32 origin, Size32 size, WindowColour colour, ContentAlign align, StringId content = StringIds::empty, StringId tooltip = StringIds::null) : Label(WidgetId::none, origin, size, colour, align, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/NewsPanelWidget.cpp ```cpp #include "NewsPanelWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" #include <cassert> namespace OpenLoco::Ui::Widgets { void NewsPanel::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto centerPos = pos + Point(widget.width() / 2, 0); const auto style = static_cast<Style>(widget.styleData); if (style == Style::old) { auto imageId = Gfx::recolour(ImageIds::news_background_old_left, ExtColour::translucentBrown1); drawingCtx.drawImage(pos, imageId); imageId = Gfx::recolour(ImageIds::news_background_old_right, ExtColour::translucentBrown1); drawingCtx.drawImage(centerPos, imageId); } else if (style == Style::new_) { drawingCtx.drawImage(pos, ImageIds::news_background_new_left); drawingCtx.drawImage(centerPos, ImageIds::news_background_new_right); } else { assert(false); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/NewsPanelWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct NewsPanel : public Widget { static constexpr auto kWidgetType = WidgetType::newsPanel; enum class Style : uint32_t { old, new_, }; constexpr NewsPanel(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null, Style newsStyle = Style::old) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; styleData = enumValue(newsStyle); } constexpr NewsPanel(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null, Style newsStyle = Style::old) : NewsPanel(WidgetId::none, origin, size, colour, content, tooltip, newsStyle) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/PanelWidget.cpp ```cpp #include "PanelWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x004CAB8E static void drawResizeHandle(Gfx::DrawingContext& drawingCtx, const Window* window, const Widget& widget, AdvancedColour colour) { if (!window->hasFlags(WindowFlags::resizable)) { return; } if (window->minHeight == window->maxHeight || window->minWidth == window->maxWidth) { return; } const auto pos = window->position() + widget.position(); const auto size = widget.size(); const auto resizeBarPos = pos + Ui::Point(size.width - 18, size.height - 18); uint32_t image = Gfx::recolour(ImageIds::window_resize_handle, colour.c()); drawingCtx.drawImage(resizeBarPos, image); } // 0x004CAB58 void Panel::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); drawingCtx.fillRectInset( pos, size, widgetState.colour, widgetState.flags); drawResizeHandle(drawingCtx, window, widget, widgetState.colour); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/PanelWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Panel : public Widget { static constexpr auto kWidgetType = WidgetType::panel; constexpr Panel(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Panel(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Panel(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ScrollViewWidget.cpp ```cpp #include "ScrollViewWidget.h" #include "Graphics/Colour.h" #include "Graphics/ImageIds.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/ScrollView.h" #include "Ui/Window.h" using namespace OpenLoco::Ui::ScrollView; namespace OpenLoco::Ui::Widgets { static constexpr auto kArrowOffset = 2; static void drawHScroll(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState, const ScrollArea& scrollArea) { auto* window = widgetState.window; const auto position = window->position() + widget.position(); const auto size = widget.size(); const auto colour = widgetState.colour; // Calculate adjusted dimensions auto scrollPos = position + Point{ kScrollbarMargin, size.height - kScrollbarSize - kScrollbarMargin }; auto scrollSize = Ui::Size{ size.width - (kScrollbarMargin * 2), kScrollbarSize }; if (scrollArea.hasFlags(Ui::ScrollFlags::vscrollbarVisible)) { scrollSize.width -= kScrollbarSize + kScrollbarMargin; } Gfx::RectInsetFlags f; auto tr = Gfx::TextRenderer(drawingCtx); // Scroll track drawingCtx.fillRect(scrollPos, scrollSize, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos, scrollSize, Colours::getShade(colour.c(), 3), Gfx::RectFlags::crossHatching); // Track lines drawingCtx.fillRect(scrollPos + Point{ 0, 2 }, { +scrollSize.width, 1 }, Colours::getShade(colour.c(), 3), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos + Point{ 0, 3 }, { +scrollSize.width, 1 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos + Point{ 0, 7 }, { +scrollSize.width, 1 }, Colours::getShade(colour.c(), 3), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos + Point{ 0, 8 }, { +scrollSize.width, 1 }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); // Left button f = Gfx::RectInsetFlags::none; if (scrollArea.hasFlags(Ui::ScrollFlags::hscrollbarLeftPressed)) { f = widgetState.flags | Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset(scrollPos, kScrollButtonSize, widgetState.colour, f); // Left arrow { const char* hLeftStr = "\x90\xBE"; tr.drawString(scrollPos + Point{ kArrowOffset, 0 }, Colour::black, hLeftStr); } // Right button f = Gfx::RectInsetFlags::none; if (scrollArea.hasFlags(Ui::ScrollFlags::hscrollbarRightPressed)) { f = widgetState.flags | Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset( scrollPos + Point{ scrollSize.width - kScrollButtonSize.width + kScrollbarMargin, 0 }, kScrollButtonSize, widgetState.colour, f); // Right arrow { const char* hRightStr = "\x90\xAF"; tr.drawString( scrollPos + Point{ scrollSize.width - kScrollButtonSize.width + kScrollbarMargin + kArrowOffset, 0 }, Colour::black, hRightStr); } // Thumb f = Gfx::RectInsetFlags::none; if (scrollArea.hasFlags(Ui::ScrollFlags::hscrollbarThumbPressed)) { f = Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset( scrollPos + Point{ scrollArea.hThumbLeft, 0 }, { scrollArea.hThumbRight - scrollArea.hThumbLeft - kScrollbarMargin, +scrollSize.height }, colour, f); } static void drawVScroll(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState, const ScrollArea& scrollArea) { auto* window = widgetState.window; const auto position = window->position() + widget.position(); const auto size = widget.size(); const auto colour = widgetState.colour; // Calculate adjusted dimensions auto scrollPos = position + Point{ size.width - kScrollbarSize - kScrollbarMargin, kScrollbarMargin }; auto scrollSize = Ui::Size{ kScrollbarSize, size.height - (kScrollbarMargin * 2) }; if (scrollArea.hasFlags(ScrollFlags::hscrollbarVisible)) { scrollSize.height -= kScrollbarSize; } Gfx::RectInsetFlags f = Gfx::RectInsetFlags::none; auto tr = Gfx::TextRenderer(drawingCtx); // Scroll track drawingCtx.fillRect(scrollPos, scrollSize, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos, scrollSize, Colours::getShade(colour.c(), 3), Gfx::RectFlags::crossHatching); // Track lines drawingCtx.fillRect(scrollPos + Point{ 2, 0 }, { 1, +scrollSize.height }, Colours::getShade(colour.c(), 3), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos + Point{ 3, 0 }, { 1, +scrollSize.height }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos + Point{ 7, 0 }, { 1, +scrollSize.height }, Colours::getShade(colour.c(), 3), Gfx::RectFlags::none); drawingCtx.fillRect(scrollPos + Point{ 8, 0 }, { 1, +scrollSize.height }, Colours::getShade(colour.c(), 7), Gfx::RectFlags::none); // Up button if (scrollArea.hasFlags(ScrollFlags::vscrollbarUpPressed)) { f = widgetState.flags | Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset(scrollPos, kScrollButtonSize, widgetState.colour, f); // Up arrow { const char* vTopStr = "\x90\xA0"; tr.drawString(scrollPos + Point{ 1, -1 }, Colour::black, vTopStr); } // Down button f = Gfx::RectInsetFlags::none; if (scrollArea.hasFlags(ScrollFlags::vscrollbarDownPressed)) { f = widgetState.flags | Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset( scrollPos + Point{ 0, scrollSize.height - kScrollButtonSize.height }, kScrollButtonSize, widgetState.colour, f); // Down arrow { const char* vBottomStr = "\x90\xAA"; tr.drawString( scrollPos + Point{ kScrollbarMargin, scrollSize.height - kScrollButtonSize.height }, Colour::black, vBottomStr); } // Thumb f = Gfx::RectInsetFlags::none; if (scrollArea.hasFlags(ScrollFlags::vscrollbarThumbPressed)) { f = widgetState.flags | Gfx::RectInsetFlags::borderInset; } drawingCtx.fillRectInset( scrollPos + Point{ 0, scrollArea.vThumbTop }, { +scrollSize.width, scrollArea.vThumbBottom - scrollArea.vThumbTop - kScrollbarMargin }, colour, f); } // 0x004CAB58 void ScrollView::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto position = window->position() + widget.position(); const auto size = widget.size(); auto tr = Gfx::TextRenderer(drawingCtx); // Draw background with inset drawingCtx.fillRectInset(position, size, widgetState.colour, widgetState.flags | Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker); // Adjusted content area (1px inset) auto contentPos = position + Point{ kScrollbarMargin, kScrollbarMargin }; auto contentSize = Ui::Size{ size.width - (kScrollbarMargin * 2), size.height - (kScrollbarMargin * 2) }; const auto& scrollArea = window->scrollAreas[widgetState.scrollviewIndex]; tr.setCurrentFont(Gfx::Font::medium_bold); if (scrollArea.contentWidth > size.width && scrollArea.hasFlags(Ui::ScrollFlags::hscrollbarVisible)) { drawHScroll(drawingCtx, widget, widgetState, scrollArea); contentSize.height -= kScrollbarSize; } if (scrollArea.contentHeight > size.height && scrollArea.hasFlags(Ui::ScrollFlags::vscrollbarVisible)) { drawVScroll(drawingCtx, widget, widgetState, scrollArea); contentSize.width -= kScrollbarSize; } Gfx::RenderTarget cropped = drawingCtx.currentRenderTarget(); // Restore original dimensions for cropping calculations auto cropSize = Ui::Size{ contentSize.width, contentSize.height }; if (contentPos.x > cropped.x) { int offset = contentPos.x - cropped.x; cropped.width -= offset; cropped.x = contentPos.x; cropped.pitch += offset; cropped.bits += offset; } int16_t bp = cropped.x + cropped.width - (contentPos.x + cropSize.width); if (bp > 0) { cropped.width -= bp; cropped.pitch += bp; } if (contentPos.y > cropped.y) { int offset = contentPos.y - cropped.y; cropped.height -= offset; cropped.y = contentPos.y; int aex = (cropped.pitch + cropped.width) * offset; cropped.bits += aex; } bp = cropped.y + cropped.height - (contentPos.y + cropSize.height); if (bp > 0) { cropped.height -= bp; } if (cropped.width > 0 && cropped.height > 0) { cropped.x -= contentPos.x - scrollArea.contentOffsetX; cropped.y -= contentPos.y - scrollArea.contentOffsetY; drawingCtx.pushRenderTarget(cropped); window->callDrawScroll(drawingCtx, widgetState.scrollviewIndex); drawingCtx.popRenderTarget(); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ScrollViewWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct ScrollView : public Widget { static constexpr auto kWidgetType = WidgetType::scrollview; constexpr ScrollView(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr ScrollView(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : ScrollView(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/SliderWidget.cpp ```cpp #include "SliderWidget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "TabWidget.h" namespace OpenLoco::Ui::Widgets { void Slider::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { Tab::draw(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/SliderWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Slider : public Widget { static constexpr auto kWidgetType = WidgetType::slider; constexpr Slider(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Slider(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Slider(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/StepperWidget.cpp ```cpp #include "StepperWidget.h" ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/StepperWidget.h ```h #pragma once #include "Ui/Widget.h" #include "Ui/Widgets/ButtonWidget.h" #include "Ui/Widgets/TextBoxWidget.h" namespace OpenLoco::Ui::Widgets { constexpr Button makeStepperDecreaseWidget(Ui::Point32 origin, Ui::Size32 size, WindowColour colour, [[maybe_unused]] uint32_t content = Widget::kContentNull, [[maybe_unused]] StringId tooltip = StringIds::null) { const int16_t xPos = origin.x + size.width - 26; const int16_t yPos = origin.y + 1; const uint16_t width = 13; const uint16_t height = size.height - 2; return Button({ xPos, yPos }, { width, height }, colour, StringIds::stepper_minus, tooltip); } constexpr Button makeStepperIncreaseWidget(Ui::Point32 origin, Ui::Size32 size, WindowColour colour, [[maybe_unused]] uint32_t content = Widget::kContentNull, [[maybe_unused]] StringId tooltip = StringIds::null) { const int16_t xPos = origin.x + size.width - 13; const int16_t yPos = origin.y + 1; const uint16_t width = 12; const uint16_t height = size.height - 2; return Button({ xPos, yPos }, { width, height }, colour, StringIds::stepper_plus, tooltip); } // TODO: Make this a single widget. constexpr auto stepperWidgets(Ui::Point32 origin, Ui::Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) { return makeWidgets( TextBox(origin, size, colour, content, tooltip), makeStepperDecreaseWidget(origin, size, colour), makeStepperIncreaseWidget(origin, size, colour)); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/TabWidget.cpp ```cpp #include "TabWidget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x004CADE8 static void drawTabBackground(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); ImageId imageId = ImageId{ ImageIds::tab }; // TODO: Separate content image and background image. // This is only done to keep everything as is for the time being. if (widget.image == ImageIds::wide_tab) { imageId = ImageId{ ImageIds::wide_tab }; } if (widgetState.activated) { // TODO: remove image addition imageId = imageId.withIndexOffset(1); } auto colour = widgetState.colour; if (widgetState.disabled) { uint8_t c; if (colour.isTranslucent()) { c = Colours::getShade(colour.c(), 4); drawingCtx.drawImageSolid(pos + Ui::Point{ 1, 1 }, imageId, c); c = Colours::getShade(colour.c(), 2); drawingCtx.drawImageSolid(pos, imageId, c); } else { c = Colours::getShade(colour.c(), 6); drawingCtx.drawImageSolid(pos + Ui::Point{ 1, 1 }, imageId, c); c = Colours::getShade(colour.c(), 4); drawingCtx.drawImageSolid(pos, imageId, c); } return; } imageId = imageId.withPrimary(colour.c()); drawingCtx.drawImage(pos, imageId); } static void drawTabContent(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); if (widgetState.disabled) { return; // 0x8000 } bool isActivated = widgetState.activated; if (widget.image == Widget::kContentNull) { return; } if (isActivated) { if (widget.image != Widget::kContentNull) { drawingCtx.drawImage(pos.x, pos.y, widget.image); } } else { if (widget.image != Widget::kContentUnk) { drawingCtx.drawImage(pos.x, pos.y + 1, widget.image); } drawingCtx.drawImage(pos.x, pos.y, Gfx::recolourTranslucent(ImageIds::tab, ExtColour::unk33)); drawingCtx.drawRect(pos.x, pos.y + 26, 31, 1, Colours::getShade(window->getColour(WindowColour::secondary).c(), 7), Gfx::RectFlags::none); } } void Tab::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { if (widget.content == Widget::kContentNull) { return; } drawTabBackground(drawingCtx, widget, widgetState); // Ugly hack to detect if the drawTab code is used or not. // We always draw the background as ImageIds::tab so only draw the content if the image is not the tab image. if (widget.image != ImageIds::tab && widget.image != ImageIds::wide_tab) { drawTabContent(drawingCtx, widget, widgetState); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/TabWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Tab : public Widget { static constexpr auto kWidgetType = WidgetType::tab; constexpr Tab(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Tab(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Tab(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/TableHeaderWidget.cpp ```cpp #include "TableHeaderWidget.h" #include "ButtonWidget.h" namespace OpenLoco::Ui::Widgets { void TableHeader::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { Button::draw(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/TableHeaderWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct TableHeader : public Widget { static constexpr auto kWidgetType = WidgetType::buttonTableHeader; constexpr TableHeader(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr TableHeader(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : TableHeader(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/TextBoxWidget.cpp ```cpp #include "TextBoxWidget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { // 0x4CB2D6 static void drawText(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetStated) { if (widget.content == Widget::kContentNull || widget.content == Widget::kContentUnk) { return; } auto colour = widgetStated.colour; if (widgetStated.disabled) { colour = colour.inset(); } else { colour = colour.FD(); } auto* window = widgetStated.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); auto tr = Gfx::TextRenderer(drawingCtx); auto formatArgs = FormatArgumentsView(widget.textArgs); tr.drawStringLeftClipped(pos + Point{ 1, 1 }, size.width - 2, colour, widget.text, formatArgs); } // 0x4CB29C void TextBox::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto pos = window->position() + widget.position(); const auto size = widget.size(); const auto flags = widgetState.flags | Gfx::RectInsetFlags::borderInset | Gfx::RectInsetFlags::fillDarker; drawingCtx.fillRectInset( pos, size, widgetState.colour, flags); drawText(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/TextBoxWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct TextBox : public Widget { static constexpr auto kWidgetType = WidgetType::textbox; constexpr TextBox(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr TextBox(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : TextBox(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ViewportWidget.cpp ```cpp #include "ViewportWidget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "TextBoxWidget.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { static void drawText(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetStated) { if (widget.content == Widget::kContentNull || widget.content == Widget::kContentUnk) { return; } auto colour = widgetStated.colour; if (widgetStated.disabled) { colour = colour.inset(); } else { colour = colour.FD(); } auto formatArgs = FormatArguments(widget.textArgs); auto* window = widgetStated.window; auto point = Point(window->x + widget.left + 1, window->y + widget.top); int width = widget.right - widget.left - 2; auto tr = Gfx::TextRenderer(drawingCtx); tr.drawStringLeftClipped(point, width, colour, widget.text, formatArgs); } static void drawViewports(Gfx::DrawingContext& drawingCtx, [[maybe_unused]] const Widget& widget, const WidgetState& widgetState) { // TODO: Move the viewport into the widget. auto* window = widgetState.window; // TODO: Move viewports into the Widget auto& viewports = window->viewports; if (viewports[0] != nullptr) { viewports[0]->render(drawingCtx); } if (viewports[1] != nullptr) { viewports[1]->render(drawingCtx); } } void Viewport::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { // TODO: Not an actual TextBox, this is just inset border and background. // Add border style to the Widget. TextBox::draw(drawingCtx, widget, widgetState); drawText(drawingCtx, widget, widgetState); drawViewports(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/ViewportWidget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { struct Viewport : public Widget { static constexpr auto kWidgetType = WidgetType::viewport; constexpr Viewport(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Viewport(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Viewport(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/Wt3Widget.cpp ```cpp #include "Wt3Widget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Ui/Window.h" namespace OpenLoco::Ui::Widgets { static void sub_4CADE8(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto position = window->position() + widget.position(); const bool isColourSet = widget.image & Widget::kImageIdColourSet; ImageId imageId = ImageId::fromUInt32(widget.image & ~Widget::kImageIdColourSet); auto colour = widgetState.colour; if (widgetState.disabled) { // TODO: this is odd most likely this is another flag like Widget::kImageIdColourSet if (imageId.hasSecondary()) { return; } // No colour applied image const auto pureImage = ImageId{ imageId.getIndex() }; uint8_t c; if (colour.isTranslucent()) { c = Colours::getShade(colour.c(), 4); drawingCtx.drawImageSolid(position + Ui::Point{ 1, 1 }, pureImage, c); c = Colours::getShade(colour.c(), 2); drawingCtx.drawImageSolid(position, pureImage, c); } else { c = Colours::getShade(colour.c(), 6); drawingCtx.drawImageSolid(position + Ui::Point{ 1, 1 }, pureImage, c); c = Colours::getShade(colour.c(), 4); drawingCtx.drawImageSolid(position, pureImage, c); } return; } if (!isColourSet && imageId.hasSecondary()) { imageId = imageId.withSecondary(colour.c()); } if (!isColourSet && imageId.hasPrimary()) { imageId = imageId.withPrimary(colour.c()); } drawingCtx.drawImage(position, imageId); } void Wt3Widget::draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState) { auto* window = widgetState.window; const auto position = window->position() + widget.position(); const auto size = widget.size(); int16_t t, l, b, r; t = window->y + widget.top; l = window->x + widget.left; r = window->x + widget.right; b = window->y + widget.bottom; auto flags = widgetState.flags; if (widgetState.activated) { flags |= Gfx::RectInsetFlags::borderInset; } if (widget.content == Widget::kContentUnk) { flags |= Gfx::RectInsetFlags::fillNone; drawingCtx.fillRectInset(position, size, widgetState.colour, flags); return; } if (window->hasFlags(WindowFlags::flag_6)) { drawingCtx.fillRect(position, size, enumValue(ExtColour::unk34), Gfx::RectFlags::transparent); } drawingCtx.fillRectInset(l, t, r, b, widgetState.colour, flags); if (widget.content == Widget::kContentNull) { return; } sub_4CADE8(drawingCtx, widget, widgetState); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Ui/Widgets/Wt3Widget.h ```h #pragma once #include "Ui/Widget.h" namespace OpenLoco::Ui::Widgets { // TODO: This is just another Frame widget, merge this with FrameWidget. struct Wt3Widget : public Widget { static constexpr auto kWidgetType = WidgetType::wt_3; constexpr Wt3Widget(WidgetId id, Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Widget(id, origin, size, kWidgetType, colour, content, tooltip) { events.draw = &draw; } constexpr Wt3Widget(Point32 origin, Size32 size, WindowColour colour, uint32_t content = Widget::kContentNull, StringId tooltip = StringIds::null) : Wt3Widget(WidgetId::none, origin, size, colour, content, tooltip) { } static void draw(Gfx::DrawingContext& drawingCtx, const Widget& widget, const WidgetState& widgetState); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/Colour.cpp ```cpp #include "Colour.h" #include "Gfx.h" #include "PaletteMap.h" #include <OpenLoco/Interop/Interop.hpp> #include <array> #include <cassert> using namespace OpenLoco::Interop; namespace OpenLoco::Colours { static std::array<std::array<uint8_t, 8>, 31> _colourMapA; static std::array<std::array<uint8_t, 8>, 31> _colourMapB; // 0x005045FA static constexpr std::array<std::array<ExtColour, 3>, 31> _translucentColourMap = { std::array<ExtColour, 3>{ ExtColour::translucentGrey0, ExtColour::translucentGrey1, ExtColour::translucentGrey2, }, std::array<ExtColour, 3>{ ExtColour::translucentGrey0, ExtColour::translucentGrey1, ExtColour::translucentGrey2, }, std::array<ExtColour, 3>{ ExtColour::translucentWhite0, ExtColour::translucentWhite1, ExtColour::translucentWhite2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedPurple0, ExtColour::translucentMutedPurple1, ExtColour::translucentMutedPurple2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedPurple0, ExtColour::translucentMutedPurple1, ExtColour::translucentMutedPurple2, }, std::array<ExtColour, 3>{ ExtColour::translucentPurple0, ExtColour::translucentPurple1, ExtColour::translucentPurple2, }, std::array<ExtColour, 3>{ ExtColour::translucentBlue0, ExtColour::translucentBlue1, ExtColour::translucentBlue2, }, std::array<ExtColour, 3>{ ExtColour::translucentBlue0, ExtColour::translucentBlue1, ExtColour::translucentBlue2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedTeal0, ExtColour::translucentMutedTeal1, ExtColour::translucentMutedTeal2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedTeal0, ExtColour::translucentMutedTeal1, ExtColour::translucentMutedTeal2, }, std::array<ExtColour, 3>{ ExtColour::translucentGreen0, ExtColour::translucentGreen1, ExtColour::translucentGreen2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedSeaGreen0, ExtColour::translucentMutedSeaGreen1, ExtColour::translucentMutedSeaGreen2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedGrassGreen0, ExtColour::translucentMutedGrassGreen1, ExtColour::translucentMutedGrassGreen2, }, std::array<ExtColour, 3>{ ExtColour::translucentGreen0, ExtColour::translucentGreen1, ExtColour::translucentGreen2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedAvocadoGreen0, ExtColour::translucentMutedAvocadoGreen1, ExtColour::translucentMutedAvocadoGreen2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedOliveGreen0, ExtColour::translucentMutedOliveGreen1, ExtColour::translucentMutedOliveGreen2, }, std::array<ExtColour, 3>{ ExtColour::translucentYellow0, ExtColour::translucentYellow1, ExtColour::translucentYellow2, }, std::array<ExtColour, 3>{ ExtColour::translucentYellow0, ExtColour::translucentYellow1, ExtColour::translucentYellow2, }, std::array<ExtColour, 3>{ ExtColour::translucentOrange0, ExtColour::translucentOrange1, ExtColour::translucentOrange2, }, std::array<ExtColour, 3>{ ExtColour::translucentAmber0, ExtColour::translucentAmber1, ExtColour::translucentAmber2, }, std::array<ExtColour, 3>{ ExtColour::translucentOrange0, ExtColour::translucentOrange1, ExtColour::translucentOrange2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedYellow0, ExtColour::translucentMutedYellow1, ExtColour::translucentMutedYellow2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedYellow0, ExtColour::translucentMutedYellow1, ExtColour::translucentMutedYellow2, }, std::array<ExtColour, 3>{ ExtColour::translucentBrown0, ExtColour::translucentBrown1, ExtColour::translucentBrown2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedOrange0, ExtColour::translucentMutedOrange1, ExtColour::translucentMutedOrange2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedDarkRed0, ExtColour::translucentMutedDarkRed1, ExtColour::translucentMutedDarkRed2, }, std::array<ExtColour, 3>{ ExtColour::translucentRed0, ExtColour::translucentRed1, ExtColour::translucentRed2, }, std::array<ExtColour, 3>{ ExtColour::translucentRed0, ExtColour::translucentRed1, ExtColour::translucentRed2, }, std::array<ExtColour, 3>{ ExtColour::translucentPink0, ExtColour::translucentPink1, ExtColour::translucentPink2, }, std::array<ExtColour, 3>{ ExtColour::translucentPink0, ExtColour::translucentPink1, ExtColour::translucentPink2, }, std::array<ExtColour, 3>{ ExtColour::translucentMutedRed0, ExtColour::translucentMutedRed1, ExtColour::translucentMutedRed2, }, }; static constexpr std::array<ExtColour, 31> _shadowColourMap = { ExtColour::water, ExtColour::unk21, ExtColour::unk22, ExtColour::unk23, ExtColour::unk24, ExtColour::unk25, ExtColour::unk26, ExtColour::unk27, ExtColour::unk28, ExtColour::unk29, ExtColour::unk2A, ExtColour::unk2B, ExtColour::unk2C, ExtColour::unk2D, ExtColour::unk2E, ExtColour::unk2F, ExtColour::unk30, ExtColour::unk31, ExtColour::unk32, ExtColour::unk33, ExtColour::unk34, ExtColour::translucentGrey1, ExtColour::translucentGrey2, ExtColour::translucentGrey0, ExtColour::translucentBlue1, ExtColour::translucentBlue2, ExtColour::translucentBlue0, ExtColour::translucentMutedDarkRed1, ExtColour::translucentMutedDarkRed2, ExtColour::translucentMutedDarkRed0, ExtColour::translucentMutedSeaGreen1, }; void initColourMap() { // TODO: create a list of tuples with colour and image id for (uint32_t i = 0; i < 31; i++) { const auto c = static_cast<Colour>(i); auto paletteMap = Gfx::PaletteMap::getForColour(toExt(c)); if (!paletteMap) { continue; } auto& map = *paletteMap; _colourMapA[i][0] = map[PaletteIndex::primaryRemap2]; _colourMapA[i][1] = map[PaletteIndex::primaryRemap3]; _colourMapA[i][2] = map[PaletteIndex::primaryRemap4]; _colourMapA[i][3] = map[PaletteIndex::primaryRemap5]; _colourMapA[i][4] = map[PaletteIndex::primaryRemap6]; _colourMapA[i][5] = map[PaletteIndex::primaryRemap7]; _colourMapA[i][6] = map[PaletteIndex::primaryRemap8]; _colourMapA[i][7] = map[PaletteIndex::primaryRemap9]; _colourMapB[i][0] = map[PaletteIndex::primaryRemapA]; _colourMapB[i][1] = map[PaletteIndex::primaryRemapB]; } } uint8_t getShade(Colour colour, uint8_t shade) { assert(enumValue(colour) <= 31); if (shade < 8) { return _colourMapA[enumValue(colour)][shade]; } return _colourMapB[enumValue(colour)][shade - 8]; } // 0x005045FA ExtColour getTranslucent(Colour colour) { return getTranslucent(colour, 1); } ExtColour getTranslucent(Colour colour, uint8_t shade) { return _translucentColourMap[enumValue(colour)][shade]; } ExtColour getShadow(Colour colour) { return _shadowColourMap[enumValue(colour)]; } ExtColour getGlass(Colour colour) { return static_cast<ExtColour>(enumValue(colour) + enumValue(ExtColour::unk74)); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/Colour.h ```h #pragma once #include "Types.hpp" namespace OpenLoco { using PaletteIndex_t = uint8_t; enum class Colour : uint8_t { black = 0, grey = 1, white = 2, mutedDarkPurple = 3, mutedPurple = 4, purple = 5, darkBlue = 6, blue = 7, mutedDarkTeal = 8, mutedTeal = 9, darkGreen = 10, mutedSeaGreen = 11, mutedGrassGreen = 12, green = 13, mutedAvocadoGreen = 14, mutedOliveGreen = 15, yellow = 16, darkYellow = 17, orange = 18, amber = 19, darkOrange = 20, mutedDarkYellow = 21, mutedYellow = 22, brown = 23, mutedOrange = 24, mutedDarkRed = 25, darkRed = 26, red = 27, darkPink = 28, pink = 29, mutedRed = 30, max, }; enum class ExtColour : uint8_t { black = 0, grey = 1, white = 2, mutedDarkPurple = 3, mutedPurple = 4, purple = 5, darkBlue = 6, blue = 7, mutedDarkTeal = 8, mutedTeal = 9, darkGreen = 10, mutedSeaGreen = 11, mutedGrassGreen = 12, green = 13, mutedAvocadoGreen = 14, mutedOliveGreen = 15, yellow = 16, darkYellow = 17, orange = 18, amber = 19, darkOrange = 20, mutedDarkYellow = 21, mutedYellow = 22, brown = 23, mutedOrange = 24, mutedDarkRed = 25, darkRed = 26, red = 27, darkPink = 28, pink = 29, mutedRed = 30, // First 30 are inherited from Colour clear = 31, // No colour water = 32, // Water palette map dynamically loaded from water object unk21, unk22, unk23, unk24, unk25, unk26, unk27, unk28, unk29, unk2A, unk2B, unk2C, // ghost unk2D, unk2E, // translucentGlass1 unk2F, // translucentGlass2 unk30, // translucentGlass0 unk31, // translucentGhost unk32, // shadow unk33, unk34, translucentGrey1, // 0-1 black, grey translucentGrey2, translucentGrey0, translucentBlue1, // 6-7 darkBlue, blue translucentBlue2, translucentBlue0, translucentMutedDarkRed1, // 25 mutedDarkRed translucentMutedDarkRed2, translucentMutedDarkRed0, translucentMutedSeaGreen1, // 11 mutedSeaGreen translucentMutedSeaGreen2, translucentMutedSeaGreen0, translucentMutedPurple1, // 3-4 mutedDarkPurple, mutedPurple translucentMutedPurple2, translucentMutedPurple0, translucentMutedOliveGreen1, // 15 mutedOliveGreen translucentMutedOliveGreen2, translucentMutedOliveGreen0, translucentMutedYellow1, // 21-22 mutedDarkYellow, mutedYellow translucentMutedYellow2, translucentMutedYellow0, translucentYellow1, // 16-17 yellow, darkYellow translucentYellow2, translucentYellow0, translucentMutedGrassGreen1, // 12 mutedGrassGreen translucentMutedGrassGreen2, translucentMutedGrassGreen0, translucentMutedAvocadoGreen1, // 14 mutedAvocadoGreen translucentMutedAvocadoGreen2, translucentMutedAvocadoGreen0, translucentGreen1, // 10, 13 darkGreen, green translucentGreen2, translucentGreen0, translucentMutedOrange1, // 24 mutedOrange translucentMutedOrange2, translucentMutedOrange0, translucentPurple1, // 5 purple translucentPurple2, translucentPurple0, translucentRed1, // 26-27 darkRed, red translucentRed2, translucentRed0, translucentOrange1, // 18, 20 orange, darkOrange translucentOrange2, translucentOrange0, translucentMutedTeal1, // 8-9 mutedDarkTeal, mutedTeal translucentMutedTeal2, translucentMutedTeal0, translucentPink1, // 28-29 pink, darkPink translucentPink2, translucentPink0, translucentBrown1, // 23 brown translucentBrown2, translucentBrown0, translucentMutedRed1, // 30 mutedRed translucentMutedRed2, translucentMutedRed0, translucentWhite1, // 2 white translucentWhite2, translucentWhite0, translucentAmber1, // 19 amber translucentAmber2, translucentAmber0, unk74, unk75, unk76, unk77, unk78, unk79, unk7A, unk7B, unk7C, unk7D, unk7E, unk7F, unk80, unk81, unk82, unk83, unk84, unk85, unk86, unk87, unk88, unk89, unk8A, unk8B, unk8C, unk8D, unk8E, unk8F, unk90, unk91, unk92, max, }; struct AdvancedColour { static constexpr uint8_t outlineFlag = 1 << 5; static constexpr uint8_t insetFlag = 1 << 6; static constexpr uint8_t translucentFlag = 1 << 7; static constexpr uint8_t fd = 0xFD; static constexpr uint8_t fe = 0xFE; static constexpr uint8_t ff = 0xFF; private: Colour _c = Colour::black; public: constexpr AdvancedColour() = default; constexpr AdvancedColour(const Colour c) : _c(c) { } constexpr explicit operator Colour() const { return static_cast<Colour>(enumValue(_c) & ~(outlineFlag | insetFlag | translucentFlag)); } // Returns the Colour without any additional flags set. [[nodiscard]] constexpr Colour c() const { return static_cast<Colour>(*this); } constexpr explicit operator uint8_t() const { return enumValue(_c); } [[nodiscard]] constexpr uint8_t u8() const { return static_cast<uint8_t>(*this); } [[nodiscard]] constexpr AdvancedColour outline() const { return { static_cast<Colour>(enumValue(_c) | outlineFlag) }; } [[nodiscard]] constexpr bool isOutline() const { return enumValue(_c) & outlineFlag; } [[nodiscard]] constexpr AdvancedColour inset() const { return { static_cast<Colour>(enumValue(_c) | insetFlag) }; } [[nodiscard]] constexpr bool isInset() const { return enumValue(_c) & insetFlag; } [[nodiscard]] constexpr AdvancedColour translucent() const { return { static_cast<Colour>(enumValue(_c) | translucentFlag) }; } [[nodiscard]] constexpr bool isTranslucent() const { return enumValue(_c) & translucentFlag; } [[nodiscard]] constexpr AdvancedColour opaque() const { return { static_cast<Colour>(enumValue(_c) & ~translucentFlag) }; } [[nodiscard]] constexpr bool isOpaque() const { return !isTranslucent(); } [[nodiscard]] constexpr AdvancedColour clearInset() const { return { static_cast<Colour>(enumValue(_c) & ~insetFlag) }; } [[nodiscard]] constexpr AdvancedColour clearOutline() const { return { static_cast<Colour>(enumValue(_c) & ~outlineFlag) }; } [[nodiscard]] static constexpr AdvancedColour FF() { return { static_cast<Colour>(ff) }; } [[nodiscard]] constexpr bool isFF() const { return enumValue(_c) == ff; } [[nodiscard]] static constexpr AdvancedColour FE() { return { static_cast<Colour>(fe) }; } [[nodiscard]] constexpr bool isFE() const { return enumValue(_c) == fe; } [[nodiscard]] static constexpr AdvancedColour FD() { return { static_cast<Colour>(fd) }; } [[nodiscard]] constexpr bool isFD() const { return enumValue(_c) == fd; } }; static_assert(sizeof(AdvancedColour) == 1); namespace Colours { void initColourMap(); PaletteIndex_t getShade(Colour colour, uint8_t shade); ExtColour getTranslucent(Colour colour); ExtColour getTranslucent(Colour colour, uint8_t shade); ExtColour getShadow(Colour colour); ExtColour getGlass(Colour colour); constexpr ExtColour toExt(Colour c) { return static_cast<ExtColour>(c); } } namespace PaletteIndex { // All indexes are of the form {swatch colour name}{shade} // Shades are from dark 0x0 to light 0xB // Most swatches are 0xB in length apart from: // transparent (1), // grey (4), // brightYellow (3), // textRemap (6) // // There are 3 unused indexes: // textRemap4, // textRemap5, // hotPinkUnused // 0xFF is technically unused as well constexpr PaletteIndex_t transparent = 0; constexpr PaletteIndex_t textRemap0 = 0x01; constexpr PaletteIndex_t textRemap1 = 0x02; constexpr PaletteIndex_t textRemap2 = 0x03; constexpr PaletteIndex_t textRemap3 = 0x04; constexpr PaletteIndex_t textRemap4 = 0x05; // Unused constexpr PaletteIndex_t textRemap5 = 0x06; // Unused constexpr PaletteIndex_t primaryRemap0 = 0x07; constexpr PaletteIndex_t primaryRemap1 = 0x08; constexpr PaletteIndex_t primaryRemap2 = 0x09; constexpr PaletteIndex_t black0 = 0x0A; constexpr PaletteIndex_t black1 = 0x0B; constexpr PaletteIndex_t black2 = 0x0C; constexpr PaletteIndex_t black3 = 0x0D; constexpr PaletteIndex_t black4 = 0x0E; constexpr PaletteIndex_t black5 = 0x0F; constexpr PaletteIndex_t black6 = 0x10; constexpr PaletteIndex_t black7 = 0x11; constexpr PaletteIndex_t black8 = 0x12; constexpr PaletteIndex_t black9 = 0x13; constexpr PaletteIndex_t blackA = 0x14; constexpr PaletteIndex_t blackB = 0x15; constexpr PaletteIndex_t mutedOliveGreen0 = 0x16; constexpr PaletteIndex_t mutedOliveGreen1 = 0x17; constexpr PaletteIndex_t mutedOliveGreen2 = 0x18; constexpr PaletteIndex_t mutedOliveGreen3 = 0x19; constexpr PaletteIndex_t mutedOliveGreen4 = 0x1A; constexpr PaletteIndex_t mutedOliveGreen5 = 0x1B; constexpr PaletteIndex_t mutedOliveGreen6 = 0x1C; constexpr PaletteIndex_t mutedOliveGreen7 = 0x1D; constexpr PaletteIndex_t mutedOliveGreen8 = 0x1E; constexpr PaletteIndex_t mutedOliveGreen9 = 0x1F; constexpr PaletteIndex_t mutedOliveGreenA = 0x20; constexpr PaletteIndex_t mutedOliveGreenB = 0x21; constexpr PaletteIndex_t mutedDarkYellow0 = 0x22; constexpr PaletteIndex_t mutedDarkYellow1 = 0x23; constexpr PaletteIndex_t mutedDarkYellow2 = 0x24; constexpr PaletteIndex_t mutedDarkYellow3 = 0x25; constexpr PaletteIndex_t mutedDarkYellow4 = 0x26; constexpr PaletteIndex_t mutedDarkYellow5 = 0x27; constexpr PaletteIndex_t mutedDarkYellow6 = 0x28; constexpr PaletteIndex_t mutedDarkYellow7 = 0x29; constexpr PaletteIndex_t mutedDarkYellow8 = 0x2A; constexpr PaletteIndex_t mutedDarkYellow9 = 0x2B; constexpr PaletteIndex_t mutedDarkYellowA = 0x2C; constexpr PaletteIndex_t mutedDarkYellowB = 0x2D; constexpr PaletteIndex_t yellow0 = 0x2E; constexpr PaletteIndex_t yellow1 = 0x2F; constexpr PaletteIndex_t yellow2 = 0x30; constexpr PaletteIndex_t yellow3 = 0x31; constexpr PaletteIndex_t yellow4 = 0x32; constexpr PaletteIndex_t yellow5 = 0x33; constexpr PaletteIndex_t yellow6 = 0x34; constexpr PaletteIndex_t yellow7 = 0x35; constexpr PaletteIndex_t yellow8 = 0x36; constexpr PaletteIndex_t yellow9 = 0x37; constexpr PaletteIndex_t yellowA = 0x38; constexpr PaletteIndex_t yellowB = 0x39; constexpr PaletteIndex_t mutedDarkRed0 = 0x3A; constexpr PaletteIndex_t mutedDarkRed1 = 0x3B; constexpr PaletteIndex_t mutedDarkRed2 = 0x3C; constexpr PaletteIndex_t mutedDarkRed3 = 0x3D; constexpr PaletteIndex_t mutedDarkRed4 = 0x3E; constexpr PaletteIndex_t mutedDarkRed5 = 0x3F; constexpr PaletteIndex_t mutedDarkRed6 = 0x40; constexpr PaletteIndex_t mutedDarkRed7 = 0x41; constexpr PaletteIndex_t mutedDarkRed8 = 0x42; constexpr PaletteIndex_t mutedDarkRed9 = 0x43; constexpr PaletteIndex_t mutedDarkRedA = 0x44; constexpr PaletteIndex_t mutedDarkRedB = 0x45; constexpr PaletteIndex_t mutedGrassGreen0 = 0x46; constexpr PaletteIndex_t mutedGrassGreen1 = 0x47; constexpr PaletteIndex_t mutedGrassGreen2 = 0x48; constexpr PaletteIndex_t mutedGrassGreen3 = 0x49; constexpr PaletteIndex_t mutedGrassGreen4 = 0x4A; constexpr PaletteIndex_t mutedGrassGreen5 = 0x4B; constexpr PaletteIndex_t mutedGrassGreen6 = 0x4C; constexpr PaletteIndex_t mutedGrassGreen7 = 0x4D; constexpr PaletteIndex_t mutedGrassGreen8 = 0x4E; constexpr PaletteIndex_t mutedGrassGreen9 = 0x4F; constexpr PaletteIndex_t mutedGrassGreenA = 0x50; constexpr PaletteIndex_t mutedGrassGreenB = 0x51; constexpr PaletteIndex_t mutedAvocadoGreen0 = 0x52; constexpr PaletteIndex_t mutedAvocadoGreen1 = 0x53; constexpr PaletteIndex_t mutedAvocadoGreen2 = 0x54; constexpr PaletteIndex_t mutedAvocadoGreen3 = 0x55; constexpr PaletteIndex_t mutedAvocadoGreen4 = 0x56; constexpr PaletteIndex_t mutedAvocadoGreen5 = 0x57; constexpr PaletteIndex_t mutedAvocadoGreen6 = 0x58; constexpr PaletteIndex_t mutedAvocadoGreen7 = 0x59; constexpr PaletteIndex_t mutedAvocadoGreen8 = 0x5A; constexpr PaletteIndex_t mutedAvocadoGreen9 = 0x5B; constexpr PaletteIndex_t mutedAvocadoGreenA = 0x5C; constexpr PaletteIndex_t mutedAvocadoGreenB = 0x5D; constexpr PaletteIndex_t green0 = 0x5E; constexpr PaletteIndex_t green1 = 0x5F; constexpr PaletteIndex_t green2 = 0x60; constexpr PaletteIndex_t green3 = 0x61; constexpr PaletteIndex_t green4 = 0x62; constexpr PaletteIndex_t green5 = 0x63; constexpr PaletteIndex_t green6 = 0x64; constexpr PaletteIndex_t green7 = 0x65; constexpr PaletteIndex_t green8 = 0x66; constexpr PaletteIndex_t green9 = 0x67; constexpr PaletteIndex_t greenA = 0x68; constexpr PaletteIndex_t greenB = 0x69; constexpr PaletteIndex_t mutedOrange0 = 0x6A; constexpr PaletteIndex_t mutedOrange1 = 0x6B; constexpr PaletteIndex_t mutedOrange2 = 0x6C; constexpr PaletteIndex_t mutedOrange3 = 0x6D; constexpr PaletteIndex_t mutedOrange4 = 0x6E; constexpr PaletteIndex_t mutedOrange5 = 0x6F; constexpr PaletteIndex_t mutedOrange6 = 0x70; constexpr PaletteIndex_t mutedOrange7 = 0x71; constexpr PaletteIndex_t mutedOrange8 = 0x72; constexpr PaletteIndex_t mutedOrange9 = 0x73; constexpr PaletteIndex_t mutedOrangeA = 0x74; constexpr PaletteIndex_t mutedOrangeB = 0x75; constexpr PaletteIndex_t mutedPurple0 = 0x76; constexpr PaletteIndex_t mutedPurple1 = 0x77; constexpr PaletteIndex_t mutedPurple2 = 0x78; constexpr PaletteIndex_t mutedPurple3 = 0x79; constexpr PaletteIndex_t mutedPurple4 = 0x7A; constexpr PaletteIndex_t mutedPurple5 = 0x7B; constexpr PaletteIndex_t mutedPurple6 = 0x7C; constexpr PaletteIndex_t mutedPurple7 = 0x7D; constexpr PaletteIndex_t mutedPurple8 = 0x7E; constexpr PaletteIndex_t mutedPurple9 = 0x7F; constexpr PaletteIndex_t mutedPurpleA = 0x80; constexpr PaletteIndex_t mutedPurpleB = 0x81; constexpr PaletteIndex_t blue0 = 0x82; constexpr PaletteIndex_t blue1 = 0x83; constexpr PaletteIndex_t blue2 = 0x84; constexpr PaletteIndex_t blue3 = 0x85; constexpr PaletteIndex_t blue4 = 0x86; constexpr PaletteIndex_t blue5 = 0x87; constexpr PaletteIndex_t blue6 = 0x88; constexpr PaletteIndex_t blue7 = 0x89; constexpr PaletteIndex_t blue8 = 0x8A; constexpr PaletteIndex_t blue9 = 0x8B; constexpr PaletteIndex_t blueA = 0x8C; constexpr PaletteIndex_t blueB = 0x8D; constexpr PaletteIndex_t mutedSeaGreen0 = 0x8E; constexpr PaletteIndex_t mutedSeaGreen1 = 0x8F; constexpr PaletteIndex_t mutedSeaGreen2 = 0x90; constexpr PaletteIndex_t mutedSeaGreen3 = 0x91; constexpr PaletteIndex_t mutedSeaGreen4 = 0x92; constexpr PaletteIndex_t mutedSeaGreen5 = 0x93; constexpr PaletteIndex_t mutedSeaGreen6 = 0x94; constexpr PaletteIndex_t mutedSeaGreen7 = 0x95; constexpr PaletteIndex_t mutedSeaGreen8 = 0x96; constexpr PaletteIndex_t mutedSeaGreen9 = 0x97; constexpr PaletteIndex_t mutedSeaGreenA = 0x98; constexpr PaletteIndex_t mutedSeaGreenB = 0x99; constexpr PaletteIndex_t purple0 = 0x9A; constexpr PaletteIndex_t purple1 = 0x9B; constexpr PaletteIndex_t purple2 = 0x9C; constexpr PaletteIndex_t purple3 = 0x9D; constexpr PaletteIndex_t purple4 = 0x9E; constexpr PaletteIndex_t purple5 = 0x9F; constexpr PaletteIndex_t purple6 = 0xA0; constexpr PaletteIndex_t purple7 = 0xA1; constexpr PaletteIndex_t purple8 = 0xA2; constexpr PaletteIndex_t purple9 = 0xA3; constexpr PaletteIndex_t purpleA = 0xA4; constexpr PaletteIndex_t purpleB = 0xA5; constexpr PaletteIndex_t red0 = 0xA6; constexpr PaletteIndex_t red1 = 0xA7; constexpr PaletteIndex_t red2 = 0xA8; constexpr PaletteIndex_t red3 = 0xA9; constexpr PaletteIndex_t red4 = 0xAA; constexpr PaletteIndex_t red5 = 0xAB; constexpr PaletteIndex_t red6 = 0xAC; constexpr PaletteIndex_t red7 = 0xAD; constexpr PaletteIndex_t red8 = 0xAE; constexpr PaletteIndex_t red9 = 0xAF; constexpr PaletteIndex_t redA = 0xB0; constexpr PaletteIndex_t redB = 0xB1; constexpr PaletteIndex_t orange0 = 0xB2; constexpr PaletteIndex_t orange1 = 0xB3; constexpr PaletteIndex_t orange2 = 0xB4; constexpr PaletteIndex_t orange3 = 0xB5; constexpr PaletteIndex_t orange4 = 0xB6; constexpr PaletteIndex_t orange5 = 0xB7; constexpr PaletteIndex_t orange6 = 0xB8; constexpr PaletteIndex_t orange7 = 0xB9; constexpr PaletteIndex_t orange8 = 0xBA; constexpr PaletteIndex_t orange9 = 0xBB; constexpr PaletteIndex_t orangeA = 0xBC; constexpr PaletteIndex_t orangeB = 0xBD; constexpr PaletteIndex_t mutedDarkTeal0 = 0xBE; constexpr PaletteIndex_t mutedDarkTeal1 = 0xBF; constexpr PaletteIndex_t mutedDarkTeal2 = 0xC0; constexpr PaletteIndex_t mutedDarkTeal3 = 0xC1; constexpr PaletteIndex_t mutedDarkTeal4 = 0xC2; constexpr PaletteIndex_t mutedDarkTeal5 = 0xC3; constexpr PaletteIndex_t mutedDarkTeal6 = 0xC4; constexpr PaletteIndex_t mutedDarkTeal7 = 0xC5; constexpr PaletteIndex_t mutedDarkTeal8 = 0xC6; constexpr PaletteIndex_t mutedDarkTeal9 = 0xC7; constexpr PaletteIndex_t mutedDarkTealA = 0xC8; constexpr PaletteIndex_t mutedDarkTealB = 0xC9; constexpr PaletteIndex_t pink0 = 0xCA; // Also used for secondary remap constexpr PaletteIndex_t pink1 = 0xCB; constexpr PaletteIndex_t pink2 = 0xCC; constexpr PaletteIndex_t pink3 = 0xCD; constexpr PaletteIndex_t pink4 = 0xCE; constexpr PaletteIndex_t pink5 = 0xCF; constexpr PaletteIndex_t pink6 = 0xD0; constexpr PaletteIndex_t pink7 = 0xD1; constexpr PaletteIndex_t pink8 = 0xD2; constexpr PaletteIndex_t pink9 = 0xD3; constexpr PaletteIndex_t pinkA = 0xD4; constexpr PaletteIndex_t pinkB = 0xD5; constexpr PaletteIndex_t secondaryRemap0 = 0xCA; // Also used for pink constexpr PaletteIndex_t secondaryRemap1 = 0xCB; constexpr PaletteIndex_t secondaryRemap2 = 0xCC; constexpr PaletteIndex_t secondaryRemap3 = 0xCD; constexpr PaletteIndex_t secondaryRemap4 = 0xCE; constexpr PaletteIndex_t secondaryRemap5 = 0xCF; constexpr PaletteIndex_t secondaryRemap6 = 0xD0; constexpr PaletteIndex_t secondaryRemap7 = 0xD1; constexpr PaletteIndex_t secondaryRemap8 = 0xD2; constexpr PaletteIndex_t secondaryRemap9 = 0xD3; constexpr PaletteIndex_t secondaryRemapA = 0xD4; constexpr PaletteIndex_t secondaryRemapB = 0xD5; constexpr PaletteIndex_t brown0 = 0xD6; constexpr PaletteIndex_t brown1 = 0xD7; constexpr PaletteIndex_t brown2 = 0xD8; constexpr PaletteIndex_t brown3 = 0xD9; constexpr PaletteIndex_t brown4 = 0xDA; constexpr PaletteIndex_t brown5 = 0xDB; constexpr PaletteIndex_t brown6 = 0xDC; constexpr PaletteIndex_t brown7 = 0xDD; constexpr PaletteIndex_t brown8 = 0xDE; constexpr PaletteIndex_t brown9 = 0xDF; constexpr PaletteIndex_t brownA = 0xE0; constexpr PaletteIndex_t brownB = 0xE1; constexpr PaletteIndex_t grey0 = 0xE2; constexpr PaletteIndex_t brightYellow0 = 0xE3; constexpr PaletteIndex_t brightYellow1 = 0xE4; constexpr PaletteIndex_t brightYellow2 = 0xE5; constexpr PaletteIndex_t amber0 = 0xE6; constexpr PaletteIndex_t amber1 = 0xE7; constexpr PaletteIndex_t amber2 = 0xE8; constexpr PaletteIndex_t amber3 = 0xE9; constexpr PaletteIndex_t amber4 = 0xEA; constexpr PaletteIndex_t amber5 = 0xEB; constexpr PaletteIndex_t amber6 = 0xEC; constexpr PaletteIndex_t amber7 = 0xED; constexpr PaletteIndex_t amber8 = 0xEE; constexpr PaletteIndex_t amber9 = 0xEF; constexpr PaletteIndex_t grey1 = 0xF0; constexpr PaletteIndex_t grey2 = 0xF1; constexpr PaletteIndex_t grey3 = 0xF2; constexpr PaletteIndex_t amberA = 0xF3; constexpr PaletteIndex_t amberB = 0xF4; constexpr PaletteIndex_t unusedHotPink = 0xF5; // Unused constexpr PaletteIndex_t primaryRemap3 = 0xF6; constexpr PaletteIndex_t primaryRemap4 = 0xF7; constexpr PaletteIndex_t primaryRemap5 = 0xF8; constexpr PaletteIndex_t primaryRemap6 = 0xF9; constexpr PaletteIndex_t primaryRemap7 = 0xFA; constexpr PaletteIndex_t primaryRemap8 = 0xFB; constexpr PaletteIndex_t primaryRemap9 = 0xFC; constexpr PaletteIndex_t primaryRemapA = 0xFD; constexpr PaletteIndex_t primaryRemapB = 0xFE; constexpr PaletteIndex_t index_FF = 0xFF; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/DrawSprite.cpp ```cpp #include "DrawSprite.h" #include "DrawSpriteBMP.hpp" #include "DrawSpriteRLE.hpp" #include "Graphics/Gfx.h" #include "Graphics/RenderTarget.h" namespace OpenLoco::Gfx { DrawBlendOp getDrawBlendOp(const ImageId image, const DrawSpriteArgs& args) { DrawBlendOp op = DrawBlendOp::none; // Image uses the palette pointer to remap the colours of the image if (image.hasPrimary()) { if (image.isBlended()) { // Copy non-transparent bitmap data but blend src and dst pixel using the palette map. op = DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::dst; } else { // Copy non-transparent bitmap data but re-colour using the palette map. op = DrawBlendOp::transparent | DrawBlendOp::src; } } else if (image.isBlended()) { // Image is only a transparency mask. Just colour the pixels using the palette map. // Used for glass. op = DrawBlendOp::transparent | DrawBlendOp::dst; } else if (!args.sourceImage.hasFlags(G1ElementFlags::hasTransparency)) { // Copy raw bitmap data to target op = DrawBlendOp::none; } else { // Copy raw bitmap data to target but exclude transparent pixels op = DrawBlendOp::transparent; } // Vanilla did not handle noise image for RLE compressed images if (args.noiseImage != nullptr && (!args.sourceImage.hasFlags(G1ElementFlags::isRLECompressed))) { op |= DrawBlendOp::noiseMask; } return op; } #pragma warning(push) #pragma warning(disable : 4063) // not a valid value for a switch of this enum #pragma GCC diagnostic push #pragma GCC diagnostic ignored "-Wswitch" // not a valid value for a switch of this enum template<uint8_t TZoomLevel, bool TIsRLE> inline void drawSpriteToBufferHelper(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { if constexpr (!TIsRLE) { switch (op) { case DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::dst: drawBMPSprite<DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::dst, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent | DrawBlendOp::src: drawBMPSprite<DrawBlendOp::transparent | DrawBlendOp::src, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent | DrawBlendOp::dst: drawBMPSprite<DrawBlendOp::transparent | DrawBlendOp::dst, TZoomLevel>(rt, args); break; case DrawBlendOp::none: drawBMPSprite<DrawBlendOp::none, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent: drawBMPSprite<DrawBlendOp::transparent, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::noiseMask: drawBMPSprite<DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::noiseMask, TZoomLevel>(rt, args); break; case DrawBlendOp::none | DrawBlendOp::noiseMask: drawBMPSprite<DrawBlendOp::none | DrawBlendOp::noiseMask, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent | DrawBlendOp::noiseMask: drawBMPSprite<DrawBlendOp::transparent | DrawBlendOp::noiseMask, TZoomLevel>(rt, args); break; default: assert(false); break; } } else { switch (op) { case DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::dst: drawRLESprite<DrawBlendOp::transparent | DrawBlendOp::src | DrawBlendOp::dst, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent | DrawBlendOp::src: drawRLESprite<DrawBlendOp::transparent | DrawBlendOp::src, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent | DrawBlendOp::dst: drawRLESprite<DrawBlendOp::transparent | DrawBlendOp::dst, TZoomLevel>(rt, args); break; case DrawBlendOp::none: drawRLESprite<DrawBlendOp::none, TZoomLevel>(rt, args); break; case DrawBlendOp::transparent: drawRLESprite<DrawBlendOp::transparent, TZoomLevel>(rt, args); break; default: assert(false); break; } } } #pragma GCC diagnostic pop #pragma warning(pop) template<> void drawSpriteToBuffer<0, false>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<0, false>(rt, args, op); } template<> void drawSpriteToBuffer<1, false>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<1, false>(rt, args, op); } template<> void drawSpriteToBuffer<2, false>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<2, false>(rt, args, op); } template<> void drawSpriteToBuffer<3, false>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<3, false>(rt, args, op); } template<> void drawSpriteToBuffer<0, true>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<0, true>(rt, args, op); } template<> void drawSpriteToBuffer<1, true>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<1, true>(rt, args, op); } template<> void drawSpriteToBuffer<2, true>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<2, true>(rt, args, op); } template<> void drawSpriteToBuffer<3, true>(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op) { drawSpriteToBufferHelper<3, true>(rt, args, op); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/DrawSprite.h ```h #pragma once #include "Graphics/ImageId.h" #include "Graphics/PaletteMap.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/Ui/Point.hpp> #include <OpenLoco/Engine/Ui/Size.hpp> namespace OpenLoco::Gfx { struct G1Element; struct RenderTarget; struct DrawSpritePosArgs { Ui::Point32 srcPos; Ui::Point32 dstPos; Ui::Size size; }; struct DrawSpriteArgs { const PaletteMap::View palMap; const G1Element& sourceImage; Ui::Point32 srcPos; Ui::Point32 dstPos; Ui::Size size; const G1Element* noiseImage; DrawSpriteArgs( const PaletteMap::View _palMap, const G1Element& _sourceImage, const Ui::Point32& _srcPos, const Ui::Point32& _dstPos, const Ui::Size& _size, const G1Element* _noiseImage) : palMap(_palMap) , sourceImage(_sourceImage) , srcPos(_srcPos) , dstPos(_dstPos) , size(_size) , noiseImage(_noiseImage) { } }; enum class DrawBlendOp : uint8_t { none = 0U, /** * Only supported by BITMAP. RLE images always encode transparency via the encoding. * Pixel value of 0 represents transparent. */ transparent = 1U << 0, /** * Whether to use the pixel value from the source image. * This is usually only unset for glass images where there the src is only a transparency mask. */ src = 1U << 1, /** * Whether to use the pixel value of the destination image for blending. * This is used for any image that filters the target image, e.g. glass or water. */ dst = 1U << 2, /** * Whether to use the noise image to prevent draws on certain parts of the image. */ noiseMask = 1U << 3, }; OPENLOCO_ENABLE_ENUM_OPERATORS(DrawBlendOp); DrawBlendOp getDrawBlendOp(const ImageId image, const DrawSpriteArgs& args); template<uint8_t TZoomLevel, bool TIsRLE> void drawSpriteToBuffer(const RenderTarget& rt, const DrawSpriteArgs& args, const DrawBlendOp op); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/DrawSpriteBMP.hpp ```hpp #pragma once #include "DrawSprite.h" #include "DrawSpriteHelper.hpp" #include "Graphics/Gfx.h" #include "Graphics/RenderTarget.h" namespace OpenLoco::Gfx { template<DrawBlendOp TBlendOp, uint8_t TZoomLevel> inline void drawBMPSprite(const RenderTarget& rt, const DrawSpriteArgs& args) { const auto& g1 = args.sourceImage; const auto* src = g1.offset + ((static_cast<size_t>(g1.width) * args.srcPos.y) + args.srcPos.x); const auto& paletteMap = args.palMap; const int32_t width = args.size.width; int32_t height = args.size.height; const size_t srcLineWidth = g1.width << TZoomLevel; const size_t dstLineWidth = (static_cast<size_t>(rt.width) >> TZoomLevel) + rt.pitch; auto* dst = rt.bits; // Move the pointer to the start point of the destination dst += dstLineWidth * args.dstPos.y + args.dstPos.x; constexpr auto zoom = 1 << TZoomLevel; if constexpr ((TBlendOp & DrawBlendOp::noiseMask) != DrawBlendOp::none) { const auto* noiseMask = args.noiseImage->offset + ((static_cast<size_t>(g1.width) * args.srcPos.y) + args.srcPos.x); for (; height > 0; height -= zoom) { auto* nextSrc = src + srcLineWidth; auto* nextDst = dst + dstLineWidth; auto* nextNoiseMask = noiseMask + srcLineWidth; for (int32_t widthRemaining = width; widthRemaining > 0; widthRemaining -= zoom, src += zoom, noiseMask += zoom, dst++) { blitPixel<TBlendOp>(*src, *dst, paletteMap, *noiseMask); } src = nextSrc; dst = nextDst; noiseMask = nextNoiseMask; } } else { for (; height > 0; height -= zoom) { auto* nextSrc = src + srcLineWidth; auto* nextDst = dst + dstLineWidth; for (int32_t widthRemaining = width; widthRemaining > 0; widthRemaining -= zoom, src += zoom, dst++) { blitPixel<TBlendOp>(*src, *dst, paletteMap, 0xFF); } src = nextSrc; dst = nextDst; } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/DrawSpriteHelper.hpp ```hpp #pragma once #include "DrawSprite.h" #include "Graphics/Gfx.h" #include "Graphics/PaletteMap.h" namespace OpenLoco::Gfx { inline uint8_t blend(const PaletteMap::View paletteMap, uint8_t src, uint8_t dst) { // src = 0 would be transparent so there is no blend palette for that, hence src - 1 assert(src != 0); // src is treated as a row in the palette map, validate its in range. const auto row = src - 1u; assert(row < (paletteMap.size() / PaletteMap::kDefaultSize)); const auto idx = (row * PaletteMap::kDefaultSize) + dst; assert(idx < paletteMap.size()); return paletteMap[idx]; } template<DrawBlendOp TBlendOp> bool blitPixel(uint8_t src, uint8_t& dst, [[maybe_unused]] const PaletteMap::View paletteMap, const uint8_t noiseMask) { if constexpr ((TBlendOp & DrawBlendOp::noiseMask) != DrawBlendOp::none) { // noiseMask is either 0 or 0xFF src &= noiseMask; } if constexpr ((TBlendOp & DrawBlendOp::transparent) != DrawBlendOp::none) { // Ignore transparent pixels if (src == PaletteIndex::transparent) { return false; } } if constexpr (((TBlendOp & DrawBlendOp::src) != DrawBlendOp::none) && ((TBlendOp & DrawBlendOp::dst) != DrawBlendOp::none)) { auto pixel = blend(paletteMap, src, dst); if constexpr ((TBlendOp & DrawBlendOp::transparent) != DrawBlendOp::none) { if (pixel == PaletteIndex::transparent) { return false; } } dst = pixel; return true; } else if constexpr ((TBlendOp & DrawBlendOp::src) != DrawBlendOp::none) { auto pixel = paletteMap[src]; if constexpr ((TBlendOp & DrawBlendOp::transparent) != DrawBlendOp::none) { if (pixel == PaletteIndex::transparent) { return false; } } dst = pixel; return true; } else if constexpr ((TBlendOp & DrawBlendOp::dst) != DrawBlendOp::none) { auto pixel = paletteMap[dst]; if constexpr ((TBlendOp & DrawBlendOp::transparent) != DrawBlendOp::none) { if (pixel == PaletteIndex::transparent) { return false; } } dst = pixel; return true; } else { dst = src; return true; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/DrawSpriteRLE.hpp ```hpp #pragma once #include "DrawSprite.h" #include "DrawSpriteHelper.hpp" #include "Graphics/Gfx.h" #include "Graphics/RenderTarget.h" namespace OpenLoco::Gfx { template<DrawBlendOp TBlendOp, uint8_t TZoomLevel> inline void drawRLESprite(const RenderTarget& rt, const DrawSpriteArgs& args) { auto src0 = args.sourceImage.offset; const auto srcX = args.srcPos.x; auto srcY = args.srcPos.y; const int32_t width = args.size.width; int32_t height = args.size.height; constexpr auto zoom = 1 << TZoomLevel; auto dstLineWidth = (static_cast<size_t>(rt.width) >> TZoomLevel) + rt.pitch; auto* dst0 = rt.bits; // Move the pointer to the start point of the destination dst0 += dstLineWidth * args.dstPos.y + args.dstPos.x; // Move up to the first line of the image if source_y_start is negative. Why does this even occur? if (srcY < 0) { srcY += zoom; height -= zoom; dst0 += dstLineWidth; } // For every line in the image for (int32_t i = 0; i < height; i += zoom) { int32_t y = srcY + i; // The first part of the source pointer is a list of offsets to different lines // This will move the pointer to the correct source line. uint16_t lineOffset = src0[y * 2] | (src0[y * 2 + 1] << 8); auto nextRun = src0 + lineOffset; auto dstLineStart = dst0 + dstLineWidth * (i >> TZoomLevel); // For every data chunk in the line auto isEndOfLine = false; while (!isEndOfLine) { // Read chunk metadata auto src = nextRun; auto dataSize = *src++; auto firstPixelX = *src++; isEndOfLine = (dataSize & 0x80) != 0; dataSize &= 0x7F; // Have our next source pointer point to the next data section nextRun = src + dataSize; int32_t x = firstPixelX - srcX; int32_t numPixels = dataSize; if (x > 0) { // If x is not a multiple of zoom, round it up to a multiple auto mod = x & (zoom - 1); if (mod != 0) { auto offset = zoom - mod; x += offset; src += offset; numPixels -= offset; } } else if (x < 0) { // Clamp x to zero if negative src += -x; numPixels += x; x = 0; } // If the end position is further out than the whole image // end position then we need to shorten the line again numPixels = std::min(numPixels, width - x); auto dst = dstLineStart + (x >> TZoomLevel); if constexpr ((TBlendOp & DrawBlendOp::src) == DrawBlendOp::none && (TBlendOp & DrawBlendOp::dst) == DrawBlendOp::none && TZoomLevel == 0) { // Since we're sampling each pixel at this zoom level, just do a straight std::memcpy if (numPixels > 0) { std::copy_n(src, numPixels, dst); } } else { auto& paletteMap = args.palMap; while (numPixels > 0) { blitPixel<TBlendOp>(*src, *dst, paletteMap, 0xFF); numPixels -= zoom; src += zoom; dst++; } } } } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/DrawingContext.h ```h #pragma once #include "Font.h" #include "Graphics/Gfx.h" #include "Graphics/PaletteMap.h" #include "Localisation/FormatArguments.hpp" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/Ui/Rect.hpp> #include <cstdint> namespace OpenLoco::Gfx { enum class RectInsetFlags : uint8_t { fillTransparent = 1U << 2, // ? unused borderNone = 1U << 3, // ? unused fillNone = 1U << 4, borderInset = 1U << 5, fillDarker = 1U << 6, colourLight = 1U << 7, none = 0U }; OPENLOCO_ENABLE_ENUM_OPERATORS(RectInsetFlags); enum class RectFlags : uint32_t { crossHatching = 1U << 24, transparent = 1U << 25, // Changes colour parameter from PaletteIndex_t to ExtColour selectPattern = 1U << 26, // unused g1Pattern = 1U << 27, // unused none = 0U }; OPENLOCO_ENABLE_ENUM_OPERATORS(RectFlags); class DrawingContext { public: virtual ~DrawingContext() = default; virtual void pushRenderTarget(const RenderTarget& rt) = 0; virtual void popRenderTarget() = 0; virtual const RenderTarget& currentRenderTarget() const = 0; virtual void clear(uint32_t fill) = 0; virtual void clearSingle(uint8_t paletteId) = 0; virtual void fillRect(int16_t left, int16_t top, int16_t right, int16_t bottom, uint8_t colour, RectFlags flags) = 0; void fillRect(const Ui::Point& origin, const Ui::Size& size, uint8_t colour, RectFlags flags) { fillRect(origin.x, origin.y, origin.x + size.width - 1, origin.y + size.height - 1, colour, flags); } virtual void drawRect(int16_t x, int16_t y, uint16_t dx, uint16_t dy, uint8_t colour, RectFlags flags) = 0; void drawRect(const Ui::Point& origin, const Ui::Size& size, uint8_t colour, RectFlags flags) { drawRect(origin.x, origin.y, size.width, size.height, colour, flags); } virtual void fillRectInset(int16_t left, int16_t top, int16_t right, int16_t bottom, AdvancedColour colour, RectInsetFlags flags) = 0; void fillRectInset(const Ui::Point& origin, const Ui::Size& size, AdvancedColour colour, RectInsetFlags flags) { fillRectInset(origin.x, origin.y, origin.x + size.width - 1, origin.y + size.height - 1, colour, flags); } virtual void drawRectInset(int16_t x, int16_t y, uint16_t dx, uint16_t dy, AdvancedColour colour, RectInsetFlags flags) = 0; void drawRectInset(const Ui::Point& origin, const Ui::Size& size, AdvancedColour colour, RectInsetFlags flags) { drawRectInset(origin.x, origin.y, size.width, size.height, colour, flags); } virtual void drawLine(const Ui::Point& a, const Ui::Point& b, PaletteIndex_t colour) = 0; virtual void drawImage(int16_t x, int16_t y, uint32_t image) = 0; void drawImage(const Ui::Point& pos, uint32_t image) { drawImage(pos, ImageId::fromUInt32(image)); } virtual void drawImage(const Ui::Point& pos, const ImageId& image) = 0; virtual void drawImageMasked(const Ui::Point& pos, const ImageId& image, const ImageId& maskImage) = 0; virtual void drawImageSolid(const Ui::Point& pos, const ImageId& image, PaletteIndex_t paletteIndex) = 0; virtual void drawImagePaletteSet(const Ui::Point& pos, const ImageId& image, PaletteMap::View palette, const G1Element* noiseImage) = 0; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/FPSCounter.cpp ```cpp #include "FPSCounter.h" #include "Graphics/Colour.h" #include "Graphics/Gfx.h" #include "Graphics/SoftwareDrawingEngine.h" #include "Graphics/TextRenderer.h" #include "Localisation/Formatting.h" #include "Ui.h" #include <chrono> #include <stdio.h> namespace OpenLoco::Gfx { using Clock_t = std::chrono::high_resolution_clock; using TimePoint_t = Clock_t::time_point; static TimePoint_t _referenceTime; static uint32_t _currentFrameCount; static float _currentFPS; static float measureFPS() { _currentFrameCount++; auto currentTime = Clock_t::now(); auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - _referenceTime).count() / 1000.0; if (elapsed > 1.0) { _currentFPS = _currentFrameCount / elapsed; _currentFrameCount = 0; _referenceTime = currentTime; } return _currentFPS; } void drawFPS(DrawingContext& drawingCtx) { auto tr = Gfx::TextRenderer(drawingCtx); // Measure FPS const float fps = measureFPS(); // Format string char buffer[64]; buffer[0] = ControlCodes::Font::bold; buffer[1] = ControlCodes::Font::outline; buffer[2] = ControlCodes::Colour::white; const char* formatString = (_currentFPS >= 10.0f ? "%.0f" : "%.1f"); snprintf(&buffer[3], std::size(buffer) - 3, formatString, fps); // Draw text const int stringWidth = tr.getStringWidth(buffer); auto point = Ui::Point(Ui::width() / 2 - (stringWidth / 2), 2); tr.drawString(point, Colour::black, buffer); // Make area dirty so the text doesn't get drawn over the last invalidateRegion(point.x, point.y, point.x + stringWidth, point.y + 16); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/FPSCounter.h ```h #pragma once namespace OpenLoco::Gfx { class DrawingContext; void drawFPS(DrawingContext& drawingCtx); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/Font.h ```h #pragma once #include <cstdint> namespace OpenLoco::Gfx { enum class Font : int16_t { m1 = -1, m2 = -2, medium_normal = 0, medium_bold = 224, small = 448, large = 672, }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/Gfx.cpp ```cpp #include "Gfx.h" #include "Colour.h" #include "Config.h" #include "Environment.h" #include "Font.h" #include "Graphics/DrawSprite.h" #include "Graphics/RenderTarget.h" #include "Graphics/SoftwareDrawingEngine.h" #include "ImageIds.h" #include "Input.h" #include "Localisation/Formatting.h" #include "Localisation/LanguageFiles.h" #include "Localisation/StringManager.h" #include "Logging.h" #include "Objects/CurrencyObject.h" #include "Objects/ObjectManager.h" #include "PaletteMap.h" #include "SceneManager.h" #include "Ui.h" #include "Ui/WindowManager.h" #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Core/Stream.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <algorithm> #include <cassert> #include <fstream> #include <iostream> #include <memory> #include <numeric> using namespace OpenLoco::Interop; using namespace OpenLoco::Utility; using namespace OpenLoco::Gfx; using namespace OpenLoco::Ui; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Gfx { constexpr uint32_t kG1CountTemporary = 0x1000; // 0x009E2424 static std::array<G1Element, G1ExpectedCount::kDisc + kG1CountTemporary + G1ExpectedCount::kObjects> _g1Elements; static std::unique_ptr<std::byte[]> _g1Buffer; // 0x0112C884 static std::array<std::array<uint8_t, 224>, 4> _characterWidths; // 0x0113ED20 static std::array<PaletteEntry, 256> _rgbaPalette; // 0x004FFAE8 ImageId applyGhostToImage(uint32_t imageIndex) { if (Config::get().constructionMarker) { return ImageId(imageIndex).withTranslucency(ExtColour::unk31); } else { return ImageId(imageIndex, ExtColour::unk2C); } } static std::vector<G1Element> convertElements(const std::vector<G1Element32>& elements32) { auto elements = std::vector<G1Element>(); elements.reserve(elements32.size()); std::transform( elements32.begin(), elements32.end(), std::back_inserter(elements), [](G1Element32 src) { return G1Element(src); }); return elements; } // 0x0044733C void loadG1() { auto g1Path = Environment::getPath(Environment::PathId::g1); std::ifstream stream(g1Path, std::ios::in | std::ios::binary); if (!stream) { throw Exception::RuntimeError("Opening g1 file failed."); } G1Header header; if (!readData(stream, header)) { throw Exception::RuntimeError("Reading g1 file header failed."); } if (header.numEntries != G1ExpectedCount::kDisc) { if (header.numEntries == G1ExpectedCount::kSteam) { Logging::verbose("Got Steam G1.DAT variant, will fix elements automatically."); } else { Logging::warn("G1 element count doesn't match expected value:\nExpected {}; Got {}", G1ExpectedCount::kDisc, header.numEntries); } } // Read element headers auto elements32 = std::vector<G1Element32>(header.numEntries); if (!readData(stream, elements32.data(), header.numEntries)) { throw Exception::RuntimeError("Reading g1 element headers failed."); } auto elements = convertElements(elements32); // Read element data auto elementData = std::make_unique<std::byte[]>(header.totalSize); if (!readData(stream, elementData.get(), header.totalSize)) { throw Exception::RuntimeError("Reading g1 elements failed."); } stream.close(); // The steam G1.DAT is missing two localised tutorial icons, and a smaller font variant // This code copies the closest variants into their place, and moves other elements accordingly if (header.numEntries == G1ExpectedCount::kSteam) { // Temporarily convert offsets to absolute indexes for (size_t i = 0; i < elements.size(); i++) { if (elements[i].hasFlags(G1ElementFlags::hasZoomSprites)) { elements[i].zoomOffset = static_cast<int16_t>(i - elements[i].zoomOffset); } } elements.resize(G1ExpectedCount::kDisc); // Extra two tutorial images std::copy_n(&elements[3549], header.numEntries - 3549, &elements[3551]); std::copy_n(&elements[3551], 1, &elements[3549]); std::copy_n(&elements[3551], 1, &elements[3550]); // Extra font variant std::copy_n(&elements[1788], 223, &elements[3898]); // Restore relative offsets for (size_t i = 0; i < elements.size(); i++) { if (elements[i].hasFlags(G1ElementFlags::hasZoomSprites)) { elements[i].zoomOffset = static_cast<int16_t>(i - elements[i].zoomOffset); } } } // Adjust memory offsets for (auto& element : elements) { element.offset += (uintptr_t)elementData.get(); } _g1Buffer = std::move(elementData); std::copy(elements.begin(), elements.end(), _g1Elements.begin()); } static int32_t getFontBaseIndex(Font font) { // The Font type currently encodes the index, this may change in the future. return enumValue(font); } static uint32_t getImageIdForCharacter(Font font, uint8_t character) { return ImageIds::characters_medium_normal_space + (character - 32) + getFontBaseIndex(font); } // 0x004949BC static void initialiseCharacterWidths() { struct FontEntry { Font offset; int8_t widthFudge; }; constexpr std::array<FontEntry, 4> fonts = { FontEntry{ Font::medium_normal, -1 }, FontEntry{ Font::medium_bold, -1 }, FontEntry{ Font::small, -1 }, FontEntry{ Font::large, 1 }, }; for (const auto& font : fonts) { // Supported character range is from 32 -> 255 for (uint8_t i = 0; i < 224; ++i) { uint8_t chr = i + 32; auto* element = getG1Element(getImageIdForCharacter(font.offset, chr)); if (element == nullptr) { continue; } auto width = element->width + font.widthFudge; // Characters from 123 to 150 are unused // Unsure why this zeros it out though since a negative width isn't an issue if (chr >= 123 && chr <= 150) { width = 0; } _characterWidths[enumValue(font.offset) / 224][i] = width; } } // Vanilla setup scrolling text related globals here (unused) } void initialise() { initialiseCharacterWidths(); loadDefaultPalette(); auto& drawingEngine = getDrawingEngine(); auto& drawingCtx = drawingEngine.getDrawingContext(); drawingCtx.clearSingle(PaletteIndex::black0); } // 0x004CD406 void invalidateScreen() { invalidateRegion(0, 0, Ui::width(), Ui::height()); } static std::unique_ptr<Gfx::SoftwareDrawingEngine> engine; Gfx::SoftwareDrawingEngine& getDrawingEngine() { if (!engine) { engine = std::make_unique<Gfx::SoftwareDrawingEngine>(); } return *engine; } /** * 0x004C5C69 * * @param left @<ax> * @param top @<bx> * @param right @<dx> * @param bottom @<bp> */ void invalidateRegion(int32_t left, int32_t top, int32_t right, int32_t bottom) { getDrawingEngine().invalidateRegion(left, top, right, bottom); } // 0x004C5CFA void render() { getDrawingEngine().render(); } // 0x004CF63B // TODO: Split this into two functions, one for rendering and one for processing messages. void renderAndUpdate() { if (Ui::isInitialized()) { auto& drawingEngine = Gfx::getDrawingEngine(); // Clear the screen if the scene hasn't been initialised yet, since the game doesn't clear // the screen each frame it relies on overdrawing but with no tile elements or entities loaded // there is nothing to draw. if (!SceneManager::isSceneInitialised()) { auto& ctx = drawingEngine.getDrawingContext(); ctx.clearSingle(PaletteIndex::black0); } drawingEngine.render(); drawingEngine.present(); } if (Input::hasFlag(Input::Flags::rightMousePressed)) { Input::processMessagesMini(); } else { Input::processMessages(); } } void render(Rect rect) { getDrawingEngine().render(rect); } /** * 0x004C5DD5 * rct2: window_draw_all * * @param left @<ax> * @param top @<bx> * @param right @<dx> * @param bottom @<bp> */ void render(int16_t left, int16_t top, int16_t right, int16_t bottom) { render(Rect::fromLTRB(left, top, right, bottom)); } G1Element* getG1Element(uint32_t imageId) { const auto id = getImageIndex(imageId); if (id < _g1Elements.size()) { return &_g1Elements[id]; } return nullptr; } // 0x0046E07B void loadCurrency() { const auto* currencyObject = ObjectManager::get<CurrencyObject>(); if (currencyObject == nullptr) { return; } const auto loadCurrencySymbol = [](const auto font, const auto imageId, const auto dstImageId, int offsetWidth) { const auto* image = getG1Element(imageId); if (image == nullptr) { return; } auto* currencyElement = getG1Element(dstImageId); if (currencyElement == nullptr) { return; } Gfx::setCharacterWidth(font, U'', image->width + offsetWidth); *currencyElement = *image; }; loadCurrencySymbol(Gfx::Font::small, currencyObject->objectIcon, ImageIds::characters_small_currency_sign, -1); loadCurrencySymbol(Gfx::Font::medium_normal, currencyObject->objectIcon + 1, ImageIds::characters_medium_normal_currency_sign, -1); loadCurrencySymbol(Gfx::Font::medium_bold, currencyObject->objectIcon + 2, ImageIds::characters_medium_bold_currency_sign, -1); loadCurrencySymbol(Gfx::Font::large, currencyObject->objectIcon + 3, ImageIds::characters_large_currency_sign, 1); invalidateScreen(); } // 0x00452457 void loadPalette(uint32_t imageIndex, uint8_t modifier) { auto* g1Palette = getG1Element(imageIndex); if (g1Palette == nullptr) { return; } uint8_t* colourData = g1Palette->offset; for (auto i = g1Palette->xOffset; i < g1Palette->width + g1Palette->xOffset; ++i) { _rgbaPalette[i].b = (*colourData++ * modifier) / 256; _rgbaPalette[i].g = (*colourData++ * modifier) / 256; _rgbaPalette[i].r = (*colourData++ * modifier) / 256; } getDrawingEngine().updatePalette(_rgbaPalette.data(), 10, 236); } // 0x004523F4 void loadDefaultPalette() { auto* g1Palette = getG1Element(ImageIds::default_palette); uint8_t* colourData = g1Palette->offset; for (auto i = g1Palette->xOffset; i < g1Palette->width + g1Palette->xOffset; ++i) { _rgbaPalette[i].b = *colourData++; _rgbaPalette[i].g = *colourData++; _rgbaPalette[i].r = *colourData++; } getDrawingEngine().updatePalette(_rgbaPalette.data(), 10, 236); } std::span<const PaletteEntry> getRgbaPalette() { return _rgbaPalette; } // 0x004530F8 ImageExtents getImagesMaxExtent(const ImageId baseImageId, const size_t numImages) { uint8_t bitmap[200][200] = {}; RenderTarget rt = { /*.bits = */ reinterpret_cast<uint8_t*>(bitmap), /*.x = */ -100, /*.y = */ -100, /*.width = */ 200, /*.height = */ 200, /*.pitch = */ 0, /*.zoom_level = */ 0, }; auto& drawingCtx = Gfx::getDrawingEngine().getDrawingContext(); drawingCtx.pushRenderTarget(rt); // Draw all the images on top of the one bitmap for (size_t i = 0; i < numImages; ++i) { drawingCtx.drawImage({ 0, 0 }, baseImageId.withIndexOffset(i)); } drawingCtx.popRenderTarget(); // Explore the bitmap to find the extents of the images drawn int32_t spriteWidth = -1; for (int32_t i = 99; i != 0; --i) { for (int32_t j = 0; j < 200; j++) { if (bitmap[j][100 - i] != 0) { spriteWidth = i; break; } } if (spriteWidth != -1) { break; } for (int32_t j = 0; j < 200; j++) { if (bitmap[j][100 + i] != 0) { spriteWidth = i; break; } } if (spriteWidth != -1) { break; } } spriteWidth++; int32_t spriteHeightNegative = -1; for (int32_t i = 99; i != 0; --i) { for (int32_t j = 0; j < 200; j++) { if (bitmap[100 - i][j] != 0) { spriteHeightNegative = i; break; } } if (spriteHeightNegative != -1) { break; } } spriteHeightNegative++; int32_t spriteHeightPositive = -1; for (int32_t i = 99; i != 0; --i) { for (int32_t j = 0; j < 200; j++) { if (bitmap[100 + i][j] != 0) { spriteHeightPositive = i; break; } } if (spriteHeightPositive != -1) { break; } } spriteHeightPositive++; return ImageExtents{ static_cast<uint8_t>(spriteWidth), static_cast<uint8_t>(spriteHeightNegative), static_cast<uint8_t>(spriteHeightPositive) }; } int16_t getCharacterWidth(Font font, char32_t character) { return _characterWidths[getFontBaseIndex(font) / 224][character - 32]; } void setCharacterWidth(Font font, char32_t character, int16_t width) { _characterWidths[getFontBaseIndex(font) / 224][character - 32] = width; } ImageId getImageForCharacter(Font font, char32_t character) { const auto imageId = getImageIdForCharacter(font, character); return ImageId(imageId); } // 0x00451DCB void movePixelsOnScreen(int16_t dstX, int16_t dstY, int16_t width, int16_t height, int16_t srcX, int16_t srcY) { auto& drawingEngine = getDrawingEngine(); auto& screenRT = drawingEngine.getScreenRT(); drawingEngine.movePixels(screenRT, dstX, dstY, width, height, srcX, srcY); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/Gfx.h ```h #pragma once #include "Font.h" #include "ImageId.h" #include "Types.hpp" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Engine/Ui/Rect.hpp> #include <array> #include <cstdint> #include <optional> #include <span> namespace OpenLoco { using PaletteIndex_t = uint8_t; struct AdvancedColour; enum class ExtColour : uint8_t; } namespace OpenLoco::Gfx { class SoftwareDrawingEngine; } namespace OpenLoco::Gfx { struct RenderTarget; namespace G1ExpectedCount { constexpr uint32_t kDisc = 0x101A; // And GOG constexpr uint32_t kSteam = 0x0F38; constexpr uint32_t kObjects = 0x40000; } #pragma pack(push, 1) struct G1Header { uint32_t numEntries; uint32_t totalSize; }; enum class G1ElementFlags : uint16_t { none = 0U, hasTransparency = 1U << 0, // Image data contains transparent sections (when not set data is plain bmp) unk1 = 1U << 1, // Unknown function not used on any entry isRLECompressed = 1U << 2, // Image data is encoded using CS's form of run length encoding isR8G8B8Palette = 1U << 3, // Image data is a sequence of palette entries R8G8B8 hasZoomSprites = 1U << 4, // Use a different sprite for higher zoom levels noZoomDraw = 1U << 5, // Does not get drawn at higher zoom levels (only zoom 0) duplicatePrevious = 1U << 6, // Duplicates the previous element but with adjusted x/y offsets }; OPENLOCO_ENABLE_ENUM_OPERATORS(G1ElementFlags); struct G1Element32 { uint32_t offset; // 0x00 int16_t width; // 0x04 int16_t height; // 0x06 int16_t xOffset; // 0x08 int16_t yOffset; // 0x0A G1ElementFlags flags; // 0x0C int16_t zoomOffset; // 0x0E }; // A version that can be 64-bit when ready... struct G1Element { uint8_t* offset = nullptr; int16_t width = 0; int16_t height = 0; int16_t xOffset = 0; int16_t yOffset = 0; G1ElementFlags flags = G1ElementFlags::none; int16_t zoomOffset = 0; G1Element() = default; G1Element(const G1Element32& src) : offset(reinterpret_cast<uint8_t*>(static_cast<uintptr_t>(src.offset))) , width(src.width) , height(src.height) , xOffset(src.xOffset) , yOffset(src.yOffset) , flags(src.flags) , zoomOffset(src.zoomOffset) { } constexpr bool hasFlags(G1ElementFlags flagsToTest) const { return (flags & flagsToTest) != G1ElementFlags::none; } }; struct PaletteEntry { uint8_t b; uint8_t g; uint8_t r; uint8_t a; }; #pragma pack(pop) struct ImageExtents { uint8_t width; uint8_t heightNegative; uint8_t heightPositive; }; namespace ImageIdFlags { constexpr uint32_t remap = 1U << 29; constexpr uint32_t translucent = 1U << 30; constexpr uint32_t remap2 = 1U << 31; } void loadG1(); void initialise(); // TODO: Move the recolour functions into Colour.h [[nodiscard]] constexpr uint32_t recolour(uint32_t image) { return ImageIdFlags::remap | image; } [[nodiscard]] constexpr uint32_t recolour(uint32_t image, ExtColour colour) { return ImageIdFlags::remap | (enumValue(colour) << 19) | image; } [[nodiscard]] constexpr uint32_t recolour(uint32_t image, Colour colour) { return recolour(image, Colours::toExt(colour)); } [[nodiscard]] constexpr uint32_t recolour2(uint32_t image, Colour colour1, Colour colour2) { return ImageIdFlags::remap | ImageIdFlags::remap2 | (enumValue(colour1) << 19) | (enumValue(colour2) << 24) | image; } [[nodiscard]] constexpr uint32_t recolour2(uint32_t image, ColourScheme colourScheme) { return recolour2(image, colourScheme.primary, colourScheme.secondary); } [[nodiscard]] constexpr uint32_t recolourTranslucent(uint32_t image, ExtColour colour) { return ImageIdFlags::translucent | (enumValue(colour) << 19) | image; } [[nodiscard]] ImageId applyGhostToImage(uint32_t imageIndex); [[nodiscard]] constexpr uint32_t getImageIndex(uint32_t imageId) { return imageId & 0x7FFFF; } // Invalidates the entire screen. void invalidateScreen(); // Invalidate a region of the screen. void invalidateRegion(int32_t left, int32_t top, int32_t right, int32_t bottom); // Renders all invalidated regions the next frame. void render(); // Renders a region of the screen. void render(Ui::Rect rect); void render(int16_t left, int16_t top, int16_t right, int16_t bottom); // Moves the pixels on screen. void movePixelsOnScreen(int16_t dstX, int16_t dstY, int16_t width, int16_t height, int16_t srcX, int16_t srcY); // Renders all invalidated regions and processes new messages. void renderAndUpdate(); G1Element* getG1Element(uint32_t id); Gfx::SoftwareDrawingEngine& getDrawingEngine(); void loadCurrency(); void loadDefaultPalette(); void loadPalette(uint32_t imageIndex, uint8_t modifier); std::span<const PaletteEntry> getRgbaPalette(); ImageExtents getImagesMaxExtent(const ImageId baseImageId, const size_t numImages); int16_t getCharacterWidth(Font font, char32_t character); void setCharacterWidth(Font font, char32_t character, int16_t width); ImageId getImageForCharacter(Font font, char32_t character); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/ImageId.h ```h #pragma once #include "Colour.h" #include <cassert> namespace OpenLoco { using ImageIndex = uint32_t; /** * Represents a specific image from a catalogue such as G1, object etc. with remap * colours and flags. * * This is currently all stored as a single 32-bit integer, but will allow easy * extension to 64-bits or higher so that more images can be used. */ struct ImageId { // clang-format off static constexpr uint32_t kIndexUndefined = 0b00000000000001111111111111111111; private: static constexpr uint32_t kMaskIndex = 0b00000000000001111111111111111111; static constexpr uint32_t kMaskRemap = 0b00000011111110000000000000000000; static constexpr uint32_t kMaskTranslucent = 0b00000111111110000000000000000000; static constexpr uint32_t kMaskPrimary = 0b00000000111110000000000000000000; static constexpr uint32_t kMaskSecondary = 0b00011111000000000000000000000000; static constexpr uint32_t kMaskNoiseMask = 0b00011100000000000000000000000000; static constexpr uint32_t kFlagPrimary = 0b00100000000000000000000000000000; static constexpr uint32_t kFlagBlend = 0b01000000000000000000000000000000; static constexpr uint32_t kFlagSecondary = 0b10000000000000000000000000000000; static constexpr uint32_t kShiftRemap = 19; static constexpr uint32_t kShiftPrimary = 19; static constexpr uint32_t kShiftTranslucent = 19; static constexpr uint32_t kShiftSecondary = 24; static constexpr uint32_t kShiftNoiseMask = 26; static constexpr uint32_t kValueUndefined = kIndexUndefined; // clang-format on // Noise mask can be used with NONE and PRIMARY // NONE = No remap // BLENDED = No source copy, remap destination only (glass) // PRIMARY | BLENDED = Destination is blended with source (water) // PRIMARY = Remap with palette id (first 32 are colour palettes) // PRIMARY | SECONDARY = Remap with primary and secondary colours static constexpr ImageIndex kImageIndexUndefined = std::numeric_limits<ImageIndex>::max(); uint32_t _index = kImageIndexUndefined; public: [[nodiscard]] static ImageId fromUInt32(uint32_t value) { ImageId result; result._index = value; return result; } ImageId() = default; explicit constexpr ImageId(ImageIndex index) : _index(index == kIndexUndefined ? kImageIndexUndefined : index) { } constexpr ImageId(uint32_t index, ExtColour palette) : ImageId(ImageId(index).withRemap(palette)) { } constexpr ImageId(uint32_t index, Colour primaryColour) : ImageId(ImageId(index).withPrimary(primaryColour)) { } constexpr ImageId(uint32_t index, Colour primaryColour, Colour secondaryColour) : ImageId(ImageId(index).withPrimary(primaryColour).withSecondary(secondaryColour)) { } constexpr ImageId(uint32_t index, ColourScheme scheme) : ImageId(index, scheme.primary, scheme.secondary) { } [[nodiscard]] constexpr uint32_t toUInt32() const { return _index; } [[nodiscard]] constexpr bool hasValue() const { return getIndex() != kImageIndexUndefined; } [[nodiscard]] constexpr bool hasPrimary() const { return _index & kFlagPrimary; } [[nodiscard]] constexpr bool hasSecondary() const { return _index & kFlagSecondary; } [[nodiscard]] constexpr bool hasNoiseMask() const { return !isBlended() && !hasSecondary() && (getNoiseMask() != 0); } [[nodiscard]] constexpr bool isRemap() const { return hasPrimary() && !hasSecondary() && !isBlended(); } [[nodiscard]] constexpr bool isBlended() const { return _index & kFlagBlend; } [[nodiscard]] constexpr ImageIndex getIndex() const { return _index & kMaskIndex; } [[nodiscard]] constexpr ExtColour getTranslucency() const { return static_cast<ExtColour>((_index & kMaskTranslucent) >> kShiftTranslucent); } [[nodiscard]] constexpr ExtColour getRemap() const { return static_cast<ExtColour>((_index & kMaskRemap) >> kShiftRemap); } [[nodiscard]] constexpr Colour getPrimary() const { return static_cast<Colour>((_index & kMaskPrimary) >> kShiftPrimary); } [[nodiscard]] constexpr Colour getSecondary() const { return static_cast<Colour>((_index & kMaskSecondary) >> kShiftSecondary); } [[nodiscard]] constexpr uint8_t getNoiseMask() const { return (_index & kMaskNoiseMask) >> kShiftNoiseMask; } [[nodiscard]] constexpr ImageId withIndex(ImageIndex index) const { ImageId result = *this; result._index &= ~kMaskIndex; result._index |= index; return result; } [[nodiscard]] constexpr ImageId withIndexOffset(int32_t offset) const { ImageId result = *this; result._index += offset; return result; } [[nodiscard]] constexpr ImageId withRemap(ExtColour paletteId) const { ImageId result = *this; assert(enumValue(paletteId) <= 0x7F); // If larger then it eats into noiseMask result._index &= ~(kMaskRemap | kFlagSecondary | kFlagBlend); result._index |= enumValue(paletteId) << kShiftRemap; result._index |= kFlagPrimary; return result; } // Can be used withRemap or withPrimary or with None [[nodiscard]] constexpr ImageId withNoiseMask(uint8_t noise) const { ImageId result = *this; result._index &= ~(kMaskNoiseMask | kFlagSecondary | kFlagBlend); result._index |= noise << kShiftNoiseMask; return result; } [[nodiscard]] constexpr ImageId withPrimary(Colour colour) const { ImageId result = *this; result._index &= ~kMaskPrimary; result._index |= enumValue(colour) << kShiftPrimary; result._index |= kFlagPrimary; return result; } [[nodiscard]] constexpr ImageId withSecondary(Colour colour) const { ImageId result = *this; result._index &= ~kMaskSecondary; result._index |= enumValue(colour) << kShiftSecondary; result._index |= kFlagSecondary; return result; } [[nodiscard]] constexpr ImageId withTranslucency(ExtColour colour) const { ImageId result = *this; result._index &= ~(kMaskPrimary | kMaskSecondary | kFlagSecondary | kFlagPrimary); result._index |= enumValue(colour) << kShiftRemap; result._index |= kFlagBlend; return result; } [[nodiscard]] constexpr ImageId withBlend(ExtColour colour) const { ImageId result = *this; result._index &= ~(kMaskPrimary | kMaskSecondary | kFlagSecondary); result._index |= enumValue(colour) << kShiftRemap; result._index |= kFlagBlend | kFlagPrimary; return result; } }; static_assert(sizeof(ImageId) == 4); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/ImageIds.h ```h #pragma once #include <array> #include <cstdint> #define UNUSED_IMG(x) (x) namespace OpenLoco::ImageIds { constexpr uint32_t null = 0xFFFFFFFF; constexpr uint32_t default_palette = 304; constexpr uint32_t constructionSelectionCornersSlope0 = 322; constexpr uint32_t constructionSelectionCornersSlope1 = 323; constexpr uint32_t constructionSelectionCornersSlope2 = 324; constexpr uint32_t constructionSelectionCornersSlope3 = 325; constexpr uint32_t constructionSelectionCornersSlope4 = 326; constexpr uint32_t constructionSelectionCornersSlope5 = 327; constexpr uint32_t constructionSelectionCornersSlope6 = 328; constexpr uint32_t constructionSelectionCornersSlope7 = 329; constexpr uint32_t constructionSelectionCornersSlope8 = 330; constexpr uint32_t constructionSelectionCornersSlope9 = 331; constexpr uint32_t constructionSelectionCornersSlope10 = 332; constexpr uint32_t constructionSelectionCornersSlope11 = 333; constexpr uint32_t constructionSelectionCornersSlope12 = 334; constexpr uint32_t constructionSelectionCornersSlope13 = 335; constexpr uint32_t constructionSelectionCornersSlope14 = 336; constexpr uint32_t constructionSelectionCornersSlope15 = 337; constexpr uint32_t constructionSelectionCornersSlope16 = 338; constexpr uint32_t constructionSelectionCornersSlope17 = 339; constexpr uint32_t constructionSelectionCornersSlope18 = 340; constexpr uint32_t constructionCatchmentSlope0 = 341; constexpr uint32_t constructionCatchmentSlope1 = 342; constexpr uint32_t constructionCatchmentSlope2 = 343; constexpr uint32_t constructionCatchmentSlope3 = 344; constexpr uint32_t constructionCatchmentSlope4 = 345; constexpr uint32_t constructionCatchmentSlope5 = 346; constexpr uint32_t constructionCatchmentSlope6 = 347; constexpr uint32_t constructionCatchmentSlope7 = 348; constexpr uint32_t constructionCatchmentSlope8 = 349; constexpr uint32_t constructionCatchmentSlope9 = 350; constexpr uint32_t constructionCatchmentSlope10 = 351; constexpr uint32_t constructionCatchmentSlope11 = 352; constexpr uint32_t constructionCatchmentSlope12 = 353; constexpr uint32_t constructionCatchmentSlope13 = 354; constexpr uint32_t constructionCatchmentSlope14 = 355; constexpr uint32_t constructionCatchmentSlope15 = 356; constexpr uint32_t constructionCatchmentSlope16 = 357; constexpr uint32_t constructionCatchmentSlope17 = 358; constexpr uint32_t constructionCatchmentSlope18 = 359; constexpr uint32_t constructionSelectionEdgesSlope0 = 360; constexpr uint32_t constructionSelectionEdgesSlope1 = 361; constexpr uint32_t constructionSelectionEdgesSlope2 = 362; constexpr uint32_t constructionSelectionEdgesSlope3 = 363; constexpr uint32_t constructionSelectionEdgesSlope4 = 364; constexpr uint32_t constructionSelectionEdgesSlope5 = 365; constexpr uint32_t constructionSelectionEdgesSlope6 = 366; constexpr uint32_t constructionSelectionEdgesSlope7 = 367; constexpr uint32_t constructionSelectionEdgesSlope8 = 368; constexpr uint32_t constructionSelectionEdgesSlope9 = 369; constexpr uint32_t constructionSelectionEdgesSlope10 = 370; constexpr uint32_t constructionSelectionEdgesSlope11 = 371; constexpr uint32_t constructionSelectionEdgesSlope12 = 372; constexpr uint32_t constructionSelectionEdgesSlope13 = 373; constexpr uint32_t constructionSelectionEdgesSlope14 = 374; constexpr uint32_t constructionSelectionEdgesSlope15 = 375; constexpr uint32_t constructionSelectionEdgesSlope16 = 376; constexpr uint32_t constructionSelectionEdgesSlope17 = 377; constexpr uint32_t constructionSelectionEdgesSlope18 = 378; constexpr uint32_t gridlinesSlope0 = 379; constexpr uint32_t gridlinesSlope1 = 380; constexpr uint32_t gridlinesSlope2 = 381; constexpr uint32_t gridlinesSlope3 = 382; constexpr uint32_t gridlinesSlope4 = 383; constexpr uint32_t gridlinesSlope5 = 384; constexpr uint32_t gridlinesSlope6 = 385; constexpr uint32_t gridlinesSlope7 = 386; constexpr uint32_t gridlinesSlope8 = 387; constexpr uint32_t gridlinesSlope9 = 388; constexpr uint32_t gridlinesSlope10 = 389; constexpr uint32_t gridlinesSlope11 = 390; constexpr uint32_t gridlinesSlope12 = 391; constexpr uint32_t gridlinesSlope13 = 392; constexpr uint32_t gridlinesSlope14 = 393; constexpr uint32_t gridlinesSlope15 = 394; constexpr uint32_t gridlinesSlope16 = 395; constexpr uint32_t gridlinesSlope17 = 396; constexpr uint32_t gridlinesSlope18 = 397; constexpr uint32_t constructionSelectionQuadsSlope0 = 398; constexpr uint32_t constructionSelectionQuadsSlope1 = 399; constexpr uint32_t constructionSelectionQuadsSlope2 = 400; constexpr uint32_t constructionSelectionQuadsSlope3 = 401; constexpr uint32_t constructionSelectionQuadsSlope4 = 402; constexpr uint32_t constructionSelectionQuadsSlope5 = 403; constexpr uint32_t constructionSelectionQuadsSlope6 = 404; constexpr uint32_t constructionSelectionQuadsSlope7 = 405; constexpr uint32_t constructionSelectionQuadsSlope8 = 406; constexpr uint32_t constructionSelectionQuadsSlope9 = 407; constexpr uint32_t constructionSelectionQuadsSlope10 = 408; constexpr uint32_t constructionSelectionQuadsSlope11 = 409; constexpr uint32_t constructionSelectionQuadsSlope12 = 410; constexpr uint32_t constructionSelectionQuadsSlope13 = 411; constexpr uint32_t constructionSelectionQuadsSlope14 = 412; constexpr uint32_t constructionSelectionQuadsSlope15 = 413; constexpr uint32_t constructionSelectionQuadsSlope16 = 414; constexpr uint32_t constructionSelectionQuadsSlope17 = 415; constexpr uint32_t constructionSelectionQuadsSlope18 = 416; constexpr uint32_t paletteMapUnk21 = 417; constexpr uint32_t paletteMapUnk22 = 418; constexpr uint32_t paletteMapUnk23 = 419; constexpr uint32_t paletteMapUnk24 = 420; constexpr uint32_t paletteMapUnk25 = 421; constexpr uint32_t paletteMapUnk26 = 423; constexpr uint32_t paletteMapUnk27 = 424; constexpr uint32_t paletteMapUnk28 = 425; constexpr uint32_t paletteMapUnk29 = 426; constexpr uint32_t paletteMapUnk2A = 427; constexpr uint32_t paletteMapUnk2B = 422; constexpr uint32_t construction_arrow_north = 428; constexpr uint32_t construction_arrow_east = 429; constexpr uint32_t construction_arrow_south = 430; constexpr uint32_t construction_arrow_west = 431; constexpr uint32_t construction_arrow_north2 = 432; constexpr uint32_t construction_arrow_east2 = 433; constexpr uint32_t construction_arrow_south2 = 434; constexpr uint32_t construction_arrow_west2 = 435; constexpr uint32_t construction_arrow_north3 = 436; constexpr uint32_t construction_arrow_east3 = 437; constexpr uint32_t construction_arrow_south3 = 438; constexpr uint32_t construction_arrow_west3 = 439; constexpr uint32_t construction_arrow_north_east = 440; constexpr uint32_t construction_arrow_south_east = 441; constexpr uint32_t construction_arrow_south_west = 442; constexpr uint32_t construction_arrow_north_west = 443; constexpr uint32_t blank_tile = 448; constexpr uint32_t one_way_direction_arrow_north = 449; constexpr uint32_t one_way_direction_arrow_north_east = 450; constexpr uint32_t one_way_direction_arrow_east = 451; constexpr uint32_t one_way_direction_arrow_south_east = 452; constexpr uint32_t one_way_direction_arrow_south = 453; constexpr uint32_t one_way_direction_arrow_south_west = 454; constexpr uint32_t one_way_direction_arrow_west = 455; constexpr uint32_t one_way_direction_arrow_north_west = 456; constexpr uint32_t characters_medium_normal_space = 1116; constexpr uint32_t characters_medium_normal_exclamation_mark = 1117; constexpr uint32_t characters_medium_normal_double_quoatation_mark = 1118; constexpr uint32_t characters_medium_normal_pound_sign = 1119; constexpr uint32_t characters_medium_normal_dollar_sign = 1120; constexpr uint32_t characters_medium_normal_percent_sign = 1121; constexpr uint32_t characters_medium_normal_ampersand = 1122; constexpr uint32_t characters_medium_normal_apostrophe = 1123; constexpr uint32_t characters_medium_normal_left_parenthesis = 1124; constexpr uint32_t characters_medium_normal_right_parenthesis = 1125; constexpr uint32_t characters_medium_normal_asterisk = 1126; constexpr uint32_t characters_medium_normal_plus_sign = 1127; constexpr uint32_t characters_medium_normal_comma = 1128; constexpr uint32_t characters_medium_normal_minus_sign = 1129; constexpr uint32_t characters_medium_normal_period = 1130; constexpr uint32_t characters_medium_normal_slash = 1131; constexpr uint32_t characters_medium_normal_digit_0 = 1132; constexpr uint32_t characters_medium_normal_digit_1 = 1133; constexpr uint32_t characters_medium_normal_digit_2 = 1134; constexpr uint32_t characters_medium_normal_digit_3 = 1135; constexpr uint32_t characters_medium_normal_digit_4 = 1136; constexpr uint32_t characters_medium_normal_digit_5 = 1137; constexpr uint32_t characters_medium_normal_digit_6 = 1138; constexpr uint32_t characters_medium_normal_digit_7 = 1139; constexpr uint32_t characters_medium_normal_digit_8 = 1140; constexpr uint32_t characters_medium_normal_digit_9 = 1141; constexpr uint32_t characters_medium_normal_colon = 1142; constexpr uint32_t characters_medium_normal_semicolon = 1143; constexpr uint32_t characters_medium_normal_less_than_sign = 1144; constexpr uint32_t characters_medium_normal_equal_sign = 1145; constexpr uint32_t characters_medium_normal_greater_than_sign = 1146; constexpr uint32_t characters_medium_normal_question_mark = 1147; constexpr uint32_t characters_medium_normal_at_sign = 1148; constexpr uint32_t characters_medium_normal_capital_a = 1149; constexpr uint32_t characters_medium_normal_capital_b = 1150; constexpr uint32_t characters_medium_normal_capital_c = 1151; constexpr uint32_t characters_medium_normal_capital_d = 1152; constexpr uint32_t characters_medium_normal_capital_e = 1153; constexpr uint32_t characters_medium_normal_capital_f = 1154; constexpr uint32_t characters_medium_normal_capital_g = 1155; constexpr uint32_t characters_medium_normal_capital_h = 1156; constexpr uint32_t characters_medium_normal_capital_i = 1157; constexpr uint32_t characters_medium_normal_capital_j = 1158; constexpr uint32_t characters_medium_normal_capital_k = 1159; constexpr uint32_t characters_medium_normal_capital_l = 1160; constexpr uint32_t characters_medium_normal_capital_m = 1161; constexpr uint32_t characters_medium_normal_capital_n = 1162; constexpr uint32_t characters_medium_normal_capital_o = 1163; constexpr uint32_t characters_medium_normal_capital_p = 1164; constexpr uint32_t characters_medium_normal_capital_q = 1165; constexpr uint32_t characters_medium_normal_capital_r = 1166; constexpr uint32_t characters_medium_normal_capital_s = 1167; constexpr uint32_t characters_medium_normal_capital_t = 1168; constexpr uint32_t characters_medium_normal_capital_u = 1169; constexpr uint32_t characters_medium_normal_capital_v = 1170; constexpr uint32_t characters_medium_normal_capital_w = 1171; constexpr uint32_t characters_medium_normal_capital_x = 1172; constexpr uint32_t characters_medium_normal_capital_y = 1173; constexpr uint32_t characters_medium_normal_capital_z = 1174; constexpr uint32_t characters_medium_normal_left_square_bracket = 1175; constexpr uint32_t characters_medium_normal_backslash = 1176; constexpr uint32_t characters_medium_normal_right_square_bracket = 1177; constexpr uint32_t characters_medium_normal_circumflex = 1178; constexpr uint32_t characters_medium_normal_underscore = 1179; constexpr uint32_t characters_medium_normal_grave = 1180; constexpr uint32_t characters_medium_normal_small_a = 1181; constexpr uint32_t characters_medium_normal_small_b = 1182; constexpr uint32_t characters_medium_normal_small_c = 1183; constexpr uint32_t characters_medium_normal_small_d = 1184; constexpr uint32_t characters_medium_normal_small_e = 1185; constexpr uint32_t characters_medium_normal_small_f = 1186; constexpr uint32_t characters_medium_normal_small_g = 1187; constexpr uint32_t characters_medium_normal_small_h = 1188; constexpr uint32_t characters_medium_normal_small_i = 1189; constexpr uint32_t characters_medium_normal_small_j = 1190; constexpr uint32_t characters_medium_normal_small_k = 1191; constexpr uint32_t characters_medium_normal_small_l = 1192; constexpr uint32_t characters_medium_normal_small_m = 1193; constexpr uint32_t characters_medium_normal_small_n = 1194; constexpr uint32_t characters_medium_normal_small_o = 1195; constexpr uint32_t characters_medium_normal_small_p = 1196; constexpr uint32_t characters_medium_normal_small_q = 1197; constexpr uint32_t characters_medium_normal_small_r = 1198; constexpr uint32_t characters_medium_normal_small_s = 1199; constexpr uint32_t characters_medium_normal_small_t = 1200; constexpr uint32_t characters_medium_normal_small_u = 1201; constexpr uint32_t characters_medium_normal_small_v = 1202; constexpr uint32_t characters_medium_normal_small_w = 1203; constexpr uint32_t characters_medium_normal_small_x = 1204; constexpr uint32_t characters_medium_normal_small_y = 1205; constexpr uint32_t characters_medium_normal_small_z = 1206; constexpr uint32_t characters_medium_normal_left_brace = 1207; constexpr uint32_t characters_medium_normal_verticle_bar = 1208; constexpr uint32_t characters_medium_normal_right_brace = 1209; constexpr uint32_t characters_medium_normal_tilde = 1210; constexpr uint32_t characters_medium_normal_delete = 1211; constexpr uint32_t characters_medium_normal_128 = 1212; constexpr uint32_t characters_medium_normal_129 = 1213; constexpr uint32_t characters_medium_normal_130 = 1214; constexpr uint32_t characters_medium_normal_131 = 1215; constexpr uint32_t characters_medium_normal_132 = 1216; constexpr uint32_t characters_medium_normal_133 = 1217; constexpr uint32_t characters_medium_normal_134 = 1218; constexpr uint32_t characters_medium_normal_135 = 1219; constexpr uint32_t characters_medium_normal_136 = 1220; constexpr uint32_t characters_medium_normal_137 = 1221; constexpr uint32_t characters_medium_normal_138 = 1222; constexpr uint32_t characters_medium_normal_139 = 1223; constexpr uint32_t characters_medium_normal_140 = 1224; constexpr uint32_t characters_medium_normal_141 = 1225; constexpr uint32_t characters_medium_normal_142 = 1226; constexpr uint32_t characters_medium_normal_143 = 1227; constexpr uint32_t characters_medium_normal_144 = 1228; constexpr uint32_t characters_medium_normal_145 = 1229; constexpr uint32_t characters_medium_normal_146 = 1230; constexpr uint32_t characters_medium_normal_147 = 1231; constexpr uint32_t characters_medium_normal_148 = 1232; constexpr uint32_t characters_medium_normal_149 = 1233; constexpr uint32_t characters_medium_normal_150 = 1234; constexpr uint32_t characters_medium_normal_151 = 1235; constexpr uint32_t characters_medium_normal_152 = 1236; constexpr uint32_t characters_medium_normal_153 = 1237; constexpr uint32_t characters_medium_normal_154 = 1238; constexpr uint32_t characters_medium_normal_155 = 1239; constexpr uint32_t characters_medium_normal_156 = 1240; constexpr uint32_t characters_medium_normal_157 = 1241; constexpr uint32_t characters_medium_normal_158 = 1242; constexpr uint32_t characters_medium_normal_a_ogonek = 1243; constexpr uint32_t characters_medium_normal_up_arrow = 1244; constexpr uint32_t characters_medium_normal_inverted_exclamation_mark = 1245; constexpr uint32_t characters_medium_normal_capital_c_acute = 1246; constexpr uint32_t characters_medium_normal_currency_sign = 1247; constexpr uint32_t characters_medium_normal_general_currency_sign = 1248; constexpr uint32_t characters_medium_normal_yen_sign = 1249; constexpr uint32_t characters_medium_normal_capital_e_ogonek = 1250; constexpr uint32_t characters_medium_normal_capital_l_stroke = 1251; constexpr uint32_t characters_medium_normal_168 = 1252; constexpr uint32_t characters_medium_normal_copyright_sign = 1253; constexpr uint32_t characters_medium_normal_down_arrow = 1254; constexpr uint32_t characters_medium_normal_left_double_angle_quote = 1255; constexpr uint32_t characters_medium_normal_tick_sign = 1256; constexpr uint32_t characters_medium_normal_cross_sign = 1257; constexpr uint32_t characters_medium_normal_174 = 1258; constexpr uint32_t characters_medium_normal_right_arrow = 1259; constexpr uint32_t characters_medium_normal_degree_sign = 1260; constexpr uint32_t characters_medium_normal_railway_sign = 1261; constexpr uint32_t characters_medium_normal_superscript_2 = 1262; constexpr uint32_t characters_medium_normal_superscript_3 = 1263; constexpr uint32_t characters_medium_normal_double_quote_open = 1264; constexpr uint32_t characters_medium_normal_micro_sign = 1265; constexpr uint32_t characters_medium_normal_road_sign = 1266; constexpr uint32_t characters_medium_normal_air_sign = 1267; constexpr uint32_t characters_medium_normal_water_sign = 1268; constexpr uint32_t characters_medium_normal_superscript_1 = 1269; constexpr uint32_t characters_medium_normal_masculine_ordinal_indicator = 1270; constexpr uint32_t characters_medium_normal_right_double_angle_quote = 1271; constexpr uint32_t characters_medium_normal_small_up_arrow = 1272; constexpr uint32_t characters_medium_normal_small_down_arrow = 1273; constexpr uint32_t characters_medium_normal_fraction_3_4 = 1274; constexpr uint32_t characters_medium_normal_inverted_question_mark = 1275; constexpr uint32_t characters_medium_normal_capital_a_grave = 1276; constexpr uint32_t characters_medium_normal_capital_a_acute = 1277; constexpr uint32_t characters_medium_normal_capital_a_circumflex = 1278; constexpr uint32_t characters_medium_normal_capital_a_tilde = 1279; constexpr uint32_t characters_medium_normal_capital_a_umlaut = 1280; constexpr uint32_t characters_medium_normal_capital_a_ring = 1281; constexpr uint32_t characters_medium_normal_capital_n_acute = 1282; constexpr uint32_t characters_medium_normal_capital_c_cedilla = 1283; constexpr uint32_t characters_medium_normal_capital_e_grave = 1284; constexpr uint32_t characters_medium_normal_capital_e_acute = 1285; constexpr uint32_t characters_medium_normal_capital_e_circumflex = 1286; constexpr uint32_t characters_medium_normal_capital_e_umlaut = 1287; constexpr uint32_t characters_medium_normal_capital_i_grave = 1288; constexpr uint32_t characters_medium_normal_capital_i_acute = 1289; constexpr uint32_t characters_medium_normal_capital_i_circumflex = 1290; constexpr uint32_t characters_medium_normal_capital_i_umlaut = 1291; constexpr uint32_t characters_medium_normal_capital_s_acute = 1292; constexpr uint32_t characters_medium_normal_capital_n_tilde = 1293; constexpr uint32_t characters_medium_normal_capital_o_grave = 1294; constexpr uint32_t characters_medium_normal_capital_o_acute = 1295; constexpr uint32_t characters_medium_normal_capital_o_circumflex = 1296; constexpr uint32_t characters_medium_normal_capital_o_tilde = 1297; constexpr uint32_t characters_medium_normal_capital_o_umlaut = 1298; constexpr uint32_t characters_medium_normal_capital_z_acute = 1299; constexpr uint32_t characters_medium_normal_capital_z_dot = 1300; constexpr uint32_t characters_medium_normal_capital_u_grave = 1301; constexpr uint32_t characters_medium_normal_capital_u_acute = 1302; constexpr uint32_t characters_medium_normal_capital_u_circumflex = 1303; constexpr uint32_t characters_medium_normal_capital_u_umlaut = 1304; constexpr uint32_t characters_medium_normal_small_a_ogonek = 1305; constexpr uint32_t characters_medium_normal_small_c_acute = 1306; constexpr uint32_t characters_medium_normal_small_s_sharp = 1307; constexpr uint32_t characters_medium_normal_small_a_grave = 1308; constexpr uint32_t characters_medium_normal_small_a_acute = 1309; constexpr uint32_t characters_medium_normal_small_a_circumflex = 1310; constexpr uint32_t characters_medium_normal_small_a_tilde = 1311; constexpr uint32_t characters_medium_normal_small_a_umlaut = 1312; constexpr uint32_t characters_medium_normal_small_a_ring = 1313; constexpr uint32_t characters_medium_normal_small_e_ogonek = 1314; constexpr uint32_t characters_medium_normal_small_c_cedilla = 1315; constexpr uint32_t characters_medium_normal_small_e_grave = 1316; constexpr uint32_t characters_medium_normal_small_e_acute = 1317; constexpr uint32_t characters_medium_normal_small_e_circumflex = 1318; constexpr uint32_t characters_medium_normal_small_e_umlaut = 1319; constexpr uint32_t characters_medium_normal_small_i_grave = 1320; constexpr uint32_t characters_medium_normal_small_i_acute = 1321; constexpr uint32_t characters_medium_normal_small_i_circumflex = 1322; constexpr uint32_t characters_medium_normal_small_i_umlaut = 1323; constexpr uint32_t characters_medium_normal_small_n_acute = 1324; constexpr uint32_t characters_medium_normal_small_n_tilde = 1325; constexpr uint32_t characters_medium_normal_small_o_grave = 1326; constexpr uint32_t characters_medium_normal_small_o_acute = 1327; constexpr uint32_t characters_medium_normal_small_o_circumflex = 1328; constexpr uint32_t characters_medium_normal_small_o_tilde = 1329; constexpr uint32_t characters_medium_normal_small_o_umlaut = 1330; constexpr uint32_t characters_medium_normal_small_l_stroke = 1331; constexpr uint32_t characters_medium_normal_small_s_acute = 1332; constexpr uint32_t characters_medium_normal_small_u_grave = 1333; constexpr uint32_t characters_medium_normal_small_u_acute = 1334; constexpr uint32_t characters_medium_normal_small_u_circumflex = 1335; constexpr uint32_t characters_medium_normal_small_u_umlaut = 1336; constexpr uint32_t characters_medium_normal_small_z_dot = 1337; constexpr uint32_t characters_medium_normal_small_z_acute = 1338; constexpr uint32_t characters_medium_normal_small_255 = 1339; constexpr uint32_t characters_medium_bold_space = 1340; constexpr uint32_t characters_medium_bold_exclamation_mark = 1341; constexpr uint32_t characters_medium_bold_double_quoatation_mark = 1342; constexpr uint32_t characters_medium_bold_pound_sign = 1343; constexpr uint32_t characters_medium_bold_dollar_sign = 1344; constexpr uint32_t characters_medium_bold_percent_sign = 1345; constexpr uint32_t characters_medium_bold_ampersand = 1346; constexpr uint32_t characters_medium_bold_apostrophe = 1347; constexpr uint32_t characters_medium_bold_left_parenthesis = 1348; constexpr uint32_t characters_medium_bold_right_parenthesis = 1349; constexpr uint32_t characters_medium_bold_asterisk = 1350; constexpr uint32_t characters_medium_bold_plus_sign = 1351; constexpr uint32_t characters_medium_bold_comma = 1352; constexpr uint32_t characters_medium_bold_minus_sign = 1353; constexpr uint32_t characters_medium_bold_period = 1354; constexpr uint32_t characters_medium_bold_slash = 1355; constexpr uint32_t characters_medium_bold_digit_0 = 1356; constexpr uint32_t characters_medium_bold_digit_1 = 1357; constexpr uint32_t characters_medium_bold_digit_2 = 1358; constexpr uint32_t characters_medium_bold_digit_3 = 1359; constexpr uint32_t characters_medium_bold_digit_4 = 1360; constexpr uint32_t characters_medium_bold_digit_5 = 1361; constexpr uint32_t characters_medium_bold_digit_6 = 1362; constexpr uint32_t characters_medium_bold_digit_7 = 1363; constexpr uint32_t characters_medium_bold_digit_8 = 1364; constexpr uint32_t characters_medium_bold_digit_9 = 1365; constexpr uint32_t characters_medium_bold_colon = 1366; constexpr uint32_t characters_medium_bold_semicolon = 1367; constexpr uint32_t characters_medium_bold_less_than_sign = 1368; constexpr uint32_t characters_medium_bold_equal_sign = 1369; constexpr uint32_t characters_medium_bold_greater_than_sign = 1370; constexpr uint32_t characters_medium_bold_question_mark = 1371; constexpr uint32_t characters_medium_bold_at_sign = 1372; constexpr uint32_t characters_medium_bold_capital_a = 1373; constexpr uint32_t characters_medium_bold_capital_b = 1374; constexpr uint32_t characters_medium_bold_capital_c = 1375; constexpr uint32_t characters_medium_bold_capital_d = 1376; constexpr uint32_t characters_medium_bold_capital_e = 1377; constexpr uint32_t characters_medium_bold_capital_f = 1378; constexpr uint32_t characters_medium_bold_capital_g = 1379; constexpr uint32_t characters_medium_bold_capital_h = 1380; constexpr uint32_t characters_medium_bold_capital_i = 1381; constexpr uint32_t characters_medium_bold_capital_j = 1382; constexpr uint32_t characters_medium_bold_capital_k = 1383; constexpr uint32_t characters_medium_bold_capital_l = 1384; constexpr uint32_t characters_medium_bold_capital_m = 1385; constexpr uint32_t characters_medium_bold_capital_n = 1386; constexpr uint32_t characters_medium_bold_capital_o = 1387; constexpr uint32_t characters_medium_bold_capital_p = 1388; constexpr uint32_t characters_medium_bold_capital_q = 1389; constexpr uint32_t characters_medium_bold_capital_r = 1390; constexpr uint32_t characters_medium_bold_capital_s = 1391; constexpr uint32_t characters_medium_bold_capital_t = 1392; constexpr uint32_t characters_medium_bold_capital_u = 1393; constexpr uint32_t characters_medium_bold_capital_v = 1394; constexpr uint32_t characters_medium_bold_capital_w = 1395; constexpr uint32_t characters_medium_bold_capital_x = 1396; constexpr uint32_t characters_medium_bold_capital_y = 1397; constexpr uint32_t characters_medium_bold_capital_z = 1398; constexpr uint32_t characters_medium_bold_left_square_bracket = 1399; constexpr uint32_t characters_medium_bold_backslash = 1400; constexpr uint32_t characters_medium_bold_right_square_bracket = 1401; constexpr uint32_t characters_medium_bold_circumflex = 1402; constexpr uint32_t characters_medium_bold_underscore = 1403; constexpr uint32_t characters_medium_bold_grave = 1404; constexpr uint32_t characters_medium_bold_small_a = 1405; constexpr uint32_t characters_medium_bold_small_b = 1406; constexpr uint32_t characters_medium_bold_small_c = 1407; constexpr uint32_t characters_medium_bold_small_d = 1408; constexpr uint32_t characters_medium_bold_small_e = 1409; constexpr uint32_t characters_medium_bold_small_f = 1410; constexpr uint32_t characters_medium_bold_small_g = 1411; constexpr uint32_t characters_medium_bold_small_h = 1412; constexpr uint32_t characters_medium_bold_small_i = 1413; constexpr uint32_t characters_medium_bold_small_j = 1414; constexpr uint32_t characters_medium_bold_small_k = 1415; constexpr uint32_t characters_medium_bold_small_l = 1416; constexpr uint32_t characters_medium_bold_small_m = 1417; constexpr uint32_t characters_medium_bold_small_n = 1418; constexpr uint32_t characters_medium_bold_small_o = 1419; constexpr uint32_t characters_medium_bold_small_p = 1420; constexpr uint32_t characters_medium_bold_small_q = 1421; constexpr uint32_t characters_medium_bold_small_r = 1422; constexpr uint32_t characters_medium_bold_small_s = 1423; constexpr uint32_t characters_medium_bold_small_t = 1424; constexpr uint32_t characters_medium_bold_small_u = 1425; constexpr uint32_t characters_medium_bold_small_v = 1426; constexpr uint32_t characters_medium_bold_small_w = 1427; constexpr uint32_t characters_medium_bold_small_x = 1428; constexpr uint32_t characters_medium_bold_small_y = 1429; constexpr uint32_t characters_medium_bold_small_z = 1430; constexpr uint32_t characters_medium_bold_left_brace = 1431; constexpr uint32_t characters_medium_bold_verticle_bar = 1432; constexpr uint32_t characters_medium_bold_right_brace = 1433; constexpr uint32_t characters_medium_bold_tilde = 1434; constexpr uint32_t characters_medium_bold_delete = 1435; constexpr uint32_t characters_medium_bold_128 = 1436; constexpr uint32_t characters_medium_bold_129 = 1437; constexpr uint32_t characters_medium_bold_130 = 1438; constexpr uint32_t characters_medium_bold_131 = 1439; constexpr uint32_t characters_medium_bold_132 = 1440; constexpr uint32_t characters_medium_bold_133 = 1441; constexpr uint32_t characters_medium_bold_134 = 1442; constexpr uint32_t characters_medium_bold_135 = 1443; constexpr uint32_t characters_medium_bold_136 = 1444; constexpr uint32_t characters_medium_bold_137 = 1445; constexpr uint32_t characters_medium_bold_138 = 1446; constexpr uint32_t characters_medium_bold_139 = 1447; constexpr uint32_t characters_medium_bold_140 = 1448; constexpr uint32_t characters_medium_bold_141 = 1449; constexpr uint32_t characters_medium_bold_142 = 1450; constexpr uint32_t characters_medium_bold_143 = 1451; constexpr uint32_t characters_medium_bold_144 = 1452; constexpr uint32_t characters_medium_bold_145 = 1453; constexpr uint32_t characters_medium_bold_146 = 1454; constexpr uint32_t characters_medium_bold_147 = 1455; constexpr uint32_t characters_medium_bold_148 = 1456; constexpr uint32_t characters_medium_bold_149 = 1457; constexpr uint32_t characters_medium_bold_150 = 1458; constexpr uint32_t characters_medium_bold_151 = 1459; constexpr uint32_t characters_medium_bold_152 = 1460; constexpr uint32_t characters_medium_bold_153 = 1461; constexpr uint32_t characters_medium_bold_154 = 1462; constexpr uint32_t characters_medium_bold_155 = 1463; constexpr uint32_t characters_medium_bold_156 = 1464; constexpr uint32_t characters_medium_bold_157 = 1465; constexpr uint32_t characters_medium_bold_158 = 1466; constexpr uint32_t characters_medium_bold_a_ogonek = 1467; constexpr uint32_t characters_medium_bold_up_arrow = 1468; constexpr uint32_t characters_medium_bold_inverted_exclamation_mark = 1469; constexpr uint32_t characters_medium_bold_capital_c_acute = 1470; constexpr uint32_t characters_medium_bold_currency_sign = 1471; constexpr uint32_t characters_medium_bold_general_currency_sign = 1472; constexpr uint32_t characters_medium_bold_yen_sign = 1473; constexpr uint32_t characters_medium_bold_capital_e_ogonek = 1474; constexpr uint32_t characters_medium_bold_capital_l_stroke = 1475; constexpr uint32_t characters_medium_bold_168 = 1476; constexpr uint32_t characters_medium_bold_copyright_sign = 1477; constexpr uint32_t characters_medium_bold_down_arrow = 1478; constexpr uint32_t characters_medium_bold_left_double_angle_quote = 1479; constexpr uint32_t characters_medium_bold_tick_sign = 1480; constexpr uint32_t characters_medium_bold_cross_sign = 1481; constexpr uint32_t characters_medium_bold_174 = 1482; constexpr uint32_t characters_medium_bold_right_arrow = 1483; constexpr uint32_t characters_medium_bold_degree_sign = 1484; constexpr uint32_t characters_medium_bold_railway_sign = 1485; constexpr uint32_t characters_medium_bold_superscript_2 = 1486; constexpr uint32_t characters_medium_bold_superscript_3 = 1487; constexpr uint32_t characters_medium_bold_double_quote_open = 1488; constexpr uint32_t characters_medium_bold_micro_sign = 1489; constexpr uint32_t characters_medium_bold_road_sign = 1490; constexpr uint32_t characters_medium_bold_air_sign = 1491; constexpr uint32_t characters_medium_bold_water_sign = 1492; constexpr uint32_t characters_medium_bold_superscript_1 = 1493; constexpr uint32_t characters_medium_bold_masculine_ordinal_indicator = 1494; constexpr uint32_t characters_medium_bold_right_double_angle_quote = 1495; constexpr uint32_t characters_medium_bold_small_up_arrow = 1496; constexpr uint32_t characters_medium_bold_small_down_arrow = 1497; constexpr uint32_t characters_medium_bold_fraction_3_4 = 1498; constexpr uint32_t characters_medium_bold_inverted_question_mark = 1499; constexpr uint32_t characters_medium_bold_capital_a_grave = 1500; constexpr uint32_t characters_medium_bold_capital_a_acute = 1501; constexpr uint32_t characters_medium_bold_capital_a_circumflex = 1502; constexpr uint32_t characters_medium_bold_capital_a_tilde = 1503; constexpr uint32_t characters_medium_bold_capital_a_umlaut = 1504; constexpr uint32_t characters_medium_bold_capital_a_ring = 1505; constexpr uint32_t characters_medium_bold_capital_n_acute = 1506; constexpr uint32_t characters_medium_bold_capital_c_cedilla = 1507; constexpr uint32_t characters_medium_bold_capital_e_grave = 1508; constexpr uint32_t characters_medium_bold_capital_e_acute = 1509; constexpr uint32_t characters_medium_bold_capital_e_circumflex = 1510; constexpr uint32_t characters_medium_bold_capital_e_umlaut = 1511; constexpr uint32_t characters_medium_bold_capital_i_grave = 1512; constexpr uint32_t characters_medium_bold_capital_i_acute = 1513; constexpr uint32_t characters_medium_bold_capital_i_circumflex = 1514; constexpr uint32_t characters_medium_bold_capital_i_umlaut = 1515; constexpr uint32_t characters_medium_bold_capital_s_acute = 1516; constexpr uint32_t characters_medium_bold_capital_n_tilde = 1517; constexpr uint32_t characters_medium_bold_capital_o_grave = 1518; constexpr uint32_t characters_medium_bold_capital_o_acute = 1519; constexpr uint32_t characters_medium_bold_capital_o_circumflex = 1520; constexpr uint32_t characters_medium_bold_capital_o_tilde = 1521; constexpr uint32_t characters_medium_bold_capital_o_umlaut = 1522; constexpr uint32_t characters_medium_bold_capital_z_acute = 1523; constexpr uint32_t characters_medium_bold_capital_z_dot = 1524; constexpr uint32_t characters_medium_bold_capital_u_grave = 1525; constexpr uint32_t characters_medium_bold_capital_u_acute = 1526; constexpr uint32_t characters_medium_bold_capital_u_circumflex = 1527; constexpr uint32_t characters_medium_bold_capital_u_umlaut = 1528; constexpr uint32_t characters_medium_bold_small_a_ogonek = 1529; constexpr uint32_t characters_medium_bold_small_c_acute = 1530; constexpr uint32_t characters_medium_bold_small_s_sharp = 1531; constexpr uint32_t characters_medium_bold_small_a_grave = 1532; constexpr uint32_t characters_medium_bold_small_a_acute = 1533; constexpr uint32_t characters_medium_bold_small_a_circumflex = 1534; constexpr uint32_t characters_medium_bold_small_a_tilde = 1535; constexpr uint32_t characters_medium_bold_small_a_umlaut = 1536; constexpr uint32_t characters_medium_bold_small_a_ring = 1537; constexpr uint32_t characters_medium_bold_small_e_ogonek = 1538; constexpr uint32_t characters_medium_bold_small_c_cedilla = 1539; constexpr uint32_t characters_medium_bold_small_e_grave = 1540; constexpr uint32_t characters_medium_bold_small_e_acute = 1541; constexpr uint32_t characters_medium_bold_small_e_circumflex = 1542; constexpr uint32_t characters_medium_bold_small_e_umlaut = 1543; constexpr uint32_t characters_medium_bold_small_i_grave = 1544; constexpr uint32_t characters_medium_bold_small_i_acute = 1545; constexpr uint32_t characters_medium_bold_small_i_circumflex = 1546; constexpr uint32_t characters_medium_bold_small_i_umlaut = 1547; constexpr uint32_t characters_medium_bold_small_n_acute = 1548; constexpr uint32_t characters_medium_bold_small_n_tilde = 1549; constexpr uint32_t characters_medium_bold_small_o_grave = 1550; constexpr uint32_t characters_medium_bold_small_o_acute = 1551; constexpr uint32_t characters_medium_bold_small_o_circumflex = 1552; constexpr uint32_t characters_medium_bold_small_o_tilde = 1553; constexpr uint32_t characters_medium_bold_small_o_umlaut = 1554; constexpr uint32_t characters_medium_bold_small_l_stroke = 1555; constexpr uint32_t characters_medium_bold_small_s_acute = 1556; constexpr uint32_t characters_medium_bold_small_u_grave = 1557; constexpr uint32_t characters_medium_bold_small_u_acute = 1558; constexpr uint32_t characters_medium_bold_small_u_circumflex = 1559; constexpr uint32_t characters_medium_bold_small_u_umlaut = 1560; constexpr uint32_t characters_medium_bold_small_z_dot = 1561; constexpr uint32_t characters_medium_bold_small_z_acute = 1562; constexpr uint32_t characters_medium_bold_small_255 = 1563; constexpr uint32_t characters_small_space = 1564; constexpr uint32_t characters_small_exclamation_mark = 1565; constexpr uint32_t characters_small_double_quoatation_mark = 1566; constexpr uint32_t characters_small_pound_sign = 1567; constexpr uint32_t characters_small_dollar_sign = 1568; constexpr uint32_t characters_small_percent_sign = 1569; constexpr uint32_t characters_small_ampersand = 1570; constexpr uint32_t characters_small_apostrophe = 1571; constexpr uint32_t characters_small_left_parenthesis = 1572; constexpr uint32_t characters_small_right_parenthesis = 1573; constexpr uint32_t characters_small_asterisk = 1574; constexpr uint32_t characters_small_plus_sign = 1575; constexpr uint32_t characters_small_comma = 1576; constexpr uint32_t characters_small_minus_sign = 1577; constexpr uint32_t characters_small_period = 1578; constexpr uint32_t characters_small_slash = 1579; constexpr uint32_t characters_small_digit_0 = 1580; constexpr uint32_t characters_small_digit_1 = 1581; constexpr uint32_t characters_small_digit_2 = 1582; constexpr uint32_t characters_small_digit_3 = 1583; constexpr uint32_t characters_small_digit_4 = 1584; constexpr uint32_t characters_small_digit_5 = 1585; constexpr uint32_t characters_small_digit_6 = 1586; constexpr uint32_t characters_small_digit_7 = 1587; constexpr uint32_t characters_small_digit_8 = 1588; constexpr uint32_t characters_small_digit_9 = 1589; constexpr uint32_t characters_small_colon = 1590; constexpr uint32_t characters_small_semicolon = 1591; constexpr uint32_t characters_small_less_than_sign = 1592; constexpr uint32_t characters_small_equal_sign = 1593; constexpr uint32_t characters_small_greater_than_sign = 1594; constexpr uint32_t characters_small_question_mark = 1595; constexpr uint32_t characters_small_at_sign = 1596; constexpr uint32_t characters_small_capital_a = 1597; constexpr uint32_t characters_small_capital_b = 1598; constexpr uint32_t characters_small_capital_c = 1599; constexpr uint32_t characters_small_capital_d = 1600; constexpr uint32_t characters_small_capital_e = 1601; constexpr uint32_t characters_small_capital_f = 1602; constexpr uint32_t characters_small_capital_g = 1603; constexpr uint32_t characters_small_capital_h = 1604; constexpr uint32_t characters_small_capital_i = 1605; constexpr uint32_t characters_small_capital_j = 1606; constexpr uint32_t characters_small_capital_k = 1607; constexpr uint32_t characters_small_capital_l = 1608; constexpr uint32_t characters_small_capital_m = 1609; constexpr uint32_t characters_small_capital_n = 1610; constexpr uint32_t characters_small_capital_o = 1611; constexpr uint32_t characters_small_capital_p = 1612; constexpr uint32_t characters_small_capital_q = 1613; constexpr uint32_t characters_small_capital_r = 1614; constexpr uint32_t characters_small_capital_s = 1615; constexpr uint32_t characters_small_capital_t = 1616; constexpr uint32_t characters_small_capital_u = 1617; constexpr uint32_t characters_small_capital_v = 1618; constexpr uint32_t characters_small_capital_w = 1619; constexpr uint32_t characters_small_capital_x = 1620; constexpr uint32_t characters_small_capital_y = 1621; constexpr uint32_t characters_small_capital_z = 1622; constexpr uint32_t characters_small_left_square_bracket = 1623; constexpr uint32_t characters_small_backslash = 1624; constexpr uint32_t characters_small_right_square_bracket = 1625; constexpr uint32_t characters_small_circumflex = 1626; constexpr uint32_t characters_small_underscore = 1627; constexpr uint32_t characters_small_grave = 1628; constexpr uint32_t characters_small_small_a = 1629; constexpr uint32_t characters_small_small_b = 1630; constexpr uint32_t characters_small_small_c = 1631; constexpr uint32_t characters_small_small_d = 1632; constexpr uint32_t characters_small_small_e = 1633; constexpr uint32_t characters_small_small_f = 1634; constexpr uint32_t characters_small_small_g = 1635; constexpr uint32_t characters_small_small_h = 1636; constexpr uint32_t characters_small_small_i = 1637; constexpr uint32_t characters_small_small_j = 1638; constexpr uint32_t characters_small_small_k = 1639; constexpr uint32_t characters_small_small_l = 1640; constexpr uint32_t characters_small_small_m = 1641; constexpr uint32_t characters_small_small_n = 1642; constexpr uint32_t characters_small_small_o = 1643; constexpr uint32_t characters_small_small_p = 1644; constexpr uint32_t characters_small_small_q = 1645; constexpr uint32_t characters_small_small_r = 1646; constexpr uint32_t characters_small_small_s = 1647; constexpr uint32_t characters_small_small_t = 1648; constexpr uint32_t characters_small_small_u = 1649; constexpr uint32_t characters_small_small_v = 1650; constexpr uint32_t characters_small_small_w = 1651; constexpr uint32_t characters_small_small_x = 1652; constexpr uint32_t characters_small_small_y = 1653; constexpr uint32_t characters_small_small_z = 1654; constexpr uint32_t characters_small_left_brace = 1655; constexpr uint32_t characters_small_verticle_bar = 1656; constexpr uint32_t characters_small_right_brace = 1657; constexpr uint32_t characters_small_tilde = 1658; constexpr uint32_t characters_small_delete = 1659; constexpr uint32_t characters_small_128 = 1660; constexpr uint32_t characters_small_129 = 1661; constexpr uint32_t characters_small_130 = 1662; constexpr uint32_t characters_small_131 = 1663; constexpr uint32_t characters_small_132 = 1664; constexpr uint32_t characters_small_133 = 1665; constexpr uint32_t characters_small_134 = 1666; constexpr uint32_t characters_small_135 = 1667; constexpr uint32_t characters_small_136 = 1668; constexpr uint32_t characters_small_137 = 1669; constexpr uint32_t characters_small_138 = 1670; constexpr uint32_t characters_small_139 = 1671; constexpr uint32_t characters_small_140 = 1672; constexpr uint32_t characters_small_141 = 1673; constexpr uint32_t characters_small_142 = 1674; constexpr uint32_t characters_small_143 = 1675; constexpr uint32_t characters_small_144 = 1676; constexpr uint32_t characters_small_145 = 1677; constexpr uint32_t characters_small_146 = 1678; constexpr uint32_t characters_small_147 = 1679; constexpr uint32_t characters_small_148 = 1680; constexpr uint32_t characters_small_149 = 1681; constexpr uint32_t characters_small_150 = 1682; constexpr uint32_t characters_small_151 = 1683; constexpr uint32_t characters_small_152 = 1684; constexpr uint32_t characters_small_153 = 1685; constexpr uint32_t characters_small_154 = 1686; constexpr uint32_t characters_small_155 = 1687; constexpr uint32_t characters_small_156 = 1688; constexpr uint32_t characters_small_157 = 1689; constexpr uint32_t characters_small_158 = 1690; constexpr uint32_t characters_small_a_ogonek = 1691; constexpr uint32_t characters_small_up_arrow = 1692; constexpr uint32_t characters_small_inverted_exclamation_mark = 1693; constexpr uint32_t characters_small_capital_c_acute = 1694; constexpr uint32_t characters_small_currency_sign = 1695; constexpr uint32_t characters_small_general_currency_sign = 1696; constexpr uint32_t characters_small_yen_sign = 1697; constexpr uint32_t characters_small_capital_e_ogonek = 1698; constexpr uint32_t characters_small_capital_l_stroke = 1699; constexpr uint32_t characters_small_168 = 1700; constexpr uint32_t characters_small_copyright_sign = 1701; constexpr uint32_t characters_small_down_arrow = 1702; constexpr uint32_t characters_small_left_double_angle_quote = 1703; constexpr uint32_t characters_small_tick_sign = 1704; constexpr uint32_t characters_small_cross_sign = 1705; constexpr uint32_t characters_small_174 = 1706; constexpr uint32_t characters_small_right_arrow = 1707; constexpr uint32_t characters_small_degree_sign = 1708; constexpr uint32_t characters_small_railway_sign = 1709; constexpr uint32_t characters_small_superscript_2 = 1710; constexpr uint32_t characters_small_superscript_3 = 1711; constexpr uint32_t characters_small_double_quote_open = 1712; constexpr uint32_t characters_small_micro_sign = 1713; constexpr uint32_t characters_small_road_sign = 1714; constexpr uint32_t characters_small_air_sign = 1715; constexpr uint32_t characters_small_water_sign = 1716; constexpr uint32_t characters_small_superscript_1 = 1717; constexpr uint32_t characters_small_masculine_ordinal_indicator = 1718; constexpr uint32_t characters_small_right_double_angle_quote = 1719; constexpr uint32_t characters_small_small_up_arrow = 1720; constexpr uint32_t characters_small_small_down_arrow = 1721; constexpr uint32_t characters_small_fraction_3_4 = 1722; constexpr uint32_t characters_small_inverted_question_mark = 1723; constexpr uint32_t characters_small_capital_a_grave = 1724; constexpr uint32_t characters_small_capital_a_acute = 1725; constexpr uint32_t characters_small_capital_a_circumflex = 1726; constexpr uint32_t characters_small_capital_a_tilde = 1727; constexpr uint32_t characters_small_capital_a_umlaut = 1728; constexpr uint32_t characters_small_capital_a_ring = 1729; constexpr uint32_t characters_small_capital_n_acute = 1730; constexpr uint32_t characters_small_capital_c_cedilla = 1731; constexpr uint32_t characters_small_capital_e_grave = 1732; constexpr uint32_t characters_small_capital_e_acute = 1733; constexpr uint32_t characters_small_capital_e_circumflex = 1734; constexpr uint32_t characters_small_capital_e_umlaut = 1735; constexpr uint32_t characters_small_capital_i_grave = 1736; constexpr uint32_t characters_small_capital_i_acute = 1737; constexpr uint32_t characters_small_capital_i_circumflex = 1738; constexpr uint32_t characters_small_capital_i_umlaut = 1739; constexpr uint32_t characters_small_capital_s_acute = 1740; constexpr uint32_t characters_small_capital_n_tilde = 1741; constexpr uint32_t characters_small_capital_o_grave = 1742; constexpr uint32_t characters_small_capital_o_acute = 1743; constexpr uint32_t characters_small_capital_o_circumflex = 1744; constexpr uint32_t characters_small_capital_o_tilde = 1745; constexpr uint32_t characters_small_capital_o_umlaut = 1746; constexpr uint32_t characters_small_capital_z_acute = 1747; constexpr uint32_t characters_small_capital_z_dot = 1748; constexpr uint32_t characters_small_capital_u_grave = 1749; constexpr uint32_t characters_small_capital_u_acute = 1750; constexpr uint32_t characters_small_capital_u_circumflex = 1751; constexpr uint32_t characters_small_capital_u_umlaut = 1752; constexpr uint32_t characters_small_small_a_ogonek = 1753; constexpr uint32_t characters_small_small_c_acute = 1754; constexpr uint32_t characters_small_small_s_sharp = 1755; constexpr uint32_t characters_small_small_a_grave = 1756; constexpr uint32_t characters_small_small_a_acute = 1757; constexpr uint32_t characters_small_small_a_circumflex = 1758; constexpr uint32_t characters_small_small_a_tilde = 1759; constexpr uint32_t characters_small_small_a_umlaut = 1760; constexpr uint32_t characters_small_small_a_ring = 1761; constexpr uint32_t characters_small_small_e_ogonek = 1762; constexpr uint32_t characters_small_small_c_cedilla = 1763; constexpr uint32_t characters_small_small_e_grave = 1764; constexpr uint32_t characters_small_small_e_acute = 1765; constexpr uint32_t characters_small_small_e_circumflex = 1766; constexpr uint32_t characters_small_small_e_umlaut = 1767; constexpr uint32_t characters_small_small_i_grave = 1768; constexpr uint32_t characters_small_small_i_acute = 1769; constexpr uint32_t characters_small_small_i_circumflex = 1770; constexpr uint32_t characters_small_small_i_umlaut = 1771; constexpr uint32_t characters_small_small_n_acute = 1772; constexpr uint32_t characters_small_small_n_tilde = 1773; constexpr uint32_t characters_small_small_o_grave = 1774; constexpr uint32_t characters_small_small_o_acute = 1775; constexpr uint32_t characters_small_small_o_circumflex = 1776; constexpr uint32_t characters_small_small_o_tilde = 1777; constexpr uint32_t characters_small_small_o_umlaut = 1778; constexpr uint32_t characters_small_small_l_stroke = 1779; constexpr uint32_t characters_small_small_s_acute = 1780; constexpr uint32_t characters_small_small_u_grave = 1781; constexpr uint32_t characters_small_small_u_acute = 1782; constexpr uint32_t characters_small_small_u_circumflex = 1783; constexpr uint32_t characters_small_small_u_umlaut = 1784; constexpr uint32_t characters_small_small_z_dot = 1785; constexpr uint32_t characters_small_small_z_acute = 1786; constexpr uint32_t characters_small_small_255 = 1787; constexpr uint32_t characters_large_space = 1788; constexpr uint32_t characters_large_exclamation_mark = 1789; constexpr uint32_t characters_large_double_quoatation_mark = 1790; constexpr uint32_t characters_large_pound_sign = 1791; constexpr uint32_t characters_large_dollar_sign = 1792; constexpr uint32_t characters_large_percent_sign = 1793; constexpr uint32_t characters_large_ampersand = 1794; constexpr uint32_t characters_large_apostrophe = 1795; constexpr uint32_t characters_large_left_parenthesis = 1796; constexpr uint32_t characters_large_right_parenthesis = 1797; constexpr uint32_t characters_large_asterisk = 1798; constexpr uint32_t characters_large_plus_sign = 1799; constexpr uint32_t characters_large_comma = 1800; constexpr uint32_t characters_large_minus_sign = 1801; constexpr uint32_t characters_large_period = 1802; constexpr uint32_t characters_large_slash = 1803; constexpr uint32_t characters_large_digit_0 = 1804; constexpr uint32_t characters_large_digit_1 = 1805; constexpr uint32_t characters_large_digit_2 = 1806; constexpr uint32_t characters_large_digit_3 = 1807; constexpr uint32_t characters_large_digit_4 = 1808; constexpr uint32_t characters_large_digit_5 = 1809; constexpr uint32_t characters_large_digit_6 = 1810; constexpr uint32_t characters_large_digit_7 = 1811; constexpr uint32_t characters_large_digit_8 = 1812; constexpr uint32_t characters_large_digit_9 = 1813; constexpr uint32_t characters_large_colon = 1814; constexpr uint32_t characters_large_semicolon = 1815; constexpr uint32_t characters_large_less_than_sign = 1816; constexpr uint32_t characters_large_equal_sign = 1817; constexpr uint32_t characters_large_greater_than_sign = 1818; constexpr uint32_t characters_large_question_mark = 1819; constexpr uint32_t characters_large_at_sign = 1820; constexpr uint32_t characters_large_capital_a = 1821; constexpr uint32_t characters_large_capital_b = 1822; constexpr uint32_t characters_large_capital_c = 1823; constexpr uint32_t characters_large_capital_d = 1824; constexpr uint32_t characters_large_capital_e = 1825; constexpr uint32_t characters_large_capital_f = 1826; constexpr uint32_t characters_large_capital_g = 1827; constexpr uint32_t characters_large_capital_h = 1828; constexpr uint32_t characters_large_capital_i = 1829; constexpr uint32_t characters_large_capital_j = 1830; constexpr uint32_t characters_large_capital_k = 1831; constexpr uint32_t characters_large_capital_l = 1832; constexpr uint32_t characters_large_capital_m = 1833; constexpr uint32_t characters_large_capital_n = 1834; constexpr uint32_t characters_large_capital_o = 1835; constexpr uint32_t characters_large_capital_p = 1836; constexpr uint32_t characters_large_capital_q = 1837; constexpr uint32_t characters_large_capital_r = 1838; constexpr uint32_t characters_large_capital_s = 1839; constexpr uint32_t characters_large_capital_t = 1840; constexpr uint32_t characters_large_capital_u = 1841; constexpr uint32_t characters_large_capital_v = 1842; constexpr uint32_t characters_large_capital_w = 1843; constexpr uint32_t characters_large_capital_x = 1844; constexpr uint32_t characters_large_capital_y = 1845; constexpr uint32_t characters_large_capital_z = 1846; constexpr uint32_t characters_large_left_square_bracket = 1847; constexpr uint32_t characters_large_backslash = 1848; constexpr uint32_t characters_large_right_square_bracket = 1849; constexpr uint32_t characters_large_circumflex = 1850; constexpr uint32_t characters_large_underscore = 1851; constexpr uint32_t characters_large_grave = 1852; constexpr uint32_t characters_large_small_a = 1853; constexpr uint32_t characters_large_small_b = 1854; constexpr uint32_t characters_large_small_c = 1855; constexpr uint32_t characters_large_small_d = 1856; constexpr uint32_t characters_large_small_e = 1857; constexpr uint32_t characters_large_small_f = 1858; constexpr uint32_t characters_large_small_g = 1859; constexpr uint32_t characters_large_small_h = 1860; constexpr uint32_t characters_large_small_i = 1861; constexpr uint32_t characters_large_small_j = 1862; constexpr uint32_t characters_large_small_k = 1863; constexpr uint32_t characters_large_small_l = 1864; constexpr uint32_t characters_large_small_m = 1865; constexpr uint32_t characters_large_small_n = 1866; constexpr uint32_t characters_large_small_o = 1867; constexpr uint32_t characters_large_small_p = 1868; constexpr uint32_t characters_large_small_q = 1869; constexpr uint32_t characters_large_small_r = 1870; constexpr uint32_t characters_large_small_s = 1871; constexpr uint32_t characters_large_small_t = 1872; constexpr uint32_t characters_large_small_u = 1873; constexpr uint32_t characters_large_small_v = 1874; constexpr uint32_t characters_large_small_w = 1875; constexpr uint32_t characters_large_small_x = 1876; constexpr uint32_t characters_large_small_y = 1877; constexpr uint32_t characters_large_small_z = 1878; constexpr uint32_t characters_large_left_brace = 1879; constexpr uint32_t characters_large_verticle_bar = 1880; constexpr uint32_t characters_large_right_brace = 1881; constexpr uint32_t characters_large_tilde = 1882; constexpr uint32_t characters_large_delete = 1883; constexpr uint32_t characters_large_128 = 1884; constexpr uint32_t characters_large_129 = 1885; constexpr uint32_t characters_large_130 = 1886; constexpr uint32_t characters_large_131 = 1887; constexpr uint32_t characters_large_132 = 1888; constexpr uint32_t characters_large_133 = 1889; constexpr uint32_t characters_large_134 = 1890; constexpr uint32_t characters_large_135 = 1891; constexpr uint32_t characters_large_136 = 1892; constexpr uint32_t characters_large_137 = 1893; constexpr uint32_t characters_large_138 = 1894; constexpr uint32_t characters_large_139 = 1895; constexpr uint32_t characters_large_140 = 1896; constexpr uint32_t characters_large_141 = 1897; constexpr uint32_t characters_large_142 = 1898; constexpr uint32_t characters_large_143 = 1899; constexpr uint32_t characters_large_144 = 1900; constexpr uint32_t characters_large_145 = 1901; constexpr uint32_t characters_large_146 = 1902; constexpr uint32_t characters_large_147 = 1903; constexpr uint32_t characters_large_148 = 1904; constexpr uint32_t characters_large_149 = 1905; constexpr uint32_t characters_large_150 = 1906; constexpr uint32_t characters_large_151 = 1907; constexpr uint32_t characters_large_152 = 1908; constexpr uint32_t characters_large_153 = 1909; constexpr uint32_t characters_large_154 = 1910; constexpr uint32_t characters_large_155 = 1911; constexpr uint32_t characters_large_156 = 1912; constexpr uint32_t characters_large_157 = 1913; constexpr uint32_t characters_large_158 = 1914; constexpr uint32_t characters_large_a_ogonek = 1915; constexpr uint32_t characters_large_up_arrow = 1916; constexpr uint32_t characters_large_inverted_exclamation_mark = 1917; constexpr uint32_t characters_large_capital_c_acute = 1918; constexpr uint32_t characters_large_currency_sign = 1919; constexpr uint32_t characters_large_general_currency_sign = 1920; constexpr uint32_t characters_large_yen_sign = 1921; constexpr uint32_t characters_large_capital_e_ogonek = 1922; constexpr uint32_t characters_large_capital_l_stroke = 1923; constexpr uint32_t characters_large_168 = 1924; constexpr uint32_t characters_large_copyright_sign = 1925; constexpr uint32_t characters_large_down_arrow = 1926; constexpr uint32_t characters_large_left_double_angle_quote = 1927; constexpr uint32_t characters_large_tick_sign = 1928; constexpr uint32_t characters_large_cross_sign = 1929; constexpr uint32_t characters_large_174 = 1930; constexpr uint32_t characters_large_right_arrow = 1931; constexpr uint32_t characters_large_degree_sign = 1932; constexpr uint32_t characters_large_railway_sign = 1933; constexpr uint32_t characters_large_superscript_2 = 1934; constexpr uint32_t characters_large_superscript_3 = 1935; constexpr uint32_t characters_large_double_quote_open = 1936; constexpr uint32_t characters_large_micro_sign = 1937; constexpr uint32_t characters_large_road_sign = 1938; constexpr uint32_t characters_large_air_sign = 1939; constexpr uint32_t characters_large_water_sign = 1940; constexpr uint32_t characters_large_superscript_1 = 1941; constexpr uint32_t characters_large_masculine_ordinal_indicator = 1942; constexpr uint32_t characters_large_right_double_angle_quote = 1943; constexpr uint32_t characters_large_small_up_arrow = 1944; constexpr uint32_t characters_large_small_down_arrow = 1945; constexpr uint32_t characters_large_fraction_3_4 = 1946; constexpr uint32_t characters_large_inverted_question_mark = 1947; constexpr uint32_t characters_large_capital_a_grave = 1948; constexpr uint32_t characters_large_capital_a_acute = 1949; constexpr uint32_t characters_large_capital_a_circumflex = 1950; constexpr uint32_t characters_large_capital_a_tilde = 1951; constexpr uint32_t characters_large_capital_a_umlaut = 1952; constexpr uint32_t characters_large_capital_a_ring = 1953; constexpr uint32_t characters_large_capital_n_acute = 1954; constexpr uint32_t characters_large_capital_c_cedilla = 1955; constexpr uint32_t characters_large_capital_e_grave = 1956; constexpr uint32_t characters_large_capital_e_acute = 1957; constexpr uint32_t characters_large_capital_e_circumflex = 1958; constexpr uint32_t characters_large_capital_e_umlaut = 1959; constexpr uint32_t characters_large_capital_i_grave = 1960; constexpr uint32_t characters_large_capital_i_acute = 1961; constexpr uint32_t characters_large_capital_i_circumflex = 1962; constexpr uint32_t characters_large_capital_i_umlaut = 1963; constexpr uint32_t characters_large_capital_s_acute = 1964; constexpr uint32_t characters_large_capital_n_tilde = 1965; constexpr uint32_t characters_large_capital_o_grave = 1966; constexpr uint32_t characters_large_capital_o_acute = 1967; constexpr uint32_t characters_large_capital_o_circumflex = 1968; constexpr uint32_t characters_large_capital_o_tilde = 1969; constexpr uint32_t characters_large_capital_o_umlaut = 1970; constexpr uint32_t characters_large_capital_z_acute = 1971; constexpr uint32_t characters_large_capital_z_dot = 1972; constexpr uint32_t characters_large_capital_u_grave = 1973; constexpr uint32_t characters_large_capital_u_acute = 1974; constexpr uint32_t characters_large_capital_u_circumflex = 1975; constexpr uint32_t characters_large_capital_u_umlaut = 1976; constexpr uint32_t characters_large_small_a_ogonek = 1977; constexpr uint32_t characters_large_small_c_acute = 1978; constexpr uint32_t characters_large_small_s_sharp = 1979; constexpr uint32_t characters_large_small_a_grave = 1980; constexpr uint32_t characters_large_small_a_acute = 1981; constexpr uint32_t characters_large_small_a_circumflex = 1982; constexpr uint32_t characters_large_small_a_tilde = 1983; constexpr uint32_t characters_large_small_a_umlaut = 1984; constexpr uint32_t characters_large_small_a_ring = 1985; constexpr uint32_t characters_large_small_e_ogonek = 1986; constexpr uint32_t characters_large_small_c_cedilla = 1987; constexpr uint32_t characters_large_small_e_grave = 1988; constexpr uint32_t characters_large_small_e_acute = 1989; constexpr uint32_t characters_large_small_e_circumflex = 1990; constexpr uint32_t characters_large_small_e_umlaut = 1991; constexpr uint32_t characters_large_small_i_grave = 1992; constexpr uint32_t characters_large_small_i_acute = 1993; constexpr uint32_t characters_large_small_i_circumflex = 1994; constexpr uint32_t characters_large_small_i_umlaut = 1995; constexpr uint32_t characters_large_small_n_acute = 1996; constexpr uint32_t characters_large_small_n_tilde = 1997; constexpr uint32_t characters_large_small_o_grave = 1998; constexpr uint32_t characters_large_small_o_acute = 1999; constexpr uint32_t characters_large_small_o_circumflex = 2000; constexpr uint32_t characters_large_small_o_tilde = 2001; constexpr uint32_t characters_large_small_o_umlaut = 2002; constexpr uint32_t characters_large_small_l_stroke = 2003; constexpr uint32_t characters_large_small_s_acute = 2004; constexpr uint32_t characters_large_small_u_grave = 2005; constexpr uint32_t characters_large_small_u_acute = 2006; constexpr uint32_t characters_large_small_u_circumflex = 2007; constexpr uint32_t characters_large_small_u_umlaut = 2008; constexpr uint32_t characters_large_small_z_dot = 2009; constexpr uint32_t characters_large_small_z_acute = 2010; constexpr uint32_t characters_large_small_255 = 2011; constexpr uint32_t currency_symbol = characters_large_currency_sign; constexpr uint32_t text_palette = 2169; constexpr uint32_t paletteMapBlack = 2170; constexpr uint32_t paletteMapGrey = 2171; constexpr uint32_t paletteMapWhite = 2172; constexpr uint32_t paletteMapMutedDarkPurple = 2173; constexpr uint32_t paletteMapMutedPurple = 2174; constexpr uint32_t paletteMapPurple = 2175; constexpr uint32_t paletteMapDarkBlue = 2176; constexpr uint32_t paletteMapBlue = 2177; constexpr uint32_t paletteMapMutedDarkTeal = 2178; constexpr uint32_t paletteMapMutedTeal = 2179; constexpr uint32_t paletteMapDarkGreen = 2180; constexpr uint32_t paletteMapMutedSeaGreen = 2181; constexpr uint32_t paletteMapMutedGrassGreen = 2182; constexpr uint32_t paletteMapGreen = 2183; constexpr uint32_t paletteMapMutedAvocadoGreen = 2184; constexpr uint32_t paletteMapMutedOliveGreen = 2185; constexpr uint32_t paletteMapYellow = 2186; constexpr uint32_t paletteMapDarkYellow = 2187; constexpr uint32_t paletteMapOrange = 2188; constexpr uint32_t paletteMapAmber = 2189; constexpr uint32_t paletteMapDarkOrange = 2190; constexpr uint32_t paletteMapMutedDarkYellow = 2191; constexpr uint32_t paletteMapMutedYellow = 2192; constexpr uint32_t paletteMapBrown = 2193; constexpr uint32_t paletteMapMutedOrange = 2194; constexpr uint32_t paletteMapMutedDarkRed = 2195; constexpr uint32_t paletteMapDarkRed = 2196; constexpr uint32_t paletteMapRed = 2197; constexpr uint32_t paletteMapDarkPink = 2198; constexpr uint32_t paletteMapPink = 2199; constexpr uint32_t paletteMapMutedRed = 2200; constexpr uint32_t paletteMapClear = 2201; constexpr uint32_t paletteMapUnk2C = 2202; constexpr uint32_t paletteMapUnk2D = 2203; constexpr uint32_t paletteMapUnk2E = 2204; constexpr uint32_t paletteMapUnk2F = 2205; constexpr uint32_t paletteMapUnk30 = 2206; constexpr uint32_t paletteMapUnk31 = 2207; constexpr uint32_t paletteMapUnk32 = 2208; constexpr uint32_t paletteMapUnk33 = 2209; constexpr uint32_t paletteMapUnk34 = 2210; constexpr uint32_t paletteMapTranslucentGrey1 = 2211; constexpr uint32_t paletteMapTranslucentGrey2 = 2212; constexpr uint32_t paletteMapTranslucentGrey0 = 2213; constexpr uint32_t paletteMapTranslucentBlue1 = 2214; constexpr uint32_t paletteMapTranslucentBlue2 = 2215; constexpr uint32_t paletteMapTranslucentBlue0 = 2216; constexpr uint32_t paletteMapTranslucentMutedDarkRed1 = 2217; constexpr uint32_t paletteMapTranslucentMutedDarkRed2 = 2218; constexpr uint32_t paletteMapTranslucentMutedDarkRed0 = 2219; constexpr uint32_t paletteMapTranslucentMutedSeaGreen1 = 2220; constexpr uint32_t paletteMapTranslucentMutedSeaGreen2 = 2221; constexpr uint32_t paletteMapTranslucentMutedSeaGreen0 = 2222; constexpr uint32_t paletteMapTranslucentMutedPurple1 = 2223; constexpr uint32_t paletteMapTranslucentMutedPurple2 = 2224; constexpr uint32_t paletteMapTranslucentMutedPurple0 = 2225; constexpr uint32_t paletteMapTranslucentMutedOliveGreen1 = 2226; constexpr uint32_t paletteMapTranslucentMutedOliveGreen2 = 2227; constexpr uint32_t paletteMapTranslucentMutedOliveGreen0 = 2228; constexpr uint32_t paletteMapTranslucentMutedYellow1 = 2229; constexpr uint32_t paletteMapTranslucentMutedYellow2 = 2230; constexpr uint32_t paletteMapTranslucentMutedYellow0 = 2231; constexpr uint32_t paletteMapTranslucentYellow1 = 2232; constexpr uint32_t paletteMapTranslucentYellow2 = 2233; constexpr uint32_t paletteMapTranslucentYellow0 = 2234; constexpr uint32_t paletteMapTranslucentMutedGrassGreen1 = 2235; constexpr uint32_t paletteMapTranslucentMutedGrassGreen2 = 2236; constexpr uint32_t paletteMapTranslucentMutedGrassGreen0 = 2237; constexpr uint32_t paletteMapTranslucentMutedAvocadoGreen1 = 2238; constexpr uint32_t paletteMapTranslucentMutedAvocadoGreen2 = 2239; constexpr uint32_t paletteMapTranslucentMutedAvocadoGreen0 = 2240; constexpr uint32_t paletteMapTranslucentGreen1 = 2241; constexpr uint32_t paletteMapTranslucentGreen2 = 2242; constexpr uint32_t paletteMapTranslucentGreen0 = 2243; constexpr uint32_t paletteMapTranslucentMutedOrange1 = 2244; constexpr uint32_t paletteMapTranslucentMutedOrange2 = 2245; constexpr uint32_t paletteMapTranslucentMutedOrange0 = 2246; constexpr uint32_t paletteMapTranslucentPurple1 = 2247; constexpr uint32_t paletteMapTranslucentPurple2 = 2248; constexpr uint32_t paletteMapTranslucentPurple0 = 2249; constexpr uint32_t paletteMapTranslucentRed1 = 2250; constexpr uint32_t paletteMapTranslucentRed2 = 2251; constexpr uint32_t paletteMapTranslucentRed0 = 2252; constexpr uint32_t paletteMapTranslucentOrange1 = 2253; constexpr uint32_t paletteMapTranslucentOrange2 = 2254; constexpr uint32_t paletteMapTranslucentOrange0 = 2255; constexpr uint32_t paletteMapTranslucentMutedTeal1 = 2256; constexpr uint32_t paletteMapTranslucentMutedTeal2 = 2257; constexpr uint32_t paletteMapTranslucentMutedTeal0 = 2258; constexpr uint32_t paletteMapTranslucentPink1 = 2259; constexpr uint32_t paletteMapTranslucentPink2 = 2260; constexpr uint32_t paletteMapTranslucentPink0 = 2261; constexpr uint32_t paletteMapTranslucentBrown1 = 2262; constexpr uint32_t paletteMapTranslucentBrown2 = 2263; constexpr uint32_t paletteMapTranslucentBrown0 = 2264; constexpr uint32_t paletteMapTranslucentMutedRed1 = 2265; constexpr uint32_t paletteMapTranslucentMutedRed2 = 2266; constexpr uint32_t paletteMapTranslucentMutedRed0 = 2267; constexpr uint32_t paletteMapTranslucentWhite1 = 2268; constexpr uint32_t paletteMapTranslucentWhite2 = 2269; constexpr uint32_t paletteMapTranslucentWhite0 = 2270; constexpr uint32_t paletteMapTranslucentAmber1 = 2271; constexpr uint32_t paletteMapTranslucentAmber2 = 2272; constexpr uint32_t paletteMapTranslucentAmber0 = 2273; constexpr uint32_t paletteMapUnk74 = 2274; constexpr uint32_t paletteMapUnk75 = 2275; constexpr uint32_t paletteMapUnk76 = 2276; constexpr uint32_t paletteMapUnk77 = 2277; constexpr uint32_t paletteMapUnk78 = 2278; constexpr uint32_t paletteMapUnk79 = 2279; constexpr uint32_t paletteMapUnk7A = 2280; constexpr uint32_t paletteMapUnk7B = 2281; constexpr uint32_t paletteMapUnk7C = 2282; constexpr uint32_t paletteMapUnk7D = 2283; constexpr uint32_t paletteMapUnk7E = 2284; constexpr uint32_t paletteMapUnk7F = 2285; constexpr uint32_t paletteMapUnk80 = 2286; constexpr uint32_t paletteMapUnk81 = 2287; constexpr uint32_t paletteMapUnk82 = 2288; constexpr uint32_t paletteMapUnk83 = 2289; constexpr uint32_t paletteMapUnk84 = 2290; constexpr uint32_t paletteMapUnk85 = 2291; constexpr uint32_t paletteMapUnk86 = 2292; constexpr uint32_t paletteMapUnk87 = 2293; constexpr uint32_t paletteMapUnk88 = 2294; constexpr uint32_t paletteMapUnk89 = 2295; constexpr uint32_t paletteMapUnk8A = 2296; constexpr uint32_t paletteMapUnk8B = 2297; constexpr uint32_t paletteMapUnk8C = 2298; constexpr uint32_t paletteMapUnk8D = 2299; constexpr uint32_t paletteMapUnk8E = 2300; constexpr uint32_t paletteMapUnk8F = 2301; constexpr uint32_t paletteMapUnk90 = 2302; constexpr uint32_t paletteMapUnk91 = 2303; constexpr uint32_t paletteMapUnk92 = 2304; constexpr uint32_t window_resize_handle = 2305; constexpr uint32_t colour_swatch_recolourable = 2306; constexpr uint32_t colour_swatch_recolourable_raised = 2307; constexpr uint32_t colour_swatch_recolourable_pressed = 2308; constexpr uint32_t company_list_dropdown_icon = 2309; constexpr uint32_t icon_parent_folder = 2310; constexpr uint32_t icon_folder = 2311; constexpr uint32_t curved_border_left_medium = 2315; constexpr uint32_t curved_border_right_medium = 2316; constexpr uint32_t curved_border_left_medium_bold = 2317; constexpr uint32_t curved_border_right_medium_bold = 2318; constexpr uint32_t curved_border_left_small = 2319; constexpr uint32_t curved_border_right_small = 2320; constexpr uint32_t close_button = 2321; constexpr uint32_t frame_background_image = 2322; constexpr uint32_t frame_background_image_alt = 2323; constexpr uint32_t inline_green_up_arrow = 2324; constexpr uint32_t inline_red_down_arrow = 2325; constexpr uint32_t progressbar_style0_frame0 = 2326; constexpr uint32_t progressbar_style0_frame1 = 2327; constexpr uint32_t progressbar_style0_frame2 = 2328; constexpr uint32_t progressbar_style0_frame3 = 2329; constexpr uint32_t progressbar_track = 2330; constexpr uint32_t progressbar_style1_frame0 = 2331; constexpr uint32_t progressbar_style1_frame1 = 2332; constexpr uint32_t progressbar_style1_frame2 = 2333; constexpr uint32_t progressbar_style1_frame3 = 2334; constexpr uint32_t construction_straight = 2335; constexpr uint32_t step_back = 2336; constexpr uint32_t step_forward = 2337; constexpr uint32_t red_arrow_up = 2338; constexpr uint32_t red_arrow_down = 2339; constexpr uint32_t construction_left_hand_curve_very_small = 2340; constexpr uint32_t construction_right_hand_curve_very_small = 2341; constexpr uint32_t construction_left_hand_curve_small = 2342; constexpr uint32_t construction_right_hand_curve_small = 2343; constexpr uint32_t construction_left_hand_curve = 2344; constexpr uint32_t construction_right_hand_curve = 2345; constexpr uint32_t construction_left_hand_curve_large = 2346; constexpr uint32_t construction_right_hand_curve_large = 2347; constexpr uint32_t construction_steep_slope_down = 2348; constexpr uint32_t construction_slope_down = 2349; constexpr uint32_t construction_level = 2350; constexpr uint32_t construction_slope_up = 2351; constexpr uint32_t construction_steep_slope_up = 2352; constexpr uint32_t construction_s_bend_left = 2353; constexpr uint32_t construction_s_bend_right = 2354; constexpr uint32_t construction_s_bend_dual_track_left = 2355; constexpr uint32_t construction_s_bend_dual_track_right = 2356; constexpr uint32_t construction_s_bend_to_single_track_left = 2357; constexpr uint32_t construction_s_bend_to_single_track_right = 2358; constexpr uint32_t construction_right_turnaround = 2359; constexpr uint32_t construction_left_turnaround = 2360; constexpr uint32_t construction_remove = 2361; constexpr uint32_t construction_new_position = 2362; constexpr uint32_t rubbish_bin = 2363; constexpr uint32_t centre_viewport = 2364; constexpr uint32_t rotate_object = 2365; constexpr uint32_t photo_camera = 2366; constexpr uint32_t paintbrush = 2367; constexpr uint32_t stopwatch = 2368; constexpr uint32_t red_flag = 2369; constexpr uint32_t green_flag = 2370; constexpr uint32_t yellow_flag = 2371; constexpr uint32_t airport_pickup = 2372; constexpr uint32_t airport_place = 2373; constexpr uint32_t pass_signal = 2374; constexpr uint32_t route_delete = 2375; constexpr uint32_t route_skip = 2376; constexpr uint32_t route_wait = 2377; constexpr uint32_t route_force_unload = 2378; constexpr uint32_t show_station_catchment = 2379; constexpr uint32_t plant_cluster_selected_tree = 2380; constexpr uint32_t plant_cluster_random_tree = 2381; constexpr uint32_t town_expand = 2382; constexpr uint32_t music_controls_stop = 2383; constexpr uint32_t music_controls_play = 2384; constexpr uint32_t music_controls_next = 2385; constexpr uint32_t refit_cargo_button = 2386; constexpr uint32_t tab = 2387; constexpr uint32_t selected_tab = 2388; constexpr uint32_t tab_display = 2391; constexpr uint32_t tab_control = 2392; constexpr uint32_t tab_sound = 2393; constexpr uint32_t tab_miscellaneous = 2394; constexpr uint32_t tab_globe_0 = 2395; constexpr uint32_t tab_globe_1 = 2396; constexpr uint32_t tab_globe_2 = 2397; constexpr uint32_t tab_globe_3 = 2398; constexpr uint32_t tab_globe_4 = 2399; constexpr uint32_t tab_globe_5 = 2400; constexpr uint32_t tab_globe_6 = 2401; constexpr uint32_t tab_globe_7 = 2402; constexpr uint32_t tab_globe_8 = 2403; constexpr uint32_t tab_globe_9 = 2404; constexpr uint32_t tab_globe_10 = 2405; constexpr uint32_t tab_globe_11 = 2406; constexpr uint32_t tab_globe_12 = 2407; constexpr uint32_t tab_globe_13 = 2408; constexpr uint32_t tab_globe_14 = 2409; constexpr uint32_t tab_globe_15 = 2410; constexpr uint32_t tab_globe_16 = 2411; constexpr uint32_t tab_globe_17 = 2412; constexpr uint32_t tab_globe_18 = 2413; constexpr uint32_t tab_globe_19 = 2414; constexpr uint32_t tab_globe_20 = 2415; constexpr uint32_t tab_globe_21 = 2416; constexpr uint32_t tab_globe_22 = 2417; constexpr uint32_t tab_globe_23 = 2418; constexpr uint32_t tab_globe_24 = 2419; constexpr uint32_t tab_globe_25 = 2420; constexpr uint32_t tab_globe_26 = 2421; constexpr uint32_t tab_globe_27 = 2422; constexpr uint32_t tab_globe_28 = 2423; constexpr uint32_t tab_globe_29 = 2424; constexpr uint32_t tab_globe_30 = 2425; constexpr uint32_t tab_globe_31 = 2426; constexpr uint32_t tab_music_0 = 2427; constexpr uint32_t tab_music_1 = 2428; constexpr uint32_t tab_music_2 = 2429; constexpr uint32_t tab_music_3 = 2430; constexpr uint32_t tab_music_4 = 2431; constexpr uint32_t tab_music_5 = 2432; constexpr uint32_t tab_music_6 = 2433; constexpr uint32_t tab_music_7 = 2434; constexpr uint32_t tab_music_8 = 2435; constexpr uint32_t tab_music_9 = 2436; constexpr uint32_t tab_music_10 = 2437; constexpr uint32_t tab_music_11 = 2438; constexpr uint32_t tab_music_12 = 2439; constexpr uint32_t tab_music_13 = 2440; constexpr uint32_t tab_music_14 = 2441; constexpr uint32_t tab_music_15 = 2442; constexpr uint32_t decrease_tool_area = 2443; constexpr uint32_t increase_tool_area = 2445; constexpr uint32_t tool_area = 2447; constexpr uint32_t speed_pause = 2460; constexpr uint32_t speed_pause_active = 2461; constexpr uint32_t speed_normal = 2462; constexpr uint32_t speed_normal_active = 2463; constexpr uint32_t speed_fast_forward = 2464; constexpr uint32_t speed_fast_forward_active = 2465; constexpr uint32_t speed_extra_fast_forward = 2466; constexpr uint32_t speed_extra_fast_forward_active = 2467; constexpr uint32_t random_map_watermark = 2468; constexpr uint32_t height_map_compass = 2469; constexpr uint32_t height_marker_neg_128_u = 2470; constexpr uint32_t height_marker_neg_127_u = 2471; constexpr uint32_t height_marker_neg_126_u = 2472; constexpr uint32_t height_marker_neg_125_u = 2473; constexpr uint32_t height_marker_neg_124_u = 2474; constexpr uint32_t height_marker_neg_123_u = 2475; constexpr uint32_t height_marker_neg_122_u = 2476; constexpr uint32_t height_marker_neg_121_u = 2477; constexpr uint32_t height_marker_neg_120_u = 2478; constexpr uint32_t height_marker_neg_119_u = 2479; constexpr uint32_t height_marker_neg_118_u = 2480; constexpr uint32_t height_marker_neg_117_u = 2481; constexpr uint32_t height_marker_neg_116_u = 2482; constexpr uint32_t height_marker_neg_115_u = 2483; constexpr uint32_t height_marker_neg_114_u = 2484; constexpr uint32_t height_marker_neg_113_u = 2485; constexpr uint32_t height_marker_neg_112_u = 2486; constexpr uint32_t height_marker_neg_111_u = 2487; constexpr uint32_t height_marker_neg_110_u = 2488; constexpr uint32_t height_marker_neg_109_u = 2489; constexpr uint32_t height_marker_neg_108_u = 2490; constexpr uint32_t height_marker_neg_107_u = 2491; constexpr uint32_t height_marker_neg_106_u = 2492; constexpr uint32_t height_marker_neg_105_u = 2493; constexpr uint32_t height_marker_neg_104_u = 2494; constexpr uint32_t height_marker_neg_103_u = 2495; constexpr uint32_t height_marker_neg_102_u = 2496; constexpr uint32_t height_marker_neg_101_u = 2497; constexpr uint32_t height_marker_neg_100_u = 2498; constexpr uint32_t height_marker_neg_99_u = 2499; constexpr uint32_t height_marker_neg_98_u = 2500; constexpr uint32_t height_marker_neg_97_u = 2501; constexpr uint32_t height_marker_neg_96_u = 2502; constexpr uint32_t height_marker_neg_95_u = 2503; constexpr uint32_t height_marker_neg_94_u = 2504; constexpr uint32_t height_marker_neg_93_u = 2505; constexpr uint32_t height_marker_neg_92_u = 2506; constexpr uint32_t height_marker_neg_91_u = 2507; constexpr uint32_t height_marker_neg_90_u = 2508; constexpr uint32_t height_marker_neg_89_u = 2509; constexpr uint32_t height_marker_neg_88_u = 2510; constexpr uint32_t height_marker_neg_87_u = 2511; constexpr uint32_t height_marker_neg_86_u = 2512; constexpr uint32_t height_marker_neg_85_u = 2513; constexpr uint32_t height_marker_neg_84_u = 2514; constexpr uint32_t height_marker_neg_83_u = 2515; constexpr uint32_t height_marker_neg_82_u = 2516; constexpr uint32_t height_marker_neg_81_u = 2517; constexpr uint32_t height_marker_neg_80_u = 2518; constexpr uint32_t height_marker_neg_79_u = 2519; constexpr uint32_t height_marker_neg_78_u = 2520; constexpr uint32_t height_marker_neg_77_u = 2521; constexpr uint32_t height_marker_neg_76_u = 2522; constexpr uint32_t height_marker_neg_75_u = 2523; constexpr uint32_t height_marker_neg_74_u = 2524; constexpr uint32_t height_marker_neg_73_u = 2525; constexpr uint32_t height_marker_neg_72_u = 2526; constexpr uint32_t height_marker_neg_71_u = 2527; constexpr uint32_t height_marker_neg_70_u = 2528; constexpr uint32_t height_marker_neg_69_u = 2529; constexpr uint32_t height_marker_neg_68_u = 2530; constexpr uint32_t height_marker_neg_67_u = 2531; constexpr uint32_t height_marker_neg_66_u = 2532; constexpr uint32_t height_marker_neg_65_u = 2533; constexpr uint32_t height_marker_neg_64_u = 2534; constexpr uint32_t height_marker_neg_63_u = 2535; constexpr uint32_t height_marker_neg_62_u = 2536; constexpr uint32_t height_marker_neg_61_u = 2537; constexpr uint32_t height_marker_neg_60_u = 2538; constexpr uint32_t height_marker_neg_59_u = 2539; constexpr uint32_t height_marker_neg_58_u = 2540; constexpr uint32_t height_marker_neg_57_u = 2541; constexpr uint32_t height_marker_neg_56_u = 2542; constexpr uint32_t height_marker_neg_55_u = 2543; constexpr uint32_t height_marker_neg_54_u = 2544; constexpr uint32_t height_marker_neg_53_u = 2545; constexpr uint32_t height_marker_neg_52_u = 2546; constexpr uint32_t height_marker_neg_51_u = 2547; constexpr uint32_t height_marker_neg_50_u = 2548; constexpr uint32_t height_marker_neg_49_u = 2549; constexpr uint32_t height_marker_neg_48_u = 2550; constexpr uint32_t height_marker_neg_47_u = 2551; constexpr uint32_t height_marker_neg_46_u = 2552; constexpr uint32_t height_marker_neg_45_u = 2553; constexpr uint32_t height_marker_neg_44_u = 2554; constexpr uint32_t height_marker_neg_43_u = 2555; constexpr uint32_t height_marker_neg_42_u = 2556; constexpr uint32_t height_marker_neg_41_u = 2557; constexpr uint32_t height_marker_neg_40_u = 2558; constexpr uint32_t height_marker_neg_39_u = 2559; constexpr uint32_t height_marker_neg_38_u = 2560; constexpr uint32_t height_marker_neg_37_u = 2561; constexpr uint32_t height_marker_neg_36_u = 2562; constexpr uint32_t height_marker_neg_35_u = 2563; constexpr uint32_t height_marker_neg_34_u = 2564; constexpr uint32_t height_marker_neg_33_u = 2565; constexpr uint32_t height_marker_neg_32_u = 2566; constexpr uint32_t height_marker_neg_31_u = 2567; constexpr uint32_t height_marker_neg_30_u = 2568; constexpr uint32_t height_marker_neg_29_u = 2569; constexpr uint32_t height_marker_neg_28_u = 2570; constexpr uint32_t height_marker_neg_27_u = 2571; constexpr uint32_t height_marker_neg_26_u = 2572; constexpr uint32_t height_marker_neg_25_u = 2573; constexpr uint32_t height_marker_neg_24_u = 2574; constexpr uint32_t height_marker_neg_23_u = 2575; constexpr uint32_t height_marker_neg_22_u = 2576; constexpr uint32_t height_marker_neg_21_u = 2577; constexpr uint32_t height_marker_neg_20_u = 2578; constexpr uint32_t height_marker_neg_19_u = 2579; constexpr uint32_t height_marker_neg_18_u = 2580; constexpr uint32_t height_marker_neg_17_u = 2581; constexpr uint32_t height_marker_neg_16_u = 2582; constexpr uint32_t height_marker_neg_15_u = 2583; constexpr uint32_t height_marker_neg_14_u = 2584; constexpr uint32_t height_marker_neg_13_u = 2585; constexpr uint32_t height_marker_neg_12_u = 2586; constexpr uint32_t height_marker_neg_11_u = 2587; constexpr uint32_t height_marker_neg_10_u = 2588; constexpr uint32_t height_marker_neg_9_u = 2589; constexpr uint32_t height_marker_neg_8_u = 2590; constexpr uint32_t height_marker_neg_7_u = 2591; constexpr uint32_t height_marker_neg_6_u = 2592; constexpr uint32_t height_marker_neg_5_u = 2593; constexpr uint32_t height_marker_neg_4_u = 2594; constexpr uint32_t height_marker_neg_3_u = 2595; constexpr uint32_t height_marker_neg_2_u = 2596; constexpr uint32_t height_marker_neg_1_u = 2597; constexpr uint32_t height_marker_0_u = 2598; constexpr uint32_t height_marker_1_u = 2599; constexpr uint32_t height_marker_2_u = 2600; constexpr uint32_t height_marker_3_u = 2601; constexpr uint32_t height_marker_4_u = 2602; constexpr uint32_t height_marker_5_u = 2603; constexpr uint32_t height_marker_6_u = 2604; constexpr uint32_t height_marker_7_u = 2605; constexpr uint32_t height_marker_8_u = 2606; constexpr uint32_t height_marker_9_u = 2607; constexpr uint32_t height_marker_10_u = 2608; constexpr uint32_t height_marker_11_u = 2609; constexpr uint32_t height_marker_12_u = 2610; constexpr uint32_t height_marker_13_u = 2611; constexpr uint32_t height_marker_14_u = 2612; constexpr uint32_t height_marker_15_u = 2613; constexpr uint32_t height_marker_16_u = 2614; constexpr uint32_t height_marker_17_u = 2615; constexpr uint32_t height_marker_18_u = 2616; constexpr uint32_t height_marker_19_u = 2617; constexpr uint32_t height_marker_20_u = 2618; constexpr uint32_t height_marker_21_u = 2619; constexpr uint32_t height_marker_22_u = 2620; constexpr uint32_t height_marker_23_u = 2621; constexpr uint32_t height_marker_24_u = 2622; constexpr uint32_t height_marker_25_u = 2623; constexpr uint32_t height_marker_26_u = 2624; constexpr uint32_t height_marker_27_u = 2625; constexpr uint32_t height_marker_28_u = 2626; constexpr uint32_t height_marker_29_u = 2627; constexpr uint32_t height_marker_30_u = 2628; constexpr uint32_t height_marker_31_u = 2629; constexpr uint32_t height_marker_32_u = 2630; constexpr uint32_t height_marker_33_u = 2631; constexpr uint32_t height_marker_34_u = 2632; constexpr uint32_t height_marker_35_u = 2633; constexpr uint32_t height_marker_36_u = 2634; constexpr uint32_t height_marker_37_u = 2635; constexpr uint32_t height_marker_38_u = 2636; constexpr uint32_t height_marker_39_u = 2637; constexpr uint32_t height_marker_40_u = 2638; constexpr uint32_t height_marker_41_u = 2639; constexpr uint32_t height_marker_42_u = 2640; constexpr uint32_t height_marker_43_u = 2641; constexpr uint32_t height_marker_44_u = 2642; constexpr uint32_t height_marker_45_u = 2643; constexpr uint32_t height_marker_46_u = 2644; constexpr uint32_t height_marker_47_u = 2645; constexpr uint32_t height_marker_48_u = 2646; constexpr uint32_t height_marker_49_u = 2647; constexpr uint32_t height_marker_50_u = 2648; constexpr uint32_t height_marker_51_u = 2649; constexpr uint32_t height_marker_52_u = 2650; constexpr uint32_t height_marker_53_u = 2651; constexpr uint32_t height_marker_54_u = 2652; constexpr uint32_t height_marker_55_u = 2653; constexpr uint32_t height_marker_56_u = 2654; constexpr uint32_t height_marker_57_u = 2655; constexpr uint32_t height_marker_58_u = 2656; constexpr uint32_t height_marker_59_u = 2657; constexpr uint32_t height_marker_60_u = 2658; constexpr uint32_t height_marker_61_u = 2659; constexpr uint32_t height_marker_62_u = 2660; constexpr uint32_t height_marker_63_u = 2661; constexpr uint32_t height_marker_64_u = 2662; constexpr uint32_t height_marker_65_u = 2663; constexpr uint32_t height_marker_66_u = 2664; constexpr uint32_t height_marker_67_u = 2665; constexpr uint32_t height_marker_68_u = 2666; constexpr uint32_t height_marker_69_u = 2667; constexpr uint32_t height_marker_70_u = 2668; constexpr uint32_t height_marker_71_u = 2669; constexpr uint32_t height_marker_72_u = 2670; constexpr uint32_t height_marker_73_u = 2671; constexpr uint32_t height_marker_74_u = 2672; constexpr uint32_t height_marker_75_u = 2673; constexpr uint32_t height_marker_76_u = 2674; constexpr uint32_t height_marker_77_u = 2675; constexpr uint32_t height_marker_78_u = 2676; constexpr uint32_t height_marker_79_u = 2677; constexpr uint32_t height_marker_80_u = 2678; constexpr uint32_t height_marker_81_u = 2679; constexpr uint32_t height_marker_82_u = 2680; constexpr uint32_t height_marker_83_u = 2681; constexpr uint32_t height_marker_84_u = 2682; constexpr uint32_t height_marker_85_u = 2683; constexpr uint32_t height_marker_86_u = 2684; constexpr uint32_t height_marker_87_u = 2685; constexpr uint32_t height_marker_88_u = 2686; constexpr uint32_t height_marker_89_u = 2687; constexpr uint32_t height_marker_90_u = 2688; constexpr uint32_t height_marker_91_u = 2689; constexpr uint32_t height_marker_92_u = 2690; constexpr uint32_t height_marker_93_u = 2691; constexpr uint32_t height_marker_94_u = 2692; constexpr uint32_t height_marker_95_u = 2693; constexpr uint32_t height_marker_96_u = 2694; constexpr uint32_t height_marker_97_u = 2695; constexpr uint32_t height_marker_98_u = 2696; constexpr uint32_t height_marker_99_u = 2697; constexpr uint32_t height_marker_100_u = 2698; constexpr uint32_t height_marker_101_u = 2699; constexpr uint32_t height_marker_102_u = 2700; constexpr uint32_t height_marker_103_u = 2701; constexpr uint32_t height_marker_104_u = 2702; constexpr uint32_t height_marker_105_u = 2703; constexpr uint32_t height_marker_106_u = 2704; constexpr uint32_t height_marker_107_u = 2705; constexpr uint32_t height_marker_108_u = 2706; constexpr uint32_t height_marker_109_u = 2707; constexpr uint32_t height_marker_110_u = 2708; constexpr uint32_t height_marker_111_u = 2709; constexpr uint32_t height_marker_112_u = 2710; constexpr uint32_t height_marker_113_u = 2711; constexpr uint32_t height_marker_114_u = 2712; constexpr uint32_t height_marker_115_u = 2713; constexpr uint32_t height_marker_116_u = 2714; constexpr uint32_t height_marker_117_u = 2715; constexpr uint32_t height_marker_118_u = 2716; constexpr uint32_t height_marker_119_u = 2717; constexpr uint32_t height_marker_120_u = 2718; constexpr uint32_t height_marker_121_u = 2719; constexpr uint32_t height_marker_122_u = 2720; constexpr uint32_t height_marker_123_u = 2721; constexpr uint32_t height_marker_124_u = 2722; constexpr uint32_t height_marker_125_u = 2723; constexpr uint32_t height_marker_126_u = 2724; constexpr uint32_t height_marker_127_u = 2725; constexpr uint32_t height_marker_neg_128_i = 2726; constexpr uint32_t height_marker_neg_127_i = 2727; constexpr uint32_t height_marker_neg_126_i = 2728; constexpr uint32_t height_marker_neg_125_i = 2729; constexpr uint32_t height_marker_neg_124_i = 2730; constexpr uint32_t height_marker_neg_123_i = 2731; constexpr uint32_t height_marker_neg_122_i = 2732; constexpr uint32_t height_marker_neg_121_i = 2733; constexpr uint32_t height_marker_neg_120_i = 2734; constexpr uint32_t height_marker_neg_119_i = 2735; constexpr uint32_t height_marker_neg_118_i = 2736; constexpr uint32_t height_marker_neg_117_i = 2737; constexpr uint32_t height_marker_neg_116_i = 2738; constexpr uint32_t height_marker_neg_115_i = 2739; constexpr uint32_t height_marker_neg_114_i = 2740; constexpr uint32_t height_marker_neg_113_i = 2741; constexpr uint32_t height_marker_neg_112_i = 2742; constexpr uint32_t height_marker_neg_111_i = 2743; constexpr uint32_t height_marker_neg_110_i = 2744; constexpr uint32_t height_marker_neg_109_i = 2745; constexpr uint32_t height_marker_neg_108_i = 2746; constexpr uint32_t height_marker_neg_107_i = 2747; constexpr uint32_t height_marker_neg_106_i = 2748; constexpr uint32_t height_marker_neg_105_i = 2749; constexpr uint32_t height_marker_neg_104_i = 2750; constexpr uint32_t height_marker_neg_103_i = 2751; constexpr uint32_t height_marker_neg_102_i = 2752; constexpr uint32_t height_marker_neg_101_i = 2753; constexpr uint32_t height_marker_neg_100_i = 2754; constexpr uint32_t height_marker_neg_99_i = 2755; constexpr uint32_t height_marker_neg_98_i = 2756; constexpr uint32_t height_marker_neg_97_i = 2757; constexpr uint32_t height_marker_neg_96_i = 2758; constexpr uint32_t height_marker_neg_95_i = 2759; constexpr uint32_t height_marker_neg_94_i = 2760; constexpr uint32_t height_marker_neg_93_i = 2761; constexpr uint32_t height_marker_neg_92_i = 2762; constexpr uint32_t height_marker_neg_91_i = 2763; constexpr uint32_t height_marker_neg_90_i = 2764; constexpr uint32_t height_marker_neg_89_i = 2765; constexpr uint32_t height_marker_neg_88_i = 2766; constexpr uint32_t height_marker_neg_87_i = 2767; constexpr uint32_t height_marker_neg_86_i = 2768; constexpr uint32_t height_marker_neg_85_i = 2769; constexpr uint32_t height_marker_neg_84_i = 2770; constexpr uint32_t height_marker_neg_83_i = 2771; constexpr uint32_t height_marker_neg_82_i = 2772; constexpr uint32_t height_marker_neg_81_i = 2773; constexpr uint32_t height_marker_neg_80_i = 2774; constexpr uint32_t height_marker_neg_79_i = 2775; constexpr uint32_t height_marker_neg_78_i = 2776; constexpr uint32_t height_marker_neg_77_i = 2777; constexpr uint32_t height_marker_neg_76_i = 2778; constexpr uint32_t height_marker_neg_75_i = 2779; constexpr uint32_t height_marker_neg_74_i = 2780; constexpr uint32_t height_marker_neg_73_i = 2781; constexpr uint32_t height_marker_neg_72_i = 2782; constexpr uint32_t height_marker_neg_71_i = 2783; constexpr uint32_t height_marker_neg_70_i = 2784; constexpr uint32_t height_marker_neg_69_i = 2785; constexpr uint32_t height_marker_neg_68_i = 2786; constexpr uint32_t height_marker_neg_67_i = 2787; constexpr uint32_t height_marker_neg_66_i = 2788; constexpr uint32_t height_marker_neg_65_i = 2789; constexpr uint32_t height_marker_neg_64_i = 2790; constexpr uint32_t height_marker_neg_63_i = 2791; constexpr uint32_t height_marker_neg_62_i = 2792; constexpr uint32_t height_marker_neg_61_i = 2793; constexpr uint32_t height_marker_neg_60_i = 2794; constexpr uint32_t height_marker_neg_59_i = 2795; constexpr uint32_t height_marker_neg_58_i = 2796; constexpr uint32_t height_marker_neg_57_i = 2797; constexpr uint32_t height_marker_neg_56_i = 2798; constexpr uint32_t height_marker_neg_55_i = 2799; constexpr uint32_t height_marker_neg_54_i = 2800; constexpr uint32_t height_marker_neg_53_i = 2801; constexpr uint32_t height_marker_neg_52_i = 2802; constexpr uint32_t height_marker_neg_51_i = 2803; constexpr uint32_t height_marker_neg_50_i = 2804; constexpr uint32_t height_marker_neg_49_i = 2805; constexpr uint32_t height_marker_neg_48_i = 2806; constexpr uint32_t height_marker_neg_47_i = 2807; constexpr uint32_t height_marker_neg_46_i = 2808; constexpr uint32_t height_marker_neg_45_i = 2809; constexpr uint32_t height_marker_neg_44_i = 2810; constexpr uint32_t height_marker_neg_43_i = 2811; constexpr uint32_t height_marker_neg_42_i = 2812; constexpr uint32_t height_marker_neg_41_i = 2813; constexpr uint32_t height_marker_neg_40_i = 2814; constexpr uint32_t height_marker_neg_39_i = 2815; constexpr uint32_t height_marker_neg_38_i = 2816; constexpr uint32_t height_marker_neg_37_i = 2817; constexpr uint32_t height_marker_neg_36_i = 2818; constexpr uint32_t height_marker_neg_35_i = 2819; constexpr uint32_t height_marker_neg_34_i = 2820; constexpr uint32_t height_marker_neg_33_i = 2821; constexpr uint32_t height_marker_neg_32_i = 2822; constexpr uint32_t height_marker_neg_31_i = 2823; constexpr uint32_t height_marker_neg_30_i = 2824; constexpr uint32_t height_marker_neg_29_i = 2825; constexpr uint32_t height_marker_neg_28_i = 2826; constexpr uint32_t height_marker_neg_27_i = 2827; constexpr uint32_t height_marker_neg_26_i = 2828; constexpr uint32_t height_marker_neg_25_i = 2829; constexpr uint32_t height_marker_neg_24_i = 2830; constexpr uint32_t height_marker_neg_23_i = 2831; constexpr uint32_t height_marker_neg_22_i = 2832; constexpr uint32_t height_marker_neg_21_i = 2833; constexpr uint32_t height_marker_neg_20_i = 2834; constexpr uint32_t height_marker_neg_19_i = 2835; constexpr uint32_t height_marker_neg_18_i = 2836; constexpr uint32_t height_marker_neg_17_i = 2837; constexpr uint32_t height_marker_neg_16_i = 2838; constexpr uint32_t height_marker_neg_15_i = 2839; constexpr uint32_t height_marker_neg_14_i = 2840; constexpr uint32_t height_marker_neg_13_i = 2841; constexpr uint32_t height_marker_neg_12_i = 2842; constexpr uint32_t height_marker_neg_11_i = 2843; constexpr uint32_t height_marker_neg_10_i = 2844; constexpr uint32_t height_marker_neg_9_i = 2845; constexpr uint32_t height_marker_neg_8_i = 2846; constexpr uint32_t height_marker_neg_7_i = 2847; constexpr uint32_t height_marker_neg_6_i = 2848; constexpr uint32_t height_marker_neg_5_i = 2849; constexpr uint32_t height_marker_neg_4_i = 2850; constexpr uint32_t height_marker_neg_3_i = 2851; constexpr uint32_t height_marker_neg_2_i = 2852; constexpr uint32_t height_marker_neg_1_i = 2853; constexpr uint32_t height_marker_0_i = 2854; constexpr uint32_t height_marker_1_i = 2855; constexpr uint32_t height_marker_2_i = 2856; constexpr uint32_t height_marker_3_i = 2857; constexpr uint32_t height_marker_4_i = 2858; constexpr uint32_t height_marker_5_i = 2859; constexpr uint32_t height_marker_6_i = 2860; constexpr uint32_t height_marker_7_i = 2861; constexpr uint32_t height_marker_8_i = 2862; constexpr uint32_t height_marker_9_i = 2863; constexpr uint32_t height_marker_10_i = 2864; constexpr uint32_t height_marker_11_i = 2865; constexpr uint32_t height_marker_12_i = 2866; constexpr uint32_t height_marker_13_i = 2867; constexpr uint32_t height_marker_14_i = 2868; constexpr uint32_t height_marker_15_i = 2869; constexpr uint32_t height_marker_16_i = 2870; constexpr uint32_t height_marker_17_i = 2871; constexpr uint32_t height_marker_18_i = 2872; constexpr uint32_t height_marker_19_i = 2873; constexpr uint32_t height_marker_20_i = 2874; constexpr uint32_t height_marker_21_i = 2875; constexpr uint32_t height_marker_22_i = 2876; constexpr uint32_t height_marker_23_i = 2877; constexpr uint32_t height_marker_24_i = 2878; constexpr uint32_t height_marker_25_i = 2879; constexpr uint32_t height_marker_26_i = 2880; constexpr uint32_t height_marker_27_i = 2881; constexpr uint32_t height_marker_28_i = 2882; constexpr uint32_t height_marker_29_i = 2883; constexpr uint32_t height_marker_30_i = 2884; constexpr uint32_t height_marker_31_i = 2885; constexpr uint32_t height_marker_32_i = 2886; constexpr uint32_t height_marker_33_i = 2887; constexpr uint32_t height_marker_34_i = 2888; constexpr uint32_t height_marker_35_i = 2889; constexpr uint32_t height_marker_36_i = 2890; constexpr uint32_t height_marker_37_i = 2891; constexpr uint32_t height_marker_38_i = 2892; constexpr uint32_t height_marker_39_i = 2893; constexpr uint32_t height_marker_40_i = 2894; constexpr uint32_t height_marker_41_i = 2895; constexpr uint32_t height_marker_42_i = 2896; constexpr uint32_t height_marker_43_i = 2897; constexpr uint32_t height_marker_44_i = 2898; constexpr uint32_t height_marker_45_i = 2899; constexpr uint32_t height_marker_46_i = 2900; constexpr uint32_t height_marker_47_i = 2901; constexpr uint32_t height_marker_48_i = 2902; constexpr uint32_t height_marker_49_i = 2903; constexpr uint32_t height_marker_50_i = 2904; constexpr uint32_t height_marker_51_i = 2905; constexpr uint32_t height_marker_52_i = 2906; constexpr uint32_t height_marker_53_i = 2907; constexpr uint32_t height_marker_54_i = 2908; constexpr uint32_t height_marker_55_i = 2909; constexpr uint32_t height_marker_56_i = 2910; constexpr uint32_t height_marker_57_i = 2911; constexpr uint32_t height_marker_58_i = 2912; constexpr uint32_t height_marker_59_i = 2913; constexpr uint32_t height_marker_60_i = 2914; constexpr uint32_t height_marker_61_i = 2915; constexpr uint32_t height_marker_62_i = 2916; constexpr uint32_t height_marker_63_i = 2917; constexpr uint32_t height_marker_64_i = 2918; constexpr uint32_t height_marker_65_i = 2919; constexpr uint32_t height_marker_66_i = 2920; constexpr uint32_t height_marker_67_i = 2921; constexpr uint32_t height_marker_68_i = 2922; constexpr uint32_t height_marker_69_i = 2923; constexpr uint32_t height_marker_70_i = 2924; constexpr uint32_t height_marker_71_i = 2925; constexpr uint32_t height_marker_72_i = 2926; constexpr uint32_t height_marker_73_i = 2927; constexpr uint32_t height_marker_74_i = 2928; constexpr uint32_t height_marker_75_i = 2929; constexpr uint32_t height_marker_76_i = 2930; constexpr uint32_t height_marker_77_i = 2931; constexpr uint32_t height_marker_78_i = 2932; constexpr uint32_t height_marker_79_i = 2933; constexpr uint32_t height_marker_80_i = 2934; constexpr uint32_t height_marker_81_i = 2935; constexpr uint32_t height_marker_82_i = 2936; constexpr uint32_t height_marker_83_i = 2937; constexpr uint32_t height_marker_84_i = 2938; constexpr uint32_t height_marker_85_i = 2939; constexpr uint32_t height_marker_86_i = 2940; constexpr uint32_t height_marker_87_i = 2941; constexpr uint32_t height_marker_88_i = 2942; constexpr uint32_t height_marker_89_i = 2943; constexpr uint32_t height_marker_90_i = 2944; constexpr uint32_t height_marker_91_i = 2945; constexpr uint32_t height_marker_92_i = 2946; constexpr uint32_t height_marker_93_i = 2947; constexpr uint32_t height_marker_94_i = 2948; constexpr uint32_t height_marker_95_i = 2949; constexpr uint32_t height_marker_96_i = 2950; constexpr uint32_t height_marker_97_i = 2951; constexpr uint32_t height_marker_98_i = 2952; constexpr uint32_t height_marker_99_i = 2953; constexpr uint32_t height_marker_100_i = 2954; constexpr uint32_t height_marker_101_i = 2955; constexpr uint32_t height_marker_102_i = 2956; constexpr uint32_t height_marker_103_i = 2957; constexpr uint32_t height_marker_104_i = 2958; constexpr uint32_t height_marker_105_i = 2959; constexpr uint32_t height_marker_106_i = 2960; constexpr uint32_t height_marker_107_i = 2961; constexpr uint32_t height_marker_108_i = 2962; constexpr uint32_t height_marker_109_i = 2963; constexpr uint32_t height_marker_110_i = 2964; constexpr uint32_t height_marker_111_i = 2965; constexpr uint32_t height_marker_112_i = 2966; constexpr uint32_t height_marker_113_i = 2967; constexpr uint32_t height_marker_114_i = 2968; constexpr uint32_t height_marker_115_i = 2969; constexpr uint32_t height_marker_116_i = 2970; constexpr uint32_t height_marker_117_i = 2971; constexpr uint32_t height_marker_118_i = 2972; constexpr uint32_t height_marker_119_i = 2973; constexpr uint32_t height_marker_120_i = 2974; constexpr uint32_t height_marker_121_i = 2975; constexpr uint32_t height_marker_122_i = 2976; constexpr uint32_t height_marker_123_i = 2977; constexpr uint32_t height_marker_124_i = 2978; constexpr uint32_t height_marker_125_i = 2979; constexpr uint32_t height_marker_126_i = 2980; constexpr uint32_t height_marker_127_i = 2981; constexpr uint32_t height_marker_neg_128_m = 2982; constexpr uint32_t height_marker_neg_127_m = 2983; constexpr uint32_t height_marker_neg_126_m = 2984; constexpr uint32_t height_marker_neg_125_m = 2985; constexpr uint32_t height_marker_neg_124_m = 2986; constexpr uint32_t height_marker_neg_123_m = 2987; constexpr uint32_t height_marker_neg_122_m = 2988; constexpr uint32_t height_marker_neg_121_m = 2989; constexpr uint32_t height_marker_neg_120_m = 2990; constexpr uint32_t height_marker_neg_119_m = 2991; constexpr uint32_t height_marker_neg_118_m = 2992; constexpr uint32_t height_marker_neg_117_m = 2993; constexpr uint32_t height_marker_neg_116_m = 2994; constexpr uint32_t height_marker_neg_115_m = 2995; constexpr uint32_t height_marker_neg_114_m = 2996; constexpr uint32_t height_marker_neg_113_m = 2997; constexpr uint32_t height_marker_neg_112_m = 2998; constexpr uint32_t height_marker_neg_111_m = 2999; constexpr uint32_t height_marker_neg_110_m = 3000; constexpr uint32_t height_marker_neg_109_m = 3001; constexpr uint32_t height_marker_neg_108_m = 3002; constexpr uint32_t height_marker_neg_107_m = 3003; constexpr uint32_t height_marker_neg_106_m = 3004; constexpr uint32_t height_marker_neg_105_m = 3005; constexpr uint32_t height_marker_neg_104_m = 3006; constexpr uint32_t height_marker_neg_103_m = 3007; constexpr uint32_t height_marker_neg_102_m = 3008; constexpr uint32_t height_marker_neg_101_m = 3009; constexpr uint32_t height_marker_neg_100_m = 3010; constexpr uint32_t height_marker_neg_99_m = 3011; constexpr uint32_t height_marker_neg_98_m = 3012; constexpr uint32_t height_marker_neg_97_m = 3013; constexpr uint32_t height_marker_neg_96_m = 3014; constexpr uint32_t height_marker_neg_95_m = 3015; constexpr uint32_t height_marker_neg_94_m = 3016; constexpr uint32_t height_marker_neg_93_m = 3017; constexpr uint32_t height_marker_neg_92_m = 3018; constexpr uint32_t height_marker_neg_91_m = 3019; constexpr uint32_t height_marker_neg_90_m = 3020; constexpr uint32_t height_marker_neg_89_m = 3021; constexpr uint32_t height_marker_neg_88_m = 3022; constexpr uint32_t height_marker_neg_87_m = 3023; constexpr uint32_t height_marker_neg_86_m = 3024; constexpr uint32_t height_marker_neg_85_m = 3025; constexpr uint32_t height_marker_neg_84_m = 3026; constexpr uint32_t height_marker_neg_83_m = 3027; constexpr uint32_t height_marker_neg_82_m = 3028; constexpr uint32_t height_marker_neg_81_m = 3029; constexpr uint32_t height_marker_neg_80_m = 3030; constexpr uint32_t height_marker_neg_79_m = 3031; constexpr uint32_t height_marker_neg_78_m = 3032; constexpr uint32_t height_marker_neg_77_m = 3033; constexpr uint32_t height_marker_neg_76_m = 3034; constexpr uint32_t height_marker_neg_75_m = 3035; constexpr uint32_t height_marker_neg_74_m = 3036; constexpr uint32_t height_marker_neg_73_m = 3037; constexpr uint32_t height_marker_neg_72_m = 3038; constexpr uint32_t height_marker_neg_71_m = 3039; constexpr uint32_t height_marker_neg_70_m = 3040; constexpr uint32_t height_marker_neg_69_m = 3041; constexpr uint32_t height_marker_neg_68_m = 3042; constexpr uint32_t height_marker_neg_67_m = 3043; constexpr uint32_t height_marker_neg_66_m = 3044; constexpr uint32_t height_marker_neg_65_m = 3045; constexpr uint32_t height_marker_neg_64_m = 3046; constexpr uint32_t height_marker_neg_63_m = 3047; constexpr uint32_t height_marker_neg_62_m = 3048; constexpr uint32_t height_marker_neg_61_m = 3049; constexpr uint32_t height_marker_neg_60_m = 3050; constexpr uint32_t height_marker_neg_59_m = 3051; constexpr uint32_t height_marker_neg_58_m = 3052; constexpr uint32_t height_marker_neg_57_m = 3053; constexpr uint32_t height_marker_neg_56_m = 3054; constexpr uint32_t height_marker_neg_55_m = 3055; constexpr uint32_t height_marker_neg_54_m = 3056; constexpr uint32_t height_marker_neg_53_m = 3057; constexpr uint32_t height_marker_neg_52_m = 3058; constexpr uint32_t height_marker_neg_51_m = 3059; constexpr uint32_t height_marker_neg_50_m = 3060; constexpr uint32_t height_marker_neg_49_m = 3061; constexpr uint32_t height_marker_neg_48_m = 3062; constexpr uint32_t height_marker_neg_47_m = 3063; constexpr uint32_t height_marker_neg_46_m = 3064; constexpr uint32_t height_marker_neg_45_m = 3065; constexpr uint32_t height_marker_neg_44_m = 3066; constexpr uint32_t height_marker_neg_43_m = 3067; constexpr uint32_t height_marker_neg_42_m = 3068; constexpr uint32_t height_marker_neg_41_m = 3069; constexpr uint32_t height_marker_neg_40_m = 3070; constexpr uint32_t height_marker_neg_39_m = 3071; constexpr uint32_t height_marker_neg_38_m = 3072; constexpr uint32_t height_marker_neg_37_m = 3073; constexpr uint32_t height_marker_neg_36_m = 3074; constexpr uint32_t height_marker_neg_35_m = 3075; constexpr uint32_t height_marker_neg_34_m = 3076; constexpr uint32_t height_marker_neg_33_m = 3077; constexpr uint32_t height_marker_neg_32_m = 3078; constexpr uint32_t height_marker_neg_31_m = 3079; constexpr uint32_t height_marker_neg_30_m = 3080; constexpr uint32_t height_marker_neg_29_m = 3081; constexpr uint32_t height_marker_neg_28_m = 3082; constexpr uint32_t height_marker_neg_27_m = 3083; constexpr uint32_t height_marker_neg_26_m = 3084; constexpr uint32_t height_marker_neg_25_m = 3085; constexpr uint32_t height_marker_neg_24_m = 3086; constexpr uint32_t height_marker_neg_23_m = 3087; constexpr uint32_t height_marker_neg_22_m = 3088; constexpr uint32_t height_marker_neg_21_m = 3089; constexpr uint32_t height_marker_neg_20_m = 3090; constexpr uint32_t height_marker_neg_19_m = 3091; constexpr uint32_t height_marker_neg_18_m = 3092; constexpr uint32_t height_marker_neg_17_m = 3093; constexpr uint32_t height_marker_neg_16_m = 3094; constexpr uint32_t height_marker_neg_15_m = 3095; constexpr uint32_t height_marker_neg_14_m = 3096; constexpr uint32_t height_marker_neg_13_m = 3097; constexpr uint32_t height_marker_neg_12_m = 3098; constexpr uint32_t height_marker_neg_11_m = 3099; constexpr uint32_t height_marker_neg_10_m = 3100; constexpr uint32_t height_marker_neg_9_m = 3101; constexpr uint32_t height_marker_neg_8_m = 3102; constexpr uint32_t height_marker_neg_7_m = 3103; constexpr uint32_t height_marker_neg_6_m = 3104; constexpr uint32_t height_marker_neg_5_m = 3105; constexpr uint32_t height_marker_neg_4_m = 3106; constexpr uint32_t height_marker_neg_3_m = 3107; constexpr uint32_t height_marker_neg_2_m = 3108; constexpr uint32_t height_marker_neg_1_m = 3109; constexpr uint32_t height_marker_0_m = 3110; constexpr uint32_t height_marker_1_m = 3111; constexpr uint32_t height_marker_2_m = 3112; constexpr uint32_t height_marker_3_m = 3113; constexpr uint32_t height_marker_4_m = 3114; constexpr uint32_t height_marker_5_m = 3115; constexpr uint32_t height_marker_6_m = 3116; constexpr uint32_t height_marker_7_m = 3117; constexpr uint32_t height_marker_8_m = 3118; constexpr uint32_t height_marker_9_m = 3119; constexpr uint32_t height_marker_10_m = 3120; constexpr uint32_t height_marker_11_m = 3121; constexpr uint32_t height_marker_12_m = 3122; constexpr uint32_t height_marker_13_m = 3123; constexpr uint32_t height_marker_14_m = 3124; constexpr uint32_t height_marker_15_m = 3125; constexpr uint32_t height_marker_16_m = 3126; constexpr uint32_t height_marker_17_m = 3127; constexpr uint32_t height_marker_18_m = 3128; constexpr uint32_t height_marker_19_m = 3129; constexpr uint32_t height_marker_20_m = 3130; constexpr uint32_t height_marker_21_m = 3131; constexpr uint32_t height_marker_22_m = 3132; constexpr uint32_t height_marker_23_m = 3133; constexpr uint32_t height_marker_24_m = 3134; constexpr uint32_t height_marker_25_m = 3135; constexpr uint32_t height_marker_26_m = 3136; constexpr uint32_t height_marker_27_m = 3137; constexpr uint32_t height_marker_28_m = 3138; constexpr uint32_t height_marker_29_m = 3139; constexpr uint32_t height_marker_30_m = 3140; constexpr uint32_t height_marker_31_m = 3141; constexpr uint32_t height_marker_32_m = 3142; constexpr uint32_t height_marker_33_m = 3143; constexpr uint32_t height_marker_34_m = 3144; constexpr uint32_t height_marker_35_m = 3145; constexpr uint32_t height_marker_36_m = 3146; constexpr uint32_t height_marker_37_m = 3147; constexpr uint32_t height_marker_38_m = 3148; constexpr uint32_t height_marker_39_m = 3149; constexpr uint32_t height_marker_40_m = 3150; constexpr uint32_t height_marker_41_m = 3151; constexpr uint32_t height_marker_42_m = 3152; constexpr uint32_t height_marker_43_m = 3153; constexpr uint32_t height_marker_44_m = 3154; constexpr uint32_t height_marker_45_m = 3155; constexpr uint32_t height_marker_46_m = 3156; constexpr uint32_t height_marker_47_m = 3157; constexpr uint32_t height_marker_48_m = 3158; constexpr uint32_t height_marker_49_m = 3159; constexpr uint32_t height_marker_50_m = 3160; constexpr uint32_t height_marker_51_m = 3161; constexpr uint32_t height_marker_52_m = 3162; constexpr uint32_t height_marker_53_m = 3163; constexpr uint32_t height_marker_54_m = 3164; constexpr uint32_t height_marker_55_m = 3165; constexpr uint32_t height_marker_56_m = 3166; constexpr uint32_t height_marker_57_m = 3167; constexpr uint32_t height_marker_58_m = 3168; constexpr uint32_t height_marker_59_m = 3169; constexpr uint32_t height_marker_60_m = 3170; constexpr uint32_t height_marker_61_m = 3171; constexpr uint32_t height_marker_62_m = 3172; constexpr uint32_t height_marker_63_m = 3173; constexpr uint32_t height_marker_64_m = 3174; constexpr uint32_t height_marker_65_m = 3175; constexpr uint32_t height_marker_66_m = 3176; constexpr uint32_t height_marker_67_m = 3177; constexpr uint32_t height_marker_68_m = 3178; constexpr uint32_t height_marker_69_m = 3179; constexpr uint32_t height_marker_70_m = 3180; constexpr uint32_t height_marker_71_m = 3181; constexpr uint32_t height_marker_72_m = 3182; constexpr uint32_t height_marker_73_m = 3183; constexpr uint32_t height_marker_74_m = 3184; constexpr uint32_t height_marker_75_m = 3185; constexpr uint32_t height_marker_76_m = 3186; constexpr uint32_t height_marker_77_m = 3187; constexpr uint32_t height_marker_78_m = 3188; constexpr uint32_t height_marker_79_m = 3189; constexpr uint32_t height_marker_80_m = 3190; constexpr uint32_t height_marker_81_m = 3191; constexpr uint32_t height_marker_82_m = 3192; constexpr uint32_t height_marker_83_m = 3193; constexpr uint32_t height_marker_84_m = 3194; constexpr uint32_t height_marker_85_m = 3195; constexpr uint32_t height_marker_86_m = 3196; constexpr uint32_t height_marker_87_m = 3197; constexpr uint32_t height_marker_88_m = 3198; constexpr uint32_t height_marker_89_m = 3199; constexpr uint32_t height_marker_90_m = 3200; constexpr uint32_t height_marker_91_m = 3201; constexpr uint32_t height_marker_92_m = 3202; constexpr uint32_t height_marker_93_m = 3203; constexpr uint32_t height_marker_94_m = 3204; constexpr uint32_t height_marker_95_m = 3205; constexpr uint32_t height_marker_96_m = 3206; constexpr uint32_t height_marker_97_m = 3207; constexpr uint32_t height_marker_98_m = 3208; constexpr uint32_t height_marker_99_m = 3209; constexpr uint32_t height_marker_100_m = 3210; constexpr uint32_t height_marker_101_m = 3211; constexpr uint32_t height_marker_102_m = 3212; constexpr uint32_t height_marker_103_m = 3213; constexpr uint32_t height_marker_104_m = 3214; constexpr uint32_t height_marker_105_m = 3215; constexpr uint32_t height_marker_106_m = 3216; constexpr uint32_t height_marker_107_m = 3217; constexpr uint32_t height_marker_108_m = 3218; constexpr uint32_t height_marker_109_m = 3219; constexpr uint32_t height_marker_110_m = 3220; constexpr uint32_t height_marker_111_m = 3221; constexpr uint32_t height_marker_112_m = 3222; constexpr uint32_t height_marker_113_m = 3223; constexpr uint32_t height_marker_114_m = 3224; constexpr uint32_t height_marker_115_m = 3225; constexpr uint32_t height_marker_116_m = 3226; constexpr uint32_t height_marker_117_m = 3227; constexpr uint32_t height_marker_118_m = 3228; constexpr uint32_t height_marker_119_m = 3229; constexpr uint32_t height_marker_120_m = 3230; constexpr uint32_t height_marker_121_m = 3231; constexpr uint32_t height_marker_122_m = 3232; constexpr uint32_t height_marker_123_m = 3233; constexpr uint32_t height_marker_124_m = 3234; constexpr uint32_t height_marker_125_m = 3235; constexpr uint32_t height_marker_126_m = 3236; constexpr uint32_t height_marker_127_m = 3237; constexpr uint32_t number_circle_00 = 3238; constexpr uint32_t number_circle_01 = 3239; constexpr uint32_t number_circle_02 = 3240; constexpr uint32_t number_circle_03 = 3241; constexpr uint32_t number_circle_04 = 3242; constexpr uint32_t number_circle_05 = 3243; constexpr uint32_t number_circle_06 = 3244; constexpr uint32_t number_circle_07 = 3245; constexpr uint32_t number_circle_08 = 3246; constexpr uint32_t number_circle_09 = 3247; constexpr uint32_t number_circle_10 = 3248; constexpr uint32_t number_circle_11 = 3249; constexpr uint32_t number_circle_12 = 3250; constexpr uint32_t number_circle_13 = 3251; constexpr uint32_t number_circle_14 = 3252; constexpr uint32_t number_circle_15 = 3253; constexpr uint32_t number_circle_16 = 3254; constexpr uint32_t number_circle_17 = 3255; constexpr uint32_t number_circle_18 = 3256; constexpr uint32_t number_circle_19 = 3257; constexpr uint32_t number_circle_20 = 3258; constexpr uint32_t number_circle_21 = 3259; constexpr uint32_t number_circle_22 = 3260; constexpr uint32_t number_circle_23 = 3261; constexpr uint32_t number_circle_24 = 3262; constexpr uint32_t number_circle_25 = 3263; constexpr uint32_t number_circle_26 = 3264; constexpr uint32_t number_circle_27 = 3265; constexpr uint32_t number_circle_28 = 3266; constexpr uint32_t number_circle_29 = 3267; constexpr uint32_t number_circle_30 = 3268; constexpr uint32_t number_circle_31 = 3269; constexpr uint32_t number_circle_32 = 3270; constexpr uint32_t number_circle_33 = 3271; constexpr uint32_t number_circle_34 = 3272; constexpr uint32_t number_circle_35 = 3273; constexpr uint32_t number_circle_36 = 3274; constexpr uint32_t number_circle_37 = 3275; constexpr uint32_t number_circle_38 = 3276; constexpr uint32_t number_circle_39 = 3277; constexpr uint32_t number_circle_40 = 3278; constexpr uint32_t number_circle_41 = 3279; constexpr uint32_t number_circle_42 = 3280; constexpr uint32_t number_circle_43 = 3281; constexpr uint32_t number_circle_44 = 3282; constexpr uint32_t number_circle_45 = 3283; constexpr uint32_t number_circle_46 = 3284; constexpr uint32_t number_circle_47 = 3285; constexpr uint32_t number_circle_48 = 3286; constexpr uint32_t number_circle_49 = 3287; constexpr uint32_t number_circle_50 = 3288; constexpr uint32_t number_circle_51 = 3289; constexpr uint32_t number_circle_52 = 3290; constexpr uint32_t number_circle_53 = 3291; constexpr uint32_t number_circle_54 = 3292; constexpr uint32_t number_circle_55 = 3293; constexpr uint32_t number_circle_56 = 3294; constexpr uint32_t number_circle_57 = 3295; constexpr uint32_t number_circle_58 = 3296; constexpr uint32_t number_circle_59 = 3297; constexpr uint32_t number_circle_60 = 3298; constexpr uint32_t number_circle_61 = 3299; constexpr uint32_t number_circle_62 = 3300; constexpr uint32_t number_circle_63 = 3301; constexpr uint32_t vehicle_crash_0_00 = 3302; constexpr uint32_t vehicle_crash_0_01 = 3303; constexpr uint32_t vehicle_crash_0_02 = 3304; constexpr uint32_t vehicle_crash_0_03 = 3305; constexpr uint32_t vehicle_crash_0_04 = 3306; constexpr uint32_t vehicle_crash_0_05 = 3307; constexpr uint32_t vehicle_crash_0_06 = 3308; constexpr uint32_t vehicle_crash_0_07 = 3309; constexpr uint32_t vehicle_crash_0_08 = 3310; constexpr uint32_t vehicle_crash_0_09 = 3311; constexpr uint32_t vehicle_crash_0_10 = 3312; constexpr uint32_t vehicle_crash_0_11 = 3313; constexpr uint32_t vehicle_crash_1_00 = 3314; constexpr uint32_t vehicle_crash_1_01 = 3315; constexpr uint32_t vehicle_crash_1_02 = 3316; constexpr uint32_t vehicle_crash_1_03 = 3317; constexpr uint32_t vehicle_crash_1_04 = 3318; constexpr uint32_t vehicle_crash_1_05 = 3319; constexpr uint32_t vehicle_crash_1_06 = 3320; constexpr uint32_t vehicle_crash_1_07 = 3321; constexpr uint32_t vehicle_crash_1_08 = 3322; constexpr uint32_t vehicle_crash_1_09 = 3323; constexpr uint32_t vehicle_crash_1_10 = 3324; constexpr uint32_t vehicle_crash_1_11 = 3325; constexpr uint32_t vehicle_crash_2_00 = 3326; constexpr uint32_t vehicle_crash_2_01 = 3327; constexpr uint32_t vehicle_crash_2_02 = 3328; constexpr uint32_t vehicle_crash_2_03 = 3329; constexpr uint32_t vehicle_crash_2_04 = 3330; constexpr uint32_t vehicle_crash_2_05 = 3331; constexpr uint32_t vehicle_crash_2_06 = 3332; constexpr uint32_t vehicle_crash_2_07 = 3333; constexpr uint32_t vehicle_crash_2_08 = 3334; constexpr uint32_t vehicle_crash_2_09 = 3335; constexpr uint32_t vehicle_crash_2_10 = 3336; constexpr uint32_t vehicle_crash_2_11 = 3337; constexpr uint32_t vehicle_crash_3_00 = 3338; constexpr uint32_t vehicle_crash_3_01 = 3339; constexpr uint32_t vehicle_crash_3_02 = 3340; constexpr uint32_t vehicle_crash_3_03 = 3341; constexpr uint32_t vehicle_crash_3_04 = 3342; constexpr uint32_t vehicle_crash_3_05 = 3343; constexpr uint32_t vehicle_crash_3_06 = 3344; constexpr uint32_t vehicle_crash_3_07 = 3345; constexpr uint32_t vehicle_crash_3_08 = 3346; constexpr uint32_t vehicle_crash_3_09 = 3347; constexpr uint32_t vehicle_crash_3_10 = 3348; constexpr uint32_t vehicle_crash_3_11 = 3349; constexpr uint32_t vehicle_crash_4_00 = 3350; constexpr uint32_t vehicle_crash_4_01 = 3351; constexpr uint32_t vehicle_crash_4_02 = 3352; constexpr uint32_t vehicle_crash_4_03 = 3353; constexpr uint32_t vehicle_crash_4_04 = 3354; constexpr uint32_t vehicle_crash_4_05 = 3355; constexpr uint32_t vehicle_crash_4_06 = 3356; constexpr uint32_t vehicle_crash_4_07 = 3357; constexpr uint32_t vehicle_crash_4_08 = 3358; constexpr uint32_t vehicle_crash_4_09 = 3359; constexpr uint32_t vehicle_crash_4_10 = 3360; constexpr uint32_t vehicle_crash_4_11 = 3361; constexpr uint32_t explosion_smoke_00 = 3362; constexpr uint32_t explosion_smoke_01 = 3363; constexpr uint32_t explosion_smoke_02 = 3364; constexpr uint32_t explosion_smoke_03 = 3365; constexpr uint32_t explosion_smoke_04 = 3366; constexpr uint32_t explosion_smoke_05 = 3367; constexpr uint32_t explosion_smoke_06 = 3368; constexpr uint32_t explosion_smoke_07 = 3369; constexpr uint32_t explosion_smoke_08 = 3370; constexpr uint32_t explosion_smoke_09 = 3371; constexpr uint32_t explosion_cloud_00 = 3372; constexpr uint32_t explosion_cloud_01 = 3373; constexpr uint32_t explosion_cloud_02 = 3374; constexpr uint32_t explosion_cloud_03 = 3375; constexpr uint32_t explosion_cloud_04 = 3376; constexpr uint32_t explosion_cloud_05 = 3377; constexpr uint32_t explosion_cloud_06 = 3378; constexpr uint32_t explosion_cloud_07 = 3379; constexpr uint32_t explosion_cloud_08 = 3380; constexpr uint32_t explosion_cloud_09 = 3381; constexpr uint32_t explosion_cloud_10 = 3382; constexpr uint32_t explosion_cloud_11 = 3383; constexpr uint32_t explosion_cloud_12 = 3384; constexpr uint32_t explosion_cloud_13 = 3385; constexpr uint32_t explosion_cloud_14 = 3386; constexpr uint32_t explosion_cloud_15 = 3387; constexpr uint32_t explosion_cloud_16 = 3388; constexpr uint32_t explosion_cloud_17 = 3389; constexpr uint32_t fireball_00 = 3390; constexpr uint32_t fireball_01 = 3391; constexpr uint32_t fireball_02 = 3392; constexpr uint32_t fireball_03 = 3393; constexpr uint32_t fireball_04 = 3394; constexpr uint32_t fireball_05 = 3395; constexpr uint32_t fireball_06 = 3396; constexpr uint32_t fireball_07 = 3397; constexpr uint32_t fireball_08 = 3398; constexpr uint32_t fireball_09 = 3399; constexpr uint32_t fireball_10 = 3400; constexpr uint32_t fireball_11 = 3401; constexpr uint32_t fireball_12 = 3402; constexpr uint32_t fireball_13 = 3403; constexpr uint32_t fireball_14 = 3404; constexpr uint32_t fireball_15 = 3405; constexpr uint32_t fireball_16 = 3406; constexpr uint32_t fireball_17 = 3407; constexpr uint32_t fireball_18 = 3408; constexpr uint32_t fireball_19 = 3409; constexpr uint32_t fireball_20 = 3410; constexpr uint32_t fireball_21 = 3411; constexpr uint32_t fireball_22 = 3412; constexpr uint32_t fireball_23 = 3413; constexpr uint32_t fireball_24 = 3414; constexpr uint32_t fireball_25 = 3415; constexpr uint32_t fireball_26 = 3416; constexpr uint32_t fireball_27 = 3417; constexpr uint32_t fireball_28 = 3418; constexpr uint32_t fireball_29 = 3419; constexpr uint32_t fireball_30 = 3420; constexpr uint32_t splash_00 = 3421; constexpr uint32_t splash_01 = 3422; constexpr uint32_t splash_02 = 3423; constexpr uint32_t splash_03 = 3424; constexpr uint32_t splash_04 = 3425; constexpr uint32_t splash_05 = 3426; constexpr uint32_t splash_06 = 3427; constexpr uint32_t splash_07 = 3428; constexpr uint32_t splash_08 = 3429; constexpr uint32_t splash_09 = 3430; constexpr uint32_t splash_10 = 3431; constexpr uint32_t splash_11 = 3432; constexpr uint32_t splash_12 = 3433; constexpr uint32_t splash_13 = 3434; constexpr uint32_t splash_14 = 3435; constexpr uint32_t splash_15 = 3436; constexpr uint32_t splash_16 = 3437; constexpr uint32_t splash_17 = 3438; constexpr uint32_t splash_18 = 3439; constexpr uint32_t splash_19 = 3440; constexpr uint32_t splash_20 = 3441; constexpr uint32_t splash_21 = 3442; constexpr uint32_t splash_22 = 3443; constexpr uint32_t splash_23 = 3444; constexpr uint32_t splash_24 = 3445; constexpr uint32_t splash_25 = 3446; constexpr uint32_t splash_26 = 3447; constexpr uint32_t splash_27 = 3448; constexpr uint32_t smoke_00 = 3465; constexpr uint32_t smoke_01 = 3466; constexpr uint32_t smoke_02 = 3467; constexpr uint32_t smoke_03 = 3468; constexpr uint32_t smoke_04 = 3469; constexpr uint32_t smoke_05 = 3470; constexpr uint32_t smoke_06 = 3471; constexpr uint32_t smoke_07 = 3472; constexpr uint32_t smoke_08 = 3473; constexpr uint32_t smoke_09 = 3474; constexpr uint32_t smoke_10 = 3475; constexpr uint32_t smoke_11 = 3476; constexpr uint32_t noise_mask_1 = 3479; // mask zero is use no masking constexpr uint32_t noise_mask_2 = 3480; constexpr uint32_t noise_mask_3 = 3481; constexpr uint32_t noise_mask_4 = 3482; constexpr uint32_t noise_mask_5 = 3483; constexpr uint32_t noise_mask_6 = 3484; constexpr uint32_t noise_mask_7 = 3485; constexpr uint32_t road_hit_test_straight_NE = 3486; constexpr uint32_t road_hit_test_straight_SW = 3487; constexpr uint32_t road_hit_test_very_small_curve_right_NE = 3488; constexpr uint32_t road_hit_test_very_small_curve_right_SE = 3489; constexpr uint32_t road_hit_test_very_small_curve_right_SW = 3490; constexpr uint32_t road_hit_test_very_small_curve_right_NW = 3491; constexpr uint32_t one_way_direction_arrow_left_lane_north_east = 3492; constexpr uint32_t one_way_direction_arrow_right_lane_south_west = 3493; constexpr uint32_t one_way_direction_arrow_left_lane_south_east = 3494; constexpr uint32_t one_way_direction_arrow_right_lane_north_east = 3495; constexpr uint32_t one_way_direction_arrow_left_lane_east = 3496; constexpr uint32_t one_way_direction_arrow_right_lane_west = 3497; constexpr uint32_t one_way_direction_arrow_left_lane_south = 3498; constexpr uint32_t one_way_direction_arrow_right_lane_north = 3499; constexpr uint32_t one_way_direction_arrow_left_lane_east_2 = 3500; constexpr uint32_t one_way_direction_arrow_right_lane_west_2 = 3501; constexpr uint32_t one_way_direction_arrow_left_lane_north_2 = 3502; constexpr uint32_t one_way_direction_arrow_right_lane_south_2 = 3503; constexpr uint32_t tab_object_settings = 3505; constexpr uint32_t tab_object_audio = 3506; constexpr uint32_t tab_object_currency = 3507; constexpr uint32_t tab_object_smoke = 3508; constexpr uint32_t tab_object_cliff = 3509; constexpr uint32_t tab_object_water = 3510; constexpr uint32_t tab_object_landscape = 3511; constexpr uint32_t tab_object_town_names = 3512; constexpr uint32_t tab_object_cargo = 3513; constexpr uint32_t tab_object_walls = 3514; constexpr uint32_t tab_object_signals = 3515; constexpr uint32_t tab_object_level_crossings = 3516; constexpr uint32_t tab_object_streetlights = 3517; constexpr uint32_t tab_object_tunnels = 3518; constexpr uint32_t tab_object_bridges = 3519; constexpr uint32_t tab_object_track_stations = 3520; constexpr uint32_t tab_object_track_mods = 3521; constexpr uint32_t tab_object_track = 3522; constexpr uint32_t tab_object_road_stations = 3523; constexpr uint32_t tab_object_road_mods = 3524; constexpr uint32_t tab_object_road = 3525; constexpr uint32_t tab_object_airports = 3526; constexpr uint32_t tab_object_docks = 3527; constexpr uint32_t tab_object_vehicles = 3528; constexpr uint32_t tab_object_trees = 3529; constexpr uint32_t tab_object_snow = 3530; constexpr uint32_t tab_object_climate = 3531; constexpr uint32_t tab_object_map = 3532; constexpr uint32_t tab_object_buildings = 3533; constexpr uint32_t tab_object_construction = 3534; constexpr uint32_t tab_object_industries = 3535; constexpr uint32_t tab_object_world = 3536; constexpr uint32_t tab_object_companies = 3537; constexpr uint32_t tab_object_scenarios = 3538; constexpr uint32_t news_background_old_left = 3539; constexpr uint32_t news_background_old_right = 3540; constexpr uint32_t news_background_new_left = 3541; constexpr uint32_t news_background_new_right = 3542; constexpr uint32_t volume_slider_track = 3543; constexpr uint32_t volume_slider_thumb = 3544; constexpr uint32_t speed_control_track = 3545; constexpr uint32_t speed_control_thumb = 3546; constexpr uint32_t title_menu_sparkle = 3547; constexpr uint32_t title_menu_save = 3548; constexpr uint32_t title_menu_lesson_l = 3549; constexpr uint32_t title_menu_lesson_a = 3550; constexpr uint32_t title_menu_lesson_p = 3551; constexpr uint32_t title_menu_globe_spin_0 = 3552; constexpr uint32_t title_menu_globe_spin_1 = 3553; constexpr uint32_t title_menu_globe_spin_2 = 3554; constexpr uint32_t title_menu_globe_spin_3 = 3555; constexpr uint32_t title_menu_globe_spin_4 = 3556; constexpr uint32_t title_menu_globe_spin_5 = 3557; constexpr uint32_t title_menu_globe_spin_6 = 3558; constexpr uint32_t title_menu_globe_spin_7 = 3559; constexpr uint32_t title_menu_globe_spin_8 = 3560; constexpr uint32_t title_menu_globe_spin_9 = 3561; constexpr uint32_t title_menu_globe_spin_10 = 3562; constexpr uint32_t title_menu_globe_spin_11 = 3563; constexpr uint32_t title_menu_globe_spin_12 = 3564; constexpr uint32_t title_menu_globe_spin_13 = 3565; constexpr uint32_t title_menu_globe_spin_14 = 3566; constexpr uint32_t title_menu_globe_spin_15 = 3567; constexpr uint32_t title_menu_globe_spin_16 = 3568; constexpr uint32_t title_menu_globe_spin_17 = 3569; constexpr uint32_t title_menu_globe_spin_18 = 3570; constexpr uint32_t title_menu_globe_spin_19 = 3571; constexpr uint32_t title_menu_globe_spin_20 = 3572; constexpr uint32_t title_menu_globe_spin_21 = 3573; constexpr uint32_t title_menu_globe_spin_22 = 3574; constexpr uint32_t title_menu_globe_spin_23 = 3575; constexpr uint32_t title_menu_globe_spin_24 = 3576; constexpr uint32_t title_menu_globe_spin_25 = 3577; constexpr uint32_t title_menu_globe_spin_26 = 3578; constexpr uint32_t title_menu_globe_spin_27 = 3579; constexpr uint32_t title_menu_globe_spin_28 = 3580; constexpr uint32_t title_menu_globe_spin_29 = 3581; constexpr uint32_t title_menu_globe_spin_30 = 3582; constexpr uint32_t title_menu_globe_spin_31 = 3583; constexpr uint32_t title_menu_globe_construct_0 = 3584; constexpr uint32_t title_menu_globe_construct_1 = 3585; constexpr uint32_t title_menu_globe_construct_2 = 3586; constexpr uint32_t title_menu_globe_construct_3 = 3587; constexpr uint32_t title_menu_globe_construct_4 = 3588; constexpr uint32_t title_menu_globe_construct_5 = 3589; constexpr uint32_t title_menu_globe_construct_6 = 3590; constexpr uint32_t title_menu_globe_construct_7 = 3591; constexpr uint32_t title_menu_globe_construct_8 = 3592; constexpr uint32_t title_menu_globe_construct_9 = 3593; constexpr uint32_t title_menu_globe_construct_10 = 3594; constexpr uint32_t title_menu_globe_construct_11 = 3595; constexpr uint32_t title_menu_globe_construct_12 = 3596; constexpr uint32_t title_menu_globe_construct_13 = 3597; constexpr uint32_t title_menu_globe_construct_14 = 3598; constexpr uint32_t title_menu_globe_construct_15 = 3599; constexpr uint32_t title_menu_globe_construct_16 = 3600; constexpr uint32_t title_menu_globe_construct_17 = 3601; constexpr uint32_t title_menu_globe_construct_18 = 3602; constexpr uint32_t title_menu_globe_construct_19 = 3603; constexpr uint32_t title_menu_globe_construct_20 = 3604; constexpr uint32_t title_menu_globe_construct_21 = 3605; constexpr uint32_t title_menu_globe_construct_22 = 3606; constexpr uint32_t title_menu_globe_construct_23 = 3607; constexpr uint32_t title_menu_globe_construct_24 = 3608; constexpr uint32_t title_menu_globe_construct_25 = 3609; constexpr uint32_t title_menu_globe_construct_26 = 3610; constexpr uint32_t title_menu_globe_construct_27 = 3611; constexpr uint32_t title_menu_globe_construct_28 = 3612; constexpr uint32_t title_menu_globe_construct_29 = 3613; constexpr uint32_t title_menu_globe_construct_30 = 3614; constexpr uint32_t title_menu_globe_construct_31 = 3615; constexpr uint32_t chris_sawyer_logo_small = 3616; constexpr uint32_t chris_sawyer_logo_intro_left = 3617; constexpr uint32_t chris_sawyer_logo_intro_right = 3618; constexpr uint32_t chris_sawyer_intro_palette = 3619; constexpr uint32_t atari_logo_intro_left = 3620; constexpr uint32_t atari_logo_intro_right = 3621; constexpr uint32_t atari_intro_palette = 3622; constexpr uint32_t atari_logo_small = UNUSED_IMG(3623); constexpr uint32_t locomotion_logo = 3624; constexpr uint32_t wide_tab = 3625; constexpr uint32_t scenario_completed_tick = 3629; constexpr uint32_t owner_jailed = 3630; constexpr uint32_t bridgeShadowFullTileSlope0 = 3631; constexpr uint32_t bridgeShadowFullTileSlope1 = 3632; constexpr uint32_t bridgeShadowFullTileSlope2 = 3633; constexpr uint32_t bridgeShadowFullTileSlope3 = 3634; constexpr uint32_t bridgeShadowFullTileSlope4 = 3635; constexpr uint32_t bridgeShadowFullTileSlope5 = 3636; constexpr uint32_t bridgeShadowFullTileSlope6 = 3637; constexpr uint32_t bridgeShadowFullTileSlope7 = 3638; constexpr uint32_t bridgeShadowFullTileSlope8 = 3639; constexpr uint32_t bridgeShadowFullTileSlope9 = 3640; constexpr uint32_t bridgeShadowFullTileSlope10 = 3641; constexpr uint32_t bridgeShadowFullTileSlope11 = 3642; constexpr uint32_t bridgeShadowFullTileSlope12 = 3643; constexpr uint32_t bridgeShadowFullTileSlope13 = 3644; constexpr uint32_t bridgeShadowFullTileSlope14 = 3645; constexpr uint32_t bridgeShadowFullTileSlope15 = 3646; constexpr uint32_t bridgeShadowFullTileSlope16 = 3647; constexpr uint32_t bridgeShadowFullTileSlope17 = 3648; constexpr uint32_t bridgeShadowFullTileSlope18 = 3649; constexpr uint32_t bridgeShadowQuarter0Slope0 = 3650; constexpr uint32_t bridgeShadowQuarter0Slope1 = 3651; constexpr uint32_t bridgeShadowQuarter0Slope2 = 3652; constexpr uint32_t bridgeShadowQuarter0Slope3 = 3653; constexpr uint32_t bridgeShadowQuarter0Slope4 = 3654; constexpr uint32_t bridgeShadowQuarter0Slope5 = 3655; constexpr uint32_t bridgeShadowQuarter0Slope6 = 3656; constexpr uint32_t bridgeShadowQuarter0Slope7 = 3657; constexpr uint32_t bridgeShadowQuarter0Slope8 = 3658; constexpr uint32_t bridgeShadowQuarter0Slope9 = 3659; constexpr uint32_t bridgeShadowQuarter0Slope10 = 3660; constexpr uint32_t bridgeShadowQuarter0Slope11 = 3661; constexpr uint32_t bridgeShadowQuarter0Slope12 = 3662; constexpr uint32_t bridgeShadowQuarter0Slope13 = 3663; constexpr uint32_t bridgeShadowQuarter0Slope14 = 3664; constexpr uint32_t bridgeShadowQuarter0Slope15 = 3665; constexpr uint32_t bridgeShadowQuarter0Slope16 = 3666; constexpr uint32_t bridgeShadowQuarter0Slope17 = 3667; constexpr uint32_t bridgeShadowQuarter0Slope18 = 3668; constexpr uint32_t bridgeShadowQuarter1Slope0 = 3669; constexpr uint32_t bridgeShadowQuarter1Slope1 = 3670; constexpr uint32_t bridgeShadowQuarter1Slope2 = 3671; constexpr uint32_t bridgeShadowQuarter1Slope3 = 3672; constexpr uint32_t bridgeShadowQuarter1Slope4 = 3673; constexpr uint32_t bridgeShadowQuarter1Slope5 = 3674; constexpr uint32_t bridgeShadowQuarter1Slope6 = 3675; constexpr uint32_t bridgeShadowQuarter1Slope7 = 3676; constexpr uint32_t bridgeShadowQuarter1Slope8 = 3677; constexpr uint32_t bridgeShadowQuarter1Slope9 = 3678; constexpr uint32_t bridgeShadowQuarter1Slope10 = 3679; constexpr uint32_t bridgeShadowQuarter1Slope11 = 3680; constexpr uint32_t bridgeShadowQuarter1Slope12 = 3681; constexpr uint32_t bridgeShadowQuarter1Slope13 = 3682; constexpr uint32_t bridgeShadowQuarter1Slope14 = 3683; constexpr uint32_t bridgeShadowQuarter1Slope15 = 3684; constexpr uint32_t bridgeShadowQuarter1Slope16 = 3685; constexpr uint32_t bridgeShadowQuarter1Slope17 = 3686; constexpr uint32_t bridgeShadowQuarter1Slope18 = 3687; constexpr uint32_t bridgeShadowQuarter2Slope0 = 3688; constexpr uint32_t bridgeShadowQuarter2Slope1 = 3689; constexpr uint32_t bridgeShadowQuarter2Slope2 = 3690; constexpr uint32_t bridgeShadowQuarter2Slope3 = 3691; constexpr uint32_t bridgeShadowQuarter2Slope4 = 3692; constexpr uint32_t bridgeShadowQuarter2Slope5 = 3693; constexpr uint32_t bridgeShadowQuarter2Slope6 = 3694; constexpr uint32_t bridgeShadowQuarter2Slope7 = 3695; constexpr uint32_t bridgeShadowQuarter2Slope8 = 3696; constexpr uint32_t bridgeShadowQuarter2Slope9 = 3697; constexpr uint32_t bridgeShadowQuarter2Slope10 = 3698; constexpr uint32_t bridgeShadowQuarter2Slope11 = 3699; constexpr uint32_t bridgeShadowQuarter2Slope12 = 3700; constexpr uint32_t bridgeShadowQuarter2Slope13 = 3701; constexpr uint32_t bridgeShadowQuarter2Slope14 = 3702; constexpr uint32_t bridgeShadowQuarter2Slope15 = 3703; constexpr uint32_t bridgeShadowQuarter2Slope16 = 3704; constexpr uint32_t bridgeShadowQuarter2Slope17 = 3705; constexpr uint32_t bridgeShadowQuarter2Slope18 = 3706; constexpr uint32_t bridgeShadowQuarter3Slope0 = 3707; constexpr uint32_t bridgeShadowQuarter3Slope1 = 3708; constexpr uint32_t bridgeShadowQuarter3Slope2 = 3709; constexpr uint32_t bridgeShadowQuarter3Slope3 = 3710; constexpr uint32_t bridgeShadowQuarter3Slope4 = 3711; constexpr uint32_t bridgeShadowQuarter3Slope5 = 3712; constexpr uint32_t bridgeShadowQuarter3Slope6 = 3713; constexpr uint32_t bridgeShadowQuarter3Slope7 = 3714; constexpr uint32_t bridgeShadowQuarter3Slope8 = 3715; constexpr uint32_t bridgeShadowQuarter3Slope9 = 3716; constexpr uint32_t bridgeShadowQuarter3Slope10 = 3617; constexpr uint32_t bridgeShadowQuarter3Slope11 = 3618; constexpr uint32_t bridgeShadowQuarter3Slope12 = 3619; constexpr uint32_t bridgeShadowQuarter3Slope13 = 3620; constexpr uint32_t bridgeShadowQuarter3Slope14 = 3621; constexpr uint32_t bridgeShadowQuarter3Slope15 = 3622; constexpr uint32_t bridgeShadowQuarter3Slope16 = 3623; constexpr uint32_t bridgeShadowQuarter3Slope17 = 3624; constexpr uint32_t bridgeShadowQuarter3Slope18 = 3625; constexpr uint32_t cliffEdge0MaskSlope0 = 3726; constexpr uint32_t cliffEdge0MaskSlope1 = 3727; constexpr uint32_t cliffEdge0MaskSlope2 = 3728; constexpr uint32_t cliffEdge0MaskSlope3 = 3729; constexpr uint32_t cliffEdge0MaskSlope4 = 3730; constexpr uint32_t cliffEdge1MaskSlope0 = 3731; constexpr uint32_t cliffEdge1MaskSlope1 = 3732; constexpr uint32_t cliffEdge1MaskSlope2 = 3733; constexpr uint32_t cliffEdge1MaskSlope3 = 3734; constexpr uint32_t cliffEdge1MaskSlope4 = 3735; constexpr uint32_t cliffEdge0UndergroundMaskSlope0 = 3736; constexpr uint32_t cliffEdge0UndergroundMaskSlope1 = 3737; constexpr uint32_t cliffEdge0UndergroundMaskSlope2 = 3738; constexpr uint32_t cliffEdge0UndergroundMaskSlope3 = 3739; constexpr uint32_t cliffEdge0UndergroundMaskSlope4 = 3740; constexpr uint32_t cliffEdge1UndergroundMaskSlope0 = 3741; constexpr uint32_t cliffEdge1UndergroundMaskSlope1 = 3742; constexpr uint32_t cliffEdge1UndergroundMaskSlope2 = 3743; constexpr uint32_t cliffEdge1UndergroundMaskSlope3 = 3744; constexpr uint32_t cliffEdge1UndergroundMaskSlope4 = 3745; constexpr uint32_t surfaceSmooth3Slope0 = 3746; constexpr uint32_t surfaceSmooth3Slope1 = 3747; constexpr uint32_t surfaceSmooth3Slope2 = 3748; constexpr uint32_t surfaceSmooth3Slope3 = 3749; constexpr uint32_t surfaceSmooth3Slope4 = 3750; constexpr uint32_t surfaceSmooth3Slope5 = 3751; constexpr uint32_t surfaceSmooth3Slope6 = 3752; constexpr uint32_t surfaceSmooth3Slope7 = 3753; constexpr uint32_t surfaceSmooth3Slope8 = 3754; constexpr uint32_t surfaceSmooth3Slope9 = 3755; constexpr uint32_t surfaceSmooth3Slope10 = 3756; constexpr uint32_t surfaceSmooth3Slope11 = 3757; constexpr uint32_t surfaceSmooth3Slope12 = 3758; constexpr uint32_t surfaceSmooth3Slope13 = 3759; constexpr uint32_t surfaceSmooth3Slope14 = 3760; constexpr uint32_t surfaceSmooth3Slope15 = 3761; constexpr uint32_t surfaceSmooth3Slope16 = 3762; constexpr uint32_t surfaceSmooth3Slope17 = 3763; constexpr uint32_t surfaceSmooth3Slope18 = 3764; constexpr uint32_t surfaceSmooth1Slope0 = 3765; constexpr uint32_t surfaceSmooth1Slope1 = 3766; constexpr uint32_t surfaceSmooth1Slope2 = 3767; constexpr uint32_t surfaceSmooth1Slope3 = 3768; constexpr uint32_t surfaceSmooth1Slope4 = 3769; constexpr uint32_t surfaceSmooth1Slope5 = 3770; constexpr uint32_t surfaceSmooth1Slope6 = 3771; constexpr uint32_t surfaceSmooth1Slope7 = 3772; constexpr uint32_t surfaceSmooth1Slope8 = 3773; constexpr uint32_t surfaceSmooth1Slope9 = 3774; constexpr uint32_t surfaceSmooth1Slope10 = 3775; constexpr uint32_t surfaceSmooth1Slope11 = 3776; constexpr uint32_t surfaceSmooth1Slope12 = 3777; constexpr uint32_t surfaceSmooth1Slope13 = 3778; constexpr uint32_t surfaceSmooth1Slope14 = 3779; constexpr uint32_t surfaceSmooth1Slope15 = 3780; constexpr uint32_t surfaceSmooth1Slope16 = 3781; constexpr uint32_t surfaceSmooth1Slope17 = 3782; constexpr uint32_t surfaceSmooth1Slope18 = 3783; constexpr uint32_t surfaceSmooth0Slope0 = 3784; constexpr uint32_t surfaceSmooth0Slope1 = 3785; constexpr uint32_t surfaceSmooth0Slope2 = 3786; constexpr uint32_t surfaceSmooth0Slope3 = 3787; constexpr uint32_t surfaceSmooth0Slope4 = 3788; constexpr uint32_t surfaceSmooth0Slope5 = 3789; constexpr uint32_t surfaceSmooth0Slope6 = 3790; constexpr uint32_t surfaceSmooth0Slope7 = 3791; constexpr uint32_t surfaceSmooth0Slope8 = 3792; constexpr uint32_t surfaceSmooth0Slope9 = 3793; constexpr uint32_t surfaceSmooth0Slope10 = 3794; constexpr uint32_t surfaceSmooth0Slope11 = 3795; constexpr uint32_t surfaceSmooth0Slope12 = 3796; constexpr uint32_t surfaceSmooth0Slope13 = 3797; constexpr uint32_t surfaceSmooth0Slope14 = 3798; constexpr uint32_t surfaceSmooth0Slope15 = 3799; constexpr uint32_t surfaceSmooth0Slope16 = 3800; constexpr uint32_t surfaceSmooth0Slope17 = 3801; constexpr uint32_t surfaceSmooth0Slope18 = 3802; constexpr uint32_t surfaceSmooth2Slope0 = 3803; constexpr uint32_t surfaceSmooth2Slope1 = 3804; constexpr uint32_t surfaceSmooth2Slope2 = 3805; constexpr uint32_t surfaceSmooth2Slope3 = 3806; constexpr uint32_t surfaceSmooth2Slope4 = 3807; constexpr uint32_t surfaceSmooth2Slope5 = 3808; constexpr uint32_t surfaceSmooth2Slope6 = 3809; constexpr uint32_t surfaceSmooth2Slope7 = 3810; constexpr uint32_t surfaceSmooth2Slope8 = 3811; constexpr uint32_t surfaceSmooth2Slope9 = 3812; constexpr uint32_t surfaceSmooth2Slope10 = 3813; constexpr uint32_t surfaceSmooth2Slope11 = 3814; constexpr uint32_t surfaceSmooth2Slope12 = 3815; constexpr uint32_t surfaceSmooth2Slope13 = 3816; constexpr uint32_t surfaceSmooth2Slope14 = 3817; constexpr uint32_t surfaceSmooth2Slope15 = 3818; constexpr uint32_t surfaceSmooth2Slope16 = 3819; constexpr uint32_t surfaceSmooth2Slope17 = 3820; constexpr uint32_t surfaceSmooth2Slope18 = 3821; constexpr uint32_t snowMaskCoverage1Slope0 = 3822; constexpr uint32_t snowMaskCoverage1Slope1 = 3823; constexpr uint32_t snowMaskCoverage1Slope2 = 3824; constexpr uint32_t snowMaskCoverage1Slope3 = 3825; constexpr uint32_t snowMaskCoverage1Slope4 = 3826; constexpr uint32_t snowMaskCoverage1Slope5 = 3827; constexpr uint32_t snowMaskCoverage1Slope6 = 3828; constexpr uint32_t snowMaskCoverage1Slope7 = 3829; constexpr uint32_t snowMaskCoverage1Slope8 = 3830; constexpr uint32_t snowMaskCoverage1Slope9 = 3831; constexpr uint32_t snowMaskCoverage1Slope10 = 3832; constexpr uint32_t snowMaskCoverage1Slope11 = 3833; constexpr uint32_t snowMaskCoverage1Slope12 = 3834; constexpr uint32_t snowMaskCoverage1Slope13 = 3835; constexpr uint32_t snowMaskCoverage1Slope14 = 3836; constexpr uint32_t snowMaskCoverage1Slope15 = 3837; constexpr uint32_t snowMaskCoverage1Slope16 = 3838; constexpr uint32_t snowMaskCoverage1Slope17 = 3839; constexpr uint32_t snowMaskCoverage1Slope18 = 3840; constexpr uint32_t snowMaskCoverage2Slope0 = 3841; constexpr uint32_t snowMaskCoverage2Slope1 = 3842; constexpr uint32_t snowMaskCoverage2Slope2 = 3843; constexpr uint32_t snowMaskCoverage2Slope3 = 3844; constexpr uint32_t snowMaskCoverage2Slope4 = 3845; constexpr uint32_t snowMaskCoverage2Slope5 = 3846; constexpr uint32_t snowMaskCoverage2Slope6 = 3847; constexpr uint32_t snowMaskCoverage2Slope7 = 3848; constexpr uint32_t snowMaskCoverage2Slope8 = 3849; constexpr uint32_t snowMaskCoverage2Slope9 = 3850; constexpr uint32_t snowMaskCoverage2Slope10 = 3851; constexpr uint32_t snowMaskCoverage2Slope11 = 3852; constexpr uint32_t snowMaskCoverage2Slope12 = 3853; constexpr uint32_t snowMaskCoverage2Slope13 = 3854; constexpr uint32_t snowMaskCoverage2Slope14 = 3855; constexpr uint32_t snowMaskCoverage2Slope15 = 3856; constexpr uint32_t snowMaskCoverage2Slope16 = 3857; constexpr uint32_t snowMaskCoverage2Slope17 = 3858; constexpr uint32_t snowMaskCoverage2Slope18 = 3859; constexpr uint32_t snowMaskCoverage3Slope0 = 3860; constexpr uint32_t snowMaskCoverage3Slope1 = 3861; constexpr uint32_t snowMaskCoverage3Slope2 = 3862; constexpr uint32_t snowMaskCoverage3Slope3 = 3863; constexpr uint32_t snowMaskCoverage3Slope4 = 3864; constexpr uint32_t snowMaskCoverage3Slope5 = 3865; constexpr uint32_t snowMaskCoverage3Slope6 = 3866; constexpr uint32_t snowMaskCoverage3Slope7 = 3867; constexpr uint32_t snowMaskCoverage3Slope8 = 3868; constexpr uint32_t snowMaskCoverage3Slope9 = 3869; constexpr uint32_t snowMaskCoverage3Slope10 = 3870; constexpr uint32_t snowMaskCoverage3Slope11 = 3871; constexpr uint32_t snowMaskCoverage3Slope12 = 3872; constexpr uint32_t snowMaskCoverage3Slope13 = 3873; constexpr uint32_t snowMaskCoverage3Slope14 = 3874; constexpr uint32_t snowMaskCoverage3Slope15 = 3875; constexpr uint32_t snowMaskCoverage3Slope16 = 3876; constexpr uint32_t snowMaskCoverage3Slope17 = 3877; constexpr uint32_t snowMaskCoverage3Slope18 = 3878; constexpr uint32_t snowMaskCoverage4Slope0 = 3879; constexpr uint32_t snowMaskCoverage4Slope1 = 3880; constexpr uint32_t snowMaskCoverage4Slope2 = 3881; constexpr uint32_t snowMaskCoverage4Slope3 = 3882; constexpr uint32_t snowMaskCoverage4Slope4 = 3883; constexpr uint32_t snowMaskCoverage4Slope5 = 3884; constexpr uint32_t snowMaskCoverage4Slope6 = 3885; constexpr uint32_t snowMaskCoverage4Slope7 = 3886; constexpr uint32_t snowMaskCoverage4Slope8 = 3887; constexpr uint32_t snowMaskCoverage4Slope9 = 3888; constexpr uint32_t snowMaskCoverage4Slope10 = 3889; constexpr uint32_t snowMaskCoverage4Slope11 = 3890; constexpr uint32_t snowMaskCoverage4Slope12 = 3891; constexpr uint32_t snowMaskCoverage4Slope13 = 3892; constexpr uint32_t snowMaskCoverage4Slope14 = 3893; constexpr uint32_t snowMaskCoverage4Slope15 = 3894; constexpr uint32_t snowMaskCoverage4Slope16 = 3895; constexpr uint32_t snowMaskCoverage4Slope17 = 3896; constexpr uint32_t snowMaskCoverage4Slope18 = 3897; constexpr uint32_t getNumberCircle(uint8_t num) { constexpr std::array numbers = { number_circle_00, number_circle_01, number_circle_02, number_circle_03, number_circle_04, number_circle_05, number_circle_06, number_circle_07, number_circle_08, number_circle_09, number_circle_10, number_circle_11, number_circle_12, number_circle_13, number_circle_14, number_circle_15, number_circle_16, number_circle_17, number_circle_18, number_circle_19, number_circle_20, number_circle_21, number_circle_22, number_circle_23, number_circle_24, number_circle_25, number_circle_26, number_circle_27, number_circle_28, number_circle_29, number_circle_30, number_circle_31, number_circle_32, number_circle_33, number_circle_34, number_circle_35, number_circle_36, number_circle_37, number_circle_38, number_circle_39, number_circle_40, number_circle_41, number_circle_42, number_circle_43, number_circle_44, number_circle_45, number_circle_46, number_circle_47, number_circle_48, number_circle_49, number_circle_50, number_circle_51, number_circle_52, number_circle_53, number_circle_54, number_circle_55, number_circle_56, number_circle_57, number_circle_58, number_circle_59, number_circle_60, number_circle_61, number_circle_62, number_circle_63, }; if (num >= numbers.size()) { return number_circle_00; } return numbers[num]; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/InvalidationGrid.cpp ```cpp #include "InvalidationGrid.h" #include <algorithm> #include <cstring> namespace OpenLoco::Gfx { uint32_t InvalidationGrid::getRowCount() const noexcept { return _rowCount; } uint32_t InvalidationGrid::getColumnCount() const noexcept { return _columnCount; } uint32_t InvalidationGrid::getBlockWidth() const noexcept { return _blockWidth; } uint32_t InvalidationGrid::getBlockHeight() const noexcept { return _blockHeight; } void InvalidationGrid::reset(int32_t width, int32_t height, uint32_t blockWidth, uint32_t blockHeight) noexcept { _blockWidth = blockWidth; _blockHeight = blockHeight; _columnCount = (width / blockWidth) + 1; _rowCount = (height / blockHeight) + 1; _screenWidth = width; _screenHeight = height; _blocks.resize(_columnCount * _rowCount); _blocks.shrink_to_fit(); // Clear the grid. std::ranges::fill(_blocks, 0x00); } void InvalidationGrid::invalidate(int32_t left, int32_t top, int32_t right, int32_t bottom) noexcept { left = std::max(left, 0); top = std::max(top, 0); right = std::min(right, static_cast<int32_t>(_screenWidth)); bottom = std::min(bottom, static_cast<int32_t>(_screenHeight)); if (left >= right) { return; } if (top >= bottom) { return; } left /= _blockWidth; right /= _blockWidth; top /= _blockHeight; bottom /= _blockHeight; // TODO: Remove this once _blocks is no longer interop wrapper. auto& blocks = _blocks; const auto columnSize = right - left + 1; for (int16_t y = top; y <= bottom; y++) { const auto yOffset = y * _columnCount; // Mark row by column size as invalidated. std::fill_n(blocks.begin() + yOffset + left, columnSize, 0xFF); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/InvalidationGrid.h ```h #pragma once #include <algorithm> #include <cstdint> #include <vector> namespace OpenLoco::Gfx { class InvalidationGrid { uint16_t _blockWidth{}; uint16_t _blockHeight{}; uint32_t _columnCount{}; uint32_t _rowCount{}; std::vector<uint8_t> _blocks; uint32_t _screenWidth{}; uint32_t _screenHeight{}; public: uint32_t getRowCount() const noexcept; uint32_t getColumnCount() const noexcept; uint32_t getBlockWidth() const noexcept; uint32_t getBlockHeight() const noexcept; void reset(int32_t width, int32_t height, uint32_t blockWidth, uint32_t blockHeight) noexcept; void invalidate(int32_t left, int32_t top, int32_t right, int32_t bottom) noexcept; template<typename F> void traverseDirtyCells(F&& func) { const auto columnCount = _columnCount; const auto rowCount = _rowCount; const auto blockWidth = _blockWidth; const auto blockHeight = _blockHeight; auto& blocks = _blocks; for (uint32_t column = 0; column < columnCount; column++) { for (uint32_t row = 0; row < rowCount; row++) { const auto rowStartOffset = row * columnCount; if (blocks[rowStartOffset + column] != 0) { uint32_t rowEndOffset = rowStartOffset; uint32_t numRowsDirty = 0; // Count amount of dirty rows at current column. while (true) { if (row + numRowsDirty + 1 >= rowCount || blocks[rowEndOffset + column + columnCount] == 0) { break; } numRowsDirty++; rowEndOffset += columnCount; } // Clear rows at the current column. for (auto rowOffset = rowStartOffset; rowOffset <= rowEndOffset; rowOffset += columnCount) { blocks[rowOffset + column] = 0; } // Convert to pixel coordinates. const auto left = column * blockWidth; const auto top = row * blockHeight; const auto right = (column + 1) * blockWidth; const auto bottom = (row + numRowsDirty + 1) * blockHeight; if (left < _screenWidth && top < _screenHeight) { func(left, top, std::min(right, _screenWidth), std::min(bottom, _screenHeight)); } } } } } }; } // namespace OpenRCT2 ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/PaletteMap.cpp ```cpp #include "PaletteMap.h" #include "Gfx.h" #include "Graphics/SoftwareDrawingEngine.h" #include "ImageIds.h" #include <OpenLoco/Interop/Interop.hpp> #include <algorithm> #include <cassert> #include <cstring> #include <numeric> using namespace OpenLoco::Interop; namespace OpenLoco::Gfx::PaletteMap { static constexpr std::array<uint32_t, enumValue(ExtColour::max)> kDefaultPaletteToG1Offset = { ImageIds::paletteMapBlack, // black ImageIds::paletteMapGrey, // grey ImageIds::paletteMapWhite, // white ImageIds::paletteMapMutedDarkPurple, // mutedDarkPurple ImageIds::paletteMapMutedPurple, // mutedPurple ImageIds::paletteMapPurple, // purple ImageIds::paletteMapDarkBlue, // darkBlue ImageIds::paletteMapBlue, // blue ImageIds::paletteMapMutedDarkTeal, // mutedDarkTeal ImageIds::paletteMapMutedTeal, // mutedTeal ImageIds::paletteMapDarkGreen, // darkGreen ImageIds::paletteMapMutedSeaGreen, // mutedSeaGreen ImageIds::paletteMapMutedGrassGreen, // mutedGrassGreen ImageIds::paletteMapGreen, // green ImageIds::paletteMapMutedAvocadoGreen, // mutedAvocadoGreen ImageIds::paletteMapMutedOliveGreen, // mutedOliveGreen ImageIds::paletteMapYellow, // yellow ImageIds::paletteMapDarkYellow, // darkYellow ImageIds::paletteMapOrange, // orange ImageIds::paletteMapAmber, // amber ImageIds::paletteMapDarkOrange, // darkOrange ImageIds::paletteMapMutedDarkYellow, // mutedDarkYellow ImageIds::paletteMapMutedYellow, // mutedYellow ImageIds::paletteMapBrown, // brown ImageIds::paletteMapMutedOrange, // mutedOrange ImageIds::paletteMapMutedDarkRed, // mutedDarkRed ImageIds::paletteMapDarkRed, // darkRed ImageIds::paletteMapRed, // red ImageIds::paletteMapDarkPink, // darkPink ImageIds::paletteMapPink, // pink ImageIds::paletteMapMutedRed, // mutedRed ImageIds::paletteMapClear, // clear 0, // water (no palette map will be loaded from water object) ImageIds::paletteMapUnk21, // unk21 ImageIds::paletteMapUnk22, // unk22 ImageIds::paletteMapUnk23, // unk23 ImageIds::paletteMapUnk24, // unk24 ImageIds::paletteMapUnk25, // unk25 ImageIds::paletteMapUnk26, // unk26 ImageIds::paletteMapUnk27, // unk27 ImageIds::paletteMapUnk28, // unk28 ImageIds::paletteMapUnk29, // unk29 ImageIds::paletteMapUnk2A, // unk2A ImageIds::paletteMapUnk2B, // unk2B ImageIds::paletteMapUnk2C, // unk2C ImageIds::paletteMapUnk2D, // unk2D ImageIds::paletteMapUnk2E, // unk2E ImageIds::paletteMapUnk2F, // unk2F ImageIds::paletteMapUnk30, // unk30 ImageIds::paletteMapUnk31, // unk31 ImageIds::paletteMapUnk32, // unk32 ImageIds::paletteMapUnk33, // unk33 ImageIds::paletteMapUnk34, // unk34 ImageIds::paletteMapTranslucentGrey1, // translucentGrey1 ImageIds::paletteMapTranslucentGrey2, // translucentGrey2 ImageIds::paletteMapTranslucentGrey0, // translucentGrey0 ImageIds::paletteMapTranslucentBlue1, // translucentBlue1 ImageIds::paletteMapTranslucentBlue2, // translucentBlue2 ImageIds::paletteMapTranslucentBlue0, // translucentBlue0 ImageIds::paletteMapTranslucentMutedDarkRed1, // translucentMutedDarkRed1 ImageIds::paletteMapTranslucentMutedDarkRed2, // translucentMutedDarkRed2 ImageIds::paletteMapTranslucentMutedDarkRed0, // translucentMutedDarkRed0 ImageIds::paletteMapTranslucentMutedSeaGreen1, // translucentMutedSeaGreen1 ImageIds::paletteMapTranslucentMutedSeaGreen2, // translucentMutedSeaGreen2 ImageIds::paletteMapTranslucentMutedSeaGreen0, // translucentMutedSeaGreen0 ImageIds::paletteMapTranslucentMutedPurple1, // translucentMutedPurple1 ImageIds::paletteMapTranslucentMutedPurple2, // translucentMutedPurple2 ImageIds::paletteMapTranslucentMutedPurple0, // translucentMutedPurple0 ImageIds::paletteMapTranslucentMutedOliveGreen1, // translucentMutedOliveGreen1 ImageIds::paletteMapTranslucentMutedOliveGreen2, // translucentMutedOliveGreen2 ImageIds::paletteMapTranslucentMutedOliveGreen0, // translucentMutedOliveGreen0 ImageIds::paletteMapTranslucentMutedYellow1, // translucentMutedYellow1 ImageIds::paletteMapTranslucentMutedYellow2, // translucentMutedYellow2 ImageIds::paletteMapTranslucentMutedYellow0, // translucentMutedYellow0 ImageIds::paletteMapTranslucentYellow1, // translucentYellow1 ImageIds::paletteMapTranslucentYellow2, // translucentYellow2 ImageIds::paletteMapTranslucentYellow0, // translucentYellow0 ImageIds::paletteMapTranslucentMutedGrassGreen1, // translucentMutedGrassGreen1 ImageIds::paletteMapTranslucentMutedGrassGreen2, // translucentMutedGrassGreen2 ImageIds::paletteMapTranslucentMutedGrassGreen0, // translucentMutedGrassGreen0 ImageIds::paletteMapTranslucentMutedAvocadoGreen1, // translucentMutedAvocadoGreen1 ImageIds::paletteMapTranslucentMutedAvocadoGreen2, // translucentMutedAvocadoGreen2 ImageIds::paletteMapTranslucentMutedAvocadoGreen0, // translucentMutedAvocadoGreen0 ImageIds::paletteMapTranslucentGreen1, // translucentGreen1 ImageIds::paletteMapTranslucentGreen2, // translucentGreen2 ImageIds::paletteMapTranslucentGreen0, // translucentGreen0 ImageIds::paletteMapTranslucentMutedOrange1, // translucentMutedOrange1 ImageIds::paletteMapTranslucentMutedOrange2, // translucentMutedOrange2 ImageIds::paletteMapTranslucentMutedOrange0, // translucentMutedOrange0 ImageIds::paletteMapTranslucentPurple1, // translucentPurple1 ImageIds::paletteMapTranslucentPurple2, // translucentPurple2 ImageIds::paletteMapTranslucentPurple0, // translucentPurple0 ImageIds::paletteMapTranslucentRed1, // translucentRed1 ImageIds::paletteMapTranslucentRed2, // translucentRed2 ImageIds::paletteMapTranslucentRed0, // translucentRed0 ImageIds::paletteMapTranslucentOrange1, // translucentOrange1 ImageIds::paletteMapTranslucentOrange2, // translucentOrange2 ImageIds::paletteMapTranslucentOrange0, // translucentOrange0 ImageIds::paletteMapTranslucentMutedTeal1, // translucentMutedTeal1 ImageIds::paletteMapTranslucentMutedTeal2, // translucentMutedTeal2 ImageIds::paletteMapTranslucentMutedTeal0, // translucentMutedTeal0 ImageIds::paletteMapTranslucentPink1, // translucentPink1 ImageIds::paletteMapTranslucentPink2, // translucentPink2 ImageIds::paletteMapTranslucentPink0, // translucentPink0 ImageIds::paletteMapTranslucentBrown1, // translucentBrown1 ImageIds::paletteMapTranslucentBrown2, // translucentBrown2 ImageIds::paletteMapTranslucentBrown0, // translucentBrown0 ImageIds::paletteMapTranslucentMutedRed1, // translucentMutedRed1 ImageIds::paletteMapTranslucentMutedRed2, // translucentMutedRed2 ImageIds::paletteMapTranslucentMutedRed0, // translucentMutedRed0 ImageIds::paletteMapTranslucentWhite1, // translucentWhite1 ImageIds::paletteMapTranslucentWhite2, // translucentWhite2 ImageIds::paletteMapTranslucentWhite0, // translucentWhite0 ImageIds::paletteMapTranslucentAmber1, // translucentAmber1 ImageIds::paletteMapTranslucentAmber2, // translucentAmber2 ImageIds::paletteMapTranslucentAmber0, // translucentAmber0 ImageIds::paletteMapUnk74, // unk74 ImageIds::paletteMapUnk75, // unk75 ImageIds::paletteMapUnk76, // unk76 ImageIds::paletteMapUnk77, // unk77 ImageIds::paletteMapUnk78, // unk78 ImageIds::paletteMapUnk79, // unk79 ImageIds::paletteMapUnk7A, // unk7A ImageIds::paletteMapUnk7B, // unk7B ImageIds::paletteMapUnk7C, // unk7C ImageIds::paletteMapUnk7D, // unk7D ImageIds::paletteMapUnk7E, // unk7E ImageIds::paletteMapUnk7F, // unk7F ImageIds::paletteMapUnk80, // unk80 ImageIds::paletteMapUnk81, // unk81 ImageIds::paletteMapUnk82, // unk82 ImageIds::paletteMapUnk83, // unk83 ImageIds::paletteMapUnk84, // unk84 ImageIds::paletteMapUnk85, // unk85 ImageIds::paletteMapUnk86, // unk86 ImageIds::paletteMapUnk87, // unk87 ImageIds::paletteMapUnk88, // unk88 ImageIds::paletteMapUnk89, // unk89 ImageIds::paletteMapUnk8A, // unk8A ImageIds::paletteMapUnk8B, // unk8B ImageIds::paletteMapUnk8C, // unk8C ImageIds::paletteMapUnk8D, // unk8D ImageIds::paletteMapUnk8E, // unk8E ImageIds::paletteMapUnk8F, // unk8F ImageIds::paletteMapUnk90, // unk90 ImageIds::paletteMapUnk91, // unk91 ImageIds::paletteMapUnk92 // unk92 }; // 0x0050B8C8 static std::array<uint32_t, enumValue(ExtColour::max)> _paletteToG1Offset = kDefaultPaletteToG1Offset; // Default immutable palette map. static const auto _defaultPaletteMapBuffer = [] { Buffer<kDefaultSize> data; std::iota(data.begin(), data.end(), 0); return data; }(); // This buffer is used when sprites are drawn with a secondary palette. // TODO: Make this thread safe via thread_local if multi-threading is implemented. static auto _secondaryPaletteMapBuffer = _defaultPaletteMapBuffer; View getDefault() { return _defaultPaletteMapBuffer; } static void copyPaletteMapData(Buffer<kDefaultSize>& dst, size_t dstIndex, const View src, size_t srcIndex, size_t length) { auto maxLength = std::min(dst.size() - srcIndex, dst.size() - dstIndex); assert(length <= maxLength); auto copyLength = std::min(length, maxLength); std::copy_n(src.begin() + srcIndex, copyLength, dst.begin() + dstIndex); } static std::optional<uint32_t> getPaletteG1Index(ExtColour paletteId) { if (enumValue(paletteId) < std::size(_paletteToG1Offset)) { return _paletteToG1Offset[enumValue(paletteId)]; } return std::nullopt; } std::optional<View> getForColour(ExtColour paletteId) { auto g1Index = getPaletteG1Index(paletteId); if (g1Index) { auto g1 = getG1Element(*g1Index); if (g1 != nullptr) { const size_t length = g1->width * g1->height; // Palette maps must be of 256 entries per row. assert((length % kDefaultSize) == 0); return View(std::span{ g1->offset, length }); } } return std::nullopt; } std::optional<View> getForImage(const ImageId image) { // No remapping required so use default palette map if (!image.hasPrimary() && !image.isBlended()) { return std::nullopt; // Will use default } if (image.hasSecondary()) { // Combines portions of two different palettes into the global palette map. auto& paletteMap = _secondaryPaletteMapBuffer; const auto primaryMap = getForColour(Colours::toExt(image.getPrimary())); const auto secondaryMap = getForColour(Colours::toExt(image.getSecondary())); if (!primaryMap || !secondaryMap) { assert(false); } // Remap sections are split into two bits for primary copyPaletteMapData(paletteMap, PaletteIndex::primaryRemap0, *primaryMap, PaletteIndex::primaryRemap0, (PaletteIndex::primaryRemap2 - PaletteIndex::primaryRemap0 + 1)); copyPaletteMapData(paletteMap, PaletteIndex::primaryRemap3, *primaryMap, PaletteIndex::primaryRemap3, (PaletteIndex::primaryRemapB - PaletteIndex::primaryRemap3 + 1)); copyPaletteMapData(paletteMap, PaletteIndex::secondaryRemap0, *secondaryMap, PaletteIndex::primaryRemap0, (PaletteIndex::primaryRemap2 - PaletteIndex::primaryRemap0 + 1)); copyPaletteMapData(paletteMap, PaletteIndex::secondaryRemap3, *secondaryMap, PaletteIndex::primaryRemap3, (PaletteIndex::primaryRemapB - PaletteIndex::primaryRemap3 + 1)); return paletteMap; } else { if (image.isBlended()) { return getForColour(image.getTranslucency()); } else { // For primary flagged images return getForColour(image.getRemap()); } } } void setEntryImage(ExtColour paletteId, uint32_t imageId) { assert(enumValue(paletteId) < std::size(_paletteToG1Offset)); _paletteToG1Offset[enumValue(paletteId)] = imageId; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/PaletteMap.h ```h #pragma once #include "Colour.h" #include "ImageId.h" #include <array> #include <cstdint> #include <optional> #include <span> namespace OpenLoco::Gfx::PaletteMap { /** * The typical palette map size used to render images. */ constexpr size_t kDefaultSize = 256; /** * Represents an 8-bit indexed map that maps from one palette index to another. */ template<std::size_t TSize> using Buffer = std::array<PaletteIndex_t, TSize>; using View = std::span<const PaletteIndex_t>; View getDefault(); std::optional<View> getForColour(ExtColour paletteId); std::optional<View> getForImage(const ImageId image); void setEntryImage(ExtColour paletteId, uint32_t imageId); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/RenderTarget.cpp ```cpp #include "RenderTarget.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Gfx { Ui::Rect RenderTarget::getDrawableRect() const { auto zoom = zoomLevel; auto left = x >> zoom; auto top = y >> zoom; auto right = (width >> zoom) + left; auto bottom = (height >> zoom) + top; return Ui::Rect::fromLTRB(left, top, right, bottom); } Ui::Rect RenderTarget::getUiRect() const { return Ui::Rect::fromLTRB(x, y, x + width, y + height); } // 0x004CEC50 std::optional<RenderTarget> clipRenderTarget(const RenderTarget& src, const Ui::Rect& newRect) { const Ui::Rect oldRect = src.getUiRect(); Ui::Rect intersect = oldRect.intersection(newRect); const auto stride = oldRect.size.width + src.pitch; const int16_t newPitch = stride - intersect.size.width; auto* newBits = src.bits + (stride * (intersect.origin.y - oldRect.origin.y) + (intersect.origin.x - oldRect.origin.x)); intersect.origin.x = std::max(0, oldRect.origin.x - newRect.origin.x); intersect.origin.y = std::max(0, oldRect.origin.y - newRect.origin.y); RenderTarget newRT{ newBits, static_cast<int16_t>(intersect.origin.x), static_cast<int16_t>(intersect.origin.y), static_cast<int16_t>(intersect.size.width), static_cast<int16_t>(intersect.size.height), newPitch, 0 }; if (newRT.width <= 0 || newRT.height <= 0) { return {}; } return { newRT }; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/RenderTarget.h ```h #pragma once #include <OpenLoco/Engine/Ui/Rect.hpp> #include <cstdint> #include <optional> namespace OpenLoco::Gfx { #pragma pack(push, 1) // TODO: Convert this to a handle once everything is implemented. // Depending on the rendering engine this could be a buffer on GPU or RAM. struct RenderTarget { uint8_t* bits; // 0x00 int16_t x; // 0x04 int16_t y; // 0x06 int16_t width; // 0x08 int16_t height; // 0x0A int16_t pitch; // 0x0C note: this is actually (pitch - width) uint16_t zoomLevel; // 0x0E Ui::Rect getUiRect() const; Ui::Rect getDrawableRect() const; }; #pragma pack(pop) std::optional<RenderTarget> clipRenderTarget(const RenderTarget& src, const Ui::Rect& newRect); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/SoftwareDrawingContext.cpp ```cpp #include "SoftwareDrawingContext.h" #include "DrawSprite.h" #include "Font.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Localisation/Formatting.h" #include "RenderTarget.h" #include "TextRenderer.h" #include "Ui.h" #include "Ui/WindowManager.h" #include <OpenLoco/Core/EnumFlags.hpp> #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> #include <SDL2/SDL.h> #include <algorithm> #include <cassert> #include <stack> using namespace OpenLoco::Interop; using namespace OpenLoco::Gfx; using namespace OpenLoco::Ui; namespace OpenLoco::Gfx { struct SoftwareDrawingContextState { std::stack<RenderTarget> rtStack; }; namespace Impl { // 0x009DA3E0 // Originally 0x009DA3E0 was an array of the image data pointers setup within 0x00452336 // We have removed that step and instead work directly on the images. static constexpr std::array<uint32_t, 8> _noiseMaskImages = { ImageIds::null, ImageIds::noise_mask_1, ImageIds::noise_mask_2, ImageIds::noise_mask_3, ImageIds::noise_mask_4, ImageIds::noise_mask_5, ImageIds::noise_mask_6, ImageIds::noise_mask_7, }; static void drawRect(const RenderTarget& rt, int16_t x, int16_t y, uint16_t dx, uint16_t dy, uint8_t colour, RectFlags flags); static void drawImageSolid(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image, PaletteIndex_t paletteIndex); // 0x00447485 // edi: rt // ebp: fill static void clear(const RenderTarget& rt, uint32_t fill) { int32_t w = rt.width / (1 << rt.zoomLevel); int32_t h = rt.height / (1 << rt.zoomLevel); uint8_t* ptr = rt.bits; for (int32_t y = 0; y < h; y++) { std::fill_n(ptr, w, fill); ptr += w + rt.pitch; } } static void clearSingle(const RenderTarget& rt, uint8_t paletteId) { auto fill = (paletteId << 24) | (paletteId << 16) | (paletteId << 8) | paletteId; clear(rt, fill); } static const G1Element* getNoiseMaskImageFromImage(const ImageId image) { if (image.hasNoiseMask()) { const auto noise = image.getNoiseMask(); const auto* noiseImage = getG1Element(_noiseMaskImages[noise]); if (noiseImage == nullptr) { return nullptr; } return noiseImage; } else { return nullptr; } } template<uint8_t TZoomLevel, bool TIsRLE> static std::optional<DrawSpritePosArgs> getDrawImagePosArgs(const RenderTarget& rt, const Ui::Point& pos, const G1Element& element) { if constexpr (TZoomLevel > 0) { if (element.hasFlags(G1ElementFlags::noZoomDraw)) { return std::nullopt; } } auto dispPos{ pos }; // Its used super often so we will define it to a separate variable. constexpr auto zoomMask = static_cast<uint32_t>(0xFFFFFFFFULL << TZoomLevel); if constexpr (TZoomLevel > 0 && TIsRLE) { dispPos.x -= ~zoomMask; dispPos.y -= ~zoomMask; } // This will be the height of the drawn image auto height = element.height; // This is the start y coordinate on the destination auto dstTop = dispPos.y + element.yOffset; // For whatever reason the RLE version does not use // the zoom mask on the y coordinate but does on x. if constexpr (TIsRLE) { dstTop -= rt.y; } else { dstTop = (dstTop & zoomMask) - rt.y; } // This is the start y coordinate on the source auto srcY = 0; if (dstTop < 0) { // If the destination y is negative reduce the height of the // image as we will cut off the bottom height += dstTop; // If the image is no longer visible nothing to draw if (height <= 0) { return std::nullopt; } // The source image will start a further up the image srcY -= dstTop; // The destination start is now reset to 0 dstTop = 0; } else { if constexpr (TZoomLevel > 0 && TIsRLE) { srcY -= dstTop & ~zoomMask; height += dstTop & ~zoomMask; } } auto dstBottom = dstTop + height; if (dstBottom > rt.height) { // If the destination y is outside of the drawing // image reduce the height of the image height -= dstBottom - rt.height; } // If the image no longer has anything to draw if (height <= 0) { return std::nullopt; } dstTop = dstTop >> TZoomLevel; // This will be the width of the drawn image auto width = element.width; // This is the source start x coordinate auto srcX = 0; // This is the destination start x coordinate int32_t dstLeft = ((dispPos.x + element.xOffset + ~zoomMask) & zoomMask) - rt.x; if (dstLeft < 0) { // If the destination is negative reduce the width // image will cut off the side width += dstLeft; // If there is no image to draw if (width <= 0) { return std::nullopt; } // The source start will also need to cut off the side srcX -= dstLeft; // Reset the destination to 0 dstLeft = 0; } else { if constexpr (TZoomLevel > 0 && TIsRLE) { srcX -= dstLeft & ~zoomMask; } } const auto dstRight = dstLeft + width; if (dstRight > rt.width) { // If the destination x is outside of the drawing area // reduce the image width. width -= dstRight - rt.width; // If there is no image to draw. if (width <= 0) { return std::nullopt; } } dstLeft = dstLeft >> TZoomLevel; return DrawSpritePosArgs{ Ui::Point32{ srcX, srcY }, Ui::Point32{ dstLeft, dstTop }, Ui::Size(width, height) }; } template<uint8_t TZoomLevel, bool TIsRLE> static void drawImagePaletteSet(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image, const G1Element& element, const PaletteMap::View palette, const G1Element* noiseImage) { auto args = getDrawImagePosArgs<TZoomLevel, TIsRLE>(rt, pos, element); if (args.has_value()) { const DrawSpriteArgs fullArgs{ palette, element, args->srcPos, args->dstPos, args->size, noiseImage }; const auto op = getDrawBlendOp(image, fullArgs); drawSpriteToBuffer<TZoomLevel, TIsRLE>(rt, fullArgs, op); } } // 0x00448D90 static void drawImagePaletteSet(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image, const PaletteMap::View palette, const G1Element* noiseImage) { const auto* element = getG1Element(image.getIndex()); if (element == nullptr) { return; } if (rt.zoomLevel > 0 && (element->hasFlags(G1ElementFlags::hasZoomSprites))) { auto zoomedrt{ rt }; zoomedrt.bits = rt.bits; zoomedrt.x = rt.x >> 1; zoomedrt.y = rt.y >> 1; zoomedrt.height = rt.height >> 1; zoomedrt.width = rt.width >> 1; zoomedrt.pitch = rt.pitch; zoomedrt.zoomLevel = rt.zoomLevel - 1; const auto zoomCoords = Ui::Point(pos.x >> 1, pos.y >> 1); drawImagePaletteSet( zoomedrt, zoomCoords, image.withIndexOffset(-element->zoomOffset), palette, noiseImage); return; } const bool isRLE = element->hasFlags(G1ElementFlags::isRLECompressed); if (isRLE) { switch (rt.zoomLevel) { default: drawImagePaletteSet<0, true>(rt, pos, image, *element, palette, noiseImage); break; case 1: drawImagePaletteSet<1, true>(rt, pos, image, *element, palette, noiseImage); break; case 2: drawImagePaletteSet<2, true>(rt, pos, image, *element, palette, noiseImage); break; case 3: drawImagePaletteSet<3, true>(rt, pos, image, *element, palette, noiseImage); break; } } else { switch (rt.zoomLevel) { default: drawImagePaletteSet<0, false>(rt, pos, image, *element, palette, noiseImage); break; case 1: drawImagePaletteSet<1, false>(rt, pos, image, *element, palette, noiseImage); break; case 2: drawImagePaletteSet<2, false>(rt, pos, image, *element, palette, noiseImage); break; case 3: drawImagePaletteSet<3, false>(rt, pos, image, *element, palette, noiseImage); break; } } } // 0x00448C79 static void drawImage(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image) { const auto* noiseImage = getNoiseMaskImageFromImage(image); const auto palette = PaletteMap::getForImage(image); if (!palette.has_value()) { drawImagePaletteSet(rt, pos, image, PaletteMap::getDefault(), noiseImage); } else { drawImagePaletteSet(rt, pos, image, *palette, noiseImage); } } // 0x00448C79 static void drawImage(const RenderTarget* rt, int16_t x, int16_t y, uint32_t image) { drawImage(*rt, { x, y }, ImageId::fromUInt32(image)); } // 0x00450890, 0x00450F87, 0x00450D1E, 0x00450ABA template<int32_t TZoomLevel> static void drawMaskedZoom( int16_t imageHeight, int16_t imageWidth, int16_t rowSize, const uint8_t* bytesMask, int16_t dstWrap, uint8_t* dstBuf, const uint8_t* bytesImage) { const auto scaledHeight = imageHeight >> TZoomLevel; if (scaledHeight == 0) { return; } const auto scaledWidth = imageWidth >> TZoomLevel; if (scaledWidth == 0) { return; } constexpr auto skip = (1U << TZoomLevel); // Calculate the row size. const auto scaledRowSize = [&]() { if constexpr (TZoomLevel == 0) { return rowSize; } else { constexpr auto zoomMask = (1 << TZoomLevel) - 1; const auto scaledRowSize = zoomMask * static_cast<uint16_t>(rowSize + imageWidth) + rowSize; const auto maskedRowSize = static_cast<uint16_t>(imageWidth) & zoomMask; return maskedRowSize + scaledRowSize; } }(); if constexpr (TZoomLevel > 0) { dstWrap -= scaledWidth; } for (auto y = 0; y < scaledHeight; y++) { for (auto x = 0; x < scaledWidth; x++) { const auto masked = *bytesMask & *bytesImage; if (masked) { *dstBuf = masked; } bytesImage += skip; bytesMask += skip; dstBuf++; } bytesImage += scaledRowSize; bytesMask += scaledRowSize; dstBuf += dstWrap; } } template<int32_t TZoomLevel> static void drawImageMaskedZoom(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image, const ImageId& maskImage) { const auto* g1Image = Gfx::getG1Element(image.getIndex()); if (g1Image == nullptr) { return; } if (g1Image->hasFlags(G1ElementFlags::isRLECompressed)) { // This is not supported. assert(false); return; } const auto* g1ImageMask = Gfx::getG1Element(maskImage.getIndex()); if (g1ImageMask == nullptr) { return; } if (g1ImageMask->hasFlags(G1ElementFlags::isRLECompressed)) { // This is not supported. assert(false); return; } if constexpr (TZoomLevel > 0) { if (g1Image->hasFlags(G1ElementFlags::none)) { return; } if (g1Image->hasFlags(G1ElementFlags::hasZoomSprites)) { if (g1ImageMask->hasFlags(G1ElementFlags::noZoomDraw)) { return; } if (g1ImageMask->hasFlags(G1ElementFlags::hasZoomSprites)) { auto newRt = rt; --newRt.zoomLevel; newRt.x >>= 1; newRt.y >>= 1; newRt.width >>= 1; newRt.height >>= 1; drawImageMaskedZoom<TZoomLevel - 1>( newRt, { static_cast<int16_t>(pos.x >> 1), static_cast<int16_t>(pos.y >> 1) }, image.withIndexOffset(-g1Image->zoomOffset), maskImage.withIndexOffset(-g1ImageMask->zoomOffset)); return; } } } int16_t imageHeight = g1Image->height; int16_t imageWidth = g1Image->width; const auto* imageDataPos = g1Image->offset; auto* dstBuf = rt.bits; constexpr uint16_t zoomMask = static_cast<uint16_t>(~0ULL << TZoomLevel); constexpr int16_t offsetX = (1 << TZoomLevel) - 1; int16_t dstTop = ((g1Image->yOffset + pos.y) & zoomMask) - rt.y; if (dstTop >= 0) { auto scaledWidth = rt.width >> TZoomLevel; scaledWidth = rt.pitch + scaledWidth; dstBuf += (dstTop >> TZoomLevel) * scaledWidth; } else { if (dstTop + imageHeight == 0) { return; } imageHeight += dstTop; if (imageHeight < 0) { return; } const auto startOffset = static_cast<uint16_t>(-dstTop) * g1Image->width; imageDataPos = &g1Image->offset[startOffset]; dstTop = 0; } int16_t dstBottom = imageHeight + dstTop; if (dstBottom > rt.height) { imageHeight -= dstBottom - rt.height; if (imageHeight <= 0) { return; } } int16_t rowSize = 0; int16_t dstWrap = rt.pitch + (rt.width >> TZoomLevel); if constexpr (TZoomLevel == 0) { dstWrap -= g1Image->width; } int16_t dstLeft = ((g1Image->xOffset + pos.x + offsetX) & zoomMask) - rt.x; if (dstLeft < 0) { imageWidth += dstLeft; if (imageWidth <= 0) { return; } rowSize -= dstLeft; imageDataPos -= dstLeft; if constexpr (TZoomLevel == 0) { dstWrap -= dstLeft; } dstLeft = 0; } int16_t dstRight = imageWidth + dstLeft - rt.width; if (imageWidth + dstLeft > rt.width) { imageWidth -= dstRight; if (imageWidth <= 0) { return; } rowSize += dstRight; if constexpr (TZoomLevel == 0) { dstWrap += dstRight; } } dstBuf += (dstLeft >> TZoomLevel); auto imageOffset = imageDataPos - g1Image->offset; drawMaskedZoom<TZoomLevel>( imageHeight, imageWidth, rowSize, &g1ImageMask->offset[imageOffset], dstWrap, dstBuf, imageDataPos); } // 0x00450705 static void drawImageMasked(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image, const ImageId& maskImage) { switch (rt.zoomLevel) { case 0: drawImageMaskedZoom<0>(rt, pos, image, maskImage); return; case 1: drawImageMaskedZoom<1>(rt, pos, image, maskImage); return; case 2: drawImageMaskedZoom<2>(rt, pos, image, maskImage); return; case 3: drawImageMaskedZoom<3>(rt, pos, image, maskImage); return; default: break; } // Unreachable assert(false); } static void drawImageSolid(const RenderTarget& rt, const Ui::Point& pos, const ImageId& image, PaletteIndex_t paletteIndex) { PaletteMap::Buffer<PaletteMap::kDefaultSize> palette; std::fill(palette.begin(), palette.end(), paletteIndex); palette[0] = 0; // Set the image primary flag to tell drawImagePaletteSet to recolour with the palette (Colour::black is not actually used) drawImagePaletteSet(rt, pos, image.withPrimary(Colour::black), PaletteMap::View{ palette }, {}); } // 0x004474BA // ax: left // bx: right // bp: width // cx: top // dx: bottom // ebp: colour | enumValue(flags) // edi: rt static void drawRectImpl(const RenderTarget& rt, int16_t left, int16_t top, int16_t right, int16_t bottom, uint8_t colour, RectFlags flags) { if (left > right) { return; } if (top > bottom) { return; } if (right < rt.x) { return; } if (left >= (rt.x + rt.width)) { return; } if (bottom < rt.y) { return; } if (top >= rt.y + rt.height) { return; } uint32_t crossPattern = 0; auto leftX = left - rt.x; if (leftX < 0) { crossPattern ^= leftX; leftX = 0; } auto rightX = right - rt.x + 1; if (rightX > rt.width) { rightX = rt.width; } auto topY = top - rt.y; if (topY < 0) { crossPattern ^= topY; topY = 0; } auto bottomY = bottom - rt.y + 1; if (bottomY > rt.height) { bottomY = rt.height; } auto drawRect = Rect::fromLTRB(leftX, topY, rightX, bottomY); if (flags == RectFlags::none) // Regular fill { auto* dst = drawRect.top() * (rt.width + rt.pitch) + drawRect.left() + rt.bits; const auto step = rt.width + rt.pitch; for (auto y = 0; y < drawRect.height(); y++) { std::fill_n(dst, drawRect.width(), colour); dst += step; } } else if ((flags & RectFlags::transparent) != RectFlags::none) { auto* dst = rt.bits + static_cast<uint32_t>((drawRect.top() >> rt.zoomLevel) * ((rt.width >> rt.zoomLevel) + rt.pitch) + (drawRect.left() >> rt.zoomLevel)); auto paletteMap = PaletteMap::getForColour(static_cast<ExtColour>(colour)); if (paletteMap.has_value()) { const auto& paletteEntries = paletteMap.value(); const auto scaledWidth = drawRect.width() >> rt.zoomLevel; const auto scaledHeight = drawRect.height() >> rt.zoomLevel; const auto step = (rt.width >> rt.zoomLevel) + rt.pitch; // Fill the rectangle with the colours from the colour table for (auto y = 0; y < scaledHeight; y++) { auto* nextDst = dst + step * y; for (auto x = 0; x < scaledWidth; x++) { auto index = *(nextDst + x); *(nextDst + x) = paletteEntries[index]; } } } } else if ((flags & RectFlags::crossHatching) != RectFlags::none) { auto* dst = (drawRect.top() * (rt.width + rt.pitch)) + drawRect.left() + rt.bits; const auto step = rt.width + rt.pitch; for (auto y = 0; y < drawRect.height(); y++) { auto* nextDst = dst + step * y; auto p = std::rotr(crossPattern, 1); // Fill every other pixel with the colour for (auto x = 0; x < drawRect.width(); x++) { p ^= 0x80000000; if (p & 0x80000000) { *(nextDst + x) = colour; } } crossPattern ^= 1; } } else if ((flags & RectFlags::g1Pattern) != RectFlags::none) { assert(false); // unused } else if ((flags & RectFlags::selectPattern) != RectFlags::none) { assert(false); // unused } } static void drawRectImpl(const RenderTarget& rt, const Ui::Rect& rect, uint8_t colour, RectFlags flags) { drawRectImpl(rt, rect.left(), rect.top(), rect.right(), rect.bottom(), colour, flags); } static void fillRect(const RenderTarget& rt, int16_t left, int16_t top, int16_t right, int16_t bottom, uint8_t colour, RectFlags flags) { drawRectImpl(rt, left, top, right, bottom, colour, flags); } static void drawRect(const RenderTarget& rt, int16_t x, int16_t y, uint16_t dx, uint16_t dy, uint8_t colour, RectFlags flags) { // This makes the function signature more like a drawing application drawRectImpl(rt, x, y, x + dx - 1, y + dy - 1, colour, flags); } static void fillRectInset(const RenderTarget& rt, int16_t left, int16_t top, int16_t right, int16_t bottom, AdvancedColour colour, RectInsetFlags flags) { const auto rect = Ui::Rect::fromLTRB(left, top, right, bottom); const auto baseColour = static_cast<Colour>(colour); assert(!colour.isOutline()); assert(!colour.isInset()); if (colour.isTranslucent()) { // Must pass RectFlags::transparent to drawRectImpl for this code path if ((flags & RectInsetFlags::borderNone) != RectInsetFlags::none) { drawRectImpl(rt, rect, enumValue(Colours::getTranslucent(baseColour, 1)), RectFlags::transparent); } else if ((flags & RectInsetFlags::borderInset) != RectInsetFlags::none) { // Draw outline of box drawRectImpl(rt, Ui::Rect::fromLTRB(left, top, left, bottom), enumValue(Colours::getTranslucent(baseColour, 2)), RectFlags::transparent); drawRectImpl(rt, Ui::Rect::fromLTRB(left, top, right, top), enumValue(Colours::getTranslucent(baseColour, 2)), RectFlags::transparent); drawRectImpl(rt, Ui::Rect::fromLTRB(right, top, right, bottom), enumValue(Colours::getTranslucent(baseColour, 0)), RectFlags::transparent); drawRectImpl(rt, Ui::Rect::fromLTRB(left, bottom, right, bottom), enumValue(Colours::getTranslucent(baseColour, 0)), RectFlags::transparent); if ((flags & RectInsetFlags::fillNone) == RectInsetFlags::none) { drawRectImpl(rt, Ui::Rect::fromLTRB(left + 1, top + 1, right - 1, bottom - 1), enumValue(Colours::getTranslucent(baseColour, 1)), RectFlags::transparent); } } else { // Draw outline of box drawRectImpl(rt, Ui::Rect::fromLTRB(left, top, left, bottom), enumValue(Colours::getTranslucent(baseColour, 0)), RectFlags::transparent); drawRectImpl(rt, Ui::Rect::fromLTRB(left, top, right, top), enumValue(Colours::getTranslucent(baseColour, 0)), RectFlags::transparent); drawRectImpl(rt, Ui::Rect::fromLTRB(right, top, right, bottom), enumValue(Colours::getTranslucent(baseColour, 2)), RectFlags::transparent); drawRectImpl(rt, Ui::Rect::fromLTRB(left, bottom, right, bottom), enumValue(Colours::getTranslucent(baseColour, 2)), RectFlags::transparent); if ((flags & RectInsetFlags::fillNone) == RectInsetFlags::none) { drawRectImpl( rt, Ui::Rect::fromLTRB(left + 1, top + 1, right - 1, bottom - 1), enumValue(Colours::getTranslucent(baseColour, 1)), RectFlags::transparent); } } } else { PaletteIndex_t shadow, fill, fill2, hilight; if ((flags & RectInsetFlags::colourLight) != RectInsetFlags::none) { shadow = Colours::getShade(baseColour, 1); fill = Colours::getShade(baseColour, 3); fill2 = Colours::getShade(baseColour, 4); hilight = Colours::getShade(baseColour, 5); } else { shadow = Colours::getShade(baseColour, 3); fill = Colours::getShade(baseColour, 5); fill2 = Colours::getShade(baseColour, 6); hilight = Colours::getShade(baseColour, 7); } if ((flags & RectInsetFlags::borderNone) != RectInsetFlags::none) { drawRectImpl(rt, rect, fill, RectFlags::none); } else if ((flags & RectInsetFlags::borderInset) != RectInsetFlags::none) { // Draw outline of box drawRectImpl(rt, Ui::Rect::fromLTRB(left, top, left, bottom), shadow, RectFlags::none); drawRectImpl(rt, Ui::Rect::fromLTRB(left + 1, top, right, top), shadow, RectFlags::none); drawRectImpl(rt, Ui::Rect::fromLTRB(right, top + 1, right, bottom - 1), hilight, RectFlags::none); drawRectImpl(rt, Ui::Rect::fromLTRB(left + 1, bottom, right, bottom), hilight, RectFlags::none); if ((flags & RectInsetFlags::fillNone) == RectInsetFlags::none) { if ((flags & RectInsetFlags::fillDarker) == RectInsetFlags::none) { fill = fill2; } if ((flags & RectInsetFlags::fillTransparent) != RectInsetFlags::none) { fill = PaletteIndex::transparent; } drawRectImpl(rt, Ui::Rect::fromLTRB(left + 1, top + 1, right - 1, bottom - 1), fill, RectFlags::none); } } else { // Draw outline of box drawRectImpl(rt, Ui::Rect::fromLTRB(left, top, left, bottom - 1), hilight, RectFlags::none); drawRectImpl(rt, Ui::Rect::fromLTRB(left + 1, top, right - 1, top), hilight, RectFlags::none); drawRectImpl(rt, Ui::Rect::fromLTRB(right, top, right, bottom - 1), shadow, RectFlags::none); drawRectImpl(rt, Ui::Rect::fromLTRB(left, bottom, right, bottom), shadow, RectFlags::none); if ((flags & RectInsetFlags::fillNone) == RectInsetFlags::none) { if ((flags & RectInsetFlags::fillTransparent) != RectInsetFlags::none) { fill = PaletteIndex::transparent; } drawRectImpl(rt, Ui::Rect::fromLTRB(left + 1, top + 1, right - 1, bottom - 1), fill, RectFlags::none); } } } } static void drawRectInset(const RenderTarget& rt, int16_t x, int16_t y, uint16_t dx, uint16_t dy, AdvancedColour colour, RectInsetFlags flags) { // This makes the function signature more like a drawing application fillRectInset(rt, x, y, x + dx - 1, y + dy - 1, colour, flags); } /** * Draws a horizontal line of specified colour to a buffer. * 0x0045308A */ static void drawHorizontalLine(const RenderTarget& rt, PaletteIndex_t colour, const Ui::Point& startCoord, int32_t length) { Ui::Point offset(startCoord.x - rt.x, startCoord.y - rt.y); // Check to make sure point is in the y range if (offset.y < 0) { return; } if (offset.y >= rt.height) { return; } // Check to make sure we are drawing at least a pixel if (length == 0) { length++; } // If x coord outside range leave if (offset.x < 0) { // Unless the number of pixels is enough to be in range length += offset.x; if (length <= 0) { return; } // Resets starting point to 0 as we don't draw outside the range offset.x = 0; } // Ensure that the end point of the line is within range if (offset.x + length - rt.width > 0) { // If the end point has any pixels outside range // cut them off. If there are now no pixels return. length -= offset.x + length - rt.width; if (length <= 0) { return; } } // Get the buffer we are drawing to and move to the first coordinate. uint8_t* buffer = rt.bits + offset.y * static_cast<int32_t>(rt.pitch + rt.width) + offset.x; // Draw the line to the specified colour std::fill_n(buffer, length, colour); } // 0x00452DA4 static void drawLine(const RenderTarget& rt, Ui::Point a, Ui::Point b, const PaletteIndex_t colour) { const auto bounding = Rect::fromLTRB(a.x, a.y, b.x, b.y); // Check to make sure the line is within the drawing area if (!rt.getUiRect().intersects(bounding)) { return; } // Bresenham's algorithm // If vertical plot points upwards const bool isSteep = std::abs(a.y - b.y) > std::abs(a.x - b.x); if (isSteep) { std::swap(b.y, a.x); std::swap(a.y, b.x); } // If line is right to left swap direction if (a.x > b.x) { std::swap(a.x, b.x); std::swap(b.y, a.y); } const auto deltaX = b.x - a.x; const auto deltaY = std::abs(b.y - a.y); auto error = deltaX / 2; const auto yStep = a.y < b.y ? 1 : -1; auto y = a.y; for (auto x = a.x, xStart = a.x, length = static_cast<int16_t>(1); x < b.x; ++x, ++length) { // Vertical lines are drawn 1 pixel at a time if (isSteep) { drawHorizontalLine(rt, colour, { y, x }, 1); } error -= deltaY; if (error < 0) { // Non vertical lines are drawn with as many pixels in a horizontal line as possible if (!isSteep) { drawHorizontalLine(rt, colour, { xStart, y }, length); } // Reset non vertical line vars xStart = x + 1; length = 0; // NB: will be incremented in next iteration y += yStep; error += deltaX; } // Catch the case of the last line if (x + 1 == b.x && !isSteep) { drawHorizontalLine(rt, colour, { xStart, y }, length); } } } } SoftwareDrawingContext::SoftwareDrawingContext() : _state{ std::make_unique<SoftwareDrawingContextState>() } { } SoftwareDrawingContext::~SoftwareDrawingContext() { // Need to keep the empty destructor to allow for unique_ptr to delete the actual type. } void SoftwareDrawingContext::clear(uint32_t fill) { auto& rt = currentRenderTarget(); return Impl::clear(rt, fill); } void SoftwareDrawingContext::clearSingle(uint8_t paletteId) { auto& rt = currentRenderTarget(); return Impl::clearSingle(rt, paletteId); } void SoftwareDrawingContext::fillRect(int16_t left, int16_t top, int16_t right, int16_t bottom, uint8_t colour, RectFlags flags) { auto& rt = currentRenderTarget(); return Impl::fillRect(rt, left, top, right, bottom, colour, flags); } void SoftwareDrawingContext::drawRect(int16_t x, int16_t y, uint16_t dx, uint16_t dy, uint8_t colour, RectFlags flags) { auto& rt = currentRenderTarget(); return Impl::drawRect(rt, x, y, dx, dy, colour, flags); } void SoftwareDrawingContext::fillRectInset(int16_t left, int16_t top, int16_t right, int16_t bottom, AdvancedColour colour, RectInsetFlags flags) { auto& rt = currentRenderTarget(); return Impl::fillRectInset(rt, left, top, right, bottom, colour, flags); } void SoftwareDrawingContext::drawRectInset(int16_t x, int16_t y, uint16_t dx, uint16_t dy, AdvancedColour colour, RectInsetFlags flags) { auto& rt = currentRenderTarget(); return Impl::drawRectInset(rt, x, y, dx, dy, colour, flags); } void SoftwareDrawingContext::drawLine(const Ui::Point& a, const Ui::Point& b, PaletteIndex_t colour) { auto& rt = currentRenderTarget(); return Impl::drawLine(rt, a, b, colour); } void SoftwareDrawingContext::drawImage(int16_t x, int16_t y, uint32_t image) { auto& rt = currentRenderTarget(); return Impl::drawImage(&rt, x, y, image); } void SoftwareDrawingContext::drawImage(const Ui::Point& pos, const ImageId& image) { auto& rt = currentRenderTarget(); return Impl::drawImage(rt, pos, image); } void SoftwareDrawingContext::drawImageMasked(const Ui::Point& pos, const ImageId& image, const ImageId& maskImage) { auto& rt = currentRenderTarget(); return Impl::drawImageMasked(rt, pos, image, maskImage); } void SoftwareDrawingContext::drawImageSolid(const Ui::Point& pos, const ImageId& image, PaletteIndex_t paletteIndex) { auto& rt = currentRenderTarget(); return Impl::drawImageSolid(rt, pos, image, paletteIndex); } void SoftwareDrawingContext::drawImagePaletteSet(const Ui::Point& pos, const ImageId& image, PaletteMap::View palette, const G1Element* noiseImage) { auto& rt = currentRenderTarget(); return Impl::drawImagePaletteSet(rt, pos, image, palette, noiseImage); } void SoftwareDrawingContext::pushRenderTarget(const RenderTarget& rt) { _state->rtStack.push(rt); // In case this leaks it will trigger an assert, the stack should ordinarily be really small. assert(_state->rtStack.size() < 10); } void SoftwareDrawingContext::popRenderTarget() { // Should not be empty before pop. assert(_state->rtStack.empty() == false); _state->rtStack.pop(); // Should not be empty after pop assert(_state->rtStack.empty() == false); } const RenderTarget& SoftwareDrawingContext::currentRenderTarget() const { // Should not be empty. assert(_state->rtStack.empty() == false); return _state->rtStack.top(); } void SoftwareDrawingContext::reset() { _state->rtStack = {}; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/SoftwareDrawingContext.h ```h #pragma once #include "DrawingContext.h" #include "Font.h" #include "Graphics/Gfx.h" #include "Graphics/PaletteMap.h" #include "Types.hpp" #include <OpenLoco/Engine/Ui/Rect.hpp> #include <cstdint> #include <memory> namespace OpenLoco::Gfx { struct SoftwareDrawingContextState; class SoftwareDrawingContext final : public DrawingContext { private: std::unique_ptr<SoftwareDrawingContextState> _state; public: SoftwareDrawingContext(); ~SoftwareDrawingContext() override; void reset(); void pushRenderTarget(const RenderTarget& rt) override; void popRenderTarget() override; const RenderTarget& currentRenderTarget() const override; void clear(uint32_t fill) override; void clearSingle(uint8_t paletteId) override; void fillRect(int16_t left, int16_t top, int16_t right, int16_t bottom, uint8_t colour, RectFlags flags) override; void drawRect(int16_t x, int16_t y, uint16_t dx, uint16_t dy, uint8_t colour, RectFlags flags) override; void fillRectInset(int16_t left, int16_t top, int16_t right, int16_t bottom, AdvancedColour colour, RectInsetFlags flags) override; void drawRectInset(int16_t x, int16_t y, uint16_t dx, uint16_t dy, AdvancedColour colour, RectInsetFlags flags) override; void drawLine(const Ui::Point& a, const Ui::Point& b, PaletteIndex_t colour) override; void drawImage(int16_t x, int16_t y, uint32_t image) override; void drawImage(const Ui::Point& pos, const ImageId& image) override; void drawImageMasked(const Ui::Point& pos, const ImageId& image, const ImageId& maskImage) override; void drawImageSolid(const Ui::Point& pos, const ImageId& image, PaletteIndex_t paletteIndex) override; void drawImagePaletteSet(const Ui::Point& pos, const ImageId& image, PaletteMap::View palette, const G1Element* noiseImage) override; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/SoftwareDrawingEngine.cpp ```cpp #include "SoftwareDrawingEngine.h" #include "Config.h" #include "Graphics/FPSCounter.h" #include "Logging.h" #include "RenderTarget.h" #include "Ui.h" #include "Ui/WindowManager.h" #include <OpenLoco/Interop/Interop.hpp> #include <SDL2/SDL.h> #include <algorithm> #include <cstdlib> using namespace OpenLoco::Interop; using namespace OpenLoco::Gfx; using namespace OpenLoco::Ui; using namespace OpenLoco::Diagnostics; namespace OpenLoco::Gfx { using SetPaletteFunc = void (*)(const PaletteEntry* palette, int32_t index, int32_t count); // TODO: Move into the renderer. // 0x0050B884 static RenderTarget _screenRT{}; // 0x0050B894 static Ui::ScreenInfo _screenInfo; SoftwareDrawingEngine::SoftwareDrawingEngine() { RenderTarget rtDummy{}; _ctx.pushRenderTarget(rtDummy); } SoftwareDrawingEngine::~SoftwareDrawingEngine() { if (_palette != nullptr) { SDL_FreePalette(_palette); _palette = nullptr; } if (_screenTexture != nullptr) { SDL_DestroyTexture(_screenTexture); _screenTexture = nullptr; } if (_scaledScreenTexture != nullptr) { SDL_DestroyTexture(_scaledScreenTexture); _screenTexture = nullptr; } if (_screenTextureFormat != nullptr) { SDL_FreeFormat(_screenTextureFormat); _screenTextureFormat = nullptr; } } void SoftwareDrawingEngine::initialize(SDL_Window* window) { SDL_SetHint(SDL_HINT_RENDER_DRIVER, "opengl"); _renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED); if (_renderer == nullptr) { // Try to fallback to software renderer. Logging::warn("Hardware acceleration not available, falling back to software renderer."); _renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE); if (_renderer == nullptr) { Logging::error("Unable to create hardware or software renderer: {}", SDL_GetError()); std::abort(); } } _window = window; createPalette(); } void SoftwareDrawingEngine::resize(const int32_t width, const int32_t height) { // Scale the width and height by configured scale factor const auto scaleFactor = Config::get().scaleFactor; const auto scaledWidth = (int32_t)(width / scaleFactor); const auto scaledHeight = (int32_t)(height / scaleFactor); // Release old resources. if (_screenSurface != nullptr) { SDL_FreeSurface(_screenSurface); } if (_screenRGBASurface != nullptr) { SDL_FreeSurface(_screenRGBASurface); } if (_screenTexture != nullptr) { SDL_DestroyTexture(_screenTexture); _screenTexture = nullptr; } if (_scaledScreenTexture != nullptr) { SDL_DestroyTexture(_scaledScreenTexture); _scaledScreenTexture = nullptr; } if (_screenTextureFormat != nullptr) { SDL_FreeFormat(_screenTextureFormat); _screenTextureFormat = nullptr; } // Surfaces. _screenSurface = SDL_CreateRGBSurface(0, scaledWidth, scaledHeight, 8, 0, 0, 0, 0); if (_screenSurface == nullptr) { Logging::error("SDL_CreateRGBSurface (_screenSurface) failed: {}", SDL_GetError()); return; } _screenRGBASurface = SDL_CreateRGBSurface(0, scaledWidth, scaledHeight, 32, 0, 0, 0, 0); if (_screenRGBASurface == nullptr) { Logging::error("SDL_CreateRGBSurface (_screenRGBASurface) failed: {}", SDL_GetError()); return; } SDL_SetSurfaceBlendMode(_screenRGBASurface, SDL_BLENDMODE_NONE); SDL_SetSurfacePalette(_screenSurface, _palette); SDL_RendererInfo rendererInfo{}; int32_t result = SDL_GetRendererInfo(_renderer, &rendererInfo); if (result < 0) { Logging::error("HWDisplayDrawingEngine::Resize error: {}", SDL_GetError()); return; } uint32_t pixelFormat = SDL_PIXELFORMAT_UNKNOWN; for (uint32_t i = 0; i < rendererInfo.num_texture_formats; i++) { uint32_t format = rendererInfo.texture_formats[i]; if (!SDL_ISPIXELFORMAT_FOURCC(format) && !SDL_ISPIXELFORMAT_INDEXED(format) && (pixelFormat == SDL_PIXELFORMAT_UNKNOWN || SDL_BYTESPERPIXEL(format) < SDL_BYTESPERPIXEL(pixelFormat))) { pixelFormat = format; } } SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest"); _screenTexture = SDL_CreateTexture(_renderer, pixelFormat, SDL_TEXTUREACCESS_STREAMING, scaledWidth, scaledHeight); if (_screenTexture == nullptr) { Logging::error("SDL_CreateTexture (_screenTexture) failed: {}", SDL_GetError()); return; } if (scaleFactor > 1.0f) { const auto scale = std::ceil(scaleFactor); // We only need this texture when we have a scale above 1x, this texture uses the actual canvas size. SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear"); _scaledScreenTexture = SDL_CreateTexture(_renderer, pixelFormat, SDL_TEXTUREACCESS_TARGET, width * scale, height * scale); if (_scaledScreenTexture == nullptr) { Logging::error("SDL_CreateTexture (_scaledScreenTexture) failed: {}", SDL_GetError()); return; } } uint32_t format; SDL_QueryTexture(_screenTexture, &format, nullptr, nullptr, nullptr); _screenTextureFormat = SDL_AllocFormat(format); int32_t pitch = _screenSurface->pitch; RenderTarget& rt = _screenRT; if (rt.bits != nullptr) { delete[] rt.bits; } rt.bits = new uint8_t[pitch * scaledHeight]; rt.width = scaledWidth; rt.height = scaledHeight; rt.pitch = pitch - scaledWidth; _screenInfo.width = scaledWidth; _screenInfo.height = scaledHeight; _screenInfo.width_2 = scaledWidth; _screenInfo.height_2 = scaledHeight; _screenInfo.width_3 = scaledWidth; _screenInfo.height_3 = scaledHeight; int32_t widthShift = 6; int16_t blockWidth = 1 << widthShift; int32_t heightShift = 3; int16_t blockHeight = 1 << heightShift; _invalidationGrid.reset(scaledWidth, scaledHeight, blockWidth, blockHeight); // Reset the drawing context, this holds the old screen render target. _ctx.reset(); // Push the screen render target so that by default we render to that. _ctx.pushRenderTarget(rt); // Set the normal background colour. _ctx.clearSingle(PaletteIndex::black0); } /** * 0x004C5C69 * * @param left @<ax> * @param top @<bx> * @param right @<dx> * @param bottom @<bp> */ void SoftwareDrawingEngine::invalidateRegion(int32_t left, int32_t top, int32_t right, int32_t bottom) { _invalidationGrid.invalidate(left, top, right, bottom); } void SoftwareDrawingEngine::createPalette() { // Create a palette for the window _palette = SDL_AllocPalette(256); } void SoftwareDrawingEngine::updatePalette(const PaletteEntry* entries, int32_t index, int32_t count) { assert(index + count < 256); SDL_Color base[256]{}; SDL_Color* basePtr = &base[index]; auto* entryPtr = &entries[index]; for (int i = 0; i < count; ++i, basePtr++, entryPtr++) { basePtr->r = entryPtr->r; basePtr->g = entryPtr->g; basePtr->b = entryPtr->b; basePtr->a = 0; } SDL_SetPaletteColors(_palette, &base[index], index, count); } // 0x004C5CFA void SoftwareDrawingEngine::render() { // Need to first render the current dirty regions before updating the viewports. // This is needed to ensure it will copy the correct pixels when the viewport will be moved. renderDirtyRegions(); // Updating the viewports will potentially move pixels and mark previously invisible regions as dirty. WindowManager::updateViewports(); // Render the uncovered regions. renderDirtyRegions(); // Draw FPS counter. if (Config::get().showFPS) { Gfx::drawFPS(_ctx); } } void SoftwareDrawingEngine::renderDirtyRegions() { _invalidationGrid.traverseDirtyCells([this](int32_t left, int32_t top, int32_t right, int32_t bottom) { this->render(Rect::fromLTRB(left, top, right, bottom)); }); } void SoftwareDrawingEngine::render(const Rect& _rect) { auto max = Rect(0, 0, Ui::width(), Ui::height()); auto rect = _rect.intersection(max); RenderTarget rt; rt.width = rect.width(); rt.height = rect.height(); rt.x = rect.left(); rt.y = rect.top(); rt.bits = _screenRT.bits + rect.left() + ((_screenRT.width + _screenRT.pitch) * rect.top()); rt.pitch = _screenRT.width + _screenRT.pitch - rect.width(); rt.zoomLevel = 0; // Set the render target to the screen rt. _ctx.pushRenderTarget(rt); // TODO: Remove main window and draw that independent from UI. // Draw UI. Ui::WindowManager::render(_ctx, rect); // Restore state. _ctx.popRenderTarget(); } void SoftwareDrawingEngine::present() { // Lock the surface before setting its pixels if (SDL_MUSTLOCK(_screenSurface)) { if (SDL_LockSurface(_screenSurface) < 0) { return; } } // Copy pixels from the virtual screen buffer to the surface auto& rt = getScreenRT(); if (rt.bits != nullptr) { std::memcpy(_screenSurface->pixels, rt.bits, _screenSurface->pitch * _screenSurface->h); } // Unlock the surface if (SDL_MUSTLOCK(_screenSurface)) { SDL_UnlockSurface(_screenSurface); } // Convert colours via palette mapping onto the RGBA surface. if (SDL_BlitSurface(_screenSurface, nullptr, _screenRGBASurface, nullptr)) { Logging::error("SDL_BlitSurface {}", SDL_GetError()); return; } // Copy the RGBA pixels into screen texture. SDL_UpdateTexture(_screenTexture, nullptr, _screenRGBASurface->pixels, _screenRGBASurface->pitch); const auto scaleFactor = Config::get().scaleFactor; if (scaleFactor > 1.0f) { // Copy screen texture to the scaled texture. SDL_SetRenderTarget(_renderer, _scaledScreenTexture); SDL_RenderCopy(_renderer, _screenTexture, nullptr, nullptr); // Copy scaled texture to primary render target. SDL_SetRenderTarget(_renderer, nullptr); SDL_RenderCopy(_renderer, _scaledScreenTexture, nullptr, nullptr); } else { SDL_RenderCopy(_renderer, _screenTexture, nullptr, nullptr); } // Display buffers. SDL_RenderPresent(_renderer); } DrawingContext& SoftwareDrawingEngine::getDrawingContext() { return _ctx; } const RenderTarget& SoftwareDrawingEngine::getScreenRT() { return _screenRT; } void SoftwareDrawingEngine::movePixels( const RenderTarget& rt, int16_t dstX, int16_t dstY, int16_t width, int16_t height, int16_t srcX, int16_t srcY) { if (dstX == 0 && dstY == 0) { return; } // Adjust for move off canvas. // NOTE: when zooming, there can be x, y, dx, dy combinations that go off the // canvas; hence the checks. This code should ultimately not be called when // zooming because this function is specific to updating the screen on move int32_t lmargin = std::min(dstX - srcX, 0); int32_t rmargin = std::min((int32_t)rt.width - (dstX - srcX + width), 0); int32_t tmargin = std::min(dstY - srcY, 0); int32_t bmargin = std::min((int32_t)rt.height - (dstY - srcY + height), 0); dstX -= lmargin; dstY -= tmargin; width += lmargin + rmargin; height += tmargin + bmargin; int32_t stride = rt.width + rt.pitch; uint8_t* to = rt.bits + dstY * stride + dstX; uint8_t* from = rt.bits + (dstY - srcY) * stride + dstX - srcX; if (srcY > 0) { // If positive dy, reverse directions to += (height - 1) * stride; from += (height - 1) * stride; stride = -stride; } // Move bytes for (int32_t i = 0; i < height; i++) { std::memmove(to, from, width); to += stride; from += stride; } } const Ui::ScreenInfo& SoftwareDrawingEngine::getScreenInfo() const { return _screenInfo; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/SoftwareDrawingEngine.h ```h #pragma once #include "Graphics/Gfx.h" #include "InvalidationGrid.h" #include "SoftwareDrawingContext.h" #include <OpenLoco/Engine/Ui/Rect.hpp> #include <algorithm> #include <cstddef> #include <memory> struct SDL_Palette; struct SDL_Surface; struct SDL_Window; struct SDL_Renderer; struct SDL_Texture; struct SDL_PixelFormat; namespace OpenLoco::Ui { struct ScreenInfo; } namespace OpenLoco::Gfx { struct RenderTarget; class SoftwareDrawingEngine { public: SoftwareDrawingEngine(); ~SoftwareDrawingEngine(); void initialize(SDL_Window* window); void resize(int32_t width, int32_t height); // Renders all invalidated regions. void render(); // Renders a specific region. void render(const Ui::Rect& rect); // Presents the final image to the screen. void present(); // Invalidates a region, this forces it to be rendered next frame. void invalidateRegion(int32_t left, int32_t top, int32_t right, int32_t bottom); void createPalette(); SDL_Palette* getPalette() { return _palette; } void updatePalette(const PaletteEntry* entries, int32_t index, int32_t count); DrawingContext& getDrawingContext(); const RenderTarget& getScreenRT(); // Moves the pixels in the specified render target. void movePixels( const RenderTarget& rt, int16_t dstX, int16_t dstY, int16_t width, int16_t height, int16_t srcX, int16_t srcY); const Ui::ScreenInfo& getScreenInfo() const; private: void renderDirtyRegions(); private: SDL_Renderer* _renderer{}; SDL_Window* _window{}; SDL_Palette* _palette{}; SDL_Surface* _screenSurface{}; SDL_Surface* _screenRGBASurface{}; SDL_Texture* _screenTexture{}; SDL_Texture* _scaledScreenTexture{}; SDL_PixelFormat* _screenTextureFormat{}; SDL_Texture* _screenRGBATexture{}; SoftwareDrawingContext _ctx; InvalidationGrid _invalidationGrid; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/TextRenderer.cpp ```cpp #include "TextRenderer.h" #include "DrawingContext.h" #include "Graphics/Gfx.h" #include "Graphics/ImageIds.h" #include "Localisation/Formatting.h" #include "RenderTarget.h" #include "Ui/WindowManager.h" namespace OpenLoco::Gfx { struct TextDrawingState { Font font; TextDrawFlags fontFlags; PaletteMap::Buffer<8> textColours{ 0 }; }; namespace Impl { static uint16_t getStringWidth(Font font, const char* str); static std::pair<uint16_t, uint16_t> wrapString(Font font, char* buffer, uint16_t stringWidth); static uint16_t wrapStringTicker(Font font, char* buffer, uint16_t stringWidth, uint16_t numCharacters); static int16_t clipString(Font font, int16_t width, char* string); static uint16_t getLineHeight(Font font) { if (font == Font::medium_normal || font == Font::medium_bold) { return 10; } else if (font == Font::small) { return 6; } else if (font == Font::large) { return 18; } return 0; } static uint16_t getSmallerLineHeight(Font font) { if (font == Font::medium_normal || font == Font::medium_bold) { return 5; } else if (font == Font::small) { return 3; } else if (font == Font::large) { return 9; } return 0; } static void setTextColours(TextDrawingState& drawState, PaletteIndex_t pal1, PaletteIndex_t pal2, PaletteIndex_t pal3) { if ((drawState.fontFlags & TextDrawFlags::inset) != TextDrawFlags::none) { return; } drawState.textColours[PaletteIndex::textRemap0] = pal1; drawState.textColours[PaletteIndex::textRemap1] = PaletteIndex::transparent; drawState.textColours[PaletteIndex::textRemap2] = PaletteIndex::transparent; if ((drawState.fontFlags & TextDrawFlags::outline) != TextDrawFlags::none) { drawState.textColours[PaletteIndex::textRemap1] = pal2; drawState.textColours[PaletteIndex::textRemap2] = pal3; } } static void setTextColour(TextDrawingState& drawState, int colour) { const auto* el = getG1Element(ImageIds::text_palette); setTextColours(drawState, el->offset[colour * 4 + 0], el->offset[colour * 4 + 1], el->offset[colour * 4 + 2]); } // 0x00451189 static Ui::Point loopNewline(TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget* rt, Ui::Point origin, const char* str) { Ui::Point pos = origin; while (true) { // When off-screen in y dimension don't draw text // In original this check only performed if pos.y updated instead of every loop bool offscreen = true; if (pos.y + 19 > rt->y) { if (rt->y + rt->height > pos.y) { offscreen = false; } } const auto chr = static_cast<uint8_t>(*str); str++; switch (chr) { case 0U: return pos; case ControlCodes::adjustPalette: // This control character does not appear in the localisation files assert(false); str++; break; case ControlCodes::newlineSmaller: pos.x = origin.x; pos.y += getSmallerLineHeight(drawState.font); break; case ControlCodes::newline: pos.x = origin.x; pos.y += getLineHeight(drawState.font); break; case ControlCodes::moveX: { uint8_t offset = *str; str++; pos.x = origin.x + offset; break; } case ControlCodes::newlineXY: { uint8_t offset = *str; str++; pos.x = origin.x + offset; offset = *str; str++; pos.y = origin.y + offset; break; } case ControlCodes::Font::small: drawState.font = Font::small; break; case ControlCodes::Font::large: drawState.font = Font::large; break; case ControlCodes::Font::regular: drawState.font = Font::medium_normal; break; case ControlCodes::Font::bold: drawState.font = Font::medium_bold; break; case ControlCodes::Font::outline: drawState.fontFlags |= TextDrawFlags::outline; break; case ControlCodes::Font::outlineOff: drawState.fontFlags &= ~TextDrawFlags::outline; break; case ControlCodes::windowColour1: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::primary).c(); setTextColours(drawState, Colours::getShade(hue, 7), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour2: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::secondary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour3: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::tertiary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour4: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::quaternary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::inlineSpriteStr: { uint32_t image = ((uint32_t*)str)[0]; ImageId imageId{ image & 0x7FFFF }; str += 4; if ((drawState.fontFlags & TextDrawFlags::inset) != TextDrawFlags::none) { ctx.drawImageSolid(pos, imageId, drawState.textColours[PaletteIndex::textRemap2]); ctx.drawImageSolid(pos + Ui::Point{ 1, 1 }, imageId, drawState.textColours[PaletteIndex::textRemap0]); } else { ctx.drawImage(pos.x, pos.y, image); } pos.x += getG1Element(imageId.getIndex())->width; break; } case ControlCodes::Colour::black: setTextColour(drawState, 0); break; case ControlCodes::Colour::grey: setTextColour(drawState, 1); break; case ControlCodes::Colour::white: setTextColour(drawState, 2); break; case ControlCodes::Colour::red: setTextColour(drawState, 3); break; case ControlCodes::Colour::green: setTextColour(drawState, 4); break; case ControlCodes::Colour::yellow: setTextColour(drawState, 5); break; case ControlCodes::Colour::topaz: setTextColour(drawState, 6); break; case ControlCodes::Colour::celadon: setTextColour(drawState, 7); break; case ControlCodes::Colour::babyBlue: setTextColour(drawState, 8); break; case ControlCodes::Colour::paleLavender: setTextColour(drawState, 9); break; case ControlCodes::Colour::paleGold: setTextColour(drawState, 10); break; case ControlCodes::Colour::lightPink: setTextColour(drawState, 11); break; case ControlCodes::Colour::pearlAqua: setTextColour(drawState, 12); break; case ControlCodes::Colour::paleSilver: setTextColour(drawState, 13); break; default: if (!offscreen) { // When off-screen in the y dimension there is no requirement to keep pos.x correct if (chr >= 32) { const auto chrImage = getImageForCharacter(drawState.font, chr); // Use withPrimary to set imageId flag to use the correct palette code (Colour::black is not actually used) ctx.drawImagePaletteSet(pos, chrImage.withPrimary(Colour::black), PaletteMap::View{ drawState.textColours }, {}); pos.x += Gfx::getCharacterWidth(drawState.font, chr); } else { // Unhandled control code assert(false); } } break; } } return pos; } /** * 0x00451025 * * @param x @<cx> * @param y @<dx> * @param colour @<al> * @param rt @<edi> * @param text @<esi> */ static Ui::Point drawString(TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, AdvancedColour colour, const char* str) { if (colour.isFE()) { return loopNewline(drawState, ctx, &rt, origin, str); } if (colour.isFD()) { drawState.fontFlags = TextDrawFlags::none; setTextColour(drawState, 0); return loopNewline(drawState, ctx, &rt, origin, str); } if (origin.x >= rt.x + rt.width) { return origin; } if (origin.x < rt.x - 1280) { return origin; } if (origin.y >= rt.y + rt.height) { return origin; } if (origin.y < rt.y - 90) { return origin; } if (colour.isFF()) { return loopNewline(drawState, ctx, &rt, origin, str); } drawState.fontFlags = TextDrawFlags::none; if (drawState.font == Font::m1) { drawState.font = Font::medium_bold; drawState.fontFlags |= TextDrawFlags::dark; } else if (drawState.font == Font::m2) { drawState.font = Font::medium_bold; drawState.fontFlags |= TextDrawFlags::dark; drawState.fontFlags |= TextDrawFlags::extraDark; } drawState.textColours[PaletteIndex::transparent] = PaletteIndex::transparent; drawState.textColours[PaletteIndex::textRemap0] = Colours::getShade(Colour::mutedDarkPurple, 5); drawState.textColours[PaletteIndex::textRemap1] = Colours::getShade(Colour::mutedRed, 5); drawState.textColours[PaletteIndex::textRemap2] = Colours::getShade(Colour::blue, 5); if (colour.isOutline()) { colour = colour.clearOutline(); drawState.fontFlags |= TextDrawFlags::outline; } if (colour.isInset()) { colour = colour.clearInset(); drawState.fontFlags |= TextDrawFlags::inset; } if ((drawState.fontFlags & TextDrawFlags::inset) != TextDrawFlags::none) { if ((drawState.fontFlags & TextDrawFlags::dark) != TextDrawFlags::none && (drawState.fontFlags & TextDrawFlags::extraDark) != TextDrawFlags::none) { drawState.textColours[PaletteIndex::textRemap0] = Colours::getShade(colour.c(), 2); drawState.textColours[PaletteIndex::textRemap1] = PaletteIndex::transparent; drawState.textColours[PaletteIndex::textRemap2] = Colours::getShade(colour.c(), 4); } else if ((drawState.fontFlags & TextDrawFlags::dark) != TextDrawFlags::none) { drawState.textColours[PaletteIndex::textRemap0] = Colours::getShade(colour.c(), 3); drawState.textColours[PaletteIndex::textRemap1] = PaletteIndex::transparent; drawState.textColours[PaletteIndex::textRemap2] = Colours::getShade(colour.c(), 5); } else { drawState.textColours[PaletteIndex::textRemap0] = Colours::getShade(colour.c(), 4); drawState.textColours[PaletteIndex::textRemap1] = PaletteIndex::transparent; drawState.textColours[PaletteIndex::textRemap2] = Colours::getShade(colour.c(), 6); } } else { setTextColours(drawState, Colours::getShade(colour.c(), 9), PaletteIndex::black0, PaletteIndex::black0); } return loopNewline(drawState, ctx, &rt, origin, str); } // Use only with buffer mangled by wrapString static const char* advanceToNextLineWrapped(const char* str) { // Traverse the buffer for the next line const char* ptr = str; while (true) { const auto chr = static_cast<uint8_t>(*ptr++); if (chr == 0U) { return ptr; } if (chr >= ControlCodes::oneArgBegin && chr < ControlCodes::oneArgEnd) { // Skip argument ptr++; } else if (chr >= ControlCodes::twoArgBegin && chr < ControlCodes::twoArgEnd) { // Skip argument ptr += 2; } else if (chr >= ControlCodes::fourArgBegin && chr < ControlCodes::fourArgEnd) { // Skip argument ptr += 4; } } return nullptr; } // 0x00495224 // al: colour // bp: width // bx: string id // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringLeftWrapped( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, int16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); // Setup the text colours (FIXME: This should be a separate function) const auto curDrawState = drawState; char empty[1] = ""; drawString(drawState, ctx, rt, origin, colour, empty); drawState = curDrawState; auto wrapResult = wrapString(drawState.font, buffer, width); auto breakCount = wrapResult.second + 1; // wrapString might change the font due to formatting codes uint16_t lineHeight = getLineHeight(drawState.font); // _112D404 auto point = origin; const char* ptr = buffer; for (auto i = 0; ptr != nullptr && i < breakCount; i++) { drawString(drawState, ctx, rt, point, AdvancedColour::FE(), const_cast<char*>(ptr)); ptr = advanceToNextLineWrapped(ptr); point.y += lineHeight; } return point; } /** * 0x00494B3F * @param rt @<edi> * @param origin {x @<cx>, y @<dx>} * @param colour @<al> * @param stringId @<bx> * @param args @<edi> */ static Ui::Point drawStringLeft( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); return drawString(drawState, ctx, rt, origin, colour, buffer); } // 0x00494BBF // al: colour // bx: string id // cx: x // dx: y // esi: args // edi: rt // bp: width static Ui::Point drawStringLeftClipped( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); clipString(drawState.font, width, buffer); return drawString(drawState, ctx, rt, origin, colour, buffer); } // 0x00494C78 // al: colour // bx: string id // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringRight( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); uint16_t width = getStringWidth(drawState.font, buffer); auto point = origin; point.x -= width; return drawString(drawState, ctx, rt, point, colour, buffer); } // 0x00494CB2 // al: colour // bx: string id // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringRightUnderline( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); uint16_t width = getStringWidth(drawState.font, buffer); auto point = origin; point.x -= width; drawString(drawState, ctx, rt, point, colour, buffer); // Draw underline ctx.drawRect(point.x, point.y + 11, width, 1, drawState.textColours[PaletteIndex::textRemap0], RectFlags::none); if (drawState.textColours[PaletteIndex::textRemap1] != 0) { ctx.drawRect(point.x, point.y + 12, width, 1, drawState.textColours[PaletteIndex::textRemap1], RectFlags::none); } return point; } // 0x00494D78 // al: colour // bx: string id // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringLeftUnderline( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); uint16_t width = getStringWidth(drawState.font, buffer); auto point = drawString(drawState, ctx, rt, origin, colour, buffer); // Draw underline ctx.drawRect(origin.x, origin.y + 11, width, 1, drawState.textColours[PaletteIndex::textRemap0], RectFlags::none); if (drawState.textColours[PaletteIndex::textRemap1] != 0) { ctx.drawRect(origin.x, origin.y + 12, width, 1, drawState.textColours[PaletteIndex::textRemap1], RectFlags::none); } return point; } // 0x00494DE8 // al: colour // bx: string id // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringCentred( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); uint16_t width = getStringWidth(drawState.font, buffer); auto point = origin; point.x = origin.x - (width / 2); if (point.x < 0) { return origin; } return drawString(drawState, ctx, rt, point, colour, buffer); } // 0x00494C36 // al: colour // bx: string id // bp: width // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringCentredClipped( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); width = clipString(drawState.font, width, buffer); auto point = Ui::Point(origin.x - (width / 2), origin.y); return drawString(drawState, ctx, rt, point, colour, buffer); } /** * 0x00494ECF * * @param rt @<edi> * @param origin {x @<cx>, y @<dx>} * @param width @<bp> * @param colour @<al> * @param stringId @<bx> * @param args @<esi> * returns width @<ax> */ static Ui::Point drawStringCentredWrapped( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args) { // Setup the text colours (FIXME: This should be a separate function) auto curDrawState = drawState; char empty[1] = ""; drawString(drawState, ctx, rt, origin, colour, empty); drawState = curDrawState; char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId, args); auto wrapResult = wrapString(drawState.font, buffer, width); auto breakCount = wrapResult.second + 1; // wrapString might change the font due to formatting codes uint16_t lineHeight = getLineHeight(drawState.font); // _112D404 Ui::Point basePoint = origin; basePoint.y -= (lineHeight / 2) * (breakCount - 1); const char* ptr = buffer; uint16_t lineWidth{}; uint16_t maxLineWidth{}; for (auto i = 0; ptr != nullptr && i < breakCount; i++) { lineWidth = getStringWidth(drawState.font, ptr); maxLineWidth = std::max(lineWidth, maxLineWidth); auto point = basePoint; point.x -= lineWidth / 2; drawString(drawState, ctx, rt, point, AdvancedColour::FE(), const_cast<char*>(ptr)); ptr = advanceToNextLineWrapped(ptr); basePoint.y += lineHeight; } basePoint.x -= maxLineWidth / 2; return basePoint; } // 0x00494E33 // al: colour // bx: string id // bp: width // cx: x // dx: y // esi: args // edi: rt static Ui::Point drawStringCentredRaw( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, uint16_t linebreakCount, AdvancedColour colour, const char* wrappedStr) { // Setup the text colours (FIXME: This should be a separate function) char empty[1] = ""; drawString(drawState, ctx, rt, origin, colour, empty); const char* ptr = wrappedStr; auto basePoint = origin; for (auto i = 0; i < linebreakCount + 1 && ptr != nullptr; ++i) { uint16_t lineWidth = getStringWidth(drawState.font, ptr); auto point = basePoint; point.x -= lineWidth / 2; drawString(drawState, ctx, rt, point, AdvancedColour::FE(), const_cast<char*>(ptr)); ptr = advanceToNextLineWrapped(ptr); basePoint.y += getLineHeight(drawState.font); } return basePoint; } static void drawStringYOffsets( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, const Ui::Point& loc, AdvancedColour colour, const char* str, const int8_t* yOffsets) { // This function has been somewhat simplified removing unreachable parts if (colour.isFE()) { assert(false); return; } if (loc.x >= rt.x + rt.width) { return; } if (loc.x < rt.x - 1280) { return; } if (loc.y >= rt.y + rt.height) { return; } // Note: 60 not 90 like drawString if (loc.y < rt.y - 60) { return; } drawState.fontFlags = TextDrawFlags::none; setTextColours(drawState, Colours::getShade(colour.c(), 9), PaletteIndex::black0, PaletteIndex::black0); Ui::Point pos = loc; while (true) { // When off-screen in y dimension don't draw text // In original this check only performed if pos.y updated instead of every loop bool offscreen = true; // Note: 39 unlike drawString if (pos.y + 39 > rt.y) { if (rt.y + rt.height > pos.y - 20) { offscreen = false; } } const auto chr = static_cast<uint8_t>(*str); str++; switch (chr) { case 0U: return; case ControlCodes::adjustPalette: // This control character does not appear in the localisation files assert(false); str++; break; case ControlCodes::newlineSmaller: pos.x = loc.x; pos.y += getSmallerLineHeight(drawState.font); break; case ControlCodes::newline: pos.x = loc.x; pos.y += getLineHeight(drawState.font); break; case ControlCodes::moveX: { uint8_t offset = *str; str++; pos.x = loc.x + offset; break; } case ControlCodes::newlineXY: { uint8_t offset = *str; str++; pos.x = loc.x + offset; offset = *str; str++; pos.y = loc.y + offset; break; } case ControlCodes::Font::small: drawState.font = Font::small; break; case ControlCodes::Font::large: drawState.font = Font::large; break; case ControlCodes::Font::regular: drawState.font = Font::medium_normal; break; case ControlCodes::Font::bold: drawState.font = Font::medium_bold; break; case ControlCodes::Font::outline: drawState.fontFlags |= TextDrawFlags::outline; break; case ControlCodes::Font::outlineOff: drawState.fontFlags &= ~TextDrawFlags::outline; break; case ControlCodes::windowColour1: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::primary).c(); setTextColours(drawState, Colours::getShade(hue, 7), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour2: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::secondary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour3: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::tertiary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour4: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::quaternary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::inlineSpriteStr: { str += 4; // Not handled for YOffsets code assert(false); break; } case ControlCodes::Colour::black: setTextColour(drawState, 0); break; case ControlCodes::Colour::grey: setTextColour(drawState, 1); break; case ControlCodes::Colour::white: setTextColour(drawState, 2); break; case ControlCodes::Colour::red: setTextColour(drawState, 3); break; case ControlCodes::Colour::green: setTextColour(drawState, 4); break; case ControlCodes::Colour::yellow: setTextColour(drawState, 5); break; case ControlCodes::Colour::topaz: setTextColour(drawState, 6); break; case ControlCodes::Colour::celadon: setTextColour(drawState, 7); break; case ControlCodes::Colour::babyBlue: setTextColour(drawState, 8); break; case ControlCodes::Colour::paleLavender: setTextColour(drawState, 9); break; case ControlCodes::Colour::paleGold: setTextColour(drawState, 10); break; case ControlCodes::Colour::lightPink: setTextColour(drawState, 11); break; case ControlCodes::Colour::pearlAqua: setTextColour(drawState, 12); break; case ControlCodes::Colour::paleSilver: setTextColour(drawState, 13); break; default: if (pos.x >= rt.x + rt.width) { offscreen = true; } if (!offscreen) { if (pos.x + 26 < rt.x) { pos.x += Gfx::getCharacterWidth(drawState.font, chr); yOffsets++; } else { if (chr >= 32) { // Use withPrimary to set imageId flag to use the correct palette code (Colour::black is not actually used) const auto chrImage = getImageForCharacter(drawState.font, chr); ctx.drawImagePaletteSet(pos + Ui::Point(0, *yOffsets), chrImage.withPrimary(Colour::black), PaletteMap::View{ drawState.textColours }, {}); pos.x += Gfx::getCharacterWidth(drawState.font, chr); yOffsets++; } else { // Unhandled control code assert(false); } } } break; } } } // 0x00451582 static int16_t drawStringMaxChars( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, const AdvancedColour colour, uint8_t* str, const int16_t numCharsRemaining) { // This function has been somewhat simplified removing unreachable parts if (!colour.isFE()) { assert(false); return numCharsRemaining; } int16_t numChars = numCharsRemaining; Ui::Point pos = origin; while (true) { if (numChars == 0) { break; } // When off-screen in y dimension don't draw text // In original this check only performed if pos.y updated instead of every loop bool offscreen = true; if (pos.y + 19 > rt.y) { if (rt.y + rt.height > pos.y) { offscreen = false; } } const auto chr = static_cast<uint8_t>(*str); str++; switch (chr) { case 0U: return numChars; case ControlCodes::adjustPalette: // This control character does not appear in the localisation files assert(false); str++; break; case ControlCodes::newlineSmaller: pos.x = origin.x; pos.y += getSmallerLineHeight(drawState.font); break; case ControlCodes::newline: pos.x = origin.x; pos.y += getLineHeight(drawState.font); break; case ControlCodes::moveX: { uint8_t offset = *str; str++; pos.x = origin.x + offset; break; } case ControlCodes::newlineXY: { uint8_t offset = *str; str++; pos.x = origin.x + offset; offset = *str; str++; pos.y = origin.y + offset; break; } case ControlCodes::Font::small: drawState.font = Font::small; break; case ControlCodes::Font::large: drawState.font = Font::large; break; case ControlCodes::Font::regular: drawState.font = Font::medium_normal; break; case ControlCodes::Font::bold: drawState.font = Font::medium_bold; break; case ControlCodes::Font::outline: drawState.fontFlags |= TextDrawFlags::outline; break; case ControlCodes::Font::outlineOff: drawState.fontFlags &= ~TextDrawFlags::outline; break; case ControlCodes::windowColour1: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::primary).c(); setTextColours(drawState, Colours::getShade(hue, 7), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour2: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::secondary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour3: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::tertiary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::windowColour4: { auto hue = Ui::WindowManager::getWindowColour(Ui::WindowColour::quaternary).c(); setTextColours(drawState, Colours::getShade(hue, 9), PaletteIndex::black0, PaletteIndex::black0); break; } case ControlCodes::inlineSpriteStr: { uint32_t image = ((uint32_t*)str)[0]; ImageId imageId{ image & 0x7FFFF }; str += 4; ctx.drawImage(pos.x, pos.y, image); // For some reason the wrapStringTicker doesn't do this?? numChars--; pos.x += getG1Element(imageId.getIndex())->width; break; } case ControlCodes::Colour::black: setTextColour(drawState, 0); break; case ControlCodes::Colour::grey: setTextColour(drawState, 1); break; case ControlCodes::Colour::white: setTextColour(drawState, 2); break; case ControlCodes::Colour::red: setTextColour(drawState, 3); break; case ControlCodes::Colour::green: setTextColour(drawState, 4); break; case ControlCodes::Colour::yellow: setTextColour(drawState, 5); break; case ControlCodes::Colour::topaz: setTextColour(drawState, 6); break; case ControlCodes::Colour::celadon: setTextColour(drawState, 7); break; case ControlCodes::Colour::babyBlue: setTextColour(drawState, 8); break; case ControlCodes::Colour::paleLavender: setTextColour(drawState, 9); break; case ControlCodes::Colour::paleGold: setTextColour(drawState, 10); break; case ControlCodes::Colour::lightPink: setTextColour(drawState, 11); break; case ControlCodes::Colour::pearlAqua: setTextColour(drawState, 12); break; case ControlCodes::Colour::paleSilver: setTextColour(drawState, 13); break; default: if (chr >= 32) { numChars--; } if (!offscreen) { // When off-screen in the y dimension there is no requirement to keep pos.x correct if (chr >= 32) { // Use withPrimary to set imageId flag to use the correct palette code (Colour::black is not actually used) const auto chrImage = getImageForCharacter(drawState.font, chr); ctx.drawImagePaletteSet(pos, chrImage.withPrimary(Colour::black), PaletteMap::View{ drawState.textColours }, {}); pos.x += Gfx::getCharacterWidth(drawState.font, chr); } else { // Unhandled control code assert(false); } } break; } } return numChars; } // 0x004950EF static void drawStringTicker( TextDrawingState& drawState, DrawingContext& ctx, const RenderTarget& rt, Ui::Point origin, StringId stringId, Colour colour, uint8_t numLinesToDisplay, uint16_t numCharactersToDisplay, uint16_t width) { // Setup the text colours (FIXME: This should be a separate function) const auto curDrawState = drawState; char empty[1] = ""; drawString(drawState, ctx, rt, origin, colour, empty); drawState = curDrawState; char buffer[512]; StringManager::formatString(buffer, std::size(buffer), stringId); const auto numLinesToDisplayAllChars = wrapStringTicker(drawState.font, buffer, width, numCharactersToDisplay); const auto lineToDisplayFrom = numLinesToDisplayAllChars - numLinesToDisplay; // wrapString might change the font due to formatting codes uint16_t lineHeight = getLineHeight(drawState.font); // _112D404 Ui::Point point = origin; if (lineToDisplayFrom > 0) { point.y -= lineHeight * lineToDisplayFrom; } const char* ptr = buffer; auto numChars = numCharactersToDisplay; for (auto i = 0; ptr != nullptr && i < numLinesToDisplayAllChars; i++) { uint16_t lineWidth = getStringWidth(drawState.font, ptr); // special drawstring numChars = drawStringMaxChars(drawState, ctx, rt, point - Ui::Point(lineWidth / 2, 0), AdvancedColour::FE(), reinterpret_cast<uint8_t*>(const_cast<char*>(ptr)), numChars); ptr = advanceToNextLineWrapped(ptr); point.y += lineHeight; } } // 0x00495301 // Note: Returned break count is -1. TODO: Refactor out this -1. // @return maxWidth @<cx> (numLinesToDisplayAllChars-1) @<di> static std::pair<uint16_t, uint16_t> wrapString(Font font, char* buffer, uint16_t stringWidth) { // std::vector<const char*> wrap; TODO: refactor to return pointers to line starts uint16_t wrapCount = 0; uint16_t maxWidth = 0; for (auto* ptr = buffer; *ptr != '\0';) { auto* startLine = ptr; uint16_t lineWidth = 0; auto lastWordLineWith = lineWidth; auto* wordStart = ptr; for (; *ptr != '\0' && lineWidth < stringWidth; ++ptr) { const auto chr = static_cast<uint8_t>(*ptr); if (chr >= ControlCodes::noArgBegin && chr < ControlCodes::noArgEnd) { bool forceEndl = false; switch (chr) { case ControlCodes::newline: { *ptr = '\0'; forceEndl = true; ++ptr; // Skip over '\0' when forcing a new line wrapCount++; // wrap.push_back(startLine); TODO: refactor to return pointers to line starts maxWidth = std::max(maxWidth, lineWidth); break; } case ControlCodes::Font::small: font = Font::small; break; case ControlCodes::Font::large: font = Font::large; break; case ControlCodes::Font::bold: font = Font::medium_bold; break; case ControlCodes::Font::regular: font = Font::medium_normal; break; } if (forceEndl) { break; } } else if (chr >= ControlCodes::oneArgBegin && chr < ControlCodes::oneArgEnd) { switch (chr) { case ControlCodes::moveX: lineWidth = static_cast<uint8_t>(ptr[1]); break; } ptr += 1; } else if (chr >= ControlCodes::twoArgBegin && chr < ControlCodes::twoArgEnd) { ptr += 2; } else if (chr >= ControlCodes::fourArgBegin && chr < ControlCodes::fourArgEnd) { switch (chr) { case ControlCodes::inlineSpriteStr: { uint32_t image = *reinterpret_cast<const uint32_t*>(ptr); ImageId imageId{ image & 0x7FFFF }; auto* el = getG1Element(imageId.getIndex()); if (el != nullptr) { lineWidth += el->width; } break; } } ptr += 4; } else { if (*ptr == ' ') { wordStart = ptr; lastWordLineWith = lineWidth; } lineWidth += Gfx::getCharacterWidth(font, static_cast<uint8_t>(*ptr)); } } if (lineWidth >= stringWidth || *ptr == '\0') { if (startLine == wordStart || (*ptr == '\0' && lineWidth < stringWidth)) { // wrap.push_back(startLine); TODO: refactor to return pointers to line starts maxWidth = std::max(maxWidth, lineWidth); if (startLine == wordStart && *ptr != '\0') { // Shuffle the string forward by one to make space for line ending const auto len = StringManager::locoStrlen(ptr) + 1; // +1 for null termination std::copy_backward(ptr, ptr + len, ptr + len + 1); // Insert line ending *ptr++ = '\0'; } } else { // wrap.push_back(startLine); TODO: refactor to return pointers to line starts maxWidth = std::max(maxWidth, lastWordLineWith); // Insert line ending instead of space character *wordStart = '\0'; ptr = wordStart + 1; } wrapCount++; } } return std::make_pair(maxWidth, std::max(static_cast<uint16_t>(wrapCount) - 1, 0)); } // 0x0049544E // Vanilla would also return maxWidth @<cx> (breakCount-1) @<di> // @return numLinesToDisplayAllChars @<ax> static uint16_t wrapStringTicker(Font font, char* buffer, uint16_t stringWidth, uint16_t numCharacters) { // std::vector<const char*> wrap; TODO: refactor to return pointers to line starts uint16_t numLinesToDisplayAllChars = 1; int16_t charNum = numCharacters; for (auto* ptr = buffer; *ptr != '\0';) { auto* startLine = ptr; uint16_t lineWidth = 0; auto lastWordCharNum = charNum; auto* wordStart = ptr; for (; *ptr != '\0' && lineWidth < stringWidth; ++ptr) { const auto chr = static_cast<uint8_t>(*ptr); if (chr >= ControlCodes::noArgBegin && chr < ControlCodes::noArgEnd) { bool forceEndl = false; switch (chr) { case ControlCodes::newline: { *ptr = '\0'; forceEndl = true; ++ptr; // Skip over '\0' when forcing a new line // wrap.push_back(startLine); TODO: refactor to return pointers to line starts if (charNum > 0) { numLinesToDisplayAllChars++; } break; } case ControlCodes::Font::small: font = Font::small; break; case ControlCodes::Font::large: font = Font::large; break; case ControlCodes::Font::bold: font = Font::medium_bold; break; case ControlCodes::Font::regular: font = Font::medium_normal; break; } if (forceEndl) { break; } } else if (chr >= ControlCodes::oneArgBegin && chr < ControlCodes::oneArgEnd) { switch (*ptr) { case ControlCodes::moveX: lineWidth = static_cast<uint8_t>(ptr[1]); break; } ptr += 1; } else if (chr >= ControlCodes::twoArgBegin && chr < ControlCodes::twoArgEnd) { ptr += 2; } else if (chr >= ControlCodes::fourArgBegin && chr < ControlCodes::fourArgEnd) { switch (chr) { case ControlCodes::inlineSpriteStr: { uint32_t image = *reinterpret_cast<const uint32_t*>(ptr); ImageId imageId{ image & 0x7FFFF }; auto* el = getG1Element(imageId.getIndex()); if (el != nullptr) { lineWidth += el->width; } break; } } ptr += 4; } else { if (*ptr == ' ') { wordStart = ptr; lastWordCharNum = charNum; } charNum--; lineWidth += Gfx::getCharacterWidth(font, static_cast<uint8_t>(*ptr)); } } if (lineWidth >= stringWidth || *ptr == '\0') { if (startLine == wordStart || (*ptr == '\0' && lineWidth < stringWidth)) { // wrap.push_back(startLine); TODO: refactor to return pointers to line starts if (startLine == wordStart && *ptr != '\0') { // Shuffle the string forward by one to make space for line ending const auto len = StringManager::locoStrlen(ptr) + 1; // +1 for null termination std::copy_backward(ptr, ptr + len, ptr + len + 1); // Insert line ending *ptr++ = '\0'; } } else { // wrap.push_back(startLine); TODO: refactor to return pointers to line starts charNum = lastWordCharNum; if (charNum > 0) { numLinesToDisplayAllChars++; } // Insert line ending instead of space character *wordStart = '\0'; ptr = wordStart + 1; } } } return numLinesToDisplayAllChars; } // 0x004957C4 static int16_t clipString(Font font, int16_t width, char* string) { if (width < 6) { *string = '\0'; return 0; } // If width of the full string is less than allowed width then we don't need to clip auto clippedWidth = getStringWidth(font, string); if (clippedWidth <= width) { return clippedWidth; } // Append each character 1 by 1 with an ellipsis on the end until width is exceeded std::string bestString; std::string curString; for (const auto* chr = string; *chr != '\0'; ++chr) { curString.push_back(*chr); switch (static_cast<uint8_t>(*chr)) { case ControlCodes::moveX: curString.push_back(*++chr); break; case ControlCodes::adjustPalette: case 3: case 4: curString.push_back(*++chr); break; case ControlCodes::newline: case ControlCodes::newlineSmaller: case ControlCodes::Font::small: case ControlCodes::Font::large: case ControlCodes::Font::bold: case ControlCodes::Font::regular: case ControlCodes::Font::outline: case ControlCodes::Font::outlineOff: case ControlCodes::windowColour1: case ControlCodes::windowColour2: case ControlCodes::windowColour3: case ControlCodes::windowColour4: break; case ControlCodes::inlineSpriteStr: curString.push_back(*++chr); curString.push_back(*++chr); curString.push_back(*++chr); curString.push_back(*++chr); break; case ControlCodes::newlineXY: curString.push_back(*++chr); curString.push_back(*++chr); break; default: if (static_cast<uint8_t>(*chr) <= 0x16) { curString.push_back(*++chr); curString.push_back(*++chr); } else if (static_cast<uint8_t>(*chr) < 32) { curString.push_back(*++chr); curString.push_back(*++chr); curString.push_back(*++chr); curString.push_back(*++chr); } break; } auto ellipseString = curString; ellipseString.append("..."); auto ellipsedWidth = getStringWidth(font, ellipseString.c_str()); if (ellipsedWidth < width) { // Keep best string with ellipse bestString = ellipseString; } else { StringManager::locoStrcpy(string, bestString.c_str()); return getStringWidth(font, string); } } return getStringWidth(font, string); } /** * 0x00495685 * * @param buffer @<esi> * @return width @<cx> */ static uint16_t getStringWidth(Font font, const char* str) { uint16_t width = 0; while (*str != '\0') { const auto chr = static_cast<uint8_t>(*str); str++; if (chr >= 32) { width += Gfx::getCharacterWidth(font, chr); continue; } switch (chr) { case ControlCodes::moveX: width = *str; str++; break; case ControlCodes::adjustPalette: case 3: case 4: str++; break; case ControlCodes::newline: case ControlCodes::newlineSmaller: break; case ControlCodes::Font::small: font = Font::small; break; case ControlCodes::Font::large: font = Font::large; break; case ControlCodes::Font::bold: font = Font::medium_bold; break; case ControlCodes::Font::regular: font = Font::medium_normal; break; case ControlCodes::Font::outline: case ControlCodes::Font::outlineOff: case ControlCodes::windowColour1: case ControlCodes::windowColour2: case ControlCodes::windowColour3: case ControlCodes::windowColour4: break; case ControlCodes::newlineXY: width = *str++; str++; break; case ControlCodes::inlineSpriteStr: { const uint32_t image = reinterpret_cast<const uint32_t*>(str)[0]; const uint32_t imageId = image & 0x7FFFF; str += 4; width += getG1Element(imageId)->width; break; } default: if (chr <= 0x16) { str += 2; } else { str += 4; } break; } } return width; } static std::tuple<uint16_t, const char*, Font> getStringWidthOneLine(const char* ptr, Font font) { uint16_t lineWidth = 0; for (; *ptr != '\0'; ++ptr) { const auto chr = static_cast<uint8_t>(*ptr); if (chr >= ControlCodes::noArgBegin && chr < ControlCodes::noArgEnd) { switch (chr) { case ControlCodes::newline: { return std::make_tuple(lineWidth, ptr, font); } case ControlCodes::Font::small: font = Font::small; break; case ControlCodes::Font::large: font = Font::large; break; case ControlCodes::Font::bold: font = Font::medium_bold; break; case ControlCodes::Font::regular: font = Font::medium_normal; break; } } else if (chr >= ControlCodes::oneArgBegin && chr < ControlCodes::oneArgEnd) { switch (chr) { case ControlCodes::moveX: lineWidth = static_cast<uint8_t>(ptr[1]); break; } ptr += 1; } else if (chr >= ControlCodes::twoArgBegin && chr < ControlCodes::twoArgEnd) { ptr += 2; } else if (chr >= ControlCodes::fourArgBegin && chr < ControlCodes::fourArgEnd) { switch (chr) { case ControlCodes::inlineSpriteStr: { uint32_t image = *reinterpret_cast<const uint32_t*>(ptr); ImageId imageId{ image & 0x7FFFF }; auto* el = getG1Element(imageId.getIndex()); if (el != nullptr) { lineWidth += el->width; } break; } } ptr += 4; } else { lineWidth += Gfx::getCharacterWidth(font, chr); } } return std::make_tuple(lineWidth, ptr, font); } // 0x00495715 // @param buffer @<esi> // @return width @<cx> static uint16_t getStringWidthNewLined(Font font, const char* buffer) { uint16_t maxWidth = 0; for (auto* ptr = buffer; *ptr != '\0'; ++ptr) { auto [lineWidth, nextLine, nextFont] = getStringWidthOneLine(ptr, font); ptr = nextLine; font = nextFont; maxWidth = std::max(maxWidth, lineWidth); } return maxWidth; } /** * 0x004955BC * * @param buffer @<esi> * @return width @<cx> */ static uint16_t getMaxStringWidth(Font font, const char* str) { uint16_t width = 0; uint16_t maxWidth = 0; while (*str != '\0') { const auto chr = static_cast<uint8_t>(*str); str++; if (chr >= 32) { width += Gfx::getCharacterWidth(font, chr); continue; } switch (chr) { case ControlCodes::moveX: maxWidth = std::max(width, maxWidth); width = *str; str++; break; case ControlCodes::adjustPalette: case 3: case 4: str++; break; case ControlCodes::newline: case ControlCodes::newlineSmaller: continue; case ControlCodes::Font::small: font = Font::small; break; case ControlCodes::Font::large: font = Font::large; break; case ControlCodes::Font::bold: font = Font::medium_bold; break; case ControlCodes::Font::regular: font = Font::medium_normal; break; case ControlCodes::Font::outline: case ControlCodes::Font::outlineOff: case ControlCodes::windowColour1: case ControlCodes::windowColour2: case ControlCodes::windowColour3: case ControlCodes::windowColour4: break; case ControlCodes::newlineXY: maxWidth = std::max(width, maxWidth); width = *str; str += 2; break; case ControlCodes::inlineSpriteStr: { const uint32_t image = reinterpret_cast<const uint32_t*>(str)[0]; const uint32_t imageId = image & 0x7FFFF; str += 4; width += getG1Element(imageId)->width; break; } default: if (chr <= 0x16) { str += 2; } else { str += 4; } break; } } maxWidth = std::max(width, maxWidth); return maxWidth; } } // namespace Impl TextRenderer::TextRenderer(DrawingContext& ctx) : _ctx(ctx) { } Font TextRenderer::getCurrentFont() const { return _currentFontSpriteBase; } void TextRenderer::setCurrentFont(Font base) { _currentFontSpriteBase = base; } int16_t TextRenderer::clipString(int16_t width, char* string) const { return Impl::clipString(_currentFontSpriteBase, width, string); } int16_t TextRenderer::clipString(Font font, int16_t width, char* string) { return Impl::clipString(font, width, string); } uint16_t TextRenderer::getStringWidth(const char* buffer) const { return Impl::getStringWidth(_currentFontSpriteBase, buffer); } uint16_t TextRenderer::getStringWidth(const Font base, const char* buffer) { return Impl::getStringWidth(base, buffer); } uint16_t TextRenderer::getMaxStringWidth(const char* buffer) const { return Impl::getMaxStringWidth(_currentFontSpriteBase, buffer); } uint16_t TextRenderer::getMaxStringWidth(Font font, const char* buffer) { return Impl::getMaxStringWidth(font, buffer); } Ui::Point TextRenderer::drawString(Ui::Point origin, AdvancedColour colour, const char* str) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawString(drawState, _ctx, rt, origin, colour, str); } Ui::Point TextRenderer::drawStringLeft(Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringLeft(drawState, _ctx, rt, origin, colour, stringId, args); } Ui::Point TextRenderer::drawStringLeftClipped(Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringLeftClipped(drawState, _ctx, rt, origin, width, colour, stringId, args); } Ui::Point TextRenderer::drawStringLeftUnderline(Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringLeftUnderline(drawState, _ctx, rt, origin, colour, stringId, args); } Ui::Point TextRenderer::drawStringLeftWrapped(Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringLeftWrapped(drawState, _ctx, rt, origin, width, colour, stringId, args); } Ui::Point TextRenderer::drawStringCentred(Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringCentred(drawState, _ctx, rt, origin, colour, stringId, args); } Ui::Point TextRenderer::drawStringCentredClipped(Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringCentredClipped(drawState, _ctx, rt, origin, width, colour, stringId, args); } Ui::Point TextRenderer::drawStringCentredRaw(Ui::Point origin, uint16_t linebreakCount, AdvancedColour colour, const char* wrappedStr) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringCentredRaw(drawState, _ctx, rt, origin, linebreakCount, colour, wrappedStr); } Ui::Point TextRenderer::drawStringCentredWrapped(Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringCentredWrapped(drawState, _ctx, rt, origin, width, colour, stringId, args); } Ui::Point TextRenderer::drawStringRight(Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringRight(drawState, _ctx, rt, origin, colour, stringId, args); } Ui::Point TextRenderer::drawStringRightUnderline(Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args /* = {}*/) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringRightUnderline(drawState, _ctx, rt, origin, colour, stringId, args); } void TextRenderer::drawStringYOffsets(Ui::Point loc, AdvancedColour colour, const char* str, const int8_t* yOffsets) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; return Impl::drawStringYOffsets(drawState, _ctx, rt, loc, colour, str, yOffsets); } void TextRenderer::drawStringTicker(Ui::Point origin, StringId stringId, Colour colour, uint8_t numLinesToDisplay, uint16_t numCharactersToDisplay, uint16_t width) { auto& rt = _ctx.currentRenderTarget(); TextDrawingState drawState; drawState.font = _currentFontSpriteBase; drawState.fontFlags = _currentFontFlags; Impl::drawStringTicker(drawState, _ctx, rt, origin, stringId, colour, numLinesToDisplay, numCharactersToDisplay, width); } uint16_t TextRenderer::getStringWidthNewLined(const char* buffer) const { return Impl::getStringWidthNewLined(_currentFontSpriteBase, buffer); } uint16_t TextRenderer::getStringWidthNewLined(Font font, const char* buffer) { return Impl::getStringWidthNewLined(font, buffer); } std::pair<uint16_t, uint16_t> TextRenderer::wrapString(char* buffer, uint16_t stringWidth) const { return Impl::wrapString(_currentFontSpriteBase, buffer, stringWidth); } std::pair<uint16_t, uint16_t> TextRenderer::wrapString(Font font, char* buffer, uint16_t stringWidth) { return Impl::wrapString(font, buffer, stringWidth); } uint16_t TextRenderer::getLineHeight(Font font) { return Impl::getLineHeight(font); } uint16_t TextRenderer::getSmallerLineHeight(Font font) { return Impl::getSmallerLineHeight(font); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/Graphics/TextRenderer.h ```h #pragma once #include "DrawingContext.h" #include "Font.h" #include "Graphics/Gfx.h" #include "Graphics/PaletteMap.h" #include "Types.hpp" #include <OpenLoco/Engine/Ui/Rect.hpp> #include <cstdint> namespace OpenLoco::Gfx { class DrawingContext; // Make this maybe public? enum class TextDrawFlags : uint16_t { none = 0U, inset = (1U << 0), outline = (1U << 1), dark = (1U << 2), extraDark = (1U << 3), }; OPENLOCO_ENABLE_ENUM_OPERATORS(TextDrawFlags); class TextRenderer { DrawingContext& _ctx; TextDrawFlags _currentFontFlags{}; Font _currentFontSpriteBase{ Font::medium_bold }; public: TextRenderer(DrawingContext& ctx); Font getCurrentFont() const; void setCurrentFont(Font base); int16_t clipString(int16_t width, char* string) const; static int16_t clipString(Font font, int16_t width, char* string); uint16_t getStringWidth(const char* buffer) const; static uint16_t getStringWidth(Font base, const char* buffer); uint16_t getMaxStringWidth(const char* buffer) const; static uint16_t getMaxStringWidth(Font font, const char* buffer); uint16_t getStringWidthNewLined(const char* buffer) const; static uint16_t getStringWidthNewLined(Font font, const char* buffer); std::pair<uint16_t, uint16_t> wrapString(char* buffer, uint16_t stringWidth) const; static std::pair<uint16_t, uint16_t> wrapString(Font font, char* buffer, uint16_t stringWidth); static uint16_t getLineHeight(Font font); static uint16_t getSmallerLineHeight(Font font); Ui::Point drawString( Ui::Point origin, AdvancedColour colour, const char* str); Ui::Point drawStringLeft( Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringLeftClipped( Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringLeftUnderline( Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringLeftWrapped( Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringCentred( Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringCentredClipped( Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringCentredRaw( Ui::Point origin, uint16_t linebreakCount, AdvancedColour colour, const char* wrappedStr); Ui::Point drawStringCentredWrapped( Ui::Point origin, uint16_t width, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringRight( Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); Ui::Point drawStringRightUnderline( Ui::Point origin, AdvancedColour colour, StringId stringId, FormatArgumentsView args = {}); void drawStringYOffsets(Ui::Point loc, AdvancedColour colour, const char* str, const int8_t* yOffsets); void drawStringTicker(Ui::Point origin, StringId stringId, Colour colour, uint8_t numLinesToDisplay, uint16_t numCharactersToDisplay, uint16_t width); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/GameCommands.cpp ```cpp #include "GameCommands.h" #include "Airports/CreateAirport.h" #include "Airports/RemoveAirport.h" #include "Audio/Audio.h" #include "Buildings/CreateBuilding.h" #include "Buildings/RemoveBuilding.h" #include "Cheats/Cheat.h" #include "Company/BuildCompanyHeadquarters.h" #include "Company/ChangeCompanyColour.h" #include "Company/ChangeCompanyFace.h" #include "Company/ChangeLoan.h" #include "Company/RemoveCompanyHeadquarters.h" #include "Company/RenameCompanyName.h" #include "Company/RenameCompanyOwner.h" #include "Company/UpdateOwnerStatus.h" #include "CompanyAi/AiCreateRoadAndStation.h" #include "CompanyAi/AiCreateTrackAndStation.h" #include "CompanyAi/AiTrackReplacement.h" #include "Config.h" #include "Docks/CreatePort.h" #include "Docks/RemovePort.h" #include "General/LoadSaveQuit.h" #include "General/RenameStation.h" #include "General/SetGameSpeed.h" #include "General/TogglePause.h" #include "Industries/CreateIndustry.h" #include "Industries/RemoveIndustry.h" #include "Industries/RenameIndustry.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Logging.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/Tile.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Network/Network.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "Road/CreateRoad.h" #include "Road/CreateRoadMod.h" #include "Road/CreateRoadStation.h" #include "Road/RemoveRoad.h" #include "Road/RemoveRoadMod.h" #include "Road/RemoveRoadStation.h" #include "SceneManager.h" #include "Terraform/ChangeLandMaterial.h" #include "Terraform/ClearLand.h" #include "Terraform/CreateTree.h" #include "Terraform/CreateWall.h" #include "Terraform/LowerLand.h" #include "Terraform/LowerRaiseLandMountain.h" #include "Terraform/LowerWater.h" #include "Terraform/RaiseLand.h" #include "Terraform/RaiseWater.h" #include "Terraform/RemoveTree.h" #include "Terraform/RemoveWall.h" #include "Town/CreateTown.h" #include "Town/RemoveTown.h" #include "Town/RenameTown.h" #include "Track/CreateSignal.h" #include "Track/CreateTrack.h" #include "Track/CreateTrackMod.h" #include "Track/CreateTrainStation.h" #include "Track/RemoveSignal.h" #include "Track/RemoveTrack.h" #include "Track/RemoveTrackMod.h" #include "Track/RemoveTrainStation.h" #include "Ui/WindowManager.h" #include "Vehicles/CloneVehicle.h" #include "Vehicles/CreateVehicle.h" #include "Vehicles/RenameVehicle.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleChangeRunningMode.h" #include "Vehicles/VehicleOrderDelete.h" #include "Vehicles/VehicleOrderDown.h" #include "Vehicles/VehicleOrderInsert.h" #include "Vehicles/VehicleOrderReverse.h" #include "Vehicles/VehicleOrderSkip.h" #include "Vehicles/VehicleOrderUp.h" #include "Vehicles/VehiclePassSignal.h" #include "Vehicles/VehiclePickup.h" #include "Vehicles/VehiclePickupAir.h" #include "Vehicles/VehiclePickupWater.h" #include "Vehicles/VehiclePlace.h" #include "Vehicles/VehiclePlaceAir.h" #include "Vehicles/VehiclePlaceWater.h" #include "Vehicles/VehicleRearrange.h" #include "Vehicles/VehicleRefit.h" #include "Vehicles/VehicleRepaint.h" #include "Vehicles/VehicleReverse.h" #include "Vehicles/VehicleSell.h" #include "Vehicles/VehicleSpeedControl.h" #include "World/Company.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <cassert> using namespace OpenLoco::Ui; namespace OpenLoco::GameCommands { static uint16_t _gameCommandFlags; static uint8_t _gameCommandNestLevel = 0; // 0x00508F08 static CompanyId _updatingCompanyId; // 0x009C68EB static const World::TileElement* _errorTileElementPtr = World::TileManager::kInvalidTile; // 0x009C68D0 static World::Pos3 _gGameCommandPosition; // 0x009C68E0 static StringId _gGameCommandErrorText; // 0x009C68E6 static StringId _gGameCommandErrorTitle; // 0x009C68E8 static ExpenditureType _gGameCommandExpenditureType; // 0x009C68EA static CompanyId _errorCompanyId; // 0x009C68EE using GameCommandFunc = void (*)(registers& regs); struct GameCommandInfo { GameCommand id; GameCommandFunc implementation; uintptr_t originalAddress; // original array: 0x004F9548 bool unpausesGame; // original array: 0x004F9688 }; // clang-format off static constexpr GameCommandInfo kGameCommandDefinitions[85] = { { GameCommand::vehicleRearrange, vehicleRearrange, 0x004AF1DF, true }, { GameCommand::vehiclePlace, vehiclePlace, 0x004B01B6, true }, { GameCommand::vehiclePickup, vehiclePickup, 0x004B0826, true }, { GameCommand::vehicleReverse, vehicleReverse, 0x004ADAA8, true }, { GameCommand::vehiclePassSignal, vehiclePassSignal, 0x004B0B50, true }, { GameCommand::vehicleCreate, createVehicle, 0x004AE5E4, true }, { GameCommand::vehicleSell, sellVehicle, 0x004AED34, true }, { GameCommand::createTrack, createTrack, 0x0049BB98, true }, { GameCommand::removeTrack, removeTrack, 0x0049C7F2, true }, { GameCommand::changeLoan, changeLoan, 0x0046DE88, false }, { GameCommand::vehicleRename, renameVehicle, 0x004B6572, false }, { GameCommand::changeStationName, renameStation, 0x00490756, false }, { GameCommand::vehicleChangeRunningMode, vehicleChangeRunningMode, 0x004B694B, true }, { GameCommand::createSignal, createSignal, 0x00488BDB, true }, { GameCommand::removeSignal, removeSignal, 0x004891E4, true }, { GameCommand::createTrainStation, createTrainStation, 0x0048BB20, true }, { GameCommand::removeTrainStation, removeTrainStation, 0x0048C402, true }, { GameCommand::createTrackMod, createTrackMod, 0x004A6479, true }, { GameCommand::removeTrackMod, removeTrackMod, 0x004A668A, true }, { GameCommand::changeCompanyColourScheme, changeCompanyColour, 0x0043483D, false }, { GameCommand::pauseGame, togglePause, 0x00431E32, false }, { GameCommand::loadSaveQuitGame, loadSaveQuit, 0x0043BFCB, false }, { GameCommand::removeTree, removeTree, 0x004BB392, true }, { GameCommand::createTree, createTree, 0x004BB138, true }, { GameCommand::changeLandMaterial, changeLandMaterial, 0x00468EDD, true }, { GameCommand::raiseLand, raiseLand, 0x00463702, true }, { GameCommand::lowerLand, lowerLand, 0x004638C6, true }, { GameCommand::lowerRaiseLandMountain, lowerRaiseLandMountain, 0x00462DCE, true }, { GameCommand::raiseWater, raiseWater, 0x004C4F19, true }, { GameCommand::lowerWater, lowerWater, 0x004C5126, true }, { GameCommand::changeCompanyName, changeCompanyName, 0x00434914, false }, { GameCommand::changeCompanyOwnerName, changeCompanyOwnerName, 0x00434A58, false }, { GameCommand::createWall, createWall, 0x004C436C, true }, { GameCommand::removeWall, removeWall, 0x004C466C, true }, { GameCommand::gc_unk_34, nullptr, 0x004C4717, false }, { GameCommand::vehicleOrderInsert, vehicleOrderInsert, 0x0047036E, false }, { GameCommand::vehicleOrderDelete, vehicleOrderDelete, 0x0047057A, false }, { GameCommand::vehicleOrderSkip, vehicleOrderSkip, 0x0047071A, false }, { GameCommand::createRoad, createRoad, 0x00475FBC, true }, { GameCommand::removeRoad, removeRoad, 0x004775A5, true }, { GameCommand::createRoadMod, createRoadMod, 0x0047A21E, true }, { GameCommand::removeRoadMod, removeRoadMod, 0x0047A42F, true }, { GameCommand::createRoadStation, createRoadStation, 0x0048C708, true }, { GameCommand::removeRoadStation, removeRoadStation, 0x0048D2AC, true }, { GameCommand::createBuilding, createBuilding, 0x0042D133, true }, { GameCommand::removeBuilding, removeBuilding, 0x0042D74E, true }, { GameCommand::renameTown, renameTown, 0x0049B11E, false }, { GameCommand::createIndustry, createIndustry, 0x0045436B, true }, { GameCommand::removeIndustry, removeIndustry, 0x00455943, true }, { GameCommand::createTown, createTown, 0x00496C22, true }, { GameCommand::removeTown, removeTown, 0x0049711F, true }, { GameCommand::aiCreateTrackAndStation, aiCreateTrackAndStation, 0x004A6FDC, true }, { GameCommand::aiTrackReplacement, aiTrackReplacement, 0x004A734F, true }, { GameCommand::aiCreateRoadAndStation, aiCreateRoadAndStation, 0x0047AF0B, true }, { GameCommand::buildCompanyHeadquarters, buildCompanyHeadquarters, 0x0042ECFC, true }, { GameCommand::removeCompanyHeadquarters, removeCompanyHeadquarters, 0x0042EEAF, true }, { GameCommand::createAirport, createAirport, 0x00492C41, true }, { GameCommand::removeAirport, removeAirport, 0x00493559, true }, { GameCommand::vehiclePlaceAir, vehiclePlaceAir, 0x004267BE, true }, { GameCommand::vehiclePickupAir, vehiclePickupAir, 0x00426B29, true }, { GameCommand::createPort, createPort, 0x00493AA7, true }, { GameCommand::removePort, removePort, 0x00494570, true }, { GameCommand::vehiclePlaceWater, vehiclePlaceWater, 0x0042773C, true }, { GameCommand::vehiclePickupWater, vehiclePickupWater, 0x004279CC, true }, { GameCommand::vehicleRefit, vehicleRefit, 0x0042F6DB, false }, { GameCommand::changeCompanyFace, changeCompanyFace, 0x00435506, false }, { GameCommand::clearLand, clearLand, 0x00469CCB, true }, { GameCommand::loadMultiplayerMap, nullptr, 0x00444DA0, false }, { GameCommand::gc_unk_68, nullptr, 0x0046F8A5, false }, { GameCommand::gc_unk_69, nullptr, 0x004454BE, false }, { GameCommand::gc_unk_70, nullptr, 0x004456C8, false }, { GameCommand::sendChatMessage, nullptr, 0x0046F976, false }, { GameCommand::multiplayerSave, nullptr, 0x004A0ACD, false }, { GameCommand::updateOwnerStatus, updateOwnerStatus, 0x004383CA, false }, { GameCommand::vehicleSpeedControl, vehicleSpeedControl, 0x004BAB63, true }, { GameCommand::vehicleOrderUp, vehicleOrderUp, 0x00470CD2, false }, { GameCommand::vehicleOrderDown, vehicleOrderDown, 0x00470E06, false }, { GameCommand::vehicleApplyShuntCheat, vehicleShuntCheat, 0x004BAC53, false }, { GameCommand::applyFreeCashCheat, freeCashCheat, 0x00438A08, false }, { GameCommand::renameIndustry, renameIndustry, 0x00455029, false }, { GameCommand::vehicleClone, cloneVehicle, 0, true }, { GameCommand::cheat, cheat, 0, true }, { GameCommand::setGameSpeed, setGameSpeed, 0, true }, { GameCommand::vehicleOrderReverse, vehicleOrderReverse, 0, false }, { GameCommand::vehicleRepaint, vehicleRepaint, 0, false }, }; // clang-format on static uint32_t loc_4314EA(); static uint32_t loc_4313C6(int esi, const registers& regs); static bool commandRequiresUnpausingGame(GameCommand command, uint16_t flags) { if ((flags & (Flags::aiAllocated | Flags::ghost)) != 0) { return false; } auto& gameCommand = kGameCommandDefinitions[static_cast<uint32_t>(command)]; if (!gameCommand.unpausesGame || SceneManager::isPauseOverrideEnabled()) { return false; } return true; } // 0x00431315 uint32_t doCommand(GameCommand command, const registers& regs) { uint16_t flags = regs.bx; uint32_t esi = static_cast<uint32_t>(command); _gameCommandFlags = regs.bx; if (_gameCommandNestLevel != 0) { return loc_4313C6(esi, regs); } if ((flags & Flags::apply) == 0) { return loc_4313C6(esi, regs); } auto isGhost = (flags & Flags::ghost) != 0; if (!isGhost && Network::isConnected()) { // For network games, we need to delay the command apply processing // Just return the result without applying for now registers copyRegs = regs; copyRegs.esi = static_cast<int32_t>(command); Network::queueGameCommand(_updatingCompanyId, copyRegs); copyRegs.bx &= ~Flags::apply; return loc_4313C6(esi, copyRegs); } return doCommandForReal(command, _updatingCompanyId, regs); } uint32_t doCommandForReal(GameCommand command, CompanyId company, const registers& regs) { _updatingCompanyId = company; uint16_t flags = regs.bx; uint32_t esi = static_cast<uint32_t>(command); if (commandRequiresUnpausingGame(command, flags) && _updatingCompanyId == CompanyManager::getControllingId()) { if (SceneManager::getPauseFlags() & 1) { SceneManager::unsetPauseFlag(1); WindowManager::invalidate(WindowType::timeToolbar); Audio::unpauseSound(); Ui::Windows::PlayerInfoPanel::invalidateFrame(); } if (SceneManager::getGameSpeed() != GameSpeed::Normal) { // calling the command setGameSpeed will cause infinite recursion here, so just call the real function SceneManager::setGameSpeed(GameSpeed::Normal); } if (SceneManager::isPaused()) { _gGameCommandErrorText = StringIds::empty; return GameCommands::FAILURE; } } if (_updatingCompanyId == CompanyManager::getControllingId() && SceneManager::isNetworked()) { // assert(false); // registers fnRegs = regs; // call(0x0046E34A, fnRegs); // some network stuff. Untested } return loc_4313C6(esi, regs); } static void callGameCommandFunction(uint32_t command, registers& regs) { auto& gameCommand = kGameCommandDefinitions[command]; if (gameCommand.implementation != nullptr) { gameCommand.implementation(regs); } else { auto addr = gameCommand.originalAddress; Diagnostics::Logging::error("Unimplemented game command called: id:{}, address:{}", static_cast<uint32_t>(gameCommand.id), addr); } } static uint32_t loc_4313C6(int esi, const registers& regs) { uint16_t flags = regs.bx; _gGameCommandErrorText = StringIds::null; _gameCommandNestLevel++; uint16_t flagsBackup = _gameCommandFlags; registers fnRegs1 = regs; fnRegs1.bl &= ~Flags::apply; callGameCommandFunction(esi, fnRegs1); int32_t ebx = fnRegs1.ebx; _gameCommandFlags = flagsBackup; if (ebx != static_cast<int32_t>(GameCommands::FAILURE)) { if (SceneManager::isEditorMode()) { ebx = 0; } if (_gameCommandNestLevel == 1) { if ((_gameCommandFlags & Flags::allowNegativeCashFlow) == 0 && (_gameCommandFlags & Flags::ghost) == 0 && ebx != 0) { if (!CompanyManager::ensureCompanyFunding(getUpdatingCompanyId(), ebx)) { ebx = GameCommands::FAILURE; } } } } if (ebx == static_cast<int32_t>(GameCommands::FAILURE)) { if (flags & Flags::apply) { return loc_4314EA(); } else { _gameCommandNestLevel--; return ebx; } } if ((flags & 1) == 0) { _gameCommandNestLevel--; return ebx; } uint16_t flagsBackup2 = _gameCommandFlags; registers fnRegs2 = regs; callGameCommandFunction(esi, fnRegs2); int32_t ebx2 = fnRegs2.ebx; _gameCommandFlags = flagsBackup2; if (ebx2 == static_cast<int32_t>(GameCommands::FAILURE)) { return loc_4314EA(); } if (SceneManager::isEditorMode()) { ebx = 0; } if (ebx2 < ebx) { ebx = ebx2; } _gameCommandNestLevel--; if (_gameCommandNestLevel != 0) { return ebx; } if ((flagsBackup2 & Flags::noPayment) != 0) { return ebx; } // Apply to company money CompanyManager::applyPaymentToCompany(GameCommands::getUpdatingCompanyId(), ebx, getExpenditureType()); if (ebx != 0 && _updatingCompanyId == CompanyManager::getControllingId()) { // Add flying cost text CompanyManager::spendMoneyEffect(getPosition() + World::Pos3{ 0, 0, 24 }, _updatingCompanyId, ebx); } return ebx; } static uint32_t loc_4314EA() { _gameCommandNestLevel--; if (_gameCommandNestLevel != 0) { return GameCommands::FAILURE; } if (_updatingCompanyId != CompanyManager::getControllingId()) { return GameCommands::FAILURE; } if (_gameCommandFlags & Flags::noErrorWindow) { return GameCommands::FAILURE; } if (_gGameCommandErrorText != 0xFFFE) { Windows::Error::open(_gGameCommandErrorTitle, _gGameCommandErrorText); return GameCommands::FAILURE; } // advanced errors if (_errorTileElementPtr != World::TileManager::kInvalidTile) { using namespace OpenLoco::World; auto* tile = _errorTileElementPtr; switch (tile->type()) { case ElementType::track: // 4 { auto& trackElement = tile->get<TrackElement>(); const TrackObject* pObject = ObjectManager::get<TrackObject>(trackElement.trackObjectId()); if (pObject == nullptr) { break; } auto formatter = FormatArguments::common(); formatter.push(pObject->name); formatter.push(CompanyManager::get(_errorCompanyId)->name); Windows::Error::openWithCompetitor(_gGameCommandErrorTitle, StringIds::error_reason_stringid_belongs_to, _errorCompanyId); return GameCommands::FAILURE; } case ElementType::road: // 0x1C { auto& roadElement = tile->get<RoadElement>(); const RoadObject* pObject = ObjectManager::get<RoadObject>(roadElement.roadObjectId()); if (pObject == nullptr) { break; } auto formatter = FormatArguments::common(); formatter.push(pObject->name); formatter.push(CompanyManager::get(_errorCompanyId)->name); Windows::Error::openWithCompetitor(_gGameCommandErrorTitle, StringIds::error_reason_stringid_belongs_to, _errorCompanyId); return GameCommands::FAILURE; } case ElementType::station: // 8 { auto& stationElement = tile->get<StationElement>(); const Station* pStation = StationManager::get(stationElement.stationId()); if (pStation == nullptr) { break; } auto formatter = FormatArguments::common(); formatter.push(pStation->name); formatter.push(pStation->town); formatter.push(CompanyManager::get(_errorCompanyId)->name); Windows::Error::openWithCompetitor(_gGameCommandErrorTitle, StringIds::error_reason_stringid_belongs_to, _errorCompanyId); return GameCommands::FAILURE; } case ElementType::signal: // 0x0C { auto formatter = FormatArguments::common(); formatter.push(CompanyManager::get(_errorCompanyId)->name); Windows::Error::openWithCompetitor(_gGameCommandErrorTitle, StringIds::error_reason_signal_belongs_to, _errorCompanyId); return GameCommands::FAILURE; } default: break; } } // fallback auto formatter = FormatArguments::common(); formatter.push(CompanyManager::get(_errorCompanyId)->name); Windows::Error::openWithCompetitor(_gGameCommandErrorTitle, StringIds::error_reason_belongs_to, _errorCompanyId); return GameCommands::FAILURE; } // 0x00431E6A // al : company // esi : tile bool sub_431E6A(const CompanyId company, const World::TileElement* const tile /*= nullptr*/) { if (company == CompanyId::neutral) { return true; } if (_updatingCompanyId == company || _updatingCompanyId == CompanyId::neutral) { return true; } _gGameCommandErrorText = 0xFFFEU; _errorCompanyId = company; _errorTileElementPtr = tile == nullptr ? World::TileManager::kInvalidTile : tile; return false; } const World::Pos3& getPosition() { return _gGameCommandPosition; } void setPosition(const World::Pos3& pos) { _gGameCommandPosition = pos; } void setErrorText(const StringId message) { _gGameCommandErrorText = message; } StringId getErrorText() { return _gGameCommandErrorText; } void setErrorTitle(const StringId title) { _gGameCommandErrorTitle = title; } ExpenditureType getExpenditureType() { return _gGameCommandExpenditureType; } void setExpenditureType(const ExpenditureType type) { _gGameCommandExpenditureType = type; } CompanyId getUpdatingCompanyId() { return _updatingCompanyId; } void setUpdatingCompanyId(const CompanyId companyId) { _updatingCompanyId = companyId; } uint8_t getCommandNestLevel() { return _gameCommandNestLevel; } void resetCommandNestLevel() { _gameCommandNestLevel = 0; } // TODO: Maybe move this somewhere else used by multiple game commands // 0x0048B013 void playConstructionPlacementSound(World::Pos3 pos) { const auto frequency = gPrng2().randNext(17955, 26146); Audio::playSound(Audio::SoundId::construct, pos, 0, frequency); } // TODO: Maybe move this somewhere else used by multiple game commands bool shouldInvalidateTile(uint8_t flags) { return !(flags & Flags::aiAllocated) && Config::get().showAiPlanningAsGhosts; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/GameCommands.h ```h #pragma once #include "Economy/Currency.h" #include "Entities/Entity.h" #include "Map/Tile.h" #include "Objects/Object.h" #include "World/Company.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco { enum ExpenditureType : uint8_t; enum class GameSpeed : uint8_t; enum class LoadOrQuitMode : uint16_t; } namespace OpenLoco::Vehicles { struct VehicleHead; } namespace OpenLoco::GameCommands { namespace Flags { constexpr uint8_t apply = 1 << 0; // 0x01 constexpr uint8_t preventBuildingClearing = 1 << 1; // 0x02 constexpr uint8_t allowNegativeCashFlow = 1 << 2; // 0x04 constexpr uint8_t noErrorWindow = 1 << 3; // 0x08 do not show an error window even on failure (use this with ghosts) constexpr uint8_t aiAllocated = 1 << 4; // 0x10 ai can place down invisible ghosts with this that blocks players constexpr uint8_t noPayment = 1 << 5; // 0x20 calculates cost but does not deduct it constexpr uint8_t ghost = 1 << 6; // 0x40 constexpr uint8_t flag_7 = 1 << 7; // 0x80 ai only? } enum class GameCommand : uint8_t { vehicleRearrange = 0, vehiclePlace = 1, vehiclePickup = 2, vehicleReverse = 3, vehiclePassSignal = 4, vehicleCreate = 5, vehicleSell = 6, createTrack = 7, removeTrack = 8, changeLoan = 9, vehicleRename = 10, changeStationName = 11, vehicleChangeRunningMode = 12, createSignal = 13, removeSignal = 14, createTrainStation = 15, removeTrainStation = 16, createTrackMod = 17, removeTrackMod = 18, changeCompanyColourScheme = 19, pauseGame = 20, loadSaveQuitGame = 21, removeTree = 22, createTree = 23, changeLandMaterial = 24, raiseLand = 25, lowerLand = 26, lowerRaiseLandMountain = 27, raiseWater = 28, lowerWater = 29, changeCompanyName = 30, changeCompanyOwnerName = 31, createWall = 32, removeWall = 33, gc_unk_34 = 34, vehicleOrderInsert = 35, vehicleOrderDelete = 36, vehicleOrderSkip = 37, createRoad = 38, removeRoad = 39, createRoadMod = 40, removeRoadMod = 41, createRoadStation = 42, removeRoadStation = 43, createBuilding = 44, removeBuilding = 45, renameTown = 46, createIndustry = 47, removeIndustry = 48, createTown = 49, removeTown = 50, aiCreateTrackAndStation = 51, aiTrackReplacement = 52, aiCreateRoadAndStation = 53, buildCompanyHeadquarters = 54, removeCompanyHeadquarters = 55, createAirport = 56, removeAirport = 57, vehiclePlaceAir = 58, vehiclePickupAir = 59, createPort = 60, removePort = 61, vehiclePlaceWater = 62, vehiclePickupWater = 63, vehicleRefit = 64, changeCompanyFace = 65, clearLand = 66, loadMultiplayerMap = 67, gc_unk_68 = 68, gc_unk_69 = 69, gc_unk_70 = 70, sendChatMessage = 71, multiplayerSave = 72, updateOwnerStatus = 73, vehicleSpeedControl = 74, vehicleOrderUp = 75, vehicleOrderDown = 76, vehicleApplyShuntCheat = 77, applyFreeCashCheat = 78, renameIndustry = 79, vehicleClone = 80, cheat = 81, setGameSpeed = 82, vehicleOrderReverse = 83, vehicleRepaint = 84, }; constexpr uint32_t FAILURE = 0x80000000; uint32_t doCommand(GameCommand command, const registers& registers); uint32_t doCommandForReal(GameCommand command, CompanyId company, const registers& registers); bool sub_431E6A(const CompanyId company, const World::TileElement* const tile = nullptr); template<typename T> uint32_t doCommand(const T& args, uint8_t flags) { registers regs = registers(args); regs.bl = flags; return doCommand(T::command, regs); } // Load multiplayer map inline void do_67(const char* filename) { registers regs; regs.bl = Flags::apply; regs.ebp = X86Pointer(filename); doCommand(GameCommand::loadMultiplayerMap, regs); } // Multiplayer-related inline void do_69() { registers regs; regs.bl = Flags::apply; doCommand(GameCommand::gc_unk_69, regs); } // Multiplayer-related inline void do_70() { registers regs; regs.bl = Flags::apply; doCommand(GameCommand::gc_unk_70, regs); } // Send chat message inline void do_71(int32_t ax, const char* string) { registers regs; regs.bl = Flags::apply; regs.ax = ax; memcpy(&regs.ecx, &string[0], 4); memcpy(&regs.edx, &string[4], 4); memcpy(&regs.ebp, &string[8], 4); memcpy(&regs.edi, &string[12], 4); doCommand(GameCommand::sendChatMessage, regs); } // Multiplayer save inline void do_72() { registers regs; regs.bl = Flags::apply; doCommand(GameCommand::multiplayerSave, regs); } const World::Pos3& getPosition(); void setPosition(const World::Pos3& pos); void setErrorText(const StringId message); StringId getErrorText(); void setErrorTitle(const StringId title); ExpenditureType getExpenditureType(); void setExpenditureType(const ExpenditureType type); CompanyId getUpdatingCompanyId(); void setUpdatingCompanyId(CompanyId companyId); uint8_t getCommandNestLevel(); void resetCommandNestLevel(); void playConstructionPlacementSound(World::Pos3 pos); bool shouldInvalidateTile(uint8_t flags); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Industries/CreateIndustry.cpp ```cpp #include "CreateIndustry.h" #include "Date.h" #include "Economy/Economy.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Terraform/CreateWall.h" #include "Graphics/Colour.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Map/AnimationManager.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "MessageManager.h" #include "Objects/IndustryObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/ScaffoldingObject.h" #include "Objects/TreeObject.h" #include "ScenarioOptions.h" #include "SceneManager.h" #include "ViewportManager.h" #include "World/IndustryManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::GameCommands { static loco_global<IndustryId, 0x00E0C3C9> _industryLastPlacedId; // Convert the cargo id's into a bitset static uint32_t getProducedCargoBitSet(const IndustryObject& indObj) { uint32_t producedCargoTypes = 0; for (auto& cargoType : indObj.producedCargoType) { if (cargoType != 0xFFU) { producedCargoTypes |= (1U << cargoType); } } return producedCargoTypes; } // Convert the cargo id's into a bitset static uint32_t getRequiredCargoBitSet(const IndustryObject& indObj) { uint32_t requiredCargoTypes = 0; for (auto& cargoType : indObj.requiredCargoType) { if (cargoType != 0xFFU) { requiredCargoTypes |= (1U << cargoType); } } return requiredCargoTypes; } // 0x00454C91 static IndustryId sub_454C91(uint8_t type, const World::Pos2& pos, const Core::Prng& prng) { const auto* indObj = ObjectManager::get<IndustryObject>(type); // 0x00E0C38C const uint32_t producedCargoTypes = getProducedCargoBitSet(*indObj); // 0x00E0C390 const uint32_t requiredCargoTypes = getRequiredCargoBitSet(*indObj); for (const auto& ind : IndustryManager::industries()) { const auto distance = Math::Vector::manhattanDistance2D(World::Pos2{ ind.x, ind.y }, pos); const auto* indObj2 = ind.getObject(); const uint32_t producedCargoTypes2 = getProducedCargoBitSet(*indObj2); const uint32_t requiredCargoTypes2 = getRequiredCargoBitSet(*indObj2); const auto hasAtLeast1CargoRequirement = ((requiredCargoTypes & producedCargoTypes2) != 0) || ((producedCargoTypes & requiredCargoTypes2) != 0); const auto minIndustryDistance = 32 * (hasAtLeast1CargoRequirement ? 24 : 9); if (distance < minIndustryDistance) { GameCommands::setErrorText(StringIds::too_close_to_another_industry); return IndustryId::null; } } const auto res = TownManager::getClosestTownAndDensity(pos); if (!res.has_value()) { GameCommands::setErrorText(StringIds::town_must_be_built_nearby_first); return IndustryId::null; } const auto id = IndustryManager::allocateNewIndustry(type, pos, prng, res->first); if (id != IndustryId::null) { return id; } GameCommands::setErrorText(StringIds::too_many_industries); return IndustryId::null; } // 0x0045572D static World::TileClearance::ClearFuncResult tileClearFunction(World::TileElement& el, const World::Pos2 pos, const uint8_t flags, currency32_t& cost) { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::clearTreeCollision(*elTree, pos, flags, cost); } /* 0x004551CC bh:7 = buildImmediately bh:0-3 = rotation edi = randColour << 16 dl = buildingType dh = industryId ax = pos.x cx = pos.y bl = flags */ static currency32_t placeIndustryBuilding(const IndustryId industryId, const World::Pos2& pos, const uint8_t direction, const uint8_t buildingType, const Colour colour, const bool buildImmediate, const uint8_t flags) { auto* industry = IndustryManager::get(industryId); auto* indObj = industry->getObject(); if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } const bool isMultiTile = indObj->buildingSizeFlags & (1U << buildingType); // Workout the max surface height for building footprint const auto buildingFootprint = getBuildingTileOffsets(isMultiTile); // 0x00E0C3CB (note this is smallZ) World::SmallZ highestBaseZ = 0; for (const auto& offset : buildingFootprint) { const auto tilePos = World::toTileSpace(pos + offset.pos); if (!World::validCoords(tilePos)) { continue; } auto tile = World::TileManager::get(tilePos); const auto* surface = tile.surface(); auto baseZ = World::TileManager::getSurfaceCornerHeight(*surface); highestBaseZ = std::max<World::SmallZ>(highestBaseZ, baseZ); if (surface->water()) { highestBaseZ = std::max<World::SmallZ>(highestBaseZ, surface->water() * World::kMicroToSmallZStep); } } // Workout clearance height of building (including scaffolding if required) const auto buildingParts = indObj->getBuildingParts(buildingType); const auto partHeights = indObj->getBuildingPartHeights(); // 0x00E0C3BC (note this is bigZ and does not include the base height) auto clearHeight = 0; for (auto part : buildingParts) { clearHeight += partHeights[part]; } if (!buildImmediate && indObj->scaffoldingSegmentType != 0xFF) { auto* scaffObj = ObjectManager::get<ScaffoldingObject>(); const auto segmentHeight = scaffObj->segmentHeights[indObj->scaffoldingSegmentType]; const bool requiresMore = clearHeight % segmentHeight; const auto numSegments = (clearHeight / segmentHeight) + (requiresMore ? 1 : 0); clearHeight = (numSegments * segmentHeight) + scaffObj->roofHeights[indObj->scaffoldingSegmentType]; } // ceil to 4 clearHeight += 3; clearHeight &= ~3; const auto clearZ = (clearHeight / World::kSmallZStep) + highestBaseZ; currency32_t totalCost = 0; // Loop over footprint for (const auto& offset : buildingFootprint) { const auto tilePos = World::toTileSpace(pos + offset.pos); if (!World::validCoords(tilePos)) { return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { World::TileManager::removeAllWallsOnTileBelow(tilePos, highestBaseZ + clearHeight / World::kSmallZStep); } { auto tile = World::TileManager::get(tilePos); const auto* surface = tile.surface(); auto clearFunc = [tilePos, flags, &totalCost](World::TileElement& el) { return tileClearFunction(el, World::toWorldSpace(tilePos), flags, totalCost); }; // Perform clearance checks if (indObj->hasFlags(IndustryObjectFlags::builtOnWater)) { if (surface->water() * World::kMicroToSmallZStep != highestBaseZ) { setErrorText(StringIds::can_only_be_built_on_water); return FAILURE; } if (surface->hasType6Flag()) { setErrorText(StringIds::water_channel_currently_needed_by_ships); return FAILURE; } World::QuarterTile qt(0xF, 0xF); if (!World::TileClearance::applyClearAtStandardHeight(World::toWorldSpace(tilePos), highestBaseZ, clearZ, qt, clearFunc)) { return FAILURE; } } else { if (surface->water()) { setErrorText(StringIds::cant_build_this_underwater); return FAILURE; } World::QuarterTile qt(0xF, 0xF); if (!World::TileClearance::applyClearAtStandardHeight(World::toWorldSpace(tilePos), surface->baseZ(), clearZ, qt, clearFunc)) { return FAILURE; } // TODO: This is dangerous pointer might be invalid? if (surface->slope() || surface->baseZ() != highestBaseZ) { const auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); totalCost += Economy::getInflationAdjustedCost(landObj->costFactor, landObj->costIndex, 10); } } } // Flatten surfaces (also checks if other elements will cause issues due to the flattening of the surface) if (!(flags & Flags::ghost) && !indObj->hasFlags(IndustryObjectFlags::builtOnWater)) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); if (surface->slope() || highestBaseZ != surface->baseZ()) { if (highestBaseZ < surface->baseZ()) { bool hasPassedSurface = false; for (auto& el : tile) { if (el.type() == World::ElementType::surface) { hasPassedSurface = true; continue; } if (hasPassedSurface) { auto* elTrack = el.as<World::TrackElement>(); auto* elRoad = el.as<World::RoadElement>(); auto* elStation = el.as<World::StationElement>(); auto* elBuilding = el.as<World::BuildingElement>(); auto* elIndustry = el.as<World::IndustryElement>(); auto* elTree = el.as<World::TreeElement>(); if (elTrack != nullptr && !elTrack->isGhost() && !elTrack->hasBridge()) { setErrorText(StringIds::empty); return FAILURE; } else if (elRoad != nullptr && !elRoad->isGhost() && !elRoad->hasBridge()) { setErrorText(StringIds::empty); return FAILURE; } else if (elStation != nullptr && elStation->stationType() == StationType::airport) { setErrorText(StringIds::empty); return FAILURE; } else if (elBuilding != nullptr) { setErrorText(StringIds::empty); return FAILURE; } else if (elIndustry != nullptr) { setErrorText(StringIds::empty); return FAILURE; } else if (elTree != nullptr && clearZ <= elTree->baseZ()) { setErrorText(StringIds::empty); return FAILURE; } } } } if (flags & Flags::apply) { World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); surface->setBaseZ(highestBaseZ); surface->setClearZ(highestBaseZ); surface->setSlope(0); surface->setSnowCoverage(0); surface->setGrowthStage(0); } } } // Create new tile if (flags & Flags::apply) { if (!(flags & Flags::ghost)) { World::TileManager::removeSurfaceIndustry(World::toWorldSpace(tilePos)); World::TileManager::setTerrainStyleAsCleared(World::toWorldSpace(tilePos)); } auto* elIndustry = World::TileManager::insertElement<World::IndustryElement>(World::toWorldSpace(tilePos), highestBaseZ, 0xF); if (elIndustry == nullptr) { return FAILURE; } elIndustry->setClearZ(clearZ); elIndustry->setRotation(direction); elIndustry->setIsConstructed(buildImmediate); elIndustry->setIndustryId(industryId); elIndustry->setSequenceIndex(offset.index); // TODO: If it turns out there are more vars in _5 they should be cleared here elIndustry->setSectionProgress(0); elIndustry->setColour(colour); elIndustry->setBuildingType(buildingType); elIndustry->setVar_6_003F(0); World::AnimationManager::createAnimation(3, World::toWorldSpace(tilePos), elIndustry->baseZ()); elIndustry->setGhost(flags & Flags::ghost); Ui::ViewportManager::invalidate(World::toWorldSpace(tilePos), elIndustry->baseHeight(), elIndustry->clearHeight()); } } auto& tileRef = industry->tiles[industry->numTiles]; tileRef = World::Pos3(pos, (highestBaseZ * World::kSmallZStep | (isMultiTile ? 0x8000 : 0))); industry->numTiles++; return totalCost; } // 0x0045442A static Colour getRandomAvailableColour(Core::Prng& prng, const IndustryObject& indObj) { // Could use a fixed size vector here as its never > Colour::max std::vector<Colour> availableColours; auto colourBitSet = indObj.availableColours; for (auto colourI32 = Numerics::bitScanForward(colourBitSet); colourI32 != -1; colourI32 = Numerics::bitScanForward(colourBitSet)) { colourBitSet &= ~(1ULL << colourI32); availableColours.push_back(static_cast<Colour>(colourI32)); } if (availableColours.empty()) { return Colour::black; } // Note: Don't optimise for size 1 as randNext required to prevent divergence return availableColours[prng.randNext(availableColours.size() - 1)]; } struct RangeAndMinDistance { tile_coord_t distanceRange; tile_coord_t minDistance; }; // As more placement attempts happen the distance searched to try place increases constexpr std::array<RangeAndMinDistance, 25> kPlacementAttemptDistanceRangeAndMin = { RangeAndMinDistance{ 1, 0 }, // 0 RangeAndMinDistance{ 3, -1 }, RangeAndMinDistance{ 3, -1 }, RangeAndMinDistance{ 3, -1 }, RangeAndMinDistance{ 3, -1 }, RangeAndMinDistance{ 3, -1 }, RangeAndMinDistance{ 3, -1 }, RangeAndMinDistance{ 3, -1 }, // 7 RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, RangeAndMinDistance{ 5, -2 }, }; // 0x0045436B static currency32_t createIndustry(const IndustryPlacementArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); { const auto centrePos = World::Pos2(args.pos.x + 16, args.pos.y + 16); const auto centreHeight = World::TileManager::getHeight(centrePos); GameCommands::setPosition({ args.pos.x, args.pos.y, centreHeight.landHeight }); } // TODO: Vanilla bug args.srand0 not set. Change this when we can diverge Core::Prng prng{ enumValue(GameCommand::createIndustry), args.srand1 }; const auto newIndustryId = sub_454C91(args.type, args.pos, prng); if (newIndustryId == IndustryId::null) { return FAILURE; } _industryLastPlacedId = newIndustryId; auto* newIndustry = IndustryManager::get(newIndustryId); auto* indObj = newIndustry->getObject(); if (args.buildImmediately) { newIndustry->under_construction = 0xFF; } if (flags & Flags::ghost) { newIndustry->flags |= IndustryFlags::isGhost; } if (!SceneManager::isEditorMode() && getUpdatingCompanyId() != CompanyId::neutral) { newIndustry->flags |= IndustryFlags::flag_04; newIndustry->owner = getUpdatingCompanyId(); } // 0x00E0C3D3 const auto randColour = getRandomAvailableColour(newIndustry->prng, *indObj); // 0x00E0C3BE - C0 auto lastPlacedBuildingPos = World::Pos2{ newIndustry->x, newIndustry->y }; // TODO: used also for 0x00454552 break up into two when function allowed to diverge const auto randVal = newIndustry->prng.randNext() & 0xFF; auto prodRateRand = randVal; for (auto i = 0; i < 2; ++i) { newIndustry->dailyProduction[i] = 0; const auto& initalRate = indObj->initialProductionRate[i]; newIndustry->dailyProductionTarget[i] = (((initalRate.max - initalRate.min) * prodRateRand) / 256) + initalRate.min; if (SceneManager::isEditorMode()) { newIndustry->dailyProduction[i] = newIndustry->dailyProductionTarget[i]; newIndustry->producedCargoQuantityPreviousMonth[i] = newIndustry->dailyProduction[i] * 30; } // This is odd but follows vanilla prodRateRand = newIndustry->dailyProductionTarget[i] & 0xFF; } currency32_t totalCost = 0; // 0x00454552 const auto numBuildings = (((indObj->maxNumBuildings - indObj->minNumBuildings + 1) * randVal) / 256) + indObj->minNumBuildings; const auto buildings = indObj->getBuildings(); for (auto i = 0U; i < numBuildings; ++i) { const auto building = buildings[i]; // 0x00E0C3D2 (bit 0) const bool isMultiTile = indObj->buildingSizeFlags & (1ULL << building); bool hasBuildingPlaced = false; // Attempt to place for (auto j = 0U; j < 25; ++j) { const auto randVal2 = newIndustry->prng.randNext(); // bh const uint8_t direction = indObj->hasFlags(IndustryObjectFlags::notRotatable) ? 0 : randVal2 & 0x3; const auto [distanceRange, minDistance] = kPlacementAttemptDistanceRangeAndMin[j]; const auto randTileX = static_cast<tile_coord_t>((distanceRange * ((randVal2 >> 18) & 0xFF)) / 256) + minDistance; const auto randTileY = static_cast<tile_coord_t>((distanceRange * ((randVal2 >> 2) & 0xFF)) / 256) + minDistance; const auto randPos = lastPlacedBuildingPos + World::toWorldSpace(World::TilePos2(randTileX, randTileY)); const auto minRandPos = randPos; const auto maxRandPos = isMultiTile ? randPos + World::toWorldSpace(World::TilePos2{ 1, 1 }) : randPos; // TODO: Yank this out into a function bool placementFailure = false; for (auto k = 0U; k < newIndustry->numTiles; ++k) { const auto minTileLoc = World::Pos2{ newIndustry->tiles[k].x, newIndustry->tiles[k].y }; const auto maxTileLoc = (newIndustry->tiles[k].z & (1U << 15)) ? minTileLoc + World::toWorldSpace(World::TilePos2{ 1, 1 }) : minTileLoc; if (minRandPos.x > maxTileLoc.x) { continue; } if (minRandPos.y > maxTileLoc.y) { continue; } if (maxRandPos.x < minTileLoc.x) { continue; } if (maxRandPos.y < minTileLoc.y) { continue; } placementFailure = true; break; } if (placementFailure) { continue; } // bh bit 7 is buildImmediately // edi = randColour << 16 // dl = building // dh = industryId if (flags & Flags::apply) { // do test placement const uint32_t cost = placeIndustryBuilding(newIndustryId, randPos, direction, building, randColour, args.buildImmediately, flags & ~(Flags::apply)); if (cost == FAILURE) { continue; } Scenario::getOptions().madeAnyChanges = 1; // Why are we incrementing this even on test? newIndustry->numTiles--; } const uint32_t cost = placeIndustryBuilding(newIndustryId, randPos, direction, building, randColour, args.buildImmediately, flags); if (cost == FAILURE) { continue; } totalCost += cost; lastPlacedBuildingPos = randPos; hasBuildingPlaced = true; break; } if (!hasBuildingPlaced) { StringManager::emptyUserString(newIndustry->name); // Free the industry slot newIndustry->name = StringIds::null; return FAILURE; } } // Find centre of tiles placed if (newIndustry->numTiles != 0) { // Use int32_t as this is a total and will be larger than 16bit int32_t totalX = 0; int32_t totalY = 0; for (auto i = 0; i < newIndustry->numTiles; ++i) { auto& tile = newIndustry->tiles[i]; bool isMultiTile = tile.z & 0x8000; totalX += tile.x; totalY += tile.y; if (isMultiTile) { totalX += 16; totalY += 16; } } newIndustry->x = 0xFFFFFFE0 & ((totalX / newIndustry->numTiles) + 16); newIndustry->y = 0xFFFFFFE0 & ((totalY / newIndustry->numTiles) + 16); } // 0x00454745 if ((flags & Flags::apply) && !(flags & Flags::ghost) && newIndustry->numTiles != 0) { if (indObj->farmTileGrowthStageNoProduction != 0xFF) { uint32_t buildingWallEntranceMask = 0; if (indObj->buildingWallEntrance != 0xFF) { const auto randWallVal = newIndustry->prng.srand_0(); buildingWallEntranceMask |= 1ULL << (randWallVal & 0xF); buildingWallEntranceMask |= 1ULL << ((randWallVal >> 4) & 0xF); // buildingWallEntranceMask |= 1ULL << ((randWallVal >> 8) & 0xF); CS meant to do this but made a mistake } // Claim surrounding surfaces and place perimeter fences for (auto i = 0; i < newIndustry->numTiles; ++i) { const auto& tile = newIndustry->tiles[i]; const bool isMultiTile = tile.z & 0x8000; const auto bottomLeft = World::toTileSpace(tile) - World::TilePos2{ 1, 1 }; const auto topRight = bottomLeft + (isMultiTile ? World::TilePos2{ 3, 3 } : World::TilePos2{ 2, 2 }); for (const auto& tilePos : World::TilePosRangeView(bottomLeft, topRight)) { claimSurfaceForIndustry(tilePos, newIndustry->id(), indObj->farmTileGrowthStageNoProduction, 0); // TODO: This is very similar to expand grounds code if (indObj->buildingWall != 0xFF) { GameCommands::WallPlacementArgs wallArgs; wallArgs.pos = World::Pos3(World::toWorldSpace(tilePos), 0); wallArgs.primaryColour = Colour::black; wallArgs.secondaryColour = Colour::black; wallArgs.tertiaryColour = Colour::black; // Place fences // Note: Order of this 0, 2, 3, 1 is to match vanilla if (tilePos.x == bottomLeft.x) { wallArgs.rotation = 0; bool placeEntrance = buildingWallEntranceMask & (1ULL << 0); buildingWallEntranceMask = std::rotr(buildingWallEntranceMask, 1); wallArgs.type = placeEntrance ? indObj->buildingWallEntrance : indObj->buildingWall; doCommand(wallArgs, Flags::apply); } if (tilePos.x == topRight.x) { wallArgs.rotation = 2; bool placeEntrance = buildingWallEntranceMask & (1ULL << 0); buildingWallEntranceMask = std::rotr(buildingWallEntranceMask, 1); wallArgs.type = placeEntrance ? indObj->buildingWallEntrance : indObj->buildingWall; doCommand(wallArgs, Flags::apply); } if (tilePos.y == bottomLeft.y) { wallArgs.rotation = 3; bool placeEntrance = buildingWallEntranceMask & (1ULL << 0); buildingWallEntranceMask = std::rotr(buildingWallEntranceMask, 1); wallArgs.type = placeEntrance ? indObj->buildingWallEntrance : indObj->buildingWall; doCommand(wallArgs, Flags::apply); } if (tilePos.y == topRight.y) { wallArgs.rotation = 1; bool placeEntrance = buildingWallEntranceMask & (1ULL << 0); buildingWallEntranceMask = std::rotr(buildingWallEntranceMask, 1); wallArgs.type = placeEntrance ? indObj->buildingWallEntrance : indObj->buildingWall; doCommand(wallArgs, Flags::apply); } } } } } // Expand grounds if (indObj->farmTileNumGrowthStages != 0) { const auto numExpands = (((indObj->farmNumFields * newIndustry->prng.randNext(0xFF)) / 256) + 1) * 4; for (auto i = 0; i < numExpands; ++i) { const auto randExpandVal = newIndustry->prng.randNext(); // dl const auto growthStage = ((randExpandVal & 0xFF) * indObj->farmTileNumGrowthStages) / 256; const auto updateTimerVal = (randExpandVal >> 8) & 0x7; const World::TilePos2 randOffset( ((randExpandVal >> 11) & 0x1F) - 15, ((randExpandVal >> 16) & 0x1F) - 15); const World::Pos2 randPos = World::Pos2{ newIndustry->x, newIndustry->y } + World::toWorldSpace(randOffset); bool useSecondWallType = ((randExpandVal >> 21) & 1) && indObj->wallTypes[2] != 0xFF; const auto wallType = useSecondWallType ? indObj->wallTypes[2] : indObj->wallTypes[0]; const auto wallEntranceType = useSecondWallType ? indObj->wallTypes[3] : indObj->wallTypes[1]; newIndustry->expandGrounds(randPos, wallType, wallEntranceType, growthStage, updateTimerVal); } } } // Cleanup if (!(flags & Flags::apply)) { StringManager::emptyUserString(newIndustry->name); // Free the industry slot newIndustry->name = StringIds::null; } totalCost += Economy::getInflationAdjustedCost(indObj->costFactor, indObj->costIndex, 3); // Send message post if ((flags & Flags::apply) && !(flags & Flags::ghost) && !args.buildImmediately) { MessageManager::post(MessageType::newIndustry, CompanyId::null, enumValue(newIndustry->id()), 0xFFFFU); } setExpenditureType(ExpenditureType::Miscellaneous); return totalCost; } void createIndustry(registers& regs) { IndustryPlacementArgs args(regs); regs.ebx = createIndustry(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Industries/CreateIndustry.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct IndustryPlacementArgs { static constexpr auto command = GameCommand::createIndustry; IndustryPlacementArgs() = default; explicit IndustryPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx) , type(regs.dl & 0x7F) , buildImmediately(regs.dl & 0x80) , srand0(regs.ebp) , srand1(regs.edi) { } World::Pos2 pos; uint8_t type; bool buildImmediately = false; // No scaffolding required (editor mode) uint32_t srand0; uint32_t srand1; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.dl = type | (buildImmediately ? 0x80 : 0); regs.ebp = srand0; regs.edi = srand1; regs.esi = enumValue(command); // Vanilla bug? Investigate when doing createIndustry return regs; } }; void createIndustry(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Industries/RemoveIndustry.cpp ```cpp #include "RemoveIndustry.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringManager.h" #include "Map/IndustryElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "MessageManager.h" #include "Objects/IndustryObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/Industry.h" #include "World/IndustryManager.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { // 0x00455916 // NOTE: Element is invalid after this call and all elements on tile static void removeElement(const World::Pos2& pos, World::TileElement& el) { Ui::ViewportManager::invalidate(pos, el.baseHeight(), el.clearHeight()); World::TileManager::removeElement(el); } // 0x0045579F static void removeIndustryElement(const World::Pos3& pos) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elIndustry = el.as<World::IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->baseHeight() != pos.z) { continue; } auto* industry = elIndustry->industry(); if (industry == nullptr) { continue; } auto* indObj = industry->getObject(); if (indObj == nullptr) { continue; } const auto buildingType = elIndustry->buildingType(); const auto buildingTiles = getBuildingTileOffsets(indObj->buildingSizeFlags & (1 << buildingType)); for (auto& buildTilePos : buildingTiles) { auto buildPos = buildTilePos.pos + pos; auto buildTile = World::TileManager::get(buildPos); for (auto& elB : buildTile) { auto* elBIndustry = elB.as<World::IndustryElement>(); if (elBIndustry == nullptr) { continue; } if (elBIndustry->baseHeight() != pos.z) { continue; } removeElement(buildPos, elB); break; } } for (auto i = 0; i < industry->numTiles; ++i) { const auto& indTile = industry->tiles[i]; const auto indPos = World::Pos3{ World::Pos2(indTile), static_cast<coord_t>(indTile.z & ~(1 << 15)) }; if (indPos == pos) { if (industry->numTiles > 1) { std::copy(&industry->tiles[i + 1], &industry->tiles[industry->numTiles], &industry->tiles[i]); } industry->numTiles--; break; } } break; } } // 0x00455A5C static void revokeAllSurfaceClaims(const IndustryId id) { for (auto& pos : World::getWorldRange()) { auto tile = World::TileManager::get(pos); auto* surface = tile.surface(); if (surface == nullptr) { continue; } if (!surface->isIndustrial()) { continue; } if (surface->industryId() != id) { continue; } surface->setIsIndustrialFlag(false); surface->setGrowthStage(0); surface->setVariation(0); Ui::ViewportManager::invalidate(World::toWorldSpace(pos), surface->baseHeight(), surface->baseHeight() + 32); World::TileManager::removeAllWallsOnTileAbove(pos, surface->baseZ()); } } // 0x00455943 static uint32_t removeIndustry(IndustryId id, uint8_t flags) { setExpenditureType(ExpenditureType::Miscellaneous); auto* industry = IndustryManager::get(id); if (industry == nullptr) { return FAILURE; } auto* indObj = industry->getObject(); if (indObj == nullptr) { return FAILURE; } const auto height = World::TileManager::getHeight(World::Pos2{ industry->x, industry->y } + World::Pos2{ 16, 16 }); setPosition({ industry->x, industry->y, height.landHeight }); if (flags & Flags::apply) { for (auto i = industry->numTiles; i != 0; --i) { auto tile = industry->tiles[0]; tile.z &= static_cast<coord_t>(~(1 << 15)); removeIndustryElement(tile); } Scenario::getOptions().madeAnyChanges = 1; Ui::WindowManager::close(Ui::WindowType::industry, enumValue(id)); StringManager::emptyUserString(industry->name); industry->name = StringIds::null; Ui::Windows::IndustryList::removeIndustry(id); revokeAllSurfaceClaims(id); for (auto& station : StationManager::stations()) { for (auto& stat : station.cargoStats) { if (stat.industryId == id) { stat.industryId = IndustryId::null; } } } MessageManager::removeAllSubjectRefs(enumValue(id), MessageItemArgumentType::industry); } return Economy::getInflationAdjustedCost(indObj->clearCostFactor, indObj->costIndex, 3); } void removeIndustry(registers& regs) { IndustryRemovalArgs args(regs); regs.ebx = removeIndustry(args.industryId, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Industries/RemoveIndustry.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct IndustryRemovalArgs { static constexpr auto command = GameCommand::removeIndustry; IndustryRemovalArgs() = default; explicit IndustryRemovalArgs(const registers& regs) : industryId(static_cast<IndustryId>(regs.dl)) { } IndustryId industryId; explicit operator registers() const { registers regs; regs.dl = enumValue(industryId); return regs; } }; void removeIndustry(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Industries/RenameIndustry.cpp ```cpp #include "RenameIndustry.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Industries/RenameIndustry.h" #include "Graphics/Gfx.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Types.hpp" #include "World/Industry.h" #include "World/IndustryManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { /** * 0x00455029 * Renames a particular industry. * * This command is called 3 times before the buffer is applied. Each time, 12 chars of the 36 char buffer are provided. * The resulting industry name has a maximum length of 31 chars; the last bytes are not used. * * @param flags @<bl> - game command flags * @param industryId @<cl> - industry id * @param index @<ax> - update index (in order of: 1, 2, 0) * @param buffer0 @<edx> - First part (4 chars) of the 12 update buffer * @param buffer1 @<dx> - Second part (4 chars) of the 12 update buffer * @param buffer2 @<bp> - Third part (4 chars) of the 12 update buffer * @return @<ebx> - returns 0 if rename is successful; otherwise GameCommands::FAILURE */ static uint32_t renameIndustry(const GameCommands::RenameIndustryArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); // Keep track of the industry id over several calls. static IndustryId _industryId{}; if (args.nameBufferIndex == 1) { _industryId = args.industryId; } static char staticRenameBuffer[37]{}; // Fill buffer over calls into the renameBuffer if ((flags & GameCommands::Flags::apply) != 0) { static constexpr std::array<int, 3> kTransformTable = { 2, 0, 1 }; int arrayIndex = kTransformTable.at(args.nameBufferIndex); std::memcpy(staticRenameBuffer + arrayIndex * 12, args.buffer, 12); } // Applying the buffer? if (args.nameBufferIndex != 0) { return 0; } char renameStringBuffer[37] = ""; memcpy(renameStringBuffer, staticRenameBuffer, sizeof(staticRenameBuffer)); renameStringBuffer[36] = '\0'; // Ensure the new name isn't empty. if (strlen(renameStringBuffer) == 0) { return 0; } // Figure out the current name for this industry. char currentIndustryName[256] = ""; auto industry = IndustryManager::get(_industryId); FormatArguments fargs{}; fargs.push(industry->town); StringManager::formatString(currentIndustryName, industry->name, fargs); // Verify the new name actually differs from the old one. if (strcmp(currentIndustryName, renameStringBuffer) == 0) { return 0; } // Allocate a string id for the new name. StringId allocatedStringId = StringManager::userStringAllocate(renameStringBuffer, true); if (allocatedStringId == StringIds::empty) { return GameCommands::FAILURE; } // Bailing out early? if ((flags & GameCommands::Flags::apply) == 0) { StringManager::emptyUserString(allocatedStringId); return 0; } // Apply the new name to the industry. StringId oldStringId = industry->name; industry->name = allocatedStringId; StringManager::emptyUserString(oldStringId); Gfx::invalidateScreen(); return 0; } void renameIndustry(registers& regs) { regs.ebx = renameIndustry(GameCommands::RenameIndustryArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Industries/RenameIndustry.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RenameIndustryArgs { static constexpr auto command = GameCommand::renameIndustry; RenameIndustryArgs() = default; explicit RenameIndustryArgs(const registers& regs) : industryId(IndustryId(regs.cx)) , nameBufferIndex(regs.ax) , buffer{} { std::memcpy(buffer, &regs.edx, 4); std::memcpy(buffer + 4, &regs.ebp, 4); std::memcpy(buffer + 8, &regs.edi, 4); } IndustryId industryId; uint8_t nameBufferIndex; char buffer[37]; explicit operator registers() const { registers regs; regs.cx = enumValue(industryId); regs.ax = nameBufferIndex; constexpr std::array<uint8_t, 3> iToOffset = { 24, 0, 12 }; const auto offset = iToOffset[nameBufferIndex]; std::memcpy(&regs.edx, buffer + offset, 4); std::memcpy(&regs.ebp, buffer + offset + 4, 4); std::memcpy(&regs.edi, buffer + offset + 8, 4); return regs; } }; void renameIndustry(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Docks/CreatePort.cpp ```cpp #include "CreatePort.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "Localisation/StringIds.h" #include "Map/AnimationManager.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Objects/DockObject.h" #include "Objects/IndustryObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { // Used by company ai static loco_global<StationId, 0x0112C748> _lastPlacedDockStationId; static loco_global<uint32_t, 0x00112C734> _lastConstructedAdjoiningStationId; // Can be 0xFFFF'FFFFU for no adjoining station static loco_global<World::Pos2, 0x00112C792> _lastConstructedAdjoiningStationCentrePos; // Can be x = -1 for no adjoining station // 0x0049060C static StationManager::NearbyStation findNearbyStationDocks(World::Pos3 pos) { const auto tilePosA = World::toTileSpace(pos) - World::TilePos2(1, 1); const auto tilePosB = World::toTileSpace(pos) + World::TilePos2(2, 2); for (const auto tilePos : World::getClampedRange(tilePosA, tilePosB)) { const auto tile = World::TileManager::get(tilePos); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->stationType() != StationType::docks) { continue; } if (elStation->isGhost() || elStation->isAiAllocated()) { continue; } if (elStation->owner() != getUpdatingCompanyId()) { continue; } return StationManager::NearbyStation{ elStation->stationId(), true }; } } return StationManager::findNearbyStation(pos, getUpdatingCompanyId()); } // 0x004906AC static StationManager::NearbyStation findNearbyStationDocksAi(World::Pos3 pos) { const auto tilePosA = World::toTileSpace(pos) - World::TilePos2(1, 1); const auto tilePosB = World::toTileSpace(pos) + World::TilePos2(2, 2); for (const auto tilePos : World::getClampedRange(tilePosA, tilePosB)) { const auto tile = World::TileManager::get(tilePos); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->stationType() != StationType::docks) { continue; } if (elStation->isGhost()) { continue; } // This is the part that is different compared to findNearbyStationDocks if (!elStation->isAiAllocated()) { continue; } if (elStation->owner() != getUpdatingCompanyId()) { continue; } return StationManager::NearbyStation{ elStation->stationId(), true }; } } return StationManager::findNearbyStation(pos, getUpdatingCompanyId()); } enum class NearbyStationValidation { okay, requiresNewStation, failure, }; // 0x0048BDCE & 0x0048BD40 static std::pair<NearbyStationValidation, StationId> validateNearbyStation(const World::Pos3 pos, const uint8_t flags) { auto func = (flags & Flags::aiAllocated) ? &findNearbyStationDocksAi : &findNearbyStationDocks; auto nearbyStation = func(pos); if (nearbyStation.id == StationId::null) { return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } // _lastPlacedTrackStationId = nearbyStation.id; set in callers auto* station = StationManager::get(nearbyStation.id); if (station->stationTileSize >= std::size(station->stationTiles)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_large); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } else { if (!(flags & Flags::aiAllocated)) { if (StationManager::exceedsStationSize(*station, pos)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_spread_out); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } } } return std::make_pair(NearbyStationValidation::okay, nearbyStation.id); } static bool isValidWaterIndustryPort(World::Pos2 pos) { for (auto& offset : kPortBorderOffsets) { const auto testPos = pos + World::toWorldSpace(offset); if (!World::validCoords(testPos)) { continue; } auto tile = World::TileManager::get(testPos); for (auto& el : tile) { auto* elIndustry = el.as<World::IndustryElement>(); if (elIndustry == nullptr) { continue; } if (elIndustry->isGhost()) { continue; } auto* industry = elIndustry->industry(); auto* industryObj = ObjectManager::get<IndustryObject>(industry->objectId); if (industryObj->hasFlags(IndustryObjectFlags::builtOnWater)) { return true; } } } return false; } // 0x00493F0E static uint32_t createBuilding(const PortPlacementArgs& args, const uint8_t flags, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t buildingType) { // 0x00112C80B bool isWaterIndustryPort = false; if (World::validCoords(args.pos)) { auto* elSurface = World::TileManager::get(args.pos).surface(); if (elSurface->water()) { isWaterIndustryPort = isValidWaterIndustryPort(args.pos); if (!isWaterIndustryPort) { setErrorText(StringIds::can_only_be_built_on_water_next_to_water_based_industry); return FAILURE; } } } auto* dockObj = ObjectManager::get<DockObject>(args.type); // This is identical to createIndustry but with a DockObject // TODO: look into making some sort of common version auto clearHeight = 0; const auto partHeights = dockObj->getBuildingPartHeights(); for (auto part : dockObj->getBuildingParts(buildingType)) { clearHeight += partHeights[part]; } // ceil to 4 clearHeight += 3; clearHeight &= ~3; currency32_t totalCost = 0; const auto buildingFootprint = getBuildingTileOffsets(true); for (auto& offset : buildingFootprint) { const auto tilePos = World::toTileSpace(World::Pos2(args.pos) + offset.pos); if (!World::validCoords(tilePos)) { setErrorText(StringIds::off_edge_of_map); return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost) && !(flags & Flags::aiAllocated)) { World::TileManager::removeAllWallsOnTileBelow(tilePos, (args.pos.z + clearHeight) / World::kSmallZStep); } // 0x0049434F same as TileClearance::tileClearFunction but collides on surfaces as well auto clearFunc = [pos = World::toWorldSpace(tilePos), &removedBuildings, flags, &totalCost](World::TileElement& el) { switch (el.type()) { case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearTreeCollision(*elTree, pos, flags, totalCost); } case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearBuildingCollision(*elBuilding, pos, removedBuildings, flags, totalCost); } default: return World::TileClearance::ClearFuncResult::collision; } }; // This is similar but not the same as createIndustry/createBuilding if (isWaterIndustryPort) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); if (surface->waterHeight() != args.pos.z) { // TODO: Give a better message setErrorText(StringIds::empty); return FAILURE; } if (surface->hasType6Flag()) { setErrorText(StringIds::water_channel_currently_needed_by_ships); return FAILURE; } const auto baseZ = args.pos.z / World::kSmallZStep; const auto clearZ = (args.pos.z + clearHeight) / World::kSmallZStep; World::QuarterTile qt(0xF, 0xF); if (!World::TileClearance::applyClearAtStandardHeight(World::toWorldSpace(tilePos), baseZ, clearZ, qt, clearFunc)) { return FAILURE; } } else { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); const auto argBaseZ = args.pos.z / World::kSmallZStep; const auto argClearZ = (args.pos.z + clearHeight) / World::kSmallZStep; const auto minBaseZ = std::min<World::SmallZ>(surface->baseZ(), argBaseZ); const auto maxBaseZ = std::max<World::SmallZ>(surface->baseZ(), argBaseZ); const auto baseZ = std::min<World::SmallZ>(minBaseZ, argClearZ); const auto clearZ = std::max<World::SmallZ>(maxBaseZ, argClearZ); World::QuarterTile qt(0xF, 0xF); if (!World::TileClearance::applyClearAtStandardHeight(World::toWorldSpace(tilePos), baseZ, clearZ, qt, clearFunc)) { return FAILURE; } } if (!isWaterIndustryPort) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); auto baseZDiff = std::abs((args.pos.z / World::kSmallZStep) - surface->baseZ()); if (surface->slope()) { baseZDiff++; } auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); totalCost += Economy::getInflationAdjustedCost(landObj->costFactor, landObj->costIndex, 10) * baseZDiff; // Flatten surfaces if (!(flags & Flags::ghost) && (flags & Flags::apply)) { if (surface->slope() || args.pos.z != surface->baseHeight()) { if (flags & Flags::aiAllocated) { surface->setAiAllocated(true); } else { surface->setBaseZ(args.pos.z / World::kSmallZStep); surface->setClearZ(args.pos.z / World::kSmallZStep); surface->setSlope(0); surface->setSnowCoverage(0); surface->setGrowthStage(0); } if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); } } } } // Create new tile if (flags & Flags::apply) { if (!(flags & Flags::ghost) && !(flags & Flags::aiAllocated)) { World::TileManager::removeSurfaceIndustry(World::toWorldSpace(tilePos)); World::TileManager::setTerrainStyleAsCleared(World::toWorldSpace(tilePos)); } auto* elStation = World::TileManager::insertElement<World::StationElement>(World::toWorldSpace(tilePos), args.pos.z / World::kSmallZStep, 0xF); if (elStation == nullptr) { return FAILURE; } elStation->setClearZ((clearHeight / World::kSmallZStep) + elStation->baseZ()); elStation->setRotation(args.rotation); elStation->setObjectId(args.type); elStation->setStationType(StationType::docks); elStation->setOwner(getUpdatingCompanyId()); elStation->setUnk4SLR4(0); elStation->setBuildingType(buildingType); if (!(flags & Flags::ghost)) { elStation->setStationId(_lastPlacedDockStationId); } else { elStation->setStationId(static_cast<StationId>(0)); } elStation->setGhost(flags & Flags::ghost); elStation->setSequenceIndex(offset.index); World::AnimationManager::createAnimation(8, World::toWorldSpace(tilePos), elStation->baseZ()); elStation->setAiAllocated(flags & Flags::aiAllocated); if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); } Scenario::getOptions().madeAnyChanges = 1; } } return totalCost; } // 0x004FEB80 & 0x004FEB90 static constexpr std::array<std::array<World::Pos2, 2>, 4> kRotationToBuildingFront = { std::array<World::Pos2, 2>{ World::Pos2{ 64, 0 }, World::Pos2{ 64, 32 }, }, std::array<World::Pos2, 2>{ World::Pos2{ 0, -32 }, World::Pos2{ 32, -32 }, }, std::array<World::Pos2, 2>{ World::Pos2{ -32, 32 }, World::Pos2{ -32, 0 }, }, std::array<World::Pos2, 2>{ World::Pos2{ 32, 64 }, World::Pos2{ 0, 64 }, }, }; static bool tileHasWater(World::Pos2 pos) { if (!World::validCoords(pos)) { return false; } auto* elSurface = World::TileManager::get(pos).surface(); if (elSurface->water() == 0) { return false; } return true; } static currency32_t createPort(const PortPlacementArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); _lastPlacedDockStationId = StationId::null; if ((flags & Flags::apply) && !(flags & Flags::aiAllocated)) { companySetObservation(getUpdatingCompanyId(), ObservationStatus::buildingDock, World::Pos2(args.pos) + World::Pos2{ 16, 16 }, EntityId::null, args.type); } _lastConstructedAdjoiningStationCentrePos = World::Pos2(-1, -1); _lastConstructedAdjoiningStationId = 0xFFFFFFFFU; if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } for (auto& frontTile : kRotationToBuildingFront[args.rotation]) { const auto frontPos = frontTile + args.pos; if (!tileHasWater(frontPos)) { setErrorText(StringIds::requires_water_in_front_of_dock); return FAILURE; } } if ((flags & Flags::ghost) && (flags & Flags::apply)) { _lastConstructedAdjoiningStationCentrePos = args.pos; auto nearbyStation = flags & Flags::aiAllocated ? findNearbyStationDocksAi(args.pos) : findNearbyStationDocks(args.pos); _lastConstructedAdjoiningStationId = static_cast<int16_t>(nearbyStation.id); } if (!(flags & Flags::ghost)) { if (flags & Flags::apply) { auto [result, nearbyStationId] = validateNearbyStation(args.pos, flags); switch (result) { case NearbyStationValidation::failure: // Odd??? break; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(args.pos, getUpdatingCompanyId(), 3); if (newStationId != StationId::null) { _lastPlacedDockStationId = newStationId; auto* station = StationManager::get(newStationId); station->updateLabel(); } } break; case NearbyStationValidation::okay: _lastPlacedDockStationId = nearbyStationId; break; } } else { // Same as the other branch but deallocate after allocating and return failure on failure auto [result, nearbyStationId] = validateNearbyStation(args.pos, flags); switch (result) { case NearbyStationValidation::failure: return FAILURE; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(args.pos, getUpdatingCompanyId(), 3); if (newStationId == StationId::null) { return FAILURE; } StationManager::deallocateStation(newStationId); // _lastPlacedDockStationId not set but that's fine since this is the no apply side } break; case NearbyStationValidation::okay: _lastPlacedDockStationId = nearbyStationId; break; } } } auto* dockObj = ObjectManager::get<DockObject>(args.type); currency32_t totalCost = Economy::getInflationAdjustedCost(dockObj->buildCostFactor, dockObj->costIndex, 7); World::TileClearance::RemovedBuildings removedBuildings{}; const auto buildingCost = createBuilding(args, flags, removedBuildings, 0); if (buildingCost == FAILURE) { return FAILURE; } totalCost += buildingCost; if (!(flags & Flags::ghost) && (flags & Flags::apply)) { addTileToStation(_lastPlacedDockStationId, args.pos, args.rotation); auto* station = StationManager::get(_lastPlacedDockStationId); station->invalidate(); recalculateStationModes(_lastPlacedDockStationId); recalculateStationCenter(_lastPlacedDockStationId); station->updateLabel(); station->invalidate(); sub_48D794(*station); } if (!(flags & (Flags::ghost | Flags::aiAllocated)) && (flags & Flags::apply)) { playConstructionPlacementSound(args.pos); } // Vanilla did this check wrong if ((flags & Flags::apply) && CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { companyEmotionEvent(getUpdatingCompanyId(), Emotion::thinking); } return totalCost; } // 0x00493AA7 void createPort(registers& regs) { regs.ebx = createPort(PortPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Docks/CreatePort.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct PortPlacementArgs { static constexpr auto command = GameCommand::createPort; PortPlacementArgs() = default; explicit PortPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh) , type(regs.dl) { } World::Pos3 pos; uint8_t rotation; uint8_t type; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = type; return regs; } }; void createPort(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Docks/RemovePort.cpp ```cpp #include "RemovePort.h" #include "Economy/Economy.h" #include "Localisation/StringIds.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Objects/DockObject.h" #include "Objects/ObjectManager.h" #include "ViewportManager.h" #include "World/Industry.h" #include "World/Station.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { static World::StationElement* getStationEl(const World::Pos3& pos) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* stationEl = el.as<World::StationElement>(); if (stationEl == nullptr) { continue; } if (stationEl->baseHeight() == pos.z) { return stationEl; } } return nullptr; } // 0x00494706 static bool removePortTileElements(const World::Pos3& pos, const uint8_t flags) { for (auto& searchTile : getBuildingTileOffsets(true)) { const auto portPos = World::Pos3(searchTile.pos + pos, pos.z); if ((flags & (Flags::aiAllocated | Flags::apply)) != 0) { auto tile = World::TileManager::get(portPos); auto* surfaceEl = tile.surface(); if (surfaceEl != nullptr) { surfaceEl->setAiAllocated(false); } } auto* stationEl = getStationEl(portPos); if (stationEl == nullptr) { return false; } if ((flags & Flags::apply) == 0) { continue; } if ((flags & (Flags::aiAllocated)) == 0) { Ui::ViewportManager::invalidate(World::Pos2(portPos), stationEl->baseHeight(), stationEl->clearHeight(), ZoomLevel::eighth); } World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(stationEl)); } return true; } // 0x00494570 static currency32_t removePort(const PortRemovalArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); // Find station element on tile auto* stationEl = getStationEl(args.pos); if (stationEl == nullptr) { return FAILURE; } StationId stationId = StationId::null; const auto rotation = stationEl->rotation(); // Do we need to remove the port from a station? if ((flags & Flags::ghost) == 0) { stationId = stationEl->stationId(); } // Station in use by a vehicle? if (stationEl->isFlag6()) { GameCommands::setErrorText(StringIds::currently_in_use_by_at_least_one_vehicle); return FAILURE; } // Calculate base removal cost auto* dockObj = ObjectManager::get<DockObject>(stationEl->objectId()); currency32_t totalCost = Economy::getInflationAdjustedCost(dockObj->sellCostFactor, dockObj->costIndex, 7); // Remove the actual tile elements associated with the port if (!removePortTileElements(args.pos, flags)) { return FAILURE; } // Should we update the station meta data? if ((flags & Flags::ghost) == 0 && (flags & Flags::apply) != 0) { auto* station = StationManager::get(stationId); removeTileFromStationAndRecalcCargo(stationId, args.pos, rotation); station->invalidate(); recalculateStationModes(stationId); recalculateStationCenter(stationId); station->updateLabel(); station->invalidate(); } return totalCost; } void removePort(registers& regs) { regs.ebx = removePort(PortRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Docks/RemovePort.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct PortRemovalArgs { static constexpr auto command = GameCommand::removePort; PortRemovalArgs() = default; explicit PortRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) { } World::Pos3 pos; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; return regs; } }; void removePort(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/CompanyAi/AiCreateRoadAndStation.cpp ```cpp #include "AiCreateRoadAndStation.h" #include "GameCommands/Road/CreateRoad.h" #include "GameCommands/Road/CreateRoadStation.h" #include "Map/BuildingElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "Objects/ObjectManager.h" namespace OpenLoco::GameCommands { static loco_global<uint8_t, 0x01136073> _byte_1136073; // 0x0047B0DC static World::TileClearance::ClearFuncResult clearNearbyArea(World::TileElement& el) { if (el.type() == World::ElementType::tree) { return World::TileClearance::ClearFuncResult::noCollision; } if (el.type() == World::ElementType::road) { return World::TileClearance::ClearFuncResult::noCollision; } if (el.type() == World::ElementType::building) { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } auto* buildingObj = ObjectManager::get<BuildingObject>(elBuilding->objectId()); if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters | BuildingObjectFlags::indestructible)) { return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; } static currency32_t aiCreateRoadAndStationCost(const AiRoadAndStationPlacementArgs& args, uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); if (!World::TileManager::checkFreeElementsAndReorganise()) { return GameCommands::FAILURE; } currency32_t totalCost = 0; { auto roadArgs = RoadPlacementArgs{}; roadArgs.pos = args.pos; roadArgs.rotation = args.rotation; roadArgs.roadObjectId = args.roadObjectId; roadArgs.roadId = 0; // Always straight road roadArgs.mods = args.mods; roadArgs.bridge = args.bridge; roadArgs.unkFlags = 0; auto roadRegs = static_cast<registers>(roadArgs); roadRegs.bl = flags; createRoad(roadRegs); const auto roadRes = static_cast<currency32_t>(roadRegs.ebx); if (!(flags & GameCommands::Flags::apply)) { if (static_cast<uint32_t>(roadRes) == GameCommands::FAILURE) { return GameCommands::FAILURE; } // There is a level crossing so we can't place a station if (_byte_1136073 & (1U << 2)) { return GameCommands::FAILURE; } } totalCost += roadRes; } { auto stationArgs = RoadStationPlacementArgs{}; stationArgs.pos = args.pos; stationArgs.rotation = args.rotation; stationArgs.type = args.stationObjectId; stationArgs.roadObjectId = args.roadObjectId; stationArgs.roadId = 0; // Always straight road stationArgs.index = 0; // Always index 0 for straight road auto stationRegs = static_cast<registers>(stationArgs); stationRegs.bl = flags; createRoadStation(stationRegs); const auto stationRes = static_cast<currency32_t>(stationRegs.ebx); if (!(flags & GameCommands::Flags::apply)) { if (static_cast<uint32_t>(stationRes) == GameCommands::FAILURE) { return GameCommands::FAILURE; } } totalCost += stationRes; } if (args.unk1 & (1U << 1)) { const auto pos = World::Pos2{ args.pos } - World::kRotationOffset[args.rotation]; const auto baseZ = args.pos.z / World::kSmallZStep; if (!World::TileClearance::applyClearAtStandardHeight(pos, baseZ, baseZ + 12, World::QuarterTile{ 0xF, 0 }, clearNearbyArea)) { return GameCommands::FAILURE; } } if (args.unk1 & (1U << 0)) { const auto pos = World::Pos2{ args.pos } + World::kRotationOffset[args.rotation]; const auto baseZ = args.pos.z / World::kSmallZStep; if (!World::TileClearance::applyClearAtStandardHeight(pos, baseZ, baseZ + 12, World::QuarterTile{ 0xF, 0 }, clearNearbyArea)) { return GameCommands::FAILURE; } } return totalCost; } // 0x0047AF0B void aiCreateRoadAndStation(registers& regs) { regs.ebx = aiCreateRoadAndStationCost(AiRoadAndStationPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/CompanyAi/AiCreateRoadAndStation.h ```h #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct AiRoadAndStationPlacementArgs { static constexpr auto command = GameCommand::aiCreateRoadAndStation; AiRoadAndStationPlacementArgs() = default; explicit AiRoadAndStationPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadObjectId(regs.dl) , stationObjectId(regs.dh) , stationLength((regs.edi >> 24) & 0xFFU) , mods((regs.edi >> 16) & 0xFU) , unk1((regs.edx >> 16) & 0xFFU) , bridge((regs.edx >> 24) & 0xFFU) { } World::Pos3 pos; uint8_t rotation; uint8_t roadObjectId; uint8_t stationObjectId; uint8_t stationLength; uint8_t mods; uint8_t unk1; uint8_t bridge; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.edx = (roadObjectId & 0xFFU) | ((stationObjectId & 0xFFU) << 8) | ((unk1 & 0xFFU) << 16) | ((bridge & 0xFFU) << 24); regs.edi = (pos.z & 0xFFFFFU) | ((mods & 0xFU) << 16) | ((stationLength & 0xFFU) << 24); return regs; } }; void aiCreateRoadAndStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/CompanyAi/AiCreateTrackAndStation.cpp ```cpp #include "AiCreateTrackAndStation.h" #include "GameCommands/Track/CreateTrack.h" #include "GameCommands/Track/CreateTrainStation.h" #include "Map/BuildingElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "Objects/ObjectManager.h" namespace OpenLoco::GameCommands { static loco_global<uint8_t, 0x01136073> _byte_1136073; // 0x004A7328 static World::TileClearance::ClearFuncResult clearNearbyArea(World::TileElement& el) { if (el.type() == World::ElementType::tree) { return World::TileClearance::ClearFuncResult::noCollision; } if (el.type() == World::ElementType::building) { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } auto* buildingObj = ObjectManager::get<BuildingObject>(elBuilding->objectId()); if (buildingObj->hasFlags(BuildingObjectFlags::isHeadquarters | BuildingObjectFlags::indestructible)) { return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; } static currency32_t aiCreateTrackAndStation(const AiTrackAndStationPlacementArgs& args, uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); if (!World::TileManager::checkFreeElementsAndReorganise()) { return GameCommands::FAILURE; } currency32_t totalCost = 0; int32_t numTilesTrackOrRoadUnderneath = 0; auto trackPos = args.pos; for (auto i = 0U; i < args.stationLength; ++i, trackPos += World::Pos3(World::kRotationOffset[args.rotation], 0)) { if (!(flags & Flags::apply)) { if (World::validCoords(trackPos)) { auto tile = World::TileManager::get(trackPos); bool passedSurface = false; for (const auto& el : tile) { const auto type = el.type(); if (type == World::ElementType::surface) { passedSurface = true; continue; } if (!passedSurface) { continue; } if (trackPos.z <= el.baseHeight()) { break; } if ((type == World::ElementType::road) || (type == World::ElementType::track)) { ++numTilesTrackOrRoadUnderneath; break; } } } } { auto trackArgs = TrackPlacementArgs{}; trackArgs.pos = trackPos; trackArgs.rotation = args.rotation; trackArgs.trackObjectId = args.trackObjectId; trackArgs.trackId = 0; // Always straight track trackArgs.mods = args.mods; trackArgs.bridge = args.bridge; trackArgs.unkFlags = 0; trackArgs.unk = false; auto trackRegs = static_cast<registers>(trackArgs); trackRegs.bl = flags; createTrack(trackRegs); const auto trackRes = static_cast<currency32_t>(trackRegs.ebx); if (!(flags & GameCommands::Flags::apply)) { if (static_cast<uint32_t>(trackRes) == GameCommands::FAILURE) { return GameCommands::FAILURE; } // There is a level crossing or track overlay so we can't place a station if (_byte_1136073 & ((1U << 2) | (1U << 3))) { return GameCommands::FAILURE; } } totalCost += trackRes; } { auto stationArgs = TrainStationPlacementArgs{}; stationArgs.pos = trackPos; stationArgs.rotation = args.rotation; stationArgs.type = args.stationObjectId; stationArgs.trackObjectId = args.trackObjectId; stationArgs.trackId = 0; // Always straight track stationArgs.index = 0; // Always index 0 for straight track auto stationRegs = static_cast<registers>(stationArgs); stationRegs.bl = flags; createTrainStation(stationRegs); const auto stationRes = static_cast<currency32_t>(stationRegs.ebx); if (!(flags & GameCommands::Flags::apply)) { if (static_cast<uint32_t>(stationRes) == GameCommands::FAILURE) { return GameCommands::FAILURE; } } totalCost += stationRes; } } // Ensure there is enough space for the station track to exit if (args.unk1 & (1U << 1)) { auto pos = World::Pos2{ args.pos } - World::kRotationOffset[args.rotation]; for (auto i = 0U; i < 2; ++i) { const auto baseZ = args.pos.z / World::kSmallZStep; if (!World::TileClearance::applyClearAtStandardHeight(pos, baseZ, baseZ + 12, World::QuarterTile{ 0xF, 0 }, clearNearbyArea)) { return GameCommands::FAILURE; } pos -= World::kRotationOffset[args.rotation]; } } if (args.unk1 & (1U << 0)) { auto pos = World::Pos2{ args.pos } + World::kRotationOffset[args.rotation] * args.stationLength; for (auto i = 0U; i < 2; ++i) { const auto baseZ = args.pos.z / World::kSmallZStep; if (!World::TileClearance::applyClearAtStandardHeight(pos, baseZ, baseZ + 12, World::QuarterTile{ 0xF, 0 }, clearNearbyArea)) { return GameCommands::FAILURE; } pos += World::kRotationOffset[args.rotation]; } } if (!(flags & Flags::apply)) { if (numTilesTrackOrRoadUnderneath >= args.stationLength - 2) { return GameCommands::FAILURE; } } return totalCost; } // 0x004A6FDC void aiCreateTrackAndStation(registers& regs) { regs.ebx = aiCreateTrackAndStation(AiTrackAndStationPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/CompanyAi/AiCreateTrackAndStation.h ```h #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct AiTrackAndStationPlacementArgs { static constexpr auto command = GameCommand::aiCreateTrackAndStation; AiTrackAndStationPlacementArgs() = default; explicit AiTrackAndStationPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackObjectId(regs.dl) , stationObjectId(regs.dh) , stationLength((regs.edi >> 24) & 0xFFU) , mods((regs.edi >> 16) & 0xFU) , unk1((regs.edx >> 16) & 0xFFU) , bridge((regs.edx >> 24) & 0xFFU) { } World::Pos3 pos; uint8_t rotation; uint8_t trackObjectId; uint8_t stationObjectId; uint8_t stationLength; uint8_t mods; uint8_t unk1; uint8_t bridge; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.edx = (trackObjectId & 0xFFU) | ((stationObjectId & 0xFFU) << 8) | ((unk1 & 0xFFU) << 16) | ((bridge & 0xFFU) << 24); regs.edi = (pos.z & 0xFFFFFU) | ((mods & 0xFU) << 16) | ((stationLength & 0xFFU) << 24); return regs; } }; void aiCreateTrackAndStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/CompanyAi/AiTrackReplacement.cpp ```cpp #include "AiTrackReplacement.h" #include "Economy/Economy.h" #include "GameState.h" #include "Map/BuildingElement.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/Track/TrackEnum.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Objects/BridgeObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Objects/TrainSignalObject.h" #include "Objects/TrainStationObject.h" #include "Ui/WindowManager.h" #include "World/Station.h" #include "World/StationManager.h" #include "World/Town.h" #include "World/TownManager.h" namespace OpenLoco::GameCommands { static loco_global<StationId, 0x0112C730> _lastPlacedTrackStationId; static loco_global<World::TileManager::ElementPositionFlags, 0x01136072> _byte_1136072; static loco_global<uint8_t, 0x01136073> _byte_1136073; static loco_global<World::MicroZ, 0x01136074> _byte_1136074; static loco_global<uint8_t, 0x01136075> _byte_1136075; // bridgeType of any overlapping track namespace { struct ClearFunctionArgs { World::Pos3 pos; uint8_t trackId; uint8_t bridgeId; uint8_t trackObjectId; uint8_t flags; }; } static World::TrackElement* getTrackElement(const World::Pos3 pos, const uint8_t rotation, const uint8_t trackObjectId, const uint8_t trackId, const uint8_t sequenceIndex, const CompanyId companyId) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->sequenceIndex() != sequenceIndex) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if (elTrack->trackId() != trackId) { continue; } if (elTrack->owner() != companyId) { return nullptr; } return elTrack; } return nullptr; } // 0x004A7BE8 static World::TileClearance::ClearFuncResult clearRoad(World::RoadElement& elRoad, const ClearFunctionArgs& args, bool& hasLevelCrossing) { if (elRoad.hasBridge()) { _byte_1136075 = elRoad.bridge(); auto* bridgeObj = ObjectManager::get<BridgeObject>(elRoad.bridge()); if ((bridgeObj->disabledTrackCfg & World::Track::CommonTraitFlags::junction) != World::Track::CommonTraitFlags::none) { setErrorText(StringIds::bridge_not_suitable_for_junction); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } auto* roadObj = ObjectManager::get<RoadObject>(elRoad.roadObjectId()); auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjectId); if (!(roadObj->compatibleTracks & (1U << args.trackObjectId)) && !(trackObj->compatibleRoads & (1U << elRoad.roadObjectId()))) { FormatArguments::common(roadObj->name); setErrorText(StringIds::unable_to_cross_or_create_junction_with_string); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elRoad.hasSignalElement()) { setErrorText(StringIds::signal_in_the_way); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elRoad.hasStationElement()) { setErrorText(StringIds::station_in_the_way); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elRoad.hasBridge()) { if (elRoad.bridge() != args.bridgeId) { setErrorText(StringIds::bridge_types_must_match); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } hasLevelCrossing = true; _byte_1136073 = _byte_1136073 | (1U << 2); if (args.flags & Flags::apply) { elRoad.setHasLevelCrossing(true); elRoad.setLevelCrossingObjectId(getGameState().currentDefaultLevelCrossingType); elRoad.setUnk7_10(false); elRoad.setUnk6l(0); } return World::TileClearance::ClearFuncResult::noCollision; } // 0x004A7A7F static World::TileClearance::ClearFuncResult clearFunction( World::TileElement& el, currency32_t& totalCost, bool& hasLevelCrossing, World::TileClearance::RemovedBuildings& removedBuildings, const ClearFunctionArgs& args) { switch (el.type()) { case World::ElementType::track: { return World::TileClearance::ClearFuncResult::noCollision; } case World::ElementType::station: { auto* elStation = el.as<World::StationElement>(); if (elStation->stationType() == StationType::trainStation) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; } case World::ElementType::signal: return World::TileClearance::ClearFuncResult::noCollision; case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearBuildingCollision(*elBuilding, args.pos, removedBuildings, args.flags | Flags::flag_7, totalCost); } case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearTreeCollision(*elTree, args.pos, args.flags, totalCost); } case World::ElementType::road: { auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { return clearRoad(*elRoad, args, hasLevelCrossing); } break; } case World::ElementType::surface: return World::TileClearance::ClearFuncResult::noCollision; case World::ElementType::wall: case World::ElementType::industry: return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::collision; } static currency32_t aiTrackReplacement(const AiTrackReplacementArgs& args, const uint8_t flags) { _byte_1136072 = World::TileManager::ElementPositionFlags::none; GameCommands::setExpenditureType(ExpenditureType::Construction); const auto companyId = GameCommands::getUpdatingCompanyId(); if (flags & GameCommands::Flags::apply) { const auto center = World::Pos2(args.pos) + World::Pos2{ 16, 16 }; companySetObservation(companyId, ObservationStatus::buildingTrackRoad, center, EntityId::null, args.trackObjectId); } auto* elTrackSeq = getTrackElement(args.pos, args.rotation, args.trackObjectId, args.trackId, args.sequenceIndex, companyId); if (elTrackSeq == nullptr) { return GameCommands::FAILURE; } auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjectId); currency32_t totalCost = 0; const auto trackIdCostFactor = World::TrackData::getTrackMiscData(args.trackId).costFactor; if (elTrackSeq->isAiAllocated()) { { const auto trackBaseCost = Economy::getInflationAdjustedCost(trackObj->buildCostFactor, trackObj->costIndex, 10); const auto cost = (trackBaseCost * trackIdCostFactor) / 256; totalCost += cost; } for (auto i = 0U; i < 4; ++i) { if (elTrackSeq->hasMod(i)) { auto* extraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(extraObj->buildCostFactor, extraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * trackIdCostFactor) / 256; totalCost += cost; } } } if (elTrackSeq->hasSignal()) { auto* elSignal = elTrackSeq->next()->as<World::SignalElement>(); if (elSignal != nullptr && elSignal->isAiAllocated()) { auto getSignalCost = [](const World::SignalElement::Side& side) { auto* signalObj = ObjectManager::get<TrainSignalObject>(side.signalObjectId()); return Economy::getInflationAdjustedCost(signalObj->costFactor, signalObj->costIndex, 10); }; if (elSignal->getLeft().hasSignal()) { totalCost += getSignalCost(elSignal->getLeft()); } if (elSignal->getRight().hasSignal()) { totalCost += getSignalCost(elSignal->getRight()); } } } if (elTrackSeq->hasStationElement()) { auto* elStation = elTrackSeq->next()->as<World::StationElement>(); if (elStation != nullptr && elStation->isAiAllocated()) { auto* stationObj = ObjectManager::get<TrainStationObject>(elStation->objectId()); const auto stationBaseCost = Economy::getInflationAdjustedCost(stationObj->buildCostFactor, stationObj->costIndex, 8); const auto cost = (stationBaseCost * trackIdCostFactor) / 256; totalCost += cost; } } const auto& trackPieces = World::TrackData::getTrackPiece(args.trackId); const auto& trackPieceSeq = trackPieces[args.sequenceIndex]; const auto trackLoc0 = args.pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPieceSeq.x, trackPieceSeq.y }, args.rotation), trackPieceSeq.z }; World::TileClearance::RemovedBuildings removedBuildings; // 0x0113605B bool hasBridge = false; uint8_t bridgeType = 0xFFU; bool overWater = false; for (auto& piece : trackPieces) { const auto trackLoc = trackLoc0 + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; // 0x004A76E0 auto tile = World::TileManager::get(trackLoc); auto* elSurface = tile.surface(); if (elSurface->water() != 0) { overWater = true; } auto* elTrack = getTrackElement(trackLoc, args.rotation, args.trackObjectId, args.trackId, piece.index, companyId); if (elTrack == nullptr) { continue; } if (elTrack->hasBridge()) { hasBridge = true; bridgeType = elTrack->bridge(); } if (elTrack->isAiAllocated()) { if (flags & GameCommands::Flags::apply) { elTrack->setAiAllocated(false); World::TileManager::mapInvalidateTileFull(trackLoc); } } if (elTrack->hasSignal()) { auto* elSignal = elTrack->next()->as<World::SignalElement>(); if (elSignal != nullptr && (flags & GameCommands::Flags::apply)) { elSignal->setAiAllocated(false); World::TileManager::mapInvalidateTileFull(trackLoc); } } if (elTrack->hasStationElement()) { auto* elStation = elTrack->next()->as<World::StationElement>(); if (elStation != nullptr && (flags & GameCommands::Flags::apply)) { elStation->setAiAllocated(false); World::TileManager::mapInvalidateTileFull(trackLoc); _lastPlacedTrackStationId = elStation->stationId(); auto* station = StationManager::get(_lastPlacedTrackStationId); if ((station->flags & StationFlags::flag_5) != StationFlags::none) { station->flags &= ~StationFlags::flag_5; auto* town = TownManager::get(station->town); town->numStations++; Ui::WindowManager::invalidate(Ui::WindowType::town, enumValue(town->id())); } station->invalidate(); recalculateStationModes(_lastPlacedTrackStationId); recalculateStationCenter(_lastPlacedTrackStationId); station->updateLabel(); station->invalidate(); sub_48D794(*station); } } ClearFunctionArgs clearArgs; clearArgs.pos = trackLoc; clearArgs.bridgeId = bridgeType; clearArgs.trackId = args.trackId; clearArgs.trackObjectId = args.trackObjectId; clearArgs.flags = flags; bool hasLevelCrossing = false; auto clearFunc = [&totalCost, &hasLevelCrossing, &removedBuildings, &clearArgs](World::TileElement& el) { return clearFunction(el, totalCost, hasLevelCrossing, removedBuildings, clearArgs); }; if (!World::TileClearance::applyClearAtStandardHeight(trackLoc, elTrack->baseZ(), elTrack->clearZ(), World::QuarterTile(elTrack->occupiedQuarter(), 0), clearFunc)) { return GameCommands::FAILURE; } const auto posFlags = World::TileClearance::getPositionFlags(); // Abridged flags for just above/underground const auto newGroundFlags = posFlags & (World::TileManager::ElementPositionFlags::aboveGround | World::TileManager::ElementPositionFlags::underground); _byte_1136072 = newGroundFlags; if (hasLevelCrossing && (flags & GameCommands::Flags::apply)) { // elTrack is invalid after clearFunction elTrack = getTrackElement(trackLoc, args.rotation, args.trackObjectId, args.trackId, piece.index, companyId); elTrack->setHasLevelCrossing(true); } if (flags & Flags::apply) { World::TileManager::removeAllWallsOnTileBelow(World::toTileSpace(trackLoc), trackLoc.z / World::kSmallZStep); World::TileManager::removeSurfaceIndustryAtHeight(trackLoc); World::TileManager::setTerrainStyleAsClearedAtHeight(trackLoc); } } // 0x004A7999 if (hasBridge) { auto* bridgeObj = ObjectManager::get<BridgeObject>(bridgeType); const auto heightCost = 1 * bridgeObj->heightCostFactor; // Why 1??? const auto bridgeBaseCost = Economy::getInflationAdjustedCost(bridgeObj->baseCostFactor + heightCost, bridgeObj->costIndex, 10); auto cost = (bridgeBaseCost * trackIdCostFactor) / 256; if (overWater) { cost *= 2; } totalCost += cost; } if ((_byte_1136072 & World::TileManager::ElementPositionFlags::underground) != World::TileManager::ElementPositionFlags::none) { const auto tunnelBaseCost = Economy::getInflationAdjustedCost(trackObj->tunnelCostFactor, 2, 8); auto cost = (tunnelBaseCost * trackIdCostFactor) / 256; totalCost += cost; } if (flags & Flags::apply) { playConstructionPlacementSound(getPosition()); } return totalCost; } // 0x004A734F void aiTrackReplacement(registers& regs) { regs.ebx = aiTrackReplacement(AiTrackReplacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/CompanyAi/AiTrackReplacement.h ```h #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct AiTrackReplacementArgs { static constexpr auto command = GameCommand::aiTrackReplacement; AiTrackReplacementArgs() = default; explicit AiTrackReplacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl) , sequenceIndex(regs.dh) , trackObjectId(regs.bp) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t sequenceIndex; uint8_t trackObjectId; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = trackId; regs.dh = sequenceIndex; regs.bp = trackObjectId; return regs; } }; void aiTrackReplacement(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/LoadSaveQuit.cpp ```cpp #include "LoadSaveQuit.h" #include "Audio/Audio.h" #include "Game.h" #include "GameCommands/GameCommands.h" #include "SceneManager.h" #include "Tutorial.h" #include "Ui/WindowManager.h" #include "Ui/WindowType.h" #pragma warning(disable : 4702) using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0043BFCB static uint32_t loadSaveQuit(const LoadSaveQuitGameArgs& args, const uint8_t flags) { if ((flags & Flags::apply) == 0) { return 0; } if (args.saveMode == LoadSaveQuitGameArgs::SaveMode::closeSavePrompt) { Ui::WindowManager::close(Ui::WindowType::saveGamePrompt); return 0; } auto loadOrQuitMode = args.loadQuitMode; if (args.saveMode == LoadSaveQuitGameArgs::SaveMode::promptSave) { Ui::Windows::TextInput::cancel(); Ui::Windows::PromptSaveWindow::open(loadOrQuitMode); if (!SceneManager::isTitleMode()) { // 0x0043C369 // NB: tutorial recording has been omitted. if (Tutorial::state() == Tutorial::State::playing) { Tutorial::stop(); } else if (!SceneManager::isNetworked() || loadOrQuitMode != LoadOrQuitMode::quitGamePrompt) { if (SceneManager::getSceneAge() >= 0xF00) { auto window = Ui::WindowManager::bringToFront(Ui::WindowType::saveGamePrompt); Audio::playSound(Audio::SoundId::openWindow, window->x + (window->width / 2)); return 0; } } } } // 0x0043BFE3 switch (loadOrQuitMode) { case LoadOrQuitMode::loadGamePrompt: Game::loadGame(); break; case LoadOrQuitMode::returnToTitlePrompt: Game::returnToTitle(); break; case LoadOrQuitMode::quitGamePrompt: Game::quitGame(); break; } return 0; } void loadSaveQuit(registers& regs) { regs.ebx = loadSaveQuit(LoadSaveQuitGameArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/LoadSaveQuit.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct LoadSaveQuitGameArgs { enum class SaveMode : uint8_t { promptSave, closeSavePrompt, dontSave, }; static constexpr auto command = GameCommand::loadSaveQuitGame; LoadSaveQuitGameArgs() = default; explicit LoadSaveQuitGameArgs(const registers& regs) : loadQuitMode(static_cast<LoadOrQuitMode>(regs.di)) , saveMode(static_cast<SaveMode>(regs.dl)) { } LoadOrQuitMode loadQuitMode; SaveMode saveMode; explicit operator registers() const { registers regs; regs.di = enumValue(loadQuitMode); // [ 0 = load game, 1 = return to title screen, 2 = quit to desktop ] regs.dl = enumValue(saveMode); // [ 0 = prompt save, 1 = close save prompt, 2 = don't save ] return regs; } }; void loadSaveQuit(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/RenameStation.cpp ```cpp #include "RenameStation.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Graphics/Gfx.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Types.hpp" #include "World/Industry.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { /** * 0x00490756 * Renames a particular station. * * This command is called 3 times before the buffer is applied. Each time, 12 chars of the 36 char buffer are provided. * The resulting station name has a maximum length of 31 chars; the last bytes are not used. * * @param flags @<bl> - game command flags * @param stationId @<cx> - station id * @param index @<ax> - update index (in order of: 1, 2, 0) * @param buffer0 @<edx> - First part (4 chars) of the 12 update buffer * @param buffer1 @<dx> - Second part (4 chars) of the 12 update buffer * @param buffer2 @<bp> - Third part (4 chars) of the 12 update buffer * @return @<ebx> - returns 0 if rename is successful; otherwise GameCommands::FAILURE */ static uint32_t renameStation(const GameCommands::RenameStationArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); // Keep track of the station id over several calls. static StationId _stationId{}; if (args.nameBufferIndex == 1) { _stationId = args.stationId; } static char staticRenameBuffer[37]{}; // Fill buffer over calls into the renameBuffer if ((flags & GameCommands::Flags::apply) != 0) { static constexpr std::array<int, 3> kTransformTable = { 2, 0, 1 }; int arrayIndex = kTransformTable.at(args.nameBufferIndex); std::memcpy(staticRenameBuffer + arrayIndex * 12, args.buffer, 12); } // Applying the buffer? if (args.nameBufferIndex != 0) { return 0; } char renameStringBuffer[37] = ""; memcpy(renameStringBuffer, staticRenameBuffer, sizeof(staticRenameBuffer)); renameStringBuffer[36] = '\0'; // Figure out the current name for this station. char currentStationName[256] = ""; auto station = StationManager::get(_stationId); FormatArguments fArgs{}; fArgs.push(station->town); StringManager::formatString(currentStationName, station->name, fArgs); // Verify the new name actually differs from the old one. if (strcmp(currentStationName, renameStringBuffer) == 0) { return 0; } StringId oldStringId = station->name; // If an empty string is given, generate one instead. if (strlen(renameStringBuffer) == 0) { // Are we bailing out early? if ((flags & GameCommands::Flags::apply) == 0) { return 0; } station->name = StationManager::generateNewStationName(_stationId, station->town, World::Pos3(station->x, station->y, station->z), 0); } else { // Allocate a string id for the new name. StringId allocatedStringId = StringManager::userStringAllocate(renameStringBuffer, true); if (allocatedStringId == StringIds::empty) { return GameCommands::FAILURE; } // Are we bailing out early? if ((flags & GameCommands::Flags::apply) == 0) { StringManager::emptyUserString(allocatedStringId); return 0; } // Apply the new name to the station. station->name = allocatedStringId; } StringManager::emptyUserString(oldStringId); station->updateLabel(); Gfx::invalidateScreen(); return 0; } void renameStation(registers& regs) { regs.ebx = renameStation(GameCommands::RenameStationArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/RenameStation.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RenameStationArgs { static constexpr auto command = GameCommand::changeStationName; RenameStationArgs() = default; explicit RenameStationArgs(const registers& regs) : stationId(StationId(regs.cx)) , nameBufferIndex(regs.ax) , buffer{} { std::memcpy(buffer, &regs.edx, 4); std::memcpy(buffer + 4, &regs.ebp, 4); std::memcpy(buffer + 8, &regs.edi, 4); } StationId stationId; uint8_t nameBufferIndex; char buffer[37]; explicit operator registers() const { registers regs; regs.cx = enumValue(stationId); regs.ax = nameBufferIndex; constexpr std::array<uint8_t, 3> iToOffset = { 24, 0, 12 }; const auto offset = iToOffset[nameBufferIndex]; std::memcpy(&regs.edx, buffer + offset, 4); std::memcpy(&regs.ebp, buffer + offset + 4, 4); std::memcpy(&regs.edi, buffer + offset + 8, 4); return regs; } }; void renameStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/SetGameSpeed.cpp ```cpp #include "SetGameSpeed.h" #include "GameCommands/GameCommands.h" #include "SceneManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { static uint32_t setGameSpeed(const GameSpeed speed) { if (speed > GameSpeed::MAX) { return FAILURE; } SceneManager::setGameSpeed(speed); return 0; } void setGameSpeed(registers& regs) { SetGameSpeedArgs args(regs); regs.ebx = GameCommands::setGameSpeed(args.newSpeed); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/SetGameSpeed.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct SetGameSpeedArgs { static constexpr auto command = GameCommand::setGameSpeed; SetGameSpeedArgs() = default; explicit SetGameSpeedArgs(const registers& regs) : newSpeed(static_cast<GameSpeed>(regs.edi)) { } explicit SetGameSpeedArgs(const GameSpeed speed) { newSpeed = speed; } GameSpeed newSpeed; explicit operator registers() const { registers regs; regs.edi = static_cast<std::underlying_type_t<GameSpeed>>(newSpeed); return regs; } }; void setGameSpeed(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/TogglePause.cpp ```cpp #include "TogglePause.h" #include "Audio/Audio.h" #include "GameCommands/GameCommands.h" #include "GameException.hpp" #include "SceneManager.h" #include "Ui/WindowManager.h" #include "Ui/WindowType.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x00431E32 static uint32_t togglePause(uint8_t flags) { if ((flags & Flags::apply) == 0) { return 0; } Ui::WindowManager::invalidate(Ui::WindowType::timeToolbar); if (SceneManager::isPaused()) { SceneManager::unsetPauseFlag(1 << 0); Audio::unpauseSound(); } else { SceneManager::setPauseFlag(1 << 0); Audio::pauseSound(); Ui::Windows::TimePanel::invalidateFrame(); } return 0; } void togglePause(registers& regs) { regs.ebx = togglePause(regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/General/TogglePause.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct PauseGameArgs { static constexpr auto command = GameCommand::pauseGame; PauseGameArgs() = default; explicit PauseGameArgs(const registers&) { } explicit operator registers() const { return registers(); } }; void togglePause(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Cheats/Cheat.cpp ```cpp #include "Cheat.h" #include "Economy/Currency.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Logging.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "MessageManager.h" #include "Scenario.h" #include "Types.hpp" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include "World/TownManager.h" using namespace OpenLoco::World; using namespace OpenLoco::Diagnostics; namespace OpenLoco::GameCommands { namespace Cheats { static uint32_t acquireAssets(CompanyId targetCompanyId) { auto ourCompanyId = GameCommands::getUpdatingCompanyId(); // First phase: change ownership of all tile elements that currently belong to the target company. for (auto& element : TileManager::getElements()) { auto* roadElement = element.as<RoadElement>(); if (roadElement != nullptr) { // Check to verify that roadElement is owned by the target company if (roadElement->owner() == targetCompanyId) { roadElement->setOwner(ourCompanyId); } continue; } auto* trackElement = element.as<TrackElement>(); if (trackElement != nullptr) { // Check to verify that the trackElement is owned by the target company. if (trackElement->owner() == targetCompanyId) { trackElement->setOwner(ourCompanyId); } continue; } } // Second phase: change ownership of all stations that currently belong to the target company. for (auto& station : StationManager::stations()) { if (station.owner != targetCompanyId) { continue; } station.owner = ourCompanyId; } // Third phase: change ownership of all vehicles that currently belong to the target company. for (auto* vehicle : VehicleManager::VehicleList()) { if (vehicle->owner != targetCompanyId) { continue; } Vehicles::Vehicle train(*vehicle); train.applyToComponents([ourCompanyId](Vehicles::VehicleBase& component) { component.owner = ourCompanyId; }); } return 0; } static uint32_t addCash(currency32_t amount) { auto company = CompanyManager::getPlayerCompany(); company->cash = company->cash + amount; return 0; } static uint32_t clearLoan() { auto company = CompanyManager::getPlayerCompany(); company->currentLoan = 0; return 0; } static uint32_t companyRatings(bool absolute, int32_t value) { auto companyId = CompanyManager::getControllingId(); for (auto& town : TownManager::towns()) { // Does this town have a rating for our company? if (!(town.companiesWithRating &= (1 << enumValue(companyId)))) { continue; } int16_t newRanking{}; if (absolute) { newRanking = value * kMaxCompanyRating; } else { newRanking = town.companyRatings[enumValue(companyId)] + kMaxCompanyRating; newRanking *= 1.0f + (1.0f / value); newRanking -= kMaxCompanyRating; } // Set the new rating. town.companyRatings[enumValue(companyId)] = std::clamp<int16_t>(newRanking, kMinCompanyRating, kMaxCompanyRating); } return 0; } static uint32_t switchCompany(CompanyId targetCompanyId) { auto ourId = CompanyManager::getControllingId(); auto otherId = CompanyManager::getSecondaryPlayerId(); // Already controlling the target company? if (targetCompanyId == ourId) { return 0; } // Is the other player controlling the target company? Swap companies. if (targetCompanyId == otherId) { CompanyManager::setSecondaryPlayerId(ourId); CompanyManager::setControllingId(otherId); return 0; } // Change control over to the other company. CompanyManager::setControllingId(targetCompanyId); return 0; } static uint32_t toggleBankruptcy(CompanyId targetCompanyId) { auto company = CompanyManager::get(targetCompanyId); company->challengeFlags ^= CompanyFlags::bankrupt; return 0; } static uint32_t toggleJail(CompanyId targetCompanyId) { auto company = CompanyManager::get(targetCompanyId); if (company->jailStatus == 0) { company->jailStatus = 30; } else { company->jailStatus = 0; } return 0; } static uint32_t completeChallenge(CompanyId targetCompanyId) { auto company = CompanyManager::get(targetCompanyId); if ((company->challengeFlags & CompanyFlags::challengeCompleted) != CompanyFlags::none) { return 0; } company->challengeFlags &= ~(CompanyFlags::challengeBeatenByOpponent | CompanyFlags::challengeCompleted | CompanyFlags::challengeFailed); company->challengeProgress = 100; company->evaluateChallengeProgress(); return 0; } static uint32_t vehicleReliability(int32_t newReliablity) { auto ourCompanyId = GameCommands::getUpdatingCompanyId(); for (auto* vehicle : VehicleManager::VehicleList()) { if (vehicle->owner != ourCompanyId) { continue; } Vehicles::Vehicle train(*vehicle); train.veh2->reliability = newReliablity; // Set reliability for the front bogie component on each car. for (auto& car : train.cars) { car.front->reliability = newReliablity * 256; } } return 0; } static uint32_t modifyDateCheat(int32_t year, int32_t month, int32_t day) { Scenario::initialiseDate(static_cast<uint16_t>(year), static_cast<MonthId>(month), static_cast<uint8_t>(day)); Logging::info("Date set to: Day={} Month={} Year={}", day, month, year); return 0; } } static uint32_t cheat(const GameCommands::GenericCheatArgs& args, uint8_t flags) { if (!(flags & GameCommands::Flags::apply)) { return 0; } switch (args.subcommand) { case CheatCommand::acquireAssets: return Cheats::acquireAssets(CompanyId(args.param1)); case CheatCommand::addCash: return Cheats::addCash(args.param1); case CheatCommand::clearLoan: return Cheats::clearLoan(); case CheatCommand::companyRatings: return Cheats::companyRatings(args.param1, args.param2); case CheatCommand::switchCompany: return Cheats::switchCompany(CompanyId(args.param1)); case CheatCommand::toggleBankruptcy: return Cheats::toggleBankruptcy(CompanyId(args.param1)); case CheatCommand::toggleJail: return Cheats::toggleJail(CompanyId(args.param1)); case CheatCommand::vehicleReliability: return Cheats::vehicleReliability(args.param1); case CheatCommand::modifyDate: return Cheats::modifyDateCheat(args.param1, args.param2, args.param3); case CheatCommand::completeChallenge: return Cheats::completeChallenge(CompanyId(args.param1)); default: break; } return 0; } void cheat(registers& regs) { regs.ebx = cheat(GameCommands::GenericCheatArgs(regs), regs.bl); } // 0x004BAC53 static uint32_t vehicleShuntCheat(EntityId head, uint8_t flags) { auto* veh = EntityManager::get<Vehicles::VehicleHead>(head); if (veh == nullptr) { return GameCommands::FAILURE; } if (flags & Flags::apply) { veh->vehicleFlags |= VehicleFlags::shuntCheat; } return 0; } void vehicleShuntCheat(registers& regs) { VehicleApplyShuntCheatArgs args(regs); regs.ebx = vehicleShuntCheat(args.head, regs.bl); } // 0x00438A08 static uint32_t freeCashCheat(uint8_t flags) { if (flags & Flags::apply) { auto companyId = GameCommands::getUpdatingCompanyId(); auto* company = CompanyManager::get(companyId); company->jailStatus = 30; Ui::WindowManager::invalidate(Ui::WindowType::company, static_cast<Ui::WindowNumber_t>(companyId)); Ui::WindowManager::invalidate(Ui::WindowType::news); Ui::WindowManager::invalidate(static_cast<Ui::WindowType>(0x2E)); MessageManager::post(MessageType::companyCheated, CompanyId::null, enumValue(companyId), 0xFFFF); companyEmotionEvent(companyId, Emotion::dejected); } return 0; } void freeCashCheat(registers& regs) { regs.ebx = freeCashCheat(regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Cheats/Cheat.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleApplyShuntCheatArgs { static constexpr auto command = GameCommand::vehicleApplyShuntCheat; VehicleApplyShuntCheatArgs() = default; explicit VehicleApplyShuntCheatArgs(const registers& regs) : head(EntityId(regs.cx)) { } EntityId head; explicit operator registers() const { registers regs; regs.cx = enumValue(head); return regs; } }; struct ApplyFreeCashCheatArgs { static constexpr auto command = GameCommand::applyFreeCashCheat; ApplyFreeCashCheatArgs() = default; explicit ApplyFreeCashCheatArgs(const registers&) { } explicit operator registers() const { return registers(); } }; enum class CheatCommand : uint8_t { acquireAssets, addCash, clearLoan, companyRatings, switchCompany, toggleBankruptcy, toggleJail, vehicleReliability, modifyDate, completeChallenge, }; struct GenericCheatArgs { static constexpr auto command = GameCommand::cheat; GenericCheatArgs() = default; explicit GenericCheatArgs(const registers& regs) : subcommand(static_cast<CheatCommand>(regs.bh)) , param1(regs.eax) , param2(regs.ecx) , param3(regs.edx) { } CheatCommand subcommand{}; int32_t param1{}; int32_t param2{}; int32_t param3{}; explicit operator registers() const { registers regs; regs.bh = enumValue(subcommand); regs.eax = param1; regs.ecx = param2; regs.edx = param3; return regs; } }; void vehicleShuntCheat(registers& regs); void cheat(registers& regs); void freeCashCheat(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/CloneVehicle.cpp ```cpp #include "CloneVehicle.h" #include "CreateVehicle.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "VehicleChangeRunningMode.h" #include "VehicleOrderInsert.h" #include "VehicleRefit.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { static void copyVehicleColours(Vehicles::VehicleBase* source, Vehicles::VehicleBase* target) { auto* sourceHead = source; auto* targetHead = target; while (sourceHead != nullptr && targetHead != nullptr) { targetHead->setColourScheme(sourceHead->getColourScheme()); sourceHead = sourceHead->nextVehicleComponent(); targetHead = targetHead->nextVehicleComponent(); } } static uint32_t cloneVehicle(EntityId head, uint8_t flags) { static loco_global<EntityId, 0x0113642A> _113642A; Vehicles::Vehicle existingTrain(head); Vehicles::VehicleHead* newHead = nullptr; // Get total cost for a new vehicle if (!(flags & Flags::apply)) { uint32_t totalCost = 0; for (auto& car : existingTrain.cars) { VehicleCreateArgs args{}; args.vehicleId = EntityId::null; args.vehicleType = car.front->objectId; const auto cost = doCommand(args, 0); if (cost == FAILURE) { totalCost = FAILURE; break; } else { totalCost += cost; } } if (totalCost == FAILURE) { return FAILURE; } return totalCost; } uint16_t cargoType = 0; uint32_t totalCost = 0; for (auto& car : existingTrain.cars) { uint32_t cost = 0; if (newHead == nullptr) { VehicleCreateArgs args{}; args.vehicleId = EntityId::null; args.vehicleType = car.front->objectId; cost = doCommand(args, Flags::apply); cargoType = car.body->primaryCargo.type; auto* newVeh = EntityManager::get<Vehicles::VehicleBase>(_113642A); if (newVeh == nullptr) { return FAILURE; } newHead = EntityManager::get<Vehicles::VehicleHead>(newVeh->getHead()); } else { VehicleCreateArgs args{}; args.vehicleId = newHead->head; args.vehicleType = car.front->objectId; cost = doCommand(args, Flags::apply); } if (cost == FAILURE) { totalCost = FAILURE; break; } else { totalCost += cost; } } if (totalCost == FAILURE || newHead == nullptr) { return FAILURE; } copyVehicleColours(existingTrain.head, newHead); // Copy orders std::vector<std::shared_ptr<Vehicles::Order>> clonedOrders; for (auto& existingOrders : Vehicles::OrderRingView(existingTrain.head->orderTableOffset)) { clonedOrders.push_back(existingOrders.clone()); } for (auto& order : clonedOrders) { // Do not cache this as it will be a different value every iteration auto chosenOffset = newHead->sizeOfOrderTable - 1; VehicleOrderInsertArgs args{}; args.head = newHead->id; args.orderOffset = chosenOffset; args.rawOrder = order->getRaw(); GameCommands::doCommand(args, GameCommands::Flags::apply); } // Copy express/local if ((existingTrain.veh1->var_48 & Vehicles::Flags48::expressMode) != Vehicles::Flags48::none) { GameCommands::VehicleChangeRunningModeArgs args{}; args.head = newHead->id; args.mode = GameCommands::VehicleChangeRunningModeArgs::Mode::toggleLocalExpress; GameCommands::doCommand(args, GameCommands::Flags::apply); } // Copy cargo refit status (only applies to boats and airplanes) if (newHead->vehicleType == VehicleType::ship || newHead->vehicleType == VehicleType::aircraft) { VehicleRefitArgs args{}; args.head = newHead->head; args.cargoType = cargoType; doCommand(args, Flags::apply); } return totalCost; } void cloneVehicle(registers& regs) { regs.ebx = cloneVehicle(EntityId(regs.ax), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/CloneVehicle.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleCloneArgs { static constexpr auto command = GameCommand::vehicleClone; VehicleCloneArgs() = default; explicit VehicleCloneArgs(const registers& regs) : vehicleHeadId(static_cast<EntityId>(regs.ax)) { } EntityId vehicleHeadId; explicit operator registers() const { registers regs; regs.ax = enumValue(vehicleHeadId); return regs; } }; void cloneVehicle(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/CreateVehicle.cpp ```cpp #include "CreateVehicle.h" #include "Audio/Audio.h" #include "Config.h" #include "Date.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/Tile.h" #include "MessageManager.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/SoundObject.h" #include "Objects/TrackObject.h" #include "Objects/VehicleObject.h" #include "Random.h" #include "Types.hpp" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/RoutingManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "World/CompanyManager.h" #include "World/Station.h" #include <numeric> #include <optional> #include <utility> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; using namespace OpenLoco::Vehicles; namespace OpenLoco::GameCommands { constexpr auto kMaxAiVehicles = 500; constexpr auto kMaxNumCarComponentsInCar = 4; // TODO: Move to VehicleObject constexpr auto kNumVehicleComponentsInCarComponent = 3; // Bogie body constexpr auto kNumVehicleComponentsInBase = 4; // head unk_1 unk_2 tail constexpr auto kMaxNumVehicleComponentsInCar = kNumVehicleComponentsInCarComponent * kMaxNumCarComponentsInCar; static loco_global<ColourScheme, 0x01136140> _1136140; // primary colour static loco_global<int32_t, 0x011360FC> _11360FC; static loco_global<VehicleHead*, 0x01136240> _backupVeh0; static loco_global<int16_t, 0x01136248> _backup2E; static loco_global<TrackAndDirection, 0x0113624C> _backup2C; static loco_global<int16_t, 0x01136250> _backupX; static loco_global<int16_t, 0x01136254> _backupY; static loco_global<uint8_t, 0x01136258> _backupZ; static loco_global<EntityId, 0x0113642A> _113642A; // used by build window and others // 0x004B1D96 static bool aiIsBelowVehicleLimit() { if (CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { return true; } const auto& companies = CompanyManager::companies(); auto totalAiVehicles = std::accumulate(companies.begin(), companies.end(), 0, [](const int32_t total, const auto& company) { if (CompanyManager::isPlayerCompany(company.id())) { return total; } return total + std::accumulate(std::begin(company.transportTypeCount), std::end(company.transportTypeCount), 0); }); if (totalAiVehicles > kMaxAiVehicles) { setErrorText(StringIds::too_many_vehicles); return false; } return true; } // 0x004B1E44 static bool isEmptyVehicleSlotAvailable() { if (!aiIsBelowVehicleLimit()) { return false; } if (RoutingManager::isEmptyRoutingSlotAvailable()) { return true; } setErrorText(StringIds::too_many_vehicles); return false; } template<typename T> static T* createVehicleBaseEntity() { auto* const base = EntityManager::createEntityVehicle(); base->baseType = EntityBaseType::vehicle; auto* const vehicleBase = base->asBase<Vehicles::VehicleBase>(); vehicleBase->setSubType(T::kVehicleThingType); return static_cast<T*>(vehicleBase); } // 0x004AE8F1, 0x004AEA9E static VehicleBogie* createBogie(const EntityId head, const uint16_t vehicleTypeId, [[maybe_unused]] const VehicleObject& vehObject, const uint8_t bodyNumber, VehicleBase* const lastVeh, const ColourScheme colourScheme) { auto newBogie = createVehicleBaseEntity<VehicleBogie>(); newBogie->owner = getUpdatingCompanyId(); newBogie->head = head; newBogie->bodyIndex = bodyNumber; newBogie->trackType = lastVeh->getTrackType(); newBogie->mode = lastVeh->getTransportMode(); newBogie->tileX = -1; newBogie->tileY = 0; newBogie->tileBaseZ = 0; newBogie->subPosition = 0; newBogie->trackAndDirection = TrackAndDirection(0, 0); newBogie->routingHandle = lastVeh->getRoutingHandle(); newBogie->objectId = vehicleTypeId; auto& prng = gPrng1(); newBogie->var_44 = prng.randNext(); newBogie->creationDay = getCurrentDay(); newBogie->animationIndex = 0; newBogie->var_47 = 0; newBogie->secondaryCargo.acceptedTypes = 0; newBogie->secondaryCargo.type = 0xFF; newBogie->secondaryCargo.qty = 0; newBogie->wheelSlipping = 0; newBogie->breakdownFlags = BreakdownFlags::none; newBogie->var_60 = 0; // different to createbody newBogie->var_61 = 0; // different to createbody newBogie->spriteWidth = 1; newBogie->spriteHeightNegative = 1; newBogie->spriteHeightPositive = 1; newBogie->colourScheme = colourScheme; lastVeh->setNextCar(newBogie->id); return newBogie; } // 0x4AE8F1 static VehicleBogie* createFirstBogie(const EntityId head, const uint16_t vehicleTypeId, const VehicleObject& vehObject, const uint8_t bodyNumber, VehicleBase* const lastVeh, const ColourScheme colourScheme) { auto newBogie = createBogie(head, vehicleTypeId, vehObject, bodyNumber, lastVeh, colourScheme); if (newBogie == nullptr) // Can never happen { return nullptr; } newBogie->var_38 = Flags38::none; int32_t reliability = vehObject.reliability * 256; if (vehObject.designed + 2 > getCurrentYear()) { // Vanilla intended to reduce reliability by 1/8th twice for the first two years after the year designed, then reduce reliability by 1/8th once for the third year. However, a bug meant that the two 1/8th reductions were always applied. reliability -= reliability / 8; reliability -= reliability / 8; } if (reliability != 0) { reliability += 255; } newBogie->reliability = reliability; sub_4BA873(*newBogie); // Calculate refund cost == 7/8 * cost auto cost = Economy::getInflationAdjustedCost(vehObject.costFactor, vehObject.costIndex, 6); newBogie->refundCost = cost - cost / 8; if (bodyNumber == 0) { // Only front car components front bogie can have cargo // stores only secondary cargo presumably due to space constraints // in the front car component body if (vehObject.numSimultaneousCargoTypes > 1) { newBogie->secondaryCargo.maxQty = vehObject.maxCargo[1]; newBogie->secondaryCargo.acceptedTypes = vehObject.compatibleCargoCategories[1]; auto cargoType = Numerics::bitScanForward(newBogie->secondaryCargo.acceptedTypes); if (cargoType != -1) { newBogie->secondaryCargo.type = cargoType; } } } newBogie->objectSpriteType = vehObject.carComponents[bodyNumber].frontBogieSpriteInd; if (newBogie->objectSpriteType != SpriteIndex::null) { newBogie->spriteWidth = vehObject.bogieSprites[newBogie->objectSpriteType].width; newBogie->spriteHeightNegative = vehObject.bogieSprites[newBogie->objectSpriteType].heightNegative; newBogie->spriteHeightPositive = vehObject.bogieSprites[newBogie->objectSpriteType].heightPositive; } return newBogie; } // 0x004AEA9E static VehicleBogie* createSecondBogie(const EntityId head, const uint16_t vehicleTypeId, const VehicleObject& vehObject, const uint8_t bodyNumber, VehicleBase* const lastVeh, const ColourScheme colourScheme) { auto newBogie = createBogie(head, vehicleTypeId, vehObject, bodyNumber, lastVeh, colourScheme); if (newBogie == nullptr) // Can never happen { return nullptr; } newBogie->var_38 = Flags38::isReversed; newBogie->objectSpriteType = vehObject.carComponents[bodyNumber].backBogieSpriteInd; if (newBogie->objectSpriteType != SpriteIndex::null) { newBogie->spriteWidth = vehObject.bogieSprites[newBogie->objectSpriteType].width; newBogie->spriteHeightNegative = vehObject.bogieSprites[newBogie->objectSpriteType].heightNegative; newBogie->spriteHeightPositive = vehObject.bogieSprites[newBogie->objectSpriteType].heightPositive; } return newBogie; } // 0x004AEA9E static VehicleBody* createBody(const EntityId head, const uint16_t vehicleTypeId, const VehicleObject& vehObject, const uint8_t bodyNumber, VehicleBase* const lastVeh, const ColourScheme colourScheme) { auto newBody = createVehicleBaseEntity<VehicleBody>(); // TODO: move this into the create function somehow newBody->setSubType(bodyNumber == 0 ? VehicleEntityType::body_start : VehicleEntityType::body_continued); newBody->owner = getUpdatingCompanyId(); newBody->head = head; newBody->bodyIndex = bodyNumber; newBody->trackType = lastVeh->getTrackType(); newBody->mode = lastVeh->getTransportMode(); newBody->tileX = -1; newBody->tileY = 0; newBody->tileBaseZ = 0; newBody->subPosition = 0; newBody->trackAndDirection = TrackAndDirection(0, 0); newBody->routingHandle = lastVeh->getRoutingHandle(); newBody->var_38 = Flags38::unk_0; // different to create bogie newBody->objectId = vehicleTypeId; auto& prng = gPrng1(); newBody->var_44 = prng.randNext(); newBody->creationDay = getCurrentDay(); newBody->animationFrame = 0; newBody->cargoFrame = 0; newBody->primaryCargo.acceptedTypes = 0; newBody->primaryCargo.type = 0xFF; newBody->primaryCargo.qty = 0; newBody->chuffSoundIndex = 0; // different to create bogie newBody->wheelSlipping = 0; newBody->breakdownFlags = BreakdownFlags::none; // different to create bogie if (bodyNumber == 0) { // If the car carries any type of cargo then it will have a primary // cargo in the first body of the first car component of the car. // Locomotives do not carry any cargo. if (vehObject.numSimultaneousCargoTypes != 0) { newBody->primaryCargo.maxQty = vehObject.maxCargo[0]; newBody->primaryCargo.acceptedTypes = vehObject.compatibleCargoCategories[0]; auto cargoType = Numerics::bitScanForward(newBody->primaryCargo.acceptedTypes); if (cargoType != -1) { newBody->primaryCargo.type = cargoType; } } } newBody->spriteWidth = 1; newBody->spriteHeightNegative = 1; newBody->spriteHeightPositive = 1; // different onwards to create bogie auto spriteType = vehObject.carComponents[bodyNumber].bodySpriteInd; if (spriteType != SpriteIndex::null) { if (spriteType & SpriteIndex::isReversed) { newBody->var_38 |= Flags38::isReversed; spriteType &= ~SpriteIndex::isReversed; } } newBody->objectSpriteType = spriteType; if (newBody->objectSpriteType != SpriteIndex::null) { newBody->spriteWidth = vehObject.bodySprites[newBody->objectSpriteType].width; newBody->spriteHeightNegative = vehObject.bodySprites[newBody->objectSpriteType].heightNegative; newBody->spriteHeightPositive = vehObject.bodySprites[newBody->objectSpriteType].heightPositive; } newBody->colourScheme = colourScheme; // same as create bogie if (bodyNumber == 0 && vehObject.hasFlags(VehicleObjectFlags::jacobsBogieFront)) { newBody->var_38 |= Flags38::jacobsBogieAvailable; } if (bodyNumber + 1 == vehObject.numCarComponents && vehObject.hasFlags(VehicleObjectFlags::jacobsBogieRear)) { newBody->var_38 |= Flags38::jacobsBogieAvailable; } lastVeh->setNextCar(newBody->id); // same as create bogie return newBody; } // 0x004AE86D static bool createCar(VehicleHead* head, const uint16_t vehicleTypeId) { if (!EntityManager::checkNumFreeEntities(kMaxNumVehicleComponentsInCar)) { return false; } // Get Car insertion location Vehicle train(*head); // lastVeh will point to the vehicle component prior to the tail (head, unk_1, unk_2 *here*, tail) or (... bogie, bogie, body *here*, tail) VehicleBase* lastVeh = nullptr; if (!train.cars.empty()) { for (auto& car : train.cars) { for (auto& carComponent : car) { lastVeh = carComponent.body; } } } else { lastVeh = train.veh2; } const auto vehObject = ObjectManager::get<VehicleObject>(vehicleTypeId); const auto company = CompanyManager::get(getUpdatingCompanyId()); _1136140 = company->mainColours; // Copy to global variable. Can be removed when all global uses confirmed auto colourScheme = company->mainColours; if (company->customVehicleColoursSet & (1 << vehObject->colourType)) { _1136140 = company->vehicleColours[vehObject->colourType - 1]; // Copy to global variable. Can be removed when all global uses confirmed colourScheme = company->vehicleColours[vehObject->colourType - 1]; } VehicleBogie* newCarStart = nullptr; for (auto bodyNumber = 0; bodyNumber < vehObject->numCarComponents; ++bodyNumber) { auto* const firstBogie = createFirstBogie(head->id, vehicleTypeId, *vehObject, bodyNumber, lastVeh, colourScheme); lastVeh = firstBogie; auto* const secondBogie = createSecondBogie(head->id, vehicleTypeId, *vehObject, bodyNumber, lastVeh, colourScheme); lastVeh = secondBogie; auto* const body = createBody(head->id, vehicleTypeId, *vehObject, bodyNumber, lastVeh, colourScheme); lastVeh = body; if (newCarStart == nullptr) { newCarStart = firstBogie; } } if (lastVeh == nullptr) // can never happen { return false; } lastVeh->setNextCar(train.tail->id); head->updateTrainProperties(); return true; } // 0x004B64F9 static uint16_t createUniqueTypeNumber(const VehicleType type) { std::array<bool, Limits::kMaxVehicles> _unkArr{}; for (auto* v : VehicleManager::VehicleList()) { if (v->owner == getUpdatingCompanyId() && v->vehicleType == type) { if (v->ordinalNumber != 0) { _unkArr[v->ordinalNumber - 1] = true; } } } uint16_t newNum = 0; for (; newNum < _unkArr.size(); ++newNum) { if (!_unkArr[newNum]) { break; } } return newNum + 1; } // 0x004AE34B static VehicleHead* createHead(const uint8_t trackType, const TransportMode mode, const RoutingHandle routingHandle, const VehicleType vehicleType) { auto* const newHead = createVehicleBaseEntity<VehicleHead>(); EntityManager::moveEntityToList(newHead, EntityManager::EntityListType::vehicleHead); newHead->owner = getUpdatingCompanyId(); newHead->head = newHead->id; newHead->vehicleFlags |= VehicleFlags::commandStop; newHead->trackType = trackType; newHead->mode = mode; newHead->tileX = -1; newHead->tileY = 0; newHead->tileBaseZ = 0; newHead->remainingDistance = 0; newHead->subPosition = 0; newHead->trackAndDirection = TrackAndDirection(0, 0); newHead->routingHandle = routingHandle; newHead->spriteWidth = 0; newHead->spriteHeightNegative = 0; newHead->spriteHeightPositive = 0; newHead->var_38 = Flags38::none; newHead->var_3C = 0; newHead->vehicleType = vehicleType; newHead->name = static_cast<uint8_t>(vehicleType) + 4; newHead->ordinalNumber = 0; // Reset to null value so ignored in next function newHead->ordinalNumber = createUniqueTypeNumber(vehicleType); newHead->var_52 = 0; newHead->var_5C = 0; newHead->status = Status::unk_0; newHead->stationId = StationId::null; newHead->breakdownFlags = BreakdownFlags::none; newHead->aiThoughtId = 0xFFU; newHead->aiPlacementPos.x = -1; newHead->totalRefundCost = 0; newHead->lastAverageSpeed = 0_mph; newHead->restartStoppedCarsTimeout = 0; OrderManager::allocateOrders(*newHead); return newHead; } // 0x004AE40E static Vehicle1* createVehicle1(const EntityId head, VehicleBase* const lastVeh) { auto* const newVeh1 = createVehicleBaseEntity<Vehicle1>(); newVeh1->owner = getUpdatingCompanyId(); newVeh1->head = head; newVeh1->trackType = lastVeh->getTrackType(); newVeh1->mode = lastVeh->getTransportMode(); newVeh1->tileX = -1; newVeh1->tileY = 0; newVeh1->tileBaseZ = 0; newVeh1->remainingDistance = 0; newVeh1->subPosition = 0; newVeh1->trackAndDirection = TrackAndDirection(0, 0); newVeh1->routingHandle = lastVeh->getRoutingHandle(); newVeh1->spriteWidth = 0; newVeh1->spriteHeightNegative = 0; newVeh1->spriteHeightPositive = 0; newVeh1->var_38 = Flags38::none; newVeh1->var_3C = 0; newVeh1->targetSpeed = 0_mph; newVeh1->timeAtSignal = 0; newVeh1->var_48 = Flags48::none; newVeh1->var_52 = 0; newVeh1->var_4E = 0; newVeh1->var_50 = 0; newVeh1->lastIncome.day = -1; lastVeh->setNextCar(newVeh1->id); return newVeh1; } // 0x004AE4A0 static Vehicle2* createVehicle2(const EntityId head, VehicleBase* const lastVeh) { auto* const newVeh2 = createVehicleBaseEntity<Vehicle2>(); newVeh2->owner = getUpdatingCompanyId(); newVeh2->head = head; newVeh2->trackType = lastVeh->getTrackType(); newVeh2->mode = lastVeh->getTransportMode(); newVeh2->tileX = -1; newVeh2->tileY = 0; newVeh2->tileBaseZ = 0; newVeh2->remainingDistance = 0; newVeh2->subPosition = 0; newVeh2->trackAndDirection = TrackAndDirection(0, 0); newVeh2->routingHandle = lastVeh->getRoutingHandle(); newVeh2->spriteWidth = 0; newVeh2->spriteHeightNegative = 0; newVeh2->spriteHeightPositive = 0; newVeh2->var_38 = Flags38::none; newVeh2->currentSpeed = 0.0_mph; newVeh2->motorState = MotorState::stopped; newVeh2->brakeLightTimeout = 0; newVeh2->drivingSoundId = SoundObjectId::null; newVeh2->objectId = 0xFFFFU; newVeh2->soundFlags = Vehicles::SoundFlags::none; newVeh2->curMonthRevenue = 0; newVeh2->profit[0] = 0; newVeh2->profit[1] = 0; newVeh2->profit[2] = 0; newVeh2->profit[3] = 0; newVeh2->reliability = 0; newVeh2->var_73 = Flags73::none; lastVeh->setNextCar(newVeh2->id); return newVeh2; } // 0x004AE54E static VehicleTail* createVehicleTail(const EntityId head, VehicleBase* const lastVeh) { auto* const newTail = createVehicleBaseEntity<VehicleTail>(); newTail->owner = getUpdatingCompanyId(); newTail->head = head; newTail->trackType = lastVeh->getTrackType(); newTail->mode = lastVeh->getTransportMode(); newTail->tileX = -1; newTail->tileY = 0; newTail->tileBaseZ = 0; newTail->remainingDistance = 0; newTail->subPosition = 0; newTail->trackAndDirection = TrackAndDirection(0, 0); newTail->routingHandle = lastVeh->getRoutingHandle(); newTail->spriteWidth = 0; newTail->spriteHeightNegative = 0; newTail->spriteHeightPositive = 0; newTail->var_38 = Flags38::none; newTail->drivingSoundId = SoundObjectId::null; newTail->objectId = 0xFFFFU; newTail->soundFlags = Vehicles::SoundFlags::none; newTail->trainDanglingTimeout = 0; lastVeh->setNextCar(newTail->id); newTail->nextCarId = EntityId::null; return newTail; } static std::optional<RoutingHandle> getAndAllocateFreeRoutingHandle() { if (!aiIsBelowVehicleLimit()) { return std::nullopt; } auto res = RoutingManager::getAndAllocateFreeRoutingHandle(); if (res.has_value()) { return res; } setErrorText(StringIds::too_many_vehicles); return std::nullopt; } // 0x004AE318 static std::optional<VehicleHead*> createBaseVehicle(const TransportMode mode, const VehicleType type, const uint8_t trackType) { if (!EntityManager::checkNumFreeEntities(kNumVehicleComponentsInBase)) { return {}; } if (OrderManager::orderTableLength() >= Limits::kMaxOrders) { setErrorText(StringIds::no_space_for_more_vehicle_orders); return {}; } auto routingHandle = getAndAllocateFreeRoutingHandle(); if (!routingHandle) { return {}; } auto* head = createHead(trackType, mode, *routingHandle, type); VehicleBase* lastVeh = head; if (lastVeh == nullptr) // Can never happen { return {}; } lastVeh = createVehicle1(head->id, lastVeh); if (lastVeh == nullptr) // Can never happen { return {}; } lastVeh = createVehicle2(head->id, lastVeh); if (lastVeh == nullptr) // Can never happen { return {}; } createVehicleTail(head->id, lastVeh); head->updateTrainProperties(); return { head }; } // 0x004AE6DE static void updateWholeVehicle(VehicleHead* const head) { head->autoLayoutTrain(); auto company = CompanyManager::get(getUpdatingCompanyId()); company->recalculateTransportCounts(); if (_backupVeh0 != reinterpret_cast<VehicleHead*>(-1)) { VehicleManager::placeDownVehicle(_backupVeh0, _backupX, _backupY, _backupZ, _backup2C, _backup2E); } Ui::WindowManager::invalidate(Ui::WindowType::vehicleList, enumValue(head->owner)); } // 0x004AE74E static uint32_t createNewVehicle(const uint8_t flags, const uint16_t vehicleTypeId) { setPosition({ Location::null, 0, 0 }); if (!EntityManager::checkNumFreeEntities(kMaxNumVehicleComponentsInCar + kNumVehicleComponentsInBase)) { return FAILURE; } if (!isEmptyVehicleSlotAvailable()) { return FAILURE; } if (flags & Flags::apply) { auto vehObject = ObjectManager::get<VehicleObject>(vehicleTypeId); auto head = createBaseVehicle(vehObject->mode, vehObject->type, vehObject->trackType); if (!head) { return FAILURE; } auto _head = *head; _113642A = _head->id; if (createCar(_head, vehicleTypeId)) { // 0x004AE6DE updateWholeVehicle(_head); } else { // Cleanup and delete base vehicle before exit. RoutingManager::freeRoutingHandle(_head->routingHandle); OrderManager::freeOrders(_head); MessageManager::removeAllSubjectRefs(enumValue(_head->id), MessageItemArgumentType::vehicle); auto veh1 = _head->nextVehicleComponent(); if (veh1 == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } auto veh2 = veh1->nextVehicleComponent(); if (veh2 == nullptr) { throw Exception::RuntimeError("Bad vehicle structure"); } auto tail = veh2->nextVehicleComponent(); // Get all vehicles before freeing EntityManager::freeEntity(_head); EntityManager::freeEntity(veh1); EntityManager::freeEntity(veh2); EntityManager::freeEntity(tail); return FAILURE; } } // 0x4AE733 auto vehObject = ObjectManager::get<VehicleObject>(vehicleTypeId); auto cost = Economy::getInflationAdjustedCost(vehObject->costFactor, vehObject->costIndex, 6); return cost; } // 0x004AE5FF static uint32_t addCarToVehicle(const uint8_t flags, const uint16_t vehicleTypeId, const EntityId headId) { Vehicle train(headId); setPosition(train.veh2->position); if (!sub_431E6A(train.head->owner)) { return FAILURE; } if (!train.head->canBeModified()) { return FAILURE; } if (!train.head->isVehicleTypeCompatible(vehicleTypeId)) { return FAILURE; } if (!EntityManager::checkNumFreeEntities(kMaxNumVehicleComponentsInCar)) { return FAILURE; } if (flags & Flags::apply) { if (train.head->tileX != -1) { _backupX = train.head->tileX; _backupY = train.head->tileY; _backupZ = train.head->tileBaseZ; _backup2C = train.head->trackAndDirection; _backup2E = train.head->subPosition; _backupVeh0 = train.head; train.head->liftUpVehicle(); } if (createCar(train.head, vehicleTypeId)) { // Note train.cars is no longer valid from after createCar updateWholeVehicle(train.head); } else { if (_backupVeh0 == reinterpret_cast<VehicleHead*>(-1)) { return FAILURE; } VehicleHead* veh0backup = _backupVeh0; // If it has an existing body Vehicle bkupTrain(*veh0backup); if (!bkupTrain.cars.empty()) { VehicleManager::placeDownVehicle(_backupVeh0, _backupX, _backupY, _backupZ, _backup2C, _backup2E); } return FAILURE; } } // 0x4AE733 auto vehObject = ObjectManager::get<VehicleObject>(vehicleTypeId); auto cost = Economy::getInflationAdjustedCost(vehObject->costFactor, vehObject->costIndex, 6); return cost; } // 0x004AE5E4 static uint32_t createVehicle(const uint8_t flags, const uint16_t vehicleTypeId, const EntityId headId) { setExpenditureType(ExpenditureType::VehiclePurchases); _backupVeh0 = reinterpret_cast<VehicleHead*>(-1); const auto* company = CompanyManager::get(GameCommands::getUpdatingCompanyId()); auto vehicleIsLocked = !company->isVehicleIndexUnlocked(static_cast<uint16_t>(vehicleTypeId)); if (vehicleIsLocked && !Config::get().buildLockedVehicles) { setErrorText(StringIds::vehicle_is_locked); return FAILURE; } if (headId == EntityId::null) { return createNewVehicle(flags, vehicleTypeId); } else { return addCarToVehicle(flags, vehicleTypeId, headId); } } void createVehicle(registers& regs) { regs.ebx = createVehicle(regs.bl, regs.dx, EntityId(regs.di)); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/CreateVehicle.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleCreateArgs { static constexpr auto command = GameCommand::vehicleCreate; VehicleCreateArgs() = default; explicit VehicleCreateArgs(const registers& regs) : vehicleId(static_cast<EntityId>(regs.di)) , vehicleType(regs.dx) { } EntityId vehicleId; // Optional id representing where it will attach uint16_t vehicleType; explicit operator registers() const { registers regs; regs.di = enumValue(vehicleId); regs.edx = vehicleType; return regs; } }; void createVehicle(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/RenameVehicle.cpp ```cpp #include "RenameVehicle.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Types.hpp" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> #include <array> #include <unordered_map> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { /** * 0x004B6572 * Rename vehicle - calls 3 times with part of the buffers (each 12 bytes long), in each cycle first without apply flag, second with apply flag. * The vehicle name is up to 31 characters long (no more characters were taken during the game play). * * @param flags @<bl> - game command flags * @param headId @<cx> - head id of the vehicle * @param index @<ax> - update index (in order of: 1, 2, 0) * @param buffer0 @<edx> - First group of 4 characters of a 12 character update buffer * @param buffer1 @<dx> - Second group of 4 characters of a 12 character update buffer * @param buffer2 @<bp> - Third group of 4 characters of a 12 character update buffer * @return @<ebx> - if rename is successful, return 0, if failed, return FAILURE */ static uint32_t renameVehicle(const VehicleRenameArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); static loco_global<EntityId, 0x0113621D> _headId_113621D; if (args.i == 1) { _headId_113621D = args.head; } static char staticRenameBuffer[37]{}; if ((flags & Flags::apply) != 0) { static constexpr std::array<int, 3> kTransformTable = { 2, 0, 1 }; int arrayIndex = kTransformTable.at(args.i); std::memcpy(staticRenameBuffer + arrayIndex * 12, args.buffer, 12); } if (args.i != 0) { return 0; } EntityId vehicleHeadId = _headId_113621D; Vehicles::VehicleHead* vehicleHead = EntityManager::get<Vehicles::VehicleHead>(vehicleHeadId); if (vehicleHead == nullptr) { return FAILURE; } char renameStringBuffer[37] = ""; memcpy(renameStringBuffer, staticRenameBuffer, sizeof(staticRenameBuffer)); renameStringBuffer[36] = '\0'; char existingVehicleName[512]; FormatArguments fArgs{}; fArgs.push(vehicleHead->ordinalNumber); StringManager::formatString(existingVehicleName, vehicleHead->name, fArgs); if (strcmp(existingVehicleName, renameStringBuffer) == 0) { return 0; } StringId allocatedStringId = StringIds::empty; if (strlen(renameStringBuffer) != 0) { allocatedStringId = StringManager::userStringAllocate(renameStringBuffer, true); if (allocatedStringId == StringIds::empty) { return FAILURE; } if ((flags & Flags::apply) == 0) { StringManager::emptyUserString(allocatedStringId); return 0; } } else { if ((flags & Flags::apply) == 0) { return 0; } static const std::unordered_map<VehicleType, StringId> defaultVehicleStringIdMap = { { VehicleType::train, StringIds::train_number }, { VehicleType::bus, StringIds::bus_number }, { VehicleType::truck, StringIds::truck_number }, { VehicleType::tram, StringIds::tram_number }, { VehicleType::aircraft, StringIds::aircraft_number }, { VehicleType::ship, StringIds::ship_number } }; allocatedStringId = defaultVehicleStringIdMap.at(vehicleHead->vehicleType); } StringId oldStringId = vehicleHead->name; vehicleHead->name = allocatedStringId; StringManager::emptyUserString(oldStringId); Gfx::invalidateScreen(); return 0; } void renameVehicle(registers& regs) { regs.ebx = renameVehicle(VehicleRenameArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/RenameVehicle.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleRenameArgs { static constexpr auto command = GameCommand::vehicleRename; VehicleRenameArgs() = default; explicit VehicleRenameArgs(const registers& regs) : head(static_cast<EntityId>(regs.cx)) , buffer{} , i(regs.ax) { // Copies it into the first 12 bytes not into the specific slot as per i std::memcpy(buffer, &regs.edx, 4); std::memcpy(buffer + 4, &regs.ebp, 4); std::memcpy(buffer + 8, &regs.edi, 4); } EntityId head; char buffer[37]; uint16_t i; explicit operator registers() const { registers regs; regs.cx = enumValue(head); regs.ax = i; constexpr std::array<uint8_t, 3> iToOffset = { 24, 0, 12 }; const auto offset = iToOffset[i]; std::memcpy(&regs.edx, buffer + offset, 4); std::memcpy(&regs.ebp, buffer + offset + 4, 4); std::memcpy(&regs.edi, buffer + offset + 8, 4); return regs; } }; void renameVehicle(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleChangeRunningMode.cpp ```cpp #include "VehicleChangeRunningMode.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Speed.hpp" #include "Types.hpp" #include "Ui/WindowManager.h" #include "VehicleSell.h" #include "Vehicles/Vehicle.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Literals; namespace OpenLoco::GameCommands { // 0x004B6B0C static bool canVehicleBeStarted(const Vehicles::Vehicle& train) { auto* company = CompanyManager::get(train.head->owner); if ((company->challengeFlags & CompanyFlags::bankrupt) != CompanyFlags::none) { GameCommands::setErrorText(StringIds::company_is_bankrupt); return false; } if (train.cars.empty()) { GameCommands::setErrorText(StringIds::train_has_no_vehicles); return false; } if (!train.head->hasVehicleFlags(VehicleFlags::manualControl)) { auto* vehicleObj = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); if (!vehicleObj->hasFlags(VehicleObjectFlags::topAndTailPosition)) { if (vehicleObj->power == 0 || vehicleObj->hasFlags(VehicleObjectFlags::centerPosition)) { GameCommands::setErrorText(StringIds::train_has_no_driving_cab); return false; } } } if (train.veh2->totalPower == 0) { GameCommands::setErrorText(StringIds::train_needs_a_locomotive_or_power_car); return false; } if (!train.head->hasVehicleFlags(VehicleFlags::manualControl)) { uint16_t pairObjectId = 0xFFFFU; uint16_t pairCount = 0U; for (auto& car : train.cars) { if (pairCount == 0) { auto* vehicleObj = ObjectManager::get<VehicleObject>(car.front->objectId); if (vehicleObj->hasFlags(VehicleObjectFlags::mustHavePair)) { pairObjectId = car.front->objectId; pairCount++; } continue; } else { if (car.front->objectId == pairObjectId) { pairCount++; } } } if (pairCount & 1) { auto* vehicleObj = ObjectManager::get<VehicleObject>(pairObjectId); FormatArguments::common(vehicleObj->name); GameCommands::setErrorText(StringIds::requires_an_extra_stringid); return false; } } return true; } static void invalidateWindow(EntityId headId) { Ui::WindowManager::invalidate(Ui::WindowType::vehicle, static_cast<Ui::WindowNumber_t>(headId)); } // 0x004B6AEE static uint32_t changeLocalExpressMode(const Vehicles::Vehicle& train, const uint8_t flags) { if (!(flags & Flags::apply)) { return 0; } train.veh1->var_48 ^= Vehicles::Flags48::expressMode; invalidateWindow(train.head->head); return 0; } // 0x004B6A08 static uint32_t startStopVehicle(const Vehicles::Vehicle& train, bool startVehicle, const uint8_t flags) { // Starting this vehicle -- can we? if (startVehicle && !canVehicleBeStarted(train)) { return FAILURE; } // Stopping this vehicle, but vehicle is already stopped? if (!startVehicle && train.head->hasVehicleFlags(VehicleFlags::commandStop)) { return 0; } // Starting this vehicle, but vehicle is already travelling? if (startVehicle && !train.head->hasVehicleFlags(VehicleFlags::commandStop)) { return 0; } if (!(flags & Flags::apply)) { return 0; } train.head->vehicleFlags ^= VehicleFlags::commandStop; if (train.head->hasVehicleFlags(VehicleFlags::commandStop)) { train.head->vehicleFlags &= ~VehicleFlags::manualControl; } if (!train.head->hasVehicleFlags(VehicleFlags::commandStop) && CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { auto madeProfit = train.veh2->profit[0] | train.veh2->profit[1] | train.veh2->profit[2] | train.veh2->profit[3]; if (madeProfit != 0) { companyEmotionEvent(getUpdatingCompanyId(), Emotion::happy); } } invalidateWindow(train.head->head); return 0; } // 0x004B6AAF static uint32_t toggleManualDriving(const Vehicles::Vehicle& train, const uint8_t flags) { // Can we change driving modes? if (!canVehicleBeStarted(train)) { return FAILURE; } if (!(flags & Flags::apply)) { return 0; } train.head->vehicleFlags ^= VehicleFlags::manualControl; train.head->manualPower = -40; if ((train.head->vehicleFlags & VehicleFlags::manualControl) != VehicleFlags::none) { train.head->vehicleFlags &= ~VehicleFlags::commandStop; } else { train.head->vehicleFlags |= VehicleFlags::commandStop; } if (train.head->status == Vehicles::Status::approaching) { train.head->stationId = StationId::null; train.head->status = Vehicles::Status::travelling; } invalidateWindow(train.head->head); return 0; } // 0x004B694B static uint32_t vehicleChangeRunningMode(const VehicleChangeRunningModeArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); try { Vehicles::Vehicle train(args.head); setPosition(train.veh2->position); // If we're only changing local/express, we can take a shortcut. if (args.mode == VehicleChangeRunningModeArgs::Mode::toggleLocalExpress) { return changeLocalExpressMode(train, flags); } // If a vehicle is stuck or crashed, immediately sell the vehicle instead. if ((train.head->status == Vehicles::Status::stuck || train.head->status == Vehicles::Status::crashed) && CompanyManager::isPlayerCompany(train.head->owner)) { if (flags & Flags::apply) { // 0x004B69C7 train.head->sub_4AD778(); train.head->status = Vehicles::Status::stopped; train.veh2->currentSpeed = 0_mph; GameCommands::VehicleSellArgs sargs{}; sargs.car = args.head; GameCommands::doCommand(sargs, GameCommands::Flags::apply); } return 0; } // Switching to manual driving? if (args.mode == VehicleChangeRunningModeArgs::Mode::driveManually) { return toggleManualDriving(train, flags); } bool startVehicle = args.mode == VehicleChangeRunningModeArgs::Mode::startVehicle; return startStopVehicle(train, startVehicle, flags); } catch (std::runtime_error&) { return FAILURE; } } void vehicleChangeRunningMode(registers& regs) { regs.ebx = vehicleChangeRunningMode(VehicleChangeRunningModeArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleChangeRunningMode.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleChangeRunningModeArgs { enum class Mode : uint8_t { stopVehicle, startVehicle, toggleLocalExpress, driveManually, }; static constexpr auto command = GameCommand::vehicleChangeRunningMode; VehicleChangeRunningModeArgs() = default; explicit VehicleChangeRunningModeArgs(const registers& regs) : head(static_cast<EntityId>(regs.dx)) , mode(static_cast<Mode>(regs.bh)) { } EntityId head; Mode mode; explicit operator registers() const { registers regs; regs.dx = enumValue(head); regs.bh = enumValue(mode); return regs; } }; void vehicleChangeRunningMode(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderDelete.cpp ```cpp #include "VehicleOrderDelete.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0047057A static uint32_t vehicleOrderDelete(const VehicleOrderDeleteArgs& args, uint8_t flags) { auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return GameCommands::FAILURE; } GameCommands::setPosition(head->position); if (!(flags & GameCommands::Flags::apply)) { return 0; } if (args.orderOffset > head->sizeOfOrderTable) { return FAILURE; } Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head->id)); Vehicles::OrderManager::deleteOrder(head, args.orderOffset); return 0; } void vehicleOrderDelete(registers& regs) { regs.ebx = vehicleOrderDelete(VehicleOrderDeleteArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderDelete.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleOrderDeleteArgs { static constexpr auto command = GameCommand::vehicleOrderDelete; VehicleOrderDeleteArgs() = default; explicit VehicleOrderDeleteArgs(const registers& regs) : head(EntityId(regs.di)) , orderOffset(regs.edx) { } EntityId head; uint32_t orderOffset; explicit operator registers() const { registers regs; regs.di = enumValue(head); regs.edx = orderOffset; return regs; } }; void vehicleOrderDelete(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderDown.cpp ```cpp #include "VehicleOrderDown.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x00470E06 static uint32_t vehicleOrderDown(const VehicleOrderDownArgs& args, uint8_t flags) { auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return GameCommands::FAILURE; } GameCommands::setPosition(head->position); if (!(flags & GameCommands::Flags::apply)) { return 0; } if (args.orderOffset > head->sizeOfOrderTable) { return FAILURE; } Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head->id)); // Figure out which orders to swap Vehicles::OrderRingView orders(head->orderTableOffset, args.orderOffset); auto iterator = orders.begin(); auto& currentOrder = *(iterator); auto& nextOrder = *(++iterator); // Don't swap if we've looped around if (nextOrder.getOffset() < currentOrder.getOffset()) { return 0; } // Before we proceed, we keep track of the currently active order bool currentOrderIsActive = head->currentOrder == currentOrder.getOffset() - head->orderTableOffset; bool nextOrderIsActive = head->currentOrder == nextOrder.getOffset() - head->orderTableOffset; auto oldOffsetDiff = nextOrder.getOffset() - currentOrder.getOffset(); // Actually swap the two orders const auto newOffsetDiff = Vehicles::OrderManager::swapAdjacentOrders(currentOrder, nextOrder); // Compensate if we swapped the current order around if (currentOrderIsActive) { head->currentOrder += newOffsetDiff; } else if (nextOrderIsActive) { head->currentOrder -= oldOffsetDiff; } return 0; } void vehicleOrderDown(registers& regs) { regs.ebx = vehicleOrderDown(VehicleOrderDownArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderDown.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleOrderDownArgs { static constexpr auto command = GameCommand::vehicleOrderDown; VehicleOrderDownArgs() = default; explicit VehicleOrderDownArgs(const registers& regs) : head(EntityId(regs.di)) , orderOffset(regs.edx) { } EntityId head; uint32_t orderOffset; explicit operator registers() const { registers regs; regs.di = enumValue(head); regs.edx = orderOffset; return regs; } }; void vehicleOrderDown(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderInsert.cpp ```cpp #include "VehicleOrderInsert.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Objects/VehicleObject.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include "World/StationManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::Vehicles; namespace OpenLoco::GameCommands { // 0x0047036E static uint32_t vehicleOrderInsert(const VehicleOrderInsertArgs& args, uint8_t flags) { auto* head = EntityManager::get<VehicleHead>(args.head); if (head == nullptr) { return GameCommands::FAILURE; } GameCommands::setPosition(head->position); auto* order = reinterpret_cast<const Order*>(&args.rawOrder); // Ensure we can use any station that has been selected if (order->hasFlags(OrderFlags::HasStation)) { auto* stationOrder = order->as<OrderStation>(); if (stationOrder != nullptr) { auto* station = StationManager::get(stationOrder->getStation()); if (station->owner != head->owner) { setErrorText(StringIds::stationOwnedByAnotherCompany); return FAILURE; } } } // Certain orders can't be used by ships or aircraft if (order->is<OrderRouteThrough>() || order->is<OrderRouteWaypoint>()) { // Ships can have route waypoints, but not route through orders. if (head->mode == TransportMode::water && order->is<OrderRouteThrough>()) { setErrorText(StringIds::orderTypeNotValidForShips); return FAILURE; } // Aircraft can't have either order else if (head->mode == TransportMode::air) { setErrorText(StringIds::orderTypeNotValidForAircraft); return FAILURE; } } // Verify we have room for more orders, both globally and for this particular vehicle if (!OrderManager::spaceLeftInGlobalOrderTableForOrder(order)) { setErrorText(StringIds::no_space_for_more_vehicle_orders); return FAILURE; } if (!OrderManager::spaceLeftInVehicleOrderTable(head)) { setErrorText(StringIds::tooManyOrdersForThisVehicle); return FAILURE; } if (args.orderOffset > head->sizeOfOrderTable) { return FAILURE; } if (!(flags & GameCommands::Flags::apply)) { return 0; } Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head->id)); // If we're inserting the same stop order once more, change its type to route through if (order->getType() == OrderType::StopAt && !(head->mode == TransportMode::water || head->mode == TransportMode::air)) { // To get the previous order (to check if it was also the same stop order) // its a bit convoluted we need to iterate the order table keeping // a lagging previous iterator. Once the iterator either points at the // target order or its reached the end then we have the previous order. auto orderTable = OrderRingView(head->orderTableOffset, 0); auto iter = orderTable.begin(); auto targetOrder = head->orderTableOffset + args.orderOffset; auto previous = iter; if (iter->getOffset() != targetOrder && iter != orderTable.end()) { iter++; while (iter->getOffset() != targetOrder && iter != orderTable.end()) { iter++; previous++; } } auto* existingOrder = previous->as<OrderStopAt>(); auto* newOrder = order->as<OrderStopAt>(); if (existingOrder != nullptr && newOrder != nullptr && existingOrder->getStation() == newOrder->getStation()) { existingOrder->setType(OrderType::RouteThrough); return 0; } } // All looks good -- insert a brand new order! OrderManager::insertOrder(head, args.orderOffset, order); return 0; } void vehicleOrderInsert(registers& regs) { regs.ebx = vehicleOrderInsert(VehicleOrderInsertArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderInsert.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleOrderInsertArgs { static constexpr auto command = GameCommand::vehicleOrderInsert; VehicleOrderInsertArgs() = default; explicit VehicleOrderInsertArgs(const registers& regs) : head(EntityId(regs.di)) , orderOffset(regs.dx) , rawOrder((static_cast<uint64_t>(regs.cx) << 32ULL) | static_cast<uint32_t>(regs.eax)) { } EntityId head; uint32_t orderOffset; uint64_t rawOrder; explicit operator registers() const { registers regs; regs.di = enumValue(head); regs.dx = orderOffset; regs.eax = rawOrder & 0xFFFFFFFF; regs.cx = rawOrder >> 32; return regs; } }; void vehicleOrderInsert(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderReverse.cpp ```cpp #include "VehicleOrderReverse.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { static uint32_t vehicleOrderReverse(const VehicleOrderReverseArgs& args, uint8_t flags) { auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return GameCommands::FAILURE; } GameCommands::setPosition(head->position); if (!(flags & GameCommands::Flags::apply)) { return 0; } Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head->id)); head->currentOrder = Vehicles::OrderManager::reverseVehicleOrderTable(head->orderTableOffset, head->currentOrder); return 0; } void vehicleOrderReverse(registers& regs) { regs.ebx = vehicleOrderReverse(VehicleOrderReverseArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderReverse.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleOrderReverseArgs { static constexpr auto command = GameCommand::vehicleOrderReverse; VehicleOrderReverseArgs() = default; explicit VehicleOrderReverseArgs(const registers& regs) : head(EntityId(regs.di)) { } EntityId head; explicit operator registers() const { registers regs; regs.di = enumValue(head); return regs; } }; void vehicleOrderReverse(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderSkip.cpp ```cpp #include "VehicleOrderSkip.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Orders.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0047071A static uint32_t vehicleOrderSkip(EntityId headId, uint8_t flags) { auto* head = EntityManager::get<Vehicles::VehicleHead>(headId); if (head == nullptr) { return FAILURE; } setPosition(head->position); if (!(flags & Flags::apply)) { return 0; } Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head->id)); Vehicles::OrderRingView orders(head->orderTableOffset, head->currentOrder); auto nextOrder = ++orders.begin(); head->currentOrder = nextOrder->getOffset() - head->orderTableOffset; return 0; } void vehicleOrderSkip(registers& regs) { regs.ebx = vehicleOrderSkip(EntityId(regs.di), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderSkip.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleOrderSkipArgs { static constexpr auto command = GameCommand::vehicleOrderSkip; VehicleOrderSkipArgs() = default; explicit VehicleOrderSkipArgs(const registers& regs) : head(EntityId(regs.di)) { } EntityId head; explicit operator registers() const { registers regs; regs.di = enumValue(head); return regs; } }; void vehicleOrderSkip(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderUp.cpp ```cpp #include "VehicleOrderUp.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "Vehicles/OrderManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x00470CD2 static uint32_t vehicleOrderUp(const VehicleOrderUpArgs& args, uint8_t flags) { auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return GameCommands::FAILURE; } GameCommands::setPosition(head->position); if (!(flags & GameCommands::Flags::apply)) { return 0; } if (args.orderOffset > head->sizeOfOrderTable) { return FAILURE; } Ui::WindowManager::invalidateOrderPageByVehicleNumber(enumValue(head->id)); // Can't move up if the order is already at the start of the table if (args.orderOffset == 0) { return 0; } // Figure out which orders to swap Vehicles::OrderRingView orders(head->orderTableOffset, args.orderOffset); Vehicles::Order* prevOrder = nullptr; auto iterator = orders.begin(); // Continue looping until we've found the target order do { prevOrder = &*iterator; iterator++; } while ((*iterator).getOffset() - head->orderTableOffset != args.orderOffset); auto& currentOrder = *(iterator); // Before we proceed, we keep track of the currently active order bool prevOrderIsActive = head->currentOrder == prevOrder->getOffset() - head->orderTableOffset; bool currentOrderIsActive = head->currentOrder == currentOrder.getOffset() - head->orderTableOffset; auto oldOffsetDiff = currentOrder.getOffset() - prevOrder->getOffset(); // Actually swap the two orders const auto newOffsetDiff = Vehicles::OrderManager::swapAdjacentOrders(*prevOrder, currentOrder); // Compensate if we swapped the current order around if (prevOrderIsActive) { head->currentOrder += newOffsetDiff; } else if (currentOrderIsActive) { head->currentOrder -= oldOffsetDiff; } return 0; } void vehicleOrderUp(registers& regs) { regs.ebx = vehicleOrderUp(VehicleOrderUpArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleOrderUp.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleOrderUpArgs { static constexpr auto command = GameCommand::vehicleOrderUp; VehicleOrderUpArgs() = default; explicit VehicleOrderUpArgs(const registers& regs) : head(EntityId(regs.di)) , orderOffset(regs.edx) { } EntityId head; uint32_t orderOffset; explicit operator registers() const { registers regs; regs.di = enumValue(head); regs.edx = orderOffset; return regs; } }; void vehicleOrderUp(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePassSignal.cpp ```cpp #include "VehiclePassSignal.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Types.hpp" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x004B0B50 static uint32_t vehiclePassSignal(EntityId headId, const uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); try { Vehicles::Vehicle train(headId); setPosition(train.veh2->position); auto& head = train.head; if (!sub_431E6A(head->owner)) { return FAILURE; } if (!head->canBeModified()) { return FAILURE; } if (!(flags & Flags::apply)) { return 0; } if (head->tileX == -1) { return 0; } head->var_5C = 2; train.veh1->var_48 |= Vehicles::Flags48::passSignal; return 0; } catch (std::runtime_error&) { return FAILURE; } } void vehiclePassSignal(registers& regs) { VehiclePassSignalArgs args(regs); regs.ebx = vehiclePassSignal(args.head, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePassSignal.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehiclePassSignalArgs { static constexpr auto command = GameCommand::vehiclePassSignal; VehiclePassSignalArgs() = default; explicit VehiclePassSignalArgs(const registers& regs) : head(static_cast<EntityId>(regs.di)) { } EntityId head; explicit operator registers() const { registers regs; regs.di = enumValue(head); return regs; } }; void vehiclePassSignal(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePickup.cpp ```cpp #include "VehiclePickup.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Random.h" #include "Types.hpp" #include "Vehicles/Vehicle.h" #include <OpenLoco/Core/Prng.h> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::Vehicles { // 0x0048B15B void playPickupSound(Vehicles::Vehicle2* veh2) { const auto frequency = gPrng2().randNext(20003, 24098); Audio::playSound(Audio::SoundId::vehiclePickup, veh2->position, -1000, frequency); } } namespace OpenLoco::GameCommands { // 0x004B0826 static uint32_t vehiclePickup(const uint8_t flags, EntityId headId) { GameCommands::setExpenditureType(ExpenditureType::TrainRunningCosts); auto* head = EntityManager::get<Vehicles::VehicleHead>(headId); if (head == nullptr) { return FAILURE; } auto train = Vehicles::Vehicle(*head); auto* veh2 = train.veh2; GameCommands::setPosition(veh2->position); if (!GameCommands::sub_431E6A(head->owner)) { return FAILURE; } if (!head->canBeModified()) { return FAILURE; } if (!(flags & GameCommands::Flags::apply)) { return 0; } if (!(flags & GameCommands::Flags::ghost)) { Vehicles::playPickupSound(veh2); } head->liftUpVehicle(); // Clear ghost flag on primary vehicle pieces and all car components. train.applyToComponents([](auto& component) { component.var_38 &= ~Vehicles::Flags38::isGhost; }); head->vehicleFlags |= VehicleFlags::commandStop; return 0; } void vehiclePickup(registers& regs) { regs.ebx = vehiclePickup(regs.bl, EntityId(regs.di)); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePickup.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehiclePickupArgs { static constexpr auto command = GameCommand::vehiclePickup; VehiclePickupArgs() = default; explicit VehiclePickupArgs(const registers& regs) : head(static_cast<EntityId>(regs.di)) { } EntityId head; explicit operator registers() const { registers regs; regs.di = enumValue(head); return regs; } }; void vehiclePickup(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePickupAir.cpp ```cpp #include "VehiclePickupAir.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Vehicles/Vehicle.h" #include "World/StationManager.h" using namespace OpenLoco::Vehicles; namespace OpenLoco::GameCommands { // 0x00426B29 static uint32_t vehiclePickupAir(const VehiclePickupAirArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::AircraftRunningCosts); Vehicle train(args.head); setPosition(train.veh2->position); if (!sub_431E6A(train.head->owner)) { return FAILURE; } if (!train.head->canBeModified()) { return FAILURE; } if (!(flags & Flags::apply)) { return 0; } if (train.head->tileX != -1) { if (!(flags & Flags::ghost)) { Vehicles::playPickupSound(train.veh2); } train.applyToComponents([](auto& component) { component.tileX = -1; component.invalidateSprite(); component.moveTo({ static_cast<int16_t>(0x8000), 0, 0 }); }); if (train.head->stationId != StationId::null) { auto* station = StationManager::get(train.head->stationId); station->airportMovementOccupiedEdges &= ~(1ULL << train.head->airportMovementEdge); } } train.head->status = Vehicles::Status::unk_0; train.head->stationId = StationId::null; train.head->vehicleFlags |= VehicleFlags::commandStop; // Clear ghost flag on primary vehicle pieces and all car components. train.applyToComponents([](auto& component) { component.var_38 &= ~(Vehicles::Flags38::isGhost); }); for (auto& car : train.cars) { for (auto& component : car) { removeAllCargo(component); } } return 0; } void vehiclePickupAir(Interop::registers& regs) { const VehiclePickupAirArgs args(regs); regs.ebx = vehiclePickupAir(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePickupAir.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehiclePickupAirArgs { static constexpr auto command = GameCommand::vehiclePickupAir; VehiclePickupAirArgs() = default; explicit VehiclePickupAirArgs(const registers& regs) : head(static_cast<EntityId>(regs.di)) { } EntityId head; explicit operator registers() const { registers regs; regs.di = enumValue(head); return regs; } }; void vehiclePickupAir(Interop::registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePickupWater.cpp ```cpp #include "VehiclePickupWater.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Vehicles/Vehicle.h" using namespace OpenLoco::Vehicles; namespace OpenLoco::GameCommands { // 0x004279CC static uint32_t vehiclePickupWater(EntityId head, uint8_t flags) { setExpenditureType(ExpenditureType::ShipRunningCosts); Vehicle train(head); setPosition(train.veh2->position); if (!sub_431E6A(train.head->owner)) { return FAILURE; } if (!train.head->canBeModified()) { return FAILURE; } if (!(flags & Flags::apply)) { return 0; } if (!(flags & Flags::ghost)) { Vehicles::playPickupSound(train.veh2); } if (train.head->stationId != StationId::null) { auto tile = World::TileManager::get(train.head->getTrackLoc()); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != train.head->tileBaseZ) { continue; } if (elStation->isGhost() || elStation->isAiAllocated()) { continue; } elStation->setFlag6(false); train.head->stationId = StationId::null; } } train.applyToComponents([](auto& component) { component.tileX = -1; component.invalidateSprite(); component.moveTo({ static_cast<int16_t>(0x8000), 0, 0 }); }); train.head->status = Status::unk_0; // Clear ghost flag on primary vehicle pieces and all car components. train.applyToComponents([](auto& component) { component.var_38 &= ~(Vehicles::Flags38::isGhost); }); train.head->vehicleFlags |= VehicleFlags::commandStop; for (auto& car : train.cars) { for (auto& component : car) { removeAllCargo(component); } } return 0; } void vehiclePickupWater(Interop::registers& regs) { regs.ebx = vehiclePickupWater(EntityId(regs.di), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePickupWater.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehiclePickupWaterArgs { static constexpr auto command = GameCommand::vehiclePickupWater; VehiclePickupWaterArgs() = default; explicit VehiclePickupWaterArgs(const registers& regs) : head(static_cast<EntityId>(regs.di)) { } EntityId head; explicit operator registers() const { registers regs; regs.di = enumValue(head); return regs; } }; void vehiclePickupWater(Interop::registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePlace.cpp ```cpp #include "VehiclePlace.h" #include "Economy/Expenditures.h" #include "GameState.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "ViewportManager.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::GameCommands { static bool validateRoadPlacement(World::Pos3 pos, uint16_t trackAndDirection, const Vehicles::VehicleHead& head) { Vehicles::TrackAndDirection::_RoadAndDirection rtad(0, 0); rtad._data = trackAndDirection; if (rtad.isReversed()) { rtad.setReversed(false); auto& roadSize = World::TrackData::getUnkRoad(rtad._data); pos -= roadSize.pos; if (roadSize.rotationEnd < 12) { pos += World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } } pos.z += World::TrackData::getRoadPiece(rtad.id())[0].z; auto* elRoad = [&pos, &head, &rtad]() -> const World::RoadElement* { const auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != pos.z) { continue; } if (elRoad->isAiAllocated() || elRoad->isGhost()) { continue; } if (elRoad->roadObjectId() != head.trackType) { if (head.trackType != 0xFF) { continue; } if (!(getGameState().roadObjectIdIsNotTram & (1 << elRoad->roadObjectId()))) { continue; } } if (elRoad->roadId() != rtad.id()) { continue; } if (elRoad->rotation() != rtad.cardinalDirection()) { continue; } return elRoad; } return nullptr; }(); if (elRoad == nullptr) { if (head.trackType != 0xFFU) { auto* trackObj = ObjectManager::get<RoadObject>(head.trackType); FormatArguments::common(trackObj->name); } else { FormatArguments::common(StringIds::road); } setErrorText(StringIds::can_only_be_placed_on_stringid); return false; } if (!(getGameState().roadObjectIdIsFlag7 & (1 << elRoad->roadObjectId()))) { if (!sub_431E6A(elRoad->owner(), reinterpret_cast<const World::TileElement*>(elRoad))) { return false; } } if ((elRoad->mods() & head.var_53) != head.var_53) { const auto missingMods = (~elRoad->mods()) & head.var_53; const auto firstMissing = Numerics::bitScanForward(missingMods); auto* roadObj = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); auto* roadExtraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[firstMissing]); FormatArguments::common(roadExtraObj->name); setErrorText(StringIds::this_vehicle_requires_stringid); return false; } return true; } static bool validateTrackPlacement(World::Pos3 pos, uint16_t trackAndDirection, const Vehicles::VehicleHead& head) { Vehicles::TrackAndDirection::_TrackAndDirection ttad(0, 0); ttad._data = trackAndDirection; if (ttad.isReversed()) { ttad.setReversed(false); auto& trackSize = World::TrackData::getUnkTrack(ttad._data); pos -= trackSize.pos; if (trackSize.rotationEnd < 12) { pos += World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } } pos.z += World::TrackData::getTrackPiece(ttad.id())[0].z; auto* elTrack = [&pos, &head, &ttad]() -> const World::TrackElement* { const auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->isAiAllocated() || elTrack->isGhost()) { continue; } if (elTrack->trackObjectId() != head.trackType) { continue; } if (elTrack->trackId() != ttad.id()) { continue; } if (elTrack->rotation() != ttad.cardinalDirection()) { continue; } return elTrack; } return nullptr; }(); if (elTrack == nullptr) { auto* trackObj = ObjectManager::get<TrackObject>(head.trackType); FormatArguments::common(trackObj->name); setErrorText(StringIds::can_only_be_placed_on_stringid); return false; } if (!sub_431E6A(elTrack->owner(), reinterpret_cast<const World::TileElement*>(elTrack))) { return false; } if ((elTrack->mods() & head.var_53) != head.var_53) { const auto missingMods = (~elTrack->mods()) & head.var_53; const auto firstMissing = Numerics::bitScanForward(missingMods); auto* trackObj = ObjectManager::get<TrackObject>(elTrack->trackObjectId()); auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[firstMissing]); FormatArguments::common(trackExtraObj->name); setErrorText(StringIds::this_vehicle_requires_stringid); return false; } return true; } // 0x004B01B6 static currency32_t vehiclePlace(const VehiclePlacementArgs& args, const uint8_t flags) { if (args.head == EntityId::null) { return FAILURE; } try { Vehicles::Vehicle train(args.head); // TODO: Deduplicate constexpr std::array<ExpenditureType, 6> vehTypeToCost = { ExpenditureType::TrainRunningCosts, ExpenditureType::BusRunningCosts, ExpenditureType::TruckRunningCosts, ExpenditureType::TramRunningCosts, ExpenditureType::AircraftRunningCosts, ExpenditureType::ShipRunningCosts, }; setExpenditureType(vehTypeToCost[enumValue(train.head->vehicleType)]); setPosition(args.pos); if (!sub_431E6A(train.head->owner)) { return FAILURE; } if (!args.convertGhost) { if (train.head->tileX != -1) { setErrorText(StringIds::empty); return FAILURE; } if (train.cars.empty()) { setErrorText(StringIds::empty); return FAILURE; } } if (!(flags & Flags::apply)) { return 0; } if (args.convertGhost) { train.applyToComponents([](auto& component) { component.var_38 &= ~Vehicles::Flags38::isGhost; Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); }); } else { World::Pos3 pos = args.pos; if (train.head->mode == TransportMode::road) { if (!validateRoadPlacement(pos, args.trackAndDirection, *train.head)) { return FAILURE; } } else { if (!validateTrackPlacement(pos, args.trackAndDirection, *train.head)) { return FAILURE; } } Vehicles::TrackAndDirection tad(0, 0); tad.track._data = args.trackAndDirection; const auto res = VehicleManager::placeDownVehicle(train.head, args.pos.x, args.pos.y, args.pos.z / World::kSmallZStep, tad, args.trackProgress); if (res != VehicleManager::PlaceDownResult::Okay) { setErrorText( res == VehicleManager::PlaceDownResult::Unk0 ? StringIds::not_enough_space_or_vehicle_in_the_way : StringIds::vehicle_approaching_or_in_the_way); return FAILURE; } train.head->vehicleFlags |= VehicleFlags::commandStop; train.head->manualPower = -40; if (flags & Flags::ghost) { train.applyToComponents([](auto& component) { component.var_38 |= Vehicles::Flags38::isGhost; }); } } } catch (Exception::RuntimeError&) { return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { Vehicles::playPlacedownSound(args.pos); } return 0; } void vehiclePlace(registers& regs) { regs.ebx = vehiclePlace(VehiclePlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePlace.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehiclePlacementArgs { static constexpr auto command = GameCommand::vehiclePlace; VehiclePlacementArgs() = default; explicit VehiclePlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.dx * World::kSmallZStep) , trackAndDirection(regs.bp) , trackProgress(regs.ebx >> 16) , head(EntityId(regs.di)) , convertGhost((regs.ebx & 0xFFFF0000) == 0xFFFF0000) { } World::Pos3 pos; uint16_t trackAndDirection; uint16_t trackProgress; EntityId head; bool convertGhost = false; explicit operator registers() const { registers regs; regs.ebp = trackAndDirection; regs.di = enumValue(head); regs.ax = pos.x; regs.cx = pos.y; regs.dx = pos.z / World::kSmallZStep; regs.ebx = convertGhost ? 0xFFFF0000 : (trackProgress << 16); return regs; } }; void vehiclePlace(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePlaceAir.cpp ```cpp #include "VehiclePlaceAir.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "Localisation/StringIds.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Objects/AirportObject.h" #include "Objects/ObjectManager.h" #include "Objects/VehicleObject.h" #include "Random.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" #include "World/StationManager.h" using namespace OpenLoco::Literals; namespace OpenLoco::Vehicles { // TODO: MOVE TO SOMEWHERE ELSE // 0x0048B11D void playPlacedownSound(const World::Pos3 pos) { const auto frequency = gPrng2().randNext(20003, 24095); Audio::playSound(Audio::SoundId::vehiclePlace, pos, -600, frequency); } } namespace OpenLoco::GameCommands { // 0x004267BE static uint32_t vehiclePlaceAir(const VehicleAirPlacementArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::AircraftRunningCosts); auto* station = StationManager::get(args.stationId); if (station == nullptr) { return FAILURE; } const auto pos = station->airportStartPos; setPosition(pos); auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return FAILURE; } if (!sub_431E6A(head->owner)) { return FAILURE; } Vehicles::Vehicle train(head->id); if (!args.convertGhost) { if (head->tileX != -1) { setErrorText(StringIds::empty); return FAILURE; } if (train.cars.empty()) { setErrorText(StringIds::empty); return FAILURE; } } if (args.convertGhost) { train.applyToComponents([](auto& component) { component.var_38 &= ~Vehicles::Flags38::isGhost; Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); }); } else { auto* elStation = [pos]() -> World::StationElement* { const auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseHeight() != pos.z) { continue; } return elStation; } return nullptr; }(); if (elStation == nullptr) { return FAILURE; } if (elStation->isGhost() || elStation->isAiAllocated()) { return FAILURE; } auto* airportObj = ObjectManager::get<AirportObject>(elStation->objectId()); const auto movementEdges = airportObj->getMovementEdges(); auto previousEdgeId = 0; for (; previousEdgeId < airportObj->numMovementEdges; ++previousEdgeId) { if (movementEdges[previousEdgeId].nextNode == args.airportNode) { break; } } if (previousEdgeId == airportObj->numMovementEdges) { return FAILURE; } auto& previousMovEdge = movementEdges[previousEdgeId]; if (station->airportMovementOccupiedEdges & previousMovEdge.mustBeClearEdges) { setErrorText(StringIds::vehicle_approaching_or_in_the_way); return FAILURE; } if (station->airportMovementOccupiedEdges & airportObj->var_B6) { setErrorText(StringIds::vehicle_approaching_or_in_the_way); return FAILURE; } if (!sub_431E6A(station->owner)) { return FAILURE; } if ((airportObj->flags & train.cars.firstCar.front->getCompatibleAirportType()) == AirportObjectFlags::none) { setErrorText(StringIds::airport_type_not_suitable_for_aircraft); return FAILURE; } if (!(flags & Flags::apply)) { return 0; } const auto placePos = getAirportMovementNodeLoc(args.stationId, args.airportNode); const auto previousNodePos = getAirportMovementNodeLoc(args.stationId, previousMovEdge.curNode); if (!placePos.has_value() || !previousNodePos.has_value()) { return FAILURE; } auto yaw = Vehicles::calculateYaw1FromVector(placePos->x - previousNodePos->x, placePos->y - previousNodePos->y); auto reverseYaw = yaw ^ (1U << 5); auto* vehicleObj = ObjectManager::get<VehicleObject>(train.cars.firstCar.front->objectId); const auto pitch = vehicleObj->hasFlags(VehicleObjectFlags::aircraftIsTaildragger) ? Pitch::up12deg : Pitch::flat; head->movePlaneTo(*placePos, reverseYaw, pitch); head->status = Vehicles::Status::stopped; head->vehicleFlags |= VehicleFlags::commandStop; head->stationId = args.stationId; head->airportMovementEdge = previousEdgeId; station->airportMovementOccupiedEdges |= (1U << previousEdgeId); train.veh1->var_48 |= Vehicles::Flags48::flag2; train.veh2->currentSpeed = 0.0_mph; train.veh2->motorState = Vehicles::MotorState::stopped; if (flags & Flags::ghost) { train.applyToComponents([](auto& component) { component.var_38 |= Vehicles::Flags38::isGhost; }); } } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { Vehicles::playPlacedownSound(pos); } return 0; } void vehiclePlaceAir(registers& regs) { regs.ebx = vehiclePlaceAir(VehicleAirPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePlaceAir.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleAirPlacementArgs { static constexpr auto command = GameCommand::vehiclePlaceAir; VehicleAirPlacementArgs() = default; explicit VehicleAirPlacementArgs(const registers& regs) : stationId(StationId(regs.bp)) , airportNode(regs.dl) , head(EntityId(regs.di)) , convertGhost((regs.ebx & 0xFFFF0000) == 0xFFFF0000) { } StationId stationId; uint8_t airportNode; EntityId head; bool convertGhost = false; explicit operator registers() const { registers regs; regs.bp = enumValue(stationId); regs.di = enumValue(head); regs.dl = airportNode; regs.ebx = convertGhost ? 0xFFFF0000 : 0; return regs; } }; void vehiclePlaceAir(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePlaceWater.cpp ```cpp #include "VehiclePlaceWater.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "Localisation/StringIds.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Objects/DockObject.h" #include "Objects/ObjectManager.h" #include "Random.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" #include "World/StationManager.h" using namespace OpenLoco::Literals; namespace OpenLoco::GameCommands { // 0x0048B199 static void playWaterPlacedownSound(const World::Pos3 pos) { const auto frequency = gPrng2().randNext(20003, 24095); Audio::playSound(Audio::SoundId::constructShip, pos, -600, frequency); } // 0x004267BE static uint32_t vehiclePlaceWater(const VehicleWaterPlacementArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::ShipRunningCosts); setPosition(args.pos + World::Pos3{ 32, 32, 0 }); // Odd why 32,32 auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return FAILURE; } if (!sub_431E6A(head->owner)) { return FAILURE; } Vehicles::Vehicle train(head->id); if (!args.convertGhost) { if (head->tileX != -1) { setErrorText(StringIds::empty); return FAILURE; } if (train.cars.empty()) { setErrorText(StringIds::empty); return FAILURE; } } if (args.convertGhost) { train.applyToComponents([](auto& component) { component.var_38 &= ~Vehicles::Flags38::isGhost; Ui::ViewportManager::invalidate(&component, ZoomLevel::eighth); }); } else { auto* elStation = [pos = args.pos]() -> World::StationElement* { const auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseHeight() != pos.z) { continue; } return elStation; } return nullptr; }(); if (elStation == nullptr) { return FAILURE; } if (elStation->isGhost() || elStation->isAiAllocated()) { return FAILURE; } auto* station = StationManager::get(elStation->stationId()); if (!sub_431E6A(station->owner)) { return FAILURE; } if (elStation->isFlag6()) { setErrorText(StringIds::vehicle_approaching_or_in_the_way); return FAILURE; } auto* dockObj = ObjectManager::get<DockObject>(elStation->objectId()); const auto boatPos = World::Pos3(Math::Vector::rotate(dockObj->boatPosition, elStation->rotation()), 0) + args.pos + World::Pos3(32, 32, 0); const auto waterHeight = World::TileManager::getHeight(boatPos).waterHeight; if (waterHeight == 0) { setErrorText(StringIds::noWater); return FAILURE; } if (!(flags & Flags::apply)) { return 0; } auto yaw = ((elStation->rotation() + 1) & 0x3) * 16; head->moveBoatTo(boatPos, yaw, Pitch::flat); head->moveTo(boatPos + World::Pos3(0, 0, 32)); head->status = Vehicles::Status::stopped; head->vehicleFlags |= VehicleFlags::commandStop; head->stationId = elStation->stationId(); head->tileX = args.pos.x; head->tileY = args.pos.y; head->tileBaseZ = args.pos.z / World::kSmallZStep; elStation->setFlag6(true); train.veh1->var_48 |= Vehicles::Flags48::flag2; if (flags & Flags::ghost) { train.applyToComponents([](auto& component) { component.var_38 |= Vehicles::Flags38::isGhost; }); } } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { playWaterPlacedownSound(getPosition()); } return 0; } void vehiclePlaceWater(registers& regs) { regs.ebx = vehiclePlaceWater(VehicleWaterPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehiclePlaceWater.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleWaterPlacementArgs { static constexpr auto command = GameCommand::vehiclePlaceWater; VehicleWaterPlacementArgs() = default; explicit VehicleWaterPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.dx) , head(EntityId(regs.di)) , convertGhost((regs.ebx & 0xFFFF0000) == 0xFFFF0000) { } World::Pos3 pos; EntityId head; bool convertGhost = false; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.dx = pos.z; regs.di = enumValue(head); regs.ebx = convertGhost ? 0xFFFF0000 : 0; return regs; } }; void vehiclePlaceWater(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleRearrange.cpp ```cpp #include "VehicleRearrange.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "VehiclePickupAir.h" #include "VehiclePickupWater.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" namespace OpenLoco::GameCommands { struct PlacementBackup { int16_t tileX; int16_t tileY; World::SmallZ tileBaseZ; Vehicles::TrackAndDirection trackAndDirection; uint16_t subPosition; EntityId head; }; // 0x004AF1DF static currency32_t vehicleRearrange(const VehicleRearrangeArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); auto* sourceVehicle = EntityManager::get<Vehicles::VehicleBase>(args.source); auto* destVehicle = EntityManager::get<Vehicles::VehicleBase>(args.dest); auto* sourceHead = EntityManager::get<Vehicles::VehicleHead>(sourceVehicle->getHead()); auto* destHead = EntityManager::get<Vehicles::VehicleHead>(destVehicle->getHead()); if (!(flags & Flags::apply)) { if (!sub_431E6A(sourceVehicle->owner)) { return FAILURE; } if (!sub_431E6A(destVehicle->owner)) { return FAILURE; } if (!sourceHead->canBeModified()) { return FAILURE; } if (!destHead->canBeModified()) { return FAILURE; } if (sourceVehicle->getTrackType() != destVehicle->getTrackType()) { setErrorText(StringIds::incompatible_vehicle); return FAILURE; } // Pretty sure this needs to be true but not 100% (openloco addition) auto* sourceBogie = sourceVehicle->asVehicleBogie(); if (sourceBogie == nullptr) { return FAILURE; } if (!destHead->isVehicleTypeCompatible(sourceBogie->objectId)) { return FAILURE; } setPosition(destVehicle->position); return 0; } else { auto* sourceBogie = sourceVehicle->asVehicleBogie(); if (sourceBogie == nullptr) { return FAILURE; } Vehicles::Vehicle sourceTrain(*sourceHead); Vehicles::Vehicle destTrain(*destHead); if (sourceHead != destHead) { [&train = sourceTrain, &targetBogie = *sourceBogie]() { for (auto& car : train.cars) { for (auto& carComponet : car) { if (carComponet.front == &targetBogie) { Vehicles::removeAllCargo(carComponet); return; } } } }(); } auto tryPickupTrain = [](Vehicles::Vehicle& train) -> std::optional<PlacementBackup> { if (train.head->tileX == -1) { return std::nullopt; } const auto res = PlacementBackup{ train.head->tileX, train.head->tileY, train.head->tileBaseZ, train.head->trackAndDirection, train.head->subPosition, train.head->head }; switch (train.head->mode) { case TransportMode::rail: case TransportMode::road: train.head->liftUpVehicle(); break; case TransportMode::air: { // Calling this GC directly as we need the result immediately // perhaps in the future this could be changed. GameCommands::VehiclePickupAirArgs airArgs{}; airArgs.head = train.head->id; registers regs = static_cast<registers>(airArgs); regs.bl = GameCommands::Flags::apply; GameCommands::vehiclePickupAir(regs); break; } case TransportMode::water: { // Calling this GC directly as we need the result immediately // perhaps in the future this could be changed. GameCommands::VehiclePickupWaterArgs waterArgs{}; waterArgs.head = train.head->id; registers regs = static_cast<registers>(waterArgs); regs.bl = GameCommands::Flags::apply; GameCommands::vehiclePickupWater(regs); } } setExpenditureType(ExpenditureType::TrainRunningCosts); return res; }; std::optional<PlacementBackup> sourcePlacement = tryPickupTrain(sourceTrain); std::optional<PlacementBackup> destPlacement = tryPickupTrain(destTrain); insertCarBefore(*sourceBogie, *destVehicle); // Vehicle has been invalidate so get it again sourceTrain = Vehicles::Vehicle(*sourceHead); destHead->autoLayoutTrain(); destHead->updateTrainProperties(); if (sourceHead != destHead) { sourceHead->autoLayoutTrain(); sourceHead->updateTrainProperties(); } if (sourcePlacement.has_value() && !sourceTrain.cars.empty()) { VehicleManager::placeDownVehicle(sourceHead, sourcePlacement->tileX, sourcePlacement->tileY, sourcePlacement->tileBaseZ, sourcePlacement->trackAndDirection, sourcePlacement->subPosition); } if (destPlacement.has_value()) { VehicleManager::placeDownVehicle(destHead, destPlacement->tileX, destPlacement->tileY, destPlacement->tileBaseZ, destPlacement->trackAndDirection, destPlacement->subPosition); } return 0; } } void vehicleRearrange(registers& regs) { regs.ebx = vehicleRearrange(VehicleRearrangeArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleRearrange.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleRearrangeArgs { static constexpr auto command = GameCommand::vehicleRearrange; VehicleRearrangeArgs() = default; explicit VehicleRearrangeArgs(const Interop::registers& regs) : source(static_cast<EntityId>(regs.dx)) , dest(static_cast<EntityId>(regs.di)) { } EntityId source; EntityId dest; explicit operator Interop::registers() const { Interop::registers regs; regs.di = enumValue(dest); regs.dx = enumValue(source); return regs; } }; void vehicleRearrange(Interop::registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleRefit.cpp ```cpp #include "VehicleRefit.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Objects/CargoObject.h" #include "Objects/ObjectManager.h" #include "Objects/VehicleObject.h" #include "Types.hpp" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Core/Numerics.hpp> #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0042F6DB static uint32_t vehicleRefit(const VehicleRefitArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); try { Vehicles::Vehicle train(args.head); auto& head = train.head; if (!head->canBeModified()) { return FAILURE; } if (!sub_431E6A(head->owner)) { return FAILURE; } if (train.cars.empty()) { setErrorText(StringIds::empty); return 0; } auto car = train.cars.firstCar; auto* vehObj = ObjectManager::get<VehicleObject>(car.body->objectId); if (!vehObj->hasFlags(VehicleObjectFlags::refittable)) { setErrorText(StringIds::empty); return 0; } if (!(flags & Flags::apply)) { return 0; } uint16_t maxPrimaryCargo = vehObj->maxCargo[0]; auto cargoTypes = vehObj->compatibleCargoCategories[0]; auto primaryCargoId = Numerics::bitScanForward(cargoTypes); uint16_t maxCargoUnits = Vehicles::getNumUnitsForCargo(maxPrimaryCargo, primaryCargoId, args.cargoType); car.body->primaryCargo.type = args.cargoType; car.body->primaryCargo.maxQty = std::min<uint8_t>(maxCargoUnits, 0xFF); car.body->primaryCargo.qty = 0; auto primaryCargoObj = ObjectManager::get<CargoObject>(args.cargoType); auto acceptedTypes = 0; for (uint16_t cargoId = 0; cargoId < ObjectManager::getMaxObjects(ObjectType::cargo); cargoId++) { auto cargoObject = ObjectManager::get<CargoObject>(cargoId); if (cargoObject == nullptr) { continue; } if (cargoObject->cargoCategory == primaryCargoObj->cargoCategory) { acceptedTypes |= 1 << cargoId; } } car.body->primaryCargo.acceptedTypes = acceptedTypes; head->updateTrainProperties(); Ui::WindowManager::invalidate(Ui::WindowType::vehicle, static_cast<Ui::WindowNumber_t>(head->id)); return 0; } catch (std::runtime_error&) { return FAILURE; } } void vehicleRefit(registers& regs) { regs.ebx = vehicleRefit(VehicleRefitArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleRefit.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleRefitArgs { static constexpr auto command = GameCommand::vehicleRefit; VehicleRefitArgs() = default; explicit VehicleRefitArgs(const registers& regs) : head(static_cast<EntityId>(regs.di)) , cargoType(regs.dl) { } EntityId head; uint8_t cargoType; explicit operator registers() const { registers regs; regs.di = enumValue(head); regs.dl = cargoType; return regs; } }; void vehicleRefit(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleRepaint.cpp ```cpp #include "VehicleRepaint.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Types.hpp" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { static void paintComponent(Vehicles::CarComponent& component, const VehicleRepaintArgs& args) { if (args.hasRepaintFlags(VehicleRepaintFlags::bodyColour) && component.body != nullptr) { component.body->colourScheme = args.colours[kBodyColour]; component.body->invalidateSprite(); } if (args.hasRepaintFlags(VehicleRepaintFlags::frontBogieColour) && component.front != nullptr) { component.front->colourScheme = args.colours[kFrontBogieColour]; component.front->invalidateSprite(); } if (args.hasRepaintFlags(VehicleRepaintFlags::backBogieColour) && component.back != nullptr) { component.back->colourScheme = args.colours[kBackBogieColour]; component.back->invalidateSprite(); } } static void paintEntireCar(Vehicles::Car& car, const VehicleRepaintArgs& args) { for (Vehicles::CarComponent& component : car) { paintComponent(component, args); } } static uint32_t vehicleRepaint(const VehicleRepaintArgs& args, const uint8_t flags) { auto entity = EntityManager::get<EntityBase>(args.head); auto veh = entity->asBase<Vehicles::VehicleBase>(); if (veh == nullptr) { return FAILURE; } if (!sub_431E6A(veh->owner)) { return FAILURE; } if (!(flags & Flags::apply)) { return 0; } Vehicles::Vehicle train(veh->getHead()); for (auto& car : train.cars) { if (args.hasRepaintFlags(VehicleRepaintFlags::applyToEntireTrain)) { paintEntireCar(car, args); continue; } for (auto& carComponent : car) { if (carComponent.front == veh || carComponent.back == veh || carComponent.body == veh) { if (args.hasRepaintFlags(VehicleRepaintFlags::applyToEntireCar)) { paintEntireCar(car, args); } else { paintComponent(carComponent, args); } return 0; } } } return 0; } void vehicleRepaint(registers& regs) { regs.ebx = vehicleRepaint(VehicleRepaintArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleRepaint.h ```h #pragma once #include "GameCommands/GameCommands.h" #include <OpenLoco/Core/EnumFlags.hpp> namespace OpenLoco::GameCommands { using QuadraColour = std::array<ColourScheme, 4>; constexpr uint8_t kBodyColour = 0; constexpr uint8_t kFrontBogieColour = 1; constexpr uint8_t kBackBogieColour = 2; enum class VehicleRepaintFlags : uint8_t { none = 0, bodyColour = (1U << 0), frontBogieColour = (1U << 1), backBogieColour = (1U << 2), applyToEntireCar = (1U << 3), applyToEntireTrain = (1U << 4), paintFromVehicleUi = bodyColour | frontBogieColour | backBogieColour | applyToEntireCar, }; OPENLOCO_ENABLE_ENUM_OPERATORS(VehicleRepaintFlags); struct VehicleRepaintArgs { static constexpr auto command = GameCommand::vehicleRepaint; VehicleRepaintArgs() = default; explicit VehicleRepaintArgs(const registers& regs) : head(EntityId(regs.ebp)) , colours{ ColourScheme(regs.cx), ColourScheme(regs.ecx >> 16), ColourScheme(regs.dx), ColourScheme(regs.edx >> 16) } , paintFlags(VehicleRepaintFlags(regs.ax)) { } bool hasRepaintFlags(VehicleRepaintFlags flags) const { return (paintFlags & flags) != VehicleRepaintFlags::none; } void setColours(ColourScheme colour) { if (hasRepaintFlags(VehicleRepaintFlags::bodyColour)) { colours[kBodyColour] = colour; } if (hasRepaintFlags(VehicleRepaintFlags::frontBogieColour)) { colours[kFrontBogieColour] = colour; } if (hasRepaintFlags(VehicleRepaintFlags::backBogieColour)) { colours[kBackBogieColour] = colour; } } EntityId head; QuadraColour colours; VehicleRepaintFlags paintFlags; constexpr uint16_t convert(ColourScheme colour) const { return enumValue(colour.primary) | (enumValue(colour.secondary) << 8); } explicit operator registers() const { registers regs; regs.ebp = enumValue(head); regs.ecx = convert(colours[0]) | (convert(colours[1]) << 16); regs.edx = convert(colours[2]) | (convert(colours[3]) << 16); regs.ax = enumValue(paintFlags); return regs; } }; void vehicleRepaint(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleReverse.cpp ```cpp #include "VehicleReverse.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Types.hpp" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x004ADAA8 static uint32_t vehicleReverse(EntityId headId, const uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); auto* head = EntityManager::get<Vehicles::VehicleHead>(headId); if (head == nullptr) { return FAILURE; } if (!sub_431E6A(head->owner)) { return FAILURE; } if (!head->canBeModified()) { return FAILURE; } if (head->tileX == -1) { setErrorText(StringIds::empty); return FAILURE; } if (!(flags & Flags::apply)) { return 0; } uint8_t var_52_backup = head->var_52; head->var_52 = 1; head->sub_4ADB47(0); head->var_52 = var_52_backup; setPosition(head->position); return 0; } void vehicleReverse(registers& regs) { VehicleReverseArgs args(regs); regs.ebx = vehicleReverse(args.head, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleReverse.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleReverseArgs { static constexpr auto command = GameCommand::vehicleReverse; VehicleReverseArgs() = default; explicit VehicleReverseArgs(const registers& regs) : head(static_cast<EntityId>(regs.dx)) { } EntityId head; explicit operator registers() const { registers regs; regs.dx = enumValue(head); return regs; } }; void vehicleReverse(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleSell.cpp ```cpp #include "VehicleSell.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "VehiclePickupAir.h" #include "VehiclePickupWater.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" using namespace OpenLoco::Vehicles; namespace OpenLoco::GameCommands { static currency32_t sellVehicle(EntityId id, uint8_t flags) { setExpenditureType(ExpenditureType::VehicleDisposals); currency32_t refundCost = 0; auto* vehBase = EntityManager::get<VehicleBase>(id); if (vehBase == nullptr) { return FAILURE; } auto* head = EntityManager::get<VehicleHead>(vehBase->getHead()); if (head == nullptr) { return FAILURE; } Vehicle train(*head); if (head == vehBase) { for (const auto& car : train.cars) { refundCost += car.front->refundCost; } } else { auto* bogie = vehBase->asVehicleBogie(); if (bogie == nullptr) { return FAILURE; } refundCost = bogie->refundCost; } if (flags & Flags::apply) { if (head == vehBase) { VehicleManager::deleteTrain(*head); } else { struct PlaceDown { EntityId head; World::Pos3 pos; TrackAndDirection tad; uint16_t subPosition; }; std::optional<PlaceDown> placeArgs; if (head->tileX != -1) { PlaceDown args{ head->id, head->getTrackLoc(), head->trackAndDirection, head->subPosition }; placeArgs = args; switch (head->mode) { case TransportMode::road: case TransportMode::rail: head->liftUpVehicle(); break; case TransportMode::air: { GameCommands::VehiclePickupAirArgs airArgs{}; airArgs.head = head->id; GameCommands::doCommand(airArgs, Flags::apply); break; } case TransportMode::water: { GameCommands::VehiclePickupWaterArgs waterArgs{}; waterArgs.head = head->id; GameCommands::doCommand(waterArgs, Flags::apply); } } } Vehicles::Car car(vehBase); VehicleManager::deleteCar(car); head->autoLayoutTrain(); head->updateTrainProperties(); head->applyBreakdownToTrain(); if (placeArgs.has_value()) { train = Vehicle(*head); if (train.cars.empty()) { train.tail->trainDanglingTimeout = 0; } else { VehicleManager::placeDownVehicle(head, placeArgs->pos.x, placeArgs->pos.y, placeArgs->pos.z / World::kSmallZStep, placeArgs->tad, placeArgs->subPosition); } } } } else { if (!sub_431E6A(vehBase->owner)) { return FAILURE; } if (!head->canBeModified()) { // Error message set by canBeModified return FAILURE; } setPosition(head->position); } return -refundCost; } // 0x004AED34 void sellVehicle(Interop::registers& regs) { regs.ebx = sellVehicle(EntityId(regs.dx), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleSell.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleSellArgs { static constexpr auto command = GameCommand::vehicleSell; VehicleSellArgs() = default; explicit VehicleSellArgs(const registers& regs) : car(static_cast<EntityId>(regs.dx)) { } EntityId car; explicit operator registers() const { registers regs; regs.dx = enumValue(car); return regs; } }; void sellVehicle(Interop::registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleSpeedControl.cpp ```cpp #include "VehicleSpeedControl.h" #include "Economy/Expenditures.h" #include "Entities/EntityManager.h" #include "GameCommands/GameCommands.h" #include "Types.hpp" #include "Ui/WindowManager.h" #include "VehicleSell.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x004BAB63 static uint32_t vehicleSpeedControl(const VehicleSpeedControlArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::TrainRunningCosts); if (!(flags & Flags::apply)) { return 0; } auto* head = EntityManager::get<Vehicles::VehicleHead>(args.head); if (head == nullptr) { return FAILURE; } head->manualPower = args.speed; if (head->hasVehicleFlags(VehicleFlags::commandStop)) { if (head->status == Vehicles::Status::stuck || head->status == Vehicles::Status::crashed) { // The game would initially call vehicleChangeRunningMode directly, // which would in turn sell the vehicle. Our implementation changes this // to sell a crashed vehicle directly. GameCommands::VehicleSellArgs sargs{}; sargs.car = args.head; GameCommands::doCommand(sargs, GameCommands::Flags::apply); } } Ui::WindowManager::invalidate(Ui::WindowType::vehicle, static_cast<Ui::WindowNumber_t>(args.head)); return 0; } void vehicleSpeedControl(registers& regs) { regs.ebx = vehicleSpeedControl(VehicleSpeedControlArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Vehicles/VehicleSpeedControl.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct VehicleSpeedControlArgs { static constexpr auto command = GameCommand::vehicleSpeedControl; VehicleSpeedControlArgs() = default; explicit VehicleSpeedControlArgs(const registers& regs) : head(static_cast<EntityId>(regs.cx)) , speed(regs.dx) { } EntityId head; int16_t speed; explicit operator registers() const { registers regs; regs.cx = enumValue(head); regs.dx = speed; return regs; } }; void vehicleSpeedControl(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Airports/CreateAirport.cpp ```cpp #include "CreateAirport.h" #include "Economy/Economy.h" #include "Localisation/StringIds.h" #include "Map/AnimationManager.h" #include "Map/BuildingElement.h" #include "Map/QuarterTile.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Objects/AirportObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/StationManager.h" #include "World/TownManager.h" namespace OpenLoco::GameCommands { static loco_global<StationId, 0x0112C744> _lastPlacedAirportStationId; static loco_global<uint32_t, 0x00112C734> _lastConstructedAdjoiningStationId; // Can be 0xFFFF'FFFFU for no adjoining station static loco_global<World::Pos2, 0x00112C792> _lastConstructedAdjoiningStationCentrePos; // Can be x = -1 for no adjoining station // 0x00490372 static StationManager::NearbyStation findNearbyStationAirport(World::Pos3 pos, uint8_t airportObjectId, uint8_t rotation) { // This function is very similar to StationManager::findNearbyStation differences are marked const auto companyId = getUpdatingCompanyId(); // Change from StationManager::findNearbyStation auto* airportObj = ObjectManager::get<AirportObject>(airportObjectId); const auto [minExtent, maxExtent] = airportObj->getAirportExtents(World::toTileSpace(pos), rotation); // Check area including a 2 tile border around the airport const auto tilePosA = minExtent - World::TilePos2(2, 2); const auto tilePosB = maxExtent + World::TilePos2(2, 2); auto minDistanceStation = StationId::null; auto minDistance = std::numeric_limits<int16_t>::max(); bool isPhysicallyAttached = false; for (const auto& tilePos : World::getClampedRange(tilePosA, tilePosB)) { const auto tile = World::TileManager::get(tilePos); for (const auto& el : tile) { auto* elStation = el.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->isGhost()) { continue; } auto* station = StationManager::get(elStation->stationId()); if (station->owner != companyId) { continue; } const auto distance = Math::Vector::chebyshevDistance2D(World::toWorldSpace(tilePos), pos); if (distance < minDistance) { auto distDiffZ = std::abs(elStation->baseHeight() - pos.z); if (distDiffZ > StationManager::kMaxStationNearbyDistance) { continue; } // Change from StationManager::findNearbyStation if ((station->flags & StationFlags::flag_6) != StationFlags::none) { continue; } minDistance = distance + distDiffZ / 2; if (minDistance <= StationManager::kMaxStationNearbyDistance) { isPhysicallyAttached = true; } minDistanceStation = elStation->stationId(); } } } const auto nearbyEmptyStation = StationManager::findNearbyEmptyStation(pos, companyId, minDistance); if (nearbyEmptyStation != StationId::null) { return StationManager::NearbyStation{ nearbyEmptyStation, isPhysicallyAttached }; } else { return StationManager::NearbyStation{ minDistanceStation, isPhysicallyAttached }; } } enum class NearbyStationValidation { okay, requiresNewStation, failure, }; // 0x00492E48 & 0x00492DBA static std::pair<NearbyStationValidation, StationId> validateNearbyStation(const World::Pos3 pos, const uint8_t airportObjectId, const uint8_t rotation, const uint8_t flags) { auto nearbyStation = findNearbyStationAirport(pos, airportObjectId, rotation); if (nearbyStation.id == StationId::null) { return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } // _lastPlacedTrackStationId = nearbyStation.id; set in callers auto* station = StationManager::get(nearbyStation.id); if (station->stationTileSize >= std::size(station->stationTiles)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_large); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } else { if (!(flags & Flags::aiAllocated)) { if (StationManager::exceedsStationSize(*station, pos)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_spread_out); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } } } return std::make_pair(NearbyStationValidation::okay, nearbyStation.id); } // 0x004930E1 static uint32_t createBuilding(const World::TilePos2 pos, const int16_t baseHeight, const uint8_t rotation, const uint8_t variation, const uint8_t airportObjectId, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags) { auto* airportObj = ObjectManager::get<AirportObject>(airportObjectId); // This is identical to createIndustry, createDock but with an airportObject // TODO: look into making some sort of common version auto clearHeight = 0; const auto heights = airportObj->getBuildingPartHeights(); for (auto part : airportObj->getBuildingParts(variation)) { clearHeight += heights[part]; } // ceil to 4 clearHeight += 3; clearHeight &= ~3; // Unsure why? clearHeight = std::max(clearHeight, 128); const auto is2x2 = airportObj->largeTiles & (1U << variation); currency32_t totalCost = 0; const auto buildingFootprint = getBuildingTileOffsets(is2x2); for (auto& offset : buildingFootprint) { const auto tilePos = pos + World::toTileSpace(offset.pos); if (!World::validCoords(tilePos)) { setErrorText(StringIds::off_edge_of_map); return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost) && !(flags & Flags::aiAllocated)) { World::TileManager::removeAllWallsOnTileBelow(tilePos, (baseHeight + clearHeight) / World::kSmallZStep); } // 0x004933B2 same as TileClearance::tileClearFunction but collides on surfaces as well // identical to createPort version auto clearFunc = [pos = World::toWorldSpace(tilePos), &removedBuildings, flags, &totalCost](World::TileElement& el) { switch (el.type()) { case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearTreeCollision(*elTree, pos, flags, totalCost); } case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearBuildingCollision(*elBuilding, pos, removedBuildings, flags, totalCost); } default: return World::TileClearance::ClearFuncResult::collision; } }; // This is similar but not the same as createIndustry/createBuilding { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); const auto argBaseZ = baseHeight / World::kSmallZStep; const auto argClearZ = (baseHeight + clearHeight) / World::kSmallZStep; const auto minBaseZ = std::min<World::SmallZ>(surface->baseZ(), argBaseZ); const auto maxBaseZ = std::max<World::SmallZ>(surface->baseZ(), argBaseZ); const auto baseZ = std::min<World::SmallZ>(minBaseZ, argClearZ); const auto clearZ = std::max<World::SmallZ>(maxBaseZ, argClearZ); World::QuarterTile qt(0xF, 0xF); if (!World::TileClearance::applyClearAtStandardHeight(World::toWorldSpace(tilePos), baseZ, clearZ, qt, clearFunc)) { return FAILURE; } } auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); auto baseZDiff = std::abs((baseHeight / World::kSmallZStep) - surface->baseZ()); if (surface->slope()) { baseZDiff++; } auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); totalCost += Economy::getInflationAdjustedCost(landObj->costFactor, landObj->costIndex, 10) * baseZDiff; // Flatten surfaces if (!(flags & Flags::ghost) && (flags & Flags::apply)) { if (surface->slope() || baseHeight != surface->baseHeight()) { if (flags & Flags::aiAllocated) { surface->setAiAllocated(true); } else { surface->setBaseZ(baseHeight / World::kSmallZStep); surface->setClearZ(baseHeight / World::kSmallZStep); surface->setSlope(0); surface->setSnowCoverage(0); surface->setGrowthStage(0); } if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); } } } // Create new tile if (flags & Flags::apply) { if (!(flags & Flags::ghost) && !(flags & Flags::aiAllocated)) { World::TileManager::removeSurfaceIndustry(World::toWorldSpace(tilePos)); World::TileManager::setTerrainStyleAsCleared(World::toWorldSpace(tilePos)); } auto* elStation = World::TileManager::insertElement<World::StationElement>(World::toWorldSpace(tilePos), baseHeight / World::kSmallZStep, 0xF); if (elStation == nullptr) { return FAILURE; } elStation->setClearZ((clearHeight / World::kSmallZStep) + elStation->baseZ()); elStation->setRotation(rotation); elStation->setObjectId(airportObjectId); elStation->setStationType(StationType::airport); elStation->setOwner(getUpdatingCompanyId()); elStation->setUnk4SLR4(0); elStation->setBuildingType(variation); if (!(flags & Flags::ghost)) { elStation->setStationId(_lastPlacedAirportStationId); } else { elStation->setStationId(static_cast<StationId>(0)); } elStation->setGhost(flags & Flags::ghost); elStation->setSequenceIndex(offset.index); World::AnimationManager::createAnimation(7, World::toWorldSpace(tilePos), elStation->baseZ()); elStation->setAiAllocated(flags & Flags::aiAllocated); if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); } Scenario::getOptions().madeAnyChanges = 1; } } return totalCost; } // 0x00492C41 static currency32_t createAirport(const AirportPlacementArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); _lastPlacedAirportStationId = StationId::null; if ((flags & Flags::apply) && !(flags & Flags::aiAllocated)) { companySetObservation(getUpdatingCompanyId(), ObservationStatus::buildingAirport, World::Pos2(args.pos) + World::Pos2{ 16, 16 }, EntityId::null, args.type); } _lastConstructedAdjoiningStationCentrePos = World::Pos2(-1, -1); _lastConstructedAdjoiningStationId = 0xFFFFFFFFU; if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } const auto closestTown = TownManager::getClosestTownAndDensity(args.pos); if (!closestTown.has_value()) { return FAILURE; } auto* town = TownManager::get(closestTown->first); if (town->numberOfAirports >= 4) { setErrorText(StringIds::town_will_not_allow_airport_to_be_built_here); return FAILURE; } if (!CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { if (town->numberOfAirports >= 2) { setErrorText(StringIds::town_will_not_allow_airport_to_be_built_here); return FAILURE; } } if ((flags & Flags::apply) && !(flags & Flags::aiAllocated) && !(flags & Flags::ghost)) { town->numberOfAirports++; } if ((flags & Flags::ghost) && (flags & Flags::apply)) { _lastConstructedAdjoiningStationCentrePos = args.pos; auto nearbyStation = findNearbyStationAirport(args.pos, args.type, args.rotation); _lastConstructedAdjoiningStationId = static_cast<int16_t>(nearbyStation.id); } auto* airportObj = ObjectManager::get<AirportObject>(args.type); if (!(flags & Flags::ghost)) { const auto nameMode = airportObj->hasFlags(AirportObjectFlags::isHelipad) ? 2 : 1; if (flags & Flags::apply) { auto [result, nearbyStationId] = validateNearbyStation(args.pos, args.type, args.rotation, flags); switch (result) { case NearbyStationValidation::failure: // Odd??? break; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(args.pos, getUpdatingCompanyId(), nameMode); if (newStationId != StationId::null) { _lastPlacedAirportStationId = newStationId; auto* station = StationManager::get(newStationId); station->updateLabel(); } } break; case NearbyStationValidation::okay: _lastPlacedAirportStationId = nearbyStationId; break; } } else { // Same as the other branch but deallocate after allocating and return failure on failure auto [result, nearbyStationId] = validateNearbyStation(args.pos, args.type, args.rotation, flags); switch (result) { case NearbyStationValidation::failure: return FAILURE; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(args.pos, getUpdatingCompanyId(), nameMode); if (newStationId == StationId::null) { return FAILURE; } StationManager::deallocateStation(newStationId); // _lastPlacedAirportStationId not set but that's fine since this is the no apply side } break; case NearbyStationValidation::okay: _lastPlacedAirportStationId = nearbyStationId; break; } } } currency32_t totalCost = Economy::getInflationAdjustedCost(airportObj->buildCostFactor, airportObj->costIndex, 6); World::TileClearance::RemovedBuildings removedBuildings{}; for (auto& buildingPosition : airportObj->getBuildingPositions()) { auto buildingTilePos = Math::Vector::rotate(World::TilePos2(buildingPosition.x, buildingPosition.y), args.rotation) + World::toTileSpace(args.pos); const bool is2x2 = airportObj->largeTiles & (1U << buildingPosition.index); if (is2x2) { buildingTilePos -= World::toTileSpace(getBuildingTileOffsets(true)[args.rotation].pos); } const auto buildingRotation = (args.rotation + buildingPosition.rotation) & 0x3; const auto cost = createBuilding(buildingTilePos, args.pos.z, buildingRotation, buildingPosition.index, args.type, removedBuildings, flags); if (cost != FAILURE) { totalCost += cost; } else { return FAILURE; } } if (!(flags & Flags::ghost) && (flags & Flags::apply)) { addTileToStation(_lastPlacedAirportStationId, args.pos, args.rotation); auto* station = StationManager::get(_lastPlacedAirportStationId); station->flags |= StationFlags::flag_6; station->airportStartPos = args.pos; station->airportRotation = args.rotation; station->airportMovementOccupiedEdges = 0; station->invalidate(); recalculateStationModes(_lastPlacedAirportStationId); recalculateStationCenter(_lastPlacedAirportStationId); station->updateLabel(); station->invalidate(); sub_48D794(*station); } if (!(flags & (Flags::ghost | Flags::aiAllocated)) && (flags & Flags::apply)) { playConstructionPlacementSound(args.pos); } if ((flags & Flags::apply) && CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { companyEmotionEvent(getUpdatingCompanyId(), Emotion::thinking); } return totalCost; } void createAirport(registers& regs) { regs.ebx = createAirport(AirportPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Airports/CreateAirport.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct AirportPlacementArgs { static constexpr auto command = GameCommand::createAirport; AirportPlacementArgs() = default; explicit AirportPlacementArgs(const registers regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh) , type(regs.dl) { } World::Pos3 pos; uint8_t rotation; uint8_t type; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = type; return regs; } }; void createAirport(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Airports/RemoveAirport.cpp ```cpp #include "RemoveAirport.h" #include "Economy/Economy.h" #include "Localisation/StringIds.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Objects/AirportObject.h" #include "Objects/ObjectManager.h" #include "Vehicles/Vehicle.h" #include "Vehicles/VehicleManager.h" #include "ViewportManager.h" #include "World/Industry.h" #include "World/Station.h" #include "World/StationManager.h" #include "World/TownManager.h" namespace OpenLoco::GameCommands { constexpr std::array<World::Pos2, 4> kLargeTileOffsets = { { { 0, 0 }, { 0, -32 }, { -32, -32 }, { -32, 0 }, } }; static World::StationElement* getStationEl(const World::Pos3& pos) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* stationEl = el.as<World::StationElement>(); if (stationEl == nullptr) { continue; } if (stationEl->baseHeight() == pos.z) { return stationEl; } } return nullptr; } // 0x004938D9 static bool removeAirportTileElement(const World::Pos3& pos, const AirportObject* airportObj, const uint8_t buildingIndex, const uint8_t flags) { for (auto& searchTile : getBuildingTileOffsets(airportObj->largeTiles & (1U << buildingIndex))) { const auto airportPos = World::Pos3(searchTile.pos + pos, pos.z); if ((flags & Flags::aiAllocated) != 0 && (flags & Flags::apply) != 0) { auto tile = World::TileManager::get(airportPos); auto* surfaceEl = tile.surface(); if (surfaceEl != nullptr) { surfaceEl->setAiAllocated(false); } } if ((flags & Flags::apply) == 0) { continue; } auto* stationEl = getStationEl(airportPos); if (stationEl == nullptr) { return false; } if ((flags & (Flags::aiAllocated)) == 0) { Ui::ViewportManager::invalidate(World::Pos2(airportPos), stationEl->baseHeight(), stationEl->clearHeight(), ZoomLevel::eighth); } World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(stationEl)); } return true; } // 0x00493519 static bool isAirportInUseByVehicle(const StationId stationId) { auto vehicleList = VehicleManager::VehicleList(); for (auto* vehicle : vehicleList) { if (vehicle->vehicleType != VehicleType::aircraft) { continue; } if (vehicle->tileX == -1) { continue; } if (vehicle->stationId == stationId) { GameCommands::setErrorText(StringIds::currently_in_use_by_at_least_one_vehicle); return true; } } return false; } // 0x0049372F static currency32_t loc_49372F(const StationId stationId, const World::StationElement& stationEl, const World::Pos3 pos, const uint8_t flags) { const auto rotation = stationEl.rotation(); const auto objectId = stationEl.objectId(); if (stationId != StationId::null) { if (isAirportInUseByVehicle(stationId)) { return FAILURE; } } const auto* airportObj = ObjectManager::get<AirportObject>(objectId); // Calculate base removal cost currency32_t totalCost = Economy::getInflationAdjustedCost(airportObj->sellCostFactor, airportObj->costIndex, 6); // Adjust number of airports for nearest town auto maybeTown = TownManager::getClosestTownAndDensity(pos); if (maybeTown && (flags & Flags::apply) != 0) { if ((flags & (Flags::aiAllocated | Flags::ghost)) == 0) { auto* town = TownManager::get(maybeTown->first); town->numberOfAirports--; } } for (auto& building : airportObj->getBuildingPositions()) { // 0x004937FA auto offset = World::TilePos2(building.x, building.y); offset = Math::Vector::rotate(offset, rotation); auto worldPos = World::Pos3(World::toWorldSpace(offset), 0); if ((airportObj->largeTiles & (1 << building.index)) != 0) { worldPos.x += kLargeTileOffsets[rotation].x; worldPos.y += kLargeTileOffsets[rotation].y; } worldPos += pos; if (!removeAirportTileElement(worldPos, airportObj, building.index, flags)) { return FAILURE; } } // 0x00493858 // Should we update the station meta data? if ((flags & Flags::ghost) == 0 && (flags & Flags::apply) != 0) { auto* station = StationManager::get(stationId); removeTileFromStationAndRecalcCargo(stationId, pos, rotation); station->flags &= ~StationFlags::flag_6; station->invalidate(); recalculateStationModes(stationId); recalculateStationCenter(stationId); station->updateLabel(); station->invalidate(); } return totalCost; } // 0x00493559 static currency32_t removeAirport(const AirportRemovalArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); // Find station element on tile auto* stationEl = getStationEl(args.pos); if (stationEl == nullptr) { return FAILURE; } StationId stationId = StationId::null; if ((flags & Flags::ghost) != 0) { return loc_49372F(stationId, *stationEl, args.pos, flags); } // 0x004935DC stationId = stationEl->stationId(); auto* station = StationManager::get(stationId); // Try to find airport station tile at the specified Z coordinate World::StationElement* foundStationEl = nullptr; World::Pos3 foundPos{}; for (auto i = 0U; i < station->stationTileSize; i++) { auto tilePos = station->stationTiles[i]; auto rotation = tilePos.z & 3; tilePos.z = World::heightFloor(tilePos.z); if (tilePos.z != args.pos.z) { continue; } // Find station element on tile stationEl = getStationEl(tilePos); if (stationEl == nullptr) { return FAILURE; } // 0x0049364C if (stationEl->stationType() != StationType::airport) { continue; } // 0x0049365A auto* airportObj = ObjectManager::get<AirportObject>(stationEl->objectId()); auto minPos = World::toWorldSpace(World::TilePos2(airportObj->minX, airportObj->minY)); auto maxPos = World::toWorldSpace(World::TilePos2(airportObj->maxX, airportObj->maxY)); minPos = Math::Vector::rotate(minPos, rotation); maxPos = Math::Vector::rotate(maxPos, rotation); // 0x004936CD minPos += World::Pos2{ tilePos.x, tilePos.y }; maxPos += World::Pos2{ tilePos.x, tilePos.y }; if (minPos.x > maxPos.x) { std::swap(minPos.x, maxPos.x); } if (minPos.y > maxPos.y) { std::swap(minPos.y, maxPos.y); } // Ensure that current airport tile fits within these min/max bounds if (args.pos.x < minPos.x || args.pos.y < minPos.y || args.pos.x > maxPos.x || args.pos.y > maxPos.y) { // We must've targetted a neighbouring airport -- look further continue; } foundStationEl = stationEl; foundPos = tilePos; break; } if (foundStationEl == nullptr) { return FAILURE; } // 0x00493719 return loc_49372F(stationId, *foundStationEl, foundPos, flags); } void removeAirport(registers& regs) { regs.ebx = removeAirport(AirportRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Airports/RemoveAirport.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct AirportRemovalArgs { static constexpr auto command = GameCommand::removeAirport; AirportRemovalArgs() = default; explicit AirportRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) { } // Note: pos.z must be a floored BigZ World::Pos3 pos; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; return regs; } }; void removeAirport(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Town/CreateTown.cpp ```cpp #include "CreateTown.h" #include "Audio/Audio.h" #include "Date.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "GameState.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Map/SurfaceElement.h" #include "Map/TileElement.h" #include "Map/TileManager.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { // 0x00496E09 static bool checkSurroundings(Pos2 pos, bool checkSurroundingWater) { auto tile = TileManager::get(pos); auto* surfaceEl = tile.surface(); if (surfaceEl->slope() != 0 || surfaceEl->water() != 0) { return false; } if (checkSurroundingWater) { auto* landObj = ObjectManager::get<LandObject>(surfaceEl->terrain()); if (landObj->hasFlags(LandObjectFlags::isDesert | LandObjectFlags::noTrees)) { auto nearbyWaterTiles = TileManager::countNearbyWaterTiles(pos); if (nearbyWaterTiles < 10 && getGameState().rng.randNext() & 0xFF) { return false; } } } for (auto& town : TownManager::towns()) { auto manhattanDistance = Math::Vector::manhattanDistance2D(pos, Pos2(town.x, town.y)); if (manhattanDistance < 768) { setErrorText(StringIds::too_close_to_another_town); return false; } } return true; } // 0x00496C22 static uint32_t createTown(const TownPlacementArgs& args, const uint8_t flags) { auto& gameState = getGameState(); Pos2 pos = args.pos; Town* newTown = nullptr; if (args.pos.x == -1) { bool foundPos = false; for (auto attempts = 200; attempts > 0; attempts--) { uint32_t rand = gameState.rng.randNext(); auto tilePos = TilePos2(((rand >> 16) * kMapColumns) >> 16, ((rand & 0xFFFF) * kMapRows) >> 16); Pos2 attemptPos = toWorldSpace(tilePos); if (attemptPos.x < 384 || attemptPos.y < 384 || attemptPos.x > 11904 || attemptPos.y > 11904) { continue; } if (checkSurroundings(attemptPos, true)) { pos = attemptPos; foundPos = true; break; } } if (!foundPos) { return FAILURE; } } else { bool foundPos = false; for (int attempts = 0; attempts < 40; attempts++) { Pos2 attemptPos; if (attempts == 0) { attemptPos = pos; } if (attempts <= 10) { // Add random value [-2, 1] to x and y uint32_t rand = gameState.rng.randNext(); TilePos2 randOffset(((rand >> 9) & 3) - 2, ((rand >> 5) & 3) - 2); attemptPos = pos + World::toWorldSpace(randOffset); } else if (attempts > 10) { // Add random value [-3, 4] to x and y uint32_t rand = gameState.rng.randNext(); TilePos2 randOffset(((rand >> 9) & 7) - 3, ((rand >> 5) & 7) - 3); attemptPos = pos + World::toWorldSpace(randOffset); } if (attemptPos.x < 160 || attemptPos.y < 160 || attemptPos.x > 12128 || attemptPos.y > 12128) { continue; } if (checkSurroundings(attemptPos, false)) { pos = attemptPos; foundPos = true; break; } } if (!foundPos) { return FAILURE; } } newTown = TownManager::initialiseTown(pos); if (!newTown) { setErrorText(StringIds::too_many_towns); return FAILURE; } if (!(flags & Flags::apply)) { StringManager::emptyUserString(newTown->name); newTown->name = StringIds::null; return 0; } // Backup current year, and adjust temporarily auto backupYear = getCurrentYear(); setCurrentYear(backupYear - 51); auto growthFactor = args.size * args.size; for (int i = 8; i > 0; i--) { for (int j = growthFactor; j > 0; j--) { newTown->grow(TownGrowFlags::all); newTown->recalculateSize(); } setCurrentYear(getCurrentYear() + 7); } // Restore current year setCurrentYear(backupYear); newTown->history[newTown->historySize - 1] = std::max<uint8_t>(newTown->population / 50, 255); auto tileHeight = World::TileManager::getHeight(Pos2(newTown->x, newTown->y)); setPosition(World::Pos3(newTown->x + World::kTileSize / 2, newTown->y + World::kTileSize / 2, tileHeight.landHeight)); auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; return 0; } void createTown(registers& regs) { TownPlacementArgs args(regs); regs.ebx = createTown(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Town/CreateTown.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TownPlacementArgs { static constexpr auto command = GameCommand::createTown; TownPlacementArgs() = default; explicit TownPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx) , size(regs.dl) { } World::Pos2 pos; uint8_t size; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.edx = size; return regs; } }; void createTown(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Town/RemoveTown.cpp ```cpp #include "RemoveTown.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/Buildings/RemoveBuilding.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Industries/RemoveIndustry.h" #include "GameCommands/Road/RemoveRoad.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Map/BuildingElement.h" #include "Map/RoadElement.h" #include "Map/TileElement.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "MessageManager.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/IndustryManager.h" #include "World/StationManager.h" #include "World/TownManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { // 0x0049711F static uint32_t removeTown(const TownRemovalArgs& args, const uint8_t flags) { for (auto& station : StationManager::stations()) { if (station.town == args.townId) { setErrorText(StringIds::all_stations_near_this_town_must_be_removed_first); return FAILURE; } } if (!(flags & Flags::apply)) { return 0; } // NB: vanilla did not set an expenditure type GameCommands::setExpenditureType(ExpenditureType::Construction); // Iterate over the entire map to find town tiles // TODO: can't we do better than vanilla for this? e.g. a radius around the town centre? for (auto& tilePos : getWorldRange()) { auto tile = TileManager::get(tilePos); bool resetTileLoop = true; while (resetTileLoop) { resetTileLoop = false; for (auto& element : tile) { if (element.isGhost()) { continue; } auto* buildingEl = element.as<BuildingElement>(); if (buildingEl != nullptr) { if (buildingEl->isMiscBuilding()) { continue; } if (buildingEl->sequenceIndex() != 0) { continue; } auto worldPos = toWorldSpace(tilePos); auto maybeTown = TownManager::getClosestTownAndDensity(worldPos); if (maybeTown) { TownId nearestTown = maybeTown->first; if (nearestTown != args.townId) { continue; } } BuildingRemovalArgs rmArgs{}; rmArgs.pos = Pos3(worldPos.x, worldPos.y, buildingEl->baseHeight()); if (doCommand(rmArgs, flags) != FAILURE) { resetTileLoop = true; break; } continue; } auto* roadEl = element.as<RoadElement>(); if (roadEl != nullptr) { if (roadEl->owner() != CompanyId::neutral) { continue; } auto worldPos = toWorldSpace(tilePos); auto maybeTown = TownManager::getClosestTownAndDensity(worldPos); if (maybeTown) { TownId nearestTown = maybeTown->first; if (nearestTown != args.townId) { continue; } } RoadRemovalArgs rmArgs{}; rmArgs.pos = Pos3(worldPos.x, worldPos.y, roadEl->baseHeight()); rmArgs.rotation = roadEl->rotation(); rmArgs.roadId = roadEl->roadId(); rmArgs.sequenceIndex = roadEl->sequenceIndex(); rmArgs.objectId = roadEl->roadObjectId(); if (doCommand(rmArgs, flags) != FAILURE) { resetTileLoop = true; break; } } } } } Ui::WindowManager::close(Ui::WindowType::town, enumValue(args.townId)); auto* town = TownManager::get(args.townId); auto oldTownCentre = Pos2(town->x, town->y); StringManager::emptyUserString(town->name); town->name = StringIds::null; Ui::Windows::TownList::removeTown(args.townId); MessageManager::removeAllSubjectRefs(enumValue(args.townId), MessageItemArgumentType::town); for (auto& industry : IndustryManager::industries()) { if (industry.town == args.townId) { IndustryRemovalArgs rmArgs{}; rmArgs.industryId = industry.id(); doCommand(rmArgs, flags); } } auto tileHeight = TileManager::getHeight(oldTownCentre); setPosition({ oldTownCentre.x, oldTownCentre.y, tileHeight.landHeight }); TownManager::resetBuildingsInfluence(); auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; return 0; } void removeTown(registers& regs) { TownRemovalArgs args(regs); regs.ebx = removeTown(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Town/RemoveTown.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TownRemovalArgs { static constexpr auto command = GameCommand::removeTown; TownRemovalArgs() = default; explicit TownRemovalArgs(const registers& regs) : townId(TownId(regs.edi)) { } TownId townId; explicit operator registers() const { registers regs; regs.edi = enumValue(townId); return regs; } }; void removeTown(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Town/RenameTown.cpp ```cpp #include "RenameTown.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Town/RenameTown.h" #include "Graphics/Gfx.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Types.hpp" #include "World/Industry.h" #include "World/StationManager.h" #include "World/TownManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { /** * 0x00455029 * Renames a particular town. * * This command is called 3 times before the buffer is applied. Each time, 12 chars of the 36 char buffer are provided. * The resulting town name has a maximum length of 31 chars; the last bytes are not used. * * @param flags @<bl> - game command flags * @param townId @<cx> - town id * @param index @<ax> - update index (in order of: 1, 2, 0) * @param buffer0 @<edx> - First part (4 chars) of the 12 update buffer * @param buffer1 @<dx> - Second part (4 chars) of the 12 update buffer * @param buffer2 @<bp> - Third part (4 chars) of the 12 update buffer * @return @<ebx> - returns 0 if rename is successful; otherwise GameCommands::FAILURE */ static uint32_t renameTown(const GameCommands::RenameTownArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); // Keep track of the town id over several calls. static TownId _townId{}; if (args.nameBufferIndex == 1) { _townId = args.townId; } static char staticRenameBuffer[37]{}; // Fill buffer over calls into the staticRenameBuffer if ((flags & GameCommands::Flags::apply) != 0) { static constexpr std::array<int, 3> kTransformTable = { 2, 0, 1 }; int arrayIndex = kTransformTable.at(args.nameBufferIndex); std::memcpy(staticRenameBuffer + arrayIndex * 12, args.buffer, 12); } // Applying the buffer? if (args.nameBufferIndex != 0) { return 0; } char renameStringBuffer[37] = ""; memcpy(renameStringBuffer, staticRenameBuffer, sizeof(staticRenameBuffer)); renameStringBuffer[36] = '\0'; // Ensure the new name isn't empty. if (strlen(renameStringBuffer) == 0) { return 0; } // Figure out the current name for this town. char currentTownName[256] = ""; auto town = TownManager::get(_townId); StringManager::formatString(currentTownName, town->name); // Verify the new name actually differs from the old one. if (strcmp(currentTownName, renameStringBuffer) == 0) { return 0; } // Allocate a string id for the new name. StringId allocatedStringId = StringManager::userStringAllocate(renameStringBuffer, true); if (allocatedStringId == StringIds::empty) { return GameCommands::FAILURE; } // Bailing out early? if ((flags & GameCommands::Flags::apply) == 0) { StringManager::emptyUserString(allocatedStringId); return 0; } // Apply the new name to the town. StringId oldStringId = town->name; town->name = allocatedStringId; StringManager::emptyUserString(oldStringId); // Recalculate labels for the town and (surrounding) stations. town->updateLabel(); StationManager::updateLabels(); Gfx::invalidateScreen(); return 0; } void renameTown(registers& regs) { regs.ebx = renameTown(GameCommands::RenameTownArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Town/RenameTown.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RenameTownArgs { static constexpr auto command = GameCommand::renameTown; RenameTownArgs() = default; explicit RenameTownArgs(const registers& regs) : townId(TownId(regs.cx)) , nameBufferIndex(regs.ax) , buffer{} { std::memcpy(buffer, &regs.edx, 4); std::memcpy(buffer + 4, &regs.ebp, 4); std::memcpy(buffer + 8, &regs.edi, 4); } TownId townId; uint8_t nameBufferIndex; char buffer[37]; explicit operator registers() const { registers regs; regs.cx = enumValue(townId); regs.ax = nameBufferIndex; constexpr std::array<uint8_t, 3> iToOffset = { 24, 0, 12 }; const auto offset = iToOffset[nameBufferIndex]; std::memcpy(&regs.edx, buffer + offset, 4); std::memcpy(&regs.ebp, buffer + offset + 4, 4); std::memcpy(&regs.edi, buffer + offset + 8, 4); return regs; } }; void renameTown(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/ChangeLandMaterial.cpp ```cpp #include "ChangeLandMaterial.h" #include "GameCommands/GameCommands.h" #include "Map/MapGenerator/MapGenerator.h" #include "Map/SurfaceElement.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x00468EDD static uint32_t changeLandMaterial(const World::Pos2& pointA, const World::Pos2& pointB, const uint8_t landType, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); const auto midPoint = (pointA + pointB) / 2 + World::Pos2{ 16, 16 }; auto height = World::TileManager::getHeight(midPoint); GameCommands::setPosition({ midPoint.x, midPoint.y, height.landHeight }); if ((flags & Flags::apply) == 0) { return 0; } const auto tileLoop = World::getClampedRange(pointA, pointB); for (const auto& tilePos : tileLoop) { auto surface = World::TileManager::get(tilePos).surface(); if (surface == nullptr) { continue; } surface->setTerrain(landType); if (!surface->isIndustrial()) { surface->setGrowthStage(0); } const auto variation = World::MapGenerator::getRandomTerrainVariation(*surface); if (variation.has_value()) { if (!surface->isIndustrial()) { surface->setVariation(*variation); } } auto* landObj = ObjectManager::get<LandObject>(landType); if (landObj != nullptr) { if (!surface->isIndustrial()) { surface->setGrowthStage(landObj->numGrowthStages - 1); } } World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; } return 0; } void changeLandMaterial(registers& regs) { ChangeLandMaterialArgs args(regs); regs.ebx = changeLandMaterial(args.pointA, args.pointB, args.landType, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/ChangeLandMaterial.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct ChangeLandMaterialArgs { static constexpr auto command = GameCommand::changeLandMaterial; ChangeLandMaterialArgs() = default; explicit ChangeLandMaterialArgs(const registers& regs) : pointA(regs.ax, regs.cx) , pointB(regs.di, regs.bp) , landType(regs.dl) { } World::Pos2 pointA; World::Pos2 pointB; uint8_t landType; explicit operator registers() const { registers regs; regs.ax = pointA.x; regs.cx = pointA.y; regs.di = pointB.x; regs.bp = pointB.y; regs.dl = landType; return regs; } }; void changeLandMaterial(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/ClearLand.cpp ```cpp #include "ClearLand.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/QuarterTile.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Objects/BuildingObject.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "SceneManager.h" #include "ViewportManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { // 0x00469D76 static uint32_t clearTile(World::Pos2 pos, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags) { // This shouldn't happen due to using TilePosRangeView if (!World::validCoords(pos)) { GameCommands::setErrorText(StringIds::off_edge_of_map); return GameCommands::FAILURE; } if (flags & GameCommands::Flags::apply) { if (!SceneManager::isEditorMode()) { TileManager::setTerrainStyleAsCleared(pos); } auto tileHeight = World::TileManager::getHeight(pos); TileManager::removeAllWallsOnTileAbove(World::toTileSpace(pos), tileHeight.landHeight / 4); } World::QuarterTile qt(0xF, 0); currency32_t cost{}; // Bind our local vars to the tile clear function auto clearFunc = [pos, &removedBuildings, flags, &cost](World::TileElement& el) { return TileClearance::clearWithoutDefaultCollision(el, pos, removedBuildings, flags, cost); }; auto tileHeight = World::TileManager::getHeight(pos); if (TileClearance::applyClearAtAllHeights(pos, tileHeight.landHeight / 4, tileHeight.landHeight / 4, qt, clearFunc)) { return cost; } else { return GameCommands::FAILURE; } } // 0x00469CCB static uint32_t clearLand(const ClearLandArgs& args, const uint8_t flags) { const auto tileLoop = World::getClampedRange(args.pointA, args.pointB); uint32_t totalCost = 0; // We keep track of removed buildings for each tile visited // this prevents accidentally double counting their removal // cost if they span across multiple tiles. World::TileClearance::RemovedBuildings removedBuildings{}; for (const auto& tilePos : tileLoop) { uint32_t tileRes = clearTile(World::toWorldSpace(tilePos), removedBuildings, flags); if (tileRes == GameCommands::FAILURE) { return GameCommands::FAILURE; } else { totalCost += tileRes; } } GameCommands::setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(args.centre); GameCommands::setPosition(World::Pos3(args.centre.x, args.centre.y, tileHeight.landHeight)); return totalCost; } void clearLand(registers& regs) { const ClearLandArgs args(regs); regs.ebx = clearLand(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/ClearLand.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct ClearLandArgs { static constexpr auto command = GameCommand::clearLand; ClearLandArgs() = default; explicit ClearLandArgs(const registers& regs) : centre(regs.ax, regs.cx) , pointA(regs.edx & 0xFFFF, regs.ebp & 0xFFFF) , pointB(regs.edx >> 16, regs.ebp >> 16) { } World::Pos2 centre; World::Pos2 pointA; World::Pos2 pointB; explicit operator registers() const { registers regs; regs.ax = centre.x; regs.cx = centre.y; regs.edx = (pointB.x << 16) | pointA.x; regs.ebp = (pointB.y << 16) | pointA.y; return regs; } }; void clearLand(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/CreateTree.cpp ```cpp #include "CreateTree.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/QuarterTile.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "OpenLoco.h" #include "Scenario.h" #include "ScenarioOptions.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/TownManager.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { constexpr std::array<World::Pos2, 4> _quadrantCentreOffsets = { World::Pos2{ 7, 7 }, World::Pos2{ 7, 23 }, World::Pos2{ 23, 23 }, World::Pos2{ 23, 7 }, }; /** * 0x004BB138 * Create tree * * This is called when you activate the Plant Trees from the construction menu and you move the cursor over the terrain. * */ static uint32_t createTree(const TreePlacementArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(args.pos); setPosition(World::Pos3(args.pos.x + World::kTileSize / 2, args.pos.y + World::kTileSize / 2, tileHeight.landHeight)); if (!World::TileManager::checkFreeElementsAndReorganise()) { // Error message set in checkFreeElementsAndReorganise return FAILURE; } if (!World::validCoords(args.pos)) { return FAILURE; } const auto* treeObj = ObjectManager::get<TreeObject>(args.type); const auto quadrantHeight = World::TileManager::getHeight(args.pos + _quadrantCentreOffsets[args.quadrant] - World::Pos2{ 1, 1 }); auto* elSurface = World::TileManager::get(args.pos).surface(); if (elSurface == nullptr) { return FAILURE; } if (elSurface->water()) { if (elSurface->waterHeight() - 1 > quadrantHeight.landHeight) { setErrorText(StringIds::cant_build_this_underwater); return FAILURE; } } const auto* landObj = ObjectManager::get<LandObject>(elSurface->terrain()); if (landObj->hasFlags(LandObjectFlags::noTrees)) { setErrorText(StringIds::land_type_not_suitable); return FAILURE; } const auto baseZ = quadrantHeight.landHeight / World::kSmallZStep; auto clearanceZ = baseZ + treeObj->initialHeight / World::kSmallZStep; if (args.requiresFullClearance) { clearanceZ = std::numeric_limits<uint8_t>::max(); } World::QuarterTile qt(1 << (args.quadrant ^ (1 << 1)), 0xF); if (!World::TileClearance::canConstructAt(args.pos, baseZ, clearanceZ, qt)) { // Error message set in canConstructAt return FAILURE; } if (flags & Flags::apply) { auto* elTree = World::TileManager::insertElement<World::TreeElement>(args.pos, baseZ, qt.getBaseQuarterOccupied()); if (elTree == nullptr) { return FAILURE; } Ui::Windows::Terraform::setLastPlacedTree(elTree); elTree->setRotation(args.rotation); elTree->setQuadrant(args.quadrant); elTree->setTreeObjectId(args.type); elTree->setGrowth(0); elTree->setUnk5h(0); elTree->setColour(args.colour); elTree->setIsDying(false); elTree->setSnow(false); elTree->setSeason(treeObj->currentSeason); elTree->setUnk7l(7); elTree->setClearZ(treeObj->initialHeight / World::kSmallZStep + elTree->baseZ()); Scenario::getOptions().madeAnyChanges = 1; if (args.buildImmediately) { elTree->setGrowth(treeObj->growth - 1); elTree->setClearZ(treeObj->height / World::kSmallZStep + elTree->baseZ()); if (elTree->baseZ() - 4 > Scenario::getCurrentSnowLine() && treeObj->hasFlags(TreeObjectFlags::hasSnowVariation)) { elTree->setSnow(true); } } if (flags & Flags::ghost) { elTree->setGhost(true); } else { TownManager::updateTownInfo(args.pos, 0, 0, treeObj->rating, 0); } Ui::ViewportManager::invalidate(args.pos, elTree->baseHeight(), elTree->clearHeight(), ZoomLevel::eighth, 56); } return Economy::getInflationAdjustedCost(treeObj->buildCostFactor, treeObj->costIndex, 12); } void createTree(registers& regs) { TreePlacementArgs args(regs); regs.ebx = createTree(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/CreateTree.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TreePlacementArgs { static constexpr auto command = GameCommand::createTree; TreePlacementArgs() = default; explicit TreePlacementArgs(const registers& regs) : pos(regs.ax, regs.cx) , rotation(regs.di & 0x3) , type(regs.bh) , quadrant(regs.dl) , colour(static_cast<Colour>(regs.dh & 0x1F)) , buildImmediately(regs.di & 0x8000) , requiresFullClearance(regs.di & 0x4000) { } World::Pos2 pos; uint8_t rotation; uint8_t type; uint8_t quadrant; Colour colour; bool buildImmediately = false; bool requiresFullClearance = false; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.dl = quadrant; regs.dh = enumValue(colour); regs.di = rotation | (buildImmediately ? 0x8000 : 0) | (requiresFullClearance ? 0x4000 : 0); regs.bh = type; return regs; } }; void createTree(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/CreateWall.cpp ```cpp #include "CreateWall.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/QuarterTile.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Map/WallElement.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/WallObject.h" #include "OpenLoco.h" #include "Scenario.h" #include "ScenarioOptions.h" #include "Ui/WindowManager.h" #include "ViewportManager.h" #include "World/TownManager.h" #include <OpenLoco/Core/EnumFlags.hpp> using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { struct EdgeSlopeMapEntry { EdgeSlope slope; bool isElevated; }; namespace EdgeSlopeMap { constexpr auto none = EdgeSlopeMapEntry{ EdgeSlope::none, false }; constexpr auto downwards = EdgeSlopeMapEntry{ EdgeSlope::downwards, false }; constexpr auto upwards = EdgeSlopeMapEntry{ EdgeSlope::upwards, false }; constexpr auto downwardsElevated = EdgeSlopeMapEntry{ EdgeSlope::downwards, true }; constexpr auto upwardsElevated = EdgeSlopeMapEntry{ EdgeSlope::upwards, true }; constexpr auto elevated = EdgeSlopeMapEntry{ EdgeSlope::none, true }; } // clang-format off constexpr std::array<std::array<EdgeSlopeMapEntry, 4>, 32> edgeWallMapping = { { // top-right bottom-right bottom-left top-left { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::upwards, EdgeSlopeMap::downwards, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::upwards, EdgeSlopeMap::downwards }, { EdgeSlopeMap::none, EdgeSlopeMap::upwards, EdgeSlopeMap::elevated, EdgeSlopeMap::downwards }, { EdgeSlopeMap::downwards, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::upwards }, { EdgeSlopeMap::downwards, EdgeSlopeMap::upwards, EdgeSlopeMap::downwards, EdgeSlopeMap::upwards }, { EdgeSlopeMap::downwards, EdgeSlopeMap::none, EdgeSlopeMap::upwards, EdgeSlopeMap::elevated }, { EdgeSlopeMap::downwards, EdgeSlopeMap::upwards, EdgeSlopeMap::elevated, EdgeSlopeMap::elevated }, { EdgeSlopeMap::upwards, EdgeSlopeMap::downwards, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::upwards, EdgeSlopeMap::elevated, EdgeSlopeMap::downwards, EdgeSlopeMap::none }, { EdgeSlopeMap::upwards, EdgeSlopeMap::downwards, EdgeSlopeMap::upwards, EdgeSlopeMap::downwards }, { EdgeSlopeMap::upwards, EdgeSlopeMap::elevated, EdgeSlopeMap::elevated, EdgeSlopeMap::downwards }, { EdgeSlopeMap::elevated, EdgeSlopeMap::downwards, EdgeSlopeMap::none, EdgeSlopeMap::upwards }, { EdgeSlopeMap::elevated, EdgeSlopeMap::elevated, EdgeSlopeMap::downwards, EdgeSlopeMap::upwards }, { EdgeSlopeMap::elevated, EdgeSlopeMap::downwards, EdgeSlopeMap::upwards, EdgeSlopeMap::elevated }, { EdgeSlopeMap::elevated, EdgeSlopeMap::elevated, EdgeSlopeMap::elevated, EdgeSlopeMap::elevated }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::downwards, EdgeSlopeMap::upwards, EdgeSlopeMap::upwardsElevated, EdgeSlopeMap::downwardsElevated }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::upwards, EdgeSlopeMap::upwardsElevated, EdgeSlopeMap::downwardsElevated, EdgeSlopeMap::downwards }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, { EdgeSlopeMap::upwardsElevated, EdgeSlopeMap::downwardsElevated, EdgeSlopeMap::downwards, EdgeSlopeMap::upwards }, { EdgeSlopeMap::downwardsElevated, EdgeSlopeMap::downwards, EdgeSlopeMap::upwards, EdgeSlopeMap::upwardsElevated }, { EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none, EdgeSlopeMap::none }, } }; // clang-format on // 0x004C4A3B static bool canConstructWall(World::Pos3 pos, SmallZ baseZ, SmallZ clearZ, uint8_t targetEdge) { if (!drawableCoords(World::Pos2(pos))) { setErrorText(StringIds::off_edge_of_map); return false; } for (auto& el : TileManager::get(pos)) { if (el.type() == ElementType::surface) { continue; } if (baseZ >= el.clearZ()) { continue; } if (clearZ <= el.baseZ()) { continue; } if (el.type() == ElementType::wall) { auto* wallEl = el.as<WallElement>(); if (wallEl != nullptr && wallEl->rotation() == targetEdge) { TileClearance::setCollisionErrorMessage(el); return false; } continue; } if (!el.occupiedQuarter()) { continue; } if (el.type() == ElementType::tree) { continue; } TileClearance::setCollisionErrorMessage(el); return false; } return true; } // 0x004C436C static uint32_t createWall(const WallPlacementArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); auto zPos = args.pos.z; if (zPos == 0) { auto tileHeight = World::TileManager::getHeight(args.pos); zPos = tileHeight.landHeight; } setPosition(World::Pos3(args.pos.x + World::kTileSize / 2, args.pos.y + World::kTileSize / 2, zPos)); if (!World::validCoords(args.pos)) { return FAILURE; } auto* surface = World::TileManager::get(args.pos).surface(); if (surface == nullptr) { return FAILURE; } auto slopeFlags = EdgeSlope::none; auto targetHeight = args.pos.z; if (targetHeight == 0) { targetHeight = surface->baseHeight(); auto edge = args.rotation & 3; const auto& edgeMapping = edgeWallMapping[surface->slope()][edge]; slopeFlags = edgeMapping.slope; if (edgeMapping.isElevated) { targetHeight += 16; } } const auto targetBaseZ = targetHeight / kSmallZStep; if (surface->water() && targetBaseZ < surface->water() * kMicroToSmallZStep) { setErrorText(StringIds::cant_build_this_underwater); return FAILURE; } if (targetBaseZ < surface->baseZ()) { setErrorText(StringIds::error_can_only_build_above_ground); return FAILURE; } if ((slopeFlags & (EdgeSlope::upwards | EdgeSlope::downwards)) == EdgeSlope::none) { const auto testHeight = surface->baseZ() + kSmallZStep; // Test placement edges to ensure we don't build partially underground for (auto i = 2; i <= 3; i++) { auto testEdge = (args.rotation + i) & 3; if (surface->slope() & (1 << testEdge)) { if (targetBaseZ < testHeight) { setErrorText(StringIds::error_can_only_build_above_ground); return FAILURE; } if (surface->isSlopeDoubleHeight()) { testEdge = (testEdge - 1) & 3; if (surface->slope() & (1 << testEdge)) { testEdge = (testEdge + 2) & 3; if (surface->slope() & (1 << testEdge)) { if (targetBaseZ < testHeight + kSmallZStep) { setErrorText(StringIds::error_can_only_build_above_ground); return FAILURE; } } } } } } } auto clearZ = targetBaseZ; // TODO: fold into previous block; left for now to match IDA auto* wallObj = ObjectManager::get<WallObject>(args.type); if ((slopeFlags & (EdgeSlope::upwards | EdgeSlope::downwards)) != EdgeSlope::none) { if ((wallObj->flags & WallObjectFlags::onlyOnLevelLand) != WallObjectFlags::none) { setErrorText(StringIds::can_only_build_this_on_level_land); return FAILURE; } clearZ += kSmallZStep; } clearZ += wallObj->height; if (!canConstructWall(args.pos, targetBaseZ, clearZ, args.rotation)) { return FAILURE; } if (!TileManager::checkFreeElementsAndReorganise()) { // Error message set in checkFreeElementsAndReorganise return FAILURE; } if (!(flags & Flags::apply)) { return 0; } auto* wall = TileManager::insertElement<WallElement>(args.pos, targetBaseZ, 0); if (wall == nullptr) { return FAILURE; } wall->setClearZ(clearZ); wall->setRotation(args.rotation); wall->setSlopeFlags(slopeFlags); wall->setPrimaryColour(args.primaryColour); wall->setSecondaryColour(args.secondaryColour); wall->setWallObjectId(args.type); if ((wallObj->flags & WallObjectFlags::hasTertiaryColour) != WallObjectFlags::none) { wall->setTertiaryColour(args.tertiaryColour); } if (flags & Flags::ghost) { wall->setGhost(true); } // TODO: manager? static loco_global<World::WallElement*, 0x01136470> _lastPlacedWall; *_lastPlacedWall = wall; Ui::ViewportManager::invalidate(args.pos, wall->baseHeight(), wall->baseHeight() + 72, ZoomLevel::half); Scenario::getOptions().madeAnyChanges = 1; return 0; } void createWall(registers& regs) { WallPlacementArgs args(regs); regs.ebx = createWall(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/CreateWall.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct WallPlacementArgs { static constexpr auto command = GameCommand::createWall; WallPlacementArgs() = default; explicit WallPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.dl) , type(regs.bh) , primaryColour(static_cast<Colour>(regs.dh)) , secondaryColour(static_cast<Colour>(regs.bp & 0x1F)) , tertiaryColour(static_cast<Colour>((regs.bp >> 8) & 0x1F)) { } World::Pos3 pos; uint8_t rotation; uint8_t type; Colour primaryColour; Colour secondaryColour; Colour tertiaryColour; // Note: will not work; render engine does not support tertiary explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.dl = rotation; regs.dh = enumValue(primaryColour); regs.di = pos.z; regs.bp = enumValue(secondaryColour) | (enumValue(tertiaryColour) << 8); regs.bh = type; return regs; } }; void createWall(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/LowerLand.cpp ```cpp #include "LowerLand.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/RoadElement.h" #include "Map/SurfaceData.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::SurfaceSlope; namespace OpenLoco::GameCommands { // 0x004638C6, 0x004638CF uint32_t lowerLand(const LowerLandArgs& args, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags) { if (flags & Flags::apply) { Scenario::getOptions().madeAnyChanges = 1; if (getCommandNestLevel() == 1 && getUpdatingCompanyId() != CompanyId::neutral) { const auto height = TileManager::getHeight(args.centre).landHeight; Audio::playSound(Audio::SoundId::construct, World::Pos3(args.centre.x, args.centre.y, height)); } } const auto tileLoop = World::getClampedRange(args.pointA, args.pointB); // Find out what the highest baseZ in the selected range is auto highestBaseZ = 0; for (const auto& tilePos : tileLoop) { auto tile = TileManager::get(tilePos); auto* surface = tile.surface(); auto baseZ = TileManager::getSurfaceCornerHeight(*surface); highestBaseZ = std::max<SmallZ>(highestBaseZ, baseZ); } // Now modify only the elements matching this highest baseZ auto totalCost = 0; for (const auto& tilePos : tileLoop) { auto tile = TileManager::get(tilePos); auto* surface = tile.surface(); auto baseZ = TileManager::getSurfaceCornerHeight(*surface); if (baseZ < highestBaseZ) { continue; } auto targetBaseZ = surface->baseZ(); auto slopeFlags = lowerSurfaceCornerFlags(args.corner, surface->slope()); if (slopeFlags & SurfaceSlope::requiresHeightAdjustment) { targetBaseZ -= kSmallZStep; slopeFlags &= ~SurfaceSlope::requiresHeightAdjustment; } auto cost = TileManager::adjustSurfaceHeight(toWorldSpace(tilePos), targetBaseZ, slopeFlags, removedBuildings, flags); if (cost == FAILURE) { return FAILURE; } else { totalCost += cost; } } GameCommands::setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(args.centre); GameCommands::setPosition(World::Pos3(args.centre.x, args.centre.y, tileHeight.landHeight)); return totalCost; } void lowerLand(registers& regs) { // We keep track of removed buildings for each tile visited // this prevents accidentally double counting their removal // cost if they span across multiple tiles. World::TileClearance::RemovedBuildings removedBuildings{}; const LowerLandArgs args(regs); regs.ebx = lowerLand(args, removedBuildings, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/LowerLand.h ```h #pragma once #include "GameCommands/GameCommands.h" #include "Map/MapSelection.h" #include "Map/Tile.h" #include "Map/TileClearance.h" namespace OpenLoco::GameCommands { struct LowerLandArgs { static constexpr auto command = GameCommand::lowerLand; LowerLandArgs() = default; explicit LowerLandArgs(const registers& regs) : centre(regs.ax, regs.cx) , pointA(regs.dx, regs.bp) , pointB(regs.edx >> 16, regs.ebp >> 16) , corner(static_cast<World::MapSelectionType>(regs.di)) { } World::Pos2 centre; World::Pos2 pointA; World::Pos2 pointB; World::MapSelectionType corner; explicit operator registers() const { registers regs; regs.ax = centre.x; regs.cx = centre.y; regs.edx = (pointB.x << 16) | pointA.x; regs.ebp = (pointB.y << 16) | pointA.y; regs.di = enumValue(corner); return regs; } }; uint32_t lowerLand(const LowerLandArgs& args, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags); void lowerLand(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/LowerRaiseLandMountain.cpp ```cpp #include "LowerRaiseLandMountain.h" #include "Audio/Audio.h" #include "GameCommands/GameCommands.h" #include "GameCommands/Terraform/LowerLand.h" #include "GameCommands/Terraform/RaiseLand.h" #include "Map/SurfaceData.h" #include "Map/SurfaceElement.h" #include "Map/TileManager.h" #include "ScenarioOptions.h" #include "Types.hpp" using namespace OpenLoco::World; namespace OpenLoco::GameCommands { static uint32_t _mtnToolCost; // 0x00F0014E static uint8_t _mtnToolGCFlags; // 0x00F00154 static uint8_t _mtnToolHeightDiff; // 0x00F00155 static int8_t _mtnToolOuterLoopIndex; // 0x00F00156 static void adjustSurfaceSlope(Pos2 pos, int8_t targetBaseZ, uint8_t targetCorner, uint8_t referenceCornerFlag, World::TileClearance::RemovedBuildings& removedBuildings) { if (!validCoords(pos)) { return; } auto tile = TileManager::get(pos); const auto* surface = tile.surface(); SmallZ cornerBaseZ = TileManager::getSurfaceCornerDownHeight(*surface, referenceCornerFlag); int8_t baseZDiff = cornerBaseZ - targetBaseZ; uint8_t slopeFlags = 0; if (baseZDiff > 0) { if (baseZDiff <= _mtnToolHeightDiff) { return; } slopeFlags = lowerSurfaceCornerFlags(targetCorner, surface->slope()); targetBaseZ = surface->baseZ(); if (slopeFlags & SurfaceSlope::requiresHeightAdjustment) { targetBaseZ -= kSmallZStep; slopeFlags &= ~SurfaceSlope::requiresHeightAdjustment; } } else if (baseZDiff < 0) { if (-baseZDiff <= _mtnToolHeightDiff) { return; } slopeFlags = raiseSurfaceCornerFlags(targetCorner, surface->slope()); targetBaseZ = surface->baseZ(); if (slopeFlags & SurfaceSlope::requiresHeightAdjustment) { targetBaseZ += kSmallZStep; slopeFlags &= ~SurfaceSlope::requiresHeightAdjustment; } } else // if (baseZDiff == 0) { return; } auto result = TileManager::adjustSurfaceHeight(pos, targetBaseZ, slopeFlags, removedBuildings, _mtnToolGCFlags); if (result != FAILURE) { _mtnToolCost += result; } } // 0x004633F6 static void adjustSurfaceSlopeSouth(Pos2 pos, int8_t targetBaseZ, World::TileClearance::RemovedBuildings& removedBuildings) { adjustSurfaceSlope(pos, targetBaseZ, 2, SurfaceSlope::CornerUp::south, removedBuildings); } // 0x004634B9 static void adjustSurfaceSlopeWest(Pos2 pos, int8_t targetBaseZ, World::TileClearance::RemovedBuildings& removedBuildings) { adjustSurfaceSlope(pos, targetBaseZ, 3, SurfaceSlope::CornerUp::west, removedBuildings); } // 0x0046357C static void adjustSurfaceSlopeNorth(Pos2 pos, int8_t targetBaseZ, World::TileClearance::RemovedBuildings& removedBuildings) { adjustSurfaceSlope(pos, targetBaseZ, 0, SurfaceSlope::CornerUp::north, removedBuildings); } // 0x0046363F static void adjustSurfaceSlopeEast(Pos2 pos, int8_t targetBaseZ, World::TileClearance::RemovedBuildings& removedBuildings) { adjustSurfaceSlope(pos, targetBaseZ, 1, SurfaceSlope::CornerUp::east, removedBuildings); } static uint32_t adjustMountainCentre(const LowerRaiseLandMountainArgs& args, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags) { // Prepare parameters for raise/lower land tool uint32_t result = FAILURE; if (args.adjustment == 1) { RaiseLandArgs raiseArgs; raiseArgs.centre = args.centre; raiseArgs.pointA = args.pointA; raiseArgs.pointB = args.pointB; raiseArgs.corner = MapSelectionType::full; result = raiseLand(raiseArgs, removedBuildings, flags); } else { LowerLandArgs lowerArgs; lowerArgs.centre = args.centre; lowerArgs.pointA = args.pointA; lowerArgs.pointB = args.pointB; lowerArgs.corner = MapSelectionType::full; result = lowerLand(lowerArgs, removedBuildings, flags); } return result; } static void smoothenSurfaceNorth(const Pos2& refPos, const Pos2& targetPos, const LowerRaiseLandMountainArgs& args, World::TileClearance::RemovedBuildings& removedBuildings) { auto tile = TileManager::get(refPos); auto surface = tile.surface(); auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::south); adjustSurfaceSlopeEast(targetPos, height, removedBuildings); _mtnToolHeightDiff -= kSmallZStep; if (targetPos.y >= args.pointA.y) { _mtnToolHeightDiff += kSmallZStep; if (targetPos.y > args.pointB.y) { _mtnToolHeightDiff += kSmallZStep; } } height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::west); adjustSurfaceSlopeNorth(targetPos, height, removedBuildings); } static void smoothenSurfaceEast(const Pos2& refPos, const Pos2& targetPos, const LowerRaiseLandMountainArgs& args, World::TileClearance::RemovedBuildings& removedBuildings) { auto tile = TileManager::get(refPos); auto surface = tile.surface(); auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::west); adjustSurfaceSlopeSouth(targetPos, height, removedBuildings); _mtnToolHeightDiff -= kSmallZStep; if (targetPos.x >= args.pointA.x) { _mtnToolHeightDiff += kSmallZStep; if (targetPos.x > args.pointB.x) { _mtnToolHeightDiff += kSmallZStep; } } height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::north); adjustSurfaceSlopeEast(targetPos, height, removedBuildings); } static void smoothenSurfaceSouth(const Pos2& refPos, const Pos2& targetPos, const LowerRaiseLandMountainArgs& args, World::TileClearance::RemovedBuildings& removedBuildings) { auto tile = TileManager::get(refPos); auto surface = tile.surface(); auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::north); adjustSurfaceSlopeWest(targetPos, height, removedBuildings); _mtnToolHeightDiff -= kSmallZStep; if (targetPos.y <= args.pointB.y) { _mtnToolHeightDiff += kSmallZStep; if (targetPos.y < args.pointA.y) { _mtnToolHeightDiff += kSmallZStep; } } height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::east); adjustSurfaceSlopeSouth(targetPos, height, removedBuildings); } static void smoothenSurfaceWest(const Pos2& refPos, const Pos2& targetPos, const LowerRaiseLandMountainArgs& args, World::TileClearance::RemovedBuildings& removedBuildings) { auto tile = TileManager::get(refPos); auto surface = tile.surface(); auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::east); adjustSurfaceSlopeNorth(targetPos, height, removedBuildings); _mtnToolHeightDiff -= kSmallZStep; if (targetPos.x <= args.pointB.x) { _mtnToolHeightDiff += kSmallZStep; if (targetPos.x < args.pointA.x) { _mtnToolHeightDiff += kSmallZStep; } } height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::south); adjustSurfaceSlopeWest(targetPos, height, removedBuildings); } // 0x00462DCE static uint32_t lowerRaiseLandMountain(const LowerRaiseLandMountainArgs& args, const uint8_t flags) { _mtnToolGCFlags = flags; if (flags & Flags::apply) { Scenario::getOptions().madeAnyChanges = 1; } _mtnToolCost = 0; // We keep track of removed buildings for each tile visited // this prevents accidentally double counting their removal // cost if they span across multiple tiles. World::TileClearance::RemovedBuildings removedBuildings{}; // Play sound if this is a company action if ((flags & Flags::apply) && getCommandNestLevel() == 1 && getUpdatingCompanyId() != CompanyId::neutral) { const auto height = TileManager::getHeight(args.centre).landHeight; Audio::playSound(Audio::SoundId::construct, World::Pos3(args.centre.x, args.centre.y, height)); } if (!validCoords(args.pointA) || !validCoords(args.pointB)) { return FAILURE; } // First, raise/lower the mountain's centre tile { auto result = adjustMountainCentre(args, removedBuildings, flags); if (result != FAILURE) { _mtnToolCost += result; } } // 0x00462E7E auto preTile = TileManager::get(args.pointA); auto* preSurface = preTile.surface(); if (preSurface->slope() != 0) { auto result = adjustMountainCentre(args, removedBuildings, flags); if (result != FAILURE) { _mtnToolCost += result; } // Verify that the slope is now gone. Abort if not. auto tile = TileManager::get(args.pointA); auto* surface = tile.surface(); if (surface->slope() != 0) { // 0x004633CB GameCommands::setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(args.centre); GameCommands::setPosition(World::Pos3(args.centre.x, args.centre.y, tileHeight.landHeight)); return _mtnToolCost; } } // 0x00462F25 const tile_coord_t minRadius = ((args.pointB.x - args.pointA.x) / kTileSize) - 1; const tile_coord_t maxRadius = minRadius + 64; tile_coord_t radius = minRadius; auto basePos = args.pointA; _mtnToolOuterLoopIndex = -4; while (true) { _mtnToolOuterLoopIndex += 4; radius += 2; basePos -= Pos2{ kTileSize, kTileSize }; if (radius >= maxRadius) { break; } _mtnToolHeightDiff = _mtnToolOuterLoopIndex * 2; { auto tile = TileManager::get(args.pointA); auto* surface = tile.surface(); // 0x00462FAB auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::south); adjustSurfaceSlopeNorth(basePos, height, removedBuildings); basePos.y += kTileSize; } // 0x00462FCE for (auto i = radius; i > 0; i--) { auto pos = Pos2{ args.pointA.x, std::clamp(basePos.y, args.pointA.y, args.pointB.y) }; smoothenSurfaceNorth(pos, basePos, args, removedBuildings); basePos.y += kTileSize; } // 0x00463089 { auto tile = TileManager::get(args.pointA.x, args.pointB.y); auto* surface = tile.surface(); // 0x004630C1 auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::west); adjustSurfaceSlopeEast(basePos, height, removedBuildings); basePos.x += kTileSize; } // 0x004630E1 for (auto i = radius; i > 0; i--) { auto pos = Pos2{ std::clamp(basePos.x, args.pointA.x, args.pointB.x), args.pointB.y }; smoothenSurfaceEast(pos, basePos, args, removedBuildings); basePos.x += kTileSize; } // 0x00463199 { auto tile = TileManager::get(args.pointB); auto* surface = tile.surface(); // 0x004631D1 auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::north); adjustSurfaceSlopeSouth(basePos, height, removedBuildings); basePos.y -= kTileSize; } // 0x004631F4 for (auto i = radius; i > 0; i--) { auto pos = Pos2{ args.pointB.x, std::clamp(basePos.y, args.pointA.y, args.pointB.y) }; smoothenSurfaceSouth(pos, basePos, args, removedBuildings); basePos.y -= kTileSize; } // 0x004632AF { auto tile = TileManager::get(Pos2(args.pointB.x, args.pointA.y)); auto* surface = tile.surface(); // 0x004632E7 auto height = TileManager::getSurfaceCornerDownHeight(*surface, SurfaceSlope::CornerUp::east); adjustSurfaceSlopeWest(basePos, height, removedBuildings); basePos.x -= kTileSize; } // 0x0046330A for (auto i = radius; i > 0; i--) { auto pos = Pos2{ std::clamp(basePos.x, args.pointA.x, args.pointB.x), args.pointA.y }; smoothenSurfaceWest(pos, basePos, args, removedBuildings); basePos.x -= kTileSize; } } // 0x004633CB GameCommands::setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(args.centre); GameCommands::setPosition(World::Pos3(args.centre.x, args.centre.y, tileHeight.landHeight)); return _mtnToolCost; } void lowerRaiseLandMountain(registers& regs) { const LowerRaiseLandMountainArgs args(regs); regs.ebx = lowerRaiseLandMountain(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/LowerRaiseLandMountain.h ```h #pragma once #include "GameCommands/GameCommands.h" #include "Map/Tile.h" #include <set> namespace OpenLoco::GameCommands { struct LowerRaiseLandMountainArgs { static constexpr auto command = GameCommand::lowerRaiseLandMountain; LowerRaiseLandMountainArgs() = default; explicit LowerRaiseLandMountainArgs(const registers& regs) : centre(regs.ax, regs.cx) , pointA(regs.dx, regs.bp) , pointB(regs.edx >> 16, regs.ebp >> 16) , adjustment(regs.di) { } World::Pos2 centre; World::Pos2 pointA; World::Pos2 pointB; int16_t adjustment; explicit operator registers() const { registers regs; regs.ax = centre.x; regs.cx = centre.y; regs.edx = (pointB.x << 16) | pointA.x; regs.ebp = (pointB.y << 16) | pointA.y; regs.di = adjustment; return regs; } }; void lowerRaiseLandMountain(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/LowerWater.cpp ```cpp #include "LowerWater.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/SurfaceElement.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { // 0x004C5126 static uint32_t lowerWater(const LowerWaterArgs& args, const uint8_t flags) { // We keep track of removed buildings for each tile visited // this prevents accidentally double counting their removal // cost if they span across multiple tiles. World::TileClearance::RemovedBuildings removedBuildings{}; auto totalCost = 0; if (flags & Flags::apply) { Scenario::getOptions().madeAnyChanges = 1; } const auto tileLoop = getClampedRange(args.pointA, args.pointB); // Find out what the highest water height in the selected range is auto highestWaterHeight = 0; for (const auto& tilePos : tileLoop) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); if (surface->water()) { auto waterHeight = surface->water() * kMicroToSmallZStep; highestWaterHeight = std::max<SmallZ>(waterHeight, highestWaterHeight); } } if (highestWaterHeight > 0) { // Now modify only the elements matching this highest water height for (const auto& tilePos : tileLoop) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); auto waterHeight = surface->water() * kMicroToSmallZStep; if (waterHeight < highestWaterHeight) { continue; } waterHeight -= kSmallZStep; auto cost = TileManager::adjustWaterHeight(toWorldSpace(tilePos), waterHeight, removedBuildings, flags); if (cost == FAILURE) { return FAILURE; } else { totalCost += cost; } } } if ((flags & Flags::apply) && totalCost > 0) { auto centre = (args.pointA + args.pointB) / 2; auto tileHeight = World::TileManager::getHeight(centre); GameCommands::setPosition(World::Pos3(centre.x + World::kTileSize / 2, centre.y + World::kTileSize / 2, tileHeight.waterHeight)); Audio::playSound(Audio::SoundId::water, World::Pos3(centre.x, centre.y, tileHeight.waterHeight)); } return totalCost; } void lowerWater(registers& regs) { const LowerWaterArgs args(regs); regs.ebx = lowerWater(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/LowerWater.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct LowerWaterArgs { static constexpr auto command = GameCommand::lowerWater; LowerWaterArgs() = default; explicit LowerWaterArgs(const registers& regs) : pointA(regs.ax, regs.cx) , pointB(regs.di, regs.bp) { } World::Pos2 pointA; World::Pos2 pointB; explicit operator registers() const { registers regs; regs.ax = pointA.x; regs.cx = pointA.y; regs.di = pointB.x; regs.bp = pointB.y; return regs; } }; void lowerWater(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RaiseLand.cpp ```cpp #include "RaiseLand.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/RoadElement.h" #include "Map/SurfaceData.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; using namespace OpenLoco::World::SurfaceSlope; namespace OpenLoco::GameCommands { // 0x00463702, 0x0046370B uint32_t raiseLand(const RaiseLandArgs& args, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags) { if (flags & Flags::apply) { Scenario::getOptions().madeAnyChanges = 1; if (getCommandNestLevel() == 1 && getUpdatingCompanyId() != CompanyId::neutral) { const auto height = TileManager::getHeight(args.centre).landHeight; Audio::playSound(Audio::SoundId::construct, World::Pos3(args.centre.x, args.centre.y, height)); } } const auto tileLoop = getClampedRange(args.pointA, args.pointB); // Find out what the lowest baseZ in the selected range is auto lowestBaseZ = 255; for (const auto& tilePos : tileLoop) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); lowestBaseZ = std::min<SmallZ>(lowestBaseZ, surface->baseZ()); } // Now modify only the elements matching this lowest baseZ auto totalCost = 0; for (const auto& tilePos : tileLoop) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); if (surface->baseZ() > lowestBaseZ) { continue; } auto targetBaseZ = lowestBaseZ; auto slopeFlags = raiseSurfaceCornerFlags(args.corner, surface->slope()); if (slopeFlags & SurfaceSlope::requiresHeightAdjustment) { targetBaseZ += kSmallZStep; slopeFlags &= ~SurfaceSlope::requiresHeightAdjustment; } auto cost = TileManager::adjustSurfaceHeight(toWorldSpace(tilePos), targetBaseZ, slopeFlags, removedBuildings, flags); if (cost == FAILURE) { return FAILURE; } else { totalCost += cost; } } GameCommands::setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(args.centre); GameCommands::setPosition(World::Pos3(args.centre.x, args.centre.y, tileHeight.landHeight)); return totalCost; } void raiseLand(registers& regs) { // We keep track of removed buildings for each tile visited // this prevents accidentally double counting their removal // cost if they span across multiple tiles. World::TileClearance::RemovedBuildings removedBuildings{}; const RaiseLandArgs args(regs); regs.ebx = raiseLand(args, removedBuildings, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RaiseLand.h ```h #pragma once #include "GameCommands/GameCommands.h" #include "Map/MapSelection.h" #include "Map/Tile.h" #include "Map/TileClearance.h" namespace OpenLoco::GameCommands { struct RaiseLandArgs { static constexpr auto command = GameCommand::raiseLand; RaiseLandArgs() = default; explicit RaiseLandArgs(const registers& regs) : centre(regs.ax, regs.cx) , pointA(regs.dx, regs.bp) , pointB(regs.edx >> 16, regs.ebp >> 16) , corner(static_cast<World::MapSelectionType>(regs.di)) { } World::Pos2 centre; World::Pos2 pointA; World::Pos2 pointB; World::MapSelectionType corner; explicit operator registers() const { registers regs; regs.ax = centre.x; regs.cx = centre.y; regs.edx = (pointB.x << 16) | pointA.x; regs.ebp = (pointB.y << 16) | pointA.y; regs.di = enumValue(corner); return regs; } }; uint32_t raiseLand(const RaiseLandArgs& args, World::TileClearance::RemovedBuildings& removedBuildings, const uint8_t flags); void raiseLand(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RaiseWater.cpp ```cpp #include "RaiseWater.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Objects/ObjectManager.h" #include "ScenarioOptions.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { // 0x004C4F19 static uint32_t raiseWater(const RaiseWaterArgs& args, const uint8_t flags) { // We keep track of removed buildings for each tile visited // this prevents accidentally double counting their removal // cost if they span across multiple tiles. World::TileClearance::RemovedBuildings removedBuildings{}; auto totalCost = 0; if (flags & Flags::apply) { Scenario::getOptions().madeAnyChanges = 1; } const auto tileLoop = getClampedRange(args.pointA, args.pointB); // Find out what the lowest baseZ in the selected range is auto lowestBaseZ = 255; for (const auto& tilePos : tileLoop) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); auto baseZ = surface->baseZ(); if (surface->water()) { baseZ = surface->waterHeight(); } lowestBaseZ = std::min<SmallZ>(lowestBaseZ, baseZ); } // Now modify only the elements matching this lowest baseZ for (const auto& tilePos : tileLoop) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); if (surface->baseZ() > lowestBaseZ) { continue; } auto waterHeight = surface->water() * kMicroToSmallZStep; if (waterHeight == 0) { waterHeight = surface->baseZ() + kSmallZStep; } else { if (waterHeight > lowestBaseZ) { continue; } else { waterHeight += kSmallZStep; } } auto cost = TileManager::adjustWaterHeight(toWorldSpace(tilePos), waterHeight, removedBuildings, flags); if (cost == FAILURE) { return FAILURE; } else { totalCost += cost; } } if ((flags & Flags::apply) && totalCost > 0) { auto centre = (args.pointA + args.pointB) / 2; auto tileHeight = World::TileManager::getHeight(centre); Audio::playSound(Audio::SoundId::water, World::Pos3(centre.x, centre.y, tileHeight.waterHeight)); } return totalCost; } void raiseWater(registers& regs) { const RaiseWaterArgs args(regs); regs.ebx = raiseWater(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RaiseWater.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RaiseWaterArgs { static constexpr auto command = GameCommand::raiseWater; RaiseWaterArgs() = default; explicit RaiseWaterArgs(const registers& regs) : pointA(regs.ax, regs.cx) , pointB(regs.di, regs.bp) { } World::Pos2 pointA; World::Pos2 pointB; explicit operator registers() const { registers regs; regs.ax = pointA.x; regs.cx = pointA.y; regs.di = pointB.x; regs.bp = pointB.y; return regs; } }; void raiseWater(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RemoveTree.cpp ```cpp #include "RemoveTree.h" #include "Audio/Audio.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Map/TileElement.h" #include "Map/TileManager.h" #include "Map/TreeElement.h" #include "Objects/ObjectManager.h" #include "Objects/TreeObject.h" #include "Random.h" #include "ScenarioOptions.h" #include "ViewportManager.h" #include "World/TownManager.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { /** * 0x004BB392 * Remove tree * * This is called when you activate the Plant Trees from the construction (first) menu and you move the cursor over the terrain. * * @param pos_x @<ax> * @param pos_y @<cx> * @param pos_z @<dl> * World::kSmallZStep * @param type @<dh> * @param elementType @<bh> * @param flags @<bl> * @return @<ebx> - returns the remove cost if successful; otherwise GameCommands::FAILURE (in the assembly code we never get into failure path) */ static uint32_t removeTree(const World::Pos3& pos, const uint8_t type, const uint8_t elementType, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); auto tileHeight = World::TileManager::getHeight(pos); GameCommands::setPosition(World::Pos3(pos.x + World::kTileSize / 2, pos.y + World::kTileSize / 2, tileHeight.landHeight)); auto tile = World::TileManager::get(pos); for (auto& element : tile) { // TODO: refactor! Figure out what info it actually needs. if (element.rawData()[0] != elementType) { continue; } if (element.baseHeight() != pos.z) { continue; } auto* treeElement = element.as<World::TreeElement>(); if (treeElement == nullptr) { continue; } if (treeElement->treeObjectId() != type) { continue; } auto treeObj = ObjectManager::get<TreeObject>(treeElement->treeObjectId()); currency32_t removalCost = Economy::getInflationAdjustedCost(treeObj->clearCostFactor, treeObj->costIndex, 12); if (flags & Flags::apply) { World::TileManager::removeTree(*treeElement, flags, pos); } auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; return removalCost; } return FAILURE; } void removeTree(registers& regs) { TreeRemovalArgs args(regs); regs.ebx = removeTree(args.pos, args.type, args.elementType, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RemoveTree.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TreeRemovalArgs { static constexpr auto command = GameCommand::removeTree; TreeRemovalArgs() = default; explicit TreeRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.dl * World::kSmallZStep) , type(regs.dh) , elementType(regs.bh) { } World::Pos3 pos; uint8_t type; uint8_t elementType; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.dl = pos.z / World::kSmallZStep; regs.dh = type; regs.bh = elementType; return regs; } }; void removeTree(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RemoveWall.cpp ```cpp #include "RemoveWall.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Map/TileManager.h" #include "Map/WallElement.h" #include "ScenarioOptions.h" #include "ViewportManager.h" using namespace OpenLoco::Interop; using namespace OpenLoco::World; namespace OpenLoco::GameCommands { /** * 0x004C466C * Remove wall * * This is called when you activate the Build Walls from the construction (first) menu and you move the cursor over the terrain. * Removing the ghost walls (during the drawing when you move the cursor) are handled by this function. * * @param args.pos.x @<ax> * @param args.pos.y @<cx> * @param args.pos.z @<dh> * Map::kSmallZStep (multiplied by Map::kSmallZStep in WallRemovalArgs initialiser) * @param args.rotation @<bh> * @param flags @<bl> * @return @<ebx> - returns 0 (always successful) */ static uint32_t removeWall(const WallRemovalArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); GameCommands::setPosition(World::Pos3(args.pos.x + World::kTileSize / 2, args.pos.y + World::kTileSize / 2, args.pos.z)); auto tile = World::TileManager::get(args.pos); for (auto& tileElement : tile) { auto* wallElement = tileElement.as<WallElement>(); if (wallElement == nullptr) { continue; } if (wallElement->baseZ() != args.pos.z / 4) { continue; } if (wallElement->rotation() != args.rotation) { continue; } if ((flags & Flags::ghost) == 0 && wallElement->isGhost()) { continue; } if ((flags & Flags::apply) == 0) { return 0; } Ui::ViewportManager::invalidate(args.pos, wallElement->baseHeight(), wallElement->baseHeight() + 48, ZoomLevel::half); TileManager::removeElement(tileElement); auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; return 0; } return 0; } void removeWall(registers& regs) { const WallRemovalArgs args(regs); regs.ebx = removeWall(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Terraform/RemoveWall.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct WallRemovalArgs { static constexpr auto command = GameCommand::removeWall; WallRemovalArgs() = default; explicit WallRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.dh * World::kSmallZStep) , rotation(regs.dl) { } World::Pos3 pos; uint8_t rotation; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.dh = pos.z / World::kSmallZStep; regs.dl = rotation; return regs; } }; void removeWall(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/CreateRoad.cpp ```cpp #include "CreateRoad.h" #include "Economy/Economy.h" #include "GameState.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Objects/BridgeObject.h" #include "Objects/LevelCrossingObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "Objects/TrackObject.h" #include "ScenarioOptions.h" #include "SceneManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::GameCommands { using namespace World::TileManager; using namespace World::Track; static loco_global<uint8_t, 0x0112C2E9> _alternateTrackObjectId; // used by ui static loco_global<ElementPositionFlags, 0x01136072> _byte_1136072; static loco_global<uint8_t, 0x01136073> _byte_1136073; static loco_global<World::MicroZ, 0x01136074> _byte_1136074; static loco_global<uint8_t, 0x01136075> _byte_1136075; // bridgeType of any overlapping track // TODO: Identical to createTrack function static bool isBridgeRequired(const World::SmallZ baseZ, const World::SurfaceElement& elSurface, const World::TrackData::PreviewTrack& piece, const uint8_t unk) { if (baseZ > elSurface.baseZ()) { return true; } else if (baseZ == elSurface.baseZ()) { if (!piece.hasFlags(World::TrackData::PreviewTrackFlags::unk4)) { if (unk == 0 || unk == elSurface.slopeCorners()) { return false; } } return true; } return false; } namespace { struct ClearFunctionArgs { World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t bridgeId; uint8_t roadObjectId; uint8_t index; bool isLastIndex; uint8_t flags; uint8_t unkFlags; }; } struct RoadClearFunctionResult { explicit RoadClearFunctionResult(World::TileClearance::ClearFuncResult _res) : res(_res) { } World::TileClearance::ClearFuncResult res; bool hasLevelCrossing = false; uint8_t levelCrossingObjId = 0xFFU; bool hasStation = false; StationId stationId = StationId::null; std::array<uint8_t, 16> roadIdUnk = {}; }; // 0x00476EC4 static RoadClearFunctionResult clearTrack(World::TrackElement& elTrack, const ClearFunctionArgs& args) { if (elTrack.hasBridge()) { _byte_1136075 = elTrack.bridge(); auto* bridgeObj = ObjectManager::get<BridgeObject>(elTrack.bridge()); if ((bridgeObj->disabledTrackCfg & CommonTraitFlags::junction) != CommonTraitFlags::none) { setErrorText(StringIds::bridge_not_suitable_for_junction); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } } auto* trackObj = ObjectManager::get<TrackObject>(elTrack.trackObjectId()); auto* roadObj = ObjectManager::get<RoadObject>(args.roadObjectId); if (!(trackObj->compatibleRoads & (1U << args.roadObjectId)) && !(roadObj->compatibleTracks & (1U << elTrack.trackObjectId()))) { FormatArguments::common(trackObj->name); setErrorText(StringIds::unable_to_cross_or_create_junction_with_string); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elTrack.hasSignal()) { setErrorText(StringIds::signal_in_the_way); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elTrack.hasStationElement()) { setErrorText(StringIds::station_in_the_way); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elTrack.hasBridge()) { if (elTrack.bridge() != args.bridgeId) { setErrorText(StringIds::bridge_types_must_match); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } } if (elTrack.trackId() != 0 || args.roadId != 0 || !((elTrack.rotation() - args.rotation) & 0b1) || elTrack.baseHeight() != args.pos.z) { setErrorText(StringIds::level_crossing_only_possible_with_straight_road_and_track_at_same_level); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } auto res = RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); res.hasLevelCrossing = true; _byte_1136073 = _byte_1136073 | (1U << 2); if (!(args.flags & (Flags::aiAllocated | Flags::ghost)) && (args.flags & Flags::apply)) { elTrack.setHasLevelCrossing(true); } return res; } // Checks to see if this is an overlay road // such as a tram on top of a road static bool isPotentialOverlayRoad(World::RoadElement& elRoad, const ClearFunctionArgs& args) { if (elRoad.roadId() == args.roadId && elRoad.rotation() == args.rotation && elRoad.sequenceIndex() == args.index) { return true; } else if ( World::TrackData::getRoadMiscData(elRoad.roadId()).reverseRoadId == args.roadId && (elRoad.rotation() ^ (1U << 1)) == args.rotation && (World::TrackData::getRoadMiscData(elRoad.roadId()).reverseLane - 1 - elRoad.sequenceIndex()) == args.index) { return true; } return false; } static World::StationElement* getRoadStationElement(const World::Pos3& pos) { auto tile = World::TileManager::get(pos.x, pos.y); const auto baseZ = pos.z / World::kSmallZStep; for (auto& element : tile) { auto* elStation = element.as<World::StationElement>(); if (elStation == nullptr) { continue; } if (elStation->baseZ() != baseZ) { continue; } if (elStation->stationType() != StationType::roadStation) { continue; } return elStation; } return nullptr; } // 0x0047744C static bool roadTraitAndCompatbilityCheck(const World::RoadElement& elRoad, const ClearFunctionArgs& args, const RoadObject& targetRoadObj, const RoadObject& newRoadObj) { if (elRoad.roadObjectId() == args.roadObjectId) { if (!targetRoadObj.hasTraitFlags(RoadTraitFlags::junction)) { setErrorText(StringIds::junctions_not_possible); return false; } } else { if (!(targetRoadObj.compatibleRoads & (1U << args.roadObjectId)) && !(newRoadObj.compatibleRoads & (1U << elRoad.roadObjectId()))) { FormatArguments::common(targetRoadObj.name); setErrorText(StringIds::unable_to_cross_or_create_junction_with_string); return false; } } return true; } // 0x004773FE static bool finalJunctionChecks(const World::RoadElement& elRoad, const ClearFunctionArgs& args, const RoadObject& targetRoadObj, const RoadObject& newRoadObj) { if (World::TrackData::getRoadPiece(args.roadId).size() > 1 || World::TrackData::getRoadPiece(elRoad.roadId()).size() > 1) { setErrorText(StringIds::junction_not_possible); return false; } return roadTraitAndCompatbilityCheck(elRoad, args, targetRoadObj, newRoadObj); } static bool aiUnkCheck(const World::RoadElement& elRoad, const ClearFunctionArgs& args) { if (!(args.unkFlags & ((1U << 4) | (1U << 5)))) { return false; } if (!(args.flags & Flags::aiAllocated)) { return false; } if (elRoad.isAiAllocated()) { return false; } return ((args.unkFlags & (1U << 4)) || elRoad.owner() == getUpdatingCompanyId()); } // 0x00476FAB static RoadClearFunctionResult clearRoad(World::RoadElement& elRoad, const ClearFunctionArgs& args) { if (!elRoad.isGhost() && !elRoad.isAiAllocated()) { _byte_1136073 = _byte_1136073 | (1U << 6); } if (elRoad.hasBridge()) { _byte_1136075 = elRoad.bridge(); } const auto& targetPiece = World::TrackData::getRoadPiece(elRoad.roadId())[elRoad.sequenceIndex()]; const auto& newPiece = World::TrackData::getRoadPiece(args.roadId)[args.index]; const auto targetConnectFlags = targetPiece.connectFlags[elRoad.rotation()]; const auto newConnectFlags = newPiece.connectFlags[args.rotation]; if (!(targetConnectFlags & newConnectFlags)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); } // RoadObject of the road element we are clearing const auto& targetRoadObj = ObjectManager::get<RoadObject>(elRoad.roadObjectId()); // RoadObject of the road we are placing as part of createRoad const auto& newRoadObj = ObjectManager::get<RoadObject>(args.roadObjectId); if ((args.flags & Flags::aiAllocated) && (args.unkFlags & (1U << 4)) && targetRoadObj->hasFlags(RoadObjectFlags::isOneWay)) { setErrorText(StringIds::junctions_not_possible); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } const auto& gs = getGameState(); if (!(gs.roadObjectIdIsFlag7 & (1U << elRoad.roadObjectId())) || !(gs.roadObjectIdIsFlag7 & (1U << args.roadObjectId))) { if (!sub_431E6A(elRoad.owner(), reinterpret_cast<const World::TileElement*>(&elRoad))) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } } bool confirmedOverlay = false; const bool aiUnk = aiUnkCheck(elRoad, args); if (elRoad.baseHeight() == args.pos.z) { if ((World::TrackData::getRoadMiscData(elRoad.roadId()).flags & (CommonTraitFlags::slope | CommonTraitFlags::steepSlope)) != CommonTraitFlags::none) { if (isPotentialOverlayRoad(elRoad, args)) { _byte_1136073 = _byte_1136073 | (1U << 5); if (elRoad.roadObjectId() != args.roadObjectId) { confirmedOverlay = true; } if (aiUnk) { confirmedOverlay = true; } } } } if (!confirmedOverlay) { // 0x477130 if (((World::TrackData::getRoadMiscData(elRoad.roadId()).flags & (CommonTraitFlags::slope | CommonTraitFlags::steepSlope)) != CommonTraitFlags::none) || ((World::TrackData::getRoadMiscData(args.roadId).flags & (CommonTraitFlags::slope | CommonTraitFlags::steepSlope)) != CommonTraitFlags::none)) { setErrorText(StringIds::junction_must_be_entirely_level); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elRoad.baseHeight() != args.pos.z) { FormatArguments::common(targetRoadObj->name); setErrorText(StringIds::string_id_in_the_way_wrong_height_for_junction); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } } auto res = RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); if (elRoad.hasLevelCrossing()) { res.levelCrossingObjId = elRoad.levelCrossingObjectId(); } _alternateTrackObjectId = elRoad.roadObjectId(); if (elRoad.hasSignalElement()) { setErrorText(StringIds::signal_in_the_way); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elRoad.hasStationElement()) { if (args.roadId != 0 || (args.rotation != elRoad.rotation() && (args.rotation != (elRoad.rotation() ^ (1U << 1))))) { setErrorText(StringIds::station_in_the_way); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } auto* elStation = getRoadStationElement(args.pos); if (elStation != nullptr) { res.stationId = elStation->stationId(); // Check if either the road object is compatible with the station object // or if the station object is compatible with the road object for (const auto compatStationObjId : newRoadObj->stations) { if (compatStationObjId == elStation->objectId()) { res.hasStation = true; break; } } if (!res.hasStation) { auto* roadStationObj = ObjectManager::get<RoadStationObject>(elStation->objectId()); for (const auto compatRoadObjId : roadStationObj->mods) { if (compatRoadObjId == args.roadObjectId) { res.hasStation = true; break; } } } if (!res.hasStation) { setErrorText(StringIds::station_in_the_way); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } } } // Exact overlays are allowed only if objectIds are different // NOTE: Doesn't take into account sequence index const bool isExactOverlay = args.roadId == elRoad.roadId() && args.rotation == elRoad.rotation() && args.index == elRoad.sequenceIndex(); // A reverse overlay is ultimately the same as an exact overlay // NOTE: Doesn't take into account sequence index const bool isReverseExactOverlay = !isExactOverlay && (World::TrackData::getRoadMiscData(elRoad.roadId()).reverseRoadId == args.roadId) && (((World::TrackData::getRoadMiscData(elRoad.roadId()).reverseRotation + elRoad.rotation()) & 0x3) == args.rotation) && (World::TrackData::getRoadMiscData(elRoad.roadId()).reverseLane == World::TrackData::getRoadMiscData(args.roadId).reverseLane); // Ends can connect to starts or middles can connect if exactly the same (tram/road curve overlay) // NOTE: Doesn't take into account size 1 pieces that have additional allowances (tram tight curve overlay on straight road) const bool isConnectableSequence = (elRoad.sequenceIndex() == 0 && args.isLastIndex) // is Start Road && connect is End || (elRoad.sequenceIndex() != 0 && elRoad.isFlag6() && args.index == 0) // is End Road && connect is Start || (elRoad.sequenceIndex() != 0 && !elRoad.isFlag6() && elRoad.sequenceIndex() == args.index); // is Middle Road && connect same id if (elRoad.hasBridge()) { if (elRoad.bridge() != args.bridgeId) { setErrorText(StringIds::bridge_types_must_match); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } auto* bridgeObj = ObjectManager::get<BridgeObject>(args.bridgeId); if ((bridgeObj->disabledTrackCfg & CommonTraitFlags::junction) != CommonTraitFlags::none) { if (args.roadObjectId == elRoad.roadObjectId()) { setErrorText(StringIds::bridge_not_suitable_for_junction); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (!isExactOverlay) { if (!isReverseExactOverlay || !isConnectableSequence) { setErrorText(StringIds::bridge_not_suitable_for_junction); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } } } } // 0x004772F4 if (isExactOverlay) { _byte_1136073 = _byte_1136073 | (1U << 5); if (elRoad.roadObjectId() == args.roadObjectId) { // 0x004773BC if (aiUnk) { // 0x004773FE if (!finalJunctionChecks(elRoad, args, *targetRoadObj, *newRoadObj)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } res.roadIdUnk[elRoad.roadId()] |= 1U << elRoad.rotation(); res.roadIdUnk[0] |= 1U << 7; return res; } setErrorText(StringIds::already_built_here); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } // 0x0047744C if (!roadTraitAndCompatbilityCheck(elRoad, args, *targetRoadObj, *newRoadObj)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } return res; } // 0x00477336 if (isReverseExactOverlay) { if (!isConnectableSequence) { // 0x004773FE if (!finalJunctionChecks(elRoad, args, *targetRoadObj, *newRoadObj)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elRoad.roadObjectId() == args.roadObjectId) { res.roadIdUnk[elRoad.roadId()] |= 1U << elRoad.rotation(); res.roadIdUnk[0] |= 1U << 7; } return res; } // 0x004773A5 _byte_1136073 = _byte_1136073 | (1U << 5); if (elRoad.roadObjectId() == args.roadObjectId) { // 0x004773BC if (aiUnk) { // 0x004773FE if (!finalJunctionChecks(elRoad, args, *targetRoadObj, *newRoadObj)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } res.roadIdUnk[elRoad.roadId()] |= 1U << elRoad.rotation(); res.roadIdUnk[0] |= 1U << 7; return res; } setErrorText(StringIds::already_built_here); return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } // 0x0047744C if (!roadTraitAndCompatbilityCheck(elRoad, args, *targetRoadObj, *newRoadObj)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } return res; } // 0x004773FE if (!finalJunctionChecks(elRoad, args, *targetRoadObj, *newRoadObj)) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collisionErrorSet); } if (elRoad.roadObjectId() == args.roadObjectId) { res.roadIdUnk[elRoad.roadId()] |= 1U << elRoad.rotation(); res.roadIdUnk[0] |= 1U << 7; } return res; } // 0x00476D40 static RoadClearFunctionResult clearFunction(World::TileElement& el, currency32_t& totalCost, World::TileClearance::RemovedBuildings& removedBuildings, const ClearFunctionArgs& args) { // stack // 0x0 = totalCost // 0xC = roadObjectId // 0xD = roadId // 0xE = bridge // 0x14 = flags // 0x15 = rotation // 0x0112C2E2 = hasLevelCrossing // 0x0112C2E3 = levelCrossingObjId // 0x0112C2EC = hasStation switch (el.type()) { case World::ElementType::track: { auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { return clearTrack(*elTrack, args); } break; } case World::ElementType::station: { auto* elStation = el.as<World::StationElement>(); if (elStation->stationType() == StationType::roadStation) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); } return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collision); } case World::ElementType::signal: return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); } _byte_1136073 = _byte_1136073 | (1U << 4); return RoadClearFunctionResult(World::TileClearance::clearBuildingCollision(*elBuilding, args.pos, removedBuildings, args.flags, totalCost)); } case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::noCollision); } return RoadClearFunctionResult(World::TileClearance::clearTreeCollision(*elTree, args.pos, args.flags, totalCost)); } case World::ElementType::road: { auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { return clearRoad(*elRoad, args); } break; } case World::ElementType::surface: case World::ElementType::wall: case World::ElementType::industry: return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collision); } return RoadClearFunctionResult(World::TileClearance::ClearFuncResult::collision); } // 0x00475FBC static uint32_t createRoad(const RoadPlacementArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3{ 16, 16, 0 }); _byte_1136072 = ElementPositionFlags::none; _byte_1136073 = 0; // Bridge related _byte_1136074 = 0; _byte_1136075 = 0xFFU; _alternateTrackObjectId = 0xFFU; const auto companyId = SceneManager::isEditorMode() ? CompanyId::neutral : getUpdatingCompanyId(); if ((flags & Flags::apply) && !(flags & Flags::aiAllocated) && companyId != CompanyId::neutral) { companySetObservation(getUpdatingCompanyId(), ObservationStatus::buildingTrackRoad, args.pos, EntityId::null, args.roadObjectId | (1U << 7)); } if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } auto* roadObj = ObjectManager::get<RoadObject>(args.roadObjectId); const auto compatFlags = World::TrackData::getRoadMiscData(args.roadId).compatibleFlags; uint8_t validMods = args.mods; for (auto i = 0U; i < 2; ++i) { if (args.mods & (1U << i)) { auto* extraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); if ((compatFlags & extraObj->roadPieces) != compatFlags) { validMods &= ~(1U << i); } } } if (args.pos.z & 0xF) { return FAILURE; } currency32_t totalCost = 0; { const auto roadBaseCost = Economy::getInflationAdjustedCost(roadObj->buildCostFactor, roadObj->costIndex, 10); const auto cost = (roadBaseCost * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; totalCost += cost; } for (auto i = 0U; i < 2; ++i) { if (validMods & (1U << i)) { auto* extraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(extraObj->buildCostFactor, extraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; totalCost += cost; } } auto& roadPieces = World::TrackData::getRoadPiece(args.roadId); World::TileClearance::RemovedBuildings removedBuildings; // 0x0113C2EC bool hasStation = false; // 0x0112C2EA StationId stationId = StationId::null; std::array<uint8_t, 16> roadIdUnk = {}; roadIdUnk[args.roadId] |= 1U << args.rotation; for (auto& piece : roadPieces) { const auto roadLoc = args.pos + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; const auto quarterTile = piece.subTileClearance.rotate(args.rotation); const auto unk = Numerics::rotl4bit(enumValue(piece.flags) & 0xF, args.rotation); if (roadLoc.z < 16) { setErrorText(StringIds::error_too_low); return FAILURE; } const auto baseZ = roadLoc.z / World::kSmallZStep; auto clearZ = baseZ + (piece.clearZ + 32) / World::kSmallZStep; _byte_1136073 = _byte_1136073 & ~(1U << 1); // Why aren't we just failing invalid??? if (World::validCoords(roadLoc)) { const auto tile = World::TileManager::get(roadLoc); auto* elSurface = tile.surface(); if (elSurface->water()) { _byte_1136073 = _byte_1136073 | (1U << 7); } const bool requiresBridge = isBridgeRequired(baseZ, *elSurface, piece, unk); if (requiresBridge) { // 0x004762CD _byte_1136073 = _byte_1136073 | (1U << 1) | (1U << 0); World::MicroZ heightDiff = (baseZ - elSurface->baseZ()) / World::kMicroToSmallZStep; if (args.bridge == 0xFFU) { setErrorText(StringIds::bridge_needed); return FAILURE; } auto* bridgeObj = ObjectManager::get<BridgeObject>(args.bridge); if (heightDiff > bridgeObj->maxHeight) { setErrorText(StringIds::too_far_above_ground_for_bridge_type); return FAILURE; } _byte_1136074 = std::max(heightDiff, *_byte_1136074); if ((bridgeObj->disabledTrackCfg & World::TrackData::getRoadMiscData(args.roadId).flags) != CommonTraitFlags::none) { setErrorText(StringIds::bridge_type_unsuitable_for_this_configuration); return FAILURE; } clearZ += bridgeObj->clearHeight / World::kSmallZStep; } } // 0x0047632B if (clearZ > 236) { setErrorText(StringIds::error_too_high); return FAILURE; } // 0x0113C2E2 bool hasLevelCrossing = false; // 0x0113C2E3 uint8_t levelCrossingObjId = 0xFFU; ClearFunctionArgs clearArgs{}; clearArgs.pos = roadLoc; clearArgs.rotation = args.rotation; clearArgs.roadId = args.roadId; clearArgs.bridgeId = args.bridge; clearArgs.roadObjectId = args.roadObjectId; clearArgs.index = piece.index; clearArgs.isLastIndex = piece.index == (roadPieces.size() - 1); clearArgs.flags = flags; clearArgs.unkFlags = args.unkFlags; auto clearFunc = [&totalCost, &hasLevelCrossing, &hasStation, &removedBuildings, &levelCrossingObjId, &stationId, &roadIdUnk, &clearArgs](World::TileElement& el) { const auto res = clearFunction(el, totalCost, removedBuildings, clearArgs); hasLevelCrossing |= res.hasLevelCrossing; hasStation |= res.hasStation; if (res.levelCrossingObjId != 0xFFU) { levelCrossingObjId = res.levelCrossingObjId; } if (res.stationId != StationId::null) { stationId = res.stationId; } for (auto i = 0U; i < std::size(roadIdUnk); ++i) { roadIdUnk[i] |= res.roadIdUnk[i]; } return res.res; }; if (!World::TileClearance::applyClearAtStandardHeight(roadLoc, baseZ, clearZ, quarterTile, clearFunc)) { return FAILURE; } if (levelCrossingObjId == 0xFFU) { levelCrossingObjId = getGameState().currentDefaultLevelCrossingType; } if (hasLevelCrossing) { auto* levelCrossObj = ObjectManager::get<LevelCrossingObject>(levelCrossingObjId); totalCost += Economy::getInflationAdjustedCost(levelCrossObj->costFactor, levelCrossObj->costIndex, 10); } if ((flags & Flags::apply) && !(flags & (Flags::ghost | Flags::aiAllocated))) { World::TileManager::removeAllWallsOnTileBelow(World::toTileSpace(roadLoc), baseZ); } // 0x00476408 const auto posFlags = World::TileClearance::getPositionFlags(); // Abridged flags for just above/underground const auto newGroundFlags = posFlags & (ElementPositionFlags::aboveGround | ElementPositionFlags::underground); if (_byte_1136072 != ElementPositionFlags::none && (*_byte_1136072 & newGroundFlags) == ElementPositionFlags::none) { setErrorText(StringIds::cant_build_partly_above_partly_below_ground); return FAILURE; } _byte_1136072 = newGroundFlags; if ((posFlags & ElementPositionFlags::partiallyUnderwater) != ElementPositionFlags::none) { setErrorText(StringIds::cant_build_this_underwater); return FAILURE; } if ((posFlags & ElementPositionFlags::underwater) != ElementPositionFlags::none) { setErrorText(StringIds::too_close_to_water_surface); return FAILURE; } if (!(flags & Flags::apply)) { continue; } if (CompanyManager::isPlayerCompany(companyId)) { companyEmotionEvent(getUpdatingCompanyId(), Emotion::thinking); } if (!(flags & (Flags::ghost | Flags::aiAllocated))) { World::TileManager::removeSurfaceIndustryAtHeight(roadLoc); World::TileManager::setTerrainStyleAsClearedAtHeight(roadLoc); } auto* newElRoad = World::TileManager::insertElementRoad(roadLoc, baseZ, quarterTile.getBaseQuarterOccupied()); if (newElRoad == nullptr) { return FAILURE; } newElRoad->setClearZ(clearZ); newElRoad->setRotation(args.rotation); newElRoad->setRoadObjectId(args.roadObjectId); newElRoad->setSequenceIndex(piece.index); newElRoad->setRoadId(args.roadId); newElRoad->setOwner(companyId); for (auto i = 0U; i < 2; ++i) { if (validMods & (1U << i)) { newElRoad->setMod(i, true); } } if ((getGameState().roadObjectIdIsNotTram & (1U << args.roadObjectId)) && companyId != CompanyId::neutral) { newElRoad->setUnk7_40(true); } newElRoad->setBridgeObjectId(args.bridge); newElRoad->setHasBridge(_byte_1136073 & (1U << 1)); if (hasLevelCrossing && !(flags & Flags::aiAllocated)) { newElRoad->setHasLevelCrossing(true); newElRoad->setLevelCrossingObjectId(levelCrossingObjId); } else { newElRoad->setHasLevelCrossing(false); newElRoad->setLevelCrossingObjectId(0); } newElRoad->setHasStationElement(hasStation); newElRoad->setFlag6(piece.index == (roadPieces.size() - 1)); newElRoad->setGhost(flags & Flags::ghost); newElRoad->setAiAllocated(flags & Flags::aiAllocated); if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(roadLoc); } } // TODO: Verify if we remembered to do this for track if (flags & Flags::apply) { auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; } // 0x47656B if ((flags & Flags::apply) && !(flags & (Flags::aiAllocated | Flags::ghost)) && (roadIdUnk[0] & (1U << 7)) && roadObj->hasFlags(RoadObjectFlags::unk_02)) { for (auto i = 0U; i < 4; ++i) { const auto rot0 = i; const auto rot1 = (i + 1) & 0x3; const auto rot2 = (i + 2) & 0x3; const auto rot3 = (i + 3) & 0x3; const auto rot0Flag = (1U << rot0); const auto rot1Flag = (1U << rot1); const auto rot2Flag = (1U << rot2); const auto rot3Flag = (1U << rot3); auto placeAddition = [&args, companyId, validMods, flags](uint8_t rotation, uint8_t roadId) { World::TileManager::removeSurfaceIndustryAtHeight(args.pos); World::TileManager::setTerrainStyleAsClearedAtHeight(args.pos); auto* newElRoad = World::TileManager::insertElement<World::RoadElement>(args.pos, args.pos.z / World::kSmallZStep, 0xFU); if (newElRoad == nullptr) { return; } newElRoad->setClearZ(args.pos.z / World::kSmallZStep + 8); newElRoad->setRotation(rotation); newElRoad->setRoadObjectId(args.roadObjectId); newElRoad->setSequenceIndex(0); newElRoad->setRoadId(roadId); newElRoad->setOwner(companyId); for (auto i = 0U; i < 2; ++i) { if (validMods & (1U << i)) { newElRoad->setMod(i, true); } } newElRoad->setBridgeObjectId(args.bridge); newElRoad->setHasBridge(_byte_1136073 & (1U << 1)); newElRoad->setFlag6(true); newElRoad->setGhost(flags & Flags::ghost); newElRoad->setAiAllocated(flags & Flags::aiAllocated); }; auto requiresAdditionalLeft = [&roadIdUnk, rot0Flag, rot1Flag, rot2Flag, rot3Flag]() { if ((roadIdUnk[0] & rot0Flag) && ((roadIdUnk[0] & rot3Flag) || (roadIdUnk[0] & rot1Flag) || (roadIdUnk[1] & rot1Flag) || (roadIdUnk[2] & rot2Flag))) { return true; } if ((roadIdUnk[0] & rot2Flag) && (roadIdUnk[0] & rot3Flag)) { return true; } if ((roadIdUnk[0] & rot3Flag) && ((roadIdUnk[2] & rot0Flag) || (roadIdUnk[1] & rot3Flag))) { return true; } if ((roadIdUnk[2] & rot0Flag) && ((roadIdUnk[1] & rot1Flag) || (roadIdUnk[2] & rot2Flag))) { return true; } if ((roadIdUnk[1] & rot3Flag) && ((roadIdUnk[1] & rot1Flag) || (roadIdUnk[2] & rot2Flag))) { return true; } if ((roadIdUnk[0] & rot1Flag) && (roadIdUnk[2] & rot0Flag)) { return true; } return false; }; if (requiresAdditionalLeft()) { if (!(roadIdUnk[2] & rot1Flag)) { bool place = !(roadIdUnk[1] & rot0Flag); roadIdUnk[1] |= rot0Flag; if (place) { placeAddition(i, 1); } } } // 0x0047677A auto requiresAdditionalRight = [&roadIdUnk, rot0Flag, rot1Flag, rot2Flag, rot3Flag]() { if ((roadIdUnk[0] & rot2Flag) && ((roadIdUnk[2] & rot2Flag) || (roadIdUnk[1] & rot1Flag))) { return true; } if ((roadIdUnk[1] & rot0Flag) && ((roadIdUnk[1] & rot2Flag) || (roadIdUnk[2] & rot3Flag))) { return true; } if ((roadIdUnk[2] & rot1Flag) && ((roadIdUnk[1] & rot2Flag) || (roadIdUnk[2] & rot3Flag))) { return true; } if ((roadIdUnk[0] & rot1Flag) && ((roadIdUnk[0] & rot2Flag) || (roadIdUnk[1] & rot3Flag))) { return true; } return false; }; if (requiresAdditionalRight()) { if (!(roadIdUnk[1] & rot0Flag)) { bool place = !(roadIdUnk[2] & rot1Flag); roadIdUnk[2] |= rot1Flag; if (place) { placeAddition(i + 1, 2); } } } // 0x004768F0 auto requiresAdditionalStraight1 = [&roadIdUnk, rot0Flag, rot1Flag, rot2Flag, rot3Flag]() { if ((roadIdUnk[1] & rot0Flag) && ((roadIdUnk[1] & rot1Flag) || (roadIdUnk[2] & rot2Flag))) { return true; } if ((roadIdUnk[2] & rot0Flag) && ((roadIdUnk[1] & rot1Flag) || (roadIdUnk[2] & rot2Flag))) { return true; } if ((roadIdUnk[1] & rot3Flag) && ((roadIdUnk[1] & rot1Flag) || (roadIdUnk[2] & rot2Flag))) { return true; } if ((roadIdUnk[1] & rot0Flag) && ((roadIdUnk[1] & rot2Flag) || (roadIdUnk[2] & rot3Flag))) { return true; } if ((roadIdUnk[2] & rot1Flag) && ((roadIdUnk[1] & rot2Flag) || (roadIdUnk[2] & rot3Flag))) { return true; } if ((roadIdUnk[2] & rot1Flag) && (roadIdUnk[1] & rot1Flag)) { return true; } return false; }; if (requiresAdditionalStraight1()) { if (!(roadIdUnk[0] & rot2Flag)) { bool place = !(roadIdUnk[0] & rot0Flag); roadIdUnk[0] |= rot0Flag; if (place) { placeAddition(i, 0); } } } // 0x00476AB2 auto requiresAdditionalStraight2 = [&roadIdUnk, rot1Flag, rot2Flag]() { if ((roadIdUnk[2] & rot1Flag) && (roadIdUnk[2] & rot2Flag)) { return true; } return false; }; if (requiresAdditionalStraight2()) { if (!(roadIdUnk[0] & rot2Flag)) { bool place = !(roadIdUnk[0] & rot0Flag); roadIdUnk[0] |= rot0Flag; if (place) { placeAddition(i, 0); } } } } } if ((_byte_1136073 & (1U << 0)) && !(_byte_1136073 & (1U << 6))) { auto* bridgeObj = ObjectManager::get<BridgeObject>(args.bridge); const auto heightCost = _byte_1136074 * bridgeObj->heightCostFactor; const auto bridgeBaseCost = Economy::getInflationAdjustedCost(bridgeObj->baseCostFactor + heightCost, bridgeObj->costIndex, 10); auto cost = (bridgeBaseCost * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; if (_byte_1136073 & (1U << 7)) { cost *= 2; } totalCost += cost; } if (((_byte_1136072 & ElementPositionFlags::underground) != ElementPositionFlags::none) && !(_byte_1136073 & (1U << 6))) { const auto tunnelBaseCost = Economy::getInflationAdjustedCost(roadObj->tunnelCostFactor, 2, 8); auto cost = (tunnelBaseCost * World::TrackData::getTrackMiscData(args.roadId).costFactor) / 256; totalCost += cost; } if ((flags & Flags::apply) && hasStation) { auto* station = StationManager::get(stationId); station->invalidate(); recalculateStationModes(stationId); recalculateStationCenter(stationId); station->updateLabel(); station->invalidate(); } if ((flags & Flags::apply) && !(flags & (Flags::aiAllocated | Flags::ghost)) && getUpdatingCompanyId() != CompanyId::neutral && totalCost != 0) { playConstructionPlacementSound(getPosition()); } return totalCost; } void createRoad(registers& regs) { regs.ebx = createRoad(RoadPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/CreateRoad.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RoadPlacementArgs { static constexpr auto command = GameCommand::createRoad; RoadPlacementArgs() = default; explicit RoadPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadId(regs.dh & 0xF) , mods(regs.edi >> 16) , bridge((regs.edx >> 24) & 0xFF) , roadObjectId(regs.dl) , unkFlags((regs.edx >> 16) & 0xFF) { } World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t mods; uint8_t bridge; uint8_t roadObjectId; uint8_t unkFlags; explicit operator registers() const { registers regs; regs.eax = pos.x; regs.cx = pos.y; regs.edi = (0xFFFFU & pos.z) | (mods << 16); regs.bh = rotation; regs.edx = roadObjectId | (roadId << 8) | (unkFlags << 16) | (bridge << 24); return regs; } }; void createRoad(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/CreateRoadMod.cpp ```cpp #include "CreateRoadMod.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" namespace OpenLoco::GameCommands { static World::RoadElement* getRoadElement(const RoadModsPlacementArgs& args) { auto tile = World::TileManager::get(args.pos); for (auto& element : tile) { auto* roadEl = element.as<World::RoadElement>(); if (roadEl == nullptr) { continue; } if (roadEl->baseHeight() != args.pos.z) { continue; } if (roadEl->rotation() != args.rotation) { continue; } if (roadEl->rotation() != args.rotation) { continue; } if (roadEl->sequenceIndex() != args.index) { continue; } if (roadEl->roadObjectId() != args.roadObjType) { continue; } if (roadEl->roadId() != args.roadId) { continue; } return roadEl; } return nullptr; } // 0x0047A21E static uint32_t createRoadMod(const RoadModsPlacementArgs& args, uint8_t flags) { auto* roadEl = getRoadElement(args); if (roadEl == nullptr || !sub_431E6A(roadEl->owner(), reinterpret_cast<const World::TileElement*>(roadEl))) { return FAILURE; } auto& piece = World::TrackData::getRoadPiece(args.roadId)[roadEl->sequenceIndex()]; const auto roadLoc = World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; // 0x0047A34C const auto firstTilePos = args.pos - roadLoc; const auto rad = Vehicles::TrackAndDirection::_RoadAndDirection(roadEl->roadId(), roadEl->rotation()); auto result = Vehicles::applyRoadModsToTrackNetwork(firstTilePos, rad, roadEl->owner(), args.roadObjType, flags, args.modSection, args.type); if (result.allPlacementsFailed) { setErrorText(StringIds::track_road_unsuitable); return FAILURE; } if (result.networkTooComplex && (flags & Flags::apply) && !(flags & Flags::ghost)) { Ui::Windows::Error::open(StringIds::null, StringIds::too_much_track_some_track_not_upgraded); } return result.cost; } void createRoadMod(registers& regs) { regs.ebx = createRoadMod(RoadModsPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/CreateRoadMod.h ```h #pragma once #include "GameCommands/GameCommands.h" #include "Map/Track/TrackModSection.h" namespace OpenLoco::GameCommands { struct RoadModsPlacementArgs { static constexpr auto command = GameCommand::createRoadMod; RoadModsPlacementArgs() = default; explicit RoadModsPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadId(regs.dl & 0xF) , index(regs.dh & 0x3) , type((regs.edi >> 16) & 0xF) , roadObjType(regs.ebp & 0xFF) , modSection(static_cast<World::Track::ModSection>((regs.ebp >> 16) & 0xFF)) { } World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t index; uint8_t type; uint8_t roadObjType; World::Track::ModSection modSection; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.dl = roadId; regs.dh = index; regs.edi = pos.z | (type << 16); regs.ebp = roadObjType | (enumValue(modSection) << 16); return regs; } }; void createRoadMod(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/CreateRoadStation.cpp ```cpp #include "CreateRoadStation.h" #include "Economy/Economy.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/RoadStationObject.h" #include "ViewportManager.h" #include "World/CompanyManager.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { static loco_global<StationId, 0x0112C730> _lastPlacedTrackStationId; static loco_global<bool, 0x0112C7A9> _112C7A9; static loco_global<uint32_t, 0x00112C734> _lastConstructedAdjoiningStationId; // Can be 0xFFFF'FFFFU for no adjoining station static loco_global<World::Pos2, 0x00112C792> _lastConstructedAdjoiningStationCentrePos; // Can be x = -1 for no adjoining station // 0x004900B8 static StationManager::NearbyStation findNearbyStationOnRoad(World::Pos3 pos, uint16_t tad, uint8_t roadObjectId) { { auto [nextPos, nextRotation] = World::Track::getRoadConnectionEnd(pos, tad); const auto rc = World::Track::getRoadConnections(nextPos, nextRotation, getUpdatingCompanyId(), roadObjectId, 0, 0); if (rc.stationId != StationId::null) { if (StationManager::get(rc.stationId)->owner == getUpdatingCompanyId()) { return StationManager::NearbyStation{ rc.stationId, true }; } } } { auto tailTaD = tad; const auto& roadSize = World::TrackData::getUnkRoad(tailTaD); auto tailPos = pos + roadSize.pos; if (roadSize.rotationEnd < 12) { tailPos -= World::Pos3{ World::kRotationOffset[roadSize.rotationEnd], 0 }; } tailTaD ^= (1U << 2); // Reverse auto [nextTailPos, nextTailRotation] = World::Track::getRoadConnectionEnd(tailPos, tailTaD); const auto tailRc = World::Track::getRoadConnections(nextTailPos, nextTailRotation, getUpdatingCompanyId(), roadObjectId, 0, 0); if (tailRc.stationId != StationId::null) { if (StationManager::get(tailRc.stationId)->owner == getUpdatingCompanyId()) { return StationManager::NearbyStation{ tailRc.stationId, true }; } } } return StationManager::findNearbyStation(pos, getUpdatingCompanyId()); } enum class NearbyStationValidation { okay, requiresNewStation, failure, }; // 0x0048CA3E & 0x0048C9C8 static std::pair<NearbyStationValidation, StationId> validateNearbyStation(const World::Pos3 pos, const uint16_t tad, const uint8_t trackObjectId) { auto nearbyStation = findNearbyStationOnRoad(pos, tad, trackObjectId); if (nearbyStation.id == StationId::null) { return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } // _lastPlacedTrackStationId = nearbyStation.id; set in callers auto* station = StationManager::get(nearbyStation.id); if (station->stationTileSize >= std::size(station->stationTiles)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_large); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } else { if (StationManager::exceedsStationSize(*station, pos)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_large); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } } return std::make_pair(NearbyStationValidation::okay, nearbyStation.id); } static World::RoadElement* getElRoad(World::Pos3 pos, uint8_t rotation, uint8_t roadObjectId, uint8_t roadId, uint8_t index) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != pos.z) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->roadId() != roadId) { continue; } if (elRoad->roadObjectId() != roadObjectId) { continue; } if (elRoad->sequenceIndex() != index) { continue; } return elRoad; } return nullptr; } static bool elRoadIsJunctionAi(World::Pos3 pos, uint8_t rotation) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != pos.z) { continue; } if (elRoad->isGhost()) { continue; } if (elRoad->roadId() != 0) { return true; } if ((elRoad->rotation() - rotation) & 0b01) { return true; } } return false; } // 0x0048BAF5 static World::TileClearance::ClearFuncResult clearFunc0(World::TileElement& el, World::RoadElement* elReferenceRoad0, World::RoadElement* elReferenceRoad1) { auto* elStation = el.as<World::StationElement>(); auto* elRoad = el.as<World::RoadElement>(); if (elStation != nullptr) { if (elStation->stationType() == StationType::roadStation) { return World::TileClearance::ClearFuncResult::noCollision; } } else if (elRoad != nullptr && elReferenceRoad0 != nullptr && elReferenceRoad1 != nullptr && (elRoad > elReferenceRoad0 && elRoad <= elReferenceRoad1)) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; }; // TODO THIS IS A DUPLICATE MOVE TO SOMEWHERE ELSE // 0x0048BAE5 static World::TileClearance::ClearFuncResult clearFuncCollideWithSurface(World::TileElement& el) { auto* elSurface = el.as<World::SurfaceElement>(); if (elSurface != nullptr) { return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::noCollision; }; // 0x0048C708 static currency32_t createRoadStation(const RoadStationPlacementArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); _lastPlacedTrackStationId = StationId::null; _lastConstructedAdjoiningStationCentrePos = World::Pos2(-1, -1); _lastConstructedAdjoiningStationId = 0xFFFFFFFFU; auto* stationObj = ObjectManager::get<RoadStationObject>(args.type); const auto trackIdCompatFlags = World::TrackData::getRoadMiscData(args.roadId).compatibleFlags; const auto compatibleTrack = stationObj->roadPieces & trackIdCompatFlags; if (compatibleTrack != trackIdCompatFlags) { setErrorText(StringIds::track_road_unsuitable_for_station); return FAILURE; } if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } if (!(flags & Flags::apply)) { if (stationObj->hasFlags(RoadStationFlags::roadEnd)) { const uint16_t tad = (0 << 3) | args.rotation; const auto roadEnd = World::Track::getRoadConnectionEnd(args.pos, tad); const auto rc = World::Track::getRoadConnections(roadEnd.nextPos, roadEnd.nextRotation, getUpdatingCompanyId(), args.roadObjectId, 0, 0); if (!rc.connections.empty()) { // Check other side of road const uint16_t tad2 = (1 << 2) | args.rotation; const auto roadEnd2 = World::Track::getRoadConnectionEnd(args.pos, tad2); const auto rc2 = World::Track::getRoadConnections(roadEnd2.nextPos, roadEnd2.nextRotation, getUpdatingCompanyId(), args.roadObjectId, 0, 0); if (!rc2.connections.empty()) { setErrorText(StringIds::station_type_can_only_be_built_at_road_ends); return FAILURE; } } } } auto* initialElRoad = getElRoad(args.pos, args.rotation, args.roadObjectId, args.roadId, args.index); auto index = args.index; bool unk112C7F3 = false; if (initialElRoad == nullptr) { if (flags & Flags::apply) { return FAILURE; } if (!(flags & Flags::aiAllocated)) { return FAILURE; } // Why??? index = 0; unk112C7F3 = true; } else { if ((flags & Flags::aiAllocated) && initialElRoad->hasStationElement()) { setErrorText(StringIds::empty); return FAILURE; } if (initialElRoad->hasStationElement()) { auto* elStation = getStationElement(args.pos); // Will happen if its an aiAllocated station if (elStation == nullptr) { setErrorText(StringIds::empty); return FAILURE; } // Do not allow replacing station elements owned by other companies if (!sub_431E6A(elStation->owner(), reinterpret_cast<const World::TileElement*>(elStation))) { return FAILURE; } // Otherwise, allow replacement } } auto& roadPieces = World::TrackData::getRoadPiece(args.roadId); auto& argPiece = roadPieces[index]; const auto roadStart = args.pos - World::Pos3(Math::Vector::rotate(World::Pos2(argPiece.x, argPiece.y), args.rotation), argPiece.z); if ((flags & Flags::ghost) && (flags & Flags::apply)) { _lastConstructedAdjoiningStationCentrePos = roadStart; uint16_t tad = (args.roadId << 3) | args.rotation; auto nearbyStation = findNearbyStationOnRoad(roadStart, tad, args.roadObjectId); _lastConstructedAdjoiningStationId = static_cast<int16_t>(nearbyStation.id); } if (!(flags & Flags::ghost)) { if (flags & Flags::apply) { auto [result, nearbyStationId] = validateNearbyStation(roadStart, (args.roadId << 3) | args.rotation, args.roadObjectId); switch (result) { case NearbyStationValidation::failure: // Odd??? break; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(roadStart, getUpdatingCompanyId(), 0); if (newStationId != StationId::null) { _lastPlacedTrackStationId = newStationId; auto* station = StationManager::get(newStationId); station->updateLabel(); } } break; case NearbyStationValidation::okay: _lastPlacedTrackStationId = nearbyStationId; break; } _112C7A9 = true; } else { // Same as the other branch but deallocate after allocating and return failure on failure auto [result, nearbyStationId] = validateNearbyStation(roadStart, (args.roadId << 3) | args.rotation, args.roadObjectId); switch (result) { case NearbyStationValidation::failure: return FAILURE; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(roadStart, getUpdatingCompanyId(), 0); if (newStationId == StationId::null) { return FAILURE; } StationManager::deallocateStation(newStationId); // _lastPlacedTrackStationId not set but that's fine since this is the no apply side } break; case NearbyStationValidation::okay: _lastPlacedTrackStationId = nearbyStationId; break; } } } currency32_t totalCost = 0; for (auto& piece : roadPieces) { const auto roadLoc = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; if (unk112C7F3) { if (elRoadIsJunctionAi(roadLoc, args.rotation)) { setErrorText(StringIds::station_cannot_be_built_on_a_junction); return FAILURE; } } else { auto* elRoad = getElRoad(roadLoc, args.rotation, args.roadObjectId, args.roadId, piece.index); if (elRoad == nullptr) { return FAILURE; } if (elRoad->hasSignalElement()) { setErrorText(StringIds::signal_in_the_way); return FAILURE; } if (elRoad->hasLevelCrossing()) { setErrorText(StringIds::level_crossing_in_the_way); return FAILURE; } if (elRoad->roadId() == 0) { if (elRoadIsJunctionAi(roadLoc, args.rotation)) { setErrorText(StringIds::station_cannot_be_built_on_a_junction); return FAILURE; } } else { // Connect flags validation const auto connectFlags = piece.connectFlags[elRoad->rotation()]; auto tile = World::TileManager::get(roadLoc); for (auto& el : tile) { auto* elConnectRoad = el.as<World::RoadElement>(); if (elConnectRoad == nullptr) { continue; } if (elConnectRoad == elRoad) { continue; } if (elConnectRoad->baseHeight() != roadLoc.z) { continue; } if (elConnectRoad->isGhost()) { continue; } auto& connectPiece = World::TrackData::getRoadPiece(elConnectRoad->roadId())[elConnectRoad->sequenceIndex()]; if (connectFlags & connectPiece.connectFlags[elConnectRoad->rotation()]) { setErrorText(StringIds::station_cannot_be_built_on_a_junction); return FAILURE; } } } } bool unk112C7F4 = false; // 0x0112C738 & 0x0112C73C std::array<World::RoadElement*, 2> elRoads = { nullptr, nullptr, }; { auto tile = World::TileManager::get(roadLoc); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != roadLoc.z) { continue; } auto* roadObj2 = ObjectManager::get<RoadObject>(elRoad->roadObjectId()); if (stationObj->hasFlags(RoadStationFlags::roadEnd) && !roadObj2->hasFlags(RoadObjectFlags::isRoad)) { auto formatter = FormatArguments::common(); formatter.push(roadObj2->name); setErrorText(StringIds::station_not_compatible_with_string_id); return FAILURE; } if (roadObj2->hasFlags(RoadObjectFlags::unk_03) || roadObj2->hasFlags(RoadObjectFlags::unk_07) || sub_431E6A(elRoad->owner(), &el)) { unk112C7F4 = true; } bool isCompatible = false; for (auto i = 0U; i < stationObj->numCompatible; ++i) { if (elRoad->roadObjectId() == stationObj->mods[i]) { elRoads[1] = elRoad; if (elRoads[0] == nullptr) { elRoads[0] = elRoad; } isCompatible = true; break; } } if (isCompatible) { continue; } for (auto i = 0U; i < roadObj2->numStations; ++i) { if (roadObj2->stations[i] == args.type) { elRoads[1] = elRoad; if (elRoads[0] == nullptr) { elRoads[0] = elRoad; } isCompatible = true; break; } } if (isCompatible) { continue; } // if neither above for loop auto formatter = FormatArguments::common(); formatter.push(roadObj2->name); setErrorText(StringIds::wrong_type_of_station_for_string_id); return FAILURE; } if (!unk112C7F4 && !unk112C7F3) { return FAILURE; } } // Calculate station costs if (piece.index == 0) { bool calculateCost = true; // Replace station if it already exists if (!unk112C7F3 && elRoads[1]->hasStationElement()) { auto* elStation = elRoads[1]->next()->as<World::StationElement>(); if (elStation == nullptr) { return FAILURE; } if (elStation->objectId() == args.type) { calculateCost = false; } else { auto* oldStationObj = ObjectManager::get<RoadStationObject>(elStation->objectId()); auto removeCostBase = Economy::getInflationAdjustedCost(oldStationObj->sellCostFactor, oldStationObj->costIndex, 8); const auto cost = (removeCostBase * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; totalCost += cost; } } if (calculateCost) { auto placementCostBase = Economy::getInflationAdjustedCost(stationObj->buildCostFactor, stationObj->costIndex, 8); const auto cost = (placementCostBase * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; totalCost += cost; } } // Perform clearance const auto baseZ = (roadStart.z / World::kSmallZStep); // Vanilla bug? should really be roadLoc.z const auto clearZ = baseZ + 8 + stationObj->height / World::kSmallZStep; World::QuarterTile qt(0b1111, 0); auto clearFunc = [&elRoads](World::TileElement& el) { return clearFunc0(el, elRoads[0], elRoads[1]); }; // Perform clearance at just the road clear height to road clear height + station height if (!World::TileClearance::applyClearAtStandardHeight(roadLoc, baseZ + 8, clearZ, qt, clearFunc)) { return FAILURE; } if (!(flags & Flags::aiAllocated)) { // Perform clearance at full station height (only checks for surface collisions) if (!World::TileClearance::applyClearAtStandardHeight(roadLoc, baseZ, clearZ, qt, clearFuncCollideWithSurface)) { return FAILURE; } } // elTrack is still valid as applyClearAtStandardHeight set to not remove anything // this will need changed if ever a different clear function is used if (!unk112C7F3 && elRoads[1]->hasStationElement() && (flags & Flags::ghost)) { // ????? setErrorText(StringIds::empty); return FAILURE; } if (!(flags & Flags::apply)) { continue; } if (CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { companyEmotionEvent(getUpdatingCompanyId(), Emotion::thinking); } World::StationElement* newStationElement = nullptr; // Actually place the new station if (elRoads[1]->hasStationElement()) { auto* elStation = elRoads[1]->next()->as<World::StationElement>(); if (elStation == nullptr) { return FAILURE; } auto* oldStationObj = ObjectManager::get<RoadStationObject>(elStation->objectId()); for (auto elRoad = elRoads[0]; elRoad <= elRoads[1]; ++elRoad) { elRoad->setClearZ(elRoad->clearZ() - oldStationObj->height / World::kSmallZStep); } _112C7A9 = false; Ui::ViewportManager::invalidate(roadLoc, elStation->baseHeight(), elStation->clearHeight()); newStationElement = elStation; } else { // elTrack pointer will be invalid after this call newStationElement = World::TileManager::insertElementAfterNoReorg<World::StationElement>( reinterpret_cast<World::TileElement*>(elRoads[1]), roadLoc, elRoads[1]->baseZ(), elRoads[1]->occupiedQuarter()); if (newStationElement == nullptr) { return FAILURE; } elRoads[0] = nullptr; elRoads[1] = nullptr; auto tile = World::TileManager::get(roadLoc); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != roadLoc.z) { continue; } elRoads[1] = elRoad; if (elRoads[0] == nullptr) { elRoads[0] = elRoad; } } newStationElement->setRotation(elRoads[1]->rotation()); newStationElement->setGhost(flags & Flags::ghost); newStationElement->setAiAllocated(flags & Flags::aiAllocated); newStationElement->setSequenceIndex(0); newStationElement->setUnk4SLR4(0); newStationElement->setStationType(StationType::roadStation); newStationElement->setBuildingType(0); if (!(flags & Flags::ghost)) { newStationElement->setStationId(_lastPlacedTrackStationId); } else { newStationElement->setStationId(static_cast<StationId>(0)); } for (auto elRoad = elRoads[0]; elRoad <= elRoads[1]; ++elRoad) { elRoad->setHasStationElement(true); } } newStationElement->setObjectId(args.type); for (auto elRoad = elRoads[0]; elRoad <= elRoads[1]; ++elRoad) { elRoad->setClearZ(elRoad->clearZ() + stationObj->height / World::kSmallZStep); } newStationElement->setClearZ(elRoads[0]->clearZ()); newStationElement->setOwner(getUpdatingCompanyId()); Ui::ViewportManager::invalidate(roadLoc, newStationElement->baseHeight(), newStationElement->clearHeight()); } if (!(flags & Flags::ghost) && (flags & Flags::apply)) { if (_112C7A9) { addTileToStation(_lastPlacedTrackStationId, roadStart, args.rotation); } auto* station = StationManager::get(_lastPlacedTrackStationId); station->invalidate(); recalculateStationModes(_lastPlacedTrackStationId); recalculateStationCenter(_lastPlacedTrackStationId); station->updateLabel(); station->invalidate(); } return totalCost; } void createRoadStation(registers& regs) { regs.ebx = createRoadStation(RoadStationPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/CreateRoadStation.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RoadStationPlacementArgs { static constexpr auto command = GameCommand::createRoadStation; RoadStationPlacementArgs() = default; explicit RoadStationPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadId(regs.dl & 0xF) , index(regs.dh & 0x3) , roadObjectId(regs.bp) , type(regs.edi >> 16) { } World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t index; uint8_t roadObjectId; uint8_t type; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.edi = pos.z | (type << 16); regs.bh = rotation; regs.dl = roadId; regs.dh = index; regs.bp = roadObjectId; return regs; } }; void createRoadStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/RemoveRoad.cpp ```cpp #include "RemoveRoad.h" #include "Audio/Audio.h" #include "Economy/Economy.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Objects/BridgeObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadExtraObject.h" #include "Objects/RoadObject.h" #include "Random.h" #include "RemoveRoadStation.h" #include "ScenarioOptions.h" #include "SceneManager.h" #include "World/TownManager.h" namespace OpenLoco::GameCommands { using namespace World::TileManager; // Copy of `playTrackRemovalSound` static void playRoadRemovalSound(const World::Pos3 pos) { const auto frequency = gPrng2().randNext(17955, 26146); Audio::playSound(Audio::SoundId::demolish, pos, 0, frequency); } struct OverlapRoads { World::RoadElement* _begin = nullptr; World::RoadElement* _end = nullptr; OverlapRoads(World::Pos3 pos) { auto tile = World::TileManager::get(pos.x, pos.y); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { if (_begin != nullptr) { break; } continue; } if (elRoad->baseZ() != pos.z / World::kSmallZStep) { if (_begin != nullptr) { break; } continue; } _end = elRoad + 1; if (_begin == nullptr) { _begin = elRoad; } } } World::RoadElement* begin() const { return _begin; } World::RoadElement* end() const { return _end; } }; static World::RoadElement* getRoadElement(const World::Pos3 pos, const RoadRemovalArgs& args, uint8_t sequenceIndex, uint8_t flags) { auto tile = World::TileManager::get(pos); const auto baseZ = pos.z / World::kSmallZStep; const auto companyId = SceneManager::isEditorMode() ? CompanyId::neutral : getUpdatingCompanyId(); for (auto& element : tile) { auto* elRoad = element.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseZ() != baseZ) { continue; } if (elRoad->rotation() != args.rotation) { continue; } if (elRoad->sequenceIndex() != sequenceIndex) { continue; } if (elRoad->roadObjectId() != args.objectId) { continue; } if (elRoad->roadId() != args.roadId) { continue; } if (elRoad->isGhost() != ((flags & Flags::ghost) != 0)) { continue; } if (elRoad->isAiAllocated() != ((flags & Flags::aiAllocated) != 0)) { continue; } // Ghost only as this is checked elsewhere for non-ghost so that // neutral company is always allowed if (((flags & Flags::ghost) != 0) && elRoad->owner() != companyId) { return nullptr; } return elRoad; } return nullptr; } // 0x00477A10 static currency32_t roadRemoveCost(const RoadRemovalArgs& args, const World::TrackData::PreviewTrack roadPiece0, const World::Pos3 roadStart, const uint8_t flags) { const auto roadLoc = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ roadPiece0.x, roadPiece0.y }, args.rotation), roadPiece0.z }; auto* roadElPiece = getRoadElement(roadLoc, args, roadPiece0.index, flags); if (roadElPiece == nullptr) { return 0; } currency32_t totalRemovalCost = 0; const auto* roadObj = ObjectManager::get<RoadObject>(roadElPiece->roadObjectId()); if (roadElPiece->owner() != CompanyId::neutral) { const auto trackBaseCost = Economy::getInflationAdjustedCost(roadObj->sellCostFactor, roadObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; totalRemovalCost += cost; } // Check mod removal costs if (!roadObj->hasFlags(RoadObjectFlags::unk_03)) { for (auto i = 0U; i < 2; i++) { if (roadElPiece->hasMod(i)) { const auto* trackExtraObj = ObjectManager::get<RoadExtraObject>(roadObj->mods[i]); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(trackExtraObj->sellCostFactor, trackExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; totalRemovalCost += cost; } } } return totalRemovalCost; } // 0x004775A5 static uint32_t removeRoad(const RoadRemovalArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3{ 16, 16, 0 }); // 0x0047762D auto* roadEl = getRoadElement(args.pos, args, args.sequenceIndex, flags); if (roadEl == nullptr) { return FAILURE; } if (!sub_431E6A(roadEl->owner(), reinterpret_cast<const World::TileElement*>(roadEl))) { return FAILURE; } /* // Remove check for is road in use when removing roads. It is // quite annoying when it's sometimes only the player's own // vehicles that are using it. // TODO: turn this into a setting? if (companyId != CompanyId::neutral && (roadEl->hasUnk7_40() || roadEl->hasUnk7_80())) { setErrorText(StringIds::empty); auto nearest = TownManager::getClosestTownAndDensity(args.pos); if (nearest.has_value()) { auto* town = TownManager::get(nearest->first); FormatArguments::common(town->name); setErrorText(StringIds::stringid_local_authority_wont_allow_removal_in_use); } return FAILURE; } */ currency32_t totalRemovalCost = 0; // 0x004776E3 if (roadEl->hasStationElement()) { // We only want to remove the road station if the target road element is the only // user of the road station. const auto overlaps = OverlapRoads(args.pos); const auto hasOtherRoadStationUsers = std::ranges::any_of(overlaps, [roadEl](const World::RoadElement& el) { if (&el == roadEl) { return false; } return el.hasStationElement(); }); if (!hasOtherRoadStationUsers) { auto tile = World::TileManager::get(args.pos); auto* elStation = tile.roadStation(roadEl->roadId(), roadEl->rotation(), roadEl->baseZ()); if (elStation != nullptr && !elStation->isGhost()) { RoadStationRemovalArgs srArgs = {}; srArgs.pos = args.pos; srArgs.rotation = args.rotation; srArgs.roadId = args.roadId; srArgs.index = args.sequenceIndex; srArgs.roadObjectId = args.objectId; auto stationRemovalRes = GameCommands::doCommand(srArgs, flags); if (stationRemovalRes == FAILURE) { return FAILURE; } totalRemovalCost += stationRemovalRes; } } } // Road element pointer may be invalid after road station removal. roadEl = nullptr; // 0x004777EB bool removeRoadBridge = false; // 0x0112C2CD int8_t roadBridgeId = -1; // 0x0112C2D0 const auto& roadPieces = World::TrackData::getRoadPiece(args.roadId); const auto& currentPart = roadPieces[args.sequenceIndex]; const auto roadStart = args.pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ currentPart.x, currentPart.y }, args.rotation), currentPart.z }; // NB: moved out of the loop below (was at 0x00477A10) const currency32_t pieceRemovalCost = roadRemoveCost(args, roadPieces[0], roadStart, flags); for (auto& piece : roadPieces) { const auto roadLoc = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(roadLoc); } // 0x00477934 auto* roadElPiece = getRoadElement(roadLoc, args, piece.index, flags); if (roadElPiece == nullptr) { continue; } // 0x004779B2 if (roadElPiece->hasBridge()) { const auto overlaps = OverlapRoads(args.pos); const auto numOverlappingRoads = std::ranges::distance(overlaps); // Bridge only removed if this is the only road piece removeRoadBridge = numOverlappingRoads == 1; roadBridgeId = roadElPiece->bridge(); } if (!(flags & Flags::apply)) { continue; } World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(roadElPiece)); Scenario::getOptions().madeAnyChanges = 1; World::TileManager::setLevelCrossingFlags(roadLoc); } // 0x00477A10 totalRemovalCost += pieceRemovalCost; // Seems to have been forgotten in vanilla if (removeRoadBridge) { const auto* bridgeObj = ObjectManager::get<BridgeObject>(roadBridgeId); const auto bridgeBaseCost = Economy::getInflationAdjustedCost(bridgeObj->sellCostFactor, bridgeObj->costIndex, 10); totalRemovalCost += (bridgeBaseCost * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; } // 0x00477B39 if (flags & Flags::apply) { if (!(flags & (Flags::aiAllocated | Flags::ghost))) { if (getUpdatingCompanyId() != CompanyId::neutral) { playRoadRemovalSound(args.pos); } } } return totalRemovalCost; } void removeRoad(registers& regs) { regs.ebx = removeRoad(RoadRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/RemoveRoad.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RoadRemovalArgs { static constexpr auto command = GameCommand::removeRoad; RoadRemovalArgs() = default; explicit RoadRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadId(regs.dl & 0xF) , sequenceIndex(regs.dh & 0x3) , objectId(regs.bp & 0xF) { } World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t sequenceIndex; uint8_t objectId; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = roadId; regs.dh = sequenceIndex; regs.bp = objectId; return regs; } }; void removeRoad(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/RemoveRoadMod.cpp ```cpp #include "RemoveRoadMod.h" #include "Economy/Expenditures.h" #include "Map/RoadElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Math/Vector.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0047A42F static currency32_t removeRoadMod(const RoadModsRemovalArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); auto* elRoad = [&args]() -> const World::RoadElement* { const auto tile = World::TileManager::get(args.pos); for (const auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != args.pos.z) { continue; } if (elRoad->rotation() != args.rotation) { continue; } if (elRoad->sequenceIndex() != args.index) { continue; } if (elRoad->roadObjectId() != args.roadObjType) { continue; } if (elRoad->roadId() != args.roadId) { continue; } return elRoad; } return nullptr; }(); if (elRoad == nullptr) { return FAILURE; } if (!sub_431E6A(elRoad->owner(), reinterpret_cast<const World::TileElement*>(elRoad))) { return FAILURE; } const auto& piece = World::TrackData::getRoadPiece(elRoad->roadId())[elRoad->sequenceIndex()]; const auto offsetToFirstTile = World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, elRoad->rotation()), piece.z }; const auto firstTilePos = args.pos - offsetToFirstTile; const auto tad = Vehicles::TrackAndDirection::_RoadAndDirection(elRoad->roadId(), elRoad->rotation()); auto cost = Vehicles::removeRoadModsToTrackNetwork(firstTilePos, tad, elRoad->owner(), args.roadObjType, flags, args.modSection, args.type); return cost; } void removeRoadMod(registers& regs) { regs.ebx = removeRoadMod(RoadModsRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/RemoveRoadMod.h ```h #pragma once #include "GameCommands/GameCommands.h" #include "Map/Track/TrackModSection.h" namespace OpenLoco::GameCommands { struct RoadModsRemovalArgs { static constexpr auto command = GameCommand::removeRoadMod; RoadModsRemovalArgs() = default; explicit RoadModsRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadId(regs.dl & 0xF) , index(regs.dh & 0x3) , type((regs.edi >> 16) & 0xF) , roadObjType(regs.ebp & 0xFF) , modSection(static_cast<World::Track::ModSection>((regs.ebp >> 16) & 0xFF)) { } World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t index; uint8_t type; uint8_t roadObjType; World::Track::ModSection modSection; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.dl = roadId; regs.dh = index; regs.edi = pos.z | (type << 16); regs.ebp = roadObjType | (enumValue(modSection) << 16); return regs; } }; void removeRoadMod(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/RemoveRoadStation.cpp ```cpp #include "RemoveRoadStation.h" #include "Economy/Economy.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/TileElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Objects/ObjectManager.h" #include "Objects/RoadStationObject.h" #include "ViewportManager.h" #include "World/Station.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { // TODO: based on CreateRoadStation.cpp static World::RoadElement* getElRoad(World::Pos3 pos, uint8_t rotation, uint8_t roadObjectId, uint8_t roadId, uint8_t index) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { continue; } if (elRoad->baseHeight() != pos.z) { continue; } if (elRoad->rotation() != rotation) { continue; } if (elRoad->roadId() != roadId) { continue; } // TODO: not seeing this check in disasm if (elRoad->roadObjectId() != roadObjectId) { continue; } if (elRoad->sequenceIndex() != index) { continue; } return elRoad; } return nullptr; } struct RoadElements { World::RoadElement* begin; World::TileElementBase* end; }; static RoadElements getRoadElementsRange(const World::Pos3& roadLoc) { RoadElements range{ nullptr, nullptr }; auto tile = World::TileManager::get(roadLoc); for (auto& el : tile) { auto* elRoad = el.as<World::RoadElement>(); if (elRoad == nullptr) { if (range.end != nullptr) { break; } continue; } if (elRoad->baseHeight() != roadLoc.z) { if (range.end != nullptr) { break; } continue; } range.end = elRoad->next(); if (range.begin == nullptr) { range.begin = elRoad; } } return range; } // 0x0048D2AC static currency32_t removeRoadStation(const RoadStationRemovalArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); bool updateStationTileRegistration = true; // Get road at position auto* initialElRoad = getElRoad(args.pos, args.rotation, args.roadObjectId, args.roadId, args.index); if (initialElRoad == nullptr) { return FAILURE; } // No station element on this road? if (!initialElRoad->hasStationElement()) { return FAILURE; } // Find the station element for an ownership check { // Station element must be the next element after the last consecutive road element const auto roadRange = getRoadElementsRange(args.pos); if (roadRange.begin == nullptr || roadRange.end == nullptr) { return FAILURE; } World::StationElement* stationEl = roadRange.end->as<World::StationElement>(); if (stationEl == nullptr) { return FAILURE; } // NB: vanilla would query owner from station struct, not the station element if (!sub_431E6A(stationEl->owner(), reinterpret_cast<const World::TileElement*>(stationEl))) { return FAILURE; } } const auto& roadPieces = World::TrackData::getRoadPiece(args.roadId); const auto& argPiece = roadPieces[args.index]; const auto roadStart = args.pos - World::Pos3(Math::Vector::rotate(World::Pos2(argPiece.x, argPiece.y), args.rotation), argPiece.z); StationId foundStationId = StationId::null; currency32_t totalCost = 0; for (auto& piece : roadPieces) { const auto roadLoc = roadStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; const auto roadRange = getRoadElementsRange(args.pos); if (roadRange.begin == nullptr || roadRange.end == nullptr) { return FAILURE; } World::StationElement* stationEl = roadRange.end->as<World::StationElement>(); if (stationEl == nullptr) { return FAILURE; } if (stationEl->isGhost()) { updateStationTileRegistration = false; } foundStationId = stationEl->stationId(); auto* stationObj = ObjectManager::get<RoadStationObject>(stationEl->objectId()); if (piece.index == 0) { auto removeCostBase = Economy::getInflationAdjustedCost(stationObj->sellCostFactor, stationObj->costIndex, 8); totalCost += (removeCostBase * World::TrackData::getRoadMiscData(args.roadId).costFactor) / 256; } if ((flags & Flags::apply) != 0) { for (auto* elRoad = roadRange.begin; elRoad != roadRange.end; ++elRoad) { elRoad->setHasStationElement(false); elRoad->setClearZ(elRoad->clearZ() - stationObj->height); } Ui::ViewportManager::invalidate(World::Pos2(roadLoc), stationEl->baseHeight(), stationEl->clearHeight(), ZoomLevel::eighth); World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(stationEl)); } } if (updateStationTileRegistration && (flags & Flags::apply) != 0) { auto* station = StationManager::get(foundStationId); removeTileFromStation(foundStationId, roadStart, args.rotation); station->invalidate(); recalculateStationModes(foundStationId); recalculateStationCenter(foundStationId); station->updateLabel(); station->invalidate(); } return totalCost; } void removeRoadStation(registers& regs) { regs.ebx = removeRoadStation(RoadStationRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Road/RemoveRoadStation.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct RoadStationRemovalArgs { static constexpr auto command = GameCommand::removeRoadStation; RoadStationRemovalArgs() = default; explicit RoadStationRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , roadId(regs.dl & 0xF) , index(regs.dh & 0x3) , roadObjectId(regs.bp & 0xF) { } World::Pos3 pos; uint8_t rotation; uint8_t roadId; uint8_t index; uint8_t roadObjectId; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = roadId; regs.dh = index; regs.bp = roadObjectId; return regs; } }; void removeRoadStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateSignal.cpp ```cpp #include "CreateSignal.h" #include "Economy/Economy.h" #include "Economy/Expenditures.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Map/AnimationManager.h" #include "Map/SignalElement.h" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrainSignalObject.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" namespace OpenLoco::GameCommands { static World::TrackElement* getElTrackAt(const SignalPlacementArgs& args, const World::Pos3 pos, const uint8_t index) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->rotation() != args.rotation) { continue; } if (elTrack->sequenceIndex() != index) { continue; } if (elTrack->trackObjectId() != args.trackObjType) { continue; } if (elTrack->trackId() != args.trackId) { continue; } return elTrack; } return nullptr; }; static bool validateTrackIsSignalCompatible(const SignalPlacementArgs& args, const std::span<const World::TrackData::PreviewTrack> trackPieces, const World::Pos3 trackStart) { for (auto& piece : trackPieces) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; auto* pieceElTrack = getElTrackAt(args, trackLoc, piece.index); if (pieceElTrack == nullptr) { return false; } if (pieceElTrack->hasStationElement()) { setErrorText(StringIds::signals_cannot_be_built_in_stations); return false; } const auto connectFlags = piece.connectFlags[pieceElTrack->rotation()]; auto tile = World::TileManager::get(trackLoc); for (auto& el : tile) { auto* otherElTrack = el.as<World::TrackElement>(); if (otherElTrack == nullptr) { continue; } if (otherElTrack == pieceElTrack) { continue; } if (otherElTrack->baseZ() != pieceElTrack->baseZ()) { continue; } if (otherElTrack->isGhost()) { continue; } const auto otherConnectFlags = World::TrackData::getTrackPiece(otherElTrack->trackId())[otherElTrack->sequenceIndex()].connectFlags[otherElTrack->rotation()]; if (otherConnectFlags & connectFlags) { setErrorText(StringIds::signals_cannot_be_built_on_a_junction); return false; } } } return true; } static currency32_t signalCost(const SignalPlacementArgs& args, const World::TrackData::PreviewTrack trackPiece0, const World::Pos3 trackStart) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece0.x, trackPiece0.y }, args.rotation), trackPiece0.z }; auto* pieceElTrack = getElTrackAt(args, trackLoc, trackPiece0.index); if (pieceElTrack == nullptr) { return 0; } const auto* signalObj = ObjectManager::get<TrainSignalObject>(args.type); const auto baseCost = Economy::getInflationAdjustedCost(signalObj->costFactor, signalObj->costIndex, 10); currency32_t totalCost = 0; if (args.sides & (1U << 15)) { totalCost += baseCost; if (pieceElTrack->hasSignal()) { auto* next = pieceElTrack->next()->as<World::SignalElement>(); if (next != nullptr && next->getLeft().hasSignal()) { if (next->getLeft().signalObjectId() == args.type) { totalCost -= baseCost; } else { const auto* existingSignalObj = ObjectManager::get<TrainSignalObject>(next->getLeft().signalObjectId()); totalCost += Economy::getInflationAdjustedCost(existingSignalObj->sellCostFactor, existingSignalObj->costIndex, 10); } } } } if (args.sides & (1U << 14)) { totalCost += baseCost; if (pieceElTrack->hasSignal()) { auto* next = pieceElTrack->next()->as<World::SignalElement>(); if (next != nullptr && next->getRight().hasSignal()) { if (next->getRight().signalObjectId() == args.type) { totalCost -= baseCost; } else { const auto* existingSignalObj = ObjectManager::get<TrainSignalObject>(next->getRight().signalObjectId()); totalCost += Economy::getInflationAdjustedCost(existingSignalObj->sellCostFactor, existingSignalObj->costIndex, 10); } } } } return totalCost; } // 0x00488BDB static uint32_t createSignal(const SignalPlacementArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3{ 16, 16, 0 }); if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } auto* elTrack = getElTrackAt(args, args.pos, args.index); if (elTrack == nullptr) { return FAILURE; } if (elTrack->hasLevelCrossing()) { setErrorText(StringIds::level_crossing_in_the_way); return FAILURE; } if (!sub_431E6A(elTrack->owner(), reinterpret_cast<World::TileElement*>(elTrack))) { return FAILURE; } const auto trackPieces = World::TrackData::getTrackPiece(args.trackId); auto& trackPiece = trackPieces[args.index]; const auto trackStart = args.pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, args.rotation), trackPiece.z }; if (!validateTrackIsSignalCompatible(args, trackPieces, trackStart)) { return FAILURE; } uint32_t totalCost = signalCost(args, trackPieces[0], trackStart); // We remove certain sides from placing when in ghost mode auto sides = args.sides; for (auto& piece : trackPieces) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; auto* pieceElTrack = getElTrackAt(args, trackLoc, piece.index); if (pieceElTrack == nullptr) { return FAILURE; } if (flags & Flags::ghost) { if (pieceElTrack->hasSignal()) { auto* elSignal = pieceElTrack->next()->as<World::SignalElement>(); if (elSignal != nullptr) { if (elSignal->getLeft().hasSignal()) { sides &= ~(1U << 15); } if (elSignal->getRight().hasSignal()) { sides &= ~(1U << 14); } } } } if (flags & Flags::apply) { if (!pieceElTrack->hasSignal()) { // pieceElTrack is invalid after this call! auto* newSignal = World::TileManager::insertElementAfterNoReorg<World::SignalElement>(reinterpret_cast<World::TileElement*>(pieceElTrack), trackLoc, pieceElTrack->baseZ(), pieceElTrack->occupiedQuarter()); if (newSignal == nullptr) { return FAILURE; } pieceElTrack = newSignal->prev()->as<World::TrackElement>(); if (pieceElTrack == nullptr) { return FAILURE; } newSignal->setRotation(pieceElTrack->rotation()); newSignal->setGhost(flags & Flags::ghost); newSignal->setAiAllocated(flags & Flags::aiAllocated); newSignal->setClearZ(pieceElTrack->clearZ()); newSignal->getLeft() = World::SignalElement::Side{}; newSignal->getRight() = World::SignalElement::Side{}; pieceElTrack->setHasSignal(true); } auto* elSignal = pieceElTrack->next()->as<World::SignalElement>(); if (elSignal == nullptr) { return FAILURE; } if (sides & (1U << 15)) { if (!(flags & Flags::ghost) || !elSignal->getLeft().hasSignal()) { auto& left = elSignal->getLeft(); left.setHasSignal(true); elSignal->setLeftGhost(flags & Flags::ghost); left.setSignalObjectId(args.type); left.setFrame(0); left.setAllLights(0); } } if (sides & (1U << 14)) { if (!(flags & Flags::ghost) || !elSignal->getRight().hasSignal()) { auto& right = elSignal->getRight(); right.setHasSignal(true); elSignal->setRightGhost(flags & Flags::ghost); right.setSignalObjectId(args.type); right.setFrame(0); right.setAllLights(0); } } if (!(flags & Flags::ghost)) { World::AnimationManager::createAnimation(0, trackLoc, elSignal->baseZ()); } Ui::ViewportManager::invalidate(trackLoc, elSignal->baseHeight(), elSignal->baseHeight() + 32, ZoomLevel::half); } } if (flags & Flags::apply) { if (!(flags & (Flags::aiAllocated | Flags::ghost))) { const uint16_t tad = args.rotation | (args.trackId << 3); { auto [nextLoc, nextRotation] = World::Track::getTrackConnectionEnd(args.pos, tad); auto tc = World::Track::getTrackConnections(nextLoc, nextRotation, getUpdatingCompanyId(), args.trackObjType, 0, 0); if (!tc.connections.empty()) { Vehicles::TrackAndDirection::_TrackAndDirection tad2{ 0, 0 }; tad2._data = tc.connections.front() & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; Vehicles::sub_4A2AD7(nextLoc, tad2, getUpdatingCompanyId(), args.trackObjType); } } auto& trackSize = World::TrackData::getUnkTrack(tad); auto nextTrackStart = args.pos + trackSize.pos; if (trackSize.rotationEnd < 12) { nextTrackStart -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } auto tc = World::Track::getTrackConnections(nextTrackStart, World::kReverseRotation[trackSize.rotationEnd], getUpdatingCompanyId(), args.trackObjType, 0, 0); if (!tc.connections.empty()) { Vehicles::TrackAndDirection::_TrackAndDirection tad2{ 0, 0 }; tad2._data = tc.connections.front() & World::Track::AdditionalTaDFlags::basicTaDWithSignalMask; Vehicles::sub_4A2AD7(nextTrackStart, tad2, getUpdatingCompanyId(), args.trackObjType); } } } return totalCost; } void createSignal(registers& regs) { regs.ebx = createSignal(SignalPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateSignal.h ```h #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct SignalPlacementArgs { static constexpr auto command = GameCommand::createSignal; SignalPlacementArgs() = default; explicit SignalPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh) , type((regs.edi >> 16) & 0xFF) , trackObjType(regs.ebp & 0xFF) , sides((regs.edi >> 16) & 0xC000) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t type; uint8_t trackObjType; uint16_t sides; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.edi = pos.z | (type << 16) | ((sides & 0xC000) << 16); regs.ebp = trackObjType; return regs; } }; void createSignal(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateTrack.cpp ```cpp #include "CreateTrack.h" #include "Audio/Audio.h" #include "Economy/Economy.h" #include "GameState.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Objects/BridgeObject.h" #include "Objects/LevelCrossingObject.h" #include "Objects/ObjectManager.h" #include "Objects/RoadObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "World/CompanyManager.h" #include "World/StationManager.h" #include <OpenLoco/Core/Numerics.hpp> namespace OpenLoco::GameCommands { using namespace World::TileManager; using namespace World::Track; static loco_global<ElementPositionFlags, 0x01136072> _byte_1136072; static loco_global<uint8_t, 0x01136073> _byte_1136073; static loco_global<World::MicroZ, 0x01136074> _byte_1136074; static loco_global<uint8_t, 0x01136075> _byte_1136075; // bridgeType of any overlapping track static bool isBridgeRequired(const World::SmallZ baseZ, const World::SurfaceElement& elSurface, const World::TrackData::PreviewTrack& piece, const uint8_t unk) { if (baseZ > elSurface.baseZ()) { return true; } else if (baseZ == elSurface.baseZ()) { if (!piece.hasFlags(World::TrackData::PreviewTrackFlags::unk4)) { if (unk == 0 || unk == elSurface.slopeCorners()) { return false; } } return true; } return false; } namespace { struct ClearFunctionArgs { World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t unkFlags; uint8_t bridgeId; uint8_t trackObjectId; uint8_t index; bool isLastIndex; uint8_t flags; }; } // 0x0049C4FF static World::TileClearance::ClearFuncResult clearTrack(World::TrackElement& elTrack, const ClearFunctionArgs& args) { if (elTrack.hasBridge()) { _byte_1136075 = elTrack.bridge(); } const auto& targetPiece = World::TrackData::getTrackPiece(elTrack.trackId())[elTrack.sequenceIndex()]; const auto& newPiece = World::TrackData::getTrackPiece(args.trackId)[args.index]; const auto targetConnectFlags = targetPiece.connectFlags[elTrack.rotation()]; const auto newConnectFlags = newPiece.connectFlags[args.rotation]; if (!(targetConnectFlags & newConnectFlags)) { return World::TileClearance::ClearFuncResult::noCollision; } if (args.unkFlags & (1U << 2)) { setErrorText(StringIds::junctions_not_possible); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (!sub_431E6A(elTrack.owner(), reinterpret_cast<const World::TileElement*>(&elTrack))) { return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (((World::TrackData::getTrackMiscData(elTrack.trackId()).flags & (CommonTraitFlags::slope | CommonTraitFlags::steepSlope)) != CommonTraitFlags::none) || ((World::TrackData::getTrackMiscData(args.trackId).flags & (CommonTraitFlags::slope | CommonTraitFlags::steepSlope)) != CommonTraitFlags::none)) { setErrorText(StringIds::junction_must_be_entirely_level); return World::TileClearance::ClearFuncResult::collisionErrorSet; } auto* targetTrackObj = ObjectManager::get<TrackObject>(elTrack.trackObjectId()); auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjectId); if (elTrack.baseHeight() != args.pos.z) { FormatArguments::common(targetTrackObj->name); setErrorText(StringIds::string_id_in_the_way_wrong_height_for_junction); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elTrack.hasSignal()) { setErrorText(StringIds::signal_in_the_way); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elTrack.hasStationElement()) { setErrorText(StringIds::station_in_the_way); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (!((args.rotation ^ elTrack.rotation()) & 0b1)) { if (((World::TrackData::getTrackMiscData(elTrack.trackId()).flags ^ World::TrackData::getTrackMiscData(args.trackId).flags) & CommonTraitFlags::oneSided) != CommonTraitFlags::none) { setErrorText(StringIds::track_combination_not_possible); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } if (elTrack.hasBridge()) { if (elTrack.bridge() != args.bridgeId) { setErrorText(StringIds::bridge_types_must_match); return World::TileClearance::ClearFuncResult::collisionErrorSet; } auto* bridgeObj = ObjectManager::get<BridgeObject>(args.bridgeId); if ((bridgeObj->disabledTrackCfg & CommonTraitFlags::junction) != CommonTraitFlags::none) { setErrorText(StringIds::bridge_not_suitable_for_junction); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } if (elTrack.trackObjectId() == args.trackObjectId) { if (elTrack.trackId() == args.trackId) { if (elTrack.rotation() == args.rotation) { if (elTrack.sequenceIndex() == args.index) { setErrorText(StringIds::already_built_here); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } } // This is working out reversed elements if (World::TrackData::getTrackMiscData(elTrack.trackId()).reverseTrackId == args.trackId) { if (((World::TrackData::getTrackMiscData(elTrack.trackId()).reverseRotation + elTrack.rotation()) & 0x3) == args.rotation) { if (args.isLastIndex && elTrack.sequenceIndex() == 0) { setErrorText(StringIds::already_built_here); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } } } if (elTrack.trackObjectId() == args.trackObjectId) { if (!targetTrackObj->hasTraitFlags(TrackTraitFlags::junction)) { setErrorText(StringIds::junctions_not_possible); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } else { if (!(targetTrackObj->compatibleTracks & (1U << args.trackObjectId)) && !(trackObj->compatibleTracks & (1U << elTrack.trackObjectId()))) { FormatArguments::common(targetTrackObj->name); setErrorText(StringIds::unable_to_cross_or_create_junction_with_string); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } _byte_1136073 = _byte_1136073 | (1U << 3); return World::TileClearance::ClearFuncResult::noCollision; } // 0x0049C401 static World::TileClearance::ClearFuncResult clearRoad(World::RoadElement& elRoad, const ClearFunctionArgs& args, bool& hasLevelCrossing) { if (elRoad.hasBridge()) { _byte_1136075 = elRoad.bridge(); auto* bridgeObj = ObjectManager::get<BridgeObject>(elRoad.bridge()); if ((bridgeObj->disabledTrackCfg & CommonTraitFlags::junction) != CommonTraitFlags::none) { setErrorText(StringIds::bridge_not_suitable_for_junction); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } auto* roadObj = ObjectManager::get<RoadObject>(elRoad.roadObjectId()); auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjectId); if (!(roadObj->compatibleTracks & (1U << args.trackObjectId)) && !(trackObj->compatibleRoads & (1U << elRoad.roadObjectId()))) { FormatArguments::common(roadObj->name); setErrorText(StringIds::unable_to_cross_or_create_junction_with_string); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elRoad.hasSignalElement()) { setErrorText(StringIds::signal_in_the_way); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elRoad.hasStationElement()) { setErrorText(StringIds::station_in_the_way); return World::TileClearance::ClearFuncResult::collisionErrorSet; } if (elRoad.hasBridge()) { if (elRoad.bridge() != args.bridgeId) { setErrorText(StringIds::bridge_types_must_match); return World::TileClearance::ClearFuncResult::collisionErrorSet; } } if (elRoad.roadId() != 0 || args.trackId != 0 || !((elRoad.rotation() - args.rotation) & 0b1) || elRoad.baseHeight() != args.pos.z) { setErrorText(StringIds::level_crossing_only_possible_with_straight_road_and_track_at_same_level); return World::TileClearance::ClearFuncResult::collisionErrorSet; } hasLevelCrossing = true; _byte_1136073 = _byte_1136073 | (1U << 2); if (!(args.flags & (Flags::aiAllocated | Flags::ghost)) && (args.flags & Flags::apply)) { elRoad.setHasLevelCrossing(true); elRoad.setLevelCrossingObjectId(getGameState().currentDefaultLevelCrossingType); elRoad.setUnk7_10(false); elRoad.setUnk6l(0); } return World::TileClearance::ClearFuncResult::noCollision; } // 0x0049C275 static World::TileClearance::ClearFuncResult clearFunction( World::TileElement& el, currency32_t& totalCost, bool& hasLevelCrossing, World::TileClearance::RemovedBuildings& removedBuildings, const ClearFunctionArgs& args) { switch (el.type()) { case World::ElementType::track: { auto* elTrack = el.as<World::TrackElement>(); if (elTrack != nullptr) { return clearTrack(*elTrack, args); } break; } case World::ElementType::station: { auto* elStation = el.as<World::StationElement>(); if (elStation->stationType() == StationType::trainStation) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; } case World::ElementType::signal: return World::TileClearance::ClearFuncResult::noCollision; case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } _byte_1136073 = _byte_1136073 | (1U << 4); return World::TileClearance::clearBuildingCollision(*elBuilding, args.pos, removedBuildings, args.flags, totalCost); } case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearTreeCollision(*elTree, args.pos, args.flags, totalCost); } case World::ElementType::road: { auto* elRoad = el.as<World::RoadElement>(); if (elRoad != nullptr) { return clearRoad(*elRoad, args, hasLevelCrossing); } break; } case World::ElementType::surface: case World::ElementType::wall: case World::ElementType::industry: return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::collision; } // 0x0049BB98 static uint32_t createTrack(const TrackPlacementArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3{ 16, 16, 0 }); _byte_1136072 = ElementPositionFlags::none; _byte_1136073 = 0; // Bridge related _byte_1136074 = 0; _byte_1136075 = 0xFFU; // 0x01135C68 = unkFlags if ((flags & Flags::apply) && !(flags & Flags::aiAllocated)) { companySetObservation(getUpdatingCompanyId(), ObservationStatus::buildingTrackRoad, args.pos, EntityId::null, args.trackObjectId); } if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjectId); const auto compatFlags = World::TrackData::getTrackMiscData(args.trackId).compatibleFlags; uint8_t validMods = args.mods; for (auto i = 0U; i < 4; ++i) { if (args.mods & (1U << i)) { auto* extraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); if ((compatFlags & extraObj->trackPieces) != compatFlags) { validMods &= ~(1U << i); } } } // This is a check from RCT2 and is not used in loco TRACK_ELEM_FLAG_STARTS_AT_HALF_HEIGHT if ((World::TrackData::getTrackMiscData(args.trackId).flags & CommonTraitFlags::startsAtHalfHeight) != CommonTraitFlags::none) { if ((args.pos.z & 0xF) != 8) { return FAILURE; } } else { if (args.pos.z & 0xF) { return FAILURE; } } currency32_t totalCost = 0; { const auto trackBaseCost = Economy::getInflationAdjustedCost(trackObj->buildCostFactor, trackObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } for (auto i = 0U; i < 4; ++i) { if (validMods & (1U << i)) { auto* extraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(extraObj->buildCostFactor, extraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } } auto& trackPieces = World::TrackData::getTrackPiece(args.trackId); World::TileClearance::RemovedBuildings removedBuildings; for (auto& piece : trackPieces) { const auto trackLoc = args.pos + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; const auto quarterTile = piece.subTileClearance.rotate(args.rotation); const auto unk = Numerics::rotl4bit(enumValue(piece.flags) & 0xF, args.rotation); if (trackLoc.z < 16) { setErrorText(StringIds::error_too_low); return FAILURE; } const auto baseZ = trackLoc.z / World::kSmallZStep; auto clearZ = baseZ + (piece.clearZ + 32) / World::kSmallZStep; _byte_1136073 = _byte_1136073 & ~(1U << 1); // Why aren't we just failing invalid??? if (World::validCoords(trackLoc)) { const auto tile = World::TileManager::get(trackLoc); auto* elSurface = tile.surface(); if (elSurface->water()) { _byte_1136073 = _byte_1136073 | (1U << 7); } const bool requiresBridge = isBridgeRequired(baseZ, *elSurface, piece, unk); if (requiresBridge) { // 0x0049BF1E _byte_1136073 = _byte_1136073 | (1U << 1) | (1U << 0); World::MicroZ heightDiff = (baseZ - elSurface->baseZ()) / World::kMicroToSmallZStep; if (args.bridge == 0xFFU) { setErrorText(StringIds::bridge_needed); return FAILURE; } auto* bridgeObj = ObjectManager::get<BridgeObject>(args.bridge); if (heightDiff > bridgeObj->maxHeight) { setErrorText(StringIds::too_far_above_ground_for_bridge_type); return FAILURE; } _byte_1136074 = std::max(heightDiff, *_byte_1136074); if ((bridgeObj->disabledTrackCfg & World::TrackData::getTrackMiscData(args.trackId).flags) != CommonTraitFlags::none) { setErrorText(StringIds::bridge_type_unsuitable_for_this_configuration); return FAILURE; } clearZ += bridgeObj->clearHeight / World::kSmallZStep; } } // 0x0049BF7C if (clearZ > 236) { setErrorText(StringIds::error_too_high); return FAILURE; } // 0x0113607C bool hasLevelCrossing = false; ClearFunctionArgs clearArgs{}; clearArgs.pos = trackLoc; clearArgs.rotation = args.rotation; clearArgs.trackId = args.trackId; clearArgs.unkFlags = args.unkFlags; clearArgs.bridgeId = args.bridge; clearArgs.trackObjectId = args.trackObjectId; clearArgs.index = piece.index; clearArgs.isLastIndex = piece.index == (trackPieces.size() - 1); clearArgs.flags = flags; auto clearFunc = [&totalCost, &hasLevelCrossing, &removedBuildings, &clearArgs](World::TileElement& el) { return clearFunction(el, totalCost, hasLevelCrossing, removedBuildings, clearArgs); }; if (!World::TileClearance::applyClearAtStandardHeight(trackLoc, baseZ, clearZ, quarterTile, clearFunc)) { return FAILURE; } if (hasLevelCrossing) { auto* levelCrossObj = ObjectManager::get<LevelCrossingObject>(getGameState().currentDefaultLevelCrossingType); totalCost += Economy::getInflationAdjustedCost(levelCrossObj->costFactor, levelCrossObj->costIndex, 10); } if ((flags & Flags::apply) && !(flags & (Flags::ghost | Flags::aiAllocated))) { World::TileManager::removeAllWallsOnTileBelow(World::toTileSpace(trackLoc), baseZ); } // 0x0049C015 const auto posFlags = World::TileClearance::getPositionFlags(); // Abridged flags for just above/underground const auto newGroundFlags = posFlags & (ElementPositionFlags::aboveGround | ElementPositionFlags::underground); if (_byte_1136072 != ElementPositionFlags::none && (*_byte_1136072 & newGroundFlags) == ElementPositionFlags::none) { setErrorText(StringIds::cant_build_partly_above_partly_below_ground); return FAILURE; } _byte_1136072 = newGroundFlags; if ((posFlags & ElementPositionFlags::partiallyUnderwater) != ElementPositionFlags::none) { setErrorText(StringIds::cant_build_this_underwater); return FAILURE; } if ((posFlags & ElementPositionFlags::underwater) != ElementPositionFlags::none) { setErrorText(StringIds::too_close_to_water_surface); return FAILURE; } if (!(flags & Flags::apply)) { continue; } if (CompanyManager::isPlayerCompany(getUpdatingCompanyId())) { companyEmotionEvent(getUpdatingCompanyId(), Emotion::thinking); } if (!(flags & (Flags::ghost | Flags::aiAllocated))) { World::TileManager::removeSurfaceIndustryAtHeight(trackLoc); World::TileManager::setTerrainStyleAsClearedAtHeight(trackLoc); } auto* newElTrack = World::TileManager::insertElement<World::TrackElement>(trackLoc, baseZ, quarterTile.getBaseQuarterOccupied()); if (newElTrack == nullptr) { return FAILURE; } newElTrack->setClearZ(clearZ); newElTrack->setRotation(args.rotation); newElTrack->setTrackObjectId(args.trackObjectId); newElTrack->setSequenceIndex(piece.index); newElTrack->setTrackId(args.trackId); newElTrack->setOwner(getUpdatingCompanyId()); for (auto i = 0U; i < 4; ++i) { if (validMods & (1U << i)) { newElTrack->setMod(i, true); } } newElTrack->setBridgeObjectId(args.bridge); newElTrack->setHasBridge(_byte_1136073 & (1U << 1)); newElTrack->setHasLevelCrossing(hasLevelCrossing); newElTrack->setFlag6(piece.index == (trackPieces.size() - 1)); newElTrack->setGhost(flags & Flags::ghost); newElTrack->setAiAllocated(flags & Flags::aiAllocated); if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(trackLoc); } } if (_byte_1136073 & (1U << 0)) { auto* bridgeObj = ObjectManager::get<BridgeObject>(args.bridge); const auto heightCost = _byte_1136074 * bridgeObj->heightCostFactor; const auto bridgeBaseCost = Economy::getInflationAdjustedCost(bridgeObj->baseCostFactor + heightCost, bridgeObj->costIndex, 10); auto cost = (bridgeBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; if (_byte_1136073 & (1U << 7)) { cost *= 2; } totalCost += cost; } if ((_byte_1136072 & ElementPositionFlags::underground) != ElementPositionFlags::none) { const auto tunnelBaseCost = Economy::getInflationAdjustedCost(trackObj->tunnelCostFactor, 2, 8); auto cost = (tunnelBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } if ((flags & Flags::apply) && !(flags & (Flags::aiAllocated | Flags::ghost))) { playConstructionPlacementSound(getPosition()); } return totalCost; } void createTrack(registers& regs) { regs.ebx = createTrack(TrackPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateTrack.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TrackPlacementArgs { static constexpr auto command = GameCommand::createTrack; TrackPlacementArgs() = default; explicit TrackPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dh & 0x3F) , mods((regs.edi >> 16) & 0xFF) , unkFlags((regs.edx >> 20) & 0xF) , bridge((regs.edx >> 24) & 0xFF) , trackObjectId(regs.dl) , unk(regs.edi & 0x800000) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t mods; uint8_t unkFlags; uint8_t bridge; uint8_t trackObjectId; bool unk; explicit operator registers() const { registers regs; regs.eax = pos.x; regs.cx = pos.y; regs.edi = (0xFFFF & pos.z) | (mods << 16) | (unk ? 0x800000 : 0); regs.bh = rotation; regs.edx = trackObjectId | (trackId << 8) | (unkFlags << 20) | (bridge << 24); return regs; } }; void createTrack(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateTrackMod.cpp ```cpp #include "CreateTrackMod.h" #include "Economy/Expenditures.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Math/Vector.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x004A6479 static currency32_t createTrackMod(const TrackModsPlacementArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); auto* elTrack = [&args]() -> const World::TrackElement* { const auto tile = World::TileManager::get(args.pos); for (const auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != args.pos.z) { continue; } if (elTrack->rotation() != args.rotation) { continue; } if (elTrack->sequenceIndex() != args.index) { continue; } if (elTrack->trackObjectId() != args.trackObjType) { continue; } if (elTrack->trackId() != args.trackId) { continue; } return elTrack; } return nullptr; }(); if (elTrack == nullptr) { return FAILURE; } if (!sub_431E6A(elTrack->owner(), reinterpret_cast<const World::TileElement*>(elTrack))) { return FAILURE; } const auto& piece = World::TrackData::getTrackPiece(elTrack->trackId())[elTrack->sequenceIndex()]; const auto offsetToFirstTile = World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, elTrack->rotation()), piece.z }; const auto firstTilePos = args.pos - offsetToFirstTile; const auto tad = Vehicles::TrackAndDirection::_TrackAndDirection(elTrack->trackId(), elTrack->rotation()); auto result = Vehicles::applyTrackModsToTrackNetwork(firstTilePos, tad, elTrack->owner(), args.trackObjType, flags, args.modSection, args.type); if (result.allPlacementsFailed) { setErrorText(StringIds::track_road_unsuitable); return FAILURE; } if (result.networkTooComplex && (flags & Flags::apply) && !(flags & Flags::ghost)) { Ui::Windows::Error::open(StringIds::null, StringIds::too_much_track_some_track_not_upgraded); } return result.cost; } void createTrackMod(registers& regs) { regs.ebx = createTrackMod(TrackModsPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateTrackMod.h ```h #pragma once #include "GameCommands/GameCommands.h" #include "Map/Track/TrackModSection.h" namespace OpenLoco::GameCommands { struct TrackModsPlacementArgs { static constexpr auto command = GameCommand::createTrackMod; TrackModsPlacementArgs() = default; explicit TrackModsPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh & 0x3) , type((regs.edi >> 16) & 0xF) , trackObjType(regs.ebp & 0xFF) , modSection(static_cast<World::Track::ModSection>((regs.ebp >> 16) & 0xFF)) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t type; uint8_t trackObjType; World::Track::ModSection modSection; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.edi = pos.z | (type << 16); regs.ebp = trackObjType | (enumValue(modSection) << 16); return regs; } }; void createTrackMod(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateTrainStation.cpp ```cpp #include "CreateTrainStation.h" #include "Economy/Economy.h" #include "Localisation/StringIds.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileLoop.hpp" #include "Map/TileManager.h" #include "Map/Track/Track.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrackObject.h" #include "Objects/TrainStationObject.h" #include "ViewportManager.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { static loco_global<StationId, 0x0112C730> _lastPlacedTrackStationId; static loco_global<uint32_t, 0x00112C734> _lastConstructedAdjoiningStationId; // Can be 0xFFFF'FFFFU for no adjoining station static loco_global<World::Pos2, 0x00112C792> _lastConstructedAdjoiningStationCentrePos; // Can be x = -1 for no adjoining station // 0x0048FF36 static StationManager::NearbyStation findNearbyStationOnTrack(World::Pos3 pos, uint16_t tad, uint8_t trackObjectId) { { auto [nextPos, nextRotation] = World::Track::getTrackConnectionEnd(pos, tad); const auto tc = World::Track::getTrackConnections(nextPos, nextRotation, getUpdatingCompanyId(), trackObjectId, 0, 0); if (tc.stationId != StationId::null) { return StationManager::NearbyStation{ tc.stationId, true }; } } { auto tailTaD = tad; const auto& trackSize = World::TrackData::getUnkTrack(tailTaD); auto tailPos = pos + trackSize.pos; if (trackSize.rotationEnd < 12) { tailPos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } tailTaD ^= (1U << 2); // Reverse auto [nextTailPos, nextTailRotation] = World::Track::getTrackConnectionEnd(tailPos, tailTaD); const auto tailTc = World::Track::getTrackConnections(nextTailPos, nextTailRotation, getUpdatingCompanyId(), trackObjectId, 0, 0); if (tailTc.stationId != StationId::null) { return StationManager::NearbyStation{ tailTc.stationId, true }; } } return StationManager::findNearbyStation(pos, getUpdatingCompanyId()); } // 0x0048FFF7 static StationManager::NearbyStation findNearbyStationOnTrackAi(World::Pos3 pos, uint16_t tad, uint8_t trackObjectId) { { auto [nextPos, nextRotation] = World::Track::getTrackConnectionEnd(pos, tad); const auto tc = World::Track::getTrackConnectionsAi(nextPos, nextRotation, getUpdatingCompanyId(), trackObjectId, 0, 0); if (tc.stationId != StationId::null) { return StationManager::NearbyStation{ tc.stationId, true }; } } { auto tailTaD = tad; const auto& trackSize = World::TrackData::getUnkTrack(tailTaD); auto tailPos = pos + trackSize.pos; if (trackSize.rotationEnd < 12) { tailPos -= World::Pos3{ World::kRotationOffset[trackSize.rotationEnd], 0 }; } tailTaD ^= (1U << 2); // Reverse auto [nextTailPos, nextTailRotation] = World::Track::getTrackConnectionEnd(tailPos, tailTaD); const auto tailTc = World::Track::getTrackConnectionsAi(nextTailPos, nextTailRotation, getUpdatingCompanyId(), trackObjectId, 0, 0); if (tailTc.stationId != StationId::null) { return StationManager::NearbyStation{ tailTc.stationId, true }; } } return StationManager::findNearbyStation(pos, getUpdatingCompanyId()); } enum class NearbyStationValidation { okay, requiresNewStation, failure, }; // 0x0048BDCE & 0x0048BD40 static std::pair<NearbyStationValidation, StationId> validateNearbyStation(const World::Pos3 pos, const uint16_t tad, const uint8_t trackObjectId, const uint8_t flags) { auto func = (flags & Flags::aiAllocated) ? &findNearbyStationOnTrackAi : &findNearbyStationOnTrack; auto nearbyStation = func(pos, tad, trackObjectId); if (nearbyStation.id == StationId::null) { return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } // _lastPlacedTrackStationId = nearbyStation.id; set in callers auto* station = StationManager::get(nearbyStation.id); if (station->stationTileSize >= std::size(station->stationTiles)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_large); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } else { if (!(flags & Flags::aiAllocated)) { if (StationManager::exceedsStationSize(*station, pos)) { if (nearbyStation.isPhysicallyAttached) { setErrorText(StringIds::station_too_spread_out); return std::make_pair(NearbyStationValidation::failure, StationId::null); } return std::make_pair(NearbyStationValidation::requiresNewStation, StationId::null); } } } return std::make_pair(NearbyStationValidation::okay, nearbyStation.id); } static World::TrackElement* getElTrack(World::Pos3 pos, uint8_t rotation, uint8_t trackObjectId, uint8_t trackId, uint8_t index) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->trackId() != trackId) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } if (elTrack->sequenceIndex() != index) { continue; } return elTrack; } return nullptr; } // 0x0048BAC2 static World::TileClearance::ClearFuncResult clearFuncAiReservation(World::TileElement& el, World::TrackElement& elReferenceTrack) { auto* elStation = el.as<World::StationElement>(); auto* elTrack = el.as<World::TrackElement>(); if (elStation != nullptr) { if (elStation->stationType() == StationType::trainStation) { return World::TileClearance::ClearFuncResult::noCollision; } } else if (elTrack != nullptr && elTrack == &elReferenceTrack) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::ClearFuncResult::collision; }; // 0x0048BAE5 static World::TileClearance::ClearFuncResult clearFuncCollideWithSurface(World::TileElement& el) { auto* elSurface = el.as<World::SurfaceElement>(); if (elSurface != nullptr) { return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::ClearFuncResult::noCollision; }; // 0x0048BB20 static currency32_t createTrainStation(const TrainStationPlacementArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); bool updateStationTileRegistration = false; _lastPlacedTrackStationId = StationId::null; _lastConstructedAdjoiningStationCentrePos = World::Pos2(-1, -1); _lastConstructedAdjoiningStationId = 0xFFFFFFFFU; auto* trackObj = ObjectManager::get<TrackObject>(args.trackObjectId); auto* stationObj = ObjectManager::get<TrainStationObject>(args.type); const auto trackIdCompatFlags = World::TrackData::getTrackMiscData(args.trackId).compatibleFlags; const auto compatibleTrack = trackObj->stationTrackPieces & stationObj->trackPieces & trackIdCompatFlags; if (compatibleTrack != trackIdCompatFlags) { setErrorText(StringIds::track_road_unsuitable_for_station); return FAILURE; } if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } auto* initialElTrack = getElTrack(args.pos, args.rotation, args.trackObjectId, args.trackId, args.index); auto index = args.index; if (initialElTrack == nullptr) { if (flags & Flags::apply) { return FAILURE; } if (!(flags & Flags::aiAllocated)) { return FAILURE; } // Why??? index = 0; } else { if (!sub_431E6A(initialElTrack->owner(), reinterpret_cast<World::TileElement*>(initialElTrack))) { return FAILURE; } } auto& trackPieces = World::TrackData::getTrackPiece(args.trackId); auto& argPiece = trackPieces[index]; const auto trackStart = args.pos - World::Pos3(Math::Vector::rotate(World::Pos2(argPiece.x, argPiece.y), args.rotation), argPiece.z); if ((flags & Flags::ghost) && (flags & Flags::apply)) { _lastConstructedAdjoiningStationCentrePos = trackStart; uint16_t tad = (args.trackId << 3) | args.rotation; auto nearbyStation = findNearbyStationOnTrack(trackStart, tad, args.trackObjectId); _lastConstructedAdjoiningStationId = static_cast<int16_t>(nearbyStation.id); } if (!(flags & Flags::ghost)) { if (flags & Flags::apply) { auto [result, nearbyStationId] = validateNearbyStation(trackStart, (args.trackId << 3) | args.rotation, args.trackObjectId, flags); switch (result) { case NearbyStationValidation::failure: // Odd??? break; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(trackStart, getUpdatingCompanyId(), 0); if (newStationId != StationId::null) { _lastPlacedTrackStationId = newStationId; auto* station = StationManager::get(newStationId); station->updateLabel(); } } break; case NearbyStationValidation::okay: _lastPlacedTrackStationId = nearbyStationId; break; } updateStationTileRegistration = true; } else { // Same as the other branch but deallocate after allocating and return failure on failure auto [result, nearbyStationId] = validateNearbyStation(trackStart, (args.trackId << 3) | args.rotation, args.trackObjectId, flags); switch (result) { case NearbyStationValidation::failure: return FAILURE; case NearbyStationValidation::requiresNewStation: { const auto newStationId = StationManager::allocateNewStation(trackStart, getUpdatingCompanyId(), 0); if (newStationId == StationId::null) { return FAILURE; } StationManager::deallocateStation(newStationId); // _lastPlacedTrackStationId not set but that's fine since this is the no apply side } break; case NearbyStationValidation::okay: _lastPlacedTrackStationId = nearbyStationId; break; } } } currency32_t totalCost = 0; for (auto& piece : trackPieces) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; auto* elTrack = getElTrack(trackLoc, args.rotation, args.trackObjectId, args.trackId, piece.index); if (elTrack == nullptr) { // 0x0048BEC7 // The following code is only used for aiPlacement when querying to get a rough idea of costs and // if there is clearance. It will never get here in a execute. // Common with below code. Extract out // Calculate station costs if (piece.index == 0) { auto placementCostBase = Economy::getInflationAdjustedCost(stationObj->buildCostFactor, stationObj->costIndex, 8); const auto cost = (placementCostBase * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } // Perform clearance // Subtly different to below (baseZ and qt stuff) const auto baseZ = trackLoc.z / World::kSmallZStep; const auto clearZ = baseZ + 8 + stationObj->height / World::kSmallZStep; // Vanilla did the following code wrong so we have taken a best guess as to what it should do. // Vanilla had the following issues: // - Kept a pointer to 1 past the end of the tile // - Used that pointer to get the quarter tile (which most of the time would mean // the first tileElement in the next tile in the x direction) // - Used that pointer to compare tiles on this tile (which would do nothing) // - Performed a clearance on the wrong clearZ due to adding 8 twice. const auto qt = World::QuarterTile(World::TrackData::getTrackPiece(args.trackId)[index].subTileClearance.getBaseQuarterOccupied(), 0); if (!World::TileClearance::applyClearAtStandardHeight(trackLoc, baseZ, clearZ, qt, clearFuncCollideWithSurface)) { return FAILURE; } continue; } else { if (elTrack->hasSignal()) { setErrorText(StringIds::signal_in_the_way); return FAILURE; } if (elTrack->hasLevelCrossing()) { setErrorText(StringIds::level_crossing_in_the_way); return FAILURE; } // Connect flags validation const auto connectFlags = piece.connectFlags[elTrack->rotation()]; auto tile = World::TileManager::get(trackLoc); for (auto& el : tile) { auto* elConnectTrack = el.as<World::TrackElement>(); if (elConnectTrack == nullptr) { continue; } if (elConnectTrack == elTrack) { continue; } if (elConnectTrack->baseHeight() != trackLoc.z) { continue; } if (elConnectTrack->isGhost()) { continue; } auto& connectPiece = World::TrackData::getTrackPiece(elConnectTrack->trackId())[elConnectTrack->sequenceIndex()]; if (connectFlags & connectPiece.connectFlags[elConnectTrack->rotation()]) { setErrorText(StringIds::station_cannot_be_built_on_a_junction); return FAILURE; } } // Calculate station costs if (piece.index == 0) { bool calculateCost = true; // Replace station if it already exists if (elTrack->hasStationElement()) { auto* elStation = elTrack->next()->as<World::StationElement>(); if (elStation == nullptr) { return FAILURE; } if (elStation->objectId() == args.type) { calculateCost = false; } else { auto* oldStationObj = ObjectManager::get<TrainStationObject>(elStation->objectId()); auto removeCostBase = Economy::getInflationAdjustedCost(oldStationObj->sellCostFactor, oldStationObj->costIndex, 8); const auto cost = (removeCostBase * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } } if (calculateCost) { auto placementCostBase = Economy::getInflationAdjustedCost(stationObj->buildCostFactor, stationObj->costIndex, 8); const auto cost = (placementCostBase * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } } // Perform clearance const auto baseZ = elTrack->baseZ(); const auto clearZ = baseZ + 8 + stationObj->height / World::kSmallZStep; World::QuarterTile qt(elTrack->occupiedQuarter(), 0); if (!(flags & Flags::aiAllocated)) { auto clearFunc = [&elTrack](World::TileElement& el) { return clearFuncAiReservation(el, *elTrack); }; if (!World::TileClearance::applyClearAtStandardHeight(trackLoc, baseZ + 8, clearZ, qt, clearFunc)) { return FAILURE; } } if (!World::TileClearance::applyClearAtStandardHeight(trackLoc, baseZ, clearZ, qt, clearFuncCollideWithSurface)) { return FAILURE; } // elTrack is still valid as applyClearAtStandardHeight set to not remove anything // this will need changed if ever a different clear function is used if (elTrack->hasStationElement() && (flags & Flags::ghost)) { // ????? setErrorText(StringIds::empty); return FAILURE; } if (!(flags & Flags::apply)) { continue; } World::StationElement* newStationElement = nullptr; // Actually place the new station if (elTrack->hasStationElement()) { auto* elStation = elTrack->next()->as<World::StationElement>(); if (elStation == nullptr) { return FAILURE; } auto* oldStationObj = ObjectManager::get<TrainStationObject>(elStation->objectId()); elTrack->setClearZ(elTrack->clearZ() - oldStationObj->height / World::kSmallZStep); elStation->setSequenceIndex(0); updateStationTileRegistration = false; Ui::ViewportManager::invalidate(trackLoc, elStation->baseHeight(), elStation->clearHeight()); newStationElement = elStation; } else { // elTrack pointer will be invalid after this call newStationElement = World::TileManager::insertElementAfterNoReorg<World::StationElement>( reinterpret_cast<World::TileElement*>(elTrack), trackLoc, elTrack->baseZ(), elTrack->occupiedQuarter()); if (newStationElement == nullptr) { return FAILURE; } elTrack = newStationElement->prev()->as<World::TrackElement>(); if (elTrack == nullptr) { return FAILURE; } newStationElement->setRotation(elTrack->rotation()); newStationElement->setGhost(flags & Flags::ghost); newStationElement->setAiAllocated(flags & Flags::aiAllocated); newStationElement->setSequenceIndex(0); newStationElement->setUnk4SLR4(0); newStationElement->setStationType(StationType::trainStation); newStationElement->setBuildingType(0); if (!(flags & Flags::ghost)) { newStationElement->setStationId(_lastPlacedTrackStationId); } else { newStationElement->setStationId(static_cast<StationId>(0)); } elTrack->setHasStationElement(true); } newStationElement->setObjectId(args.type); elTrack->setClearZ(elTrack->clearZ() + stationObj->height / World::kSmallZStep); newStationElement->setClearZ(elTrack->clearZ()); newStationElement->setOwner(getUpdatingCompanyId()); Ui::ViewportManager::invalidate(trackLoc, newStationElement->baseHeight(), newStationElement->clearHeight()); } } if (!(flags & Flags::ghost) && (flags & Flags::apply)) { if (updateStationTileRegistration) { addTileToStation(_lastPlacedTrackStationId, trackStart, args.rotation); } auto* station = StationManager::get(_lastPlacedTrackStationId); station->invalidate(); recalculateStationModes(_lastPlacedTrackStationId); recalculateStationCenter(_lastPlacedTrackStationId); station->updateLabel(); station->invalidate(); sub_48D794(*station); } return totalCost; } void createTrainStation(registers& regs) { regs.ebx = createTrainStation(TrainStationPlacementArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/CreateTrainStation.h ```h #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TrainStationPlacementArgs { static constexpr auto command = GameCommand::createTrainStation; TrainStationPlacementArgs() = default; explicit TrainStationPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh & 0x3) , trackObjectId(regs.bp) , type(regs.edi >> 16) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t trackObjectId; uint8_t type; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.edi = pos.z | (type << 16); regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.bp = trackObjectId; return regs; } }; void createTrainStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveSignal.cpp ```cpp #include "RemoveSignal.h" #include "Economy/Economy.h" #include "Map/SignalElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/TrainSignalObject.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" namespace OpenLoco::GameCommands { static World::TrackElement* getElTrackAt(const SignalRemovalArgs& args, const World::Pos3 pos, const uint8_t sequenceIndex) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->rotation() != args.rotation) { continue; } if (elTrack->sequenceIndex() != sequenceIndex) { continue; } if (elTrack->trackObjectId() != args.trackObjType) { continue; } if (elTrack->trackId() != args.trackId) { continue; } return elTrack; } return nullptr; }; static currency32_t signalRemoveCost(const SignalRemovalArgs& args, const World::TrackData::PreviewTrack trackPiece0, const World::Pos3 trackStart) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece0.x, trackPiece0.y }, args.rotation), trackPiece0.z }; auto* pieceElTrack = getElTrackAt(args, trackLoc, trackPiece0.index); if (pieceElTrack == nullptr) { return 0; } if (!pieceElTrack->hasSignal()) { return 0; } auto* elSignal = pieceElTrack->next()->as<World::SignalElement>(); if (elSignal == nullptr) { return FAILURE; } currency32_t totalCost = 0; if ((args.flags & (1U << 15)) && elSignal->getLeft().hasSignal()) { const auto* signalObj = ObjectManager::get<TrainSignalObject>(elSignal->getLeft().signalObjectId()); totalCost += Economy::getInflationAdjustedCost(signalObj->sellCostFactor, signalObj->costIndex, 10); } if ((args.flags & (1U << 14)) && elSignal->getRight().hasSignal()) { const auto* signalObj = ObjectManager::get<TrainSignalObject>(elSignal->getRight().signalObjectId()); totalCost += Economy::getInflationAdjustedCost(signalObj->sellCostFactor, signalObj->costIndex, 10); } return totalCost; } // 0x004891E4 static currency32_t removeSignal(const SignalRemovalArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3{ 16, 16, 0 }); auto* elTrack = getElTrackAt(args, args.pos, args.index); if (elTrack == nullptr) { return FAILURE; } if (!sub_431E6A(elTrack->owner(), reinterpret_cast<World::TileElement*>(elTrack))) { return FAILURE; } const auto trackPieces = World::TrackData::getTrackPiece(args.trackId); auto& trackPiece = trackPieces[args.index]; const auto trackStart = args.pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, args.rotation), trackPiece.z }; currency32_t cost = signalRemoveCost(args, trackPieces[0], trackStart); if (static_cast<uint32_t>(cost) == FAILURE) { return FAILURE; } for (auto& piece : trackPieces) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; auto* pieceElTrack = getElTrackAt(args, trackLoc, piece.index); if (pieceElTrack == nullptr) { return FAILURE; } if (!(flags & Flags::apply)) { continue; } if (!pieceElTrack->hasSignal()) { return 0; } auto* elSignal = pieceElTrack->next()->as<World::SignalElement>(); if (elSignal == nullptr) { return FAILURE; } if (args.flags & (1U << 15)) { if (!(flags & Flags::ghost) || elSignal->isLeftGhost()) { auto& left = elSignal->getLeft(); left.setHasSignal(false); left.setAllLights(0); left.setFrame(0); elSignal->setLeftGhost(false); } } if (args.flags & (1U << 14)) { if (!(flags & Flags::ghost) || elSignal->isRightGhost()) { auto& right = elSignal->getRight(); right.setHasSignal(false); right.setAllLights(0); right.setFrame(0); elSignal->setRightGhost(false); } } Ui::ViewportManager::invalidate(trackLoc, elSignal->baseHeight(), elSignal->baseHeight() + 32, ZoomLevel::half); elSignal->setGhost(false); // Why?? // No signals anymore so delete the tile! if (!elSignal->getLeft().hasSignal() && !elSignal->getRight().hasSignal()) { pieceElTrack->setHasSignal(false); World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(elSignal)); } } if (flags & Flags::apply) { if (!(flags & (Flags::aiAllocated | Flags::ghost))) { const Vehicles::TrackAndDirection::_TrackAndDirection tad(args.trackId, args.rotation); Vehicles::sub_4A2AD7(trackStart, tad, getUpdatingCompanyId(), args.trackObjType); } } return cost; } void removeSignal(registers& regs) { regs.ebx = removeSignal(SignalRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveSignal.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct SignalRemovalArgs { static constexpr auto command = GameCommand::removeSignal; SignalRemovalArgs() = default; explicit SignalRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh & 0xF) , trackObjType(regs.bp & 0xF) , flags(regs.edi >> 16) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t trackObjType; uint16_t flags; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.edi = pos.z | (flags << 16); regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.bp = trackObjType; return regs; } }; void removeSignal(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveTrack.cpp ```cpp #include "RemoveTrack.h" #include "Economy/Economy.h" #include "Map/RoadElement.h" #include "Map/SignalElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/BridgeObject.h" #include "Objects/TrackExtraObject.h" #include "Objects/TrackObject.h" #include "Random.h" #include "RemoveSignal.h" #include "RemoveTrainStation.h" #include "Vehicles/Vehicle.h" #include "ViewportManager.h" namespace OpenLoco::GameCommands { static World::TrackElement* getElTrackAt(const TrackRemovalArgs& args, const uint8_t flags, const World::Pos3 pos, const uint8_t sequenceIndex) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->rotation() != args.rotation) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->sequenceIndex() != sequenceIndex) { continue; } if (elTrack->trackObjectId() != args.trackObjectId) { continue; } if (elTrack->trackId() != args.trackId) { continue; } if (elTrack->isGhost() != ((flags & Flags::ghost) != 0)) { continue; } if (elTrack->isAiAllocated() != ((flags & Flags::aiAllocated) != 0)) { continue; } // Ghost only as this is checked elsewhere for non-ghost so that // neutral company is always allowed if (elTrack->owner() != getUpdatingCompanyId() && ((flags & Flags::ghost) != 0)) { continue; } return elTrack; } return nullptr; }; // 0x0049CC23 static currency32_t trackRemoveCost(const TrackRemovalArgs& args, const World::TrackData::PreviewTrack trackPiece0, const World::Pos3 trackStart, const uint8_t flags) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece0.x, trackPiece0.y }, args.rotation), trackPiece0.z }; auto* pieceElTrack = getElTrackAt(args, flags, trackLoc, trackPiece0.index); if (pieceElTrack == nullptr) { return 0; } currency32_t totalCost = 0; const auto* trackObj = ObjectManager::get<TrackObject>(pieceElTrack->trackObjectId()); { const auto trackBaseCost = Economy::getInflationAdjustedCost(trackObj->sellCostFactor, trackObj->costIndex, 10); const auto cost = (trackBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } // Check mod removal costs for (auto i = 0U; i < 4; i++) { if (pieceElTrack->hasMod(i)) { const auto* trackExtraObj = ObjectManager::get<TrackExtraObject>(trackObj->mods[i]); const auto trackExtraBaseCost = Economy::getInflationAdjustedCost(trackExtraObj->sellCostFactor, trackExtraObj->costIndex, 10); const auto cost = (trackExtraBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; totalCost += cost; } } return totalCost; } // 0x0048B04E static void playTrackRemovalSound(const World::Pos3 pos) { const auto frequency = gPrng2().randNext(17955, 26146); Audio::playSound(Audio::SoundId::demolish, pos, 0, frequency); } // 0x0049C7F2 static currency32_t removeTrack(const TrackRemovalArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3{ 16, 16, 0 }); currency32_t totalRemovalCost = 0; auto* elTrack = getElTrackAt(args, flags, args.pos, args.index); if (elTrack == nullptr) { return FAILURE; } if ((flags & Flags::ghost) == 0 && !sub_431E6A(elTrack->owner(), reinterpret_cast<World::TileElement*>(elTrack))) { return FAILURE; } if (elTrack->hasSignal()) { GameCommands::SignalRemovalArgs srArgs; srArgs.pos = args.pos; srArgs.rotation = args.rotation; srArgs.index = args.index; srArgs.trackId = args.trackId; srArgs.trackObjType = args.trackObjectId; srArgs.flags = 0; auto* elSignal = elTrack->next()->as<World::SignalElement>(); if (elSignal != nullptr) { if (elSignal->getLeft().hasSignal()) { srArgs.flags |= 1U << 15; } if (elSignal->getRight().hasSignal()) { srArgs.flags |= 1U << 14; } } if (auto cost = GameCommands::doCommand(srArgs, flags); cost != FAILURE) { totalRemovalCost += cost; } else { return FAILURE; } } // Fetch track element again; signal removal above might have invalidated the pointer. elTrack = getElTrackAt(args, flags, args.pos, args.index); if (elTrack->hasStationElement()) { GameCommands::TrainStationRemovalArgs tsArgs; tsArgs.pos = args.pos; tsArgs.rotation = args.rotation; tsArgs.trackId = args.trackId; tsArgs.index = args.index; tsArgs.type = args.trackObjectId; if (auto cost = GameCommands::doCommand(tsArgs, flags); cost != FAILURE) { totalRemovalCost += cost; } else { return FAILURE; } } // Fetch track element again; station removal above might have invalidated the pointer. elTrack = getElTrackAt(args, flags, args.pos, args.index); const auto trackPieces = World::TrackData::getTrackPiece(args.trackId); auto& trackPiece = trackPieces[args.index]; const auto trackStart = args.pos - World::Pos3{ Math::Vector::rotate(World::Pos2{ trackPiece.x, trackPiece.y }, args.rotation), trackPiece.z }; // NB: moved out of the loop below (was at 0x0049CC1B) const currency32_t pieceRemovalCost = trackRemoveCost(args, trackPieces[0], trackStart, flags); bool trackHadBridge = false; // 0x0113605B int8_t trackBridgeId = -1; // 0x0113605C for (auto& piece : trackPieces) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; if (shouldInvalidateTile(flags)) { World::TileManager::mapInvalidateTileFull(trackLoc); } auto* pieceElTrack = getElTrackAt(args, flags, trackLoc, piece.index); if (pieceElTrack == nullptr) { return FAILURE; } if (pieceElTrack->hasBridge()) { trackHadBridge = true; trackBridgeId = pieceElTrack->bridge(); } if (!(flags & Flags::apply)) { continue; } World::TileManager::removeElement(*reinterpret_cast<World::TileElement*>(pieceElTrack)); World::TileManager::setLevelCrossingFlags(trackLoc); } totalRemovalCost += pieceRemovalCost; if (trackHadBridge) { const auto* bridgeObj = ObjectManager::get<BridgeObject>(trackBridgeId); const auto bridgeBaseCost = Economy::getInflationAdjustedCost(bridgeObj->sellCostFactor, bridgeObj->costIndex, 10); totalRemovalCost += (bridgeBaseCost * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; } if (flags & Flags::apply) { if (!(flags & (Flags::aiAllocated | Flags::ghost))) { playTrackRemovalSound(args.pos); } } return totalRemovalCost; } void removeTrack(registers& regs) { regs.ebx = removeTrack(TrackRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveTrack.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TrackRemovalArgs { static constexpr auto command = GameCommand::removeTrack; TrackRemovalArgs() = default; explicit TrackRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh) , trackObjectId(regs.ebp) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t trackObjectId; explicit operator registers() const { registers regs; regs.eax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.ebp = trackObjectId; return regs; } }; void removeTrack(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveTrackMod.cpp ```cpp #include "RemoveTrackMod.h" #include "Economy/Expenditures.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Ui/WindowManager.h" #include "Vehicles/Vehicle.h" #include <OpenLoco/Math/Vector.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x004A668A static currency32_t removeTrackMod(const TrackModsRemovalArgs& args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); auto* elTrack = [&args]() -> const World::TrackElement* { const auto tile = World::TileManager::get(args.pos); for (const auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != args.pos.z) { continue; } if (elTrack->rotation() != args.rotation) { continue; } if (elTrack->sequenceIndex() != args.index) { continue; } if (elTrack->trackObjectId() != args.trackObjType) { continue; } if (elTrack->trackId() != args.trackId) { continue; } return elTrack; } return nullptr; }(); if (elTrack == nullptr) { return FAILURE; } if (!sub_431E6A(elTrack->owner(), reinterpret_cast<const World::TileElement*>(elTrack))) { return FAILURE; } const auto& piece = World::TrackData::getTrackPiece(elTrack->trackId())[elTrack->sequenceIndex()]; const auto offsetToFirstTile = World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, elTrack->rotation()), piece.z }; const auto firstTilePos = args.pos - offsetToFirstTile; const auto tad = Vehicles::TrackAndDirection::_TrackAndDirection(elTrack->trackId(), elTrack->rotation()); auto cost = Vehicles::removeTrackModsToTrackNetwork(firstTilePos, tad, elTrack->owner(), args.trackObjType, flags, args.modSection, args.type); return cost; } void removeTrackMod(registers& regs) { regs.ebx = removeTrackMod(TrackModsRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveTrackMod.h ```h #include "GameCommands/GameCommands.h" #include "Map/Track/TrackModSection.h" namespace OpenLoco::GameCommands { struct TrackModsRemovalArgs { static constexpr auto command = GameCommand::removeTrackMod; TrackModsRemovalArgs() = default; explicit TrackModsRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh & 0x3) , type((regs.edi >> 16) & 0xF) , trackObjType(regs.ebp & 0xFF) , modSection(static_cast<World::Track::ModSection>((regs.ebp >> 16) & 0xFF)) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t type; uint8_t trackObjType; World::Track::ModSection modSection; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.edi = pos.z | (type << 16); regs.ebp = trackObjType | (enumValue(modSection) << 16); return regs; } }; void removeTrackMod(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveTrainStation.cpp ```cpp #include "RemoveTrainStation.h" #include "Economy/Economy.h" #include "Map/StationElement.h" #include "Map/TileElement.h" #include "Map/TileManager.h" #include "Map/Track/TrackData.h" #include "Map/TrackElement.h" #include "Objects/ObjectManager.h" #include "Objects/TrainStationObject.h" #include "ViewportManager.h" #include "World/Station.h" #include "World/StationManager.h" namespace OpenLoco::GameCommands { // TODO: based on CreateTrainStation.cpp static World::TrackElement* getElTrack(World::Pos3 pos, uint8_t rotation, uint8_t trackObjectId, uint8_t trackId, uint8_t index) { auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elTrack = el.as<World::TrackElement>(); if (elTrack == nullptr) { continue; } if (elTrack->baseHeight() != pos.z) { continue; } if (elTrack->rotation() != rotation) { continue; } if (elTrack->sequenceIndex() != index) { continue; } if (elTrack->trackId() != trackId) { continue; } if (elTrack->trackObjectId() != trackObjectId) { continue; } return elTrack; } return nullptr; } // 0x0048C402 static currency32_t removeTrainStation(const TrainStationRemovalArgs& args, const uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(args.pos + World::Pos3(16, 16, 0)); bool updateStationTileRegistration = true; auto* initialElTrack = getElTrack(args.pos, args.rotation, args.type, args.trackId, args.index); if (initialElTrack == nullptr) { return FAILURE; } if (!sub_431E6A(initialElTrack->owner(), reinterpret_cast<const World::TileElement*>(initialElTrack))) { return FAILURE; } const auto& trackPieces = World::TrackData::getTrackPiece(args.trackId); const auto& argPiece = trackPieces[args.index]; const auto trackStart = args.pos - World::Pos3(Math::Vector::rotate(World::Pos2(argPiece.x, argPiece.y), args.rotation), argPiece.z); StationId foundStationId = StationId::null; currency32_t totalCost = 0; for (auto& piece : trackPieces) { const auto trackLoc = trackStart + World::Pos3{ Math::Vector::rotate(World::Pos2{ piece.x, piece.y }, args.rotation), piece.z }; auto* elTrack = getElTrack(trackLoc, args.rotation, args.type, args.trackId, piece.index); if (elTrack == nullptr) { return FAILURE; } auto* nextEl = elTrack->next(); auto* stationEl = nextEl->as<World::StationElement>(); if (stationEl == nullptr) { return FAILURE; } if (stationEl->isGhost()) { updateStationTileRegistration = false; } foundStationId = stationEl->stationId(); auto* stationObj = ObjectManager::get<TrainStationObject>(stationEl->objectId()); if (piece.index == 0) { auto removeCostBase = Economy::getInflationAdjustedCost(stationObj->sellCostFactor, stationObj->costIndex, 8); totalCost += (removeCostBase * World::TrackData::getTrackMiscData(args.trackId).costFactor) / 256; } if ((flags & Flags::apply) != 0) { elTrack->setClearZ(elTrack->clearZ() - stationObj->height); Ui::ViewportManager::invalidate(World::Pos2(trackLoc), stationEl->baseHeight(), stationEl->clearHeight(), ZoomLevel::eighth); elTrack->setHasStationElement(false); World::TileManager::removeElement(*nextEl); } } if (updateStationTileRegistration && (flags & Flags::apply) != 0) { auto* station = StationManager::get(foundStationId); removeTileFromStationAndRecalcCargo(foundStationId, trackStart, args.rotation); station->invalidate(); recalculateStationModes(foundStationId); recalculateStationCenter(foundStationId); station->updateLabel(); station->invalidate(); sub_48D794(*station); } return totalCost; } void removeTrainStation(registers& regs) { regs.ebx = removeTrainStation(TrainStationRemovalArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Track/RemoveTrainStation.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct TrainStationRemovalArgs { static constexpr auto command = GameCommand::removeTrainStation; TrainStationRemovalArgs() = default; explicit TrainStationRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , trackId(regs.dl & 0x3F) , index(regs.dh & 0xF) , type(regs.bp & 0xF) { } World::Pos3 pos; uint8_t rotation; uint8_t trackId; uint8_t index; uint8_t type; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.bh = rotation; regs.dl = trackId; regs.dh = index; regs.bp = type; return regs; } }; void removeTrainStation(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/BuildCompanyHeadquarters.cpp ```cpp #include "BuildCompanyHeadquarters.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/Buildings/CreateBuilding.h" #include "GameCommands/Company/RemoveCompanyHeadquarters.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" namespace OpenLoco::GameCommands { // 0x0042ECFC static uint32_t buildCompanyHeadquarters(HeadquarterPlacementArgs args, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(World::Pos3(args.pos.x + World::kTileSize / 2, args.pos.y + World::kTileSize / 2, args.pos.z)); currency32_t totalCost = 0; auto targetCompanyId = getUpdatingCompanyId(); auto* company = CompanyManager::get(targetCompanyId); if (company->headquartersX != -1 && !(flags & Flags::ghost)) { HeadquarterRemovalArgs rmArgs{}; rmArgs.pos = World::Pos3(company->headquartersX, company->headquartersY, company->headquartersZ * World::kSmallZStep); auto rmCost = doCommand(rmArgs, flags); if (rmCost != FAILURE) { totalCost += rmCost; } else { return FAILURE; } } BuildingPlacementArgs buildArgs{}; buildArgs.pos = args.pos; buildArgs.rotation = args.rotation; buildArgs.type = args.type; buildArgs.variation = company->getHeadquarterPerformanceVariation(); buildArgs.colour = CompanyManager::getCompanyColour(targetCompanyId); buildArgs.buildImmediately = args.buildImmediately; auto buildCost = doCommand(buildArgs, flags); if (buildCost != FAILURE) { totalCost += buildCost; } else { return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { company->headquartersX = args.pos.x; company->headquartersY = args.pos.y; company->headquartersZ = args.pos.z / World::kSmallZStep; Ui::WindowManager::invalidate(Ui::WindowType::company, Ui::WindowNumber_t(targetCompanyId)); } if ((flags & Flags::apply) && !(flags & (Flags::aiAllocated | Flags::ghost))) { Audio::playSound(Audio::SoundId::construct, args.pos); } return totalCost; } void buildCompanyHeadquarters(registers& regs) { HeadquarterPlacementArgs args(regs); regs.ebx = buildCompanyHeadquarters(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/BuildCompanyHeadquarters.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct HeadquarterPlacementArgs { static constexpr auto command = GameCommand::buildCompanyHeadquarters; HeadquarterPlacementArgs() = default; explicit HeadquarterPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , type(regs.dl) , buildImmediately(regs.bh & 0x80) { } World::Pos3 pos; uint8_t rotation; uint8_t type; bool buildImmediately = false; // No scaffolding required (editor mode) explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; regs.dx = type; regs.bh = rotation | (buildImmediately ? 0x80 : 0); return regs; } }; void buildCompanyHeadquarters(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/ChangeCompanyColour.cpp ```cpp #include "ChangeCompanyColour.h" #include "Audio/Audio.h" #include "GameCommands/GameCommands.h" #include "GameException.hpp" #include "Localisation/StringIds.h" #include "OpenLoco.h" #include "Ui/WindowManager.h" #include "Ui/WindowType.h" #include "World/CompanyManager.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0043483D static uint32_t changeCompanyColour(const ChangeCompanyColourSchemeArgs& args, uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); GameCommands::setPosition({ static_cast<int16_t>(0x8000), 0, 0 }); auto* company = CompanyManager::get(args.companyId); if (flags & Flags::apply) { // Toggling vehicle palette if (args.setColourMode) { if (args.value) { company->customVehicleColoursSet |= (1 << args.colourType); } else { company->customVehicleColoursSet &= ~(1 << args.colourType); } } // Setting a colour else { ColourScheme* colours; if (args.colourType == 0) { colours = &company->mainColours; } else { colours = &company->vehicleColours[args.colourType - 1]; } if (args.isPrimary) { colours->primary = static_cast<Colour>(args.value); } else { colours->secondary = static_cast<Colour>(args.value); } } company->updateVehicleColours(); CompanyManager::updateColours(); company->updateHeadquartersColour(); Ui::WindowManager::invalidate(Ui::WindowType::company); return 0; } else { if (!sub_431E6A(args.companyId, nullptr)) { return GameCommands::FAILURE; } if (args.setColourMode || args.colourType > 0 || !args.isPrimary) { return 0; } // Check whether the requested colour is available uint32_t unavailableColours = CompanyManager::competingColourMask(args.companyId); if (unavailableColours & (1 << args.value)) { setErrorText(StringIds::empty); return GameCommands::FAILURE; } } return 0; } void changeCompanyColour(registers& regs) { regs.ebx = changeCompanyColour(ChangeCompanyColourSchemeArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/ChangeCompanyColour.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct ChangeCompanyColourSchemeArgs { static constexpr auto command = GameCommand::changeCompanyColourScheme; ChangeCompanyColourSchemeArgs() = default; explicit ChangeCompanyColourSchemeArgs(const registers& regs) : companyId(CompanyId(regs.dl)) , isPrimary() , value(regs.al) , colourType(regs.cl) , setColourMode(regs.dh) { if (!setColourMode) { isPrimary = regs.ah == 0; } } CompanyId companyId; bool isPrimary; uint8_t value; uint8_t colourType; bool setColourMode; explicit operator registers() const { registers regs; regs.cl = colourType; // vehicle type or main regs.dh = setColourMode; // [ 0, 1 ] -- 0 = set colour, 1 = toggle enabled/disabled; regs.dl = enumValue(companyId); // company id if (!setColourMode) { // cl is divided by 2 when used regs.ah = isPrimary ? 1 : 0; // [ 0, 1 ] -- primary or secondary palette regs.al = value; // new colour } else if (setColourMode) { regs.al = value; // [ 0, 1 ] -- off or on } return regs; } }; void changeCompanyColour(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/ChangeCompanyFace.cpp ```cpp #include "ChangeCompanyFace.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Objects/CompetitorObject.h" #include "Objects/ObjectManager.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x00435506 static uint32_t changeCompanyFace(uint8_t flags, CompanyId targetCompanyId, ObjectHeader& targetHeader) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); GameCommands::setPosition({ static_cast<int16_t>(0x8000), 0, 0 }); // Find target competitor object among loaded objects auto foundCompetitor = ObjectManager::findObjectHandle(targetHeader); if (foundCompetitor) { // See whether any other company is using this competitor already for (auto& company : CompanyManager::companies()) { if (company.competitorId != foundCompetitor->id) { continue; } if (company.id() != targetCompanyId) { GameCommands::setErrorText(StringIds::already_selected_for_another_company); return GameCommands::FAILURE; } else { // No change; no work required return 0; } } } // Stop here if we're just querying if ((flags & GameCommands::Flags::apply) == 0) { return 0; } // Do we need to load the competitor, still? if (!foundCompetitor) { // Load the new competitor object if (!ObjectManager::load(targetHeader)) { return GameCommands::FAILURE; } ObjectManager::reloadAll(); Ui::WindowManager::close(Ui::WindowType::dropdown); foundCompetitor = ObjectManager::findObjectHandle(targetHeader); if (!foundCompetitor) { return GameCommands::FAILURE; } } // Any other company also using the same competitor? // (This shouldn't happen, but might have been hacked in) bool otherCompanyUsingOldCompetitor = false; for (auto& company : CompanyManager::companies()) { if (company.id() == targetCompanyId) { continue; } if (company.competitorId == foundCompetitor->id) { otherCompanyUsingOldCompetitor = true; break; } } // Unload the target company's current competitor, if no other company is using it auto* targetCompany = CompanyManager::get(targetCompanyId); if (!otherCompanyUsingOldCompetitor) { auto& headerToUnload = ObjectManager::getHeader({ ObjectType::competitor, targetCompany->competitorId }); ObjectManager::unload(headerToUnload); ObjectManager::reloadAll(); Ui::WindowManager::close(Ui::WindowType::dropdown); } // Set the new competitor id targetCompany->competitorId = foundCompetitor->id; // Non-player companies should use the competitor object name if (!CompanyManager::isPlayerCompany(targetCompanyId)) { auto* competitor = ObjectManager::get<CompetitorObject>(foundCompetitor->id); auto oldName = targetCompany->name; targetCompany->name = competitor->name; StringManager::emptyUserString(oldName); } Gfx::invalidateScreen(); return 0; } void changeCompanyFace(registers& regs) { ChangeCompanyFaceArgs args(regs); regs.ebx = changeCompanyFace(regs.bl, args.companyId, args.objHeader); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/ChangeCompanyFace.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { void changeCompanyFace(registers& regs); struct ChangeCompanyFaceArgs { static constexpr auto command = GameCommand::changeCompanyFace; ChangeCompanyFaceArgs() = default; explicit ChangeCompanyFaceArgs(const registers& regs) : companyId(CompanyId(regs.bh)) , objHeader() { uint8_t objData[sizeof(ObjectHeader)]{}; uint8_t* objPtr = objData; std::memcpy(objPtr, &regs.eax, sizeof(uint32_t)); objPtr += sizeof(uint32_t); std::memcpy(objPtr, &regs.ecx, sizeof(uint32_t)); objPtr += sizeof(uint32_t); std::memcpy(objPtr, &regs.edx, sizeof(uint32_t)); objPtr += sizeof(uint32_t); std::memcpy(objPtr, &regs.edi, sizeof(uint32_t)); std::memcpy(&objHeader, objData, sizeof(objData)); } CompanyId companyId; ObjectHeader objHeader; explicit operator registers() const { registers regs; regs.bh = enumValue(companyId); // company id uint8_t objData[sizeof(ObjectHeader)]{}; std::memcpy(objData, &objHeader, sizeof(objData)); const uint8_t* objPtr = objData; std::memcpy(&regs.eax, objPtr, sizeof(uint32_t)); objPtr += sizeof(uint32_t); std::memcpy(&regs.ecx, objPtr, sizeof(uint32_t)); objPtr += sizeof(uint32_t); std::memcpy(&regs.edx, objPtr, sizeof(uint32_t)); objPtr += sizeof(uint32_t); std::memcpy(&regs.edi, objPtr, sizeof(uint32_t)); return regs; } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/ChangeLoan.cpp ```cpp #include "ChangeLoan.h" #include "Economy/Economy.h" #include "GameCommands/GameCommands.h" #include "Localisation/StringIds.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x0046DE88 static uint32_t changeLoan(const currency32_t newLoan, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::LoanInterest); auto* company = CompanyManager::get(GameCommands::getUpdatingCompanyId()); const currency32_t loanDifference = company->currentLoan - newLoan; if (company->currentLoan > newLoan) { if (company->cash < loanDifference) { GameCommands::setErrorText(StringIds::not_enough_cash_available); return FAILURE; } } else { const auto maxLoan = Economy::getInflationAdjustedCost(CompanyManager::getMaxLoanSize(), 0, 8); if (newLoan > maxLoan) { GameCommands::setErrorText(StringIds::bank_refuses_to_increase_loan); return FAILURE; } } if (flags & Flags::apply) { company->currentLoan = newLoan; company->cash -= loanDifference; Ui::WindowManager::invalidate(Ui::WindowType::company, static_cast<uint16_t>(GameCommands::getUpdatingCompanyId())); if (CompanyManager::getControllingId() == GameCommands::getUpdatingCompanyId()) { Ui::Windows::PlayerInfoPanel::invalidateFrame(); } } return 0; } void changeLoan(registers& regs) { ChangeLoanArgs args(regs); regs.ebx = changeLoan(args.newLoan, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/ChangeLoan.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct ChangeLoanArgs { static constexpr auto command = GameCommand::changeLoan; ChangeLoanArgs() = default; explicit ChangeLoanArgs(const registers& regs) : newLoan(regs.edx) { } currency32_t newLoan; explicit operator registers() const { registers regs; regs.edx = newLoan; return regs; } }; void changeLoan(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/RemoveCompanyHeadquarters.cpp ```cpp #include "RemoveCompanyHeadquarters.h" #include "Audio/Audio.h" #include "Economy/Expenditures.h" #include "GameCommands/Buildings/RemoveBuilding.h" #include "GameCommands/GameCommands.h" #include "Ui/WindowManager.h" #include "World/CompanyManager.h" namespace OpenLoco::GameCommands { // 0x0042EEAF static uint32_t removeCompanyHeadquarters(World::Pos3 pos, uint8_t flags) { setExpenditureType(ExpenditureType::Construction); setPosition(pos); currency32_t totalCost = 0; auto targetCompanyId = CompanyId::null; if (!(flags & Flags::ghost)) { auto baseZ = pos.z / World::kSmallZStep; for (auto& company : CompanyManager::companies()) { if (company.headquartersX != pos.x) { continue; } if (company.headquartersY != pos.y) { continue; } if (company.headquartersZ != baseZ) { continue; } if (!sub_431E6A(company.id(), nullptr)) { return GameCommands::FAILURE; } targetCompanyId = company.id(); break; } } BuildingRemovalArgs args{}; args.pos = pos; if (auto cost = GameCommands::doCommand(args, flags); cost != FAILURE) { totalCost += cost; } else { return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { auto* company = CompanyManager::get(targetCompanyId); company->headquartersX = -1; Ui::WindowManager::invalidate(Ui::WindowType::company, Ui::WindowNumber_t(targetCompanyId)); } if ((flags & Flags::apply) && !(flags & (Flags::aiAllocated | Flags::ghost))) { Audio::playSound(Audio::SoundId::demolish, pos); } return totalCost; } void removeCompanyHeadquarters(registers& regs) { HeadquarterRemovalArgs args(regs); regs.ebx = removeCompanyHeadquarters(args.pos, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/RemoveCompanyHeadquarters.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct HeadquarterRemovalArgs { static constexpr auto command = GameCommand::removeCompanyHeadquarters; HeadquarterRemovalArgs() = default; explicit HeadquarterRemovalArgs(const World::Pos3& place) : pos(place) { } explicit HeadquarterRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) { } World::Pos3 pos; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; return regs; } }; void removeCompanyHeadquarters(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/RenameCompanyName.cpp ```cpp #include "RenameCompanyName.h" #include "Economy/Expenditures.h" #include "Engine/Limits.h" #include "GameCommands/GameCommands.h" #include "Graphics/Gfx.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Types.hpp" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { /** * 0x00434914 * Renames a particular company. * * This command is called 3 times before the buffer is applied. Each time, 12 chars of the 36 char buffer are provided. * The resulting company name has a maximum length of 31 chars; the last bytes are not used. */ static uint32_t changeCompanyName(const ChangeCompanyNameArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); // Keep track of the company id over several calls. static CompanyId _companyId{}; if (args.bufferIndex == 1) { _companyId = args.companyId; } static char renameBuffer[37]{}; // Fill buffer over calls into the renameBuffer if ((flags & GameCommands::Flags::apply) != 0) { static const std::array<int, 3> transformTable = { 2, 0, 1 }; const int arrayIndex = transformTable.at(args.bufferIndex); std::memcpy(renameBuffer + arrayIndex * 12, args.buffer, 12); } // Applying the buffer? if (args.bufferIndex != 0) { return 0; } char renameStringBuffer[37] = ""; memcpy(renameStringBuffer, renameBuffer, sizeof(renameBuffer)); renameStringBuffer[36] = '\0'; // Ensure the new name isn't empty. if (strlen(renameStringBuffer) == 0) { return 0; } // Retrieve the current name for this company. char currentCompanyName[256] = ""; auto company = CompanyManager::get(_companyId); StringManager::formatString(currentCompanyName, company->name); // Verify the new name actually differs from the old one. if (strcmp(currentCompanyName, renameStringBuffer) == 0) { return 0; } // Verify the name isn't in use by any other company for (auto& rival : CompanyManager::companies()) { if (rival.id() == _companyId) { continue; } char rivalCompanyName[256] = ""; StringManager::formatString(rivalCompanyName, rival.name); if (strcmp(rivalCompanyName, renameStringBuffer) == 0) { GameCommands::setErrorText(StringIds::chosen_name_in_use); return GameCommands::FAILURE; } } // Allocate a string id for the new name. StringId allocatedStringId = StringManager::userStringAllocate(renameStringBuffer, false); if (allocatedStringId == StringIds::empty) { return GameCommands::FAILURE; } // Bailing out early? if ((flags & GameCommands::Flags::apply) == 0) { StringManager::emptyUserString(allocatedStringId); return 0; } // Apply the new name to the company. StringId oldStringId = company->name; company->name = allocatedStringId; StringManager::emptyUserString(oldStringId); Gfx::invalidateScreen(); return 0; } void changeCompanyName(registers& regs) { regs.ebx = changeCompanyName(ChangeCompanyNameArgs(regs), regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/RenameCompanyName.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct ChangeCompanyNameArgs { static constexpr auto command = GameCommand::changeCompanyName; ChangeCompanyNameArgs() = default; explicit ChangeCompanyNameArgs(const registers& regs) : companyId(CompanyId(regs.cx)) , bufferIndex(regs.ax) { memcpy(buffer, &regs.edx, 4); memcpy(buffer + 4, &regs.ebp, 4); memcpy(buffer + 8, &regs.edi, 4); } CompanyId companyId; uint16_t bufferIndex; char buffer[37]; explicit operator registers() const { registers regs; regs.cl = enumValue(companyId); regs.ax = bufferIndex; // [ 0, 1, 2] constexpr std::array<uint8_t, 3> iToOffset = { 24, 0, 12 }; const auto offset = iToOffset[bufferIndex]; std::memcpy(&regs.edx, buffer + offset, 4); std::memcpy(&regs.ebp, buffer + offset + 4, 4); std::memcpy(&regs.edi, buffer + offset + 8, 4); return regs; } }; void changeCompanyName(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/RenameCompanyOwner.cpp ```cpp #include "RenameCompanyOwner.h" #include "ChangeCompanyFace.h" #include "Economy/Expenditures.h" #include "Engine/Limits.h" #include "GameCommands/GameCommands.h" #include "Graphics/Gfx.h" #include "Localisation/Formatting.h" #include "Localisation/StringIds.h" #include "Localisation/StringManager.h" #include "Objects/ObjectIndex.h" #include "Objects/ObjectManager.h" #include "Types.hpp" #include "World/CompanyManager.h" #include <OpenLoco/Interop/Interop.hpp> using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { void tryLoadInstalledFaceForName(const CompanyId id, const char* companyName); /** * 0x00434914 * Renames a particular company owner. * * This command is called 3 times before the buffer is applied. Each time, 12 chars of the 36 char buffer are provided. * The resulting company owner name has a maximum length of 31 chars; the last bytes are not used. */ static uint32_t changeCompanyOwnerName(const ChangeCompanyOwnerNameArgs& args, const uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Miscellaneous); // Keep track of the company id over several calls. static CompanyId _companyId{}; if (args.bufferIndex == 1) { _companyId = args.companyId; } static char staticRenameBuffer[37]{}; // Fill buffer over calls into the renameBuffer if ((flags & GameCommands::Flags::apply) != 0) { static const std::array<int, 3> transformTable = { 2, 0, 1 }; int arrayIndex = transformTable.at(args.bufferIndex); std::memcpy(staticRenameBuffer + arrayIndex * 12, args.newName, 12); } // Applying the buffer? if (args.bufferIndex != 0) { return 0; } char renameStringBuffer[37] = ""; memcpy(renameStringBuffer, staticRenameBuffer, sizeof(staticRenameBuffer)); renameStringBuffer[36] = '\0'; // Ensure the new name isn't empty. if (strlen(renameStringBuffer) == 0) { return 0; } // Retrieve the current name for this company. char currentOwnerName[256] = ""; auto company = CompanyManager::get(_companyId); StringManager::formatString(currentOwnerName, company->ownerName); // Verify the new name actually differs from the old one. if (strcmp(currentOwnerName, renameStringBuffer) == 0) { return 0; } // Verify the name isn't in use by any other company for (auto& rival : CompanyManager::companies()) { if (rival.id() == _companyId) { continue; } char rivalOwnerName[256] = ""; StringManager::formatString(rivalOwnerName, rival.ownerName); if (strcmp(rivalOwnerName, renameStringBuffer) == 0) { GameCommands::setErrorText(StringIds::chosen_name_in_use); return GameCommands::FAILURE; } } // Allocate a string id for the new name. StringId allocatedStringId = StringManager::userStringAllocate(renameStringBuffer, false); if (allocatedStringId == StringIds::empty) { return GameCommands::FAILURE; } // Bailing out early? if ((flags & GameCommands::Flags::apply) == 0) { StringManager::emptyUserString(allocatedStringId); return 0; } // Apply the new owner name to the company. StringId oldStringId = company->ownerName; company->ownerName = allocatedStringId; StringManager::emptyUserString(oldStringId); Gfx::invalidateScreen(); tryLoadInstalledFaceForName(_companyId, renameStringBuffer); return 0; } void changeCompanyOwnerName(registers& regs) { regs.ebx = changeCompanyOwnerName(ChangeCompanyOwnerNameArgs(regs), regs.bl); } // 0x00434BA1 void tryLoadInstalledFaceForName(const CompanyId id, const char* companyName) { const auto competitorInstalledObjects = CompanyManager::findAllOtherInUseCompetitors(id); std::optional<ObjectHeader> foundInstalledObject = std::nullopt; for (const auto& object : ObjectManager::getAvailableObjects(ObjectType::competitor)) { auto res = std::find(competitorInstalledObjects.begin(), competitorInstalledObjects.end(), object.index); if (res != competitorInstalledObjects.end()) { continue; } // Copy the string as it needs some processing std::string objectName = object.object._name; // Not sure what ControlCodes::pop16 is doing in the object name but it is at the start of all the object names objectName.erase(std::remove(std::begin(objectName), std::end(objectName), static_cast<char>(ControlCodes::pop16))); auto strcmpSpecial = [](const char* lhs, const char* rhs) { while (*lhs && *rhs) { const auto chr = *lhs; if (chr == '\xFF') { if (chr != *rhs) { return false; } lhs++; rhs++; const uint16_t unkLhs = *reinterpret_cast<const uint16_t*>(lhs); const uint16_t unkRhs = *reinterpret_cast<const uint16_t*>(rhs); if (unkLhs != unkRhs) { return false; } lhs += 2; rhs += 2; continue; } auto toUpper = [](const char chr) -> char { if (chr < 'a' || chr > 'z') { return chr; } return chr - 0x20; }; if (toUpper(chr) != toUpper(*rhs)) { return false; } lhs++; rhs++; } return *lhs == *rhs; }; if (strcmpSpecial(companyName, objectName.c_str())) { foundInstalledObject = object.object._header; break; } } if (foundInstalledObject.has_value()) { ChangeCompanyFaceArgs args{}; args.companyId = id; args.objHeader = foundInstalledObject.value(); auto regs = registers(args); regs.bl = Flags::apply; changeCompanyFace(regs); } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/RenameCompanyOwner.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct ChangeCompanyOwnerNameArgs { static constexpr auto command = GameCommand::changeCompanyOwnerName; ChangeCompanyOwnerNameArgs() = default; explicit ChangeCompanyOwnerNameArgs(const registers& regs) : companyId(CompanyId(regs.cx)) , bufferIndex(regs.ax) { memcpy(newName, &regs.edx, 4); memcpy(newName + 4, &regs.ebp, 4); memcpy(newName + 8, &regs.edi, 4); } CompanyId companyId; uint16_t bufferIndex; char newName[37]; explicit operator registers() const { registers regs; regs.cl = enumValue(companyId); regs.ax = bufferIndex; // [ 0, 1, 2] constexpr std::array<uint8_t, 3> iToOffset = { 24, 0, 12 }; const auto offset = iToOffset[bufferIndex]; std::memcpy(&regs.edx, newName + offset, 4); std::memcpy(&regs.ebp, newName + offset + 4, 4); std::memcpy(&regs.edi, newName + offset + 8, 4); return regs; } }; void changeCompanyOwnerName(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/UpdateOwnerStatus.cpp ```cpp #include "UpdateOwnerStatus.h" #include "GameCommands/GameCommands.h" #include "World/CompanyManager.h" using namespace OpenLoco::Interop; namespace OpenLoco::GameCommands { // 0x004383CA static uint32_t updateOwnerStatus(const uint8_t flags, const OwnerStatus& ownerStatus) { if (flags & Flags::apply) { auto companyId = GameCommands::getUpdatingCompanyId(); auto* company = CompanyManager::get(companyId); if (company == nullptr) { return FAILURE; } company->ownerStatus = ownerStatus; } return 0; } void updateOwnerStatus(registers& regs) { UpdateOwnerStatusArgs args(regs); regs.ebx = updateOwnerStatus(regs.bl, args.ownerStatus); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Company/UpdateOwnerStatus.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct UpdateOwnerStatusArgs { static constexpr auto command = GameCommand::updateOwnerStatus; UpdateOwnerStatusArgs() = default; explicit UpdateOwnerStatusArgs(const registers& regs) : ownerStatus(regs.ax, regs.cx) { } OwnerStatus ownerStatus; explicit operator registers() const { registers regs; int16_t res[2]; ownerStatus.getData(res); regs.ax = res[0]; regs.cx = res[1]; return regs; } }; void updateOwnerStatus(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Buildings/CreateBuilding.cpp ```cpp #include "CreateBuilding.h" #include "Economy/Economy.h" #include "Localisation/StringIds.h" #include "Map/AnimationManager.h" #include "Map/BuildingElement.h" #include "Map/IndustryElement.h" #include "Map/QuarterTile.h" #include "Map/RoadElement.h" #include "Map/StationElement.h" #include "Map/SurfaceElement.h" #include "Map/TileClearance.h" #include "Map/TileManager.h" #include "Map/TrackElement.h" #include "Map/TreeElement.h" #include "Objects/BuildingObject.h" #include "Objects/LandObject.h" #include "Objects/ObjectManager.h" #include "Objects/ScaffoldingObject.h" #include "ScenarioOptions.h" #include "ViewportManager.h" #include "World/Industry.h" #include "World/Station.h" #include "World/TownManager.h" namespace OpenLoco::GameCommands { // 0x0042D133 static uint32_t createBuilding(const BuildingPlacementArgs& args, uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); GameCommands::setPosition(args.pos + World::Pos3{ 16, 16, 0 }); // 0x00525D2C currency32_t totalCost = 0; auto* buildingObj = ObjectManager::get<BuildingObject>(args.type); if (!World::TileManager::checkFreeElementsAndReorganise()) { return FAILURE; } if (!buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { auto nearest = TownManager::getClosestTownAndDensity(args.pos); if (!nearest.has_value()) { setErrorText(StringIds::town_must_be_built_first); return FAILURE; } } // This is identical to createIndustry but with a BuildingObject // TODO: look into making some sort of common version auto clearHeight = 0; const auto partHeights = buildingObj->getBuildingPartHeights(); for (auto part : buildingObj->getBuildingParts(args.variation)) { clearHeight += partHeights[part]; } if (!args.buildImmediately && buildingObj->scaffoldingSegmentType != 0xFF) { auto* scaffObj = ObjectManager::get<ScaffoldingObject>(); const auto segmentHeight = scaffObj->segmentHeights[buildingObj->scaffoldingSegmentType]; const bool requiresMore = clearHeight % segmentHeight; const auto numSegments = (clearHeight / segmentHeight) + (requiresMore ? 1 : 0); clearHeight = (numSegments * segmentHeight) + scaffObj->roofHeights[buildingObj->scaffoldingSegmentType]; } // ceil to 4 clearHeight += 3; clearHeight &= ~3; World::TileClearance::RemovedBuildings removedBuildings; const auto buildingFootprint = getBuildingTileOffsets(buildingObj->hasFlags(BuildingObjectFlags::largeTile)); for (auto& offset : buildingFootprint) { const auto tilePos = World::toTileSpace(World::Pos2(args.pos) + offset.pos); if (!World::validCoords(tilePos)) { return FAILURE; } if ((flags & Flags::apply) && !(flags & Flags::ghost)) { World::TileManager::removeAllWallsOnTileBelow(tilePos, (args.pos.z + clearHeight) / World::kSmallZStep); } { auto tile = World::TileManager::get(tilePos); const auto* surface = tile.surface(); // Perform clearance checks if (surface->water()) { setErrorText(StringIds::cant_build_this_underwater); return FAILURE; } const auto baseZ = std::min<World::SmallZ>(surface->baseZ(), (args.pos.z / World::kSmallZStep)); const auto clearZ = (args.pos.z + clearHeight) / World::kSmallZStep; World::QuarterTile qt(0xF, 0xF); auto clearFunc = [tilePos, &removedBuildings, flags, &totalCost](World::TileElement& el) { switch (el.type()) { case World::ElementType::tree: { auto* elTree = el.as<World::TreeElement>(); if (elTree == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } return World::TileClearance::clearTreeCollision(*elTree, World::toWorldSpace(tilePos), flags, totalCost); } case World::ElementType::building: { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { return World::TileClearance::ClearFuncResult::noCollision; } // This is used to stop creating a building ghost // even if a clear could succeed here. This is // because if it did place a ghost the ghost cleanup // function might remove the wrong building! if (flags & Flags::preventBuildingClearing) { return World::TileClearance::ClearFuncResult::collision; } return World::TileClearance::clearBuildingCollision(*elBuilding, World::toWorldSpace(tilePos), removedBuildings, flags, totalCost); } default: return World::TileClearance::ClearFuncResult::collision; } }; if (!World::TileClearance::applyClearAtStandardHeight(World::toWorldSpace(tilePos), baseZ, clearZ, qt, clearFunc)) { return FAILURE; } // TODO: This is dangerous pointer might be invalid? if (surface->slope() || surface->baseHeight() != args.pos.z) { const auto* landObj = ObjectManager::get<LandObject>(surface->terrain()); totalCost += Economy::getInflationAdjustedCost(landObj->costFactor, landObj->costIndex, 10); } } // Flatten surfaces (also checks if other elements will cause issues due to the flattening of the surface) if (!(flags & Flags::ghost)) { auto tile = World::TileManager::get(tilePos); auto* surface = tile.surface(); // TODO: This is identical to CreateIndustry if (surface->slope() || args.pos.z != surface->baseHeight()) { if (args.pos.z < surface->baseHeight()) { bool hasPassedSurface = false; for (auto& el : tile) { if (el.type() == World::ElementType::surface) { hasPassedSurface = true; continue; } if (hasPassedSurface) { auto* elTrack = el.as<World::TrackElement>(); auto* elRoad = el.as<World::RoadElement>(); auto* elStation = el.as<World::StationElement>(); auto* elBuilding = el.as<World::BuildingElement>(); auto* elIndustry = el.as<World::IndustryElement>(); auto* elTree = el.as<World::TreeElement>(); if (elTrack != nullptr && !elTrack->isGhost() && !elTrack->hasBridge()) { setErrorText(StringIds::empty); return FAILURE; } else if (elRoad != nullptr && !elRoad->isGhost() && !elRoad->hasBridge()) { setErrorText(StringIds::empty); return FAILURE; } else if (elStation != nullptr && elStation->stationType() == StationType::airport) { setErrorText(StringIds::empty); return FAILURE; } else if (elBuilding != nullptr) { setErrorText(StringIds::empty); return FAILURE; } else if (elIndustry != nullptr) { setErrorText(StringIds::empty); return FAILURE; } else if (elTree != nullptr && args.pos.z + clearHeight <= elTree->baseHeight()) { setErrorText(StringIds::empty); return FAILURE; } } } } if (flags & Flags::apply) { World::TileManager::mapInvalidateTileFull(World::toWorldSpace(tilePos)); surface->setBaseZ(args.pos.z / World::kSmallZStep); surface->setClearZ(args.pos.z / World::kSmallZStep); surface->setSlope(0); surface->setSnowCoverage(0); surface->setGrowthStage(0); } } } // Create new tile if (flags & Flags::apply) { if (!(flags & Flags::ghost)) { World::TileManager::removeSurfaceIndustry(World::toWorldSpace(tilePos)); World::TileManager::setTerrainStyleAsCleared(World::toWorldSpace(tilePos)); } auto* elBuilding = World::TileManager::insertElement<World::BuildingElement>(World::toWorldSpace(tilePos), args.pos.z / World::kSmallZStep, 0xF); if (elBuilding == nullptr) { return FAILURE; } elBuilding->setClearZ((clearHeight / World::kSmallZStep) + elBuilding->baseZ()); elBuilding->setRotation(args.rotation); elBuilding->setConstructed(args.buildImmediately); if (args.buildImmediately && offset.index == 0 && buildingObj->numElevatorSequences != 0) { World::AnimationManager::createAnimation(5, World::toWorldSpace(tilePos), elBuilding->baseZ()); } elBuilding->setObjectId(args.type); elBuilding->setSequenceIndex(offset.index); elBuilding->setUnk5u(0); elBuilding->setColour(args.colour); elBuilding->setVariation(args.variation); elBuilding->setAge(0); elBuilding->setIsMiscBuilding(buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)); bool hasFrames = false; const auto partAnimations = buildingObj->getBuildingPartAnimations(); for (auto part : buildingObj->getBuildingParts(args.variation)) { if (partAnimations[part].numFrames > 1) { hasFrames = true; } } if (hasFrames) { World::AnimationManager::createAnimation(6, World::toWorldSpace(tilePos), elBuilding->baseZ()); } elBuilding->setGhost(flags & Flags::ghost); Ui::ViewportManager::invalidate(World::toWorldSpace(tilePos), elBuilding->baseHeight(), elBuilding->clearHeight()); Scenario::getOptions().madeAnyChanges = 1; } } if ((flags & Flags::apply) && !(flags & Flags::ghost) && !buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { const auto populationCapacity = buildingObj->producedQuantity[0]; const auto population = args.buildImmediately ? populationCapacity : 0; auto* town = TownManager::updateTownInfo(args.pos, population, populationCapacity, 0, 1); if (town != nullptr) { if (buildingObj->var_AC != 0xFF) { town->var_150[buildingObj->var_AC]++; } } } return totalCost; } void createBuilding(registers& regs) { BuildingPlacementArgs args(regs); regs.ebx = createBuilding(args, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Buildings/CreateBuilding.h ```h #pragma once #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct BuildingPlacementArgs { static constexpr auto command = GameCommand::createBuilding; BuildingPlacementArgs() = default; explicit BuildingPlacementArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) , rotation(regs.bh & 0x3) , type(regs.dl) , variation(regs.dh) , colour(static_cast<Colour>((regs.edi >> 16) & 0x1F)) , buildImmediately(regs.bh & 0x80) { } World::Pos3 pos; uint8_t rotation; uint8_t type; uint8_t variation; Colour colour; bool buildImmediately = false; // No scaffolding required (editor mode) explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.edi = pos.z | (enumValue(colour) << 16); regs.dl = type; regs.dh = variation; regs.bh = rotation | (buildImmediately ? 0x80 : 0); return regs; } }; void createBuilding(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Buildings/RemoveBuilding.cpp ```cpp #include "RemoveBuilding.h" #include "Economy/Economy.h" #include "GameCommands/GameCommands.h" #include "Localisation/FormatArguments.hpp" #include "Localisation/StringIds.h" #include "Map/BuildingElement.h" #include "Map/TileManager.h" #include "Objects/BuildingObject.h" #include "ScenarioOptions.h" #include "SceneManager.h" #include "World/CompanyManager.h" #include "World/Industry.h" #include "World/TownManager.h" namespace OpenLoco::GameCommands { // 0x00497D8D static std::optional<int16_t> getCompanyRating(World::Pos2& pos) { auto companyId = GameCommands::getUpdatingCompanyId(); if (companyId != CompanyId::neutral) { auto res = TownManager::getClosestTownAndDensity(pos); if (res.has_value()) { auto townId = res->first; auto town = TownManager::get(townId); if (town != nullptr) { return town->companyRatings[enumValue(companyId)]; } } } return std::nullopt; } // 0x0042D74E static uint32_t removeBuilding(World::Pos3& pos, uint8_t flags) { GameCommands::setExpenditureType(ExpenditureType::Construction); GameCommands::setPosition(pos); auto tile = World::TileManager::get(pos); for (auto& el : tile) { auto* elBuilding = el.as<World::BuildingElement>(); if (elBuilding == nullptr) { continue; } if (elBuilding->baseZ() != pos.z / World::kSmallZStep) { continue; } const auto* buildingObj = elBuilding->getObject(); if (!SceneManager::isEditorMode()) { if ((flags & (GameCommands::Flags::ghost | GameCommands::Flags::flag_7)) == 0) { bool isPlayerCompany = CompanyManager::isPlayerCompany(GameCommands::getUpdatingCompanyId()); if (!(SceneManager::isSandboxMode() && isPlayerCompany) && buildingObj->hasFlags(BuildingObjectFlags::indestructible)) { GameCommands::setErrorText(StringIds::demolition_not_allowed); return GameCommands::FAILURE; } if (!buildingObj->hasFlags(BuildingObjectFlags::miscBuilding)) { auto rating = getCompanyRating(pos); if (rating.has_value() && *rating < 0) { auto res = TownManager::getClosestTownAndDensity(pos); auto* town = TownManager::get(res->first); auto formatArgs = FormatArguments::common(); formatArgs.push(town->name); GameCommands::setErrorText(StringIds::local_authority_refuses_permission); return GameCommands::FAILURE; } } } } auto animOffsets = getBuildingTileOffsets(buildingObj->hasFlags(BuildingObjectFlags::largeTile)); for (auto animOffset : animOffsets) { const auto subTilePos = animOffset.pos + pos; auto subTile = World::TileManager::get(subTilePos); for (auto& element : subTile) { auto* subElBuilding = element.as<World::BuildingElement>(); if (subElBuilding == nullptr) { continue; } if (subElBuilding->baseZ() != pos.z / World::kSmallZStep) { continue; } if (flags & GameCommands::Flags::apply) { World::TileManager::removeBuildingElement(subElBuilding->get<World::BuildingElement>(), subTilePos); auto& options = Scenario::getOptions(); options.madeAnyChanges = 1; } } } return Economy::getInflationAdjustedCost(buildingObj->clearCostFactor, buildingObj->clearCostIndex, 8); } return GameCommands::FAILURE; } void removeBuilding(registers& regs) { BuildingRemovalArgs args(regs); regs.ebx = removeBuilding(args.pos, regs.bl); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/OpenLoco/src/GameCommands/Buildings/RemoveBuilding.h ```h #pragma once #include "GameCommands/Buildings/CreateBuilding.h" #include "GameCommands/GameCommands.h" namespace OpenLoco::GameCommands { struct BuildingRemovalArgs { static constexpr auto command = GameCommand::removeBuilding; BuildingRemovalArgs() = default; explicit BuildingRemovalArgs(const registers& regs) : pos(regs.ax, regs.cx, regs.di) { } explicit BuildingRemovalArgs(const BuildingPlacementArgs& place) : pos(place.pos) { } World::Pos3 pos; explicit operator registers() const { registers regs; regs.ax = pos.x; regs.cx = pos.y; regs.di = pos.z; return regs; } }; void removeBuilding(registers& regs); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/CMakeLists.txt ```txt set(public_files "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/BinaryStream.h" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/BitSet.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/EnumFlags.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/Exception.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/FileStream.h" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/FileSystem.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/LocoFixedVector.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/MemoryStream.h" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/Numerics.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/Prng.h" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/Stream.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/Timer.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Core/Traits.hpp" ) set(private_files "${CMAKE_CURRENT_SOURCE_DIR}/src/BinaryStream.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/FileStream.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/MemoryStream.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/Numerics.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/Prng.cpp" ) set(test_files "${CMAKE_CURRENT_SOURCE_DIR}/tests/EnumFlagsTests.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/FileStreamTests.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/MemoryStreamTests.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/NumericsTests.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/PrngTests.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/TimerTest.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/TraitsTest.cpp" ) loco_add_library(Core STATIC PUBLIC_FILES ${public_files} PRIVATE_FILES ${private_files} TEST_FILES ${test_files} ) target_link_libraries(Core PUBLIC fmt::fmt sfl::sfl ) ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/EnumFlagsTests.cpp ```cpp #include <OpenLoco/Core/EnumFlags.hpp> #include <gtest/gtest.h> enum class TestFlags : std::uint32_t { none = 0, a = 1U << 0, b = 1U << 2, c = 1U << 4, d = 1U << 8, e = 1U << 16, f = 1U << 24, g = 1U << 31, }; OPENLOCO_ENABLE_ENUM_OPERATORS(TestFlags); TEST(EnumFlagsTest, operatorOr) { constexpr TestFlags flags = TestFlags::a | TestFlags::c | TestFlags::d | TestFlags::g; constexpr auto value = static_cast<std::underlying_type_t<TestFlags>>(flags); ASSERT_EQ(value, 0b1000'0000'0000'0000'0000'0001'0001'0001); } TEST(EnumFlagsTest, operatorAnd) { constexpr TestFlags flags = (TestFlags::a | TestFlags::c | TestFlags::d | TestFlags::g) & TestFlags::c; constexpr auto value = static_cast<std::underlying_type_t<TestFlags>>(flags); ASSERT_EQ(value, 0b0000'0000'0000'0000'0000'0000'0001'0000); } TEST(EnumFlagsTest, operatorXor) { constexpr TestFlags flags = (TestFlags::a | TestFlags::c | TestFlags::d) ^ (TestFlags::a | TestFlags::c | TestFlags::d) ^ TestFlags::f; constexpr auto value = static_cast<std::underlying_type_t<TestFlags>>(flags); ASSERT_EQ(value, 0b0000'0001'0000'0000'0000'0000'0000'0000); } TEST(EnumFlagsTest, operatorOrInplace) { TestFlags flags = TestFlags::none; flags |= TestFlags::a; flags |= TestFlags::c; flags |= TestFlags::d; flags |= TestFlags::g; auto value = static_cast<std::underlying_type_t<TestFlags>>(flags); ASSERT_EQ(value, 0b1000'0000'0000'0000'0000'0001'0001'0001); } TEST(EnumFlagsTest, operatorAndInplace) { TestFlags flags = (TestFlags::a | TestFlags::c | TestFlags::d | TestFlags::g); flags &= TestFlags::c; auto value = static_cast<std::underlying_type_t<TestFlags>>(flags); ASSERT_EQ(value, 0b0000'0000'0000'0000'0000'0000'0001'0000); } TEST(EnumFlagsTest, operatorXorInplace) { TestFlags flags = (TestFlags::a | TestFlags::c | TestFlags::d); flags ^= (TestFlags::a | TestFlags::c | TestFlags::d); flags ^= TestFlags::f; auto value = static_cast<std::underlying_type_t<TestFlags>>(flags); ASSERT_EQ(value, 0b0000'0001'0000'0000'0000'0000'0000'0000); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/FileStreamTests.cpp ```cpp #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Core/FileStream.h> #include <array> #include <cstdio> #include <filesystem> #include <gtest/gtest.h> #include <numeric> using namespace OpenLoco; static std::filesystem::path getTempFilePath() { char tempNameBuf[L_tmpnam]{}; #ifdef _MSC_VER tmpnam_s(tempNameBuf, L_tmpnam); const char* tempName = tempNameBuf; #else const char* tempName = tmpnam(tempNameBuf); #endif auto tempDir = std::filesystem::temp_directory_path(); auto tempFile = tempDir / tempName; return tempFile; } using DataBuffer = std::vector<uint8_t>; static auto generateData(size_t dataLength) { DataBuffer data(dataLength); for (size_t i = 0; i < dataLength; i++) { data[i] = static_cast<uint8_t>(i % 256); } return data; } static void generateFile(const std::filesystem::path& filePath, const DataBuffer& inputBytes) { FileStream streamOut(filePath, StreamMode::write); ASSERT_EQ(streamOut.getLength(), 0); ASSERT_EQ(streamOut.getPosition(), 0); streamOut.write(inputBytes.data(), inputBytes.size()); ASSERT_EQ(streamOut.getLength(), inputBytes.size()); ASSERT_EQ(streamOut.getPosition(), inputBytes.size()); } TEST(FileStreamTest, testWriteRead) { const auto testDataSize = 4; const auto testData = generateData(testDataSize); const auto filePath = getTempFilePath(); generateFile(filePath, testData); FileStream streamIn(filePath, StreamMode::read); ASSERT_EQ(streamIn.getLength(), testData.size()); ASSERT_EQ(streamIn.getPosition(), 0); auto readBuffer = DataBuffer(testDataSize); streamIn.read(readBuffer.data(), readBuffer.size()); ASSERT_EQ(readBuffer, testData); streamIn.close(); std::filesystem::remove(filePath); } TEST(FileStreamTest, testBadRead) { const auto testDataSize = 4; const auto testData = generateData(testDataSize); const auto filePath = getTempFilePath(); generateFile(filePath, testData); FileStream streamIn(filePath, StreamMode::read); ASSERT_EQ(streamIn.getLength(), testData.size()); ASSERT_EQ(streamIn.getPosition(), 0); streamIn.setPosition(2); ASSERT_EQ(streamIn.getPosition(), 2); std::array<uint8_t, 4> readBuffer{}; EXPECT_THROW(streamIn.read(readBuffer.data(), readBuffer.size()), Exception::RuntimeError); streamIn.close(); std::filesystem::remove(filePath); } TEST(FileStreamTest, testPosition) { const auto testDataSize = 4; const auto testData = generateData(testDataSize); const auto filePath = getTempFilePath(); FileStream streamOut(filePath, StreamMode::write); ASSERT_EQ(streamOut.getLength(), 0); ASSERT_EQ(streamOut.getPosition(), 0); streamOut.write(testData.data(), testData.size()); ASSERT_EQ(streamOut.getLength(), testData.size()); ASSERT_EQ(streamOut.getPosition(), testData.size()); streamOut.setPosition(0); ASSERT_EQ(streamOut.getPosition(), 0); streamOut.setPosition(100); // Sparse files are not supported, the position is always clamped. ASSERT_EQ(streamOut.getPosition(), 4); streamOut.close(); std::filesystem::remove(filePath); } TEST(FileStreamTest, testModeWriteRead) { const auto testDataSize = 4; const auto testData = generateData(testDataSize); const auto filePath = getTempFilePath(); FileStream streamOut(filePath, StreamMode::write); ASSERT_EQ(streamOut.getLength(), 0); ASSERT_EQ(streamOut.getPosition(), 0); streamOut.write(testData.data(), testData.size()); ASSERT_EQ(streamOut.getLength(), testData.size()); ASSERT_EQ(streamOut.getPosition(), testData.size()); streamOut.setPosition(0); ASSERT_EQ(streamOut.getPosition(), 0); DataBuffer readBuffer(testDataSize); EXPECT_THROW(streamOut.read(readBuffer.data(), readBuffer.size()), Exception::InvalidOperation); streamOut.close(); std::filesystem::remove(filePath); } TEST(FileStreamTest, testModeReadWrite) { const auto testDataSize = 4; const auto testData = generateData(testDataSize); const auto filePath = getTempFilePath(); generateFile(filePath, testData); FileStream streamIn(filePath, StreamMode::read); ASSERT_EQ(streamIn.getLength(), testData.size()); ASSERT_EQ(streamIn.getPosition(), 0); EXPECT_THROW(streamIn.write(testData.data(), testData.size()), Exception::InvalidOperation); streamIn.close(); std::filesystem::remove(filePath); } TEST(FileStreamTest, testWrite100MiB) { const auto filePath = getTempFilePath(); FileStream streamOut(filePath, StreamMode::write); ASSERT_EQ(streamOut.getLength(), 0); ASSERT_EQ(streamOut.getPosition(), 0); const auto k100MiB = (1024U * 1024U) * 100U; const std::array<uint8_t, 1> writeBuffer{ 0xFF }; for (size_t i = 0; i < k100MiB; i++) { streamOut.write(writeBuffer.data(), writeBuffer.size()); } ASSERT_EQ(streamOut.getLength(), k100MiB); streamOut.close(); std::filesystem::remove(filePath); } TEST(FileStreamTest, testRead100MiB) { const auto k100MiB = (1024U * 1024U) * 100U; const auto testData = generateData(k100MiB); const auto filePath = getTempFilePath(); generateFile(filePath, testData); FileStream streamIn(filePath, StreamMode::read); ASSERT_EQ(streamIn.getLength(), k100MiB); ASSERT_EQ(streamIn.getPosition(), 0); DataBuffer readBuffer(k100MiB); for (size_t i = 0; i < k100MiB; i++) { streamIn.read(readBuffer.data() + i, 1); } ASSERT_EQ(streamIn.getPosition(), k100MiB); ASSERT_EQ(testData, readBuffer); streamIn.close(); std::filesystem::remove(filePath); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/MemoryStreamTests.cpp ```cpp #include <OpenLoco/Core/Exception.hpp> #include <OpenLoco/Core/MemoryStream.h> #include <array> #include <gtest/gtest.h> using namespace OpenLoco; TEST(MemoryStreamTest, testWriteRead) { MemoryStream ms; const std::array<uint8_t, 4> writeBuffer{ 0x01, 0x02, 0x03, 0x04 }; ms.write(writeBuffer.data(), writeBuffer.size()); ASSERT_EQ(ms.getLength(), sizeof(writeBuffer)); ASSERT_EQ(ms.getPosition(), sizeof(writeBuffer)); ms.setPosition(0); ASSERT_EQ(ms.getPosition(), 0); std::array<uint8_t, 4> readBuffer{}; ms.read(readBuffer.data(), readBuffer.size()); ASSERT_EQ(readBuffer, writeBuffer); } TEST(MemoryStreamTest, testOverwrite) { MemoryStream ms; const std::array<uint8_t, 4> writeBuffer{ 0x01, 0x02, 0x03, 0x04 }; ms.write(writeBuffer.data(), writeBuffer.size()); ASSERT_EQ(ms.getLength(), sizeof(writeBuffer)); ASSERT_EQ(ms.getPosition(), sizeof(writeBuffer)); ms.setPosition(0); ASSERT_EQ(ms.getPosition(), 0); const std::array<uint8_t, 4> overwriteBuffer{ 0xCC, 0xCC, 0xCC, 0xCC }; ms.write(overwriteBuffer.data(), overwriteBuffer.size()); ASSERT_EQ(ms.getLength(), sizeof(writeBuffer)); ASSERT_EQ(ms.getPosition(), sizeof(writeBuffer)); ms.setPosition(0); ASSERT_EQ(ms.getPosition(), 0); std::array<uint8_t, 4> readBuffer{}; ms.read(readBuffer.data(), readBuffer.size()); ASSERT_EQ(readBuffer, overwriteBuffer); } TEST(MemoryStreamTest, testPosition) { MemoryStream ms; const std::array<uint8_t, 4> writeBuffer{ 0x01, 0x02, 0x03, 0x04 }; ms.write(writeBuffer.data(), writeBuffer.size()); ASSERT_EQ(ms.getLength(), sizeof(writeBuffer)); ASSERT_EQ(ms.getPosition(), sizeof(writeBuffer)); ms.setPosition(0); ASSERT_EQ(ms.getPosition(), 0); ms.setPosition(100); ASSERT_EQ(ms.getPosition(), ms.getLength()); } TEST(MemoryStreamTest, testBadRead) { MemoryStream ms; const std::array<uint8_t, 4> writeBuffer{ 0x01, 0x02, 0x03, 0x04 }; ms.write(writeBuffer.data(), writeBuffer.size()); ASSERT_EQ(ms.getLength(), sizeof(writeBuffer)); ASSERT_EQ(ms.getPosition(), sizeof(writeBuffer)); ms.setPosition(2); ASSERT_EQ(ms.getPosition(), 2); std::array<uint8_t, 4> readBuffer{}; EXPECT_THROW(ms.read(readBuffer.data(), readBuffer.size()), Exception::RuntimeError); } TEST(MemoryStreamTest, testWrite100MiB) { MemoryStream ms; const auto k100MiB = (1024U * 1024U) * 100U; const std::array<uint8_t, 1> writeBuffer{ 0xFF }; for (size_t i = 0; i < k100MiB; i++) { ms.write(writeBuffer.data(), writeBuffer.size()); } ASSERT_EQ(ms.getLength(), k100MiB); } TEST(MemoryStreamTest, testResize) { MemoryStream ms; const auto kResizeSize = 100; ms.resize(kResizeSize); ASSERT_EQ(ms.getLength(), 100); ASSERT_EQ(ms.getPosition(), 0); // Write to the buffer to ensure it's writable std::byte* data = ms.data(); for (size_t i = 0; i < kResizeSize; i++) { data[i] = std::byte{ 0xCC }; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/NumericsTests.cpp ```cpp #include <OpenLoco/Core/Numerics.hpp> #include <gtest/gtest.h> using namespace OpenLoco; TEST(NumericTest, bitScanForward) { EXPECT_EQ(Numerics::bitScanForward(0), -1); EXPECT_EQ(Numerics::bitScanForward(0b00000001), 0); EXPECT_EQ(Numerics::bitScanForward(0b00000010), 1); EXPECT_EQ(Numerics::bitScanForward(0b10000010), 1); EXPECT_EQ(Numerics::bitScanForward(1u << 31), 31); } TEST(NumericTest, bitScanReverse) { EXPECT_EQ(Numerics::bitScanReverse(0), -1); EXPECT_EQ(Numerics::bitScanReverse(0b00000001), 0); EXPECT_EQ(Numerics::bitScanReverse(0b00000010), 1); EXPECT_EQ(Numerics::bitScanReverse(0b10000010), 7); EXPECT_EQ(Numerics::bitScanReverse(1u << 31), 31); } static_assert(Numerics::setMask(0, 0b1100, true) == 0b1100); static_assert(Numerics::setMask(0, 0b1100, false) == 0); static_assert(Numerics::setMask(0b0110, 0b1100, false) == 0b0010); static_assert(Numerics::setMask(0b0110, 0b1100, true) == 0b1110); static_assert(Numerics::rotl4bit(0b1000, 1) == 0b0001); ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/PrngTests.cpp ```cpp #include <OpenLoco/Core/Prng.h> #include <gtest/gtest.h> using namespace OpenLoco; TEST(PrngTests, misc) { Core::Prng prng; EXPECT_EQ(prng.randNext(), 0); EXPECT_EQ(prng.srand_0(), 0xFE2468AC); EXPECT_EQ(prng.srand_1(), 0); prng = Core::Prng(0x1234, 0x4321); EXPECT_EQ(prng.srand_0(), 0x1234); EXPECT_EQ(prng.srand_1(), 0x4321); EXPECT_EQ(prng.randNext(), 0x80000246); EXPECT_EQ(prng.srand_0(), 0xBC247A5E); EXPECT_EQ(prng.srand_1(), 0x80000246); for (auto i = 0; i < 1000; ++i) { prng.randNext(); } EXPECT_EQ(prng.srand_0(), 0x0A597A43); EXPECT_EQ(prng.srand_1(), 0x12FC0827); { constexpr size_t kMaxVal = 30; EXPECT_EQ(prng.randNext(kMaxVal), 11); for (auto i = 0; i < 1000; ++i) { EXPECT_LE(prng.randNext(kMaxVal), kMaxVal); } constexpr size_t kMinVal = 10; EXPECT_EQ(prng.randNext(kMinVal, kMaxVal), 26); for (auto i = 0; i < 1000; ++i) { const auto randVal = prng.randNext(kMinVal, kMaxVal); EXPECT_LE(randVal, kMaxVal); EXPECT_GE(randVal, kMinVal); } } { constexpr int32_t kMaxVal = -1; constexpr int32_t kMinVal = -10; EXPECT_EQ(prng.randNext(kMinVal, kMaxVal), -4); for (auto i = 0; i < 1000; ++i) { const auto randVal = prng.randNext(kMinVal, kMaxVal); EXPECT_LE(randVal, kMaxVal); EXPECT_GE(randVal, kMinVal); } } // These tests fail. Never call randNext with back to front min/max //{ // constexpr int32_t kMaxVal = -30; // EXPECT_EQ(prng.randNext(kMaxVal), 12); // for (auto i = 0; i < 1000; ++i) // { // EXPECT_LE(prng.randNext(kMaxVal), kMaxVal); // } // constexpr int32_t kMinVal = 10; // EXPECT_EQ(prng.randNext(kMinVal, kMaxVal), 12); // for (auto i = 0; i < 1000; ++i) // { // const auto randVal = prng.randNext(10, kMaxVal); // EXPECT_LT(randVal, kMaxVal); // EXPECT_GE(randVal, kMinVal); // } //} { // Negatives for single var randNext wrap around constexpr int32_t kMaxVal = -1; EXPECT_EQ(prng.randNext(kMaxVal), 0x78E536FB); for (auto i = 0; i < 1000; ++i) { EXPECT_LE(prng.randNext(kMaxVal), kMaxVal & 0x7FFFFFFF); } } EXPECT_EQ(prng.randNext(0), 0); EXPECT_EQ(prng.randNext(0, 0), 0); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/TimerTest.cpp ```cpp #include <OpenLoco/Core/Timer.hpp> #include <gtest/gtest.h> #include <thread> using namespace OpenLoco; TEST(TimerTest, TestDuration) { Core::Timer timer; // Should be close to zero at this point. EXPECT_NEAR(timer.elapsed(), 0.0f, 0.001f); // Should be close to 1000ms after 1 second. std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Need a somewhat high tolerance here, as sleeping is not very accurate. EXPECT_NEAR(timer.elapsed(), 1000.0f, 20.0f); } TEST(TimerTest, TestReset) { Core::Timer timer; // Should be close to 1000ms after 1 second. std::this_thread::sleep_for(std::chrono::milliseconds(1000)); timer.reset(); // Should be close to zero at this point. EXPECT_NEAR(timer.elapsed(), 0.0f, 0.001f); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/tests/TraitsTest.cpp ```cpp #include <OpenLoco/Core/Traits.hpp> #include <string> using namespace OpenLoco; struct TestStructPlain { int a; int b; bool c; float d; double e; }; static_assert(Traits::IsPOD<TestStructPlain>::value == true); struct TestStructPtr { int a; int b; bool c; float d; double e; void* ptr; }; static_assert(Traits::IsPOD<TestStructPtr>::value == true); struct TestStructStr { int a; int b; bool c; float d; double e; std::string str; }; static_assert(Traits::IsPOD<TestStructStr>::value == false); ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/BinaryStream.h ```h #pragma once #include "Stream.hpp" #include <cstdint> #include <cstdio> #include <vector> namespace OpenLoco { class BinaryStream final : public Stream { private: const void* _data{}; size_t _index{}; size_t _len{}; public: BinaryStream(const void* data, size_t len); size_t getLength() const noexcept override; size_t getPosition() const noexcept override; void setPosition(size_t position) override; void read(void* buffer, size_t len) override; void write(const void* buffer, size_t len) override; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/BitSet.hpp ```hpp #pragma once #include <algorithm> #include <array> #include <bit> #include <cstddef> #include <cstdint> #include <functional> #include <limits> #include <string> // Note this is identical to OpenRCT2's BitSet only with style changes to match codebase namespace OpenLoco { namespace Detail { namespace BitSet { static constexpr size_t kBitsPerByte = std::numeric_limits<std::underlying_type_t<std::byte>>::digits; template<size_t TNumBits> static constexpr size_t byteAlignBits() { const auto reminder = TNumBits % kBitsPerByte; if constexpr (reminder == 0u) { return TNumBits; } else { return TNumBits + (kBitsPerByte - (TNumBits % kBitsPerByte)); } } static_assert(byteAlignBits<1>() == 8); static_assert(byteAlignBits<4>() == 8); static_assert(byteAlignBits<8>() == 8); static_assert(byteAlignBits<9>() == 16); static_assert(byteAlignBits<9>() == 16); static_assert(byteAlignBits<17>() == 24); static_assert(byteAlignBits<24>() == 24); static_assert(byteAlignBits<31>() == 32); // Returns the amount of bytes required for a single block. template<size_t TNumBits> static constexpr size_t computeBlockSize() { constexpr size_t numBits = byteAlignBits<TNumBits>(); if constexpr (numBits >= std::numeric_limits<uintptr_t>::digits) { return sizeof(uintptr_t); } else { const auto numBytes = numBits / kBitsPerByte; auto mask = 1u; while (mask < numBytes) { mask <<= 1u; } return mask; } } template<size_t TNumBits, size_t TBlockSizeBytes> static constexpr size_t computeBlockCount() { size_t numBits = TNumBits; size_t numBlocks = 0; while (numBits > 0) { numBlocks++; numBits -= std::min(TBlockSizeBytes * kBitsPerByte, numBits); } return numBlocks; } static_assert(computeBlockSize<1>() == sizeof(uint8_t)); static_assert(computeBlockSize<4>() == sizeof(uint8_t)); static_assert(computeBlockSize<8>() == sizeof(uint8_t)); static_assert(computeBlockSize<9>() == sizeof(uint16_t)); static_assert(computeBlockSize<14>() == sizeof(uint16_t)); static_assert(computeBlockSize<16>() == sizeof(uint16_t)); static_assert(computeBlockSize<18>() == sizeof(uint32_t)); static_assert(computeBlockSize<31>() == sizeof(uint32_t)); static_assert(computeBlockSize<33>() == sizeof(uintptr_t)); template<size_t TByteSize> struct StorageBlockType; template<> struct StorageBlockType<1> { using value_type = uint8_t; }; template<> struct StorageBlockType<2> { using value_type = uint16_t; }; template<> struct StorageBlockType<4> { using value_type = uint32_t; }; template<> struct StorageBlockType<8> { using value_type = uint64_t; }; template<size_t TBitSize> struct storage_block_type_aligned { using value_type = typename StorageBlockType<computeBlockSize<TBitSize>()>::value_type; }; } // namespace BitSet } // namespace Detail template<size_t TBitSize> class BitSet { static constexpr size_t kByteAlignedBitSize = Detail::BitSet::byteAlignBits<TBitSize>(); using StorageBlockType = typename Detail::BitSet::storage_block_type_aligned<kByteAlignedBitSize>::value_type; static constexpr size_t kBlockByteSize = sizeof(StorageBlockType); static constexpr size_t kBlockBitSize = kBlockByteSize * Detail::BitSet::kBitsPerByte; static constexpr size_t kBlockCount = Detail::BitSet::computeBlockCount<kByteAlignedBitSize, kBlockByteSize>(); static constexpr size_t kCapacityBits = kBlockCount * kBlockBitSize; static constexpr StorageBlockType kBlockValueZero = StorageBlockType{ 0u }; static constexpr StorageBlockType kBlockValueOne = StorageBlockType{ 1u }; static constexpr StorageBlockType kBlockValueMask = static_cast<StorageBlockType>(~kBlockValueZero); static constexpr bool kRequiresTrim = TBitSize != kCapacityBits; public: using BlockType = StorageBlockType; using Storage = std::array<BlockType, kBlockCount>; // Proxy object to access the bits as single value. template<typename T> class reference_base { T& _storage; const size_t _blockIndex; const size_t _blockOffset; public: constexpr reference_base(T& data, size_t blockIndex, size_t blockOffset) noexcept : _storage(data) , _blockIndex(blockIndex) , _blockOffset(blockOffset) { } constexpr reference_base& operator=(const bool value) noexcept { if (!value) { _storage[_blockIndex] &= ~(kBlockValueOne << _blockOffset); } else { _storage[_blockIndex] |= (kBlockValueOne << _blockOffset); } return *this; } constexpr reference_base& operator=(const reference_base& value) noexcept { return reference_base::operator=(value.value()); } constexpr bool value() const noexcept { return (_storage[_blockIndex] & (kBlockValueOne << _blockOffset)) != kBlockValueZero; } constexpr operator bool() const noexcept { return value(); } }; using reference = reference_base<Storage>; using const_reference = reference_base<const Storage>; template<typename T, typename TValue> class iterator_base { T* _bitset{}; size_t _pos{}; public: constexpr iterator_base() = default; constexpr iterator_base(T* bset, size_t pos) : _bitset(bset) , _pos(pos) { } constexpr auto operator*() const { const auto blockIndex = computeBlockIndex(_pos); const auto blockOffset = computeBlockOffset(_pos); return TValue(_bitset->data(), blockIndex, blockOffset); } constexpr bool operator==(iterator_base other) const { return _bitset == other._bitset && _pos == other._pos; } constexpr iterator_base& operator++() { _pos++; return *this; } constexpr iterator_base operator++(int) { iterator_base res = *this; ++(*this); return res; } constexpr iterator_base& operator--() { _pos--; return *this; } constexpr iterator_base operator--(int) { iterator_base res = *this; --(*this); return res; } public: using difference_type = std::size_t; using value_type = TValue; using pointer = const TValue*; using reference = const TValue&; using iterator_category = std::forward_iterator_tag; }; using iterator = iterator_base<BitSet, reference>; using const_iterator = iterator_base<const BitSet, const_reference>; private: Storage _data{}; public: constexpr BitSet() = default; constexpr BitSet(const StorageBlockType val) : _data{ val } { } constexpr BitSet(const std::initializer_list<size_t>& indices) { for (auto idx : indices) { set(idx, true); } } constexpr size_t size() const noexcept { return TBitSize; } constexpr size_t count() const noexcept { size_t numBits = 0; for (auto& data : _data) { numBits += std::popcount(data); } return numBits; } constexpr size_t capacity() const noexcept { return kCapacityBits; } constexpr Storage& data() noexcept { return _data; } constexpr const Storage& data() const noexcept { return _data; } constexpr BitSet& set(size_t index, bool value) noexcept { const auto blockIndex = computeBlockIndex(index); const auto blockOffset = computeBlockOffset(index); if (!value) { _data[blockIndex] &= ~(kBlockValueOne << blockOffset); } else { _data[blockIndex] |= (kBlockValueOne << blockOffset); } return *this; } constexpr bool get(size_t index) const noexcept { const auto blockIndex = computeBlockIndex(index); const auto blockOffset = computeBlockOffset(index); return (_data[blockIndex] & (kBlockValueOne << blockOffset)) != kBlockValueZero; } constexpr bool operator[](const size_t index) const noexcept { const auto blockIndex = computeBlockIndex(index); const auto blockOffset = computeBlockOffset(index); const_reference ref(_data, blockIndex, blockOffset); return ref.value(); } constexpr reference operator[](const size_t index) noexcept { const auto blockIndex = computeBlockIndex(index); const auto blockOffset = computeBlockOffset(index); return reference(_data, blockIndex, blockOffset); } constexpr BitSet& flip() noexcept { for (auto& data : _data) { data ^= kBlockValueMask; } if constexpr (kRequiresTrim) { trim(); } return *this; } constexpr BitSet& reset() noexcept { std::fill(_data.begin(), _data.end(), kBlockValueZero); if constexpr (kRequiresTrim) { trim(); } return *this; } constexpr const_iterator begin() const noexcept { return const_iterator(this, 0); } constexpr const_iterator end() const noexcept { return const_iterator(this, size()); } constexpr iterator begin() noexcept { return iterator(this, 0); } constexpr iterator end() noexcept { return iterator(this, size()); } template<class TChar = char, class TTraits = std::char_traits<TChar>, class TAlloc = std::allocator<TChar>> std::basic_string<TChar, TTraits, TAlloc> to_string(TChar zero = TChar{ '0' }, TChar one = TChar{ '1' }) const { std::basic_string<TChar, TTraits, TAlloc> res; res.resize(TBitSize); for (size_t i = 0; i < TBitSize; ++i) { // Printed as little-endian. res[TBitSize - i - 1] = get(i) ? one : zero; } return res; } constexpr BitSet operator^(const BitSet& other) const noexcept { BitSet res = *this; applyOp<std::bit_xor<BlockType>>(res, other, std::make_index_sequence<kBlockCount>{}); return res; } constexpr BitSet& operator^=(const BitSet& other) noexcept { *this = *this ^ other; return *this; } constexpr BitSet operator|(const BitSet& other) const noexcept { BitSet res = *this; applyOp<std::bit_or<BlockType>>(res, other, std::make_index_sequence<kBlockCount>{}); return res; } constexpr BitSet& operator|=(const BitSet& other) noexcept { *this = *this | other; return *this; } constexpr BitSet operator&(const BitSet& other) const noexcept { BitSet res = *this; applyOp<std::bit_and<BlockType>>(res, other, std::make_index_sequence<kBlockCount>{}); return res; } constexpr BitSet& operator&=(const BitSet& other) noexcept { *this = *this & other; return *this; } constexpr BitSet operator~() const noexcept { BitSet res = *this; for (size_t i = 0; i < _data.size(); i++) { res._data[i] = ~res._data[i]; } if constexpr (kRequiresTrim) { res.trim(); } return res; } constexpr bool operator<(const BitSet& other) const noexcept { return std::lexicographical_compare( _data.begin(), _data.end(), other._data.begin(), other._data.end(), std::less<StorageBlockType>{}); } constexpr bool operator<=(const BitSet& other) const noexcept { return std::lexicographical_compare( _data.begin(), _data.end(), other._data.begin(), other._data.end(), std::less_equal<StorageBlockType>{}); } constexpr bool operator>(const BitSet& other) const noexcept { return std::lexicographical_compare( _data.begin(), _data.end(), other._data.begin(), other._data.end(), std::greater<StorageBlockType>{}); } constexpr bool operator>=(const BitSet& other) const noexcept { return std::lexicographical_compare( _data.begin(), _data.end(), other._data.begin(), other._data.end(), std::greater_equal<StorageBlockType>{}); } private: template<typename TOperator, size_t... TIndex> void applyOp(BitSet& dst, const BitSet& src, std::index_sequence<TIndex...>) const { TOperator op{}; ((dst._data[TIndex] = op(dst._data[TIndex], src._data[TIndex])), ...); if constexpr (kRequiresTrim) { dst.trim(); } } static constexpr size_t computeBlockIndex(size_t idx) noexcept { if constexpr (kBlockCount == 1) { return 0; } else { return idx / kBlockBitSize; } } static constexpr size_t computeBlockOffset(size_t idx) noexcept { if constexpr (kBlockCount == 1) { return idx; } else { return idx % kBlockBitSize; } } // Some operations require to trim of the excess. constexpr void trim() noexcept { const auto byteIdx = TBitSize / kBlockBitSize; const auto bitIdx = TBitSize % kBlockBitSize; if constexpr (bitIdx == 0) { return; } auto trimMask = kBlockValueMask; trimMask <<= (kBlockBitSize - bitIdx); trimMask >>= (kBlockBitSize - bitIdx); _data[byteIdx] &= trimMask; } }; } // namespace OpenLoco ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/EnumFlags.hpp ```hpp #pragma once #include <cassert> #include <cstdint> #include <type_traits> namespace OpenLoco::Core { #define OPENLOCO_ENABLE_ENUM_OPERATORS(ENM) \ static_assert(std::is_unsigned_v<std::underlying_type_t<ENM>> == true, "Underlying enum type must be unsigned"); \ static_assert(static_cast<std::underlying_type_t<ENM>>(ENM::none) == 0U, "Enum must have a none value"); \ inline constexpr ENM operator|(const ENM a, const ENM b) noexcept \ { \ return static_cast<ENM>(static_cast<std::underlying_type_t<ENM>>(a) | static_cast<std::underlying_type_t<ENM>>(b)); \ } \ inline constexpr ENM operator|=(ENM& a, const ENM b) noexcept \ { \ a = static_cast<ENM>(static_cast<std::underlying_type_t<ENM>>(a) | static_cast<std::underlying_type_t<ENM>>(b)); \ return a; \ } \ inline constexpr ENM operator^(const ENM a, const ENM b) noexcept \ { \ return static_cast<ENM>(static_cast<std::underlying_type_t<ENM>>(a) ^ static_cast<std::underlying_type_t<ENM>>(b)); \ } \ inline constexpr ENM operator^=(ENM& a, const ENM b) noexcept \ { \ a = static_cast<ENM>(static_cast<std::underlying_type_t<ENM>>(a) ^ static_cast<std::underlying_type_t<ENM>>(b)); \ return a; \ } \ inline constexpr ENM operator&(const ENM a, const ENM b) noexcept \ { \ return static_cast<ENM>(static_cast<std::underlying_type_t<ENM>>(a) & static_cast<std::underlying_type_t<ENM>>(b)); \ } \ inline constexpr ENM operator&=(ENM& a, const ENM b) noexcept \ { \ a = static_cast<ENM>(static_cast<std::underlying_type_t<ENM>>(a) & static_cast<std::underlying_type_t<ENM>>(b)); \ return a; \ } \ inline constexpr ENM operator~(const ENM a) noexcept \ { \ return static_cast<ENM>(~static_cast<std::underlying_type_t<ENM>>(a)); \ } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/Exception.hpp ```hpp #pragma once #include <exception> #include <fmt/format.h> #include <string> #include <string_view> namespace OpenLoco::Exception { namespace Detail { // TODO: Make this consteval for C++20 constexpr std::string_view sanitizePath(std::string_view path) { #if defined(OPENLOCO_PROJECT_PATH) constexpr std::string_view projectPath = OPENLOCO_PROJECT_PATH; // Removes also the first slash. return path.substr(projectPath.size() + 1); #else return path; #endif } } // Something like std::source_location except this works prior to C++20. class SourceLocation { std::string _function; std::string _file; int _line; public: explicit SourceLocation(std::string_view func = __builtin_FUNCTION(), std::string_view file = Detail::sanitizePath(__builtin_FILE()), int line = __builtin_LINE()) : _function(func) , _file(file) , _line(line) { } const std::string& file() const noexcept { return _file; } const std::string& function() const noexcept { return _function; } int line() const noexcept { return _line; } }; namespace Detail { template<typename TExceptionTag> class ExceptionBase : public std::exception { private: SourceLocation _location; std::string _message; public: explicit ExceptionBase(const SourceLocation& location = SourceLocation{}) : _location{ location } { _message = fmt::format("Exception thrown at '{}' - {}:{}", _location.function(), _location.file(), _location.line()); } explicit ExceptionBase(const std::string& message, const SourceLocation& location = SourceLocation{}) : _location{ location } { _message = fmt::format("Exception '{}', thrown at '{}' - {}:{}", message, _location.function(), _location.file(), _location.line()); } const char* what() const noexcept override { return _message.c_str(); } }; } using RuntimeError = Detail::ExceptionBase<struct RuntimeErrorTag>; using InvalidArgument = Detail::ExceptionBase<struct InvalidArgumentTag>; using NotImplemented = Detail::ExceptionBase<struct NotImplementedTag>; using InvalidOperation = Detail::ExceptionBase<struct InvalidOperationTag>; using BadAllocation = Detail::ExceptionBase<struct BadAllocTag>; using OutOfRange = Detail::ExceptionBase<struct OutOfRangeTag>; using OverflowError = Detail::ExceptionBase<struct OverflowErrorTag>; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/FileStream.h ```h #pragma once #include "Stream.hpp" #include <cstdint> #include <cstdio> #include <filesystem> namespace OpenLoco { class FileStream final : public Stream { private: FILE* _file{}; StreamMode _mode{}; size_t _length{}; size_t _offset{}; public: FileStream() = default; FileStream(const std::filesystem::path& path, StreamMode mode); ~FileStream() override; bool open(const std::filesystem::path& path, StreamMode mode); bool isOpen() const noexcept; void close(); StreamMode getMode() const noexcept; size_t getLength() const noexcept override; size_t getPosition() const noexcept override; void setPosition(size_t position) override; void read(void* buffer, size_t len) override; void write(const void* buffer, size_t len) override; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/FileSystem.hpp ```hpp /// @file /// This file enables access to std::filesystem as `fs` namespace #pragma once #include <filesystem> namespace fs = std::filesystem; ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/LocoFixedVector.hpp ```hpp #pragma once #include <iterator> namespace OpenLoco { template<typename ValueType, size_t Count> class FixedVector { private: ValueType* startAddress = nullptr; class Iter { private: ValueType* arr; size_t i = 0; constexpr void findNonEmpty() { for (; i < Count; ++i) { if (!arr[i].empty()) { break; } } } public: constexpr Iter(ValueType* _arr, size_t _index) : arr(_arr) , i(_index) { // finds first valid entry findNonEmpty(); } constexpr Iter& operator++() { ++i; findNonEmpty(); return *this; } constexpr Iter operator++(int) { Iter retval = *this; ++(*this); return retval; } constexpr bool operator==(Iter other) const { return i == other.i; } constexpr ValueType& operator*() const { return arr[i]; } // iterator traits using difference_type = std::ptrdiff_t; using value_type = ValueType; using pointer = ValueType*; using reference = ValueType&; using iterator_category = std::forward_iterator_tag; }; public: FixedVector(ValueType (&_arr)[Count]) : startAddress(_arr) { } Iter begin() const { return Iter(startAddress, 0); } Iter end() const { return Iter(startAddress, Count); } [[nodiscard]] bool empty() const { return begin() == end(); } [[nodiscard]] size_t size() const { return std::distance(begin(), end()); } [[nodiscard]] constexpr size_t capacity() const { return Count; } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/MemoryStream.h ```h #pragma once #include "Stream.hpp" #include <cstdint> #include <cstdio> #include <span> #include <vector> namespace OpenLoco { class MemoryStream final : public Stream { std::byte* _data{}; size_t _offset{}; size_t _length{}; size_t _capacity{}; public: ~MemoryStream() override; void reserve(size_t len); void resize(size_t len); void clear(); const std::byte* data() const; std::byte* data(); std::span<std::byte> getSpan(); std::span<const std::byte> getSpan() const; size_t getLength() const noexcept override; size_t getPosition() const noexcept override; void setPosition(size_t position) override; void read(void* buffer, size_t len) override; void write(const void* buffer, size_t len) override; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/Numerics.hpp ```hpp #pragma once #include <bit> #include <cassert> #include <cstddef> #include <cstdint> namespace OpenLoco::Numerics { int32_t bitScanForward(uint32_t source); int32_t bitScanReverse(uint32_t source); template<typename T> constexpr T setMask(T x, T mask, bool value) { return (value ? (x | mask) : (x & ~mask)); } constexpr uint8_t rotl4bit(uint8_t val, uint8_t rotation) { return ((val << rotation) | (val >> (4 - rotation))) & 0xF; } constexpr uint8_t rotr4bit(uint8_t val, uint8_t rotation) { return ((val >> rotation) | (val << (4 - rotation))) & 0xF; } // Alignment requires to be power of 2. template<typename T> constexpr T floor2(T value, size_t alignment) { // Ensure alignment is power of two or 0. assert(alignment > 0 && std::has_single_bit(alignment)); return value & ~(alignment - 1); } // Alignment requires to be power of 2. template<typename T> constexpr T ceil2(T value, size_t alignment) { return floor2(static_cast<T>(value + alignment - 1), alignment); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/Prng.h ```h #pragma once #include <cassert> #include <cstdint> namespace OpenLoco::Core { #pragma pack(push, 1) struct Prng { private: uint32_t _srand_0{}; uint32_t _srand_1{}; public: uint32_t srand_0() const { return _srand_0; } uint32_t srand_1() const { return _srand_1; } Prng() { } Prng(uint32_t s0, uint32_t s1) : _srand_0(s0) , _srand_1(s1) { } uint32_t randNext(); int32_t randNext(int32_t high) { high &= 0x7FFFFFFF; // no negatives allowed return randNext(0, high); } // NOTE: Callers to ensure low is less than high int32_t randNext(int32_t low, int32_t high) { assert(low <= high); int32_t positive = randNext() & 0x7FFFFFFF; return low + (positive % ((high + 1) - low)); } bool randBool() { return (randNext() & 1) != 0; } }; #pragma pack(pop) } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/Stream.hpp ```hpp #pragma once #include "Traits.hpp" #include <cstddef> #include <cstdint> #include <istream> namespace OpenLoco { namespace Utility { // Obsolete methods, use new Stream APIs template<typename T1, typename T2, typename T3> std::basic_istream<T1, T2>& readData(std::basic_istream<T1, T2>& stream, T3* dst, size_t count) { return stream.read((char*)dst, static_cast<uint64_t>(count) * sizeof(T3)); } template<typename T1, typename T2, typename T3> std::basic_istream<T1, T2>& readData(std::basic_istream<T1, T2>& stream, T3& dst) { return readData(stream, &dst, 1); } template<typename T3, typename T1, typename T2> T3 readValue(std::basic_istream<T1, T2>& stream) { T3 result{}; readData(stream, result); return result; } } enum class StreamMode { none = 0, read, write, }; class Stream { public: virtual ~Stream() = default; virtual size_t getLength() const noexcept = 0; virtual size_t getPosition() const noexcept = 0; virtual void setPosition(size_t) = 0; virtual void read(void*, size_t) = 0; virtual void write(const void*, size_t) = 0; template<typename T> T readValue() { static_assert(Traits::IsPrimitive<T>::value || Traits::IsPOD<T>::value, "Type must be primitive or POD"); T tmp; read(&tmp, sizeof(T)); return tmp; } template<typename T> void writeValue(const T& src) { static_assert(Traits::IsPrimitive<T>::value || Traits::IsPOD<T>::value, "Type must be primitive or POD"); write(&src, sizeof(T)); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/Timer.hpp ```hpp #pragma once #include <chrono> #include <cstdint> namespace OpenLoco::Core { class Timer { using ClockType = std::chrono::high_resolution_clock; using TimePointType = std::chrono::time_point<ClockType>; TimePointType _start = ClockType::now(); public: // Resets the timer void reset() { _start = ClockType::now(); } // Returns elapsed time in milliseconds float elapsed() const { const auto now = ClockType::now(); return std::chrono::duration<float, std::milli>(now - _start).count(); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/include/OpenLoco/Core/Traits.hpp ```hpp #pragma once #include <type_traits> namespace OpenLoco::Traits { // C++20 deprecated std::is_pod, we consider a structure POD if we can use std::memcpy. template<typename T> struct IsPOD { static constexpr auto value = std::is_trivially_copyable_v<T>; }; // Obtains the underlying type of an enum, or the type itself if not an enum. template<typename T, typename = void> struct UnderlyingType { using type = T; }; template<typename T> struct UnderlyingType<T, std::enable_if_t<std::is_enum_v<T>>> { using type = typename std::underlying_type<T>::type; }; // Determines if a type is a primitive type such as int, float, etc. Pointers are not considered primitive. // It also returns true for enums while the standard is_fundamental does not. template<typename T> struct IsPrimitive { static constexpr auto value = std::is_fundamental_v<typename UnderlyingType<T>::type>; }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/src/BinaryStream.cpp ```cpp #include "BinaryStream.h" #include "Exception.hpp" #include <cstring> namespace OpenLoco { BinaryStream::BinaryStream(const void* data, size_t len) : _data(data) , _len(len) { } size_t BinaryStream::getLength() const noexcept { return _len; } size_t BinaryStream::getPosition() const noexcept { return _index; } void BinaryStream::setPosition(size_t position) { _index = std::min(_len, position); } void BinaryStream::read(void* buffer, size_t len) { auto maxReadLen = _len - _index; if (len > maxReadLen) { throw Exception::RuntimeError("Failed to read data"); } std::memcpy(buffer, reinterpret_cast<const void*>(reinterpret_cast<size_t>(_data) + _index), len); _index += len; } void BinaryStream::write([[maybe_unused]] const void* buffer, [[maybe_unused]] size_t len) { throw Exception::InvalidOperation("Can not write"); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/src/FileStream.cpp ```cpp #include "FileStream.h" #include "Exception.hpp" #include <algorithm> #include <stdio.h> namespace OpenLoco { static FILE* fileOpen(const std::filesystem::path& path, StreamMode mode) { if (mode == StreamMode::none) { throw Exception::InvalidArgument("Invalid mode argument"); } #ifdef _WIN32 FILE* fs; _wfopen_s(&fs, path.wstring().c_str(), mode == StreamMode::read ? L"rb" : L"wb"); return fs; #else return fopen(path.u8string().c_str(), mode == StreamMode::read ? "rb" : "wb"); #endif } static size_t fileTell(FILE* fs) { #ifdef _MSC_VER return _ftelli64_nolock(fs); #else return ftello(fs); #endif } static void fileSeek(FILE* fs, size_t offset, int origin) { #ifdef _MSC_VER _fseeki64_nolock(fs, offset, origin); #else fseeko(fs, offset, origin); #endif } static size_t readFile(void* buffer, size_t len, FILE* fs) { #ifdef _MSC_VER return _fread_nolock(buffer, 1, len, fs); #else return std::fread(buffer, 1, len, fs); #endif } static size_t writeFile(const void* buffer, size_t len, FILE* fs) { #ifdef _MSC_VER return _fwrite_nolock(buffer, 1, len, fs); #else return std::fwrite(buffer, 1, len, fs); #endif } static void fileClose(FILE* fs) { #ifdef _MSC_VER _fclose_nolock(fs); #else fclose(fs); #endif } static size_t getFileLength(FILE* fs) { const auto current = fileTell(fs); fileSeek(fs, 0, SEEK_END); const auto length = fileTell(fs); fileSeek(fs, current, SEEK_SET); return length; } FileStream::FileStream(const std::filesystem::path& path, StreamMode mode) { if (!open(path, mode)) { // TODO: Make this work like fstream which is not throwing for failing to open the file. throw Exception::RuntimeError("Failed to open '" + path.u8string() + "' for writing"); } } FileStream::~FileStream() { close(); } bool FileStream::open(const std::filesystem::path& path, StreamMode mode) { close(); _file = fileOpen(path, mode); if (_file == nullptr) { return false; } // Increase the buffer size to 1MiB. std::setvbuf(_file, nullptr, _IOFBF, 1024 * 1024); // Get the length if we are reading an existing file. if (mode == StreamMode::read) { _length = getFileLength(_file); } _offset = 0; _mode = mode; return true; } bool FileStream::isOpen() const noexcept { return _file != nullptr; } void FileStream::close() { if (_file == nullptr) { return; } _mode = StreamMode::none; _length = 0; _offset = 0; fileClose(_file); _file = nullptr; } StreamMode FileStream::getMode() const noexcept { return _mode; } size_t FileStream::getLength() const noexcept { return _length; } size_t FileStream::getPosition() const noexcept { return _offset; } void FileStream::setPosition(size_t position) { if (_mode == StreamMode::none) { throw Exception::InvalidOperation("Invalid mode"); } position = std::min(_length, static_cast<size_t>(position)); fileSeek(_file, position, SEEK_SET); _offset = position; } void FileStream::read(void* buffer, size_t len) { if (_mode != StreamMode::read) { throw Exception::InvalidOperation("Can not read"); } const auto bytesRead = readFile(buffer, len, _file); if (bytesRead != len) { throw Exception::RuntimeError("Failed to read data"); } _offset += bytesRead; } void FileStream::write(const void* buffer, size_t len) { if (_mode != StreamMode::write) { throw Exception::InvalidOperation("Can not write"); } if (len == 0) { return; } const auto bytesWriten = writeFile(buffer, len, _file); if (bytesWriten != len) { throw Exception::RuntimeError("Failed to write data"); } _offset += bytesWriten; _length = std::max(_length, _offset); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/src/MemoryStream.cpp ```cpp #include "MemoryStream.h" #include "Exception.hpp" #include <algorithm> #include <cstring> namespace OpenLoco { MemoryStream::~MemoryStream() { if (_data != nullptr) { std::free(_data); } } void MemoryStream::reserve(size_t len) { if (len == 0 || len < _capacity) { return; } auto* newData = static_cast<std::byte*>(std::realloc(_data, len)); if (newData == nullptr) { throw Exception::BadAllocation(); } _data = newData; _capacity = len; } void MemoryStream::resize(size_t len) { if (len == 0) { clear(); return; } if (len < _capacity) { _length = len; return; } reserve(len); _length = len; } void MemoryStream::clear() { _offset = 0; _length = 0; } const std::byte* MemoryStream::data() const { return _data; } std::byte* MemoryStream::data() { return _data; } std::span<std::byte> MemoryStream::getSpan() { return std::span(_data, _length); } std::span<const std::byte> MemoryStream::getSpan() const { return std::span(_data, _length); } size_t MemoryStream::getLength() const noexcept { return _length; } size_t MemoryStream::getPosition() const noexcept { return _offset; } void MemoryStream::setPosition(size_t position) { _offset = std::min(_length, position); } void MemoryStream::read(void* buffer, size_t len) { const auto maxReadLength = std::min(len, _length - _offset); if (len > maxReadLength) { throw Exception::RuntimeError("Failed to read data"); } std::memcpy(buffer, _data + _offset, len); _offset += maxReadLength; } // TODO: Move this somewhere more sensible. template<typename T> static constexpr T alignTo(T val, T align) noexcept { if (val % align == 0) { return val; } return val + (align - (val % align)); } void MemoryStream::write(const void* buffer, size_t len) { const auto spaceLeft = _capacity - _offset; // Check if we have to expand the current buffer. if (len > spaceLeft) { constexpr auto kGrowthFactor = 2.0f; constexpr std::size_t kPageSize = 0x1000; const auto newCapacity = _capacity + len; const auto finalCapacity = alignTo(static_cast<std::size_t>(newCapacity * kGrowthFactor), kPageSize); auto* newData = static_cast<std::byte*>(std::realloc(_data, finalCapacity)); if (newData == nullptr) { throw Exception::BadAllocation(); } _data = newData; _capacity = finalCapacity; } // Copy the data into the buffer. std::memcpy(_data + _offset, buffer, len); const auto spaceAvailable = _length - _offset; if (len > spaceAvailable) { _length += len - spaceAvailable; } _offset += len; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/src/Numerics.cpp ```cpp #include "Numerics.hpp" #include <cstddef> #include <cstdint> #include <limits.h> #include <type_traits> #ifdef _MSC_VER #include <intrin.h> #endif namespace OpenLoco::Numerics { // Finds the first bit set in a 32-bits numeral and returns its index, or -1 if no bit is set. int32_t bitScanForward(uint32_t source) { #if defined(_MSC_VER) && (_MSC_VER >= 1400) // Visual Studio 2005 unsigned long i; uint8_t success = _BitScanForward(&i, source); return success != 0 ? i : -1; #elif defined(__GNUC__) auto result = __builtin_ffs(source); return result - 1; #else #pragma message "Falling back to iterative bitscan forward, consider using intrinsics" if (source != 0) { for (int32_t i = 0; i < 32; i++) { if (source & (1u << i)) { return i; } } } return -1; #endif } int32_t bitScanReverse(uint32_t source) { #if defined(_MSC_VER) && (_MSC_VER >= 1400) // Visual Studio 2005 unsigned long i; uint8_t success = _BitScanReverse(&i, source); return success != 0 ? i : -1; #elif defined(__GNUC__) auto result = source == 0 ? -1 : __builtin_clz(source) ^ 31; return result; #else #pragma message "Falling back to iterative bitscan reverse, consider using intrinsics" if (source != 0) { for (int32_t i = 31; i > -1; i--) { if (source & (1u << i)) { return i; } } } return -1; #endif } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Core/src/Prng.cpp ```cpp #include "Prng.h" #include <bit> namespace OpenLoco::Core { uint32_t Prng::randNext() { auto srand0 = _srand_0; auto srand1 = _srand_1; _srand_0 += std::rotr<uint32_t>(srand1 ^ 0x1234567F, 7); _srand_1 = std::rotr<uint32_t>(srand0, 3); return _srand_1; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Interop/CMakeLists.txt ```txt set(public_files "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Interop/Interop.hpp" ) set(private_files "${CMAKE_CURRENT_SOURCE_DIR}/src/Interop.cpp" ) loco_add_library(Interop STATIC PUBLIC_FILES ${public_files} PRIVATE_FILES ${private_files} ) target_link_libraries(Interop PUBLIC Diagnostics ) ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Interop/include/OpenLoco/Interop/Interop.hpp ```hpp #pragma once #include <OpenLoco/Core/Exception.hpp> #include <cassert> #include <cstddef> #include <cstdint> #include <cstdio> #include <stdexcept> #include <vector> #if defined(__i386__) || defined(_M_IX86) #define assert_struct_size(x, y) static_assert(sizeof(x) == (y), "Improper struct size") #else #define assert_struct_size(x, y) #endif constexpr int32_t kDefaultRegValue = 0xCCCCCCCC; namespace OpenLoco::Interop { template<typename T = void> class X86Pointer { private: uintptr_t _ptr; public: X86Pointer(const T* x) { _ptr = reinterpret_cast<uintptr_t>(x); } X86Pointer(const uint32_t ptr) { _ptr = ptr; } operator uint32_t() const { return (uint32_t)_ptr; } operator T*() const { return reinterpret_cast<T*>(_ptr); }; }; #pragma pack(push, 1) /** * x86 register structure, only used for easy interop to Locomotion code. */ struct registers { union { int32_t eax{ kDefaultRegValue }; int16_t ax; struct { int8_t al; int8_t ah; }; }; union { int32_t ebx{ kDefaultRegValue }; int16_t bx; struct { int8_t bl; int8_t bh; }; }; union { int32_t ecx{ kDefaultRegValue }; int16_t cx; struct { int8_t cl; int8_t ch; }; }; union { int32_t edx{ kDefaultRegValue }; int16_t dx; struct { int8_t dl; int8_t dh; }; }; union { int32_t esi{ kDefaultRegValue }; int16_t si; }; union { int32_t edi{ kDefaultRegValue }; int16_t di; }; union { int32_t ebp{ kDefaultRegValue }; int16_t bp; }; }; assert_struct_size(registers, 7 * 4); #pragma pack(pop) #ifndef USE_MMAP constexpr uintptr_t kGoodPlaceForDataSegment = 0x008A4000; #else #if defined(PLATFORM_32BIT) constexpr uintptr_t kGoodPlaceForDataSegment = 0x09000000; #elif defined(PLATFORM_64BIT) constexpr uintptr_t kGoodPlaceForDataSegment = 0x200000000; #else #error "Unknown platform" #endif #endif template<uint32_t TAddress, typename T> constexpr T& addr() { constexpr auto ptrAddr = kGoodPlaceForDataSegment - 0x008A4000 + TAddress; // We use std::launder to prevent the compiler from doing optimizations that lead to undefined behavior. return *std::launder(reinterpret_cast<T*>(ptrAddr)); } struct GlobalStore { public: static GlobalStore& getInstance(); static void addAddressRange(uint32_t begin, uint32_t size); private: GlobalStore() = default; bool isAddressInRange(uint32_t address, uint32_t size) const; std::vector<std::pair<uint32_t, uint32_t>> addressRanges; // Pairs of (begin, size) static GlobalStore gStoreInstance; }; template<typename T, uintptr_t TAddress> struct loco_global { public: typedef T type; typedef type* pointer; typedef type& reference; typedef const type& const_reference; private: pointer _Myptr; public: loco_global() { _Myptr = &(addr<TAddress, T>()); GlobalStore::addAddressRange(TAddress, sizeof(T)); } loco_global(const loco_global<T, TAddress>&) = delete; // Do not copy construct a loco global operator reference() { return addr<TAddress, T>(); } loco_global& operator=(const_reference v) { addr<TAddress, T>() = v; return *this; } loco_global& operator+=(const_reference v) { addr<TAddress, T>() += v; return *this; } loco_global& operator|=(const_reference v) { addr<TAddress, T>() |= v; return *this; } loco_global& operator&=(const_reference v) { addr<TAddress, T>() &= v; return *this; } loco_global& operator^=(const_reference v) { addr<TAddress, T>() ^= v; return *this; } loco_global& operator-=(const_reference v) { addr<TAddress, T>() -= v; return *this; } loco_global& operator++() { addr<TAddress, T>()++; return *this; } T operator++(int) { reference ref = addr<TAddress, T>(); T temp = ref; ref++; return temp; } loco_global& operator--() { addr<TAddress, T>()--; return *this; } T operator--(int) { reference ref = addr<TAddress, T>(); T temp = ref; ref--; return temp; } reference operator*() { return addr<TAddress, T>(); } pointer operator->() { return &(addr<TAddress, T>()); } constexpr size_t size() const { return sizeof(T); } }; template<typename T> struct loco_global_iterator { private: T* _ptr; public: loco_global_iterator(T* p) : _ptr(p) { } loco_global_iterator& operator++() { ++_ptr; return *this; } loco_global_iterator operator++(int) { auto temp = *this; ++_ptr; return temp; } loco_global_iterator& operator--() { --_ptr; return *this; } loco_global_iterator operator--(int) { auto temp = *this; --_ptr; return temp; } bool operator==(const loco_global_iterator& rhs) const { return _ptr == rhs._ptr; } T& operator*() { return *_ptr; } using difference_type = std::ptrdiff_t; using value_type = T; using pointer = const T*; using reference = const T&; using iterator_category = std::forward_iterator_tag; }; template<typename T, size_t TCount, uintptr_t TAddress> struct loco_global<T[TCount], TAddress> { public: typedef T type; typedef type* pointer; typedef type& reference; typedef const type& const_reference; typedef loco_global_iterator<T> iterator; static constexpr auto address = TAddress; static constexpr auto endAddress = TAddress + TCount * sizeof(type); private: pointer _Myfirst; pointer _Mylast; public: loco_global() { _Myfirst = get(); _Mylast = _Myfirst + TCount; GlobalStore::addAddressRange(TAddress, TCount * sizeof(T)); } operator pointer() { return get(); } pointer get() const { return reinterpret_cast<pointer>(&addr<TAddress, type>()); } reference operator[](int idx) { assert(idx >= 0 && static_cast<size_t>(idx) < size()); #ifndef NDEBUG if (idx < 0 || static_cast<size_t>(idx) >= size()) { throw Exception::OutOfRange("loco_global: bounds check violation!"); } #endif return get()[idx]; } constexpr size_t size() const { return TCount; } iterator begin() const { return iterator(&addr<TAddress, T>()); } iterator end() const { const pointer ptrEnd = (&addr<TAddress, T>()) + TCount; return iterator(ptrEnd); } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Interop/src/Interop.cpp ```cpp #include "Interop.hpp" #include <OpenLoco/Diagnostics/Logging.h> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Interop { GlobalStore GlobalStore::gStoreInstance = GlobalStore(); GlobalStore& GlobalStore::getInstance() { return gStoreInstance; } void GlobalStore::addAddressRange([[maybe_unused]] uint32_t begin, [[maybe_unused]] uint32_t size) { #ifdef _LOG_GLOBAL_STORE_ auto& gs = getInstance(); if (gs.isAddressInRange(begin, size)) { Logging::warn("Address range {:#08x}-{:#08x} overlaps with existing ranges.\n", begin, begin + size); return; } gs.addressRanges.emplace_back(begin, size); #endif } bool GlobalStore::isAddressInRange(uint32_t address, uint32_t size) const { for (auto& range : addressRanges) { if (address >= range.first && address < (range.first + range.second)) { return true; } } const auto end = address + size; for (auto& range : addressRanges) { if (end > range.first && end <= (range.first + range.second)) { return true; } } return false; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/CMakeLists.txt ```txt set(public_files "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Math/Bound.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Math/Trigonometry.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Math/Vector.hpp" ) set(private_files "${CMAKE_CURRENT_SOURCE_DIR}/src/Trigonometry.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/Vector.cpp" ) set(test_files "${CMAKE_CURRENT_SOURCE_DIR}/tests/TrigonometryTests.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/tests/VectorTests.cpp" ) loco_add_library(Math STATIC PUBLIC_FILES ${public_files} PRIVATE_FILES ${private_files} TEST_FILES ${test_files} ) ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/tests/TrigonometryTests.cpp ```cpp #include <OpenLoco/Math/Trigonometry.hpp> #include <gtest/gtest.h> using namespace OpenLoco::Math; TEST(TrigonometryTest, integerSinePrecisionHigh) { ASSERT_EQ(Trigonometry::integerSinePrecisionHigh(0, 500), 0); ASSERT_EQ(Trigonometry::integerSinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh / 4, 500), 499); ASSERT_EQ(Trigonometry::integerSinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh / 2, 500), 0); ASSERT_EQ(Trigonometry::integerSinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh / 4 + Trigonometry::kDirectionPrecisionHigh / 2, 500), -499); ASSERT_EQ(Trigonometry::integerSinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh, 500), 0); } TEST(TrigonometryTest, integerCosinePrecisionHigh) { ASSERT_EQ(Trigonometry::integerCosinePrecisionHigh(0, 500), 499); ASSERT_EQ(Trigonometry::integerCosinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh / 4, 500), 0); ASSERT_EQ(Trigonometry::integerCosinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh / 2, 500), -499); ASSERT_EQ(Trigonometry::integerCosinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh / 4 + Trigonometry::kDirectionPrecisionHigh / 2, 500), 0); ASSERT_EQ(Trigonometry::integerCosinePrecisionHigh(Trigonometry::kDirectionPrecisionHigh, 500), 499); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/tests/VectorTests.cpp ```cpp #include <OpenLoco/Math/Vector.hpp> #include <gtest/gtest.h> using namespace OpenLoco::Math; using Point2D = Vector::TVector2<int32_t>; using Point3D = Vector::TVector3<int32_t>; TEST(VectorTest, fastSquareRoot) { ASSERT_EQ(Vector::fastSquareRoot(0), 0); ASSERT_EQ(Vector::fastSquareRoot(256), 16); ASSERT_EQ(Vector::fastSquareRoot(10000), 100); ASSERT_EQ(Vector::fastSquareRoot(0xFFFFFFFF), 65519); // Note: Not very accurate... ASSERT_EQ(Vector::fastSquareRoot(4095), 63); // Note: Not very accurate... } // This test is ultimately the same as fastSquareRoot but more how we would acutally use it TEST(VectorTest, distance) { Point2D a{ 10, 10 }; Point2D b{ 15, 15 }; ASSERT_EQ(Vector::distance2D(a, b), 7); a = { 0, 0 }; b = { 0, 0 }; ASSERT_EQ(Vector::distance2D(a, b), 0); a = { -10, -10 }; b = { 0, 0 }; ASSERT_EQ(Vector::distance2D(a, b), 14); a = { 0, 0 }; b = { -10, -10 }; ASSERT_EQ(Vector::distance2D(a, b), 14); a = { -10, -10 }; b = { -10, -10 }; ASSERT_EQ(Vector::distance2D(a, b), 0); a = { 10, 10 }; b = { 10, 10 }; ASSERT_EQ(Vector::distance2D(a, b), 0); } static_assert(Vector::rotate(Point2D{ 10, 10 }, 0) == Point2D{ 10, 10 }); static_assert(Vector::rotate(Point2D{ 10, 10 }, 1) == Point2D{ 10, -10 }); static_assert(Vector::rotate(Point2D{ 10, 10 }, 2) == Point2D{ -10, -10 }); static_assert(Vector::rotate(Point2D{ 10, 10 }, 3) == Point2D{ -10, 10 }); // Rolls over static_assert(Vector::rotate(Point2D{ 10, 10 }, 4) == Point2D{ 10, 10 }); // Rolls under static_assert(Vector::rotate(Point2D{ 10, 10 }, -1) == Point2D{ -10, 10 }); TEST(VectorTest, manhattenDistance) { Point2D a{ 10, 10 }; Point2D b{ 15, 15 }; ASSERT_EQ(Vector::manhattanDistance2D(a, b), 10); a = { 0, 0 }; b = { 0, 0 }; ASSERT_EQ(Vector::manhattanDistance2D(a, b), 0); a = { -10, -10 }; b = { 0, 0 }; ASSERT_EQ(Vector::manhattanDistance2D(a, b), 20); a = { 0, 0 }; b = { -10, -10 }; ASSERT_EQ(Vector::manhattanDistance2D(a, b), 20); a = { -10, -10 }; b = { -10, -10 }; ASSERT_EQ(Vector::manhattanDistance2D(a, b), 0); a = { 10, 10 }; b = { 10, 10 }; ASSERT_EQ(Vector::manhattanDistance2D(a, b), 0); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/include/OpenLoco/Math/Bound.hpp ```hpp #pragma once #include <algorithm> #include <cstdint> #include <limits> namespace OpenLoco::Math::Bound { namespace Op { // Bounds an addition to within the capacity of type lhs preventing an overflow // Note: Does not work for 64bit or bigger fields // e.g. uint8_t a = 5; add(a, 254); a == 255; <--reaches upper limit struct Add { template<typename T, typename U> constexpr T operator()(T lhs, U rhs) const { static_assert(sizeof(T) < 8 && sizeof(U) < 8, "Bounded addition only possible with smaller than 64bit types"); return static_cast<T>(std::min<int64_t>(static_cast<int64_t>(lhs) + rhs, std::numeric_limits<T>::max())); } }; // Bounds a subtraction to within the capacity of type lhs preventing an underflow // Note: Does not work for 64bit or bigger fields // e.g. uint8_t a = 5; sub(a, 254); a == 0; <--reaches lower limit struct Sub { template<typename T, typename U> constexpr T operator()(T lhs, U rhs) { static_assert(sizeof(T) < 8 && sizeof(U) < 8, "Bounded subtraction only possible with smaller than 64bit types"); return static_cast<T>(std::max<int64_t>(static_cast<int64_t>(lhs) - rhs, std::numeric_limits<T>::min())); } }; } template<typename T, typename U> constexpr T add(T lhs, U rhs) { return Op::Add{}(lhs, rhs); } static_assert(add(static_cast<uint8_t>(5), 254) == 255); template<typename T, typename U> constexpr T sub(T lhs, U rhs) { return Op::Sub{}(lhs, rhs); } static_assert(sub(5u, 254u) == 0); static_assert(sub(5, 254) == -249); static_assert(sub(static_cast<int8_t>(5), 254) == -128); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/include/OpenLoco/Math/Trigonometry.hpp ```hpp #pragma once #include "Vector.hpp" #include <cstdint> namespace OpenLoco { enum class Pitch : uint8_t; } namespace OpenLoco::Math::Trigonometry { // 0x00503B6A // ROUND(COS((32/64+(L1/64))*(2*PI()))*256,0), ROUND(SIN(((L1/64))*(2*PI())) * 256,0) // Where L1 represents an incrementing column 0 - 63 // Note: Must be at least 32bit to ensure all users do not overflow static constexpr Vector::TVector2<int32_t> kYawToDirectionVector[64] = { { -256, 0 }, { -255, 25 }, { -251, 50 }, { -245, 74 }, { -237, 98 }, { -226, 121 }, { -213, 142 }, { -198, 162 }, { -181, 181 }, { -162, 198 }, { -142, 213 }, { -121, 226 }, { -98, 237 }, { -74, 245 }, { -50, 251 }, { -25, 255 }, { 0, 256 }, { 25, 255 }, { 50, 251 }, { 74, 245 }, { 98, 237 }, { 121, 226 }, { 142, 213 }, { 162, 198 }, { 181, 181 }, { 198, 162 }, { 213, 142 }, { 226, 121 }, { 237, 98 }, { 245, 74 }, { 251, 50 }, { 255, 25 }, { 256, 0 }, { 255, -25 }, { 251, -50 }, { 245, -74 }, { 237, -98 }, { 226, -121 }, { 213, -142 }, { 198, -162 }, { 181, -181 }, { 162, -198 }, { 142, -213 }, { 121, -226 }, { 98, -237 }, { 74, -245 }, { 50, -251 }, { 25, -255 }, { 0, -256 }, { -25, -255 }, { -50, -251 }, { -74, -245 }, { -98, -237 }, { -121, -226 }, { -142, -213 }, { -162, -198 }, { -181, -181 }, { -198, -162 }, { -213, -142 }, { -226, -121 }, { -237, -98 }, { -245, -74 }, { -251, -50 }, { -255, -25 }, }; // 0x00503B50 // -SIN((Y1/360)*2*PI())*256 // Where Y1 represents the angle of pitch in degrees (0, 5.75, 11.75, 17, 22.5, reverse, 10, -10, 19.25, -19.25) // Note: pitch angles not quite correct in the Pitch enum class (decimal points can't go in identifier names) constexpr int16_t kPitchHorizontalFactor[] = { 0, -26, -52, -75, -98, 26, 52, 75, 98, -44, 44, -84, 84 }; constexpr auto computeXYMagnitude(int32_t height, Pitch pitch) { return (kPitchHorizontalFactor[static_cast<uint8_t>(pitch)] * height) / 256; } constexpr auto computeXYVector(int32_t magnitude, uint8_t yaw) { return (kYawToDirectionVector[yaw] * magnitude) / 256; } constexpr auto computeXYVector(int32_t height, Pitch pitch, uint8_t yaw) { return computeXYVector(computeXYMagnitude(height, pitch), yaw); } constexpr auto kDirectionPrecisionHigh = 0x4000; int32_t integerSinePrecisionHigh(uint16_t direction, int32_t magnitude); int32_t integerCosinePrecisionHigh(uint16_t direction, int32_t magnitude); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/include/OpenLoco/Math/Vector.hpp ```hpp #pragma once #include <algorithm> #include <cmath> #include <cstdint> #include <cstdio> namespace OpenLoco::Math::Vector { #pragma pack(push, 1) struct Vector2Tag { }; template<typename T, typename TTypeTag = Vector2Tag> struct TVector2 { using TypeTag = TTypeTag; T x{}; T y{}; constexpr TVector2() noexcept = default; constexpr TVector2(int32_t _x, int32_t _y) noexcept : x{ static_cast<T>(_x) } , y{ static_cast<T>(_y) } { } constexpr bool operator==(const TVector2& rhs) const noexcept { return x == rhs.x && y == rhs.y; } constexpr TVector2& operator+=(const TVector2& rhs) noexcept { x += rhs.x; y += rhs.y; return *this; } constexpr TVector2& operator-=(const TVector2& rhs) noexcept { x -= rhs.x; y -= rhs.y; return *this; } constexpr TVector2& operator*=(const T rhs) noexcept { x *= rhs; y *= rhs; return *this; } constexpr TVector2& operator/=(const T rhs) noexcept { x /= rhs; y /= rhs; return *this; } constexpr const TVector2 operator+(const TVector2& rhs) const noexcept { return { static_cast<T>(x + rhs.x), static_cast<T>(y + rhs.y) }; } constexpr const TVector2 operator-(const TVector2& rhs) const noexcept { return { static_cast<T>(x - rhs.x), static_cast<T>(y - rhs.y) }; } constexpr const TVector2 operator*(const int32_t rhs) const noexcept { return { static_cast<T>(x * rhs), static_cast<T>(y * rhs) }; } constexpr const TVector2 operator/(const int32_t rhs) const noexcept { return { static_cast<T>(x / rhs), static_cast<T>(y / rhs) }; } constexpr const TVector2 operator<<(const uint8_t rhs) const noexcept { return { static_cast<T>(x << rhs), static_cast<T>(y << rhs) }; } constexpr const TVector2 operator>>(const uint8_t rhs) const noexcept { return { static_cast<T>(x >> rhs), static_cast<T>(y >> rhs) }; } }; struct Vector3Tag { }; template<typename T, typename TTypeTag = Vector3Tag> struct TVector3 : TVector2<T, TTypeTag> { using Base = TVector2<T, TTypeTag>; T z{}; constexpr TVector3() noexcept = default; constexpr TVector3(int32_t _x, int32_t _y, int32_t _z) noexcept : Base(_x, _y) , z(static_cast<T>(_z)) { } constexpr TVector3(const Base& other, T z) noexcept : TVector3(other.x, other.y, z) { } constexpr bool operator==(const TVector3& rhs) const noexcept { return Base::operator==(rhs) && z == rhs.z; } constexpr TVector3& operator+=(const TVector3& rhs) noexcept { Base::operator+=(rhs); z += rhs.z; return *this; } constexpr TVector3& operator-=(const TVector3& rhs) noexcept { Base::operator-=(rhs); z -= rhs.z; return *this; } constexpr TVector3& operator*=(const T rhs) noexcept { Base::operator*=(rhs); z *= rhs.z; return *this; } constexpr TVector3& operator/=(const T rhs) noexcept { Base::operator/=(rhs); z /= rhs.z; return *this; } constexpr const TVector3 operator+(const TVector3& rhs) const noexcept { return { static_cast<T>(Base::x + rhs.x), static_cast<T>(Base::y + rhs.y), static_cast<T>(z + rhs.z) }; } constexpr const TVector3 operator-(const TVector3& rhs) const noexcept { return { static_cast<T>(Base::x - rhs.x), static_cast<T>(Base::y - rhs.y), static_cast<T>(z - rhs.z) }; } constexpr const TVector3 operator*(const T rhs) const noexcept { return { static_cast<T>(Base::x * rhs), static_cast<T>(Base::y * rhs), static_cast<T>(z * rhs) }; } constexpr const TVector3 operator/(const T rhs) const noexcept { return { static_cast<T>(Base::x / rhs), static_cast<T>(Base::y / rhs), static_cast<T>(z / rhs) }; } }; #pragma pack(pop) template<typename T, typename TTypeTag> static constexpr auto rotate(const TVector2<T, TTypeTag>& vec, int32_t direction) noexcept { TVector2<T, TTypeTag> res; switch (direction & 3) { default: case 0: res.x = vec.x; res.y = vec.y; break; case 1: res.x = vec.y; res.y = -vec.x; break; case 2: res.x = -vec.x; res.y = -vec.y; break; case 3: res.x = -vec.y; res.y = vec.x; break; } return res; } // AKA taxicab distance template<typename T, typename TTypeTag> static constexpr auto manhattanDistance2D(const TVector2<T, TTypeTag>& lhs, const TVector2<T, TTypeTag>& rhs) noexcept { return std::abs(lhs.x - rhs.x) + std::abs(lhs.y - rhs.y); } // AKA taxicab distance template<typename T, typename TTypeTag> static constexpr auto manhattanDistance3D(const TVector3<T, TTypeTag>& lhs, const TVector3<T, TTypeTag>& rhs) noexcept { return std::abs(lhs.x - rhs.x) + std::abs(lhs.y - rhs.y) + std::abs(lhs.z - rhs.z); } // AKA maximum metric, chessboard distance template<typename T, typename TTypeTag> static constexpr auto chebyshevDistance2D(const TVector2<T, TTypeTag>& lhs, const TVector2<T, TTypeTag>& rhs) noexcept { return std::max(std::abs(lhs.x - rhs.x), std::abs(lhs.y - rhs.y)); } // AKA maximum metric, chessboard distance template<typename T, typename TTypeTag> static constexpr auto chebyshevDistance3D(const TVector3<T, TTypeTag>& lhs, const TVector3<T, TTypeTag>& rhs) noexcept { return std::max({ std::abs(lhs.x - rhs.x), std::abs(lhs.y - rhs.y), std::abs(lhs.z - rhs.z) }); } template<typename T, typename TTypeTag> static constexpr auto dot(const TVector2<T, TTypeTag>& lhs, const TVector2<T, TTypeTag>& rhs) noexcept { return lhs.x * rhs.x + lhs.y * rhs.y; } template<typename T, typename TTypeTag> static constexpr auto dot(const TVector3<T, TTypeTag>& lhs, const TVector3<T, TTypeTag>& rhs) noexcept { return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z; } template<typename T, typename TTypeTag> static constexpr auto cross(const TVector3<T, TTypeTag>& lhs, const TVector3<T, TTypeTag>& rhs) noexcept { return TVector3<T>{ lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x }; } uint16_t fastSquareRoot(uint32_t distance); template<typename T, typename TTypeTag> auto distance2D(const TVector2<T, TTypeTag>& lhs, const TVector2<T, TTypeTag>& rhs) noexcept { auto x = lhs.x - rhs.x; auto y = lhs.y - rhs.y; return fastSquareRoot(x * x + y * y); } template<typename T, typename TTypeTag> auto distance3D(const TVector3<T, TTypeTag>& lhs, const TVector3<T, TTypeTag>& rhs) noexcept { auto x = lhs.x - rhs.x; auto y = lhs.y - rhs.y; auto z = lhs.z - rhs.z; return fastSquareRoot(x * x + y * y + z * z); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/src/Trigonometry.cpp ```cpp #include "Trigonometry.hpp" #include <array> namespace OpenLoco::Math::Trigonometry { namespace Data { // Excel Function =SIN((A1/16384)*2*PI())*32767 // Where A1 is 0 : 4095 // NOTE: this excel func is close but not identical // clang-format off // 0x00501B50 static constexpr std::array<int16_t, kDirectionPrecisionHigh / 4> kQuarterSine = { 0, 12, 25, 37, 50, 62, 75, 87, 100, 113, 125, 138, 150, 163, 175, 188, 201, 213, 226, 238, 251, 263, 276, 289, 301, 314, 326, 339, 351, 364, 376, 389, 402, 414, 427, 439, 452, 464, 477, 490, 502, 515, 527, 540, 552, 565, 578, 590, 603, 615, 628, 640, 653, 665, 678, 691, 703, 716, 728, 741, 753, 766, 779, 791, 804, 816, 829, 841, 854, 866, 879, 892, 904, 917, 929, 942, 954, 967, 980, 992, 1005, 1017, 1030, 1042, 1055, 1067, 1080, 1093, 1105, 1118, 1130, 1143, 1155, 1168, 1180, 1193, 1206, 1218, 1231, 1243, 1256, 1268, 1281, 1293, 1306, 1319, 1331, 1344, 1356, 1369, 1381, 1394, 1406, 1419, 1432, 1444, 1457, 1469, 1482, 1494, 1507, 1519, 1532, 1545, 1557, 1570, 1582, 1595, 1607, 1620, 1632, 1645, 1658, 1670, 1683, 1695, 1708, 1720, 1733, 1745, 1758, 1770, 1783, 1796, 1808, 1821, 1833, 1846, 1858, 1871, 1883, 1896, 1908, 1921, 1934, 1946, 1959, 1971, 1984, 1996, 2009, 2021, 2034, 2046, 2059, 2072, 2084, 2097, 2109, 2122, 2134, 2147, 2159, 2172, 2184, 2197, 2209, 2222, 2235, 2247, 2260, 2272, 2285, 2297, 2310, 2322, 2335, 2347, 2360, 2372, 2385, 2397, 2410, 2423, 2435, 2448, 2460, 2473, 2485, 2498, 2510, 2523, 2535, 2548, 2560, 2573, 2585, 2598, 2610, 2623, 2636, 2648, 2661, 2673, 2686, 2698, 2711, 2723, 2736, 2748, 2761, 2773, 2786, 2798, 2811, 2823, 2836, 2848, 2861, 2873, 2886, 2898, 2911, 2924, 2936, 2949, 2961, 2974, 2986, 2999, 3011, 3024, 3036, 3049, 3061, 3074, 3086, 3099, 3111, 3124, 3136, 3149, 3161, 3174, 3186, 3199, 3211, 3224, 3236, 3249, 3261, 3274, 3286, 3299, 3311, 3324, 3336, 3349, 3361, 3374, 3386, 3399, 3411, 3424, 3436, 3449, 3461, 3474, 3486, 3499, 3511, 3524, 3536, 3549, 3561, 3574, 3586, 3599, 3611, 3624, 3636, 3649, 3661, 3674, 3686, 3699, 3711, 3724, 3736, 3749, 3761, 3774, 3786, 3798, 3811, 3823, 3836, 3848, 3861, 3873, 3886, 3898, 3911, 3923, 3936, 3948, 3961, 3973, 3986, 3998, 4011, 4023, 4036, 4048, 4060, 4073, 4085, 4098, 4110, 4123, 4135, 4148, 4160, 4173, 4185, 4198, 4210, 4223, 4235, 4247, 4260, 4272, 4285, 4297, 4310, 4322, 4335, 4347, 4360, 4372, 4384, 4397, 4409, 4422, 4434, 4447, 4459, 4472, 4484, 4497, 4509, 4521, 4534, 4546, 4559, 4571, 4584, 4596, 4609, 4621, 4633, 4646, 4658, 4671, 4683, 4696, 4708, 4720, 4733, 4745, 4758, 4770, 4783, 4795, 4807, 4820, 4832, 4845, 4857, 4870, 4882, 4894, 4907, 4919, 4932, 4944, 4957, 4969, 4981, 4994, 5006, 5019, 5031, 5044, 5056, 5068, 5081, 5093, 5106, 5118, 5130, 5143, 5155, 5168, 5180, 5192, 5205, 5217, 5230, 5242, 5255, 5267, 5279, 5292, 5304, 5317, 5329, 5341, 5354, 5366, 5379, 5391, 5403, 5416, 5428, 5440, 5453, 5465, 5478, 5490, 5502, 5515, 5527, 5540, 5552, 5564, 5577, 5589, 5601, 5614, 5626, 5639, 5651, 5663, 5676, 5688, 5701, 5713, 5725, 5738, 5750, 5762, 5775, 5787, 5799, 5812, 5824, 5837, 5849, 5861, 5874, 5886, 5898, 5911, 5923, 5935, 5948, 5960, 5973, 5985, 5997, 6010, 6022, 6034, 6047, 6059, 6071, 6084, 6096, 6108, 6121, 6133, 6145, 6158, 6170, 6182, 6195, 6207, 6219, 6232, 6244, 6256, 6269, 6281, 6293, 6306, 6318, 6330, 6343, 6355, 6367, 6380, 6392, 6404, 6417, 6429, 6441, 6454, 6466, 6478, 6491, 6503, 6515, 6528, 6540, 6552, 6565, 6577, 6589, 6602, 6614, 6626, 6638, 6651, 6663, 6675, 6688, 6700, 6712, 6725, 6737, 6749, 6761, 6774, 6786, 6798, 6811, 6823, 6835, 6847, 6860, 6872, 6884, 6897, 6909, 6921, 6933, 6946, 6958, 6970, 6983, 6995, 7007, 7019, 7032, 7044, 7056, 7069, 7081, 7093, 7105, 7118, 7130, 7142, 7154, 7167, 7179, 7191, 7203, 7216, 7228, 7240, 7252, 7265, 7277, 7289, 7301, 7314, 7326, 7338, 7350, 7363, 7375, 7387, 7399, 7412, 7424, 7436, 7448, 7461, 7473, 7485, 7497, 7510, 7522, 7534, 7546, 7558, 7571, 7583, 7595, 7607, 7620, 7632, 7644, 7656, 7668, 7681, 7693, 7705, 7717, 7730, 7742, 7754, 7766, 7778, 7791, 7803, 7815, 7827, 7839, 7852, 7864, 7876, 7888, 7900, 7913, 7925, 7937, 7949, 7961, 7974, 7986, 7998, 8010, 8022, 8034, 8047, 8059, 8071, 8083, 8095, 8108, 8120, 8132, 8144, 8156, 8168, 8181, 8193, 8205, 8217, 8229, 8241, 8254, 8266, 8278, 8290, 8302, 8314, 8327, 8339, 8351, 8363, 8375, 8387, 8399, 8412, 8424, 8436, 8448, 8460, 8472, 8484, 8497, 8509, 8521, 8533, 8545, 8557, 8569, 8581, 8594, 8606, 8618, 8630, 8642, 8654, 8666, 8678, 8691, 8703, 8715, 8727, 8739, 8751, 8763, 8775, 8787, 8800, 8812, 8824, 8836, 8848, 8860, 8872, 8884, 8896, 8908, 8921, 8933, 8945, 8957, 8969, 8981, 8993, 9005, 9017, 9029, 9041, 9053, 9066, 9078, 9090, 9102, 9114, 9126, 9138, 9150, 9162, 9174, 9186, 9198, 9210, 9222, 9234, 9247, 9259, 9271, 9283, 9295, 9307, 9319, 9331, 9343, 9355, 9367, 9379, 9391, 9403, 9415, 9427, 9439, 9451, 9463, 9475, 9487, 9499, 9511, 9523, 9535, 9547, 9559, 9572, 9584, 9596, 9608, 9620, 9632, 9644, 9656, 9668, 9680, 9692, 9704, 9716, 9728, 9740, 9752, 9764, 9776, 9788, 9800, 9812, 9824, 9836, 9848, 9860, 9872, 9883, 9895, 9907, 9919, 9931, 9943, 9955, 9967, 9979, 9991, 10003, 10015, 10027, 10039, 10051, 10063, 10075, 10087, 10099, 10111, 10123, 10135, 10147, 10159, 10171, 10183, 10195, 10206, 10218, 10230, 10242, 10254, 10266, 10278, 10290, 10302, 10314, 10326, 10338, 10350, 10362, 10373, 10385, 10397, 10409, 10421, 10433, 10445, 10457, 10469, 10481, 10493, 10504, 10516, 10528, 10540, 10552, 10564, 10576, 10588, 10600, 10612, 10623, 10635, 10647, 10659, 10671, 10683, 10695, 10707, 10718, 10730, 10742, 10754, 10766, 10778, 10790, 10802, 10813, 10825, 10837, 10849, 10861, 10873, 10885, 10896, 10908, 10920, 10932, 10944, 10956, 10968, 10979, 10991, 11003, 11015, 11027, 11039, 11050, 11062, 11074, 11086, 11098, 11109, 11121, 11133, 11145, 11157, 11169, 11180, 11192, 11204, 11216, 11228, 11239, 11251, 11263, 11275, 11287, 11298, 11310, 11322, 11334, 11346, 11357, 11369, 11381, 11393, 11405, 11416, 11428, 11440, 11452, 11463, 11475, 11487, 11499, 11510, 11522, 11534, 11546, 11558, 11569, 11581, 11593, 11605, 11616, 11628, 11640, 11652, 11663, 11675, 11687, 11699, 11710, 11722, 11734, 11745, 11757, 11769, 11781, 11792, 11804, 11816, 11828, 11839, 11851, 11863, 11874, 11886, 11898, 11910, 11921, 11933, 11945, 11956, 11968, 11980, 11991, 12003, 12015, 12026, 12038, 12050, 12062, 12073, 12085, 12097, 12108, 12120, 12132, 12143, 12155, 12167, 12178, 12190, 12202, 12213, 12225, 12237, 12248, 12260, 12272, 12283, 12295, 12307, 12318, 12330, 12341, 12353, 12365, 12376, 12388, 12400, 12411, 12423, 12435, 12446, 12458, 12469, 12481, 12493, 12504, 12516, 12527, 12539, 12551, 12562, 12574, 12586, 12597, 12609, 12620, 12632, 12643, 12655, 12667, 12678, 12690, 12701, 12713, 12725, 12736, 12748, 12759, 12771, 12782, 12794, 12806, 12817, 12829, 12840, 12852, 12863, 12875, 12887, 12898, 12910, 12921, 12933, 12944, 12956, 12967, 12979, 12990, 13002, 13014, 13025, 13037, 13048, 13060, 13071, 13083, 13094, 13106, 13117, 13129, 13140, 13152, 13163, 13175, 13186, 13198, 13209, 13221, 13232, 13244, 13255, 13267, 13278, 13290, 13301, 13313, 13324, 13336, 13347, 13359, 13370, 13382, 13393, 13404, 13416, 13427, 13439, 13450, 13462, 13473, 13485, 13496, 13508, 13519, 13531, 13542, 13553, 13565, 13576, 13588, 13599, 13611, 13622, 13633, 13645, 13656, 13668, 13679, 13691, 13702, 13713, 13725, 13736, 13748, 13759, 13770, 13782, 13793, 13805, 13816, 13827, 13839, 13850, 13862, 13873, 13884, 13896, 13907, 13918, 13930, 13941, 13953, 13964, 13975, 13987, 13998, 14009, 14021, 14032, 14043, 14055, 14066, 14078, 14089, 14100, 14112, 14123, 14134, 14146, 14157, 14168, 14180, 14191, 14202, 14214, 14225, 14236, 14248, 14259, 14270, 14281, 14293, 14304, 14315, 14327, 14338, 14349, 14361, 14372, 14383, 14394, 14406, 14417, 14428, 14440, 14451, 14462, 14473, 14485, 14496, 14507, 14518, 14530, 14541, 14552, 14564, 14575, 14586, 14597, 14609, 14620, 14631, 14642, 14654, 14665, 14676, 14687, 14698, 14710, 14721, 14732, 14743, 14755, 14766, 14777, 14788, 14799, 14811, 14822, 14833, 14844, 14855, 14867, 14878, 14889, 14900, 14911, 14923, 14934, 14945, 14956, 14967, 14979, 14990, 15001, 15012, 15023, 15034, 15046, 15057, 15068, 15079, 15090, 15101, 15113, 15124, 15135, 15146, 15157, 15168, 15179, 15191, 15202, 15213, 15224, 15235, 15246, 15257, 15268, 15280, 15291, 15302, 15313, 15324, 15335, 15346, 15357, 15368, 15379, 15391, 15402, 15413, 15424, 15435, 15446, 15457, 15468, 15479, 15490, 15501, 15512, 15524, 15535, 15546, 15557, 15568, 15579, 15590, 15601, 15612, 15623, 15634, 15645, 15656, 15667, 15678, 15689, 15700, 15711, 15722, 15733, 15744, 15755, 15766, 15777, 15788, 15799, 15810, 15821, 15832, 15843, 15854, 15865, 15876, 15887, 15898, 15909, 15920, 15931, 15942, 15953, 15964, 15975, 15986, 15997, 16008, 16019, 16030, 16041, 16052, 16063, 16074, 16085, 16096, 16107, 16118, 16129, 16140, 16151, 16161, 16172, 16183, 16194, 16205, 16216, 16227, 16238, 16249, 16260, 16271, 16282, 16292, 16303, 16314, 16325, 16336, 16347, 16358, 16369, 16380, 16391, 16401, 16412, 16423, 16434, 16445, 16456, 16467, 16477, 16488, 16499, 16510, 16521, 16532, 16543, 16553, 16564, 16575, 16586, 16597, 16608, 16618, 16629, 16640, 16651, 16662, 16673, 16683, 16694, 16705, 16716, 16727, 16737, 16748, 16759, 16770, 16781, 16791, 16802, 16813, 16824, 16835, 16845, 16856, 16867, 16878, 16888, 16899, 16910, 16921, 16932, 16942, 16953, 16964, 16975, 16985, 16996, 17007, 17017, 17028, 17039, 17050, 17060, 17071, 17082, 17093, 17103, 17114, 17125, 17135, 17146, 17157, 17168, 17178, 17189, 17200, 17210, 17221, 17232, 17242, 17253, 17264, 17274, 17285, 17296, 17307, 17317, 17328, 17339, 17349, 17360, 17370, 17381, 17392, 17402, 17413, 17424, 17434, 17445, 17456, 17466, 17477, 17488, 17498, 17509, 17519, 17530, 17541, 17551, 17562, 17572, 17583, 17594, 17604, 17615, 17625, 17636, 17647, 17657, 17668, 17678, 17689, 17700, 17710, 17721, 17731, 17742, 17752, 17763, 17774, 17784, 17795, 17805, 17816, 17826, 17837, 17847, 17858, 17868, 17879, 17889, 17900, 17911, 17921, 17932, 17942, 17953, 17963, 17974, 17984, 17995, 18005, 18016, 18026, 18037, 18047, 18058, 18068, 18079, 18089, 18100, 18110, 18120, 18131, 18141, 18152, 18162, 18173, 18183, 18194, 18204, 18215, 18225, 18235, 18246, 18256, 18267, 18277, 18288, 18298, 18308, 18319, 18329, 18340, 18350, 18361, 18371, 18381, 18392, 18402, 18413, 18423, 18433, 18444, 18454, 18465, 18475, 18485, 18496, 18506, 18516, 18527, 18537, 18547, 18558, 18568, 18579, 18589, 18599, 18610, 18620, 18630, 18641, 18651, 18661, 18672, 18682, 18692, 18703, 18713, 18723, 18734, 18744, 18754, 18764, 18775, 18785, 18795, 18806, 18816, 18826, 18836, 18847, 18857, 18867, 18878, 18888, 18898, 18908, 18919, 18929, 18939, 18949, 18960, 18970, 18980, 18990, 19001, 19011, 19021, 19031, 19042, 19052, 19062, 19072, 19082, 19093, 19103, 19113, 19123, 19133, 19144, 19154, 19164, 19174, 19184, 19195, 19205, 19215, 19225, 19235, 19246, 19256, 19266, 19276, 19286, 19296, 19306, 19317, 19327, 19337, 19347, 19357, 19367, 19377, 19388, 19398, 19408, 19418, 19428, 19438, 19448, 19458, 19469, 19479, 19489, 19499, 19509, 19519, 19529, 19539, 19549, 19559, 19570, 19580, 19590, 19600, 19610, 19620, 19630, 19640, 19650, 19660, 19670, 19680, 19690, 19700, 19710, 19720, 19730, 19740, 19750, 19760, 19771, 19781, 19791, 19801, 19811, 19821, 19831, 19841, 19851, 19861, 19871, 19881, 19891, 19901, 19911, 19920, 19930, 19940, 19950, 19960, 19970, 19980, 19990, 20000, 20010, 20020, 20030, 20040, 20050, 20060, 20070, 20080, 20090, 20100, 20110, 20119, 20129, 20139, 20149, 20159, 20169, 20179, 20189, 20199, 20209, 20218, 20228, 20238, 20248, 20258, 20268, 20278, 20288, 20298, 20307, 20317, 20327, 20337, 20347, 20357, 20366, 20376, 20386, 20396, 20406, 20416, 20425, 20435, 20445, 20455, 20465, 20475, 20484, 20494, 20504, 20514, 20524, 20533, 20543, 20553, 20563, 20573, 20582, 20592, 20602, 20612, 20621, 20631, 20641, 20651, 20660, 20670, 20680, 20690, 20699, 20709, 20719, 20729, 20738, 20748, 20758, 20768, 20777, 20787, 20797, 20806, 20816, 20826, 20836, 20845, 20855, 20865, 20874, 20884, 20894, 20903, 20913, 20923, 20932, 20942, 20952, 20961, 20971, 20981, 20990, 21000, 21010, 21019, 21029, 21039, 21048, 21058, 21067, 21077, 21087, 21096, 21106, 21115, 21125, 21135, 21144, 21154, 21163, 21173, 21183, 21192, 21202, 21211, 21221, 21231, 21240, 21250, 21259, 21269, 21278, 21288, 21297, 21307, 21317, 21326, 21336, 21345, 21355, 21364, 21374, 21383, 21393, 21402, 21412, 21421, 21431, 21440, 21450, 21459, 21469, 21478, 21488, 21497, 21507, 21516, 21526, 21535, 21545, 21554, 21564, 21573, 21583, 21592, 21601, 21611, 21620, 21630, 21639, 21649, 21658, 21668, 21677, 21686, 21696, 21705, 21715, 21724, 21733, 21743, 21752, 21762, 21771, 21780, 21790, 21799, 21809, 21818, 21827, 21837, 21846, 21855, 21865, 21874, 21883, 21893, 21902, 21912, 21921, 21930, 21940, 21949, 21958, 21968, 21977, 21986, 21995, 22005, 22014, 22023, 22033, 22042, 22051, 22061, 22070, 22079, 22088, 22098, 22107, 22116, 22126, 22135, 22144, 22153, 22163, 22172, 22181, 22190, 22200, 22209, 22218, 22227, 22237, 22246, 22255, 22264, 22273, 22283, 22292, 22301, 22310, 22319, 22329, 22338, 22347, 22356, 22365, 22375, 22384, 22393, 22402, 22411, 22421, 22430, 22439, 22448, 22457, 22466, 22475, 22485, 22494, 22503, 22512, 22521, 22530, 22539, 22548, 22558, 22567, 22576, 22585, 22594, 22603, 22612, 22621, 22630, 22639, 22649, 22658, 22667, 22676, 22685, 22694, 22703, 22712, 22721, 22730, 22739, 22748, 22757, 22766, 22775, 22784, 22793, 22802, 22811, 22821, 22830, 22839, 22848, 22857, 22866, 22875, 22884, 22893, 22902, 22911, 22919, 22928, 22937, 22946, 22955, 22964, 22973, 22982, 22991, 23000, 23009, 23018, 23027, 23036, 23045, 23054, 23063, 23072, 23081, 23090, 23098, 23107, 23116, 23125, 23134, 23143, 23152, 23161, 23170, 23179, 23187, 23196, 23205, 23214, 23223, 23232, 23241, 23249, 23258, 23267, 23276, 23285, 23294, 23303, 23311, 23320, 23329, 23338, 23347, 23355, 23364, 23373, 23382, 23391, 23399, 23408, 23417, 23426, 23435, 23443, 23452, 23461, 23470, 23479, 23487, 23496, 23505, 23514, 23522, 23531, 23540, 23549, 23557, 23566, 23575, 23583, 23592, 23601, 23610, 23618, 23627, 23636, 23644, 23653, 23662, 23671, 23679, 23688, 23697, 23705, 23714, 23723, 23731, 23740, 23749, 23757, 23766, 23775, 23783, 23792, 23800, 23809, 23818, 23826, 23835, 23844, 23852, 23861, 23869, 23878, 23887, 23895, 23904, 23912, 23921, 23930, 23938, 23947, 23955, 23964, 23973, 23981, 23990, 23998, 24007, 24015, 24024, 24032, 24041, 24049, 24058, 24067, 24075, 24084, 24092, 24101, 24109, 24118, 24126, 24135, 24143, 24152, 24160, 24169, 24177, 24186, 24194, 24203, 24211, 24219, 24228, 24236, 24245, 24253, 24262, 24270, 24279, 24287, 24295, 24304, 24312, 24321, 24329, 24338, 24346, 24354, 24363, 24371, 24380, 24388, 24396, 24405, 24413, 24422, 24430, 24438, 24447, 24455, 24463, 24472, 24480, 24488, 24497, 24505, 24514, 24522, 24530, 24539, 24547, 24555, 24563, 24572, 24580, 24588, 24597, 24605, 24613, 24622, 24630, 24638, 24646, 24655, 24663, 24671, 24680, 24688, 24696, 24704, 24713, 24721, 24729, 24737, 24746, 24754, 24762, 24770, 24778, 24787, 24795, 24803, 24811, 24820, 24828, 24836, 24844, 24852, 24861, 24869, 24877, 24885, 24893, 24901, 24910, 24918, 24926, 24934, 24942, 24950, 24958, 24967, 24975, 24983, 24991, 24999, 25007, 25015, 25024, 25032, 25040, 25048, 25056, 25064, 25072, 25080, 25088, 25096, 25104, 25113, 25121, 25129, 25137, 25145, 25153, 25161, 25169, 25177, 25185, 25193, 25201, 25209, 25217, 25225, 25233, 25241, 25249, 25257, 25265, 25273, 25281, 25289, 25297, 25305, 25313, 25321, 25329, 25337, 25345, 25353, 25361, 25369, 25377, 25385, 25393, 25401, 25409, 25417, 25425, 25432, 25440, 25448, 25456, 25464, 25472, 25480, 25488, 25496, 25504, 25511, 25519, 25527, 25535, 25543, 25551, 25559, 25567, 25574, 25582, 25590, 25598, 25606, 25614, 25622, 25629, 25637, 25645, 25653, 25661, 25668, 25676, 25684, 25692, 25700, 25707, 25715, 25723, 25731, 25739, 25746, 25754, 25762, 25770, 25777, 25785, 25793, 25801, 25808, 25816, 25824, 25832, 25839, 25847, 25855, 25863, 25870, 25878, 25886, 25893, 25901, 25909, 25916, 25924, 25932, 25940, 25947, 25955, 25963, 25970, 25978, 25986, 25993, 26001, 26008, 26016, 26024, 26031, 26039, 26047, 26054, 26062, 26069, 26077, 26085, 26092, 26100, 26107, 26115, 26123, 26130, 26138, 26145, 26153, 26161, 26168, 26176, 26183, 26191, 26198, 26206, 26213, 26221, 26228, 26236, 26244, 26251, 26259, 26266, 26274, 26281, 26289, 26296, 26304, 26311, 26319, 26326, 26334, 26341, 26349, 26356, 26363, 26371, 26378, 26386, 26393, 26401, 26408, 26416, 26423, 26430, 26438, 26445, 26453, 26460, 26468, 26475, 26482, 26490, 26497, 26505, 26512, 26519, 26527, 26534, 26541, 26549, 26556, 26564, 26571, 26578, 26586, 26593, 26600, 26608, 26615, 26622, 26630, 26637, 26644, 26652, 26659, 26666, 26673, 26681, 26688, 26695, 26703, 26710, 26717, 26724, 26732, 26739, 26746, 26753, 26761, 26768, 26775, 26782, 26790, 26797, 26804, 26811, 26819, 26826, 26833, 26840, 26847, 26855, 26862, 26869, 26876, 26883, 26891, 26898, 26905, 26912, 26919, 26926, 26934, 26941, 26948, 26955, 26962, 26969, 26977, 26984, 26991, 26998, 27005, 27012, 27019, 27026, 27033, 27041, 27048, 27055, 27062, 27069, 27076, 27083, 27090, 27097, 27104, 27111, 27118, 27125, 27132, 27140, 27147, 27154, 27161, 27168, 27175, 27182, 27189, 27196, 27203, 27210, 27217, 27224, 27231, 27238, 27245, 27252, 27259, 27266, 27273, 27280, 27286, 27293, 27300, 27307, 27314, 27321, 27328, 27335, 27342, 27349, 27356, 27363, 27370, 27377, 27384, 27390, 27397, 27404, 27411, 27418, 27425, 27432, 27439, 27445, 27452, 27459, 27466, 27473, 27480, 27487, 27493, 27500, 27507, 27514, 27521, 27528, 27534, 27541, 27548, 27555, 27562, 27568, 27575, 27582, 27589, 27595, 27602, 27609, 27616, 27623, 27629, 27636, 27643, 27650, 27656, 27663, 27670, 27677, 27683, 27690, 27697, 27703, 27710, 27717, 27724, 27730, 27737, 27744, 27750, 27757, 27764, 27770, 27777, 27784, 27790, 27797, 27804, 27810, 27817, 27824, 27830, 27837, 27843, 27850, 27857, 27863, 27870, 27876, 27883, 27890, 27896, 27903, 27909, 27916, 27923, 27929, 27936, 27942, 27949, 27955, 27962, 27969, 27975, 27982, 27988, 27995, 28001, 28008, 28014, 28021, 28027, 28034, 28040, 28047, 28053, 28060, 28066, 28073, 28079, 28086, 28092, 28099, 28105, 28112, 28118, 28124, 28131, 28137, 28144, 28150, 28157, 28163, 28170, 28176, 28182, 28189, 28195, 28202, 28208, 28214, 28221, 28227, 28234, 28240, 28246, 28253, 28259, 28265, 28272, 28278, 28284, 28291, 28297, 28303, 28310, 28316, 28322, 28329, 28335, 28341, 28348, 28354, 28360, 28367, 28373, 28379, 28385, 28392, 28398, 28404, 28410, 28417, 28423, 28429, 28435, 28442, 28448, 28454, 28460, 28467, 28473, 28479, 28485, 28491, 28498, 28504, 28510, 28516, 28522, 28529, 28535, 28541, 28547, 28553, 28559, 28566, 28572, 28578, 28584, 28590, 28596, 28603, 28609, 28615, 28621, 28627, 28633, 28639, 28645, 28651, 28658, 28664, 28670, 28676, 28682, 28688, 28694, 28700, 28706, 28712, 28718, 28724, 28730, 28736, 28742, 28748, 28754, 28760, 28767, 28773, 28779, 28785, 28791, 28797, 28803, 28809, 28815, 28820, 28826, 28832, 28838, 28844, 28850, 28856, 28862, 28868, 28874, 28880, 28886, 28892, 28898, 28904, 28910, 28916, 28922, 28927, 28933, 28939, 28945, 28951, 28957, 28963, 28969, 28975, 28980, 28986, 28992, 28998, 29004, 29010, 29015, 29021, 29027, 29033, 29039, 29045, 29050, 29056, 29062, 29068, 29074, 29079, 29085, 29091, 29097, 29103, 29108, 29114, 29120, 29126, 29131, 29137, 29143, 29149, 29154, 29160, 29166, 29172, 29177, 29183, 29189, 29194, 29200, 29206, 29212, 29217, 29223, 29229, 29234, 29240, 29246, 29251, 29257, 29263, 29268, 29274, 29280, 29285, 29291, 29296, 29302, 29308, 29313, 29319, 29325, 29330, 29336, 29341, 29347, 29352, 29358, 29364, 29369, 29375, 29380, 29386, 29391, 29397, 29403, 29408, 29414, 29419, 29425, 29430, 29436, 29441, 29447, 29452, 29458, 29463, 29469, 29474, 29480, 29485, 29491, 29496, 29502, 29507, 29513, 29518, 29524, 29529, 29534, 29540, 29545, 29551, 29556, 29562, 29567, 29572, 29578, 29583, 29589, 29594, 29599, 29605, 29610, 29616, 29621, 29626, 29632, 29637, 29642, 29648, 29653, 29658, 29664, 29669, 29674, 29680, 29685, 29690, 29696, 29701, 29706, 29712, 29717, 29722, 29728, 29733, 29738, 29743, 29749, 29754, 29759, 29764, 29770, 29775, 29780, 29785, 29791, 29796, 29801, 29806, 29812, 29817, 29822, 29827, 29832, 29838, 29843, 29848, 29853, 29858, 29863, 29869, 29874, 29879, 29884, 29889, 29894, 29900, 29905, 29910, 29915, 29920, 29925, 29930, 29935, 29941, 29946, 29951, 29956, 29961, 29966, 29971, 29976, 29981, 29986, 29991, 29996, 30002, 30007, 30012, 30017, 30022, 30027, 30032, 30037, 30042, 30047, 30052, 30057, 30062, 30067, 30072, 30077, 30082, 30087, 30092, 30097, 30102, 30107, 30112, 30117, 30122, 30126, 30131, 30136, 30141, 30146, 30151, 30156, 30161, 30166, 30171, 30176, 30181, 30185, 30190, 30195, 30200, 30205, 30210, 30215, 30220, 30224, 30229, 30234, 30239, 30244, 30249, 30253, 30258, 30263, 30268, 30273, 30278, 30282, 30287, 30292, 30297, 30301, 30306, 30311, 30316, 30321, 30325, 30330, 30335, 30340, 30344, 30349, 30354, 30359, 30363, 30368, 30373, 30377, 30382, 30387, 30392, 30396, 30401, 30406, 30410, 30415, 30420, 30424, 30429, 30434, 30438, 30443, 30448, 30452, 30457, 30462, 30466, 30471, 30475, 30480, 30485, 30489, 30494, 30498, 30503, 30508, 30512, 30517, 30521, 30526, 30530, 30535, 30540, 30544, 30549, 30553, 30558, 30562, 30567, 30571, 30576, 30580, 30585, 30589, 30594, 30598, 30603, 30607, 30612, 30616, 30621, 30625, 30630, 30634, 30639, 30643, 30648, 30652, 30656, 30661, 30665, 30670, 30674, 30679, 30683, 30687, 30692, 30696, 30701, 30705, 30709, 30714, 30718, 30723, 30727, 30731, 30736, 30740, 30744, 30749, 30753, 30757, 30762, 30766, 30770, 30775, 30779, 30783, 30788, 30792, 30796, 30800, 30805, 30809, 30813, 30818, 30822, 30826, 30830, 30835, 30839, 30843, 30847, 30852, 30856, 30860, 30864, 30868, 30873, 30877, 30881, 30885, 30889, 30894, 30898, 30902, 30906, 30910, 30915, 30919, 30923, 30927, 30931, 30935, 30939, 30944, 30948, 30952, 30956, 30960, 30964, 30968, 30972, 30977, 30981, 30985, 30989, 30993, 30997, 31001, 31005, 31009, 31013, 31017, 31021, 31025, 31029, 31033, 31037, 31041, 31045, 31050, 31054, 31058, 31062, 31066, 31070, 31074, 31078, 31081, 31085, 31089, 31093, 31097, 31101, 31105, 31109, 31113, 31117, 31121, 31125, 31129, 31133, 31137, 31141, 31145, 31148, 31152, 31156, 31160, 31164, 31168, 31172, 31176, 31180, 31183, 31187, 31191, 31195, 31199, 31203, 31206, 31210, 31214, 31218, 31222, 31226, 31229, 31233, 31237, 31241, 31245, 31248, 31252, 31256, 31260, 31263, 31267, 31271, 31275, 31278, 31282, 31286, 31290, 31293, 31297, 31301, 31305, 31308, 31312, 31316, 31319, 31323, 31327, 31330, 31334, 31338, 31341, 31345, 31349, 31352, 31356, 31360, 31363, 31367, 31371, 31374, 31378, 31381, 31385, 31389, 31392, 31396, 31399, 31403, 31407, 31410, 31414, 31417, 31421, 31425, 31428, 31432, 31435, 31439, 31442, 31446, 31449, 31453, 31456, 31460, 31463, 31467, 31470, 31474, 31477, 31481, 31484, 31488, 31491, 31495, 31498, 31502, 31505, 31509, 31512, 31516, 31519, 31522, 31526, 31529, 31533, 31536, 31539, 31543, 31546, 31550, 31553, 31556, 31560, 31563, 31567, 31570, 31573, 31577, 31580, 31583, 31587, 31590, 31593, 31597, 31600, 31603, 31607, 31610, 31613, 31617, 31620, 31623, 31626, 31630, 31633, 31636, 31640, 31643, 31646, 31649, 31653, 31656, 31659, 31662, 31666, 31669, 31672, 31675, 31678, 31682, 31685, 31688, 31691, 31694, 31698, 31701, 31704, 31707, 31710, 31714, 31717, 31720, 31723, 31726, 31729, 31732, 31736, 31739, 31742, 31745, 31748, 31751, 31754, 31757, 31760, 31764, 31767, 31770, 31773, 31776, 31779, 31782, 31785, 31788, 31791, 31794, 31797, 31800, 31803, 31806, 31809, 31812, 31815, 31818, 31821, 31824, 31827, 31830, 31833, 31836, 31839, 31842, 31845, 31848, 31851, 31854, 31857, 31860, 31863, 31866, 31869, 31872, 31874, 31877, 31880, 31883, 31886, 31889, 31892, 31895, 31898, 31901, 31903, 31906, 31909, 31912, 31915, 31918, 31920, 31923, 31926, 31929, 31932, 31935, 31937, 31940, 31943, 31946, 31949, 31951, 31954, 31957, 31960, 31963, 31965, 31968, 31971, 31974, 31976, 31979, 31982, 31985, 31987, 31990, 31993, 31995, 31998, 32001, 32004, 32006, 32009, 32012, 32014, 32017, 32020, 32022, 32025, 32028, 32030, 32033, 32036, 32038, 32041, 32043, 32046, 32049, 32051, 32054, 32057, 32059, 32062, 32064, 32067, 32069, 32072, 32075, 32077, 32080, 32082, 32085, 32087, 32090, 32092, 32095, 32098, 32100, 32103, 32105, 32108, 32110, 32113, 32115, 32118, 32120, 32123, 32125, 32128, 32130, 32132, 32135, 32137, 32140, 32142, 32145, 32147, 32150, 32152, 32154, 32157, 32159, 32162, 32164, 32166, 32169, 32171, 32174, 32176, 32178, 32181, 32183, 32185, 32188, 32190, 32193, 32195, 32197, 32200, 32202, 32204, 32206, 32209, 32211, 32213, 32216, 32218, 32220, 32223, 32225, 32227, 32229, 32232, 32234, 32236, 32238, 32241, 32243, 32245, 32247, 32250, 32252, 32254, 32256, 32258, 32261, 32263, 32265, 32267, 32269, 32272, 32274, 32276, 32278, 32280, 32282, 32285, 32287, 32289, 32291, 32293, 32295, 32297, 32300, 32302, 32304, 32306, 32308, 32310, 32312, 32314, 32316, 32318, 32320, 32322, 32325, 32327, 32329, 32331, 32333, 32335, 32337, 32339, 32341, 32343, 32345, 32347, 32349, 32351, 32353, 32355, 32357, 32359, 32361, 32363, 32365, 32367, 32369, 32371, 32373, 32375, 32376, 32378, 32380, 32382, 32384, 32386, 32388, 32390, 32392, 32394, 32396, 32397, 32399, 32401, 32403, 32405, 32407, 32409, 32410, 32412, 32414, 32416, 32418, 32420, 32422, 32423, 32425, 32427, 32429, 32431, 32432, 32434, 32436, 32438, 32439, 32441, 32443, 32445, 32447, 32448, 32450, 32452, 32453, 32455, 32457, 32459, 32460, 32462, 32464, 32466, 32467, 32469, 32471, 32472, 32474, 32476, 32477, 32479, 32481, 32482, 32484, 32486, 32487, 32489, 32490, 32492, 32494, 32495, 32497, 32499, 32500, 32502, 32503, 32505, 32507, 32508, 32510, 32511, 32513, 32514, 32516, 32517, 32519, 32521, 32522, 32524, 32525, 32527, 32528, 32530, 32531, 32533, 32534, 32536, 32537, 32539, 32540, 32542, 32543, 32545, 32546, 32547, 32549, 32550, 32552, 32553, 32555, 32556, 32558, 32559, 32560, 32562, 32563, 32565, 32566, 32567, 32569, 32570, 32571, 32573, 32574, 32576, 32577, 32578, 32580, 32581, 32582, 32584, 32585, 32586, 32588, 32589, 32590, 32592, 32593, 32594, 32595, 32597, 32598, 32599, 32600, 32602, 32603, 32604, 32605, 32607, 32608, 32609, 32610, 32612, 32613, 32614, 32615, 32617, 32618, 32619, 32620, 32621, 32622, 32624, 32625, 32626, 32627, 32628, 32629, 32631, 32632, 32633, 32634, 32635, 32636, 32637, 32639, 32640, 32641, 32642, 32643, 32644, 32645, 32646, 32647, 32648, 32649, 32650, 32652, 32653, 32654, 32655, 32656, 32657, 32658, 32659, 32660, 32661, 32662, 32663, 32664, 32665, 32666, 32667, 32668, 32669, 32670, 32671, 32672, 32673, 32674, 32674, 32675, 32676, 32677, 32678, 32679, 32680, 32681, 32682, 32683, 32684, 32685, 32685, 32686, 32687, 32688, 32689, 32690, 32691, 32692, 32692, 32693, 32694, 32695, 32696, 32697, 32697, 32698, 32699, 32700, 32701, 32701, 32702, 32703, 32704, 32705, 32705, 32706, 32707, 32708, 32708, 32709, 32710, 32711, 32711, 32712, 32713, 32714, 32714, 32715, 32716, 32716, 32717, 32718, 32718, 32719, 32720, 32720, 32721, 32722, 32722, 32723, 32724, 32724, 32725, 32726, 32726, 32727, 32728, 32728, 32729, 32729, 32730, 32731, 32731, 32732, 32732, 32733, 32733, 32734, 32735, 32735, 32736, 32736, 32737, 32737, 32738, 32738, 32739, 32739, 32740, 32740, 32741, 32741, 32742, 32742, 32743, 32743, 32744, 32744, 32745, 32745, 32746, 32746, 32747, 32747, 32747, 32748, 32748, 32749, 32749, 32750, 32750, 32750, 32751, 32751, 32752, 32752, 32752, 32753, 32753, 32753, 32754, 32754, 32755, 32755, 32755, 32756, 32756, 32756, 32757, 32757, 32757, 32757, 32758, 32758, 32758, 32759, 32759, 32759, 32759, 32760, 32760, 32760, 32760, 32761, 32761, 32761, 32761, 32762, 32762, 32762, 32762, 32763, 32763, 32763, 32763, 32763, 32764, 32764, 32764, 32764, 32764, 32764, 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766, }; // clang-format on } int32_t integerSinePrecisionHigh(uint16_t direction, int32_t magnitude) { // Build the full sine wave from the quarter wave by subtraction of direction/magnitude // Note: ~ bitwise negation important for both to match vanilla const auto sineIndex = ((direction & (1 << 12)) ? ~direction : direction) & 0xFFF; const auto value = (direction & (1 << 13)) ? ~Data::kQuarterSine[sineIndex] : Data::kQuarterSine[sineIndex]; return value * magnitude / 0x8000; } int32_t integerCosinePrecisionHigh(uint16_t direction, int32_t magnitude) { // Cosine is Sine plus pi/2 return integerSinePrecisionHigh(direction + kDirectionPrecisionHigh / 4, magnitude); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Math/src/Vector.cpp ```cpp #include "Vector.hpp" #include <array> namespace OpenLoco::Math::Vector { namespace Data { // clang-format off // 0x00500B50 constexpr std::array<uint16_t, 2048> kFastSquareRootTable = { 0, 1448, 2048, 2508, 2896, 3238, 3547, 3831, 4096, 4344, 4579, 4802, 5016, 5221, 5418, 5608, 5792, 5970, 6144, 6312, 6476, 6636, 6792, 6945, 7094, 7240, 7384, 7524, 7662, 7798, 7931, 8062, 8192, 8319, 8444, 8567, 8688, 8808, 8927, 9043, 9158, 9272, 9385, 9496, 9605, 9714, 9821, 9928, 10033, 10137, 10240, 10341, 10442, 10542, 10641, 10739, 10836, 10933, 11028, 11123, 11217, 11310, 11402, 11494, 11585, 11675, 11764, 11853, 11941, 12029, 12116, 12202, 12288, 12373, 12457, 12541, 12624, 12707, 12789, 12871, 12952, 13033, 13113, 13193, 13272, 13351, 13429, 13507, 13584, 13661, 13738, 13814, 13890, 13965, 14040, 14114, 14188, 14262, 14336, 14408, 14481, 14553, 14625, 14697, 14768, 14839, 14909, 14979, 15049, 15119, 15188, 15257, 15325, 15394, 15462, 15529, 15597, 15664, 15730, 15797, 15863, 15929, 15995, 16060, 16125, 16190, 16255, 16319, 16384, 16447, 16511, 16574, 16638, 16700, 16763, 16826, 16888, 16950, 17011, 17073, 17134, 17195, 17256, 17317, 17377, 17438, 17498, 17557, 17617, 17676, 17736, 17795, 17854, 17912, 17971, 18029, 18087, 18145, 18203, 18260, 18317, 18375, 18432, 18488, 18545, 18601, 18658, 18714, 18770, 18826, 18881, 18937, 18992, 19047, 19102, 19157, 19211, 19266, 19320, 19374, 19429, 19482, 19536, 19590, 19643, 19697, 19750, 19803, 19856, 19908, 19961, 20013, 20066, 20118, 20170, 20222, 20274, 20325, 20377, 20428, 20480, 20531, 20582, 20633, 20683, 20734, 20784, 20835, 20885, 20935, 20985, 21035, 21085, 21135, 21184, 21234, 21283, 21332, 21381, 21430, 21479, 21528, 21577, 21625, 21673, 21722, 21770, 21818, 21866, 21914, 21962, 22010, 22057, 22105, 22152, 22199, 22246, 22294, 22341, 22387, 22434, 22481, 22528, 22574, 22620, 22667, 22713, 22759, 22805, 22851, 22897, 22943, 22988, 23034, 23079, 23125, 23170, 23215, 23260, 23305, 23350, 23395, 23440, 23485, 23529, 23574, 23618, 23663, 23707, 23751, 23795, 23839, 23883, 23927, 23971, 24014, 24058, 24102, 24145, 24188, 24232, 24275, 24318, 24361, 24404, 24447, 24490, 24533, 24576, 24618, 24661, 24703, 24746, 24788, 24830, 24872, 24914, 24957, 24999, 25040, 25082, 25124, 25166, 25207, 25249, 25290, 25332, 25373, 25415, 25456, 25497, 25538, 25579, 25620, 25661, 25702, 25742, 25783, 25824, 25864, 25905, 25945, 25986, 26026, 26066, 26106, 26147, 26187, 26227, 26267, 26307, 26346, 26386, 26426, 26465, 26505, 26545, 26584, 26624, 26663, 26702, 26741, 26781, 26820, 26859, 26898, 26937, 26976, 27014, 27053, 27092, 27131, 27169, 27208, 27246, 27285, 27323, 27362, 27400, 27438, 27476, 27514, 27553, 27591, 27629, 27666, 27704, 27742, 27780, 27818, 27855, 27893, 27930, 27968, 28005, 28043, 28080, 28118, 28155, 28192, 28229, 28266, 28303, 28340, 28377, 28414, 28451, 28488, 28525, 28562, 28598, 28635, 28672, 28708, 28745, 28781, 28817, 28854, 28890, 28926, 28963, 28999, 29035, 29071, 29107, 29143, 29179, 29215, 29251, 29287, 29322, 29358, 29394, 29429, 29465, 29501, 29536, 29572, 29607, 29642, 29678, 29713, 29748, 29784, 29819, 29854, 29889, 29924, 29959, 29994, 30029, 30064, 30099, 30134, 30168, 30203, 30238, 30273, 30307, 30342, 30376, 30411, 30445, 30480, 30514, 30548, 30583, 30617, 30651, 30685, 30720, 30754, 30788, 30822, 30856, 30890, 30924, 30958, 30991, 31025, 31059, 31093, 31126, 31160, 31194, 31227, 31261, 31294, 31328, 31361, 31395, 31428, 31461, 31495, 31528, 31561, 31595, 31628, 31661, 31694, 31727, 31760, 31793, 31826, 31859, 31892, 31925, 31957, 31990, 32023, 32056, 32088, 32121, 32154, 32186, 32219, 32251, 32284, 32316, 32349, 32381, 32414, 32446, 32478, 32510, 32543, 32575, 32607, 32639, 32671, 32703, 32735, 32768, 32799, 32831, 32863, 32895, 32927, 32959, 32991, 33023, 33054, 33086, 33118, 33149, 33181, 33212, 33244, 33276, 33307, 33339, 33370, 33401, 33433, 33464, 33495, 33527, 33558, 33589, 33620, 33652, 33683, 33714, 33745, 33776, 33807, 33838, 33869, 33900, 33931, 33962, 33993, 34023, 34054, 34085, 34116, 34146, 34177, 34208, 34238, 34269, 34300, 34330, 34361, 34391, 34422, 34452, 34483, 34513, 34543, 34574, 34604, 34634, 34665, 34695, 34725, 34755, 34785, 34816, 34846, 34876, 34906, 34936, 34966, 34996, 35026, 35056, 35086, 35115, 35145, 35175, 35205, 35235, 35264, 35294, 35324, 35353, 35383, 35413, 35442, 35472, 35501, 35531, 35560, 35590, 35619, 35649, 35678, 35708, 35737, 35766, 35796, 35825, 35854, 35883, 35913, 35942, 35971, 36000, 36029, 36058, 36087, 36116, 36145, 36174, 36203, 36232, 36261, 36290, 36319, 36348, 36377, 36406, 36434, 36463, 36492, 36521, 36549, 36578, 36607, 36635, 36664, 36692, 36721, 36750, 36778, 36807, 36835, 36864, 36892, 36920, 36949, 36977, 37005, 37034, 37062, 37090, 37119, 37147, 37175, 37203, 37231, 37260, 37288, 37316, 37344, 37372, 37400, 37428, 37456, 37484, 37512, 37540, 37568, 37596, 37624, 37652, 37679, 37707, 37735, 37763, 37791, 37818, 37846, 37874, 37901, 37929, 37957, 37984, 38012, 38039, 38067, 38095, 38122, 38150, 38177, 38204, 38232, 38259, 38287, 38314, 38341, 38369, 38396, 38423, 38451, 38478, 38505, 38532, 38560, 38587, 38614, 38641, 38668, 38695, 38722, 38749, 38777, 38804, 38831, 38858, 38885, 38912, 38938, 38965, 38992, 39019, 39046, 39073, 39100, 39126, 39153, 39180, 39207, 39234, 39260, 39287, 39314, 39340, 39367, 39394, 39420, 39447, 39473, 39500, 39526, 39553, 39579, 39606, 39632, 39659, 39685, 39712, 39738, 39764, 39791, 39817, 39843, 39870, 39896, 39922, 39949, 39975, 40001, 40027, 40053, 40080, 40106, 40132, 40158, 40184, 40210, 40236, 40262, 40288, 40314, 40340, 40366, 40392, 40418, 40444, 40470, 40496, 40522, 40548, 40574, 40600, 40625, 40651, 40677, 40703, 40728, 40754, 40780, 40806, 40831, 40857, 40883, 40908, 40934, 40960, 40985, 41011, 41036, 41062, 41087, 41113, 41138, 41164, 41189, 41215, 41240, 41266, 41291, 41316, 41342, 41367, 41392, 41418, 41443, 41468, 41494, 41519, 41544, 41569, 41595, 41620, 41645, 41670, 41695, 41720, 41746, 41771, 41796, 41821, 41846, 41871, 41896, 41921, 41946, 41971, 41996, 42021, 42046, 42071, 42096, 42121, 42146, 42170, 42195, 42220, 42245, 42270, 42295, 42319, 42344, 42369, 42394, 42418, 42443, 42468, 42492, 42517, 42542, 42566, 42591, 42616, 42640, 42665, 42689, 42714, 42738, 42763, 42788, 42812, 42836, 42861, 42885, 42910, 42934, 42959, 42983, 43008, 43032, 43056, 43081, 43105, 43129, 43154, 43178, 43202, 43226, 43251, 43275, 43299, 43323, 43347, 43372, 43396, 43420, 43444, 43468, 43492, 43516, 43541, 43565, 43589, 43613, 43637, 43661, 43685, 43709, 43733, 43757, 43781, 43805, 43829, 43853, 43876, 43900, 43924, 43948, 43972, 43996, 44020, 44043, 44067, 44091, 44115, 44139, 44162, 44186, 44210, 44233, 44257, 44281, 44305, 44328, 44352, 44375, 44399, 44423, 44446, 44470, 44493, 44517, 44541, 44564, 44588, 44611, 44635, 44658, 44682, 44705, 44728, 44752, 44775, 44799, 44822, 44846, 44869, 44892, 44916, 44939, 44962, 44986, 45009, 45032, 45056, 45079, 45102, 45125, 45148, 45172, 45195, 45218, 45241, 45264, 45288, 45311, 45334, 45357, 45380, 45403, 45426, 45449, 45472, 45496, 45519, 45542, 45565, 45588, 45611, 45634, 45657, 45680, 45702, 45725, 45748, 45771, 45794, 45817, 45840, 45863, 45886, 45909, 45931, 45954, 45977, 46000, 46023, 46045, 46068, 46091, 46114, 46136, 46159, 46182, 46204, 46227, 46250, 46273, 46295, 46318, 46340, 46363, 46386, 46408, 46431, 46453, 46476, 46499, 46521, 46544, 46566, 46589, 46611, 46634, 46656, 46679, 46701, 46724, 46746, 46768, 46791, 46813, 46836, 46858, 46880, 46903, 46925, 46947, 46970, 46992, 47014, 47037, 47059, 47081, 47104, 47126, 47148, 47170, 47192, 47215, 47237, 47259, 47281, 47303, 47326, 47348, 47370, 47392, 47414, 47436, 47458, 47480, 47503, 47525, 47547, 47569, 47591, 47613, 47635, 47657, 47679, 47701, 47723, 47745, 47767, 47789, 47811, 47832, 47854, 47876, 47898, 47920, 47942, 47964, 47986, 48008, 48029, 48051, 48073, 48095, 48117, 48138, 48160, 48182, 48204, 48225, 48247, 48269, 48291, 48312, 48334, 48356, 48377, 48399, 48421, 48442, 48464, 48486, 48507, 48529, 48550, 48572, 48594, 48615, 48637, 48658, 48680, 48701, 48723, 48744, 48766, 48787, 48809, 48830, 48852, 48873, 48895, 48916, 48938, 48959, 48981, 49002, 49023, 49045, 49066, 49087, 49109, 49130, 49152, 49173, 49194, 49215, 49237, 49258, 49279, 49301, 49322, 49343, 49364, 49386, 49407, 49428, 49449, 49470, 49492, 49513, 49534, 49555, 49576, 49597, 49619, 49640, 49661, 49682, 49703, 49724, 49745, 49766, 49787, 49808, 49829, 49851, 49872, 49893, 49914, 49935, 49956, 49977, 49998, 50019, 50039, 50060, 50081, 50102, 50123, 50144, 50165, 50186, 50207, 50228, 50249, 50269, 50290, 50311, 50332, 50353, 50374, 50394, 50415, 50436, 50457, 50478, 50498, 50519, 50540, 50561, 50581, 50602, 50623, 50644, 50664, 50685, 50706, 50726, 50747, 50768, 50788, 50809, 50830, 50850, 50871, 50891, 50912, 50933, 50953, 50974, 50994, 51015, 51035, 51056, 51076, 51097, 51118, 51138, 51159, 51179, 51200, 51220, 51240, 51261, 51281, 51302, 51322, 51343, 51363, 51383, 51404, 51424, 51445, 51465, 51485, 51506, 51526, 51546, 51567, 51587, 51607, 51628, 51648, 51668, 51689, 51709, 51729, 51750, 51770, 51790, 51810, 51830, 51851, 51871, 51891, 51911, 51932, 51952, 51972, 51992, 52012, 52032, 52053, 52073, 52093, 52113, 52133, 52153, 52173, 52193, 52213, 52234, 52254, 52274, 52294, 52314, 52334, 52354, 52374, 52394, 52414, 52434, 52454, 52474, 52494, 52514, 52534, 52554, 52574, 52594, 52614, 52633, 52653, 52673, 52693, 52713, 52733, 52753, 52773, 52793, 52812, 52832, 52852, 52872, 52892, 52912, 52931, 52951, 52971, 52991, 53011, 53030, 53050, 53070, 53090, 53109, 53129, 53149, 53169, 53188, 53208, 53228, 53248, 53267, 53287, 53307, 53326, 53346, 53366, 53385, 53405, 53424, 53444, 53464, 53483, 53503, 53522, 53542, 53562, 53581, 53601, 53620, 53640, 53659, 53679, 53699, 53718, 53738, 53757, 53777, 53796, 53816, 53835, 53855, 53874, 53893, 53913, 53932, 53952, 53971, 53991, 54010, 54029, 54049, 54068, 54088, 54107, 54126, 54146, 54165, 54184, 54204, 54223, 54243, 54262, 54281, 54300, 54320, 54339, 54358, 54378, 54397, 54416, 54435, 54455, 54474, 54493, 54512, 54532, 54551, 54570, 54589, 54609, 54628, 54647, 54666, 54685, 54704, 54724, 54743, 54762, 54781, 54800, 54819, 54839, 54858, 54877, 54896, 54915, 54934, 54953, 54972, 54991, 55010, 55029, 55048, 55067, 55087, 55106, 55125, 55144, 55163, 55182, 55201, 55220, 55239, 55258, 55277, 55296, 55314, 55333, 55352, 55371, 55390, 55409, 55428, 55447, 55466, 55485, 55504, 55523, 55541, 55560, 55579, 55598, 55617, 55636, 55655, 55673, 55692, 55711, 55730, 55749, 55768, 55786, 55805, 55824, 55843, 55861, 55880, 55899, 55918, 55937, 55955, 55974, 55993, 56011, 56030, 56049, 56068, 56086, 56105, 56124, 56142, 56161, 56180, 56198, 56217, 56236, 56254, 56273, 56292, 56310, 56329, 56347, 56366, 56385, 56403, 56422, 56440, 56459, 56478, 56496, 56515, 56533, 56552, 56570, 56589, 56607, 56626, 56644, 56663, 56681, 56700, 56718, 56737, 56755, 56774, 56792, 56811, 56829, 56848, 56866, 56885, 56903, 56921, 56940, 56958, 56977, 56995, 57013, 57032, 57050, 57069, 57087, 57105, 57124, 57142, 57160, 57179, 57197, 57215, 57234, 57252, 57270, 57289, 57307, 57325, 57344, 57362, 57380, 57398, 57417, 57435, 57453, 57471, 57490, 57508, 57526, 57544, 57563, 57581, 57599, 57617, 57635, 57654, 57672, 57690, 57708, 57726, 57744, 57763, 57781, 57799, 57817, 57835, 57853, 57871, 57889, 57908, 57926, 57944, 57962, 57980, 57998, 58016, 58034, 58052, 58070, 58088, 58106, 58124, 58143, 58161, 58179, 58197, 58215, 58233, 58251, 58269, 58287, 58305, 58323, 58341, 58359, 58376, 58394, 58412, 58430, 58448, 58466, 58484, 58502, 58520, 58538, 58556, 58574, 58592, 58610, 58627, 58645, 58663, 58681, 58699, 58717, 58735, 58752, 58770, 58788, 58806, 58824, 58842, 58859, 58877, 58895, 58913, 58931, 58948, 58966, 58984, 59002, 59020, 59037, 59055, 59073, 59091, 59108, 59126, 59144, 59162, 59179, 59197, 59215, 59232, 59250, 59268, 59285, 59303, 59321, 59339, 59356, 59374, 59392, 59409, 59427, 59444, 59462, 59480, 59497, 59515, 59533, 59550, 59568, 59585, 59603, 59621, 59638, 59656, 59673, 59691, 59708, 59726, 59744, 59761, 59779, 59796, 59814, 59831, 59849, 59866, 59884, 59901, 59919, 59936, 59954, 59971, 59989, 60006, 60024, 60041, 60059, 60076, 60094, 60111, 60128, 60146, 60163, 60181, 60198, 60216, 60233, 60250, 60268, 60285, 60303, 60320, 60337, 60355, 60372, 60389, 60407, 60424, 60442, 60459, 60476, 60494, 60511, 60528, 60546, 60563, 60580, 60597, 60615, 60632, 60649, 60667, 60684, 60701, 60718, 60736, 60753, 60770, 60788, 60805, 60822, 60839, 60856, 60874, 60891, 60908, 60925, 60943, 60960, 60977, 60994, 61011, 61029, 61046, 61063, 61080, 61097, 61114, 61132, 61149, 61166, 61183, 61200, 61217, 61234, 61251, 61269, 61286, 61303, 61320, 61337, 61354, 61371, 61388, 61405, 61422, 61440, 61457, 61474, 61491, 61508, 61525, 61542, 61559, 61576, 61593, 61610, 61627, 61644, 61661, 61678, 61695, 61712, 61729, 61746, 61763, 61780, 61797, 61814, 61831, 61848, 61865, 61882, 61899, 61916, 61932, 61949, 61966, 61983, 62000, 62017, 62034, 62051, 62068, 62085, 62102, 62118, 62135, 62152, 62169, 62186, 62203, 62220, 62236, 62253, 62270, 62287, 62304, 62321, 62337, 62354, 62371, 62388, 62405, 62422, 62438, 62455, 62472, 62489, 62505, 62522, 62539, 62556, 62573, 62589, 62606, 62623, 62640, 62656, 62673, 62690, 62706, 62723, 62740, 62757, 62773, 62790, 62807, 62823, 62840, 62857, 62873, 62890, 62907, 62923, 62940, 62957, 62973, 62990, 63007, 63023, 63040, 63057, 63073, 63090, 63106, 63123, 63140, 63156, 63173, 63190, 63206, 63223, 63239, 63256, 63272, 63289, 63306, 63322, 63339, 63355, 63372, 63388, 63405, 63421, 63438, 63454, 63471, 63488, 63504, 63521, 63537, 63554, 63570, 63587, 63603, 63619, 63636, 63652, 63669, 63685, 63702, 63718, 63735, 63751, 63768, 63784, 63801, 63817, 63833, 63850, 63866, 63883, 63899, 63915, 63932, 63948, 63965, 63981, 63997, 64014, 64030, 64047, 64063, 64079, 64096, 64112, 64128, 64145, 64161, 64177, 64194, 64210, 64226, 64243, 64259, 64275, 64292, 64308, 64324, 64341, 64357, 64373, 64389, 64406, 64422, 64438, 64455, 64471, 64487, 64503, 64520, 64536, 64552, 64568, 64585, 64601, 64617, 64633, 64650, 64666, 64682, 64698, 64714, 64731, 64747, 64763, 64779, 64795, 64812, 64828, 64844, 64860, 64876, 64892, 64909, 64925, 64941, 64957, 64973, 64989, 65005, 65021, 65038, 65054, 65070, 65086, 65102, 65118, 65134, 65150, 65166, 65183, 65199, 65215, 65231, 65247, 65263, 65279, 65295, 65311, 65327, 65343, 65359, 65375, 65391, 65407, 65423, 65439, 65455, 65471, 65487, 65503, 65519, }; // clang-format on } // 0x004BE368 uint16_t fastSquareRoot(uint32_t distance) { uint8_t i = 10; for (; distance >= 4096; --i, distance >>= 2) ; return Data::kFastSquareRootTable[(distance & 0xFFE) >> 1] >> i; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/CMakeLists.txt ```txt set(public_files "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Engine/Input/ShortcutManager.h" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Engine/Types.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Engine/Ui/Point.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Engine/Ui/Rect.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Engine/Ui/Size.hpp" "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Engine/World.hpp" ) set(private_files "${CMAKE_CURRENT_SOURCE_DIR}/src/Engine.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/Input/ShortcutManager.cpp" ) loco_add_library(Engine STATIC PUBLIC_FILES ${public_files} PRIVATE_FILES ${private_files} ) target_link_libraries(Engine PUBLIC Core Diagnostics Utility Interop Math Gfx ) ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/include/OpenLoco/Engine/Types.hpp ```hpp #pragma once #include <cstdint> #include <limits> #include <type_traits> namespace OpenLoco { // To be replaced with std::to_underlying in c++23 template<typename TEnum> constexpr auto enumValue(TEnum enumerator) noexcept { return static_cast<std::underlying_type_t<TEnum>>(enumerator); } using coord_t = int16_t; using tile_coord_t = int16_t; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/include/OpenLoco/Engine/World.hpp ```hpp #pragma once #include "Types.hpp" #include <OpenLoco/Math/Vector.hpp> #include <algorithm> namespace OpenLoco::World { constexpr coord_t kTileSize = 32; constexpr coord_t kMapRows = 384; constexpr coord_t kMapColumns = 384; constexpr coord_t kMapPitch = 512; constexpr coord_t kMapHeight = kMapRows * kTileSize; constexpr coord_t kMapWidth = kMapColumns * kTileSize; constexpr int32_t kMapSize = kMapColumns * kMapRows; constexpr int16_t kMicroZStep = 16; // e.g. SurfaceElement::water is a microZ constexpr int16_t kMicroToSmallZStep = 4; // e.g. for comparisons between water and baseZ constexpr int16_t kSmallZStep = 4; // e.g. TileElement::baseZ is a smallZ using SmallZ = uint8_t; using MicroZ = uint8_t; constexpr coord_t tileFloor(coord_t coord) { return coord & (kTileSize - 1); } constexpr int16_t heightFloor(int16_t height) { return height & ~(kSmallZStep - 1); } static_assert(heightFloor(0x62) == 0x60); struct WorldSpaceTag { }; using Pos2 = Math::Vector::TVector2<coord_t, WorldSpaceTag>; static_assert(std::is_trivially_copyable_v<Pos2>, "Pos2 must be POD"); using Pos3 = Math::Vector::TVector3<coord_t, WorldSpaceTag>; static_assert(std::is_trivially_copyable_v<Pos3>, "Pos2 must be POD"); struct TileSpaceTag { }; using TilePos2 = Math::Vector::TVector2<tile_coord_t, TileSpaceTag>; static_assert(std::is_trivially_copyable_v<TilePos2>, "Pos2 must be POD"); // Until interop is removed this is a requirement. static_assert(sizeof(Pos2) == 4); static_assert(sizeof(Pos3) == 6); static_assert(sizeof(TilePos2) == 4); constexpr bool validCoord(const coord_t coord) { return (coord >= 0) && (coord < kMapWidth); } constexpr bool validTileCoord(const tile_coord_t coord) { return (coord >= 0) && (coord < kMapColumns); } constexpr bool validCoords(const Pos2& coords) { return validCoord(coords.x) && validCoord(coords.y); } constexpr bool validCoords(const TilePos2& coords) { return validTileCoord(coords.x) && validTileCoord(coords.y); } // drawing coordinates validation differs from general valid coordinate validation constexpr bool drawableCoord(const coord_t coord) { return (coord >= World::kTileSize) && (coord < (World::kMapWidth - World::kTileSize - 1)); } constexpr bool drawableTileCoord(const tile_coord_t coord) { return (coord >= 1) && (coord < (kMapColumns - 2)); } constexpr bool drawableCoords(const Pos2& coords) { return drawableCoord(coords.x) && drawableCoord(coords.y); } constexpr bool drawableCoords(const TilePos2& coords) { return drawableTileCoord(coords.x) && drawableTileCoord(coords.y); } constexpr TilePos2 toTileSpace(const Pos2& coords) { return TilePos2{ static_cast<tile_coord_t>(coords.x / kTileSize), static_cast<tile_coord_t>(coords.y / kTileSize) }; } constexpr TilePos2 toTileSpace(const Pos3& coords) { return TilePos2{ static_cast<tile_coord_t>(coords.x / kTileSize), static_cast<tile_coord_t>(coords.y / kTileSize) }; } constexpr Pos2 toWorldSpace(const TilePos2& coords) { return Pos2{ static_cast<coord_t>(coords.x * kTileSize), static_cast<coord_t>(coords.y * kTileSize) }; } constexpr coord_t clampCoord(coord_t coord) { return std::clamp<coord_t>(coord, 0, kMapWidth - 1); } constexpr coord_t clampTileCoord(coord_t coord) { return std::clamp<coord_t>(coord, 0, kMapColumns - 1); } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/include/OpenLoco/Engine/Input/ShortcutManager.h ```h #pragma once #include <cstddef> #include <cstdint> #include <functional> #include <vector> namespace OpenLoco { // TODO: Remove this when Localisation/StringTable/StringManager is moved to the engine. using StringId = uint16_t; } namespace OpenLoco::Input { enum class Shortcut : uint32_t; } namespace OpenLoco::Input::ShortcutManager { using ShortcutAction = std::function<void()>; struct ShortcutEntry { Shortcut id; ShortcutAction action; StringId displayName; const char* configName; const char* defaultBinding; }; using ShortcutMap = std::vector<ShortcutEntry>; void add(Shortcut id, StringId displayName, const ShortcutAction& action, const char* configName, const char* defaultBinding); void remove(Shortcut id); void execute(Shortcut s); StringId getName(Shortcut s); const ShortcutMap& getList(); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/include/OpenLoco/Engine/Ui/Point.hpp ```hpp #pragma once #include <OpenLoco/Math/Vector.hpp> #include <cstdint> namespace OpenLoco::Ui { struct UISpaceTag { }; using Point = Math::Vector::TVector2<int16_t, UISpaceTag>; using Point32 = Math::Vector::TVector2<int32_t, UISpaceTag>; // Until interop is removed this is a requirement (for global vars mainly) static_assert(sizeof(Point) == 4); static_assert(sizeof(Point32) == 8); } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/include/OpenLoco/Engine/Ui/Rect.hpp ```hpp #pragma once #include "Point.hpp" #include "Size.hpp" #include <algorithm> #include <cstddef> namespace OpenLoco::Ui { class Rect { public: Ui::Size size; Ui::Point32 origin; Rect(int16_t x, int16_t y, uint16_t width, uint16_t height) : size(Ui::Size(width, height)) , origin(Ui::Point32(x, y)) { } static Rect fromLTRB(int16_t left, int16_t top, int16_t right, int16_t bottom) { return Rect(left, top, right - left, bottom - top); } bool intersects(const Rect& r2) const { if (origin.x + size.width <= r2.origin.x) { return false; } if (origin.y + size.height <= r2.origin.y) { return false; } if (origin.x >= r2.origin.x + r2.size.width) { return false; } if (origin.y >= r2.origin.y + r2.size.height) { return false; } return true; } Rect intersection(const Rect r2) const { int left = std::max(this->origin.x, r2.origin.x); int top = std::max(this->origin.y, r2.origin.y); int right = std::min(this->origin.x + this->size.width, r2.origin.x + r2.size.width); int bottom = std::min(this->origin.y + this->size.height, r2.origin.y + r2.size.height); return Rect(left, top, right - left, bottom - top); } uint16_t width() const { return this->size.width; } uint16_t height() const { return this->size.height; } int32_t left() const { return this->origin.x; } int32_t right() const { return this->origin.x + this->size.width; } int32_t top() const { return this->origin.y; } int32_t bottom() const { return this->origin.y + this->size.height; } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/include/OpenLoco/Engine/Ui/Size.hpp ```hpp #pragma once #include <cstdint> namespace OpenLoco::Ui { struct Size { uint16_t width = 0; uint16_t height = 0; constexpr Size(const uint16_t _width, const uint16_t _height) : width(_width) , height(_height) { } constexpr Size(const int32_t _width, const int32_t _height) : width(static_cast<uint16_t>(_width)) , height(static_cast<uint16_t>(_height)) { } constexpr Size operator-(const Size& rhs) const { return { static_cast<uint16_t>(width - rhs.width), static_cast<uint16_t>(height - rhs.height) }; } constexpr Size operator+(const Size& rhs) const { return { static_cast<uint16_t>(width + rhs.width), static_cast<uint16_t>(height + rhs.height) }; } }; // TODO: Remove the Size struct and rename this one to Size once interop is gone. struct Size32 { int32_t width = 0; int32_t height = 0; constexpr Size32(const int32_t _width, const int32_t _height) : width(_width) , height(_height) { } }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/src/Engine.cpp ```cpp ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Engine/src/Input/ShortcutManager.cpp ```cpp #include "OpenLoco/Engine/Input/ShortcutManager.h" #include <algorithm> namespace OpenLoco::Input::ShortcutManager { static ShortcutMap _shortcuts; static auto findShortcut(Shortcut id) { auto it = std::lower_bound(std::begin(_shortcuts), std::end(_shortcuts), id, [](const auto& a, const auto& b) { return a.id < b; }); if (it == std::end(_shortcuts)) { return std::end(_shortcuts); } return it; } void add(Shortcut id, StringId displayName, const ShortcutAction& action, const char* configName, const char* defaultBinding) { auto it = findShortcut(id); if (it == std::end(_shortcuts) || it->id != id) { _shortcuts.insert(it, ShortcutEntry{ id, action, displayName, configName, defaultBinding }); } else { it->id = id; it->action = action; it->configName = configName; it->defaultBinding = defaultBinding; } } void remove(Shortcut id) { auto it = findShortcut(id); if (it == std::end(_shortcuts) || it->id != id) { return; } _shortcuts.erase(it); } void execute(Shortcut id) { auto it = findShortcut(id); if (it == std::end(_shortcuts) || it->id != id) { return; } it->action(); } StringId getName(Shortcut id) { auto it = findShortcut(id); if (it == std::end(_shortcuts) || it->id != id) { return 0xFFFF; // TODO: String-id null } return it->displayName; } const ShortcutMap& getList() { return _shortcuts; } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Gfx/CMakeLists.txt ```txt set(public_files "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Gfx/PngImage.h" ) set(private_files "${CMAKE_CURRENT_SOURCE_DIR}/src/PngImage.cpp" ) loco_add_library(Gfx STATIC PUBLIC_FILES ${public_files} PRIVATE_FILES ${private_files} ) target_link_libraries(Gfx PUBLIC Core Diagnostics ${PNG_LIBRARY} ) ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Gfx/include/OpenLoco/Gfx/PngImage.h ```h #pragma once #include <vector> #include <filesystem> namespace OpenLoco::Gfx { struct Colour32 { uint8_t r; uint8_t g; uint8_t b; uint8_t a; }; class PngImage { std::vector<uint8_t> imageData; public: const int width{}; const int height{}; const int channels{}; PngImage() = default; PngImage(int w, int h, int c); static std::unique_ptr<PngImage> loadFromFile(const std::filesystem::path& filePath); Colour32 getPixel(int x, int y); }; } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Gfx/src/PngImage.cpp ```cpp #include "PngImage.h" #include <OpenLoco/Diagnostics/Logging.h> #include <cassert> #include <fstream> #include <png.h> using namespace OpenLoco::Diagnostics; namespace OpenLoco::Gfx { PngImage::PngImage(int w, int h, int c) : width(w) , height(h) , channels(c) { assert(w > 0); assert(h > 0); assert(c > 0); imageData = std::vector<png_byte>(w * h * c); } Colour32 PngImage::getPixel(int x, int y) { const size_t index = (y * width + x) * channels; assert(index + channels < imageData.size()); // NOTE: It always assumes the image is in RGBA format, odd PNG files will cause // to read garbage data. return { imageData[index + 0], imageData[index + 1], imageData[index + 2], imageData[index + 3] }; } static void libpngErrorHandler(png_structp, png_const_charp error_msg) { throw std::runtime_error(error_msg); } static void libpngWarningHandler(png_structp, png_const_charp error_msg) { Logging::warn("{}", error_msg); } std::unique_ptr<PngImage> PngImage::loadFromFile(const std::filesystem::path& filePath) { std::ifstream inFile(filePath, std::ios::binary); png_structp png = png_create_read_struct(PNG_LIBPNG_VER_STRING, nullptr, libpngErrorHandler, libpngWarningHandler); if (!png) { Logging::error("Failed to create PNG read struct"); return nullptr; } png_infop info = png_create_info_struct(png); if (!info) { Logging::error("Failed to create PNG info struct"); png_destroy_read_struct(&png, nullptr, nullptr); return nullptr; } try { png_set_read_fn(png, static_cast<void*>(&inFile), [](png_structp png_ptr, png_bytep data, png_size_t length) { std::istream* inStream = static_cast<std::istream*>(png_get_io_ptr(png_ptr)); inStream->read(reinterpret_cast<char*>(data), length); }); png_read_info(png, info); int width = png_get_image_width(png, info); int height = png_get_image_height(png, info); int channels = png_get_channels(png, info); auto pngImage = std::make_unique<PngImage>(width, height, channels); png_bytep* rowPointers = new png_bytep[height]; for (int y = 0; y < height; y++) { rowPointers[y] = &pngImage->imageData[y * width * channels]; } png_read_image(png, rowPointers); // cleanup image delete[] rowPointers; png_destroy_read_struct(&png, &info, nullptr); inFile.close(); return pngImage; } catch (const std::runtime_error& e) { Logging::error("{}", e.what()); png_destroy_read_struct(&png, nullptr, nullptr); return nullptr; } } } ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/CMakeLists.txt ```txt # Resource files are for Windows only for now # Eventually there will be Mac resources as well here. if (WIN32) enable_language(RC) set(public_files "${CMAKE_CURRENT_SOURCE_DIR}/include/OpenLoco/Resources/Resource.h") set(private_files "${CMAKE_CURRENT_SOURCE_DIR}/src/OpenLoco.rc" "${CMAKE_CURRENT_SOURCE_DIR}/src/logo/icon.ico") loco_add_library(Resources OBJECT PUBLIC_FILES ${public_files} PRIVATE_FILES ${private_files}) endif() ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/include/OpenLoco/Resources/Resource.h ```h //{{NO_DEPENDENCIES}} // Microsoft Visual C++ generated include file. // Used by OpenLoco.rc // #define IDI_ICON 101 // Next default values for new objects // #ifdef APSTUDIO_INVOKED #ifndef APSTUDIO_READONLY_SYMBOLS #define _APS_NEXT_RESOURCE_VALUE 102 #define _APS_NEXT_COMMAND_VALUE 40001 #define _APS_NEXT_CONTROL_VALUE 1001 #define _APS_NEXT_SYMED_VALUE 101 #endif #endif ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/OpenLoco.rc ```rc // Microsoft Visual C++ generated resource script. // #include "Resource.h" #define APSTUDIO_READONLY_SYMBOLS ///////////////////////////////////////////////////////////////////////////// // // Generated from the TEXTINCLUDE 2 resource. // #include "winres.h" ///////////////////////////////////////////////////////////////////////////// #undef APSTUDIO_READONLY_SYMBOLS ///////////////////////////////////////////////////////////////////////////// // English (United Kingdom) resources #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG) LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_UK #ifdef APSTUDIO_INVOKED ///////////////////////////////////////////////////////////////////////////// // // TEXTINCLUDE // 1 TEXTINCLUDE BEGIN "Resource.h\0" END 2 TEXTINCLUDE BEGIN "#include ""winres.h""\r\n" "\0" END 3 TEXTINCLUDE BEGIN "\r\n" "\0" END #endif // APSTUDIO_INVOKED ///////////////////////////////////////////////////////////////////////////// // // Icon // // Icon with lowest ID value placed first to ensure application icon // remains consistent on all systems. IDI_ICON ICON "logo/icon.ico" #endif // English (United Kingdom) resources ///////////////////////////////////////////////////////////////////////////// #ifndef APSTUDIO_INVOKED ///////////////////////////////////////////////////////////////////////////// // // Generated from the TEXTINCLUDE 3 resource. // ///////////////////////////////////////////////////////////////////////////// #endif // not APSTUDIO_INVOKED ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon.ico ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_nocog.svg ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_nosteam.svg ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_steam.svg ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x1024.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x128.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x16.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x2048.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x256.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x32.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x512.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x64.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/icon_x8.png ``` Content skipped (binary or ignored type). ``` --- https://github.com/OpenLoco/OpenLoco/blob/main/src/Resources/src/logo/makeico.csx ```csx #r "System.Drawing.dll" using System.Drawing; using System.Drawing.Imaging; if (Args.Count == 0) { Console.WriteLine("Usage: makeico <directory>"); return; } var inputDirectory = Args[0]; var outputPath = Path.Combine(inputDirectory, "icon.ico"); var imageSizes = new int[] { 256, 128, 96, 64, 48, 40, 32, 24, 16, 8, 4 }; var foundImages = imageSizes .Select(size => (size, Path.Combine(inputDirectory, "icon_x" + size + ".png"))) .Where(x => File.Exists(x.Item2)) .ToArray(); using (FileStream fs = new FileStream(outputPath, FileMode.Create)) { var bw = new BinaryWriter(fs); bw.Write((short)0); bw.Write((short)1); bw.Write((short)foundImages.Length); var dataStartOffset = 6 + (foundImages.Length * 16); using (var dataStream = new MemoryStream()) { foreach (var (size, path) in foundImages) { bw.Write((byte)(size == 256 ? 0 : size)); bw.Write((byte)(size == 256 ? 0 : size)); bw.Write((byte)0); bw.Write((byte)0); bw.Write((short)0); bw.Write((short)32); int dataOffset = (int)dataStream.Position; int dataLength; Console.WriteLine("Importing {0}", Path.GetFileName(path)); using (var image = Image.FromFile(path)) { image.Save(dataStream, ImageFormat.Png); } dataLength = (int)dataStream.Position - dataOffset; dataOffset += dataStartOffset; bw.Write(dataLength); bw.Write(dataOffset); } bw.Write(dataStream.ToArray()); } } ``` ---